<tool id="bowtie_wrapper" name="Map with Bowtie for Illumina" version="1.1.2">
  <requirements><requirement type='package'>bowtie</requirement></requirements>
  <description></description>
  <parallelism method="basic"></parallelism>
  <command interpreter="python">
    bowtie_wrapper.py
      ## Hackish setting of number of threads
      --threads="4"
      ## Outputs
      --output=$output
      #if str( $singlePaired.sPaired ) == "single"
        #if $output_unmapped_reads_l
          --output_unmapped_reads=$output_unmapped_reads_l
        #end if
        #if $output_suppressed_reads_l
          --output_suppressed_reads=$output_suppressed_reads_l
        #end if
        --galaxy_input_format="${singlePaired.sInput1.ext}"
      #else
        #if $output_unmapped_reads_l and $output_unmapped_reads_r
          --output_unmapped_reads_l=$output_unmapped_reads_l
          --output_unmapped_reads_r=$output_unmapped_reads_r
        #end if
        #if $output_suppressed_reads_l and $output_suppressed_reads_l
          --output_suppressed_reads_l=$output_suppressed_reads_l
          --output_suppressed_reads_r=$output_suppressed_reads_r
        #end if
        --galaxy_input_format="${singlePaired.pInput1.ext}"
      #end if
      ## Inputs
      --dataType="solexa" ##this indicates that nucleotide base space is used in the wrapper
      --suppressHeader=$suppressHeader
      --genomeSource=$refGenomeSource.genomeSource
      #if $refGenomeSource.genomeSource == "history":
        ##index already exists
        #if $refGenomeSource.ownFile.extension.startswith( 'bowtie_' ):
          ##user previously built
          --ref="${refGenomeSource.ownFile.extra_files_path}/${refGenomeSource.ownFile.metadata.base_name}"
          --do_not_build_index
        #else:
          ##build index on the fly
          --ref=$refGenomeSource.ownFile
          --indexSettings=$refGenomeSource.indexParams.indexSettings
          #if $refGenomeSource.indexParams.indexSettings == "indexFull":
            --iautoB=$refGenomeSource.indexParams.autoBehavior.autoB
            #if $refGenomeSource.indexParams.autoBehavior.autoB == "set":
              --ipacked=$refGenomeSource.indexParams.autoBehavior.packed
              --ibmax=$refGenomeSource.indexParams.autoBehavior.bmax
              --ibmaxdivn=$refGenomeSource.indexParams.autoBehavior.bmaxdivn
              --idcv=$refGenomeSource.indexParams.autoBehavior.dcv
            #end if
            --inodc=$refGenomeSource.indexParams.nodc
            --inoref=$refGenomeSource.indexParams.noref
            --ioffrate=$refGenomeSource.indexParams.offrate
            --iftab=$refGenomeSource.indexParams.ftab
            --intoa=$refGenomeSource.indexParams.ntoa
            --iendian=$refGenomeSource.indexParams.endian
            --iseed=$refGenomeSource.indexParams.seed
            --icutoff=$refGenomeSource.indexParams.cutoff 
          #end if
        #end if
      #else
        ##use pre-built index
        --ref="${refGenomeSource.index.fields.path}"
      #end if
      --paired=$singlePaired.sPaired
      #if $singlePaired.sPaired == "single":
        --input1=$singlePaired.sInput1
        --params=$singlePaired.sParams.sSettingsType
        #if $singlePaired.sParams.sSettingsType == "full":
          --skip=$singlePaired.sParams.sSkip
          --alignLimit=$singlePaired.sParams.sAlignLimit
          --trimH=$singlePaired.sParams.sTrimH
          --trimL=$singlePaired.sParams.sTrimL
          --mismatchSeed=$singlePaired.sParams.sMismatchSeed
          --mismatchQual=$singlePaired.sParams.sMismatchQual
          --seedLen=$singlePaired.sParams.sSeedLen
          --rounding=$singlePaired.sParams.sRounding
          --maqSoapAlign=$singlePaired.sParams.sMaqSoapAlign
          --tryHard=$singlePaired.sParams.sTryHard
          --valAlign=$singlePaired.sParams.sValAlign
          --allValAligns=$singlePaired.sParams.sAllValAligns
          --suppressAlign=$singlePaired.sParams.sSuppressAlign
          --best=$singlePaired.sParams.sBestOption.sBest
          #if $singlePaired.sParams.sBestOption.sBest == "doBest":
            --maxBacktracks=$singlePaired.sParams.sBestOption.sdMaxBacktracks
            --strata=$singlePaired.sParams.sBestOption.sdStrata
          #else:
            --maxBacktracks=$singlePaired.sParams.sBestOption.snMaxBacktracks
          #end if
          --offrate=$singlePaired.sParams.sOffrate
          --seed=$singlePaired.sParams.sSeed
        #end if
      #else:
        --input1=$singlePaired.pInput1
        --input2=$singlePaired.pInput2
        --maxInsert=$singlePaired.pMaxInsert
        --mateOrient=$singlePaired.pMateOrient
        --params=$singlePaired.pParams.pSettingsType
        #if $singlePaired.pParams.pSettingsType == "full":
          --skip=$singlePaired.pParams.pSkip
          --alignLimit=$singlePaired.pParams.pAlignLimit
          --trimH=$singlePaired.pParams.pTrimH
          --trimL=$singlePaired.pParams.pTrimL
          --mismatchSeed=$singlePaired.pParams.pMismatchSeed
          --mismatchQual=$singlePaired.pParams.pMismatchQual
          --seedLen=$singlePaired.pParams.pSeedLen
          --rounding=$singlePaired.pParams.pRounding
          --maqSoapAlign=$singlePaired.pParams.pMaqSoapAlign
          --minInsert=$singlePaired.pParams.pMinInsert
          --maxAlignAttempt=$singlePaired.pParams.pMaxAlignAttempt
          --forwardAlign=$singlePaired.pParams.pForwardAlign
          --reverseAlign=$singlePaired.pParams.pReverseAlign
          --tryHard=$singlePaired.pParams.pTryHard
          --valAlign=$singlePaired.pParams.pValAlign
          --allValAligns=$singlePaired.pParams.pAllValAligns
          --suppressAlign=$singlePaired.pParams.pSuppressAlign
          --best=$singlePaired.pParams.pBestOption.pBest
          #if $singlePaired.pParams.pBestOption.pBest == "doBest":
            --maxBacktracks=$singlePaired.pParams.pBestOption.pdMaxBacktracks
            --strata=$singlePaired.pParams.pBestOption.pdStrata
          #else:
            --maxBacktracks=$singlePaired.pParams.pBestOption.pnMaxBacktracks
          #end if
          --offrate=$singlePaired.pParams.pOffrate
          --seed=$singlePaired.pParams.pSeed
        #end if
      #end if
  </command>
  <inputs>
    <conditional name="refGenomeSource">
      <param name="genomeSource" type="select" label="Will you select a reference genome from your history or use a built-in index?" help="Built-ins were indexed using default options">
        <option value="indexed">Use a built-in index</option>
        <option value="history">Use one from the history</option>
      </param>
      <when value="indexed">
        <param name="index" type="select" label="Select a reference genome" help="if your genome of interest is not listed - contact Galaxy team">
          <options from_data_table="bowtie_indexes">
            <filter type="sort_by" column="2" />
            <validator type="no_options" message="No indexes are available" />
          </options>
        </param>
      </when>
      <when value="history">
        <param name="ownFile" type="data" format="bowtie_base_index,fasta" metadata_name="dbkey" label="Select the reference genome" />
        <conditional name="indexParams">
          <param name="indexSettings" type="select" label="Choose whether to use Default options for building indices or to Set your own" help="These settings are ignored when using a prebuilt index">
            <option value="indexPreSet">Default</option>
            <option value="indexFull">Set your own</option>
          </param> 
          <when value="indexPreSet" />
          <when value="indexFull">
            <conditional name="autoBehavior">
              <param name="autoB" type="select" label="Choose to use automatic or specified behavior for some parameters (-a)" help="Allows you to set --packed, --bmax, --bmaxdivn, and --dcv">
                <option value="auto">Automatic behavior</option>
                <option value="set">Set values (sets --noauto and allows others to be set)</option>
              </param>
              <when value="auto" />
              <when value="set">
                <param name="packed" type="select" label="Whether or not to use a packed representation for DNA strings (--packed)">
                  <option value="unpacked">Use regular representation</option>
                  <option value="packed">Use packed representation</option>
                </param>
                <param name="bmax" type="integer" value="-1" label="Maximum number of suffixes allowed in a block (--bmax)" help="-1 for not specified. Must be at least 1" />
                <param name="bmaxdivn" type="integer" value="4" label="Maximum number of suffixes allowed in a block as a fraction of the length of the reference (--bmaxdivn)" />
                <param name="dcv" type="integer" value="1024" label="The period for the difference-cover sample (--dcv)" />
              </when>
            </conditional>
            <param name="nodc" type="select" label="Whether or not to disable the use of the difference-cover sample (--nodc)" help="Suffix sorting becomes quadratic-time in the worst case (with a very repetitive reference)">
              <option value="dc">Use difference-cover sample</option>
              <option value="nodc">Disable difference-cover sample</option>
            </param>
            <param name="noref" type="select" label="Whether or not to build the part of the reference index used only in paired-end alignment (-r)">
              <option value="ref">Build all index files</option>
              <option value="noref">Do not build paired-end alignment index files</option>
            </param>
            <param name="offrate" type="integer" value="5" label="How many rows get marked during annotation of some or all of the Burrows-Wheeler rows (-o)" />
            <param name="ftab" type="integer" value="10" label="The size of the lookup table used to calculate an initial Burrows-Wheeler range with respect to the first n characters of the query (-t)" help="ftab is 4^(n+1) bytes" />
            <param name="ntoa" type="select" label="Whether or not to convert Ns in the reference sequence to As (--ntoa)">
              <option value="no">Do not convert Ns</option>
              <option value="yes">Convert Ns to As</option>
            </param>
            <param name="endian" type="select" label="Endianness to use when serializing integers to the index file (--big/--little)" help="Little is most appropriate for Intel- and AMD-based architecture">
              <option value="little">Little</option>
              <option value="big">Big</option>
            </param> 
            <param name="seed" type="integer" value="-1" label="Seed for the pseudorandom number generator (--seed)" help="Use -1 to use default" />
            <param name="cutoff" type="integer" value="-1" label="Number of first bases of the reference sequence to index (--cutoff)" help="Use -1 to use default" />
          </when>  <!-- indexFull -->
        </conditional>  <!-- indexParams -->
      </when>  <!-- history -->
    </conditional>  <!-- refGenomeSource -->
    <conditional name="singlePaired">
      <param name="sPaired" type="select" label="Is this library mate-paired?">
        <option value="single">Single-end</option>
        <option value="paired">Paired-end</option>
      </param>
      <when value="single">
        <param name="sInput1" type="data" format="fastqsanger,fastqillumina,fastqsolexa" label="FASTQ file" help="Must have ASCII encoded quality scores"/>
        <conditional name="sParams">
          <param name="sSettingsType" type="select" label="Bowtie settings to use" help="For most mapping needs use Commonly used settings. If you want full control use Full parameter list">
            <option value="preSet">Commonly used</option>
            <option value="full">Full parameter list</option>
            </param>
          <when value="preSet" />
          <when value="full">
            <param name="sSkip" type="integer" value="0" label="Skip the first n reads (-s)" />  
            <param name="sAlignLimit" type="integer" value="-1" label="Only align the first n reads (-u)" help="-1 for off" />  
            <param name="sTrimH" type="integer" value="0" label="Trim n bases from high-quality (left) end of each read before alignment (-5)" />
            <param name="sTrimL" type="integer" value="0" label="Trim n bases from low-quality (right) end of each read before alignment (-3)" />
            <param name="sMismatchSeed" type="integer" value="2" label="Maximum number of mismatches permitted in the seed (-n)" help="May be 0, 1, 2, or 3" />
            <param name="sMismatchQual" type="integer" value="70" label="Maximum permitted total of quality values at mismatched read positions (-e)" />
            <param name="sSeedLen" type="integer" value="28" label="Seed length (-l)" help="Minimum value is 5" />
            <param name="sRounding" type="select" label="Whether or not to round to the nearest 10 and saturating at 30 (--nomaqround)">
              <option value="round">Round to nearest 10</option>
              <option value="noRound">Do not round to nearest 10</option>
            </param>
            <param name="sMaqSoapAlign" type="integer" value="-1" label="Number of mismatches for SOAP-like alignment policy (-v)" help="-1 for default MAQ-like alignment policy" />
            <param name="sTryHard" type="select" label="Whether or not to try as hard as possible to find valid alignments when they exist (-y)" help="Tryhard mode is much slower than regular mode">
              <option value="noTryHard">Do not try hard</option>
              <option value="doTryHard">Try hard</option>
            </param>
            <param name="sValAlign" type="integer" value="1" label="Report up to n valid alignments per read (-k)" />
            <param name="sAllValAligns" type="select" label="Whether or not to report all valid alignments per read (-a)">
              <option value="noAllValAligns">Do not report all valid alignments</option>
              <option value="doAllValAligns">Report all valid alignments</option>
            </param>
            <param name="sSuppressAlign" type="integer" value="-1" label="Suppress all alignments for a read if more than n reportable alignments exist (-m)" help="-1 for no limit" />
            <param name="sMaxFile" type="boolean" truevalue="true" falsevalue="false" checked="False" label="Write all reads with a number of valid alignments exceeding the limit set with the -m option to a file (--max)" />
            <param name="sUnmappedFile" type="boolean" truevalue="true" falsevalue="false" checked="False" label="Write all reads that could not be aligned to a file (--un)" />
            <conditional name="sBestOption">
              <param name="sBest" type="select" label="Whether or not to make Bowtie guarantee that reported singleton alignments are 'best' in terms of stratum and in terms of the quality values at the mismatched positions (--best)" help="Removes all strand bias. Only affects which alignments are reported by Bowtie. Runs slower with best option">
                <option value="noBest">Do not use best</option>
                <option value="doBest">Use best</option>
              </param>
              <when value="noBest">
                <param name="snMaxBacktracks" type="integer" value="125" label="Maximum number of backtracks permitted when aligning a read (--maxbts)" />
              </when>
              <when value="doBest">
                <param name="sdMaxBacktracks" type="integer" value="800" label="Maximum number of backtracks permitted when aligning a read (--maxbts)" />
                <param name="sdStrata" type="select" label="Whether or not to report only those alignments that fall in the best stratum if many valid alignments exist and are reportable (--strata)">
                  <option value="noStrata">Do not use strata option</option>
                  <option value="doStrata">Use strata option</option>
                </param>
              </when>
            </conditional> <!-- bestOption -->
            <param name="sOffrate" type="integer" value="-1" label="Override the offrate of the index to n (-o)" help="-1 for default" />
            <param name="sSeed" type="integer" value="-1" label="Seed for pseudo-random number generator (--seed)" help="-1 for default" />
          </when> <!-- full -->
        </conditional> <!-- sParams -->
      </when> <!-- single -->
      <when value="paired">
        <param name="pInput1" type="data" format="fastqsanger,fastqillumina,fastqsolexa" label="Forward FASTQ file" help="Must have ASCII encoded quality scores"/>
        <param name="pInput2" type="data" format="fastqsanger,fastqillumina,fastqsolexa" label="Reverse FASTQ file" help="File format must match the Forward FASTQ file">
            <options options_filter_attribute="ext" from_parameter="tool.app.datatypes_registry.datatypes_by_extension" transform_lines="obj.keys()">>
               <column name="name" index="0"/>
               <column name="value" index="0"/>
               <filter type="param_value" ref="pInput1" ref_attribute="ext" column="0"/> 
           </options>
        </param>
        <param name="pMaxInsert" type="integer" value="1000" label="Maximum insert size for valid paired-end alignments (-X)" />
        <param name="pMateOrient" type="select" label="The upstream/downstream mate orientation for valid paired-end alignment against the forward reference strand (--fr/--rf/--ff)">
          <option value="fr">FR (for Illumina)</option>
          <option value="rf">RF</option>
          <option value="ff">FF (for SOLiD)</option>
        </param>
        <conditional name="pParams">
          <param name="pSettingsType" type="select" label="Bowtie settings to use" help="For most mapping needs use Commonly used settings. If you want full control use Full parameter list">
            <option value="preSet">Commonly used</option>
            <option value="full">Full parameter list</option>
          </param>
          <when value="preSet" />
          <when value="full">
            <param name="pSkip" type="integer" value="0" label="Skip the first n pairs (-s)" />  
            <param name="pAlignLimit" type="integer" value="-1" label="Only align the first n pairs (-u)" help="-1 for off" />  
            <param name="pTrimH" type="integer" value="0" label="Trim n bases from high-quality (left) end of each read before alignment (-5)" />
            <param name="pTrimL" type="integer" value="0" label="Trim n bases from low-quality (right) end of each read before alignment (-3)" />
            <param name="pMismatchSeed" type="integer" value="2" label="Maximum number of mismatches permitted in the seed (-n)" help="May be 0, 1, 2, or 3" />
            <param name="pMismatchQual" type="integer" value="70" label="Maximum permitted total of quality values at mismatched read positions (-e)" />
            <param name="pSeedLen" type="integer" value="28" label="Seed length (-l)" help="Minimum value is 5" />
            <param name="pRounding" type="select" label="Whether or not to round to the nearest 10 and saturating at 30 (--nomaqround)">
              <option value="round">Round to nearest 10</option>
              <option value="noRound">Do not round to nearest 10</option>
            </param>
            <param name="pMaqSoapAlign" type="integer" value="-1" label="Number of mismatches for SOAP-like alignment policy (-v)" help="-1 for default MAQ-like alignment policy" />
            <param name="pMinInsert" type="integer" value="0" label="Minimum insert size for valid paired-end alignments (-I)" />
            <param name="pMaxAlignAttempt" type="integer" value="100" label="Maximum number of attempts Bowtie will make to match an alignment for one mate with an alignment for the opposite mate (--pairtries)" />
            <param name="pForwardAlign" type="select" label="Choose whether or not to attempt to align the forward reference strand (--nofw)">
              <option value="forward">Align against the forward reference strand</option>
              <option value="noForward">Do not align against the forward reference strand</option>
            </param>
            <param name="pReverseAlign" type="select" label="Choose whether or not to align against the reverse-complement reference strand (--norc)">
              <option value="reverse">Align against the reverse-complement reference strand</option>
              <option value="noReverse">Do not align against the reverse-complement reference strand</option>
            </param>
            <param name="pTryHard" type="select" label="Whether or not to try as hard as possible to find valid alignments when they exist (-y)" help="Tryhard mode is much slower than regular mode">
              <option value="noTryHard">Do not try hard</option>
              <option value="doTryHard">Try hard</option>
            </param>
            <param name="pValAlign" type="integer" value="1" label="Report up to n valid arguments per pair (-k)" />
            <param name="pAllValAligns" type="select" label="Whether or not to report all valid alignments per pair (-a)">
              <option value="noAllValAligns">Do not report all valid alignments</option>
              <option value="doAllValAligns">Report all valid alignments</option>
            </param>
            <param name="pSuppressAlign" type="integer" value="-1" label="Suppress all alignments for a pair if more than n reportable alignments exist (-m)" help="-1 for no limit" />
            <param name="pMaxFile" type="boolean" truevalue="true" falsevalue="false" checked="False" label="Write all reads with a number of valid alignments exceeding the limit set with the -m option to a file (--max)" />
            <param name="pUnmappedFile" type="boolean" truevalue="true" falsevalue="false" checked="False" label="Write all reads that could not be aligned to a file (--un)" />
            <conditional name="pBestOption">
              <param name="pBest" type="select" label="Whether or not to make Bowtie guarantee that reported singleton alignments are 'best' in terms of stratum and in terms of the quality values at the mismatched positions (--best)" help="Removes all strand bias. Only affects which alignments are reported by Bowtie. Runs slower with best option">
                <option value="noBest">Do not use best</option>
                <option value="doBest">Use best</option>
              </param>
              <when value="noBest">
                <param name="pnMaxBacktracks" type="integer" value="125" label="Maximum number of backtracks permitted when aligning a read (--maxbts)" />
              </when>
              <when value="doBest">
                <param name="pdMaxBacktracks" type="integer" value="800" label="Maximum number of backtracks permitted when aligning a read (--maxbts)" />
                <param name="pdStrata" type="select" label="Whether or not to report only those alignments that fall in the best stratum if many valid alignments exist and are reportable (--strata)">
                  <option value="noStrata">Do not use strata option</option>
                  <option value="doStrata">Use strata option</option>
                </param>
              </when>
            </conditional>
            <param name="pOffrate" type="integer" value="-1" label="Override the offrate of the index to n (-o)" help="-1 for default" />
            <param name="pSeed" type="integer" value="-1" label="Seed for pseudo-random number generator (--seed)" help="-1 for default" />
          </when> <!-- full -->
        </conditional> <!-- pParams -->
      </when> <!-- paired -->
    </conditional> <!-- singlePaired -->
    <param name="suppressHeader" type="boolean" truevalue="true" falsevalue="false" checked="False" label="Suppress the header in the output SAM file" help="Bowtie produces SAM with several lines of header information by default" />
  </inputs>
  <outputs>
    <data format="sam" name="output" label="${tool.name} on ${on_string}: mapped reads">
      <actions>
        <conditional name="refGenomeSource.genomeSource">
          <when value="indexed">
            <action type="metadata" name="dbkey">
              <option type="from_data_table" name="bowtie_indexes" column="1" offset="0">
                <filter type="param_value" column="0" value="#" compare="startswith" keep="False"/>
                <filter type="param_value" ref="refGenomeSource.index" column="0"/>
              </option>
            </action>
          </when>
          <when value="history">
            <action type="metadata" name="dbkey">
              <option type="from_param" name="refGenomeSource.ownFile" param_attribute="dbkey" />
            </action>
          </when>
        </conditional>
      </actions>
    </data>
    <data format="fastq" name="output_suppressed_reads_l" label="${tool.name} on ${on_string}: suppressed reads (L)">
      <filter>((
          singlePaired['sPaired'] == "single" and
          singlePaired['sParams']['sSettingsType'] == "full" and
          singlePaired['sParams']['sMaxFile'] is True
        ) or (
          singlePaired['sPaired'] == "paired" and
          singlePaired['pParams']['pSettingsType'] == "full" and
          singlePaired['pParams']['pMaxFile'] is True
        ))
      </filter>
      <actions>
        <conditional name="singlePaired.sPaired">
          <when value="single">
            <action type="format">
              <option type="from_param" name="singlePaired.sInput1" param_attribute="ext" />
            </action>
          </when>
          <when value="paired">
            <action type="format">
              <option type="from_param" name="singlePaired.pInput1" param_attribute="ext" />
            </action>
          </when>
        </conditional>
      </actions>
    </data>
    <data format="fastq" name="output_suppressed_reads_r" label="${tool.name} on ${on_string}: suppressed reads (R)">
      <filter>singlePaired['sPaired'] == "paired"</filter>
      <filter>singlePaired['pParams']['pSettingsType'] == "full"</filter>
      <filter>singlePaired['pParams']['pMaxFile'] is True</filter>
      <actions>
        <conditional name="singlePaired.sPaired">
          <when value="single">
            <action type="format">
              <option type="from_param" name="singlePaired.sInput1" param_attribute="ext" />
            </action>
          </when>
          <when value="paired">
            <action type="format">
              <option type="from_param" name="singlePaired.pInput1" param_attribute="ext" />
            </action>
          </when>
        </conditional>
      </actions>
    </data>
    <data format="fastq" name="output_unmapped_reads_l" label="${tool.name} on ${on_string}: unmapped reads (L)">
      <filter>
        ((
          singlePaired['sPaired'] == "single" and
          singlePaired['sParams']['sSettingsType'] == "full" and
          singlePaired['sParams']['sUnmappedFile'] is True
        ) or (
          singlePaired['sPaired'] == "paired" and
          singlePaired['pParams']['pSettingsType'] == "full" and
          singlePaired['pParams']['pUnmappedFile'] is True
        ))
      </filter>
      <actions>
        <conditional name="singlePaired.sPaired">
          <when value="single">
            <action type="format">
              <option type="from_param" name="singlePaired.sInput1" param_attribute="ext" />
            </action>
          </when>
          <when value="paired">
            <action type="format">
              <option type="from_param" name="singlePaired.pInput1" param_attribute="ext" />
            </action>
          </when>
        </conditional>
      </actions>
    </data>
    <data format="fastq" name="output_unmapped_reads_r" label="${tool.name} on ${on_string}: unmapped reads (R)">
      <filter>singlePaired['sPaired'] == "paired"</filter>
      <filter>singlePaired['pParams']['pSettingsType'] == "full"</filter>
      <filter>singlePaired['pParams']['pUnmappedFile'] is True</filter>
      <actions>
        <conditional name="singlePaired.sPaired">
          <when value="single">
            <action type="format">
              <option type="from_param" name="singlePaired.sInput1" param_attribute="ext" />
            </action>
          </when>
          <when value="paired">
            <action type="format">
              <option type="from_param" name="singlePaired.pInput1" param_attribute="ext" />
            </action>
          </when>
        </conditional>
      </actions>
    </data>
  </outputs>
  <tests>
    <test>
      <!--
      Bowtie command:
      bowtie -q -p 4 -S +sam-nohead chrM_base test-data/bowtie_in2.fastqsanger > bowtie_out6_u.sam
      sort bowtie_out6_u.sam > bowtie_out6.sam
      -p is the number of threads, which is hardcoded above. You need to replace the + with 2 dashes. 
      chrM_base needs to be the base location/name of the index files.
      -->
      <param name="genomeSource" value="indexed" />
      <!-- this is the backwards-compatible "unique value" for this index, not an actual path -->
      <param name="index" value="equCab2chrM" />
      <param name="sPaired" value="single" />
      <param name="sInput1" ftype="fastqsanger" value="bowtie_in2.fastqsanger" />
      <param name="sSettingsType" value="preSet" />
      <param name="suppressHeader" value="true" />
      <output name="output" ftype="sam" file="bowtie_out6.sam" sort="True" />
    </test>
    <test>
      <!--
      Bowtie command:
      bowtie-build -f test-data/phiX.fasta phiX_base
      bowtie -q -X 1000 +ff -p 4 -S +sam-nohead -n 2 -e 70 -l 28 +pairtries 100 +maxbts 800 +best +un bowtie_out8_u.fastq phiX_base -1 test-data/bowtie_in5.fastqsanger -2 test-data/bowtie_in6.fastqsanger > bowtie_out7_u.sam
      sort bowtie_out7_u.sam > bowtie_out7.sam
      sort bowtie_out8_u_1.sam > bowtie_out8_1.sam
      sort bowtie_out8_u_2.sam > bowtie_out8_2.sam
      Then also need to modify bowtie_out8_1.sam and bowtie_out8_2.sam so that all @ lines come before sequence lines.
      -p is the number of threads, hardcoded above. You need to replace the + with 2 dashes.
      The two unmapped output files will be named bowtie_out8_1.fastq and bowtie_out8_2.fastq.
      chrM_base is the index files' location/base name. 
      -->
      <param name="genomeSource" value="history" />
      <param name="ownFile" value="phiX.fasta" />
      <param name="indexSettings" value="indexPreSet" />
      <param name="sPaired" value="paired" />
      <param name="pInput1" ftype="fastqsanger" value="bowtie_in5.fastqsanger" />
      <param name="pInput2" ftype="fastqsanger" value="bowtie_in6.fastqsanger" />
      <param name="pMaxInsert" value="1000" />
      <param name="pMateOrient" value="ff" />
      <param name="pSettingsType" value="full" />
      <param name="pSkip" value="0" />
      <param name="pAlignLimit" value="-1" />
      <param name="pTrimH" value="0" />
      <param name="pTrimL" value="0" />
      <param name="pMismatchSeed" value="2" />
      <param name="pMismatchQual" value="70" />
      <param name="pSeedLen" value="28" />
      <param name="pRounding" value="round" />
      <param name="pMaqSoapAlign" value="-1" />
      <param name="pMinInsert" value="0" />
      <param name="pMaxAlignAttempt" value="100" />
      <param name="pForwardAlign" value="forward" />
      <param name="pReverseAlign" value="reverse" />
      <param name="pTryHard" value="noTryHard" />
      <param name="pValAlign" value="1" />
      <param name="pAllValAligns" value="noAllValAligns" />
      <param name="pSuppressAlign" value="-1" />
      <param name="pUnmappedFile" value="true" />
      <param name="pMaxFile" value="false" />
      <param name="pBest" value="doBest" />
      <param name="pdMaxBacktracks" value="800" />
      <param name="pdStrata" value="noStrata" />
      <param name="pOffrate" value="-1" />
      <param name="pSeed" value="-1" />
      <param name="suppressHeader" value="true" />
      <output name="output" ftype="sam" file="bowtie_out7.sam" sort="True" />
      <output name="output_unmapped_reads_l" ftype="fastqsanger" file="bowtie_out8_1.fastq" sort="True" />
      <output name="output_unmapped_reads_r" ftype="fastqsanger" file="bowtie_out8_2.fastq" sort="True" />
    </test>
    <!-- start testing of non-sanger variant fastq reads -->
    <test>
      <param name="genomeSource" value="history" />
      <param name="ownFile" value="phiX.fasta" />
      <param name="indexSettings" value="indexPreSet" />
      <param name="sPaired" value="paired" />
      <param name="pInput1" ftype="fastqillumina" value="bowtie_in5.fastqillumina" />
      <param name="pInput2" ftype="fastqillumina" value="bowtie_in6.fastqillumina" />
      <param name="pMaxInsert" value="1000" />
      <param name="pMateOrient" value="ff" />
      <param name="pSettingsType" value="full" />
      <param name="pSkip" value="0" />
      <param name="pAlignLimit" value="-1" />
      <param name="pTrimH" value="0" />
      <param name="pTrimL" value="0" />
      <param name="pMismatchSeed" value="2" />
      <param name="pMismatchQual" value="70" />
      <param name="pSeedLen" value="28" />
      <param name="pRounding" value="round" />
      <param name="pMaqSoapAlign" value="-1" />
      <param name="pMinInsert" value="0" />
      <param name="pMaxAlignAttempt" value="100" />
      <param name="pForwardAlign" value="forward" />
      <param name="pReverseAlign" value="reverse" />
      <param name="pTryHard" value="noTryHard" />
      <param name="pValAlign" value="1" />
      <param name="pAllValAligns" value="noAllValAligns" />
      <param name="pSuppressAlign" value="-1" />
      <param name="pUnmappedFile" value="true" />
      <param name="pMaxFile" value="false" />
      <param name="pBest" value="doBest" />
      <param name="pdMaxBacktracks" value="800" />
      <param name="pdStrata" value="noStrata" />
      <param name="pOffrate" value="-1" />
      <param name="pSeed" value="-1" />
      <param name="suppressHeader" value="true" />
      <output name="output" ftype="sam" file="bowtie_out7.sam" sort="True" />
      <output name="output_unmapped_reads_l" ftype="fastqillumna" file="bowtie_out8_1.fastqillumina.sorted" sort="True" />
      <output name="output_unmapped_reads_r" ftype="fastqillumna" file="bowtie_out8_2.fastqillumina.sorted" sort="True" />
    </test>
    <test>
      <param name="genomeSource" value="history" />
      <param name="ownFile" value="phiX.fasta" />
      <param name="indexSettings" value="indexPreSet" />
      <param name="sPaired" value="paired" />
      <param name="pInput1" ftype="fastqsolexa" value="bowtie_in5.fastqsolexa" />
      <param name="pInput2" ftype="fastqsolexa" value="bowtie_in6.fastqsolexa" />
      <param name="pMaxInsert" value="1000" />
      <param name="pMateOrient" value="ff" />
      <param name="pSettingsType" value="full" />
      <param name="pSkip" value="0" />
      <param name="pAlignLimit" value="-1" />
      <param name="pTrimH" value="0" />
      <param name="pTrimL" value="0" />
      <param name="pMismatchSeed" value="2" />
      <param name="pMismatchQual" value="70" />
      <param name="pSeedLen" value="28" />
      <param name="pRounding" value="round" />
      <param name="pMaqSoapAlign" value="-1" />
      <param name="pMinInsert" value="0" />
      <param name="pMaxAlignAttempt" value="100" />
      <param name="pForwardAlign" value="forward" />
      <param name="pReverseAlign" value="reverse" />
      <param name="pTryHard" value="noTryHard" />
      <param name="pValAlign" value="1" />
      <param name="pAllValAligns" value="noAllValAligns" />
      <param name="pSuppressAlign" value="-1" />
      <param name="pUnmappedFile" value="true" />
      <param name="pMaxFile" value="false" />
      <param name="pBest" value="doBest" />
      <param name="pdMaxBacktracks" value="800" />
      <param name="pdStrata" value="noStrata" />
      <param name="pOffrate" value="-1" />
      <param name="pSeed" value="-1" />
      <param name="suppressHeader" value="true" />
      <output name="output" ftype="sam" file="bowtie_out7.sam" sort="True" />
      <output name="output_unmapped_reads_l" ftype="fastqsolexa" file="bowtie_out8_1.fastqsolexa.sorted" sort="True" />
      <output name="output_unmapped_reads_r" ftype="fastqsolexa" file="bowtie_out8_2.fastqsolexa.sorted" sort="True" />
    </test>
    <!-- end testing of non-sanger variant fastq reads -->    
    <test>
      <!--
      Bowtie command:
      bowtie -q -p 4 -S +sam-nohead -n 2 -e 70 -l 28 +maxbts 125 -y -k 1 chrM_base test-data/bowtie_in2.fastqsanger > bowtie_out9_u.sam
      sort bowtie_out9_u.sam > bowtie_out9.sam
      -p is the number of threads, hardcoded above. You need to replace the + with 2 dashes.
      chrM_base is the index files' location/base name. 
      -->
      <param name="genomeSource" value="indexed" />
      <!-- this is the backwards-compatible "unique value" for this index, not an actual path -->
      <param name="index" value="equCab2chrM" />
      <param name="sPaired" value="single" />
      <param name="sInput1" ftype="fastqsanger" value="bowtie_in2.fastqsanger" />
      <param name="sSettingsType" value="full" />
      <param name="sSkip" value="0" />
      <param name="sAlignLimit" value="-1" />
      <param name="sTrimH" value="0" />
      <param name="sTrimL" value="0" />
      <param name="sMismatchSeed" value="2" />
      <param name="sMismatchQual" value="70" />
      <param name="sSeedLen" value="28" />
      <param name="sRounding" value="round" />
      <param name="sMaqSoapAlign" value="-1" />
      <param name="sTryHard" value="doTryHard" />
      <param name="sValAlign" value="1" />
      <param name="sAllValAligns" value="noAllValAligns" />
      <param name="sSuppressAlign" value="-1" />
      <param name="sUnmappedFile" value="false" />
      <param name="sMaxFile" value="false" />
      <param name="sBest" value="noBest" />
      <param name="snMaxBacktracks" value="125" />
      <param name="sOffrate" value="-1" />
      <param name="sSeed" value="-1" />
      <param name="suppressHeader" value="true" />
      <output name="output" ftype="sam" file="bowtie_out9.sam" sort="True" />
    </test>
    <test>
      <!--
      Bowtie command:
      bowtie-build +offrate 5 +ftabchars 10 +little -f test-data/phiX.fasta phiX_base
      bowtie -q -X 1000 +ff -p 4 -S +sam-nohead phiX_base -1 test-data/bowtie_in5.fastqsanger -2 test-data/bowtie_in6.fastqsanger > bowtie_out10_u.sam
      sort bowtie_out10_u.sam > bowtie_out10.sam
      -p is the number of threads, hardcoded above. You need to replace the + with 2 dashes.
      chrM_base is the index files' location/base name. 
      -->
      <param name="genomeSource" value="history" />
      <param name="ownFile" value="phiX.fasta" />
      <param name="indexSettings" value="indexFull" />
      <param name="autoB" value="auto" />
      <param name="nodc" value="dc" />
      <param name="noref" value="ref" />
      <param name="offrate" value="5" />
      <param name="ftab" value="10" />
      <param name="ntoa" value="no" />
      <param name="endian" value="little" />
      <param name="seed" value="-1" />
      <param name="cutoff" value="-1" />
      <param name="sPaired" value="paired" />
      <param name="pInput1" ftype="fastqsanger" value="bowtie_in5.fastqsanger" />
      <param name="pInput2" ftype="fastqsanger" value="bowtie_in6.fastqsanger" />
      <param name="pMaxInsert" value="1000" />
      <param name="pMateOrient" value="ff" />
      <param name="pSettingsType" value="preSet" />
      <param name="suppressHeader" value="true" />
      <output name="output" ftype="sam" file="bowtie_out10.sam" sort="True" />
    </test>
  </tests>

  <help>

**What it does**

Bowtie_ is a short read aligner designed to be ultrafast and memory-efficient. It is developed by Ben Langmead and Cole Trapnell. Please cite: Langmead B, Trapnell C, Pop M, Salzberg SL. Ultrafast and memory-efficient alignment of short DNA sequences to the human genome. Genome Biology 10:R25.

.. _Bowtie: http://bowtie-bio.sourceforge.net/index.shtml

------

**Know what you are doing**

.. class:: warningmark

There is no such thing (yet) as an automated gearshift in short read mapping. It is all like stick-shift driving in San Francisco. In other words = running this tool with default parameters will probably not give you meaningful results. A way to deal with this is to **understand** the parameters by carefully reading the `documentation`__ and experimenting. Fortunately, Galaxy makes experimenting easy.

 .. __: http://bowtie-bio.sourceforge.net/index.shtml

------

**Input formats**

Bowtie accepts files in Sanger FASTQ format. Use the FASTQ Groomer to prepare your files.

------

**A Note on Built-in Reference Genomes**

The default variant for all genomes is "Full", defined as all primary chromosomes (or scaffolds/contigs) including mitochondrial plus associated unmapped, plasmid, and other segments. When only one version of a genome is available in this tool, it represents the default "Full" variant. Some genomes will have more than one variant available. The "Canonical Male" or sometimes simply "Canonical" variant contains the primary chromosomes for a genome. For example a human "Canonical" variant contains chr1-chr22, chrX, chrY, and chrM. The "Canonical Female" variant contains the primary chromosomes excluding chrY.

------

**Outputs**

The output is in SAM format, and has the following columns::

    Column  Description
  --------  --------------------------------------------------------   
   1 QNAME  Query (pair) NAME
   2 FLAG   bitwise FLAG
   3 RNAME  Reference sequence NAME
   4 POS    1-based leftmost POSition/coordinate of clipped sequence
   5 MAPQ   MAPping Quality (Phred-scaled)
   6 CIGAR  extended CIGAR string
   7 MRNM   Mate Reference sequence NaMe ('=' if same as RNAME)
   8 MPOS   1-based Mate POSition
   9 ISIZE  Inferred insert SIZE
  10 SEQ    query SEQuence on the same strand as the reference
  11 QUAL   query QUALity (ASCII-33 gives the Phred base quality)
  12 OPT    variable OPTional fields in the format TAG:VTYPE:VALUE
  
The flags are as follows::

    Flag  Description
  ------  -------------------------------------
  0x0001  the read is paired in sequencing
  0x0002  the read is mapped in a proper pair
  0x0004  the query sequence itself is unmapped
  0x0008  the mate is unmapped
  0x0010  strand of the query (1 for reverse)
  0x0020  strand of the mate
  0x0040  the read is the first read in a pair
  0x0080  the read is the second read in a pair
  0x0100  the alignment is not primary

It looks like this (scroll sideways to see the entire example)::

  QNAME	FLAG	RNAME	POS	MAPQ	CIAGR	MRNM	MPOS	ISIZE	SEQ	QUAL	OPT
  HWI-EAS91_1_30788AAXX:1:1:1761:343	4	*	0	0	*	*	0	0	AAAAAAANNAAAAAAAAAAAAAAAAAAAAAAAAAAACNNANNGAGTNGNNNNNNNGCTTCCCACAGNNCTGG	hhhhhhh;;hhhhhhhhhhh^hOhhhhghhhfhhhgh;;h;;hhhh;h;;;;;;;hhhhhhghhhh;;Phhh
  HWI-EAS91_1_30788AAXX:1:1:1578:331	4	*	0	0	*	*	0	0	GTATAGANNAATAAGAAAAAAAAAAATGAAGACTTTCNNANNTCTGNANNNNNNNTCTTTTTTCAGNNGTAG	hhhhhhh;;hhhhhhhhhhhhhhhhhhhhhhhhhhhh;;h;;hhhh;h;;;;;;;hhhhhhhhhhh;;hhVh

-------

**Bowtie settings**

All of the options have a default value. You can change any of them. Most of the options in Bowtie have been implemented here.

------

**Bowtie parameter list**

This is an exhaustive list of Bowtie options:

For indexing (bowtie-build)::

  -a                 No auto behavior. Disable the default behavior where bowtie automatically 
                     selects values for --bmax/--bmaxdivn/--dcv/--packed parameters according 
                     to the memory available. [off]
  --packed           Packing. Use a packed representation for DNA strings. [auto] 
  --bmax INT         Suffix maximum. The maximum number of suffixes allowed in a block. [auto]
  --bmaxdivn INT     Suffix maximum fraction. The maximum number of suffixes allowed in a block 
                     expressed as a fraction of the length of the reference. [4]
  --dcv INT          Difference-cover sample. Use INT as the period for the difference-cover 
                     sample. [1024]
  --nodc INT         No difference-cover sample. Disable the difference-cover sample. [off]
  -r                 No reference indexes. Do not build the NAME.3.ebwt and NAME.4.ebwt portions 
                     of the index. Used only for paired-end alignment. [off]
  -o                 Offrate. How many Burrows-Wheeler rows get marked by the indexer. The 
                     indexer will mark every 2^INT rows. The marked rows correspond to rows on 
                     the genome. [5]
  -t INT             Ftab. The lookup table used to calculate an initial Burrows-Wheeler range 
                     with respect to the first INT characters of the query. Ftab is 4^INT+1 
                     bytes. [10]
  --ntoa             N conversion. Convert Ns to As before building the index. Otherwise, Ns are 
                     simply excluded from the index and Bowtie will not find alignments that 
                     overlap them. [off]
  --big              Endianness. Endianness to use when serializing integers to the index file. [off]
  --little           Endianness. [--little]
  --seed INT         Random seed. Use INT as the seed for the pseudo-random number generator. [off]
  --cutoff INT       Cutoff. Index only the first INT bases of the reference sequences (cumulative 
                     across sequences) and ignore the rest. [off]

For aligning (bowtie)::

  -s INT             Skip. Do not align the first INT reads or pairs in the input. [off]
  -u INT             Align limit. Only align the first INT reads/pairs from the input. [no limit]
  -5 INT             High-quality trim. Trim INT bases from the high-quality (left) end of each 
                     read before alignment. [0]
  -3 INT             Low-quality trim. Trim INT bases from the low-quality (right) end of each 
                     read before alignment. [0]
  -n INT             Mismatch seed. Maximum number of mismatches permitted in the seed (defined 
                     with seed length option). Can be 0, 1, 2, or 3. [2]
  -e INT             Mismatch quality. Maximum permitted total of quality values at mismatched 
                     read positions. Bowtie rounds quality values to the nearest 10 and saturates 
                     at 30. [70]
  -l INT             Seed length. The number of bases on the high-quality end of the read to 
                     which the -n ceiling applies. Must be at least 5. [28]
  --nomaqround       Suppress MAQ rounding. Values are internally rounded to the nearest 10 and 
                     saturate at 30. This options turns off that rounding. [off] 
  -v INT             MAQ- or SOAP-like alignment policy. This option turns off the default 
                     MAQ-like alignment policy in favor of a SOAP-like one. End-to-end alignments 
                     with at most INT mismatches. [off]
  -I INT             Minimum insert. The minimum insert size for valid paired-end alignments. 
                     Does checking on untrimmed reads if -5 or -3 is used. [0]
  -X INT             Maximum insert. The maximum insert size for valid paired-end alignments. 
                     Does checking on untrimmed reads if -5 or -3 is used. [250]
  --fr               Mate orientation. The upstream/downstream mate orientations for a valid 
                     paired-end alignment against the forward reference strand. [--fr]
  --rf               Mate orientation. [off]
  --ff               Mate orientation. [off]
  --pairtries INT    Maximum alignment attempts for paired-end data. [100] 
  --nofw             No forward aligning. Choosing this option means that Bowtie will not attempt 
                     to align against the forward reference strand. [off]
  --norc             No reverse-complement aligning. Setting this will mean that Bowtie will not 
                     attempt to align against the reverse-complement reference strand. [off]
  --un FILENAME      Write all reads that could not be aligned to file [off]
  --max FILENAME     Write all reads with a number of valid alignments exceeding the limit
                     set with the -m option to file [off]
  --maxbts INT       Maximum backtracks. The maximum number of backtracks permitted when aligning 
                     a read in -n 2 or -n 3 mode. [125 without --best] [800 with --best]
  -y                 Try hard. Try as hard as possible to find valid alignments when they exist, 
                     including paired-end alignments. [off]
  --chunkmbs INT     Thread memory. The number of megabytes of memory a given thread is given to 
                     store path descriptors in --best mode. [32]
  -k INT             Valid alignments. The number of valid alignments per read or pair. [off] 
  -a                 All valid alignments. Choosing this means that all valid alignments per read 
                     or pair will be reported. [off]
  -m INT             Suppress alignments. Suppress all alignments for a particular read or pair 
                     if more than INT reportable alignments exist for it. [no limit]
  --best             Best mode. Make Bowtie guarantee that reported singleton alignments are 
                     "best" in terms of stratum (the number of mismatches) and quality values at 
                     mismatched position. [off]
  --strata           Best strata. When running in best mode, report alignments that fall into the 
                     best stratum if there are ones falling into more than one. [off]
  -o INT             Offrate override. Override the offrate of the index with INT. Some row 
                     markings are discarded when index read into memory. INT must be greater than 
                     the value used to build the index (default: 5). [off]
  --seed INT         Random seed. Use INT as the seed for the pseudo-random number generator. [off]
  --snpphred INT     Use INT as the SNP penalty for decoding colorspace alignments. True ratio of 
                     SNPs per base in the subject genome. [see --snpfrac]
  --snpfrac DEC      Use DEC as the estimated ratio of SNPs per base when decoding colorspace 
                     alignments. [0.001]
  --col-keepends     Keep the extreme-end nucleotides and qualities when decoding colorspace 
                     alignments. [off]

  </help>
</tool>
