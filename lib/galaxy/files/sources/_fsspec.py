import abc
import functools
import logging
import os
from typing import (
    ClassVar,
    Dict,
    List,
    Optional,
    Tuple,
    Type,
    TypeVar,
)

from fsspec import AbstractFileSystem
from typing_extensions import (
    cast,
    NotRequired,
    Unpack,
)

from galaxy.exceptions import (
    AuthenticationRequired,
    MessageException,
)
from galaxy.files import OptionalUserContext
from . import (
    AnyRemoteEntry,
    BaseFilesSource,
    FilesSourceOptions,
    FilesSourceProperties,
)

log = logging.getLogger(__name__)

PACKAGE_MESSAGE = "FilesSource plugin is missing required Python fsspec plugin package [%s]"

T = TypeVar("T")

# Maximum number of items to return in a single listing.
# This is a safeguard to prevent excessive memory usage and performance issues
# since is a huge number of items is not practical for browsing in most use cases.
MAX_ITEMS_LIMIT = 1000


class FsspecFilesSourceProperties(FilesSourceProperties, total=False):
    listings_expiry_time: NotRequired[Optional[int]]


class FsspecFilesSource(BaseFilesSource):
    required_module: ClassVar[Optional[Type[AbstractFileSystem]]]
    required_package: ClassVar[str]
    supports_pagination = True
    supports_search = True
    supports_sorting = False

    def __init__(self, **kwd: Unpack[FsspecFilesSourceProperties]):
        self.ensure_required_dependency()
        props = cast(FsspecFilesSourceProperties, self._parse_common_config_opts(kwd))
        props = self._initialize_listings_expiry(props)
        self._props = props

    def ensure_required_dependency(self):
        if self.required_module is None:
            raise Exception(PACKAGE_MESSAGE % self.required_package)
        return self.required_module

    def _initialize_listings_expiry(self, props: FsspecFilesSourceProperties) -> FsspecFilesSourceProperties:
        file_sources_config = self._file_sources_config
        if (
            props.get("listings_expiry_time") is None
            and file_sources_config
            and file_sources_config.listings_expiry_time
        ):
            props["listings_expiry_time"] = file_sources_config.listings_expiry_time
        return props

    def get_prop_value(
        self, prop_name: str, expected_type: Type[T], user_context: OptionalUserContext = None
    ) -> Optional[T]:
        """Get a property value, evaluating it if necessary."""
        value = self._props.get(prop_name)
        if value is None:
            return None

        if self._is_templated(value) and user_context is not None:
            value = self._evaluate_prop(value, user_context=user_context)

        if isinstance(value, expected_type):
            return value
        return None

    @abc.abstractmethod
    def _open_fs(
        self, user_context: OptionalUserContext = None, opts: Optional[FilesSourceOptions] = None
    ) -> AbstractFileSystem:
        """Subclasses must instantiate an fsspec AbstractFileSystem handle for this file system."""

    def _list(
        self,
        path="/",
        recursive=False,
        user_context: OptionalUserContext = None,
        opts: Optional[FilesSourceOptions] = None,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        query: Optional[str] = None,
        sort_by: Optional[str] = None,
    ) -> Tuple[List[AnyRemoteEntry], int]:
        """Return the list of 'Directory's and 'File's under the given path.

        If `recursive` is True, it will recursively list all files and directories under the given path with a maximum limit of `MAX_ITEMS_PER_LISTING`.
        If `query` is provided, it will filter the results based on the query using glob patterns.
        Pagination is supported with `limit` and `offset` but please note it is not applied until after the full listing is retrieved from the filesystem.
        """
        try:
            fs = self._open_fs(user_context=user_context, opts=opts)

            if recursive:
                return self._list_recursive(fs, path)

            if query:
                entries_list = self._list_with_query(fs, path, query)
            else:
                entries_list = self._list_directory(fs, path)

            total_count = len(entries_list)

            # We apply pagination after getting all entries.
            # This is not ideal but necessary due to how fsspec handles listings.
            # At least we reduce the traffic generated by the listing.
            paginated_entries = self._apply_pagination(entries_list, limit, offset)

            return paginated_entries, total_count

        except PermissionError as e:
            raise AuthenticationRequired(
                f"Permission Denied. Reason: {e}. Please check your credentials in your preferences for {self.label}."
            )
        except Exception as e:
            raise MessageException(f"Problem listing file source path {path}. Reason: {e}") from e

    def _build_glob_pattern(self, path: str, query: str) -> str:
        """Build a glob pattern for server-side filtering."""
        # Escape special glob characters in the query except * and ?
        escaped_query = query.replace("[", r"\[").replace("]", r"\]").replace("{", r"\{").replace("}", r"\}")
        path_prefix = path.rstrip("/") if path != "/" else ""
        return f"{path_prefix}/*{escaped_query}*"

    def _realize_to(
        self,
        source_path: str,
        native_path: str,
        user_context: OptionalUserContext = None,
        opts: Optional[FilesSourceOptions] = None,
    ):
        """Download a file from the fsspec filesystem to a local path."""
        fs = self._open_fs(user_context=user_context, opts=opts)
        fs.get_file(source_path, native_path)

    def _write_from(
        self,
        target_path: str,
        native_path: str,
        user_context: OptionalUserContext = None,
        opts: Optional[FilesSourceOptions] = None,
    ):
        """Upload a file from a local path to the fsspec filesystem."""
        if opts is not None and opts.writeable is False:
            raise MessageException("Cannot write to this destination because it is configured as read-only.")
        fs = self._open_fs(user_context=user_context, opts=opts)
        fs.put_file(native_path, target_path)

    def _serialization_props(self, user_context: OptionalUserContext = None):
        """Get effective properties for serialization."""
        effective_props = {}
        for key, val in self._props.items():
            effective_props[key] = self._evaluate_prop(val, user_context=user_context)
        return effective_props

    def _file_info_to_dict(self, file_path: str, info: dict) -> AnyRemoteEntry:
        """Convert fsspec file info to Galaxy's remote entry format."""
        name = os.path.basename(file_path) if file_path != "/" else "/"
        uri = self.uri_from_path(file_path)

        if info.get("type") == "directory":
            return {"class": "Directory", "name": name, "uri": uri, "path": file_path}
        else:
            size = int(info.get("size", 0))
            # Handle timestamp fields more robustly - check for None explicitly
            mtime = info.get("mtime")
            if mtime is None:
                mtime = info.get("modified")
            if mtime is None:
                mtime = info.get("LastModified")

            ctime_result = self.to_dict_time(mtime) if mtime is not None else ""
            ctime = ctime_result if ctime_result is not None else ""
            return {
                "class": "File",
                "name": name,
                "size": size,
                "ctime": ctime,
                "uri": uri,
                "path": file_path,
            }

    def _list_recursive(self, fs: AbstractFileSystem, path: str) -> Tuple[List[AnyRemoteEntry], int]:
        """Handle recursive directory listing with item limit."""
        # TODO: this is potentially inefficient for large directories.
        # We should consider dropping this option.
        # Limiting the number of items returned for now.
        res: List[AnyRemoteEntry] = []
        count = 0
        for p, dirs, files in fs.walk(path, detail=True):
            # We are using detail=True to get file info as dicts,
            # so we can safely cast the result.
            dirs = cast(Dict[str, dict], dirs)
            files = cast(Dict[str, dict], files)
            to_dict = functools.partial(self._file_info_to_dict, str(p))
            res.extend(map(to_dict, dirs.values()))
            res.extend(map(to_dict, files.values()))
            count += len(dirs) + len(files)
            if count >= MAX_ITEMS_LIMIT:
                self._on_listing_exceeded()
                break
        return res, len(res)

    def _on_listing_exceeded(self):
        log.warning(
            "Listing for file source %s with root %s exceeded maximum items (%d).",
            self.label,
            self.get_uri_root(),
            MAX_ITEMS_LIMIT,
        )

    def _list_with_query(self, fs: AbstractFileSystem, path: str, query: str) -> List[AnyRemoteEntry]:
        """Handle directory listing with query filtering using glob patterns."""
        entries_list = []
        glob_pattern = self._build_glob_pattern(path, query)
        # Using detail=True returns a dict with file paths as keys and their info as
        # values so we can safely cast the result.
        matched_paths = cast(Dict[str, dict], fs.glob(glob_pattern, detail=True))
        for file_path, info in matched_paths.items():
            entries_list.append(self._file_info_to_dict(str(file_path), info))
        return entries_list

    def _list_directory(self, fs: AbstractFileSystem, path: str) -> List[AnyRemoteEntry]:
        """Handle standard directory listing without query filtering."""
        entries_list = []
        entries: List[dict] = fs.ls(path, detail=True)
        for entry in entries:
            entry_path = entry.get("name", entry.get("path", ""))
            if entry_path:  # Only process entries with valid paths
                entries_list.append(self._file_info_to_dict(entry_path, entry))
        return entries_list

    def _apply_pagination(
        self, entries_list: List[AnyRemoteEntry], limit: Optional[int], offset: Optional[int]
    ) -> List[AnyRemoteEntry]:
        """Apply pagination to the entries list."""
        if offset is not None and limit is not None:
            return entries_list[offset : offset + limit]
        elif limit is not None:
            return entries_list[:limit]
        return entries_list
