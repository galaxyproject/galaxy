webpackJsonp([1],{

/***/ 10:
/*!********************************************!*\
  !*** ./galaxy/scripts/mvc/ui/ui-select.js ***!
  \********************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(Backbone, _) {\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _utils = __webpack_require__(/*! utils/utils */ 4);\n\nvar _utils2 = _interopRequireDefault(_utils);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * A plugin for initializing select2 input items.\n * Make sure the select2 library itself is loaded beforehand.\n * Also the element to which select2 will be appended has to\n * be created before select2 initialization (and passed as option).\n */\nvar View = Backbone.View.extend({\n    // options\n    optionsDefault: {\n        css: \"\",\n        placeholder: \"No data available\",\n        data: [],\n        value: null,\n        multiple: false,\n        minimumInputLength: 0,\n        // example format of initial data: \"id:name,55:anotherrole@role.com,27:role@role.com\"\n        initialData: \"\"\n    },\n\n    // initialize\n    initialize: function initialize(options) {\n        // configure options\n        this.options = _utils2.default.merge(options, this.optionsDefault);\n\n        // create new element\n        this.setElement(this._template(this.options));\n\n        // check if container exists\n        if (!this.options.container) {\n            console.log(\"ui-select::initialize() : container not specified.\");\n            return;\n        }\n\n        // add to dom\n        this.options.container.append(this.$el);\n\n        // link selection dictionary\n        this.select_data = this.options.data;\n\n        // refresh\n        this._refresh();\n\n        if (!this.options.multiple) {\n            // initial value\n            if (this.options.value) {\n                this._setValue(this.options.value);\n            }\n\n            // add change event\n            var self = this;\n            if (this.options.onchange) {\n                this.$el.on(\"change\", function () {\n                    self.options.onchange(self.value());\n                });\n            }\n        }\n    },\n\n    // value\n    value: function value(new_value) {\n        // get current id/value\n        var before = this._getValue();\n\n        // check if new_value is defined\n        if (new_value !== undefined) {\n            this._setValue(new_value);\n        }\n\n        // get current id/value\n        var after = this._getValue();\n\n        // fire onchange\n        if (after != before && this.options.onchange) {\n            this.options.onchange(after);\n        }\n\n        // return current value\n        return after;\n    },\n\n    // label\n    text: function text() {\n        return this.$el.select2(\"data\").text;\n    },\n\n    // disabled\n    disabled: function disabled() {\n        return !this.$el.select2(\"enable\");\n    },\n\n    // enable\n    enable: function enable() {\n        this.$el.select2(\"enable\", true);\n    },\n\n    // disable\n    disable: function disable() {\n        this.$el.select2(\"enable\", false);\n    },\n\n    // add\n    add: function add(options) {\n        // add options\n        this.select_data.push({\n            id: options.id,\n            text: options.text\n        });\n\n        // refresh\n        this._refresh();\n    },\n\n    // remove\n    del: function del(id) {\n        // search option\n        var index = this._getIndex(id);\n\n        // check if found\n        if (index != -1) {\n            // remove options\n            this.select_data.splice(index, 1);\n\n            // refresh\n            this._refresh();\n        }\n    },\n\n    // remove\n    remove: function remove() {\n        this.$el.select2(\"destroy\");\n    },\n\n    // update\n    update: function update(options) {\n        // copy options\n        this.select_data = [];\n        for (var key in options.data) {\n            this.select_data.push(options.data[key]);\n        }\n\n        // refresh\n        this._refresh();\n    },\n\n    // refresh\n    _refresh: function _refresh() {\n        // add select2 data based on type of input\n        if (!this.options.multiple) {\n            var selected = this._getValue();\n            var select_opt = {\n                data: this.select_data,\n                containerCssClass: this.options.css,\n                placeholder: this.options.placeholder,\n                dropdownAutoWidth: true\n            };\n            this.$el.select2(select_opt);\n            // select previous value (if exists)\n            this._setValue(selected);\n        } else {\n            var select_opt = {\n                multiple: this.options.multiple,\n                containerCssClass: this.options.css,\n                placeholder: this.options.placeholder,\n                minimumInputLength: this.options.minimumInputLength,\n                ajax: this.options.ajax,\n                dropdownCssClass: this.options.dropdownCssClass,\n                escapeMarkup: this.options.escapeMarkup,\n                formatResult: this.options.formatResult,\n                formatSelection: this.options.formatSelection,\n                initSelection: this.options.initSelection,\n                initialData: this.options.initialData\n            };\n            this.$el.select2(select_opt);\n        }\n    },\n\n    // get index\n    _getIndex: function _getIndex(value) {\n        // returns the index of the searched value\n        _.findIndex(this.select_data, { id: value });\n    },\n\n    // get value\n    _getValue: function _getValue() {\n        return this.$el.select2(\"val\");\n    },\n\n    // set value\n    _setValue: function _setValue(new_value) {\n        var index = this._getIndex(new_value);\n        if (index == -1) {\n            if (this.select_data.length > 0) {\n                new_value = this.select_data[0].id;\n            }\n        }\n        this.$el.select2(\"val\", new_value);\n    },\n\n    // element\n    _template: function _template(options) {\n        return \"<input type=\\\"hidden\\\" value=\\\"\" + this.options.initialData + \"\\\"/>\";\n    }\n}); // dependencies\nexports.default = {\n    View: View\n};\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! libs/backbone */ 2), __webpack_require__(/*! underscore */ 1)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZ2FsYXh5L3NjcmlwdHMvbXZjL3VpL3VpLXNlbGVjdC5qcz8xZmJkIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGRlcGVuZGVuY2llc1xuaW1wb3J0IFV0aWxzIGZyb20gXCJ1dGlscy91dGlsc1wiO1xuLyoqXG4gKiBBIHBsdWdpbiBmb3IgaW5pdGlhbGl6aW5nIHNlbGVjdDIgaW5wdXQgaXRlbXMuXG4gKiBNYWtlIHN1cmUgdGhlIHNlbGVjdDIgbGlicmFyeSBpdHNlbGYgaXMgbG9hZGVkIGJlZm9yZWhhbmQuXG4gKiBBbHNvIHRoZSBlbGVtZW50IHRvIHdoaWNoIHNlbGVjdDIgd2lsbCBiZSBhcHBlbmRlZCBoYXMgdG9cbiAqIGJlIGNyZWF0ZWQgYmVmb3JlIHNlbGVjdDIgaW5pdGlhbGl6YXRpb24gKGFuZCBwYXNzZWQgYXMgb3B0aW9uKS5cbiAqL1xudmFyIFZpZXcgPSBCYWNrYm9uZS5WaWV3LmV4dGVuZCh7XG4gICAgLy8gb3B0aW9uc1xuICAgIG9wdGlvbnNEZWZhdWx0OiB7XG4gICAgICAgIGNzczogXCJcIixcbiAgICAgICAgcGxhY2Vob2xkZXI6IFwiTm8gZGF0YSBhdmFpbGFibGVcIixcbiAgICAgICAgZGF0YTogW10sXG4gICAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgICBtdWx0aXBsZTogZmFsc2UsXG4gICAgICAgIG1pbmltdW1JbnB1dExlbmd0aDogMCxcbiAgICAgICAgLy8gZXhhbXBsZSBmb3JtYXQgb2YgaW5pdGlhbCBkYXRhOiBcImlkOm5hbWUsNTU6YW5vdGhlcnJvbGVAcm9sZS5jb20sMjc6cm9sZUByb2xlLmNvbVwiXG4gICAgICAgIGluaXRpYWxEYXRhOiBcIlwiXG4gICAgfSxcblxuICAgIC8vIGluaXRpYWxpemVcbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIC8vIGNvbmZpZ3VyZSBvcHRpb25zXG4gICAgICAgIHRoaXMub3B0aW9ucyA9IFV0aWxzLm1lcmdlKG9wdGlvbnMsIHRoaXMub3B0aW9uc0RlZmF1bHQpO1xuXG4gICAgICAgIC8vIGNyZWF0ZSBuZXcgZWxlbWVudFxuICAgICAgICB0aGlzLnNldEVsZW1lbnQodGhpcy5fdGVtcGxhdGUodGhpcy5vcHRpb25zKSk7XG5cbiAgICAgICAgLy8gY2hlY2sgaWYgY29udGFpbmVyIGV4aXN0c1xuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5jb250YWluZXIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwidWktc2VsZWN0Ojppbml0aWFsaXplKCkgOiBjb250YWluZXIgbm90IHNwZWNpZmllZC5cIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZGQgdG8gZG9tXG4gICAgICAgIHRoaXMub3B0aW9ucy5jb250YWluZXIuYXBwZW5kKHRoaXMuJGVsKTtcblxuICAgICAgICAvLyBsaW5rIHNlbGVjdGlvbiBkaWN0aW9uYXJ5XG4gICAgICAgIHRoaXMuc2VsZWN0X2RhdGEgPSB0aGlzLm9wdGlvbnMuZGF0YTtcblxuICAgICAgICAvLyByZWZyZXNoXG4gICAgICAgIHRoaXMuX3JlZnJlc2goKTtcblxuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5tdWx0aXBsZSkge1xuICAgICAgICAgICAgLy8gaW5pdGlhbCB2YWx1ZVxuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy52YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NldFZhbHVlKHRoaXMub3B0aW9ucy52YWx1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGFkZCBjaGFuZ2UgZXZlbnRcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMub25jaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRlbC5vbihcImNoYW5nZVwiLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYub3B0aW9ucy5vbmNoYW5nZShzZWxmLnZhbHVlKCkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8vIHZhbHVlXG4gICAgdmFsdWU6IGZ1bmN0aW9uKG5ld192YWx1ZSkge1xuICAgICAgICAvLyBnZXQgY3VycmVudCBpZC92YWx1ZVxuICAgICAgICB2YXIgYmVmb3JlID0gdGhpcy5fZ2V0VmFsdWUoKTtcblxuICAgICAgICAvLyBjaGVjayBpZiBuZXdfdmFsdWUgaXMgZGVmaW5lZFxuICAgICAgICBpZiAobmV3X3ZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3NldFZhbHVlKG5ld192YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBnZXQgY3VycmVudCBpZC92YWx1ZVxuICAgICAgICB2YXIgYWZ0ZXIgPSB0aGlzLl9nZXRWYWx1ZSgpO1xuXG4gICAgICAgIC8vIGZpcmUgb25jaGFuZ2VcbiAgICAgICAgaWYgKGFmdGVyICE9IGJlZm9yZSAmJiB0aGlzLm9wdGlvbnMub25jaGFuZ2UpIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5vbmNoYW5nZShhZnRlcik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZXR1cm4gY3VycmVudCB2YWx1ZVxuICAgICAgICByZXR1cm4gYWZ0ZXI7XG4gICAgfSxcblxuICAgIC8vIGxhYmVsXG4gICAgdGV4dDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRlbC5zZWxlY3QyKFwiZGF0YVwiKS50ZXh0O1xuICAgIH0sXG5cbiAgICAvLyBkaXNhYmxlZFxuICAgIGRpc2FibGVkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLiRlbC5zZWxlY3QyKFwiZW5hYmxlXCIpO1xuICAgIH0sXG5cbiAgICAvLyBlbmFibGVcbiAgICBlbmFibGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLiRlbC5zZWxlY3QyKFwiZW5hYmxlXCIsIHRydWUpO1xuICAgIH0sXG5cbiAgICAvLyBkaXNhYmxlXG4gICAgZGlzYWJsZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuJGVsLnNlbGVjdDIoXCJlbmFibGVcIiwgZmFsc2UpO1xuICAgIH0sXG5cbiAgICAvLyBhZGRcbiAgICBhZGQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgLy8gYWRkIG9wdGlvbnNcbiAgICAgICAgdGhpcy5zZWxlY3RfZGF0YS5wdXNoKHtcbiAgICAgICAgICAgIGlkOiBvcHRpb25zLmlkLFxuICAgICAgICAgICAgdGV4dDogb3B0aW9ucy50ZXh0XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIHJlZnJlc2hcbiAgICAgICAgdGhpcy5fcmVmcmVzaCgpO1xuICAgIH0sXG5cbiAgICAvLyByZW1vdmVcbiAgICBkZWw6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgIC8vIHNlYXJjaCBvcHRpb25cbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5fZ2V0SW5kZXgoaWQpO1xuXG4gICAgICAgIC8vIGNoZWNrIGlmIGZvdW5kXG4gICAgICAgIGlmIChpbmRleCAhPSAtMSkge1xuICAgICAgICAgICAgLy8gcmVtb3ZlIG9wdGlvbnNcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0X2RhdGEuc3BsaWNlKGluZGV4LCAxKTtcblxuICAgICAgICAgICAgLy8gcmVmcmVzaFxuICAgICAgICAgICAgdGhpcy5fcmVmcmVzaCgpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8vIHJlbW92ZVxuICAgIHJlbW92ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuJGVsLnNlbGVjdDIoXCJkZXN0cm95XCIpO1xuICAgIH0sXG5cbiAgICAvLyB1cGRhdGVcbiAgICB1cGRhdGU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgLy8gY29weSBvcHRpb25zXG4gICAgICAgIHRoaXMuc2VsZWN0X2RhdGEgPSBbXTtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIG9wdGlvbnMuZGF0YSkge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RfZGF0YS5wdXNoKG9wdGlvbnMuZGF0YVtrZXldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlZnJlc2hcbiAgICAgICAgdGhpcy5fcmVmcmVzaCgpO1xuICAgIH0sXG5cbiAgICAvLyByZWZyZXNoXG4gICAgX3JlZnJlc2g6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBhZGQgc2VsZWN0MiBkYXRhIGJhc2VkIG9uIHR5cGUgb2YgaW5wdXRcbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMubXVsdGlwbGUpIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3RlZCA9IHRoaXMuX2dldFZhbHVlKCk7XG4gICAgICAgICAgICB2YXIgc2VsZWN0X29wdCA9IHtcbiAgICAgICAgICAgICAgICBkYXRhOiB0aGlzLnNlbGVjdF9kYXRhLFxuICAgICAgICAgICAgICAgIGNvbnRhaW5lckNzc0NsYXNzOiB0aGlzLm9wdGlvbnMuY3NzLFxuICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyOiB0aGlzLm9wdGlvbnMucGxhY2Vob2xkZXIsXG4gICAgICAgICAgICAgICAgZHJvcGRvd25BdXRvV2lkdGg6IHRydWVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLiRlbC5zZWxlY3QyKHNlbGVjdF9vcHQpO1xuICAgICAgICAgICAgLy8gc2VsZWN0IHByZXZpb3VzIHZhbHVlIChpZiBleGlzdHMpXG4gICAgICAgICAgICB0aGlzLl9zZXRWYWx1ZShzZWxlY3RlZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgc2VsZWN0X29wdCA9IHtcbiAgICAgICAgICAgICAgICBtdWx0aXBsZTogdGhpcy5vcHRpb25zLm11bHRpcGxlLFxuICAgICAgICAgICAgICAgIGNvbnRhaW5lckNzc0NsYXNzOiB0aGlzLm9wdGlvbnMuY3NzLFxuICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyOiB0aGlzLm9wdGlvbnMucGxhY2Vob2xkZXIsXG4gICAgICAgICAgICAgICAgbWluaW11bUlucHV0TGVuZ3RoOiB0aGlzLm9wdGlvbnMubWluaW11bUlucHV0TGVuZ3RoLFxuICAgICAgICAgICAgICAgIGFqYXg6IHRoaXMub3B0aW9ucy5hamF4LFxuICAgICAgICAgICAgICAgIGRyb3Bkb3duQ3NzQ2xhc3M6IHRoaXMub3B0aW9ucy5kcm9wZG93bkNzc0NsYXNzLFxuICAgICAgICAgICAgICAgIGVzY2FwZU1hcmt1cDogdGhpcy5vcHRpb25zLmVzY2FwZU1hcmt1cCxcbiAgICAgICAgICAgICAgICBmb3JtYXRSZXN1bHQ6IHRoaXMub3B0aW9ucy5mb3JtYXRSZXN1bHQsXG4gICAgICAgICAgICAgICAgZm9ybWF0U2VsZWN0aW9uOiB0aGlzLm9wdGlvbnMuZm9ybWF0U2VsZWN0aW9uLFxuICAgICAgICAgICAgICAgIGluaXRTZWxlY3Rpb246IHRoaXMub3B0aW9ucy5pbml0U2VsZWN0aW9uLFxuICAgICAgICAgICAgICAgIGluaXRpYWxEYXRhOiB0aGlzLm9wdGlvbnMuaW5pdGlhbERhdGFcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLiRlbC5zZWxlY3QyKHNlbGVjdF9vcHQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8vIGdldCBpbmRleFxuICAgIF9nZXRJbmRleDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgLy8gcmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIHNlYXJjaGVkIHZhbHVlXG4gICAgICAgIF8uZmluZEluZGV4KHRoaXMuc2VsZWN0X2RhdGEsIHsgaWQ6IHZhbHVlIH0pO1xuICAgIH0sXG5cbiAgICAvLyBnZXQgdmFsdWVcbiAgICBfZ2V0VmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kZWwuc2VsZWN0MihcInZhbFwiKTtcbiAgICB9LFxuXG4gICAgLy8gc2V0IHZhbHVlXG4gICAgX3NldFZhbHVlOiBmdW5jdGlvbihuZXdfdmFsdWUpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5fZ2V0SW5kZXgobmV3X3ZhbHVlKTtcbiAgICAgICAgaWYgKGluZGV4ID09IC0xKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zZWxlY3RfZGF0YS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgbmV3X3ZhbHVlID0gdGhpcy5zZWxlY3RfZGF0YVswXS5pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLiRlbC5zZWxlY3QyKFwidmFsXCIsIG5ld192YWx1ZSk7XG4gICAgfSxcblxuICAgIC8vIGVsZW1lbnRcbiAgICBfdGVtcGxhdGU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIGA8aW5wdXQgdHlwZT1cImhpZGRlblwiIHZhbHVlPVwiJHt0aGlzLm9wdGlvbnMuaW5pdGlhbERhdGF9XCIvPmA7XG4gICAgfVxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgICBWaWV3OiBWaWV3XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGdhbGF4eS9zY3JpcHRzL212Yy91aS91aS1zZWxlY3QuanMiXSwibWFwcGluZ3MiOiI7Ozs7OztBQUNBO0FBQ0E7Ozs7O0FBQUE7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFSQTtBQUNBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVhBO0FBYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBbk1BO0FBc01BO0FBQ0E7QUFEQTtBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///10\n");

/***/ }),

/***/ 126:
/*!***********************************************************!*\
  !*** ./galaxy/scripts/mvc/workflow/workflow-connector.js ***!
  \***********************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function($) {\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nfunction Connector(handle1, handle2) {\n    this.canvas = null;\n    this.dragging = false;\n    this.inner_color = \"#FFFFFF\";\n    this.outer_color = \"#D8B365\";\n    if (handle1 && handle2) {\n        this.connect(handle1, handle2);\n    }\n}\n$.extend(Connector.prototype, {\n    connect: function connect(t1, t2) {\n        this.handle1 = t1;\n        if (this.handle1) {\n            this.handle1.connect(this);\n        }\n        this.handle2 = t2;\n        if (this.handle2) {\n            this.handle2.connect(this);\n        }\n    },\n    destroy: function destroy() {\n        if (this.handle1) {\n            this.handle1.disconnect(this);\n        }\n        if (this.handle2) {\n            this.handle2.disconnect(this);\n        }\n        $(this.canvas).remove();\n    },\n    destroyIfInvalid: function destroyIfInvalid() {\n        if (this.handle1 && this.handle2 && !this.handle2.attachable(this.handle1)) {\n            this.destroy();\n        }\n    },\n    redraw: function redraw() {\n        var canvas_container = $(\"#canvas-container\");\n        if (!this.canvas) {\n            this.canvas = document.createElement(\"canvas\");\n            canvas_container.append($(this.canvas));\n            if (this.dragging) {\n                this.canvas.style.zIndex = \"300\";\n            }\n        }\n        var relativeLeft = function relativeLeft(e) {\n            return $(e).offset().left - canvas_container.offset().left;\n        };\n        var relativeTop = function relativeTop(e) {\n            return $(e).offset().top - canvas_container.offset().top;\n        };\n        if (!this.handle1 || !this.handle2) {\n            return;\n        }\n        // Find the position of each handle\n        var start_x = relativeLeft(this.handle1.element) + 5;\n        var start_y = relativeTop(this.handle1.element) + 5;\n        var end_x = relativeLeft(this.handle2.element) + 5;\n        var end_y = relativeTop(this.handle2.element) + 5;\n        // Calculate canvas area\n        var canvas_extra = 100;\n        var canvas_min_x = Math.min(start_x, end_x);\n        var canvas_max_x = Math.max(start_x, end_x);\n        var canvas_min_y = Math.min(start_y, end_y);\n        var canvas_max_y = Math.max(start_y, end_y);\n        var cp_shift = Math.min(Math.max(Math.abs(canvas_max_y - canvas_min_y) / 2, 100), 300);\n        var canvas_left = canvas_min_x - canvas_extra;\n        var canvas_top = canvas_min_y - canvas_extra;\n        var canvas_width = canvas_max_x - canvas_min_x + 2 * canvas_extra;\n        var canvas_height = canvas_max_y - canvas_min_y + 2 * canvas_extra;\n        // Place the canvas\n        this.canvas.style.left = canvas_left + \"px\";\n        this.canvas.style.top = canvas_top + \"px\";\n        this.canvas.setAttribute(\"width\", canvas_width);\n        this.canvas.setAttribute(\"height\", canvas_height);\n        // Adjust points to be relative to the canvas\n        start_x -= canvas_left;\n        start_y -= canvas_top;\n        end_x -= canvas_left;\n        end_y -= canvas_top;\n\n        // Draw the line\n\n        var c = this.canvas.getContext(\"2d\");\n\n        var start_offsets = null;\n        var end_offsets = null;\n        var num_offsets = 1;\n        if (this.handle1 && this.handle1.isMappedOver()) {\n            var start_offsets = [-6, -3, 0, 3, 6];\n            num_offsets = 5;\n        } else {\n            var start_offsets = [0];\n        }\n        if (this.handle2 && this.handle2.isMappedOver()) {\n            var end_offsets = [-6, -3, 0, 3, 6];\n            num_offsets = 5;\n        } else {\n            var end_offsets = [0];\n        }\n        var connector = this;\n        for (var i = 0; i < num_offsets; i++) {\n            var inner_width = 5;\n            var outer_width = 7;\n            if (start_offsets.length > 1 || end_offsets.length > 1) {\n                // We have a multi-run, using many lines, make them small.\n                inner_width = 1;\n                outer_width = 3;\n            }\n            connector.draw_outlined_curve(start_x, start_y, end_x, end_y, cp_shift, inner_width, outer_width, start_offsets[i % start_offsets.length], end_offsets[i % end_offsets.length]);\n        }\n    },\n    draw_outlined_curve: function draw_outlined_curve(start_x, start_y, end_x, end_y, cp_shift, inner_width, outer_width, offset_start, offset_end) {\n        var offset_start = offset_start || 0;\n        var offset_end = offset_end || 0;\n        var c = this.canvas.getContext(\"2d\");\n        c.lineCap = \"round\";\n        c.strokeStyle = this.outer_color;\n        c.lineWidth = outer_width;\n        c.beginPath();\n        c.moveTo(start_x, start_y + offset_start);\n        c.bezierCurveTo(start_x + cp_shift, start_y + offset_start, end_x - cp_shift, end_y + offset_end, end_x, end_y + offset_end);\n        c.stroke();\n        // Inner line\n        c.strokeStyle = this.inner_color;\n        c.lineWidth = inner_width;\n        c.beginPath();\n        c.moveTo(start_x, start_y + offset_start);\n        c.bezierCurveTo(start_x + cp_shift, start_y + offset_start, end_x - cp_shift, end_y + offset_end, end_x, end_y + offset_end);\n        c.stroke();\n    }\n});\nexports.default = Connector;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! jquery */ 0)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTI2LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL2dhbGF4eS9zY3JpcHRzL212Yy93b3JrZmxvdy93b3JrZmxvdy1jb25uZWN0b3IuanM/MGMwZiJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBDb25uZWN0b3IoaGFuZGxlMSwgaGFuZGxlMikge1xuICAgIHRoaXMuY2FudmFzID0gbnVsbDtcbiAgICB0aGlzLmRyYWdnaW5nID0gZmFsc2U7XG4gICAgdGhpcy5pbm5lcl9jb2xvciA9IFwiI0ZGRkZGRlwiO1xuICAgIHRoaXMub3V0ZXJfY29sb3IgPSBcIiNEOEIzNjVcIjtcbiAgICBpZiAoaGFuZGxlMSAmJiBoYW5kbGUyKSB7XG4gICAgICAgIHRoaXMuY29ubmVjdChoYW5kbGUxLCBoYW5kbGUyKTtcbiAgICB9XG59XG4kLmV4dGVuZChDb25uZWN0b3IucHJvdG90eXBlLCB7XG4gICAgY29ubmVjdDogZnVuY3Rpb24odDEsIHQyKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlMSA9IHQxO1xuICAgICAgICBpZiAodGhpcy5oYW5kbGUxKSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZTEuY29ubmVjdCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhhbmRsZTIgPSB0MjtcbiAgICAgICAgaWYgKHRoaXMuaGFuZGxlMikge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGUyLmNvbm5lY3QodGhpcyk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5oYW5kbGUxKSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZTEuZGlzY29ubmVjdCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5oYW5kbGUyKSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZTIuZGlzY29ubmVjdCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICAkKHRoaXMuY2FudmFzKS5yZW1vdmUoKTtcbiAgICB9LFxuICAgIGRlc3Ryb3lJZkludmFsaWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5oYW5kbGUxICYmIHRoaXMuaGFuZGxlMiAmJiAhdGhpcy5oYW5kbGUyLmF0dGFjaGFibGUodGhpcy5oYW5kbGUxKSkge1xuICAgICAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHJlZHJhdzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjYW52YXNfY29udGFpbmVyID0gJChcIiNjYW52YXMtY29udGFpbmVyXCIpO1xuICAgICAgICBpZiAoIXRoaXMuY2FudmFzKSB7XG4gICAgICAgICAgICB0aGlzLmNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgICAgICAgICBjYW52YXNfY29udGFpbmVyLmFwcGVuZCgkKHRoaXMuY2FudmFzKSk7XG4gICAgICAgICAgICBpZiAodGhpcy5kcmFnZ2luZykge1xuICAgICAgICAgICAgICAgIHRoaXMuY2FudmFzLnN0eWxlLnpJbmRleCA9IFwiMzAwXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlbGF0aXZlTGVmdCA9IGUgPT4gJChlKS5vZmZzZXQoKS5sZWZ0IC0gY2FudmFzX2NvbnRhaW5lci5vZmZzZXQoKS5sZWZ0O1xuICAgICAgICB2YXIgcmVsYXRpdmVUb3AgPSBlID0+ICQoZSkub2Zmc2V0KCkudG9wIC0gY2FudmFzX2NvbnRhaW5lci5vZmZzZXQoKS50b3A7XG4gICAgICAgIGlmICghdGhpcy5oYW5kbGUxIHx8ICF0aGlzLmhhbmRsZTIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBGaW5kIHRoZSBwb3NpdGlvbiBvZiBlYWNoIGhhbmRsZVxuICAgICAgICB2YXIgc3RhcnRfeCA9IHJlbGF0aXZlTGVmdCh0aGlzLmhhbmRsZTEuZWxlbWVudCkgKyA1O1xuICAgICAgICB2YXIgc3RhcnRfeSA9IHJlbGF0aXZlVG9wKHRoaXMuaGFuZGxlMS5lbGVtZW50KSArIDU7XG4gICAgICAgIHZhciBlbmRfeCA9IHJlbGF0aXZlTGVmdCh0aGlzLmhhbmRsZTIuZWxlbWVudCkgKyA1O1xuICAgICAgICB2YXIgZW5kX3kgPSByZWxhdGl2ZVRvcCh0aGlzLmhhbmRsZTIuZWxlbWVudCkgKyA1O1xuICAgICAgICAvLyBDYWxjdWxhdGUgY2FudmFzIGFyZWFcbiAgICAgICAgdmFyIGNhbnZhc19leHRyYSA9IDEwMDtcbiAgICAgICAgdmFyIGNhbnZhc19taW5feCA9IE1hdGgubWluKHN0YXJ0X3gsIGVuZF94KTtcbiAgICAgICAgdmFyIGNhbnZhc19tYXhfeCA9IE1hdGgubWF4KHN0YXJ0X3gsIGVuZF94KTtcbiAgICAgICAgdmFyIGNhbnZhc19taW5feSA9IE1hdGgubWluKHN0YXJ0X3ksIGVuZF95KTtcbiAgICAgICAgdmFyIGNhbnZhc19tYXhfeSA9IE1hdGgubWF4KHN0YXJ0X3ksIGVuZF95KTtcbiAgICAgICAgdmFyIGNwX3NoaWZ0ID0gTWF0aC5taW4oTWF0aC5tYXgoTWF0aC5hYnMoY2FudmFzX21heF95IC0gY2FudmFzX21pbl95KSAvIDIsIDEwMCksIDMwMCk7XG4gICAgICAgIHZhciBjYW52YXNfbGVmdCA9IGNhbnZhc19taW5feCAtIGNhbnZhc19leHRyYTtcbiAgICAgICAgdmFyIGNhbnZhc190b3AgPSBjYW52YXNfbWluX3kgLSBjYW52YXNfZXh0cmE7XG4gICAgICAgIHZhciBjYW52YXNfd2lkdGggPSBjYW52YXNfbWF4X3ggLSBjYW52YXNfbWluX3ggKyAyICogY2FudmFzX2V4dHJhO1xuICAgICAgICB2YXIgY2FudmFzX2hlaWdodCA9IGNhbnZhc19tYXhfeSAtIGNhbnZhc19taW5feSArIDIgKiBjYW52YXNfZXh0cmE7XG4gICAgICAgIC8vIFBsYWNlIHRoZSBjYW52YXNcbiAgICAgICAgdGhpcy5jYW52YXMuc3R5bGUubGVmdCA9IGAke2NhbnZhc19sZWZ0fXB4YDtcbiAgICAgICAgdGhpcy5jYW52YXMuc3R5bGUudG9wID0gYCR7Y2FudmFzX3RvcH1weGA7XG4gICAgICAgIHRoaXMuY2FudmFzLnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIGNhbnZhc193aWR0aCk7XG4gICAgICAgIHRoaXMuY2FudmFzLnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCBjYW52YXNfaGVpZ2h0KTtcbiAgICAgICAgLy8gQWRqdXN0IHBvaW50cyB0byBiZSByZWxhdGl2ZSB0byB0aGUgY2FudmFzXG4gICAgICAgIHN0YXJ0X3ggLT0gY2FudmFzX2xlZnQ7XG4gICAgICAgIHN0YXJ0X3kgLT0gY2FudmFzX3RvcDtcbiAgICAgICAgZW5kX3ggLT0gY2FudmFzX2xlZnQ7XG4gICAgICAgIGVuZF95IC09IGNhbnZhc190b3A7XG5cbiAgICAgICAgLy8gRHJhdyB0aGUgbGluZVxuXG4gICAgICAgIHZhciBjID0gdGhpcy5jYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuXG4gICAgICAgIHZhciBzdGFydF9vZmZzZXRzID0gbnVsbDtcbiAgICAgICAgdmFyIGVuZF9vZmZzZXRzID0gbnVsbDtcbiAgICAgICAgdmFyIG51bV9vZmZzZXRzID0gMTtcbiAgICAgICAgaWYgKHRoaXMuaGFuZGxlMSAmJiB0aGlzLmhhbmRsZTEuaXNNYXBwZWRPdmVyKCkpIHtcbiAgICAgICAgICAgIHZhciBzdGFydF9vZmZzZXRzID0gWy02LCAtMywgMCwgMywgNl07XG4gICAgICAgICAgICBudW1fb2Zmc2V0cyA9IDU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgc3RhcnRfb2Zmc2V0cyA9IFswXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5oYW5kbGUyICYmIHRoaXMuaGFuZGxlMi5pc01hcHBlZE92ZXIoKSkge1xuICAgICAgICAgICAgdmFyIGVuZF9vZmZzZXRzID0gWy02LCAtMywgMCwgMywgNl07XG4gICAgICAgICAgICBudW1fb2Zmc2V0cyA9IDU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgZW5kX29mZnNldHMgPSBbMF07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvbm5lY3RvciA9IHRoaXM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtX29mZnNldHM7IGkrKykge1xuICAgICAgICAgICAgdmFyIGlubmVyX3dpZHRoID0gNTtcbiAgICAgICAgICAgIHZhciBvdXRlcl93aWR0aCA9IDc7XG4gICAgICAgICAgICBpZiAoc3RhcnRfb2Zmc2V0cy5sZW5ndGggPiAxIHx8IGVuZF9vZmZzZXRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBoYXZlIGEgbXVsdGktcnVuLCB1c2luZyBtYW55IGxpbmVzLCBtYWtlIHRoZW0gc21hbGwuXG4gICAgICAgICAgICAgICAgaW5uZXJfd2lkdGggPSAxO1xuICAgICAgICAgICAgICAgIG91dGVyX3dpZHRoID0gMztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbm5lY3Rvci5kcmF3X291dGxpbmVkX2N1cnZlKFxuICAgICAgICAgICAgICAgIHN0YXJ0X3gsXG4gICAgICAgICAgICAgICAgc3RhcnRfeSxcbiAgICAgICAgICAgICAgICBlbmRfeCxcbiAgICAgICAgICAgICAgICBlbmRfeSxcbiAgICAgICAgICAgICAgICBjcF9zaGlmdCxcbiAgICAgICAgICAgICAgICBpbm5lcl93aWR0aCxcbiAgICAgICAgICAgICAgICBvdXRlcl93aWR0aCxcbiAgICAgICAgICAgICAgICBzdGFydF9vZmZzZXRzW2kgJSBzdGFydF9vZmZzZXRzLmxlbmd0aF0sXG4gICAgICAgICAgICAgICAgZW5kX29mZnNldHNbaSAlIGVuZF9vZmZzZXRzLmxlbmd0aF1cbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGRyYXdfb3V0bGluZWRfY3VydmU6IGZ1bmN0aW9uKFxuICAgICAgICBzdGFydF94LFxuICAgICAgICBzdGFydF95LFxuICAgICAgICBlbmRfeCxcbiAgICAgICAgZW5kX3ksXG4gICAgICAgIGNwX3NoaWZ0LFxuICAgICAgICBpbm5lcl93aWR0aCxcbiAgICAgICAgb3V0ZXJfd2lkdGgsXG4gICAgICAgIG9mZnNldF9zdGFydCxcbiAgICAgICAgb2Zmc2V0X2VuZFxuICAgICkge1xuICAgICAgICB2YXIgb2Zmc2V0X3N0YXJ0ID0gb2Zmc2V0X3N0YXJ0IHx8IDA7XG4gICAgICAgIHZhciBvZmZzZXRfZW5kID0gb2Zmc2V0X2VuZCB8fCAwO1xuICAgICAgICB2YXIgYyA9IHRoaXMuY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgICAgYy5saW5lQ2FwID0gXCJyb3VuZFwiO1xuICAgICAgICBjLnN0cm9rZVN0eWxlID0gdGhpcy5vdXRlcl9jb2xvcjtcbiAgICAgICAgYy5saW5lV2lkdGggPSBvdXRlcl93aWR0aDtcbiAgICAgICAgYy5iZWdpblBhdGgoKTtcbiAgICAgICAgYy5tb3ZlVG8oc3RhcnRfeCwgc3RhcnRfeSArIG9mZnNldF9zdGFydCk7XG4gICAgICAgIGMuYmV6aWVyQ3VydmVUbyhcbiAgICAgICAgICAgIHN0YXJ0X3ggKyBjcF9zaGlmdCxcbiAgICAgICAgICAgIHN0YXJ0X3kgKyBvZmZzZXRfc3RhcnQsXG4gICAgICAgICAgICBlbmRfeCAtIGNwX3NoaWZ0LFxuICAgICAgICAgICAgZW5kX3kgKyBvZmZzZXRfZW5kLFxuICAgICAgICAgICAgZW5kX3gsXG4gICAgICAgICAgICBlbmRfeSArIG9mZnNldF9lbmRcbiAgICAgICAgKTtcbiAgICAgICAgYy5zdHJva2UoKTtcbiAgICAgICAgLy8gSW5uZXIgbGluZVxuICAgICAgICBjLnN0cm9rZVN0eWxlID0gdGhpcy5pbm5lcl9jb2xvcjtcbiAgICAgICAgYy5saW5lV2lkdGggPSBpbm5lcl93aWR0aDtcbiAgICAgICAgYy5iZWdpblBhdGgoKTtcbiAgICAgICAgYy5tb3ZlVG8oc3RhcnRfeCwgc3RhcnRfeSArIG9mZnNldF9zdGFydCk7XG4gICAgICAgIGMuYmV6aWVyQ3VydmVUbyhcbiAgICAgICAgICAgIHN0YXJ0X3ggKyBjcF9zaGlmdCxcbiAgICAgICAgICAgIHN0YXJ0X3kgKyBvZmZzZXRfc3RhcnQsXG4gICAgICAgICAgICBlbmRfeCAtIGNwX3NoaWZ0LFxuICAgICAgICAgICAgZW5kX3kgKyBvZmZzZXRfZW5kLFxuICAgICAgICAgICAgZW5kX3gsXG4gICAgICAgICAgICBlbmRfeSArIG9mZnNldF9lbmRcbiAgICAgICAgKTtcbiAgICAgICAgYy5zdHJva2UoKTtcbiAgICB9XG59KTtcbmV4cG9ydCBkZWZhdWx0IENvbm5lY3RvcjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBnYWxheHkvc2NyaXB0cy9tdmMvd29ya2Zsb3cvd29ya2Zsb3ctY29ubmVjdG9yLmpzIl0sIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVdBO0FBQ0E7QUFDQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUUE7QUFDQTtBQXJKQTtBQXVKQTtBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///126\n");

/***/ }),

/***/ 127:
/*!************************************************************!*\
  !*** ./galaxy/scripts/mvc/library/library-dataset-view.js ***!
  \************************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(Backbone, _, $, jQuery) {\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _localization = __webpack_require__(/*! utils/localization */ 3);\n\nvar _localization2 = _interopRequireDefault(_localization);\n\nvar _toastr = __webpack_require__(/*! libs/toastr */ 7);\n\nvar _toastr2 = _interopRequireDefault(_toastr);\n\nvar _libraryModel = __webpack_require__(/*! mvc/library/library-model */ 13);\n\nvar _libraryModel2 = _interopRequireDefault(_libraryModel);\n\nvar _utils = __webpack_require__(/*! utils/utils */ 4);\n\nvar _utils2 = _interopRequireDefault(_utils);\n\nvar _uiSelect = __webpack_require__(/*! mvc/ui/ui-select */ 10);\n\nvar _uiSelect2 = _interopRequireDefault(_uiSelect);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar LibraryDatasetView = Backbone.View.extend({\n    el: \"#center\",\n\n    model: null,\n\n    options: {},\n\n    defaults: {\n        edit_mode: false\n    },\n\n    events: {\n        \"click .toolbtn_modify_dataset\": \"enableModification\",\n        \"click .toolbtn_cancel_modifications\": \"render\",\n        \"click .toolbtn-download-dataset\": \"downloadDataset\",\n        \"click .toolbtn-import-dataset\": \"importIntoHistory\",\n        \"click .copy-link-to-clipboard\": \"copyToClipboard\",\n        \"click .make-private\": \"makeDatasetPrivate\",\n        \"click .remove-restrictions\": \"removeDatasetRestrictions\",\n        \"click .toolbtn_save_permissions\": \"savePermissions\",\n        \"click .toolbtn_save_modifications\": \"saveModifications\"\n    },\n\n    // genome select\n    select_genome: null,\n\n    // extension select\n    select_extension: null,\n\n    // extension types\n    list_extensions: [],\n\n    // datatype placeholder for extension auto-detection\n    auto: {\n        id: \"auto\",\n        text: \"Auto-detect\",\n        description: \"This system will try to detect the file type automatically.\" + \" If your file is not detected properly as one of the known formats,\" + \" it most likely means that it has some format problems (e.g., different\" + \" number of columns on different rows). You can still coerce the system\" + \" to set your data to the format you think it should be.\" + \" You can also upload compressed files, which will automatically be decompressed.\"\n    },\n\n    // genomes\n    list_genomes: [],\n\n    initialize: function initialize(options) {\n        this.options = _.extend(this.options, options);\n        this.fetchExtAndGenomes();\n        if (this.options.id) {\n            this.fetchDataset();\n        }\n    },\n\n    fetchDataset: function fetchDataset(options) {\n        this.options = _.extend(this.options, options);\n        this.model = new _libraryModel2.default.Item({\n            id: this.options.id\n        });\n        var self = this;\n        this.model.fetch({\n            success: function success() {\n                if (self.options.show_permissions) {\n                    self.showPermissions();\n                } else if (self.options.show_version) {\n                    self.fetchVersion();\n                } else {\n                    self.render();\n                }\n            },\n            error: function error(model, response) {\n                if (typeof response.responseJSON !== \"undefined\") {\n                    _toastr2.default.error(response.responseJSON.err_msg + \" Click this to go back.\", \"\", {\n                        onclick: function onclick() {\n                            Galaxy.libraries.library_router.back();\n                        }\n                    });\n                } else {\n                    _toastr2.default.error(\"An error occurred. Click this to go back.\", \"\", {\n                        onclick: function onclick() {\n                            Galaxy.libraries.library_router.back();\n                        }\n                    });\n                }\n            }\n        });\n    },\n\n    render: function render(options) {\n        this.options = _.extend(this.options, options);\n        $(\".tooltip\").remove();\n        var template = this.templateDataset();\n        this.$el.html(template({ item: this.model }));\n        $(\".peek\").html(this.model.get(\"peek\"));\n        $(\"#center [data-toggle]\").tooltip();\n    },\n\n    fetchVersion: function fetchVersion(options) {\n        this.options = _.extend(this.options, options);\n        var self = this;\n        if (!this.options.ldda_id) {\n            this.render();\n            _toastr2.default.error(\"Library dataset version requested but no id provided.\");\n        } else {\n            this.ldda = new _libraryModel2.default.Ldda({\n                id: this.options.ldda_id\n            });\n            this.ldda.url = this.ldda.urlRoot + this.model.id + \"/versions/\" + this.ldda.id;\n            this.ldda.fetch({\n                success: function success() {\n                    self.renderVersion();\n                },\n                error: function error(model, response) {\n                    if (typeof response.responseJSON !== \"undefined\") {\n                        _toastr2.default.error(response.responseJSON.err_msg);\n                    } else {\n                        _toastr2.default.error(\"An error occurred.\");\n                    }\n                }\n            });\n        }\n    },\n\n    renderVersion: function renderVersion() {\n        $(\".tooltip\").remove();\n        var template = this.templateVersion();\n        this.$el.html(template({ item: this.model, ldda: this.ldda }));\n        $(\".peek\").html(this.ldda.get(\"peek\"));\n    },\n\n    enableModification: function enableModification() {\n        $(\".tooltip\").remove();\n        var template = this.templateModifyDataset();\n        this.$el.html(template({ item: this.model }));\n        this.renderSelectBoxes({\n            genome_build: this.model.get(\"genome_build\"),\n            file_ext: this.model.get(\"file_ext\")\n        });\n        $(\".peek\").html(this.model.get(\"peek\"));\n        $(\"#center [data-toggle]\").tooltip();\n    },\n\n    downloadDataset: function downloadDataset() {\n        var url = Galaxy.root + \"api/libraries/datasets/download/uncompressed\";\n        var data = { ld_ids: this.id };\n        this.processDownload(url, data);\n    },\n\n    processDownload: function processDownload(url, data, method) {\n        //url and data options required\n        if (url && data) {\n            //data can be string of parameters or array/object\n            data = typeof data == \"string\" ? data : $.param(data);\n            //split params into form inputs\n            var inputs = \"\";\n            $.each(data.split(\"&\"), function () {\n                var pair = this.split(\"=\");\n                inputs += \"<input type=\\\"hidden\\\" name=\\\"\" + pair[0] + \"\\\" value=\\\"\" + pair[1] + \"\\\" />\";\n            });\n            //send request\n            $(\"<form action=\\\"\" + url + \"\\\" method=\\\"\" + (method || \"post\") + \"\\\">\" + inputs + \"</form>\").appendTo(\"body\").submit().remove();\n\n            _toastr2.default.info(\"Your download will begin soon.\");\n        }\n    },\n\n    importIntoHistory: function importIntoHistory() {\n        this.refreshUserHistoriesList(function (self) {\n            var template = self.templateBulkImportInModal();\n            self.modal = Galaxy.modal;\n            self.modal.show({\n                closing_events: true,\n                title: (0, _localization2.default)(\"Import into History\"),\n                body: template({ histories: self.histories.models }),\n                buttons: {\n                    Import: function Import() {\n                        self.importCurrentIntoHistory();\n                    },\n                    Close: function Close() {\n                        Galaxy.modal.hide();\n                    }\n                }\n            });\n        });\n    },\n\n    refreshUserHistoriesList: function refreshUserHistoriesList(callback) {\n        var self = this;\n        this.histories = new _libraryModel2.default.GalaxyHistories();\n        this.histories.fetch({\n            success: function success(histories) {\n                if (histories.length === 0) {\n                    _toastr2.default.warning(\"You have to create history first. Click this to do so.\", \"\", {\n                        onclick: function onclick() {\n                            window.location = Galaxy.root;\n                        }\n                    });\n                } else {\n                    callback(self);\n                }\n            },\n            error: function error(model, response) {\n                if (typeof response.responseJSON !== \"undefined\") {\n                    _toastr2.default.error(response.responseJSON.err_msg);\n                } else {\n                    _toastr2.default.error(\"An error occurred.\");\n                }\n            }\n        });\n    },\n\n    importCurrentIntoHistory: function importCurrentIntoHistory() {\n        this.modal.disableButton(\"Import\");\n        var new_history_name = this.modal.$(\"input[name=history_name]\").val();\n        var self = this;\n        if (new_history_name !== \"\") {\n            $.post(Galaxy.root + \"api/histories\", {\n                name: new_history_name\n            }).done(function (new_history) {\n                self.processImportToHistory(new_history.id);\n            }).fail(function (xhr, status, error) {\n                _toastr2.default.error(\"An error occurred.\");\n            }).always(function () {\n                self.modal.enableButton(\"Import\");\n            });\n        } else {\n            var history_id = $(this.modal.$el).find(\"select[name=dataset_import_single] option:selected\").val();\n            this.processImportToHistory(history_id);\n            this.modal.enableButton(\"Import\");\n        }\n    },\n\n    processImportToHistory: function processImportToHistory(history_id) {\n        var historyItem = new _libraryModel2.default.HistoryItem();\n        historyItem.url = historyItem.urlRoot + history_id + \"/contents\";\n        // set the used history as current so user will see the last one\n        // that he imported into in the history panel on the 'analysis' page\n        jQuery.getJSON(Galaxy.root + \"history/set_as_current?id=\" + history_id);\n        // save the dataset into selected history\n        historyItem.save({ content: this.id, source: \"library\" }, {\n            success: function success() {\n                Galaxy.modal.hide();\n                _toastr2.default.success(\"Dataset imported. Click this to start analyzing it.\", \"\", {\n                    onclick: function onclick() {\n                        window.location = Galaxy.root;\n                    }\n                });\n            },\n            error: function error(model, response) {\n                if (typeof response.responseJSON !== \"undefined\") {\n                    _toastr2.default.error(\"Dataset not imported. \" + response.responseJSON.err_msg);\n                } else {\n                    _toastr2.default.error(\"An error occured. Dataset not imported. Please try again.\");\n                }\n            }\n        });\n    },\n\n    showPermissions: function showPermissions(options) {\n        var template = this.templateDatasetPermissions();\n        var self = this;\n        this.options = _.extend(this.options, options);\n        $(\".tooltip\").remove();\n        if (this.options.fetched_permissions !== undefined) {\n            if (this.options.fetched_permissions.access_dataset_roles.length === 0) {\n                this.model.set({ is_unrestricted: true });\n            } else {\n                this.model.set({ is_unrestricted: false });\n            }\n        }\n        this.$el.html(template({\n            item: this.model,\n            is_admin: Galaxy.config.is_admin_user\n        }));\n        $.get(Galaxy.root + \"api/libraries/datasets/\" + self.id + \"/permissions?scope=current\").done(function (fetched_permissions) {\n            self.prepareSelectBoxes({\n                fetched_permissions: fetched_permissions,\n                is_admin: Galaxy.config.is_admin_user\n            });\n        }).fail(function () {\n            _toastr2.default.error(\"An error occurred while attempting to fetch dataset permissions.\");\n        });\n        $(\"#center [data-toggle]\").tooltip();\n        $(\"#center\").css(\"overflow\", \"auto\");\n    },\n\n    _serializeRoles: function _serializeRoles(role_list) {\n        var selected_roles = [];\n        for (var i = 0; i < role_list.length; i++) {\n            // Replace the : and , in role's name since these are select2 separators for initialData\n            selected_roles.push(role_list[i][1] + \":\" + role_list[i][0].replace(\":\", \" \").replace(\",\", \" &\"));\n        }\n        return selected_roles;\n    },\n\n    prepareSelectBoxes: function prepareSelectBoxes(options) {\n        this.options = _.extend(this.options, options);\n        this.accessSelectObject = new _uiSelect2.default.View(this._generate_select_options({\n            selector: \"access_perm\",\n            initialData: this._serializeRoles(this.options.fetched_permissions.access_dataset_roles)\n        }));\n        this.modifySelectObject = new _uiSelect2.default.View(this._generate_select_options({\n            selector: \"modify_perm\",\n            initialData: this._serializeRoles(this.options.fetched_permissions.modify_item_roles)\n        }));\n        this.manageSelectObject = new _uiSelect2.default.View(this._generate_select_options({\n            selector: \"manage_perm\",\n            initialData: this._serializeRoles(this.options.fetched_permissions.manage_dataset_roles)\n        }));\n    },\n\n    _generate_select_options: function _generate_select_options(options) {\n        var select_options = {\n            minimumInputLength: 0,\n            multiple: true,\n            placeholder: \"Click to select a role\",\n            formatResult: function roleFormatResult(role) {\n                return role.name + \" type: \" + role.type;\n            },\n            formatSelection: function roleFormatSelection(role) {\n                return role.name;\n            },\n            initSelection: function initSelection(element, callback) {\n                // the input tag has a value attribute preloaded that points to a preselected role's id\n                // this function resolves that id attribute to an object that select2 can render\n                // using its formatResult renderer - that way the role name is shown preselected\n                var data = [];\n                $(element.val().split(\",\")).each(function () {\n                    var item = this.split(\":\");\n                    data.push({\n                        id: item[0],\n                        name: item[1]\n                    });\n                });\n                callback(data);\n            },\n            dropdownCssClass: \"bigdrop\" // apply css that makes the dropdown taller\n        };\n        select_options.container = this.$el.find(\"#\" + options.selector);\n        select_options.css = options.selector;\n        select_options.initialData = options.initialData.join(\",\");\n        select_options.ajax = {\n            url: Galaxy.root + \"api/libraries/datasets/\" + this.id + \"/permissions?scope=available\",\n            dataType: \"json\",\n            quietMillis: 100,\n            data: function data(term, page) {\n                // page is the one-based page number tracked by Select2\n                return {\n                    q: term, //search term\n                    page_limit: 10, // page size, should be same as used in 'more' variable below\n                    page: page // page number\n                };\n            },\n            results: function results(data, page) {\n                var more = page * 10 < data.total; // whether or not there are more results available\n                // notice we return the value of more so Select2 knows if more results can be loaded\n                return { results: data.roles, more: more };\n            }\n        };\n        return select_options;\n    },\n\n    /**\n     * Save the changes made to the library dataset.\n     */\n    saveModifications: function saveModifications(options) {\n        var is_changed = false;\n        var ld = this.model;\n        var new_name = this.$el.find(\".input_dataset_name\").val();\n        if (typeof new_name !== \"undefined\" && new_name !== ld.get(\"name\")) {\n            if (new_name.length > 0) {\n                ld.set(\"name\", new_name);\n                is_changed = true;\n            } else {\n                _toastr2.default.warning(\"Library dataset name has to be at least 1 character long.\");\n                return;\n            }\n        }\n        var new_info = this.$el.find(\".input_dataset_misc_info\").val();\n        if (typeof new_info !== \"undefined\" && new_info !== ld.get(\"misc_info\")) {\n            ld.set(\"misc_info\", new_info);\n            is_changed = true;\n        }\n        var new_genome_build = this.select_genome.$el.select2(\"data\").id;\n        if (typeof new_genome_build !== \"undefined\" && new_genome_build !== ld.get(\"genome_build\")) {\n            ld.set(\"genome_build\", new_genome_build);\n            is_changed = true;\n        }\n        var new_ext = this.select_extension.$el.select2(\"data\").id;\n        if (typeof new_ext !== \"undefined\" && new_ext !== ld.get(\"file_ext\")) {\n            ld.set(\"file_ext\", new_ext);\n            is_changed = true;\n        }\n        var dataset_view = this;\n        if (is_changed) {\n            ld.save(null, {\n                patch: true,\n                success: function success(ld) {\n                    dataset_view.render();\n                    _toastr2.default.success(\"Changes to library dataset saved.\");\n                },\n                error: function error(model, response) {\n                    if (typeof response.responseJSON !== \"undefined\") {\n                        _toastr2.default.error(response.responseJSON.err_msg);\n                    } else {\n                        _toastr2.default.error(\"An error occured while attempting to update the library dataset.\");\n                    }\n                }\n            });\n        } else {\n            dataset_view.render();\n            _toastr2.default.info(\"Nothing has changed.\");\n        }\n    },\n\n    copyToClipboard: function copyToClipboard(e) {\n        e.preventDefault();\n        var href = Backbone.history.location.href;\n        if (href.lastIndexOf(\"/permissions\") !== -1) {\n            href = href.substr(0, href.lastIndexOf(\"/permissions\"));\n        }\n        window.prompt(\"Copy to clipboard: Ctrl+C, Enter\", href);\n    },\n\n    makeDatasetPrivate: function makeDatasetPrivate() {\n        var self = this;\n        $.post(Galaxy.root + \"api/libraries/datasets/\" + self.id + \"/permissions?action=make_private\").done(function (fetched_permissions) {\n            self.model.set({ is_unrestricted: false });\n            self.showPermissions({\n                fetched_permissions: fetched_permissions\n            });\n            _toastr2.default.success(\"The dataset is now private to you.\");\n        }).fail(function () {\n            _toastr2.default.error(\"An error occurred while attempting to make dataset private.\");\n        });\n    },\n\n    removeDatasetRestrictions: function removeDatasetRestrictions() {\n        var self = this;\n        $.post(Galaxy.root + \"api/libraries/datasets/\" + self.id + \"/permissions?action=remove_restrictions\").done(function (fetched_permissions) {\n            self.model.set({ is_unrestricted: true });\n            self.showPermissions({\n                fetched_permissions: fetched_permissions\n            });\n            _toastr2.default.success(\"Access to this dataset is now unrestricted.\");\n        }).fail(function () {\n            _toastr2.default.error(\"An error occurred while attempting to make dataset unrestricted.\");\n        });\n    },\n\n    /**\n     * Extract the role ids from Select2 elements's 'data'\n     */\n    _extractIds: function _extractIds(roles_list) {\n        var ids_list = [];\n        for (var i = roles_list.length - 1; i >= 0; i--) {\n            ids_list.push(roles_list[i].id);\n        }\n        return ids_list;\n    },\n\n    /**\n     * Save the permissions for roles entered in the select boxes.\n     */\n    savePermissions: function savePermissions(event) {\n        var self = this;\n        var access_ids = this._extractIds(this.accessSelectObject.$el.select2(\"data\"));\n        var manage_ids = this._extractIds(this.manageSelectObject.$el.select2(\"data\"));\n        var modify_ids = this._extractIds(this.modifySelectObject.$el.select2(\"data\"));\n        $.post(Galaxy.root + \"api/libraries/datasets/\" + self.id + \"/permissions?action=set_permissions\", {\n            \"access_ids[]\": access_ids,\n            \"manage_ids[]\": manage_ids,\n            \"modify_ids[]\": modify_ids\n        }).done(function (fetched_permissions) {\n            self.showPermissions({\n                fetched_permissions: fetched_permissions\n            });\n            _toastr2.default.success(\"Permissions saved.\");\n        }).fail(function () {\n            _toastr2.default.error(\"An error occurred while attempting to set dataset permissions.\");\n        });\n    },\n\n    /**\n     * If needed request all extensions and/or genomes from Galaxy\n     * and save them in sorted arrays.\n     */\n    fetchExtAndGenomes: function fetchExtAndGenomes() {\n        var self = this;\n        if (this.list_genomes.length == 0) {\n            _utils2.default.get({\n                url: Galaxy.root + \"api/datatypes?extension_only=False\",\n                success: function success(datatypes) {\n                    for (var key in datatypes) {\n                        self.list_extensions.push({\n                            id: datatypes[key].extension,\n                            text: datatypes[key].extension,\n                            description: datatypes[key].description,\n                            description_url: datatypes[key].description_url\n                        });\n                    }\n                    self.list_extensions.sort(function (a, b) {\n                        return a.id > b.id ? 1 : a.id < b.id ? -1 : 0;\n                    });\n                    self.list_extensions.unshift(self.auto);\n                }\n            });\n        }\n        if (this.list_extensions.length == 0) {\n            _utils2.default.get({\n                url: Galaxy.root + \"api/genomes\",\n                success: function success(genomes) {\n                    for (var key in genomes) {\n                        self.list_genomes.push({\n                            id: genomes[key][1],\n                            text: genomes[key][0]\n                        });\n                    }\n                    self.list_genomes.sort(function (a, b) {\n                        return a.id > b.id ? 1 : a.id < b.id ? -1 : 0;\n                    });\n                }\n            });\n        }\n    },\n\n    renderSelectBoxes: function renderSelectBoxes(options) {\n        // This won't work properly unlesss we already have the data fetched.\n        // See this.fetchExtAndGenomes()\n        // TODO switch to common resources:\n        // https://trello.com/c/dIUE9YPl/1933-ui-common-resources-and-data-into-galaxy-object\n        var self = this;\n        var current_genome = \"?\";\n        var current_ext = \"auto\";\n        if (typeof options !== \"undefined\") {\n            if (typeof options.genome_build !== \"undefined\") {\n                current_genome = options.genome_build;\n            }\n            if (typeof options.file_ext !== \"undefined\") {\n                current_ext = options.file_ext;\n            }\n        }\n        this.select_genome = new _uiSelect2.default.View({\n            css: \"dataset-genome-select\",\n            data: self.list_genomes,\n            container: self.$el.find(\"#dataset_genome_select\"),\n            value: current_genome\n        });\n        this.select_extension = new _uiSelect2.default.View({\n            css: \"dataset-extension-select\",\n            data: self.list_extensions,\n            container: self.$el.find(\"#dataset_extension_select\"),\n            value: current_ext\n        });\n    },\n\n    templateDataset: function templateDataset() {\n        return _.template([\n        // CONTAINER START\n        '<div class=\"library_style_container\">', '<div id=\"library_toolbar\">', '<button data-toggle=\"tooltip\" data-placement=\"top\" title=\"Download dataset\" class=\"btn btn-default toolbtn-download-dataset primary-button toolbar-item\" type=\"button\">', '<span class=\"fa fa-download\"></span>', \"&nbsp;Download\", \"</button>\", '<button data-toggle=\"tooltip\" data-placement=\"top\" title=\"Import dataset into history\" class=\"btn btn-default toolbtn-import-dataset primary-button toolbar-item\" type=\"button\">', '<span class=\"fa fa-book\"></span>', \"&nbsp;to History\", \"</button>\", '<% if (item.get(\"can_user_modify\")) { %>', '<button data-toggle=\"tooltip\" data-placement=\"top\" title=\"Modify library item\" class=\"btn btn-default toolbtn_modify_dataset primary-button toolbar-item\" type=\"button\">', '<span class=\"fa fa-pencil\"></span>', \"&nbsp;Modify\", \"</button>\", \"<% } %>\", '<% if (item.get(\"can_user_manage\")) { %>', '<a href=\"#folders/<%- item.get(\"folder_id\") %>/datasets/<%- item.id %>/permissions\">', '<button data-toggle=\"tooltip\" data-placement=\"top\" title=\"Manage permissions\" class=\"btn btn-default toolbtn_change_permissions primary-button toolbar-item\" type=\"button\">', '<span class=\"fa fa-group\"></span>', \"&nbsp;Permissions\", \"</button>\", \"</a>\", \"<% } %>\", \"</div>\",\n\n        // BREADCRUMBS\n        '<ol class=\"breadcrumb\">', '<li><a title=\"Return to the list of libraries\" href=\"#\">Libraries</a></li>', '<% _.each(item.get(\"full_path\"), function(path_item) { %>', \"<% if (path_item[0] != item.id) { %>\", '<li><a title=\"Return to this folder\" href=\"#/folders/<%- path_item[0] %>\"><%- path_item[1] %></a> </li> ', \"<% } else { %>\", '<li class=\"active\"><span title=\"You are here\"><%- path_item[1] %></span></li>', \"<% } %>\", \"<% }); %>\", \"</ol>\", '<% if (item.get(\"is_unrestricted\")) { %>', \"<div>\", 'This dataset is unrestricted so everybody with the link can access it. Just share <span class=\"copy-link-to-clipboard\"><a href=\"\"a>this page</a></span>.', \"</div>\", \"<% } %>\",\n\n        // TABLE START\n        '<div class=\"dataset_table\">', '<table class=\"grid table table-striped table-condensed\">', \"<tr>\", '<th class=\"dataset-first-column\" scope=\"row\" id=\"id_row\" data-id=\"<%= _.escape(item.get(\"ldda_id\")) %>\">Name</th>', '<td><%= _.escape(item.get(\"name\")) %></td>', \"</tr>\", '<% if (item.get(\"file_ext\")) { %>', \"<tr>\", '<th scope=\"row\">Data type</th>', '<td><%= _.escape(item.get(\"file_ext\")) %></td>', \"</tr>\", \"<% } %>\", '<% if (item.get(\"genome_build\")) { %>', \"<tr>\", '<th scope=\"row\">Genome build</th>', '<td><%= _.escape(item.get(\"genome_build\")) %></td>', \"</tr>\", \"<% } %>\", '<% if (item.get(\"file_size\")) { %>', \"<tr>\", '<th scope=\"row\">Size</th>', '<td><%= _.escape(item.get(\"file_size\")) %></td>', \"</tr>\", \"<% } %>\", '<% if (item.get(\"date_uploaded\")) { %>', \"<tr>\", '<th scope=\"row\">Date uploaded (UTC)</th>', '<td><%= _.escape(item.get(\"date_uploaded\")) %></td>', \"</tr>\", \"<% } %>\", '<% if (item.get(\"uploaded_by\")) { %>', \"<tr>\", '<th scope=\"row\">Uploaded by</th>', '<td><%= _.escape(item.get(\"uploaded_by\")) %></td>', \"</tr>\", \"<% } %>\", '<% if (item.get(\"metadata_data_lines\")) { %>', \"<tr>\", '<th scope=\"row\">Data Lines</th>', '<td scope=\"row\"><%= _.escape(item.get(\"metadata_data_lines\")) %></td>', \"</tr>\", \"<% } %>\", '<% if (item.get(\"metadata_comment_lines\")) { %>', \"<tr>\", '<th scope=\"row\">Comment Lines</th>', '<td scope=\"row\"><%= _.escape(item.get(\"metadata_comment_lines\")) %></td>', \"</tr>\", \"<% } %>\", '<% if (item.get(\"metadata_columns\")) { %>', \"<tr>\", '<th scope=\"row\">Number of Columns</th>', '<td scope=\"row\"><%= _.escape(item.get(\"metadata_columns\")) %></td>', \"</tr>\", \"<% } %>\", '<% if (item.get(\"metadata_column_types\")) { %>', \"<tr>\", '<th scope=\"row\">Column Types</th>', '<td scope=\"row\"><%= _.escape(item.get(\"metadata_column_types\")) %></td>', \"</tr>\", \"<% } %>\", '<% if (item.get(\"message\")) { %>', \"<tr>\", '<th scope=\"row\">Message</th>', '<td scope=\"row\"><%= _.escape(item.get(\"message\")) %></td>', \"</tr>\", \"<% } %>\", '<% if (item.get(\"misc_blurb\")) { %>', \"<tr>\", '<th scope=\"row\">Misc. blurb</th>', '<td scope=\"row\"><%= _.escape(item.get(\"misc_blurb\")) %></td>', \"</tr>\", \"<% } %>\", '<% if (item.get(\"misc_info\")) { %>', \"<tr>\", '<th scope=\"row\">Misc. info</th>', '<td scope=\"row\"><%= _.escape(item.get(\"misc_info\")) %></td>', \"</tr>\", \"<% } %>\", '<% if (item.get(\"tags\")) { %>', \"<tr>\", '<th scope=\"row\">Tags</th>', '<td scope=\"row\"><%= _.escape(item.get(\"tags\")) %></td>', \"</tr>\", \"<% } %>\", '<% if ( item.get(\"uuid\") !== \"ok\" ) { %>', \"<tr>\", '<th scope=\"row\">UUID</th>', '<td scope=\"row\"><%= _.escape(item.get(\"uuid\")) %></td>', \"</tr>\", \"<% } %>\", '<% if ( item.get(\"state\") !== \"ok\" ) { %>', \"<tr>\", '<th scope=\"row\">State</th>', '<td scope=\"row\"><%= _.escape(item.get(\"state\")) %></td>', \"</tr>\", \"<% } %>\", \"</table>\", '<% if (item.get(\"job_stderr\")) { %>', \"<h4>Job Standard Error</h4>\", '<pre class=\"code\">', '<%= _.escape(item.get(\"job_stderr\")) %>', \"</pre>\", \"<% } %>\", '<% if (item.get(\"job_stdout\")) { %>', \"<h4>Job Standard Output</h4>\", '<pre class=\"code\">', '<%= _.escape(item.get(\"job_stdout\")) %>', \"</pre>\", \"<% } %>\", \"<div>\", '<pre class=\"peek\">', \"</pre>\", \"</div>\", '<% if (item.get(\"has_versions\")) { %>', \"<div>\", \"<h3>Expired versions:</h3>\", \"<ul>\", '<% _.each(item.get(\"expired_versions\"), function(version) { %>', '<li><a title=\"See details of this version\" href=\"#folders/<%- item.get(\"folder_id\") %>/datasets/<%- item.id %>/versions/<%- version[0] %>\"><%- version[1] %></a></li>', \"<% }) %>\", \"<ul>\", \"</div>\", \"<% } %>\",\n        // TABLE END\n        \"</div>\",\n        // CONTAINER END\n        \"</div>\"].join(\"\"));\n    },\n\n    templateVersion: function templateVersion() {\n        return _.template([\n        // CONTAINER START\n        '<div class=\"library_style_container\">', '<div id=\"library_toolbar\">', '<a href=\"#folders/<%- item.get(\"folder_id\") %>/datasets/<%- item.id %>\">', '<button data-toggle=\"tooltip\" data-placement=\"top\" title=\"Go to latest dataset\" class=\"btn btn-default primary-button toolbar-item\" type=\"button\">', '<span class=\"fa fa-caret-left fa-lg\"></span>', \"&nbsp;Latest dataset\", \"</button>\", \"<a>\", \"</div>\",\n\n        // BREADCRUMBS\n        '<ol class=\"breadcrumb\">', '<li><a title=\"Return to the list of libraries\" href=\"#\">Libraries</a></li>', '<% _.each(item.get(\"full_path\"), function(path_item) { %>', \"<% if (path_item[0] != item.id) { %>\", '<li><a title=\"Return to this folder\" href=\"#/folders/<%- path_item[0] %>\"><%- path_item[1] %></a> </li> ', \"<% } else { %>\", '<li class=\"active\"><span title=\"You are here\"><%- path_item[1] %></span></li>', \"<% } %>\", \"<% }); %>\", \"</ol>\", '<div class=\"alert alert-warning\">This is an expired version of the library dataset: <%= _.escape(item.get(\"name\")) %></div>',\n        // DATASET START\n        '<div class=\"dataset_table\">', '<table class=\"grid table table-striped table-condensed\">', \"<tr>\", '<th scope=\"row\" id=\"id_row\" data-id=\"<%= _.escape(ldda.id) %>\">Name</th>', '<td><%= _.escape(ldda.get(\"name\")) %></td>', \"</tr>\", '<% if (ldda.get(\"file_ext\")) { %>', \"<tr>\", '<th scope=\"row\">Data type</th>', '<td><%= _.escape(ldda.get(\"file_ext\")) %></td>', \"</tr>\", \"<% } %>\", '<% if (ldda.get(\"genome_build\")) { %>', \"<tr>\", '<th scope=\"row\">Genome build</th>', '<td><%= _.escape(ldda.get(\"genome_build\")) %></td>', \"</tr>\", \"<% } %>\", '<% if (ldda.get(\"file_size\")) { %>', \"<tr>\", '<th scope=\"row\">Size</th>', '<td><%= _.escape(ldda.get(\"file_size\")) %></td>', \"</tr>\", \"<% } %>\", '<% if (ldda.get(\"date_uploaded\")) { %>', \"<tr>\", '<th scope=\"row\">Date uploaded (UTC)</th>', '<td><%= _.escape(ldda.get(\"date_uploaded\")) %></td>', \"</tr>\", \"<% } %>\", '<% if (ldda.get(\"uploaded_by\")) { %>', \"<tr>\", '<th scope=\"row\">Uploaded by</th>', '<td><%= _.escape(ldda.get(\"uploaded_by\")) %></td>', \"</tr>\", \"<% } %>\", '<% if (ldda.get(\"metadata_data_lines\")) { %>', \"<tr>\", '<th scope=\"row\">Data Lines</th>', '<td scope=\"row\"><%= _.escape(ldda.get(\"metadata_data_lines\")) %></td>', \"</tr>\", \"<% } %>\", '<% if (ldda.get(\"metadata_comment_lines\")) { %>', \"<tr>\", '<th scope=\"row\">Comment Lines</th>', '<td scope=\"row\"><%= _.escape(ldda.get(\"metadata_comment_lines\")) %></td>', \"</tr>\", \"<% } %>\", '<% if (ldda.get(\"metadata_columns\")) { %>', \"<tr>\", '<th scope=\"row\">Number of Columns</th>', '<td scope=\"row\"><%= _.escape(ldda.get(\"metadata_columns\")) %></td>', \"</tr>\", \"<% } %>\", '<% if (ldda.get(\"metadata_column_types\")) { %>', \"<tr>\", '<th scope=\"row\">Column Types</th>', '<td scope=\"row\"><%= _.escape(ldda.get(\"metadata_column_types\")) %></td>', \"</tr>\", \"<% } %>\", '<% if (ldda.get(\"message\")) { %>', \"<tr>\", '<th scope=\"row\">Message</th>', '<td scope=\"row\"><%= _.escape(ldda.get(\"message\")) %></td>', \"</tr>\", \"<% } %>\", '<% if (ldda.get(\"misc_blurb\")) { %>', \"<tr>\", '<th scope=\"row\">Miscellaneous blurb</th>', '<td scope=\"row\"><%= _.escape(ldda.get(\"misc_blurb\")) %></td>', \"</tr>\", \"<% } %>\", '<% if (ldda.get(\"misc_info\")) { %>', \"<tr>\", '<th scope=\"row\">Miscellaneous information</th>', '<td scope=\"row\"><%= _.escape(ldda.get(\"misc_info\")) %></td>', \"</tr>\", \"<% } %>\", '<% if (item.get(\"tags\")) { %>', \"<tr>\", '<th scope=\"row\">Tags</th>', '<td scope=\"row\"><%= _.escape(item.get(\"tags\")) %></td>', \"</tr>\", \"<% } %>\", \"</table>\", \"<div>\", '<pre class=\"peek\">', \"</pre>\", \"</div>\",\n        // DATASET END\n        \"</div>\",\n        // CONTAINER END\n        \"</div>\"].join(\"\"));\n    },\n\n    templateModifyDataset: function templateModifyDataset() {\n        return _.template([\n        // CONTAINER START\n        '<div class=\"library_style_container\">', '<div id=\"library_toolbar\">', '<button data-toggle=\"tooltip\" data-placement=\"top\" title=\"Cancel modifications\" class=\"btn btn-default toolbtn_cancel_modifications primary-button toolbar-item\" type=\"button\">', '<span class=\"fa fa-times\"></span>', \"&nbsp;Cancel\", \"</button>\", '<button data-toggle=\"tooltip\" data-placement=\"top\" title=\"Save modifications\" class=\"btn btn-default toolbtn_save_modifications primary-button toolbar-item\" type=\"button\">', '<span class=\"fa fa-floppy-o\"></span>', \"&nbsp;Save\", \"</button>\", \"</div>\",\n\n        // BREADCRUMBS\n        '<ol class=\"breadcrumb\">', '<li><a title=\"Return to the list of libraries\" href=\"#\">Libraries</a></li>', '<% _.each(item.get(\"full_path\"), function(path_item) { %>', \"<% if (path_item[0] != item.id) { %>\", '<li><a title=\"Return to this folder\" href=\"#/folders/<%- path_item[0] %>\"><%- path_item[1] %></a> </li> ', \"<% } else { %>\", '<li class=\"active\"><span title=\"You are here\"><%- path_item[1] %></span></li>', \"<% } %>\", \"<% }); %>\", \"</ol>\", '<div class=\"dataset_table\">', '<table class=\"grid table table-striped table-condensed\">', \"<tr>\", '<th class=\"dataset-first-column\" scope=\"row\" id=\"id_row\" data-id=\"<%= _.escape(item.get(\"ldda_id\")) %>\">Name</th>', '<td><input class=\"input_dataset_name form-control\" type=\"text\" placeholder=\"name\" value=\"<%= _.escape(item.get(\"name\")) %>\"></td>', \"</tr>\", \"<tr>\", '<th scope=\"row\">Data type</th>', \"<td>\", '<span id=\"dataset_extension_select\" class=\"dataset-extension-select\" />', \"</td>\", \"</tr>\", \"<tr>\", '<th scope=\"row\">Genome build</th>', \"<td>\", '<span id=\"dataset_genome_select\" class=\"dataset-genome-select\" />', \"</td>\", \"</tr>\", \"<tr>\", '<th scope=\"row\">Size</th>', '<td><%= _.escape(item.get(\"file_size\")) %></td>', \"</tr>\", \"<tr>\", '<th scope=\"row\">Date uploaded (UTC)</th>', '<td><%= _.escape(item.get(\"date_uploaded\")) %></td>', \"</tr>\", \"<tr>\", '<th scope=\"row\">Uploaded by</th>', '<td><%= _.escape(item.get(\"uploaded_by\")) %></td>', \"</tr>\", '<tr scope=\"row\">', '<th scope=\"row\">Data Lines</th>', '<td scope=\"row\"><%= _.escape(item.get(\"metadata_data_lines\")) %></td>', \"</tr>\", '<th scope=\"row\">Comment Lines</th>', '<% if (item.get(\"metadata_comment_lines\") === \"\") { %>', '<td scope=\"row\"><%= _.escape(item.get(\"metadata_comment_lines\")) %></td>', \"<% } else { %>\", '<td scope=\"row\">unknown</td>', \"<% } %>\", \"</tr>\", \"<tr>\", '<th scope=\"row\">Number of Columns</th>', '<td scope=\"row\"><%= _.escape(item.get(\"metadata_columns\")) %></td>', \"</tr>\", \"<tr>\", '<th scope=\"row\">Column Types</th>', '<td scope=\"row\"><%= _.escape(item.get(\"metadata_column_types\")) %></td>', \"</tr>\", \"<tr>\", '<th scope=\"row\">Message</th>', '<td scope=\"row\"><%= _.escape(item.get(\"message\")) %></td>', \"</tr>\", \"<tr>\", '<th scope=\"row\">Misc. blurb</th>', '<td scope=\"row\"><%= _.escape(item.get(\"misc_blurb\")) %></td>', \"</tr>\", \"<tr>\", '<th scope=\"row\">Misc. information</th>', '<td><input class=\"input_dataset_misc_info form-control\" type=\"text\" placeholder=\"info\" value=\"<%= _.escape(item.get(\"misc_info\")) %>\"></td>', \"</tr>\",\n        //TODO: add functionality to modify tags here\n        '<% if (item.get(\"tags\")) { %>', \"<tr>\", '<th scope=\"row\">Tags</th>', '<td scope=\"row\"><%= _.escape(item.get(\"tags\")) %></td>', \"</tr>\", \"<% } %>\", \"</table>\", \"<div>\", '<pre class=\"peek\">', \"</pre>\", \"</div>\", \"</div>\",\n        // CONTAINER END\n        \"</div>\"].join(\"\"));\n    },\n\n    templateDatasetPermissions: function templateDatasetPermissions() {\n        return _.template([\n        // CONTAINER START\n        '<div class=\"library_style_container\">', '<div id=\"library_toolbar\">', '<a href=\"#folders/<%- item.get(\"folder_id\") %>/datasets/<%- item.id %>\">', '<button data-toggle=\"tooltip\" data-placement=\"top\" title=\"Go back to dataset\" class=\"btn btn-default primary-button toolbar-item\" type=\"button\">', '<span class=\"fa fa-file-o\"></span>', \"&nbsp;Dataset Details\", \"</button>\", \"<a>\", \"</div>\",\n\n        // BREADCRUMBS\n        '<ol class=\"breadcrumb\">', '<li><a title=\"Return to the list of libraries\" href=\"#\">Libraries</a></li>', '<% _.each(item.get(\"full_path\"), function(path_item) { %>', \"<% if (path_item[0] != item.id) { %>\", '<li><a title=\"Return to this folder\" href=\"#/folders/<%- path_item[0] %>\"><%- path_item[1] %></a> </li> ', \"<% } else { %>\", '<li class=\"active\"><span title=\"You are here\"><%- path_item[1] %></span></li>', \"<% } %>\", \"<% }); %>\", \"</ol>\", '<h1>Dataset: <%= _.escape(item.get(\"name\")) %></h1>', '<div class=\"alert alert-warning\">', \"<% if (is_admin) { %>\", \"You are logged in as an <strong>administrator</strong> therefore you can manage any dataset on this Galaxy instance. Please make sure you understand the consequences.\", \"<% } else { %>\", \"You can assign any number of roles to any of the following permission types. However please read carefully the implications of such actions.\", \"<% } %>\", \"</div>\", '<div class=\"dataset_table\">', \"<h2>Library-related permissions</h2>\", \"<h4>Roles that can modify the library item</h4>\", '<div id=\"modify_perm\" class=\"modify_perm roles-selection\"></div>', '<div class=\"alert alert-info roles-selection\">User with <strong>any</strong> of these roles can modify name, metadata, and other information about this library item.</div>', \"<hr/>\", \"<h2>Dataset-related permissions</h2>\", '<div class=\"alert alert-warning\">Changes made below will affect <strong>every</strong> library item that was created from this dataset and also every history this dataset is part of.</div>', '<% if (!item.get(\"is_unrestricted\")) { %>', '<p>You can <span class=\"remove-restrictions\"><a href=\"\">remove all access restrictions</a></span> on this dataset.</p>', \"<% } else { %>\", '<p>You can <span class=\"make-private\"><a href=\"\">make this dataset private</a></span> to you.</p>', \"<% } %>\", \"<h4>Roles that can access the dataset</h4>\", '<div id=\"access_perm\" class=\"access_perm roles-selection\"></div>', '<div class=\"alert alert-info roles-selection\">', \"User has to have <strong>all these roles</strong> in order to access this dataset.\", \" Users without access permission <strong>cannot</strong> have other permissions on this dataset.\", \" If there are no access roles set on the dataset it is considered <strong>unrestricted</strong>.\", \"</div>\", \"<h4>Roles that can manage permissions on the dataset</h4>\", '<div id=\"manage_perm\" class=\"manage_perm roles-selection\"></div>', '<div class=\"alert alert-info roles-selection\">', \"User with <strong>any</strong> of these roles can manage permissions of this dataset. If you remove yourself you will lose the ability manage this dataset unless you are an admin.\", \"</div>\", '<button data-toggle=\"tooltip\" data-placement=\"top\" title=\"Save modifications made on this page\" class=\"btn btn-default toolbtn_save_permissions primary-button\" type=\"button\">', '<span class=\"fa fa-floppy-o\"></span>', \"&nbsp;Save\", \"</button>\", \"</div>\",\n        // CONTAINER END\n        \"</div>\"].join(\"\"));\n    },\n\n    templateBulkImportInModal: function templateBulkImportInModal() {\n        return _.template([\"<div>\", '<div class=\"library-modal-item\">', \"Select history: \", '<select id=\"dataset_import_single\" name=\"dataset_import_single\" style=\"width:50%; margin-bottom: 1em; \" autofocus>', \"<% _.each(histories, function(history) { %>\", '<option value=\"<%= _.escape(history.get(\"id\")) %>\"><%= _.escape(history.get(\"name\")) %></option>', \"<% }); %>\", \"</select>\", \"</div>\", '<div class=\"library-modal-item\">', \"or create new: \", '<input type=\"text\" name=\"history_name\" value=\"\" placeholder=\"name of the new history\" style=\"width:50%;\">', \"</input>\", \"</div>\", \"</div>\"].join(\"\"));\n    }\n});\n\nexports.default = {\n    LibraryDatasetView: LibraryDatasetView\n};\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! libs/backbone */ 2), __webpack_require__(/*! underscore */ 1), __webpack_require__(/*! jquery */ 0), __webpack_require__(/*! jquery */ 0)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTI3LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL2dhbGF4eS9zY3JpcHRzL212Yy9saWJyYXJ5L2xpYnJhcnktZGF0YXNldC12aWV3LmpzPzY2MjEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IF9sIGZyb20gXCJ1dGlscy9sb2NhbGl6YXRpb25cIjtcbmltcG9ydCBtb2RfdG9hc3RyIGZyb20gXCJsaWJzL3RvYXN0clwiO1xuaW1wb3J0IG1vZF9saWJyYXJ5X21vZGVsIGZyb20gXCJtdmMvbGlicmFyeS9saWJyYXJ5LW1vZGVsXCI7XG5pbXBvcnQgbW9kX3V0aWxzIGZyb20gXCJ1dGlscy91dGlsc1wiO1xuaW1wb3J0IG1vZF9zZWxlY3QgZnJvbSBcIm12Yy91aS91aS1zZWxlY3RcIjtcbnZhciBMaWJyYXJ5RGF0YXNldFZpZXcgPSBCYWNrYm9uZS5WaWV3LmV4dGVuZCh7XG4gICAgZWw6IFwiI2NlbnRlclwiLFxuXG4gICAgbW9kZWw6IG51bGwsXG5cbiAgICBvcHRpb25zOiB7fSxcblxuICAgIGRlZmF1bHRzOiB7XG4gICAgICAgIGVkaXRfbW9kZTogZmFsc2VcbiAgICB9LFxuXG4gICAgZXZlbnRzOiB7XG4gICAgICAgIFwiY2xpY2sgLnRvb2xidG5fbW9kaWZ5X2RhdGFzZXRcIjogXCJlbmFibGVNb2RpZmljYXRpb25cIixcbiAgICAgICAgXCJjbGljayAudG9vbGJ0bl9jYW5jZWxfbW9kaWZpY2F0aW9uc1wiOiBcInJlbmRlclwiLFxuICAgICAgICBcImNsaWNrIC50b29sYnRuLWRvd25sb2FkLWRhdGFzZXRcIjogXCJkb3dubG9hZERhdGFzZXRcIixcbiAgICAgICAgXCJjbGljayAudG9vbGJ0bi1pbXBvcnQtZGF0YXNldFwiOiBcImltcG9ydEludG9IaXN0b3J5XCIsXG4gICAgICAgIFwiY2xpY2sgLmNvcHktbGluay10by1jbGlwYm9hcmRcIjogXCJjb3B5VG9DbGlwYm9hcmRcIixcbiAgICAgICAgXCJjbGljayAubWFrZS1wcml2YXRlXCI6IFwibWFrZURhdGFzZXRQcml2YXRlXCIsXG4gICAgICAgIFwiY2xpY2sgLnJlbW92ZS1yZXN0cmljdGlvbnNcIjogXCJyZW1vdmVEYXRhc2V0UmVzdHJpY3Rpb25zXCIsXG4gICAgICAgIFwiY2xpY2sgLnRvb2xidG5fc2F2ZV9wZXJtaXNzaW9uc1wiOiBcInNhdmVQZXJtaXNzaW9uc1wiLFxuICAgICAgICBcImNsaWNrIC50b29sYnRuX3NhdmVfbW9kaWZpY2F0aW9uc1wiOiBcInNhdmVNb2RpZmljYXRpb25zXCJcbiAgICB9LFxuXG4gICAgLy8gZ2Vub21lIHNlbGVjdFxuICAgIHNlbGVjdF9nZW5vbWU6IG51bGwsXG5cbiAgICAvLyBleHRlbnNpb24gc2VsZWN0XG4gICAgc2VsZWN0X2V4dGVuc2lvbjogbnVsbCxcblxuICAgIC8vIGV4dGVuc2lvbiB0eXBlc1xuICAgIGxpc3RfZXh0ZW5zaW9uczogW10sXG5cbiAgICAvLyBkYXRhdHlwZSBwbGFjZWhvbGRlciBmb3IgZXh0ZW5zaW9uIGF1dG8tZGV0ZWN0aW9uXG4gICAgYXV0bzoge1xuICAgICAgICBpZDogXCJhdXRvXCIsXG4gICAgICAgIHRleHQ6IFwiQXV0by1kZXRlY3RcIixcbiAgICAgICAgZGVzY3JpcHRpb246XG4gICAgICAgICAgICBcIlRoaXMgc3lzdGVtIHdpbGwgdHJ5IHRvIGRldGVjdCB0aGUgZmlsZSB0eXBlIGF1dG9tYXRpY2FsbHkuXCIgK1xuICAgICAgICAgICAgXCIgSWYgeW91ciBmaWxlIGlzIG5vdCBkZXRlY3RlZCBwcm9wZXJseSBhcyBvbmUgb2YgdGhlIGtub3duIGZvcm1hdHMsXCIgK1xuICAgICAgICAgICAgXCIgaXQgbW9zdCBsaWtlbHkgbWVhbnMgdGhhdCBpdCBoYXMgc29tZSBmb3JtYXQgcHJvYmxlbXMgKGUuZy4sIGRpZmZlcmVudFwiICtcbiAgICAgICAgICAgIFwiIG51bWJlciBvZiBjb2x1bW5zIG9uIGRpZmZlcmVudCByb3dzKS4gWW91IGNhbiBzdGlsbCBjb2VyY2UgdGhlIHN5c3RlbVwiICtcbiAgICAgICAgICAgIFwiIHRvIHNldCB5b3VyIGRhdGEgdG8gdGhlIGZvcm1hdCB5b3UgdGhpbmsgaXQgc2hvdWxkIGJlLlwiICtcbiAgICAgICAgICAgIFwiIFlvdSBjYW4gYWxzbyB1cGxvYWQgY29tcHJlc3NlZCBmaWxlcywgd2hpY2ggd2lsbCBhdXRvbWF0aWNhbGx5IGJlIGRlY29tcHJlc3NlZC5cIlxuICAgIH0sXG5cbiAgICAvLyBnZW5vbWVzXG4gICAgbGlzdF9nZW5vbWVzOiBbXSxcblxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gXy5leHRlbmQodGhpcy5vcHRpb25zLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5mZXRjaEV4dEFuZEdlbm9tZXMoKTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5pZCkge1xuICAgICAgICAgICAgdGhpcy5mZXRjaERhdGFzZXQoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBmZXRjaERhdGFzZXQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gXy5leHRlbmQodGhpcy5vcHRpb25zLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5tb2RlbCA9IG5ldyBtb2RfbGlicmFyeV9tb2RlbC5JdGVtKHtcbiAgICAgICAgICAgIGlkOiB0aGlzLm9wdGlvbnMuaWRcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdGhpcy5tb2RlbC5mZXRjaCh7XG4gICAgICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5vcHRpb25zLnNob3dfcGVybWlzc2lvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5zaG93UGVybWlzc2lvbnMoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNlbGYub3B0aW9ucy5zaG93X3ZlcnNpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5mZXRjaFZlcnNpb24oKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnJlbmRlcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlcnJvcjogZnVuY3Rpb24obW9kZWwsIHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByZXNwb25zZS5yZXNwb25zZUpTT04gIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgbW9kX3RvYXN0ci5lcnJvcihgJHtyZXNwb25zZS5yZXNwb25zZUpTT04uZXJyX21zZ30gQ2xpY2sgdGhpcyB0byBnbyBiYWNrLmAsIFwiXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uY2xpY2s6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEdhbGF4eS5saWJyYXJpZXMubGlicmFyeV9yb3V0ZXIuYmFjaygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtb2RfdG9hc3RyLmVycm9yKFwiQW4gZXJyb3Igb2NjdXJyZWQuIENsaWNrIHRoaXMgdG8gZ28gYmFjay5cIiwgXCJcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgb25jbGljazogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgR2FsYXh5LmxpYnJhcmllcy5saWJyYXJ5X3JvdXRlci5iYWNrKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIHJlbmRlcjogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBfLmV4dGVuZCh0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuICAgICAgICAkKFwiLnRvb2x0aXBcIikucmVtb3ZlKCk7XG4gICAgICAgIHZhciB0ZW1wbGF0ZSA9IHRoaXMudGVtcGxhdGVEYXRhc2V0KCk7XG4gICAgICAgIHRoaXMuJGVsLmh0bWwodGVtcGxhdGUoeyBpdGVtOiB0aGlzLm1vZGVsIH0pKTtcbiAgICAgICAgJChcIi5wZWVrXCIpLmh0bWwodGhpcy5tb2RlbC5nZXQoXCJwZWVrXCIpKTtcbiAgICAgICAgJChcIiNjZW50ZXIgW2RhdGEtdG9nZ2xlXVwiKS50b29sdGlwKCk7XG4gICAgfSxcblxuICAgIGZldGNoVmVyc2lvbjogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBfLmV4dGVuZCh0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLmxkZGFfaWQpIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgICAgICAgICBtb2RfdG9hc3RyLmVycm9yKFwiTGlicmFyeSBkYXRhc2V0IHZlcnNpb24gcmVxdWVzdGVkIGJ1dCBubyBpZCBwcm92aWRlZC5cIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmxkZGEgPSBuZXcgbW9kX2xpYnJhcnlfbW9kZWwuTGRkYSh7XG4gICAgICAgICAgICAgICAgaWQ6IHRoaXMub3B0aW9ucy5sZGRhX2lkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMubGRkYS51cmwgPSBgJHt0aGlzLmxkZGEudXJsUm9vdCArIHRoaXMubW9kZWwuaWR9L3ZlcnNpb25zLyR7dGhpcy5sZGRhLmlkfWA7XG4gICAgICAgICAgICB0aGlzLmxkZGEuZmV0Y2goe1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnJlbmRlclZlcnNpb24oKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGVycm9yOiBmdW5jdGlvbihtb2RlbCwgcmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByZXNwb25zZS5yZXNwb25zZUpTT04gIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZF90b2FzdHIuZXJyb3IocmVzcG9uc2UucmVzcG9uc2VKU09OLmVycl9tc2cpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9kX3RvYXN0ci5lcnJvcihcIkFuIGVycm9yIG9jY3VycmVkLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHJlbmRlclZlcnNpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICAkKFwiLnRvb2x0aXBcIikucmVtb3ZlKCk7XG4gICAgICAgIHZhciB0ZW1wbGF0ZSA9IHRoaXMudGVtcGxhdGVWZXJzaW9uKCk7XG4gICAgICAgIHRoaXMuJGVsLmh0bWwodGVtcGxhdGUoeyBpdGVtOiB0aGlzLm1vZGVsLCBsZGRhOiB0aGlzLmxkZGEgfSkpO1xuICAgICAgICAkKFwiLnBlZWtcIikuaHRtbCh0aGlzLmxkZGEuZ2V0KFwicGVla1wiKSk7XG4gICAgfSxcblxuICAgIGVuYWJsZU1vZGlmaWNhdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgICQoXCIudG9vbHRpcFwiKS5yZW1vdmUoKTtcbiAgICAgICAgdmFyIHRlbXBsYXRlID0gdGhpcy50ZW1wbGF0ZU1vZGlmeURhdGFzZXQoKTtcbiAgICAgICAgdGhpcy4kZWwuaHRtbCh0ZW1wbGF0ZSh7IGl0ZW06IHRoaXMubW9kZWwgfSkpO1xuICAgICAgICB0aGlzLnJlbmRlclNlbGVjdEJveGVzKHtcbiAgICAgICAgICAgIGdlbm9tZV9idWlsZDogdGhpcy5tb2RlbC5nZXQoXCJnZW5vbWVfYnVpbGRcIiksXG4gICAgICAgICAgICBmaWxlX2V4dDogdGhpcy5tb2RlbC5nZXQoXCJmaWxlX2V4dFwiKVxuICAgICAgICB9KTtcbiAgICAgICAgJChcIi5wZWVrXCIpLmh0bWwodGhpcy5tb2RlbC5nZXQoXCJwZWVrXCIpKTtcbiAgICAgICAgJChcIiNjZW50ZXIgW2RhdGEtdG9nZ2xlXVwiKS50b29sdGlwKCk7XG4gICAgfSxcblxuICAgIGRvd25sb2FkRGF0YXNldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB1cmwgPSBgJHtHYWxheHkucm9vdH1hcGkvbGlicmFyaWVzL2RhdGFzZXRzL2Rvd25sb2FkL3VuY29tcHJlc3NlZGA7XG4gICAgICAgIHZhciBkYXRhID0geyBsZF9pZHM6IHRoaXMuaWQgfTtcbiAgICAgICAgdGhpcy5wcm9jZXNzRG93bmxvYWQodXJsLCBkYXRhKTtcbiAgICB9LFxuXG4gICAgcHJvY2Vzc0Rvd25sb2FkOiBmdW5jdGlvbih1cmwsIGRhdGEsIG1ldGhvZCkge1xuICAgICAgICAvL3VybCBhbmQgZGF0YSBvcHRpb25zIHJlcXVpcmVkXG4gICAgICAgIGlmICh1cmwgJiYgZGF0YSkge1xuICAgICAgICAgICAgLy9kYXRhIGNhbiBiZSBzdHJpbmcgb2YgcGFyYW1ldGVycyBvciBhcnJheS9vYmplY3RcbiAgICAgICAgICAgIGRhdGEgPSB0eXBlb2YgZGF0YSA9PSBcInN0cmluZ1wiID8gZGF0YSA6ICQucGFyYW0oZGF0YSk7XG4gICAgICAgICAgICAvL3NwbGl0IHBhcmFtcyBpbnRvIGZvcm0gaW5wdXRzXG4gICAgICAgICAgICB2YXIgaW5wdXRzID0gXCJcIjtcbiAgICAgICAgICAgICQuZWFjaChkYXRhLnNwbGl0KFwiJlwiKSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhaXIgPSB0aGlzLnNwbGl0KFwiPVwiKTtcbiAgICAgICAgICAgICAgICBpbnB1dHMgKz0gYDxpbnB1dCB0eXBlPVwiaGlkZGVuXCIgbmFtZT1cIiR7cGFpclswXX1cIiB2YWx1ZT1cIiR7cGFpclsxXX1cIiAvPmA7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vc2VuZCByZXF1ZXN0XG4gICAgICAgICAgICAkKGA8Zm9ybSBhY3Rpb249XCIke3VybH1cIiBtZXRob2Q9XCIke21ldGhvZCB8fCBcInBvc3RcIn1cIj4ke2lucHV0c308L2Zvcm0+YClcbiAgICAgICAgICAgICAgICAuYXBwZW5kVG8oXCJib2R5XCIpXG4gICAgICAgICAgICAgICAgLnN1Ym1pdCgpXG4gICAgICAgICAgICAgICAgLnJlbW92ZSgpO1xuXG4gICAgICAgICAgICBtb2RfdG9hc3RyLmluZm8oXCJZb3VyIGRvd25sb2FkIHdpbGwgYmVnaW4gc29vbi5cIik7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgaW1wb3J0SW50b0hpc3Rvcnk6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnJlZnJlc2hVc2VySGlzdG9yaWVzTGlzdChzZWxmID0+IHtcbiAgICAgICAgICAgIHZhciB0ZW1wbGF0ZSA9IHNlbGYudGVtcGxhdGVCdWxrSW1wb3J0SW5Nb2RhbCgpO1xuICAgICAgICAgICAgc2VsZi5tb2RhbCA9IEdhbGF4eS5tb2RhbDtcbiAgICAgICAgICAgIHNlbGYubW9kYWwuc2hvdyh7XG4gICAgICAgICAgICAgICAgY2xvc2luZ19ldmVudHM6IHRydWUsXG4gICAgICAgICAgICAgICAgdGl0bGU6IF9sKFwiSW1wb3J0IGludG8gSGlzdG9yeVwiKSxcbiAgICAgICAgICAgICAgICBib2R5OiB0ZW1wbGF0ZSh7IGhpc3Rvcmllczogc2VsZi5oaXN0b3JpZXMubW9kZWxzIH0pLFxuICAgICAgICAgICAgICAgIGJ1dHRvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgSW1wb3J0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuaW1wb3J0Q3VycmVudEludG9IaXN0b3J5KCk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIENsb3NlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIEdhbGF4eS5tb2RhbC5oaWRlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIHJlZnJlc2hVc2VySGlzdG9yaWVzTGlzdDogZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB0aGlzLmhpc3RvcmllcyA9IG5ldyBtb2RfbGlicmFyeV9tb2RlbC5HYWxheHlIaXN0b3JpZXMoKTtcbiAgICAgICAgdGhpcy5oaXN0b3JpZXMuZmV0Y2goe1xuICAgICAgICAgICAgc3VjY2VzczogZnVuY3Rpb24oaGlzdG9yaWVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhpc3Rvcmllcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbW9kX3RvYXN0ci53YXJuaW5nKFwiWW91IGhhdmUgdG8gY3JlYXRlIGhpc3RvcnkgZmlyc3QuIENsaWNrIHRoaXMgdG8gZG8gc28uXCIsIFwiXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uY2xpY2s6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbiA9IEdhbGF4eS5yb290O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhzZWxmKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZXJyb3I6IGZ1bmN0aW9uKG1vZGVsLCByZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcmVzcG9uc2UucmVzcG9uc2VKU09OICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIG1vZF90b2FzdHIuZXJyb3IocmVzcG9uc2UucmVzcG9uc2VKU09OLmVycl9tc2cpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG1vZF90b2FzdHIuZXJyb3IoXCJBbiBlcnJvciBvY2N1cnJlZC5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgaW1wb3J0Q3VycmVudEludG9IaXN0b3J5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5tb2RhbC5kaXNhYmxlQnV0dG9uKFwiSW1wb3J0XCIpO1xuICAgICAgICB2YXIgbmV3X2hpc3RvcnlfbmFtZSA9IHRoaXMubW9kYWwuJChcImlucHV0W25hbWU9aGlzdG9yeV9uYW1lXVwiKS52YWwoKTtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICBpZiAobmV3X2hpc3RvcnlfbmFtZSAhPT0gXCJcIikge1xuICAgICAgICAgICAgJC5wb3N0KGAke0dhbGF4eS5yb290fWFwaS9oaXN0b3JpZXNgLCB7XG4gICAgICAgICAgICAgICAgbmFtZTogbmV3X2hpc3RvcnlfbmFtZVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuZG9uZShuZXdfaGlzdG9yeSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYucHJvY2Vzc0ltcG9ydFRvSGlzdG9yeShuZXdfaGlzdG9yeS5pZCk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuZmFpbCgoeGhyLCBzdGF0dXMsIGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIG1vZF90b2FzdHIuZXJyb3IoXCJBbiBlcnJvciBvY2N1cnJlZC5cIik7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuYWx3YXlzKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5tb2RhbC5lbmFibGVCdXR0b24oXCJJbXBvcnRcIik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgaGlzdG9yeV9pZCA9ICQodGhpcy5tb2RhbC4kZWwpXG4gICAgICAgICAgICAgICAgLmZpbmQoXCJzZWxlY3RbbmFtZT1kYXRhc2V0X2ltcG9ydF9zaW5nbGVdIG9wdGlvbjpzZWxlY3RlZFwiKVxuICAgICAgICAgICAgICAgIC52YWwoKTtcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc0ltcG9ydFRvSGlzdG9yeShoaXN0b3J5X2lkKTtcbiAgICAgICAgICAgIHRoaXMubW9kYWwuZW5hYmxlQnV0dG9uKFwiSW1wb3J0XCIpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHByb2Nlc3NJbXBvcnRUb0hpc3Rvcnk6IGZ1bmN0aW9uKGhpc3RvcnlfaWQpIHtcbiAgICAgICAgdmFyIGhpc3RvcnlJdGVtID0gbmV3IG1vZF9saWJyYXJ5X21vZGVsLkhpc3RvcnlJdGVtKCk7XG4gICAgICAgIGhpc3RvcnlJdGVtLnVybCA9IGAke2hpc3RvcnlJdGVtLnVybFJvb3QgKyBoaXN0b3J5X2lkfS9jb250ZW50c2A7XG4gICAgICAgIC8vIHNldCB0aGUgdXNlZCBoaXN0b3J5IGFzIGN1cnJlbnQgc28gdXNlciB3aWxsIHNlZSB0aGUgbGFzdCBvbmVcbiAgICAgICAgLy8gdGhhdCBoZSBpbXBvcnRlZCBpbnRvIGluIHRoZSBoaXN0b3J5IHBhbmVsIG9uIHRoZSAnYW5hbHlzaXMnIHBhZ2VcbiAgICAgICAgalF1ZXJ5LmdldEpTT04oYCR7R2FsYXh5LnJvb3R9aGlzdG9yeS9zZXRfYXNfY3VycmVudD9pZD0ke2hpc3RvcnlfaWR9YCk7XG4gICAgICAgIC8vIHNhdmUgdGhlIGRhdGFzZXQgaW50byBzZWxlY3RlZCBoaXN0b3J5XG4gICAgICAgIGhpc3RvcnlJdGVtLnNhdmUoXG4gICAgICAgICAgICB7IGNvbnRlbnQ6IHRoaXMuaWQsIHNvdXJjZTogXCJsaWJyYXJ5XCIgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgR2FsYXh5Lm1vZGFsLmhpZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgbW9kX3RvYXN0ci5zdWNjZXNzKFwiRGF0YXNldCBpbXBvcnRlZC4gQ2xpY2sgdGhpcyB0byBzdGFydCBhbmFseXppbmcgaXQuXCIsIFwiXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uY2xpY2s6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbiA9IEdhbGF4eS5yb290O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGVycm9yOiBmdW5jdGlvbihtb2RlbCwgcmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByZXNwb25zZS5yZXNwb25zZUpTT04gIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZF90b2FzdHIuZXJyb3IoYERhdGFzZXQgbm90IGltcG9ydGVkLiAke3Jlc3BvbnNlLnJlc3BvbnNlSlNPTi5lcnJfbXNnfWApO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9kX3RvYXN0ci5lcnJvcihcIkFuIGVycm9yIG9jY3VyZWQuIERhdGFzZXQgbm90IGltcG9ydGVkLiBQbGVhc2UgdHJ5IGFnYWluLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICB9LFxuXG4gICAgc2hvd1Blcm1pc3Npb25zOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHZhciB0ZW1wbGF0ZSA9IHRoaXMudGVtcGxhdGVEYXRhc2V0UGVybWlzc2lvbnMoKTtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBfLmV4dGVuZCh0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuICAgICAgICAkKFwiLnRvb2x0aXBcIikucmVtb3ZlKCk7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZmV0Y2hlZF9wZXJtaXNzaW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmZldGNoZWRfcGVybWlzc2lvbnMuYWNjZXNzX2RhdGFzZXRfcm9sZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tb2RlbC5zZXQoeyBpc191bnJlc3RyaWN0ZWQ6IHRydWUgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubW9kZWwuc2V0KHsgaXNfdW5yZXN0cmljdGVkOiBmYWxzZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLiRlbC5odG1sKFxuICAgICAgICAgICAgdGVtcGxhdGUoe1xuICAgICAgICAgICAgICAgIGl0ZW06IHRoaXMubW9kZWwsXG4gICAgICAgICAgICAgICAgaXNfYWRtaW46IEdhbGF4eS5jb25maWcuaXNfYWRtaW5fdXNlclxuICAgICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgICAgJC5nZXQoYCR7R2FsYXh5LnJvb3R9YXBpL2xpYnJhcmllcy9kYXRhc2V0cy8ke3NlbGYuaWR9L3Blcm1pc3Npb25zP3Njb3BlPWN1cnJlbnRgKVxuICAgICAgICAgICAgLmRvbmUoZmV0Y2hlZF9wZXJtaXNzaW9ucyA9PiB7XG4gICAgICAgICAgICAgICAgc2VsZi5wcmVwYXJlU2VsZWN0Qm94ZXMoe1xuICAgICAgICAgICAgICAgICAgICBmZXRjaGVkX3Blcm1pc3Npb25zOiBmZXRjaGVkX3Blcm1pc3Npb25zLFxuICAgICAgICAgICAgICAgICAgICBpc19hZG1pbjogR2FsYXh5LmNvbmZpZy5pc19hZG1pbl91c2VyXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmZhaWwoKCkgPT4ge1xuICAgICAgICAgICAgICAgIG1vZF90b2FzdHIuZXJyb3IoXCJBbiBlcnJvciBvY2N1cnJlZCB3aGlsZSBhdHRlbXB0aW5nIHRvIGZldGNoIGRhdGFzZXQgcGVybWlzc2lvbnMuXCIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICQoXCIjY2VudGVyIFtkYXRhLXRvZ2dsZV1cIikudG9vbHRpcCgpO1xuICAgICAgICAkKFwiI2NlbnRlclwiKS5jc3MoXCJvdmVyZmxvd1wiLCBcImF1dG9cIik7XG4gICAgfSxcblxuICAgIF9zZXJpYWxpemVSb2xlczogZnVuY3Rpb24ocm9sZV9saXN0KSB7XG4gICAgICAgIHZhciBzZWxlY3RlZF9yb2xlcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJvbGVfbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgLy8gUmVwbGFjZSB0aGUgOiBhbmQgLCBpbiByb2xlJ3MgbmFtZSBzaW5jZSB0aGVzZSBhcmUgc2VsZWN0MiBzZXBhcmF0b3JzIGZvciBpbml0aWFsRGF0YVxuICAgICAgICAgICAgc2VsZWN0ZWRfcm9sZXMucHVzaChgJHtyb2xlX2xpc3RbaV1bMV19OiR7cm9sZV9saXN0W2ldWzBdLnJlcGxhY2UoXCI6XCIsIFwiIFwiKS5yZXBsYWNlKFwiLFwiLCBcIiAmXCIpfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWxlY3RlZF9yb2xlcztcbiAgICB9LFxuXG4gICAgcHJlcGFyZVNlbGVjdEJveGVzOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IF8uZXh0ZW5kKHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuYWNjZXNzU2VsZWN0T2JqZWN0ID0gbmV3IG1vZF9zZWxlY3QuVmlldyhcbiAgICAgICAgICAgIHRoaXMuX2dlbmVyYXRlX3NlbGVjdF9vcHRpb25zKHtcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogXCJhY2Nlc3NfcGVybVwiLFxuICAgICAgICAgICAgICAgIGluaXRpYWxEYXRhOiB0aGlzLl9zZXJpYWxpemVSb2xlcyh0aGlzLm9wdGlvbnMuZmV0Y2hlZF9wZXJtaXNzaW9ucy5hY2Nlc3NfZGF0YXNldF9yb2xlcylcbiAgICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMubW9kaWZ5U2VsZWN0T2JqZWN0ID0gbmV3IG1vZF9zZWxlY3QuVmlldyhcbiAgICAgICAgICAgIHRoaXMuX2dlbmVyYXRlX3NlbGVjdF9vcHRpb25zKHtcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogXCJtb2RpZnlfcGVybVwiLFxuICAgICAgICAgICAgICAgIGluaXRpYWxEYXRhOiB0aGlzLl9zZXJpYWxpemVSb2xlcyh0aGlzLm9wdGlvbnMuZmV0Y2hlZF9wZXJtaXNzaW9ucy5tb2RpZnlfaXRlbV9yb2xlcylcbiAgICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMubWFuYWdlU2VsZWN0T2JqZWN0ID0gbmV3IG1vZF9zZWxlY3QuVmlldyhcbiAgICAgICAgICAgIHRoaXMuX2dlbmVyYXRlX3NlbGVjdF9vcHRpb25zKHtcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogXCJtYW5hZ2VfcGVybVwiLFxuICAgICAgICAgICAgICAgIGluaXRpYWxEYXRhOiB0aGlzLl9zZXJpYWxpemVSb2xlcyh0aGlzLm9wdGlvbnMuZmV0Y2hlZF9wZXJtaXNzaW9ucy5tYW5hZ2VfZGF0YXNldF9yb2xlcylcbiAgICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIF9nZW5lcmF0ZV9zZWxlY3Rfb3B0aW9uczogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICB2YXIgc2VsZWN0X29wdGlvbnMgPSB7XG4gICAgICAgICAgICBtaW5pbXVtSW5wdXRMZW5ndGg6IDAsXG4gICAgICAgICAgICBtdWx0aXBsZTogdHJ1ZSxcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyOiBcIkNsaWNrIHRvIHNlbGVjdCBhIHJvbGVcIixcbiAgICAgICAgICAgIGZvcm1hdFJlc3VsdDogZnVuY3Rpb24gcm9sZUZvcm1hdFJlc3VsdChyb2xlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGAke3JvbGUubmFtZX0gdHlwZTogJHtyb2xlLnR5cGV9YDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmb3JtYXRTZWxlY3Rpb246IGZ1bmN0aW9uIHJvbGVGb3JtYXRTZWxlY3Rpb24ocm9sZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiByb2xlLm5hbWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaW5pdFNlbGVjdGlvbjogZnVuY3Rpb24oZWxlbWVudCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAvLyB0aGUgaW5wdXQgdGFnIGhhcyBhIHZhbHVlIGF0dHJpYnV0ZSBwcmVsb2FkZWQgdGhhdCBwb2ludHMgdG8gYSBwcmVzZWxlY3RlZCByb2xlJ3MgaWRcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGZ1bmN0aW9uIHJlc29sdmVzIHRoYXQgaWQgYXR0cmlidXRlIHRvIGFuIG9iamVjdCB0aGF0IHNlbGVjdDIgY2FuIHJlbmRlclxuICAgICAgICAgICAgICAgIC8vIHVzaW5nIGl0cyBmb3JtYXRSZXN1bHQgcmVuZGVyZXIgLSB0aGF0IHdheSB0aGUgcm9sZSBuYW1lIGlzIHNob3duIHByZXNlbGVjdGVkXG4gICAgICAgICAgICAgICAgdmFyIGRhdGEgPSBbXTtcbiAgICAgICAgICAgICAgICAkKGVsZW1lbnQudmFsKCkuc3BsaXQoXCIsXCIpKS5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IHRoaXMuc3BsaXQoXCI6XCIpO1xuICAgICAgICAgICAgICAgICAgICBkYXRhLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGl0ZW1bMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBpdGVtWzFdXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGRhdGEpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRyb3Bkb3duQ3NzQ2xhc3M6IFwiYmlnZHJvcFwiIC8vIGFwcGx5IGNzcyB0aGF0IG1ha2VzIHRoZSBkcm9wZG93biB0YWxsZXJcbiAgICAgICAgfTtcbiAgICAgICAgc2VsZWN0X29wdGlvbnMuY29udGFpbmVyID0gdGhpcy4kZWwuZmluZChgIyR7b3B0aW9ucy5zZWxlY3Rvcn1gKTtcbiAgICAgICAgc2VsZWN0X29wdGlvbnMuY3NzID0gb3B0aW9ucy5zZWxlY3RvcjtcbiAgICAgICAgc2VsZWN0X29wdGlvbnMuaW5pdGlhbERhdGEgPSBvcHRpb25zLmluaXRpYWxEYXRhLmpvaW4oXCIsXCIpO1xuICAgICAgICBzZWxlY3Rfb3B0aW9ucy5hamF4ID0ge1xuICAgICAgICAgICAgdXJsOiBgJHtHYWxheHkucm9vdH1hcGkvbGlicmFyaWVzL2RhdGFzZXRzLyR7dGhpcy5pZH0vcGVybWlzc2lvbnM/c2NvcGU9YXZhaWxhYmxlYCxcbiAgICAgICAgICAgIGRhdGFUeXBlOiBcImpzb25cIixcbiAgICAgICAgICAgIHF1aWV0TWlsbGlzOiAxMDAsXG4gICAgICAgICAgICBkYXRhOiBmdW5jdGlvbih0ZXJtLCBwYWdlKSB7XG4gICAgICAgICAgICAgICAgLy8gcGFnZSBpcyB0aGUgb25lLWJhc2VkIHBhZ2UgbnVtYmVyIHRyYWNrZWQgYnkgU2VsZWN0MlxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHE6IHRlcm0sIC8vc2VhcmNoIHRlcm1cbiAgICAgICAgICAgICAgICAgICAgcGFnZV9saW1pdDogMTAsIC8vIHBhZ2Ugc2l6ZSwgc2hvdWxkIGJlIHNhbWUgYXMgdXNlZCBpbiAnbW9yZScgdmFyaWFibGUgYmVsb3dcbiAgICAgICAgICAgICAgICAgICAgcGFnZTogcGFnZSAvLyBwYWdlIG51bWJlclxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVzdWx0czogZnVuY3Rpb24oZGF0YSwgcGFnZSkge1xuICAgICAgICAgICAgICAgIHZhciBtb3JlID0gcGFnZSAqIDEwIDwgZGF0YS50b3RhbDsgLy8gd2hldGhlciBvciBub3QgdGhlcmUgYXJlIG1vcmUgcmVzdWx0cyBhdmFpbGFibGVcbiAgICAgICAgICAgICAgICAvLyBub3RpY2Ugd2UgcmV0dXJuIHRoZSB2YWx1ZSBvZiBtb3JlIHNvIFNlbGVjdDIga25vd3MgaWYgbW9yZSByZXN1bHRzIGNhbiBiZSBsb2FkZWRcbiAgICAgICAgICAgICAgICByZXR1cm4geyByZXN1bHRzOiBkYXRhLnJvbGVzLCBtb3JlOiBtb3JlIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBzZWxlY3Rfb3B0aW9ucztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2F2ZSB0aGUgY2hhbmdlcyBtYWRlIHRvIHRoZSBsaWJyYXJ5IGRhdGFzZXQuXG4gICAgICovXG4gICAgc2F2ZU1vZGlmaWNhdGlvbnM6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGlzX2NoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgdmFyIGxkID0gdGhpcy5tb2RlbDtcbiAgICAgICAgdmFyIG5ld19uYW1lID0gdGhpcy4kZWwuZmluZChcIi5pbnB1dF9kYXRhc2V0X25hbWVcIikudmFsKCk7XG4gICAgICAgIGlmICh0eXBlb2YgbmV3X25hbWUgIT09IFwidW5kZWZpbmVkXCIgJiYgbmV3X25hbWUgIT09IGxkLmdldChcIm5hbWVcIikpIHtcbiAgICAgICAgICAgIGlmIChuZXdfbmFtZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgbGQuc2V0KFwibmFtZVwiLCBuZXdfbmFtZSk7XG4gICAgICAgICAgICAgICAgaXNfY2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG1vZF90b2FzdHIud2FybmluZyhcIkxpYnJhcnkgZGF0YXNldCBuYW1lIGhhcyB0byBiZSBhdCBsZWFzdCAxIGNoYXJhY3RlciBsb25nLlwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5ld19pbmZvID0gdGhpcy4kZWwuZmluZChcIi5pbnB1dF9kYXRhc2V0X21pc2NfaW5mb1wiKS52YWwoKTtcbiAgICAgICAgaWYgKHR5cGVvZiBuZXdfaW5mbyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBuZXdfaW5mbyAhPT0gbGQuZ2V0KFwibWlzY19pbmZvXCIpKSB7XG4gICAgICAgICAgICBsZC5zZXQoXCJtaXNjX2luZm9cIiwgbmV3X2luZm8pO1xuICAgICAgICAgICAgaXNfY2hhbmdlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5ld19nZW5vbWVfYnVpbGQgPSB0aGlzLnNlbGVjdF9nZW5vbWUuJGVsLnNlbGVjdDIoXCJkYXRhXCIpLmlkO1xuICAgICAgICBpZiAodHlwZW9mIG5ld19nZW5vbWVfYnVpbGQgIT09IFwidW5kZWZpbmVkXCIgJiYgbmV3X2dlbm9tZV9idWlsZCAhPT0gbGQuZ2V0KFwiZ2Vub21lX2J1aWxkXCIpKSB7XG4gICAgICAgICAgICBsZC5zZXQoXCJnZW5vbWVfYnVpbGRcIiwgbmV3X2dlbm9tZV9idWlsZCk7XG4gICAgICAgICAgICBpc19jaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmV3X2V4dCA9IHRoaXMuc2VsZWN0X2V4dGVuc2lvbi4kZWwuc2VsZWN0MihcImRhdGFcIikuaWQ7XG4gICAgICAgIGlmICh0eXBlb2YgbmV3X2V4dCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBuZXdfZXh0ICE9PSBsZC5nZXQoXCJmaWxlX2V4dFwiKSkge1xuICAgICAgICAgICAgbGQuc2V0KFwiZmlsZV9leHRcIiwgbmV3X2V4dCk7XG4gICAgICAgICAgICBpc19jaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGF0YXNldF92aWV3ID0gdGhpcztcbiAgICAgICAgaWYgKGlzX2NoYW5nZWQpIHtcbiAgICAgICAgICAgIGxkLnNhdmUobnVsbCwge1xuICAgICAgICAgICAgICAgIHBhdGNoOiB0cnVlLFxuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uKGxkKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFzZXRfdmlldy5yZW5kZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgbW9kX3RvYXN0ci5zdWNjZXNzKFwiQ2hhbmdlcyB0byBsaWJyYXJ5IGRhdGFzZXQgc2F2ZWQuXCIpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZXJyb3I6IGZ1bmN0aW9uKG1vZGVsLCByZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJlc3BvbnNlLnJlc3BvbnNlSlNPTiAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9kX3RvYXN0ci5lcnJvcihyZXNwb25zZS5yZXNwb25zZUpTT04uZXJyX21zZyk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RfdG9hc3RyLmVycm9yKFwiQW4gZXJyb3Igb2NjdXJlZCB3aGlsZSBhdHRlbXB0aW5nIHRvIHVwZGF0ZSB0aGUgbGlicmFyeSBkYXRhc2V0LlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGF0YXNldF92aWV3LnJlbmRlcigpO1xuICAgICAgICAgICAgbW9kX3RvYXN0ci5pbmZvKFwiTm90aGluZyBoYXMgY2hhbmdlZC5cIik7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgY29weVRvQ2xpcGJvYXJkOiBmdW5jdGlvbihlKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdmFyIGhyZWYgPSBCYWNrYm9uZS5oaXN0b3J5LmxvY2F0aW9uLmhyZWY7XG4gICAgICAgIGlmIChocmVmLmxhc3RJbmRleE9mKFwiL3Blcm1pc3Npb25zXCIpICE9PSAtMSkge1xuICAgICAgICAgICAgaHJlZiA9IGhyZWYuc3Vic3RyKDAsIGhyZWYubGFzdEluZGV4T2YoXCIvcGVybWlzc2lvbnNcIikpO1xuICAgICAgICB9XG4gICAgICAgIHdpbmRvdy5wcm9tcHQoXCJDb3B5IHRvIGNsaXBib2FyZDogQ3RybCtDLCBFbnRlclwiLCBocmVmKTtcbiAgICB9LFxuXG4gICAgbWFrZURhdGFzZXRQcml2YXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAkLnBvc3QoYCR7R2FsYXh5LnJvb3R9YXBpL2xpYnJhcmllcy9kYXRhc2V0cy8ke3NlbGYuaWR9L3Blcm1pc3Npb25zP2FjdGlvbj1tYWtlX3ByaXZhdGVgKVxuICAgICAgICAgICAgLmRvbmUoZmV0Y2hlZF9wZXJtaXNzaW9ucyA9PiB7XG4gICAgICAgICAgICAgICAgc2VsZi5tb2RlbC5zZXQoeyBpc191bnJlc3RyaWN0ZWQ6IGZhbHNlIH0pO1xuICAgICAgICAgICAgICAgIHNlbGYuc2hvd1Blcm1pc3Npb25zKHtcbiAgICAgICAgICAgICAgICAgICAgZmV0Y2hlZF9wZXJtaXNzaW9uczogZmV0Y2hlZF9wZXJtaXNzaW9uc1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIG1vZF90b2FzdHIuc3VjY2VzcyhcIlRoZSBkYXRhc2V0IGlzIG5vdyBwcml2YXRlIHRvIHlvdS5cIik7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmZhaWwoKCkgPT4ge1xuICAgICAgICAgICAgICAgIG1vZF90b2FzdHIuZXJyb3IoXCJBbiBlcnJvciBvY2N1cnJlZCB3aGlsZSBhdHRlbXB0aW5nIHRvIG1ha2UgZGF0YXNldCBwcml2YXRlLlwiKTtcbiAgICAgICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICByZW1vdmVEYXRhc2V0UmVzdHJpY3Rpb25zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAkLnBvc3QoYCR7R2FsYXh5LnJvb3R9YXBpL2xpYnJhcmllcy9kYXRhc2V0cy8ke3NlbGYuaWR9L3Blcm1pc3Npb25zP2FjdGlvbj1yZW1vdmVfcmVzdHJpY3Rpb25zYClcbiAgICAgICAgICAgIC5kb25lKGZldGNoZWRfcGVybWlzc2lvbnMgPT4ge1xuICAgICAgICAgICAgICAgIHNlbGYubW9kZWwuc2V0KHsgaXNfdW5yZXN0cmljdGVkOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgIHNlbGYuc2hvd1Blcm1pc3Npb25zKHtcbiAgICAgICAgICAgICAgICAgICAgZmV0Y2hlZF9wZXJtaXNzaW9uczogZmV0Y2hlZF9wZXJtaXNzaW9uc1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIG1vZF90b2FzdHIuc3VjY2VzcyhcIkFjY2VzcyB0byB0aGlzIGRhdGFzZXQgaXMgbm93IHVucmVzdHJpY3RlZC5cIik7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmZhaWwoKCkgPT4ge1xuICAgICAgICAgICAgICAgIG1vZF90b2FzdHIuZXJyb3IoXCJBbiBlcnJvciBvY2N1cnJlZCB3aGlsZSBhdHRlbXB0aW5nIHRvIG1ha2UgZGF0YXNldCB1bnJlc3RyaWN0ZWQuXCIpO1xuICAgICAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEV4dHJhY3QgdGhlIHJvbGUgaWRzIGZyb20gU2VsZWN0MiBlbGVtZW50cydzICdkYXRhJ1xuICAgICAqL1xuICAgIF9leHRyYWN0SWRzOiBmdW5jdGlvbihyb2xlc19saXN0KSB7XG4gICAgICAgIHZhciBpZHNfbGlzdCA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gcm9sZXNfbGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgaWRzX2xpc3QucHVzaChyb2xlc19saXN0W2ldLmlkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaWRzX2xpc3Q7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNhdmUgdGhlIHBlcm1pc3Npb25zIGZvciByb2xlcyBlbnRlcmVkIGluIHRoZSBzZWxlY3QgYm94ZXMuXG4gICAgICovXG4gICAgc2F2ZVBlcm1pc3Npb25zOiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBhY2Nlc3NfaWRzID0gdGhpcy5fZXh0cmFjdElkcyh0aGlzLmFjY2Vzc1NlbGVjdE9iamVjdC4kZWwuc2VsZWN0MihcImRhdGFcIikpO1xuICAgICAgICB2YXIgbWFuYWdlX2lkcyA9IHRoaXMuX2V4dHJhY3RJZHModGhpcy5tYW5hZ2VTZWxlY3RPYmplY3QuJGVsLnNlbGVjdDIoXCJkYXRhXCIpKTtcbiAgICAgICAgdmFyIG1vZGlmeV9pZHMgPSB0aGlzLl9leHRyYWN0SWRzKHRoaXMubW9kaWZ5U2VsZWN0T2JqZWN0LiRlbC5zZWxlY3QyKFwiZGF0YVwiKSk7XG4gICAgICAgICQucG9zdChgJHtHYWxheHkucm9vdH1hcGkvbGlicmFyaWVzL2RhdGFzZXRzLyR7c2VsZi5pZH0vcGVybWlzc2lvbnM/YWN0aW9uPXNldF9wZXJtaXNzaW9uc2AsIHtcbiAgICAgICAgICAgIFwiYWNjZXNzX2lkc1tdXCI6IGFjY2Vzc19pZHMsXG4gICAgICAgICAgICBcIm1hbmFnZV9pZHNbXVwiOiBtYW5hZ2VfaWRzLFxuICAgICAgICAgICAgXCJtb2RpZnlfaWRzW11cIjogbW9kaWZ5X2lkc1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmRvbmUoZmV0Y2hlZF9wZXJtaXNzaW9ucyA9PiB7XG4gICAgICAgICAgICAgICAgc2VsZi5zaG93UGVybWlzc2lvbnMoe1xuICAgICAgICAgICAgICAgICAgICBmZXRjaGVkX3Blcm1pc3Npb25zOiBmZXRjaGVkX3Blcm1pc3Npb25zXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgbW9kX3RvYXN0ci5zdWNjZXNzKFwiUGVybWlzc2lvbnMgc2F2ZWQuXCIpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5mYWlsKCgpID0+IHtcbiAgICAgICAgICAgICAgICBtb2RfdG9hc3RyLmVycm9yKFwiQW4gZXJyb3Igb2NjdXJyZWQgd2hpbGUgYXR0ZW1wdGluZyB0byBzZXQgZGF0YXNldCBwZXJtaXNzaW9ucy5cIik7XG4gICAgICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSWYgbmVlZGVkIHJlcXVlc3QgYWxsIGV4dGVuc2lvbnMgYW5kL29yIGdlbm9tZXMgZnJvbSBHYWxheHlcbiAgICAgKiBhbmQgc2F2ZSB0aGVtIGluIHNvcnRlZCBhcnJheXMuXG4gICAgICovXG4gICAgZmV0Y2hFeHRBbmRHZW5vbWVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5saXN0X2dlbm9tZXMubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgIG1vZF91dGlscy5nZXQoe1xuICAgICAgICAgICAgICAgIHVybDogYCR7R2FsYXh5LnJvb3R9YXBpL2RhdGF0eXBlcz9leHRlbnNpb25fb25seT1GYWxzZWAsXG4gICAgICAgICAgICAgICAgc3VjY2VzczogZnVuY3Rpb24oZGF0YXR5cGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBkYXRhdHlwZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYubGlzdF9leHRlbnNpb25zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBkYXRhdHlwZXNba2V5XS5leHRlbnNpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogZGF0YXR5cGVzW2tleV0uZXh0ZW5zaW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBkYXRhdHlwZXNba2V5XS5kZXNjcmlwdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbl91cmw6IGRhdGF0eXBlc1trZXldLmRlc2NyaXB0aW9uX3VybFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc2VsZi5saXN0X2V4dGVuc2lvbnMuc29ydCgoYSwgYikgPT4gKGEuaWQgPiBiLmlkID8gMSA6IGEuaWQgPCBiLmlkID8gLTEgOiAwKSk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYubGlzdF9leHRlbnNpb25zLnVuc2hpZnQoc2VsZi5hdXRvKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5saXN0X2V4dGVuc2lvbnMubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgIG1vZF91dGlscy5nZXQoe1xuICAgICAgICAgICAgICAgIHVybDogYCR7R2FsYXh5LnJvb3R9YXBpL2dlbm9tZXNgLFxuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uKGdlbm9tZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIGdlbm9tZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYubGlzdF9nZW5vbWVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBnZW5vbWVzW2tleV1bMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogZ2Vub21lc1trZXldWzBdXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzZWxmLmxpc3RfZ2Vub21lcy5zb3J0KChhLCBiKSA9PiAoYS5pZCA+IGIuaWQgPyAxIDogYS5pZCA8IGIuaWQgPyAtMSA6IDApKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICByZW5kZXJTZWxlY3RCb3hlczogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICAvLyBUaGlzIHdvbid0IHdvcmsgcHJvcGVybHkgdW5sZXNzcyB3ZSBhbHJlYWR5IGhhdmUgdGhlIGRhdGEgZmV0Y2hlZC5cbiAgICAgICAgLy8gU2VlIHRoaXMuZmV0Y2hFeHRBbmRHZW5vbWVzKClcbiAgICAgICAgLy8gVE9ETyBzd2l0Y2ggdG8gY29tbW9uIHJlc291cmNlczpcbiAgICAgICAgLy8gaHR0cHM6Ly90cmVsbG8uY29tL2MvZElVRTlZUGwvMTkzMy11aS1jb21tb24tcmVzb3VyY2VzLWFuZC1kYXRhLWludG8tZ2FsYXh5LW9iamVjdFxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBjdXJyZW50X2dlbm9tZSA9IFwiP1wiO1xuICAgICAgICB2YXIgY3VycmVudF9leHQgPSBcImF1dG9cIjtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuZ2Vub21lX2J1aWxkICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudF9nZW5vbWUgPSBvcHRpb25zLmdlbm9tZV9idWlsZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5maWxlX2V4dCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRfZXh0ID0gb3B0aW9ucy5maWxlX2V4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlbGVjdF9nZW5vbWUgPSBuZXcgbW9kX3NlbGVjdC5WaWV3KHtcbiAgICAgICAgICAgIGNzczogXCJkYXRhc2V0LWdlbm9tZS1zZWxlY3RcIixcbiAgICAgICAgICAgIGRhdGE6IHNlbGYubGlzdF9nZW5vbWVzLFxuICAgICAgICAgICAgY29udGFpbmVyOiBzZWxmLiRlbC5maW5kKFwiI2RhdGFzZXRfZ2Vub21lX3NlbGVjdFwiKSxcbiAgICAgICAgICAgIHZhbHVlOiBjdXJyZW50X2dlbm9tZVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zZWxlY3RfZXh0ZW5zaW9uID0gbmV3IG1vZF9zZWxlY3QuVmlldyh7XG4gICAgICAgICAgICBjc3M6IFwiZGF0YXNldC1leHRlbnNpb24tc2VsZWN0XCIsXG4gICAgICAgICAgICBkYXRhOiBzZWxmLmxpc3RfZXh0ZW5zaW9ucyxcbiAgICAgICAgICAgIGNvbnRhaW5lcjogc2VsZi4kZWwuZmluZChcIiNkYXRhc2V0X2V4dGVuc2lvbl9zZWxlY3RcIiksXG4gICAgICAgICAgICB2YWx1ZTogY3VycmVudF9leHRcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIHRlbXBsYXRlRGF0YXNldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfLnRlbXBsYXRlKFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIC8vIENPTlRBSU5FUiBTVEFSVFxuICAgICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwibGlicmFyeV9zdHlsZV9jb250YWluZXJcIj4nLFxuICAgICAgICAgICAgICAgICc8ZGl2IGlkPVwibGlicmFyeV90b29sYmFyXCI+JyxcbiAgICAgICAgICAgICAgICAnPGJ1dHRvbiBkYXRhLXRvZ2dsZT1cInRvb2x0aXBcIiBkYXRhLXBsYWNlbWVudD1cInRvcFwiIHRpdGxlPVwiRG93bmxvYWQgZGF0YXNldFwiIGNsYXNzPVwiYnRuIGJ0bi1kZWZhdWx0IHRvb2xidG4tZG93bmxvYWQtZGF0YXNldCBwcmltYXJ5LWJ1dHRvbiB0b29sYmFyLWl0ZW1cIiB0eXBlPVwiYnV0dG9uXCI+JyxcbiAgICAgICAgICAgICAgICAnPHNwYW4gY2xhc3M9XCJmYSBmYS1kb3dubG9hZFwiPjwvc3Bhbj4nLFxuICAgICAgICAgICAgICAgIFwiJm5ic3A7RG93bmxvYWRcIixcbiAgICAgICAgICAgICAgICBcIjwvYnV0dG9uPlwiLFxuICAgICAgICAgICAgICAgICc8YnV0dG9uIGRhdGEtdG9nZ2xlPVwidG9vbHRpcFwiIGRhdGEtcGxhY2VtZW50PVwidG9wXCIgdGl0bGU9XCJJbXBvcnQgZGF0YXNldCBpbnRvIGhpc3RvcnlcIiBjbGFzcz1cImJ0biBidG4tZGVmYXVsdCB0b29sYnRuLWltcG9ydC1kYXRhc2V0IHByaW1hcnktYnV0dG9uIHRvb2xiYXItaXRlbVwiIHR5cGU9XCJidXR0b25cIj4nLFxuICAgICAgICAgICAgICAgICc8c3BhbiBjbGFzcz1cImZhIGZhLWJvb2tcIj48L3NwYW4+JyxcbiAgICAgICAgICAgICAgICBcIiZuYnNwO3RvIEhpc3RvcnlcIixcbiAgICAgICAgICAgICAgICBcIjwvYnV0dG9uPlwiLFxuICAgICAgICAgICAgICAgICc8JSBpZiAoaXRlbS5nZXQoXCJjYW5fdXNlcl9tb2RpZnlcIikpIHsgJT4nLFxuICAgICAgICAgICAgICAgICc8YnV0dG9uIGRhdGEtdG9nZ2xlPVwidG9vbHRpcFwiIGRhdGEtcGxhY2VtZW50PVwidG9wXCIgdGl0bGU9XCJNb2RpZnkgbGlicmFyeSBpdGVtXCIgY2xhc3M9XCJidG4gYnRuLWRlZmF1bHQgdG9vbGJ0bl9tb2RpZnlfZGF0YXNldCBwcmltYXJ5LWJ1dHRvbiB0b29sYmFyLWl0ZW1cIiB0eXBlPVwiYnV0dG9uXCI+JyxcbiAgICAgICAgICAgICAgICAnPHNwYW4gY2xhc3M9XCJmYSBmYS1wZW5jaWxcIj48L3NwYW4+JyxcbiAgICAgICAgICAgICAgICBcIiZuYnNwO01vZGlmeVwiLFxuICAgICAgICAgICAgICAgIFwiPC9idXR0b24+XCIsXG4gICAgICAgICAgICAgICAgXCI8JSB9ICU+XCIsXG4gICAgICAgICAgICAgICAgJzwlIGlmIChpdGVtLmdldChcImNhbl91c2VyX21hbmFnZVwiKSkgeyAlPicsXG4gICAgICAgICAgICAgICAgJzxhIGhyZWY9XCIjZm9sZGVycy88JS0gaXRlbS5nZXQoXCJmb2xkZXJfaWRcIikgJT4vZGF0YXNldHMvPCUtIGl0ZW0uaWQgJT4vcGVybWlzc2lvbnNcIj4nLFxuICAgICAgICAgICAgICAgICc8YnV0dG9uIGRhdGEtdG9nZ2xlPVwidG9vbHRpcFwiIGRhdGEtcGxhY2VtZW50PVwidG9wXCIgdGl0bGU9XCJNYW5hZ2UgcGVybWlzc2lvbnNcIiBjbGFzcz1cImJ0biBidG4tZGVmYXVsdCB0b29sYnRuX2NoYW5nZV9wZXJtaXNzaW9ucyBwcmltYXJ5LWJ1dHRvbiB0b29sYmFyLWl0ZW1cIiB0eXBlPVwiYnV0dG9uXCI+JyxcbiAgICAgICAgICAgICAgICAnPHNwYW4gY2xhc3M9XCJmYSBmYS1ncm91cFwiPjwvc3Bhbj4nLFxuICAgICAgICAgICAgICAgIFwiJm5ic3A7UGVybWlzc2lvbnNcIixcbiAgICAgICAgICAgICAgICBcIjwvYnV0dG9uPlwiLFxuICAgICAgICAgICAgICAgIFwiPC9hPlwiLFxuICAgICAgICAgICAgICAgIFwiPCUgfSAlPlwiLFxuICAgICAgICAgICAgICAgIFwiPC9kaXY+XCIsXG5cbiAgICAgICAgICAgICAgICAvLyBCUkVBRENSVU1CU1xuICAgICAgICAgICAgICAgICc8b2wgY2xhc3M9XCJicmVhZGNydW1iXCI+JyxcbiAgICAgICAgICAgICAgICAnPGxpPjxhIHRpdGxlPVwiUmV0dXJuIHRvIHRoZSBsaXN0IG9mIGxpYnJhcmllc1wiIGhyZWY9XCIjXCI+TGlicmFyaWVzPC9hPjwvbGk+JyxcbiAgICAgICAgICAgICAgICAnPCUgXy5lYWNoKGl0ZW0uZ2V0KFwiZnVsbF9wYXRoXCIpLCBmdW5jdGlvbihwYXRoX2l0ZW0pIHsgJT4nLFxuICAgICAgICAgICAgICAgIFwiPCUgaWYgKHBhdGhfaXRlbVswXSAhPSBpdGVtLmlkKSB7ICU+XCIsXG4gICAgICAgICAgICAgICAgJzxsaT48YSB0aXRsZT1cIlJldHVybiB0byB0aGlzIGZvbGRlclwiIGhyZWY9XCIjL2ZvbGRlcnMvPCUtIHBhdGhfaXRlbVswXSAlPlwiPjwlLSBwYXRoX2l0ZW1bMV0gJT48L2E+IDwvbGk+ICcsXG4gICAgICAgICAgICAgICAgXCI8JSB9IGVsc2UgeyAlPlwiLFxuICAgICAgICAgICAgICAgICc8bGkgY2xhc3M9XCJhY3RpdmVcIj48c3BhbiB0aXRsZT1cIllvdSBhcmUgaGVyZVwiPjwlLSBwYXRoX2l0ZW1bMV0gJT48L3NwYW4+PC9saT4nLFxuICAgICAgICAgICAgICAgIFwiPCUgfSAlPlwiLFxuICAgICAgICAgICAgICAgIFwiPCUgfSk7ICU+XCIsXG4gICAgICAgICAgICAgICAgXCI8L29sPlwiLFxuXG4gICAgICAgICAgICAgICAgJzwlIGlmIChpdGVtLmdldChcImlzX3VucmVzdHJpY3RlZFwiKSkgeyAlPicsXG4gICAgICAgICAgICAgICAgXCI8ZGl2PlwiLFxuICAgICAgICAgICAgICAgICdUaGlzIGRhdGFzZXQgaXMgdW5yZXN0cmljdGVkIHNvIGV2ZXJ5Ym9keSB3aXRoIHRoZSBsaW5rIGNhbiBhY2Nlc3MgaXQuIEp1c3Qgc2hhcmUgPHNwYW4gY2xhc3M9XCJjb3B5LWxpbmstdG8tY2xpcGJvYXJkXCI+PGEgaHJlZj1cIlwiYT50aGlzIHBhZ2U8L2E+PC9zcGFuPi4nLFxuICAgICAgICAgICAgICAgIFwiPC9kaXY+XCIsXG4gICAgICAgICAgICAgICAgXCI8JSB9ICU+XCIsXG5cbiAgICAgICAgICAgICAgICAvLyBUQUJMRSBTVEFSVFxuICAgICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiZGF0YXNldF90YWJsZVwiPicsXG4gICAgICAgICAgICAgICAgJzx0YWJsZSBjbGFzcz1cImdyaWQgdGFibGUgdGFibGUtc3RyaXBlZCB0YWJsZS1jb25kZW5zZWRcIj4nLFxuICAgICAgICAgICAgICAgIFwiPHRyPlwiLFxuICAgICAgICAgICAgICAgICc8dGggY2xhc3M9XCJkYXRhc2V0LWZpcnN0LWNvbHVtblwiIHNjb3BlPVwicm93XCIgaWQ9XCJpZF9yb3dcIiBkYXRhLWlkPVwiPCU9IF8uZXNjYXBlKGl0ZW0uZ2V0KFwibGRkYV9pZFwiKSkgJT5cIj5OYW1lPC90aD4nLFxuICAgICAgICAgICAgICAgICc8dGQ+PCU9IF8uZXNjYXBlKGl0ZW0uZ2V0KFwibmFtZVwiKSkgJT48L3RkPicsXG4gICAgICAgICAgICAgICAgXCI8L3RyPlwiLFxuICAgICAgICAgICAgICAgICc8JSBpZiAoaXRlbS5nZXQoXCJmaWxlX2V4dFwiKSkgeyAlPicsXG4gICAgICAgICAgICAgICAgXCI8dHI+XCIsXG4gICAgICAgICAgICAgICAgJzx0aCBzY29wZT1cInJvd1wiPkRhdGEgdHlwZTwvdGg+JyxcbiAgICAgICAgICAgICAgICAnPHRkPjwlPSBfLmVzY2FwZShpdGVtLmdldChcImZpbGVfZXh0XCIpKSAlPjwvdGQ+JyxcbiAgICAgICAgICAgICAgICBcIjwvdHI+XCIsXG4gICAgICAgICAgICAgICAgXCI8JSB9ICU+XCIsXG4gICAgICAgICAgICAgICAgJzwlIGlmIChpdGVtLmdldChcImdlbm9tZV9idWlsZFwiKSkgeyAlPicsXG4gICAgICAgICAgICAgICAgXCI8dHI+XCIsXG4gICAgICAgICAgICAgICAgJzx0aCBzY29wZT1cInJvd1wiPkdlbm9tZSBidWlsZDwvdGg+JyxcbiAgICAgICAgICAgICAgICAnPHRkPjwlPSBfLmVzY2FwZShpdGVtLmdldChcImdlbm9tZV9idWlsZFwiKSkgJT48L3RkPicsXG4gICAgICAgICAgICAgICAgXCI8L3RyPlwiLFxuICAgICAgICAgICAgICAgIFwiPCUgfSAlPlwiLFxuICAgICAgICAgICAgICAgICc8JSBpZiAoaXRlbS5nZXQoXCJmaWxlX3NpemVcIikpIHsgJT4nLFxuICAgICAgICAgICAgICAgIFwiPHRyPlwiLFxuICAgICAgICAgICAgICAgICc8dGggc2NvcGU9XCJyb3dcIj5TaXplPC90aD4nLFxuICAgICAgICAgICAgICAgICc8dGQ+PCU9IF8uZXNjYXBlKGl0ZW0uZ2V0KFwiZmlsZV9zaXplXCIpKSAlPjwvdGQ+JyxcbiAgICAgICAgICAgICAgICBcIjwvdHI+XCIsXG4gICAgICAgICAgICAgICAgXCI8JSB9ICU+XCIsXG4gICAgICAgICAgICAgICAgJzwlIGlmIChpdGVtLmdldChcImRhdGVfdXBsb2FkZWRcIikpIHsgJT4nLFxuICAgICAgICAgICAgICAgIFwiPHRyPlwiLFxuICAgICAgICAgICAgICAgICc8dGggc2NvcGU9XCJyb3dcIj5EYXRlIHVwbG9hZGVkIChVVEMpPC90aD4nLFxuICAgICAgICAgICAgICAgICc8dGQ+PCU9IF8uZXNjYXBlKGl0ZW0uZ2V0KFwiZGF0ZV91cGxvYWRlZFwiKSkgJT48L3RkPicsXG4gICAgICAgICAgICAgICAgXCI8L3RyPlwiLFxuICAgICAgICAgICAgICAgIFwiPCUgfSAlPlwiLFxuICAgICAgICAgICAgICAgICc8JSBpZiAoaXRlbS5nZXQoXCJ1cGxvYWRlZF9ieVwiKSkgeyAlPicsXG4gICAgICAgICAgICAgICAgXCI8dHI+XCIsXG4gICAgICAgICAgICAgICAgJzx0aCBzY29wZT1cInJvd1wiPlVwbG9hZGVkIGJ5PC90aD4nLFxuICAgICAgICAgICAgICAgICc8dGQ+PCU9IF8uZXNjYXBlKGl0ZW0uZ2V0KFwidXBsb2FkZWRfYnlcIikpICU+PC90ZD4nLFxuICAgICAgICAgICAgICAgIFwiPC90cj5cIixcbiAgICAgICAgICAgICAgICBcIjwlIH0gJT5cIixcbiAgICAgICAgICAgICAgICAnPCUgaWYgKGl0ZW0uZ2V0KFwibWV0YWRhdGFfZGF0YV9saW5lc1wiKSkgeyAlPicsXG4gICAgICAgICAgICAgICAgXCI8dHI+XCIsXG4gICAgICAgICAgICAgICAgJzx0aCBzY29wZT1cInJvd1wiPkRhdGEgTGluZXM8L3RoPicsXG4gICAgICAgICAgICAgICAgJzx0ZCBzY29wZT1cInJvd1wiPjwlPSBfLmVzY2FwZShpdGVtLmdldChcIm1ldGFkYXRhX2RhdGFfbGluZXNcIikpICU+PC90ZD4nLFxuICAgICAgICAgICAgICAgIFwiPC90cj5cIixcbiAgICAgICAgICAgICAgICBcIjwlIH0gJT5cIixcbiAgICAgICAgICAgICAgICAnPCUgaWYgKGl0ZW0uZ2V0KFwibWV0YWRhdGFfY29tbWVudF9saW5lc1wiKSkgeyAlPicsXG4gICAgICAgICAgICAgICAgXCI8dHI+XCIsXG4gICAgICAgICAgICAgICAgJzx0aCBzY29wZT1cInJvd1wiPkNvbW1lbnQgTGluZXM8L3RoPicsXG4gICAgICAgICAgICAgICAgJzx0ZCBzY29wZT1cInJvd1wiPjwlPSBfLmVzY2FwZShpdGVtLmdldChcIm1ldGFkYXRhX2NvbW1lbnRfbGluZXNcIikpICU+PC90ZD4nLFxuICAgICAgICAgICAgICAgIFwiPC90cj5cIixcbiAgICAgICAgICAgICAgICBcIjwlIH0gJT5cIixcbiAgICAgICAgICAgICAgICAnPCUgaWYgKGl0ZW0uZ2V0KFwibWV0YWRhdGFfY29sdW1uc1wiKSkgeyAlPicsXG4gICAgICAgICAgICAgICAgXCI8dHI+XCIsXG4gICAgICAgICAgICAgICAgJzx0aCBzY29wZT1cInJvd1wiPk51bWJlciBvZiBDb2x1bW5zPC90aD4nLFxuICAgICAgICAgICAgICAgICc8dGQgc2NvcGU9XCJyb3dcIj48JT0gXy5lc2NhcGUoaXRlbS5nZXQoXCJtZXRhZGF0YV9jb2x1bW5zXCIpKSAlPjwvdGQ+JyxcbiAgICAgICAgICAgICAgICBcIjwvdHI+XCIsXG4gICAgICAgICAgICAgICAgXCI8JSB9ICU+XCIsXG4gICAgICAgICAgICAgICAgJzwlIGlmIChpdGVtLmdldChcIm1ldGFkYXRhX2NvbHVtbl90eXBlc1wiKSkgeyAlPicsXG4gICAgICAgICAgICAgICAgXCI8dHI+XCIsXG4gICAgICAgICAgICAgICAgJzx0aCBzY29wZT1cInJvd1wiPkNvbHVtbiBUeXBlczwvdGg+JyxcbiAgICAgICAgICAgICAgICAnPHRkIHNjb3BlPVwicm93XCI+PCU9IF8uZXNjYXBlKGl0ZW0uZ2V0KFwibWV0YWRhdGFfY29sdW1uX3R5cGVzXCIpKSAlPjwvdGQ+JyxcbiAgICAgICAgICAgICAgICBcIjwvdHI+XCIsXG4gICAgICAgICAgICAgICAgXCI8JSB9ICU+XCIsXG4gICAgICAgICAgICAgICAgJzwlIGlmIChpdGVtLmdldChcIm1lc3NhZ2VcIikpIHsgJT4nLFxuICAgICAgICAgICAgICAgIFwiPHRyPlwiLFxuICAgICAgICAgICAgICAgICc8dGggc2NvcGU9XCJyb3dcIj5NZXNzYWdlPC90aD4nLFxuICAgICAgICAgICAgICAgICc8dGQgc2NvcGU9XCJyb3dcIj48JT0gXy5lc2NhcGUoaXRlbS5nZXQoXCJtZXNzYWdlXCIpKSAlPjwvdGQ+JyxcbiAgICAgICAgICAgICAgICBcIjwvdHI+XCIsXG4gICAgICAgICAgICAgICAgXCI8JSB9ICU+XCIsXG4gICAgICAgICAgICAgICAgJzwlIGlmIChpdGVtLmdldChcIm1pc2NfYmx1cmJcIikpIHsgJT4nLFxuICAgICAgICAgICAgICAgIFwiPHRyPlwiLFxuICAgICAgICAgICAgICAgICc8dGggc2NvcGU9XCJyb3dcIj5NaXNjLiBibHVyYjwvdGg+JyxcbiAgICAgICAgICAgICAgICAnPHRkIHNjb3BlPVwicm93XCI+PCU9IF8uZXNjYXBlKGl0ZW0uZ2V0KFwibWlzY19ibHVyYlwiKSkgJT48L3RkPicsXG4gICAgICAgICAgICAgICAgXCI8L3RyPlwiLFxuICAgICAgICAgICAgICAgIFwiPCUgfSAlPlwiLFxuICAgICAgICAgICAgICAgICc8JSBpZiAoaXRlbS5nZXQoXCJtaXNjX2luZm9cIikpIHsgJT4nLFxuICAgICAgICAgICAgICAgIFwiPHRyPlwiLFxuICAgICAgICAgICAgICAgICc8dGggc2NvcGU9XCJyb3dcIj5NaXNjLiBpbmZvPC90aD4nLFxuICAgICAgICAgICAgICAgICc8dGQgc2NvcGU9XCJyb3dcIj48JT0gXy5lc2NhcGUoaXRlbS5nZXQoXCJtaXNjX2luZm9cIikpICU+PC90ZD4nLFxuICAgICAgICAgICAgICAgIFwiPC90cj5cIixcbiAgICAgICAgICAgICAgICBcIjwlIH0gJT5cIixcbiAgICAgICAgICAgICAgICAnPCUgaWYgKGl0ZW0uZ2V0KFwidGFnc1wiKSkgeyAlPicsXG4gICAgICAgICAgICAgICAgXCI8dHI+XCIsXG4gICAgICAgICAgICAgICAgJzx0aCBzY29wZT1cInJvd1wiPlRhZ3M8L3RoPicsXG4gICAgICAgICAgICAgICAgJzx0ZCBzY29wZT1cInJvd1wiPjwlPSBfLmVzY2FwZShpdGVtLmdldChcInRhZ3NcIikpICU+PC90ZD4nLFxuICAgICAgICAgICAgICAgIFwiPC90cj5cIixcbiAgICAgICAgICAgICAgICBcIjwlIH0gJT5cIixcbiAgICAgICAgICAgICAgICAnPCUgaWYgKCBpdGVtLmdldChcInV1aWRcIikgIT09IFwib2tcIiApIHsgJT4nLFxuICAgICAgICAgICAgICAgIFwiPHRyPlwiLFxuICAgICAgICAgICAgICAgICc8dGggc2NvcGU9XCJyb3dcIj5VVUlEPC90aD4nLFxuICAgICAgICAgICAgICAgICc8dGQgc2NvcGU9XCJyb3dcIj48JT0gXy5lc2NhcGUoaXRlbS5nZXQoXCJ1dWlkXCIpKSAlPjwvdGQ+JyxcbiAgICAgICAgICAgICAgICBcIjwvdHI+XCIsXG4gICAgICAgICAgICAgICAgXCI8JSB9ICU+XCIsXG4gICAgICAgICAgICAgICAgJzwlIGlmICggaXRlbS5nZXQoXCJzdGF0ZVwiKSAhPT0gXCJva1wiICkgeyAlPicsXG4gICAgICAgICAgICAgICAgXCI8dHI+XCIsXG4gICAgICAgICAgICAgICAgJzx0aCBzY29wZT1cInJvd1wiPlN0YXRlPC90aD4nLFxuICAgICAgICAgICAgICAgICc8dGQgc2NvcGU9XCJyb3dcIj48JT0gXy5lc2NhcGUoaXRlbS5nZXQoXCJzdGF0ZVwiKSkgJT48L3RkPicsXG4gICAgICAgICAgICAgICAgXCI8L3RyPlwiLFxuICAgICAgICAgICAgICAgIFwiPCUgfSAlPlwiLFxuICAgICAgICAgICAgICAgIFwiPC90YWJsZT5cIixcblxuICAgICAgICAgICAgICAgICc8JSBpZiAoaXRlbS5nZXQoXCJqb2Jfc3RkZXJyXCIpKSB7ICU+JyxcbiAgICAgICAgICAgICAgICBcIjxoND5Kb2IgU3RhbmRhcmQgRXJyb3I8L2g0PlwiLFxuICAgICAgICAgICAgICAgICc8cHJlIGNsYXNzPVwiY29kZVwiPicsXG4gICAgICAgICAgICAgICAgJzwlPSBfLmVzY2FwZShpdGVtLmdldChcImpvYl9zdGRlcnJcIikpICU+JyxcbiAgICAgICAgICAgICAgICBcIjwvcHJlPlwiLFxuICAgICAgICAgICAgICAgIFwiPCUgfSAlPlwiLFxuXG4gICAgICAgICAgICAgICAgJzwlIGlmIChpdGVtLmdldChcImpvYl9zdGRvdXRcIikpIHsgJT4nLFxuICAgICAgICAgICAgICAgIFwiPGg0PkpvYiBTdGFuZGFyZCBPdXRwdXQ8L2g0PlwiLFxuICAgICAgICAgICAgICAgICc8cHJlIGNsYXNzPVwiY29kZVwiPicsXG4gICAgICAgICAgICAgICAgJzwlPSBfLmVzY2FwZShpdGVtLmdldChcImpvYl9zdGRvdXRcIikpICU+JyxcbiAgICAgICAgICAgICAgICBcIjwvcHJlPlwiLFxuICAgICAgICAgICAgICAgIFwiPCUgfSAlPlwiLFxuXG4gICAgICAgICAgICAgICAgXCI8ZGl2PlwiLFxuICAgICAgICAgICAgICAgICc8cHJlIGNsYXNzPVwicGVla1wiPicsXG4gICAgICAgICAgICAgICAgXCI8L3ByZT5cIixcbiAgICAgICAgICAgICAgICBcIjwvZGl2PlwiLFxuXG4gICAgICAgICAgICAgICAgJzwlIGlmIChpdGVtLmdldChcImhhc192ZXJzaW9uc1wiKSkgeyAlPicsXG4gICAgICAgICAgICAgICAgXCI8ZGl2PlwiLFxuICAgICAgICAgICAgICAgIFwiPGgzPkV4cGlyZWQgdmVyc2lvbnM6PC9oMz5cIixcbiAgICAgICAgICAgICAgICBcIjx1bD5cIixcbiAgICAgICAgICAgICAgICAnPCUgXy5lYWNoKGl0ZW0uZ2V0KFwiZXhwaXJlZF92ZXJzaW9uc1wiKSwgZnVuY3Rpb24odmVyc2lvbikgeyAlPicsXG4gICAgICAgICAgICAgICAgJzxsaT48YSB0aXRsZT1cIlNlZSBkZXRhaWxzIG9mIHRoaXMgdmVyc2lvblwiIGhyZWY9XCIjZm9sZGVycy88JS0gaXRlbS5nZXQoXCJmb2xkZXJfaWRcIikgJT4vZGF0YXNldHMvPCUtIGl0ZW0uaWQgJT4vdmVyc2lvbnMvPCUtIHZlcnNpb25bMF0gJT5cIj48JS0gdmVyc2lvblsxXSAlPjwvYT48L2xpPicsXG4gICAgICAgICAgICAgICAgXCI8JSB9KSAlPlwiLFxuICAgICAgICAgICAgICAgIFwiPHVsPlwiLFxuICAgICAgICAgICAgICAgIFwiPC9kaXY+XCIsXG4gICAgICAgICAgICAgICAgXCI8JSB9ICU+XCIsXG4gICAgICAgICAgICAgICAgLy8gVEFCTEUgRU5EXG4gICAgICAgICAgICAgICAgXCI8L2Rpdj5cIixcbiAgICAgICAgICAgICAgICAvLyBDT05UQUlORVIgRU5EXG4gICAgICAgICAgICAgICAgXCI8L2Rpdj5cIlxuICAgICAgICAgICAgXS5qb2luKFwiXCIpXG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIHRlbXBsYXRlVmVyc2lvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfLnRlbXBsYXRlKFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIC8vIENPTlRBSU5FUiBTVEFSVFxuICAgICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwibGlicmFyeV9zdHlsZV9jb250YWluZXJcIj4nLFxuICAgICAgICAgICAgICAgICc8ZGl2IGlkPVwibGlicmFyeV90b29sYmFyXCI+JyxcbiAgICAgICAgICAgICAgICAnPGEgaHJlZj1cIiNmb2xkZXJzLzwlLSBpdGVtLmdldChcImZvbGRlcl9pZFwiKSAlPi9kYXRhc2V0cy88JS0gaXRlbS5pZCAlPlwiPicsXG4gICAgICAgICAgICAgICAgJzxidXR0b24gZGF0YS10b2dnbGU9XCJ0b29sdGlwXCIgZGF0YS1wbGFjZW1lbnQ9XCJ0b3BcIiB0aXRsZT1cIkdvIHRvIGxhdGVzdCBkYXRhc2V0XCIgY2xhc3M9XCJidG4gYnRuLWRlZmF1bHQgcHJpbWFyeS1idXR0b24gdG9vbGJhci1pdGVtXCIgdHlwZT1cImJ1dHRvblwiPicsXG4gICAgICAgICAgICAgICAgJzxzcGFuIGNsYXNzPVwiZmEgZmEtY2FyZXQtbGVmdCBmYS1sZ1wiPjwvc3Bhbj4nLFxuICAgICAgICAgICAgICAgIFwiJm5ic3A7TGF0ZXN0IGRhdGFzZXRcIixcbiAgICAgICAgICAgICAgICBcIjwvYnV0dG9uPlwiLFxuICAgICAgICAgICAgICAgIFwiPGE+XCIsXG4gICAgICAgICAgICAgICAgXCI8L2Rpdj5cIixcblxuICAgICAgICAgICAgICAgIC8vIEJSRUFEQ1JVTUJTXG4gICAgICAgICAgICAgICAgJzxvbCBjbGFzcz1cImJyZWFkY3J1bWJcIj4nLFxuICAgICAgICAgICAgICAgICc8bGk+PGEgdGl0bGU9XCJSZXR1cm4gdG8gdGhlIGxpc3Qgb2YgbGlicmFyaWVzXCIgaHJlZj1cIiNcIj5MaWJyYXJpZXM8L2E+PC9saT4nLFxuICAgICAgICAgICAgICAgICc8JSBfLmVhY2goaXRlbS5nZXQoXCJmdWxsX3BhdGhcIiksIGZ1bmN0aW9uKHBhdGhfaXRlbSkgeyAlPicsXG4gICAgICAgICAgICAgICAgXCI8JSBpZiAocGF0aF9pdGVtWzBdICE9IGl0ZW0uaWQpIHsgJT5cIixcbiAgICAgICAgICAgICAgICAnPGxpPjxhIHRpdGxlPVwiUmV0dXJuIHRvIHRoaXMgZm9sZGVyXCIgaHJlZj1cIiMvZm9sZGVycy88JS0gcGF0aF9pdGVtWzBdICU+XCI+PCUtIHBhdGhfaXRlbVsxXSAlPjwvYT4gPC9saT4gJyxcbiAgICAgICAgICAgICAgICBcIjwlIH0gZWxzZSB7ICU+XCIsXG4gICAgICAgICAgICAgICAgJzxsaSBjbGFzcz1cImFjdGl2ZVwiPjxzcGFuIHRpdGxlPVwiWW91IGFyZSBoZXJlXCI+PCUtIHBhdGhfaXRlbVsxXSAlPjwvc3Bhbj48L2xpPicsXG4gICAgICAgICAgICAgICAgXCI8JSB9ICU+XCIsXG4gICAgICAgICAgICAgICAgXCI8JSB9KTsgJT5cIixcbiAgICAgICAgICAgICAgICBcIjwvb2w+XCIsXG5cbiAgICAgICAgICAgICAgICAnPGRpdiBjbGFzcz1cImFsZXJ0IGFsZXJ0LXdhcm5pbmdcIj5UaGlzIGlzIGFuIGV4cGlyZWQgdmVyc2lvbiBvZiB0aGUgbGlicmFyeSBkYXRhc2V0OiA8JT0gXy5lc2NhcGUoaXRlbS5nZXQoXCJuYW1lXCIpKSAlPjwvZGl2PicsXG4gICAgICAgICAgICAgICAgLy8gREFUQVNFVCBTVEFSVFxuICAgICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiZGF0YXNldF90YWJsZVwiPicsXG4gICAgICAgICAgICAgICAgJzx0YWJsZSBjbGFzcz1cImdyaWQgdGFibGUgdGFibGUtc3RyaXBlZCB0YWJsZS1jb25kZW5zZWRcIj4nLFxuICAgICAgICAgICAgICAgIFwiPHRyPlwiLFxuICAgICAgICAgICAgICAgICc8dGggc2NvcGU9XCJyb3dcIiBpZD1cImlkX3Jvd1wiIGRhdGEtaWQ9XCI8JT0gXy5lc2NhcGUobGRkYS5pZCkgJT5cIj5OYW1lPC90aD4nLFxuICAgICAgICAgICAgICAgICc8dGQ+PCU9IF8uZXNjYXBlKGxkZGEuZ2V0KFwibmFtZVwiKSkgJT48L3RkPicsXG4gICAgICAgICAgICAgICAgXCI8L3RyPlwiLFxuICAgICAgICAgICAgICAgICc8JSBpZiAobGRkYS5nZXQoXCJmaWxlX2V4dFwiKSkgeyAlPicsXG4gICAgICAgICAgICAgICAgXCI8dHI+XCIsXG4gICAgICAgICAgICAgICAgJzx0aCBzY29wZT1cInJvd1wiPkRhdGEgdHlwZTwvdGg+JyxcbiAgICAgICAgICAgICAgICAnPHRkPjwlPSBfLmVzY2FwZShsZGRhLmdldChcImZpbGVfZXh0XCIpKSAlPjwvdGQ+JyxcbiAgICAgICAgICAgICAgICBcIjwvdHI+XCIsXG4gICAgICAgICAgICAgICAgXCI8JSB9ICU+XCIsXG4gICAgICAgICAgICAgICAgJzwlIGlmIChsZGRhLmdldChcImdlbm9tZV9idWlsZFwiKSkgeyAlPicsXG4gICAgICAgICAgICAgICAgXCI8dHI+XCIsXG4gICAgICAgICAgICAgICAgJzx0aCBzY29wZT1cInJvd1wiPkdlbm9tZSBidWlsZDwvdGg+JyxcbiAgICAgICAgICAgICAgICAnPHRkPjwlPSBfLmVzY2FwZShsZGRhLmdldChcImdlbm9tZV9idWlsZFwiKSkgJT48L3RkPicsXG4gICAgICAgICAgICAgICAgXCI8L3RyPlwiLFxuICAgICAgICAgICAgICAgIFwiPCUgfSAlPlwiLFxuICAgICAgICAgICAgICAgICc8JSBpZiAobGRkYS5nZXQoXCJmaWxlX3NpemVcIikpIHsgJT4nLFxuICAgICAgICAgICAgICAgIFwiPHRyPlwiLFxuICAgICAgICAgICAgICAgICc8dGggc2NvcGU9XCJyb3dcIj5TaXplPC90aD4nLFxuICAgICAgICAgICAgICAgICc8dGQ+PCU9IF8uZXNjYXBlKGxkZGEuZ2V0KFwiZmlsZV9zaXplXCIpKSAlPjwvdGQ+JyxcbiAgICAgICAgICAgICAgICBcIjwvdHI+XCIsXG4gICAgICAgICAgICAgICAgXCI8JSB9ICU+XCIsXG4gICAgICAgICAgICAgICAgJzwlIGlmIChsZGRhLmdldChcImRhdGVfdXBsb2FkZWRcIikpIHsgJT4nLFxuICAgICAgICAgICAgICAgIFwiPHRyPlwiLFxuICAgICAgICAgICAgICAgICc8dGggc2NvcGU9XCJyb3dcIj5EYXRlIHVwbG9hZGVkIChVVEMpPC90aD4nLFxuICAgICAgICAgICAgICAgICc8dGQ+PCU9IF8uZXNjYXBlKGxkZGEuZ2V0KFwiZGF0ZV91cGxvYWRlZFwiKSkgJT48L3RkPicsXG4gICAgICAgICAgICAgICAgXCI8L3RyPlwiLFxuICAgICAgICAgICAgICAgIFwiPCUgfSAlPlwiLFxuICAgICAgICAgICAgICAgICc8JSBpZiAobGRkYS5nZXQoXCJ1cGxvYWRlZF9ieVwiKSkgeyAlPicsXG4gICAgICAgICAgICAgICAgXCI8dHI+XCIsXG4gICAgICAgICAgICAgICAgJzx0aCBzY29wZT1cInJvd1wiPlVwbG9hZGVkIGJ5PC90aD4nLFxuICAgICAgICAgICAgICAgICc8dGQ+PCU9IF8uZXNjYXBlKGxkZGEuZ2V0KFwidXBsb2FkZWRfYnlcIikpICU+PC90ZD4nLFxuICAgICAgICAgICAgICAgIFwiPC90cj5cIixcbiAgICAgICAgICAgICAgICBcIjwlIH0gJT5cIixcbiAgICAgICAgICAgICAgICAnPCUgaWYgKGxkZGEuZ2V0KFwibWV0YWRhdGFfZGF0YV9saW5lc1wiKSkgeyAlPicsXG4gICAgICAgICAgICAgICAgXCI8dHI+XCIsXG4gICAgICAgICAgICAgICAgJzx0aCBzY29wZT1cInJvd1wiPkRhdGEgTGluZXM8L3RoPicsXG4gICAgICAgICAgICAgICAgJzx0ZCBzY29wZT1cInJvd1wiPjwlPSBfLmVzY2FwZShsZGRhLmdldChcIm1ldGFkYXRhX2RhdGFfbGluZXNcIikpICU+PC90ZD4nLFxuICAgICAgICAgICAgICAgIFwiPC90cj5cIixcbiAgICAgICAgICAgICAgICBcIjwlIH0gJT5cIixcbiAgICAgICAgICAgICAgICAnPCUgaWYgKGxkZGEuZ2V0KFwibWV0YWRhdGFfY29tbWVudF9saW5lc1wiKSkgeyAlPicsXG4gICAgICAgICAgICAgICAgXCI8dHI+XCIsXG4gICAgICAgICAgICAgICAgJzx0aCBzY29wZT1cInJvd1wiPkNvbW1lbnQgTGluZXM8L3RoPicsXG4gICAgICAgICAgICAgICAgJzx0ZCBzY29wZT1cInJvd1wiPjwlPSBfLmVzY2FwZShsZGRhLmdldChcIm1ldGFkYXRhX2NvbW1lbnRfbGluZXNcIikpICU+PC90ZD4nLFxuICAgICAgICAgICAgICAgIFwiPC90cj5cIixcbiAgICAgICAgICAgICAgICBcIjwlIH0gJT5cIixcbiAgICAgICAgICAgICAgICAnPCUgaWYgKGxkZGEuZ2V0KFwibWV0YWRhdGFfY29sdW1uc1wiKSkgeyAlPicsXG4gICAgICAgICAgICAgICAgXCI8dHI+XCIsXG4gICAgICAgICAgICAgICAgJzx0aCBzY29wZT1cInJvd1wiPk51bWJlciBvZiBDb2x1bW5zPC90aD4nLFxuICAgICAgICAgICAgICAgICc8dGQgc2NvcGU9XCJyb3dcIj48JT0gXy5lc2NhcGUobGRkYS5nZXQoXCJtZXRhZGF0YV9jb2x1bW5zXCIpKSAlPjwvdGQ+JyxcbiAgICAgICAgICAgICAgICBcIjwvdHI+XCIsXG4gICAgICAgICAgICAgICAgXCI8JSB9ICU+XCIsXG4gICAgICAgICAgICAgICAgJzwlIGlmIChsZGRhLmdldChcIm1ldGFkYXRhX2NvbHVtbl90eXBlc1wiKSkgeyAlPicsXG4gICAgICAgICAgICAgICAgXCI8dHI+XCIsXG4gICAgICAgICAgICAgICAgJzx0aCBzY29wZT1cInJvd1wiPkNvbHVtbiBUeXBlczwvdGg+JyxcbiAgICAgICAgICAgICAgICAnPHRkIHNjb3BlPVwicm93XCI+PCU9IF8uZXNjYXBlKGxkZGEuZ2V0KFwibWV0YWRhdGFfY29sdW1uX3R5cGVzXCIpKSAlPjwvdGQ+JyxcbiAgICAgICAgICAgICAgICBcIjwvdHI+XCIsXG4gICAgICAgICAgICAgICAgXCI8JSB9ICU+XCIsXG4gICAgICAgICAgICAgICAgJzwlIGlmIChsZGRhLmdldChcIm1lc3NhZ2VcIikpIHsgJT4nLFxuICAgICAgICAgICAgICAgIFwiPHRyPlwiLFxuICAgICAgICAgICAgICAgICc8dGggc2NvcGU9XCJyb3dcIj5NZXNzYWdlPC90aD4nLFxuICAgICAgICAgICAgICAgICc8dGQgc2NvcGU9XCJyb3dcIj48JT0gXy5lc2NhcGUobGRkYS5nZXQoXCJtZXNzYWdlXCIpKSAlPjwvdGQ+JyxcbiAgICAgICAgICAgICAgICBcIjwvdHI+XCIsXG4gICAgICAgICAgICAgICAgXCI8JSB9ICU+XCIsXG4gICAgICAgICAgICAgICAgJzwlIGlmIChsZGRhLmdldChcIm1pc2NfYmx1cmJcIikpIHsgJT4nLFxuICAgICAgICAgICAgICAgIFwiPHRyPlwiLFxuICAgICAgICAgICAgICAgICc8dGggc2NvcGU9XCJyb3dcIj5NaXNjZWxsYW5lb3VzIGJsdXJiPC90aD4nLFxuICAgICAgICAgICAgICAgICc8dGQgc2NvcGU9XCJyb3dcIj48JT0gXy5lc2NhcGUobGRkYS5nZXQoXCJtaXNjX2JsdXJiXCIpKSAlPjwvdGQ+JyxcbiAgICAgICAgICAgICAgICBcIjwvdHI+XCIsXG4gICAgICAgICAgICAgICAgXCI8JSB9ICU+XCIsXG4gICAgICAgICAgICAgICAgJzwlIGlmIChsZGRhLmdldChcIm1pc2NfaW5mb1wiKSkgeyAlPicsXG4gICAgICAgICAgICAgICAgXCI8dHI+XCIsXG4gICAgICAgICAgICAgICAgJzx0aCBzY29wZT1cInJvd1wiPk1pc2NlbGxhbmVvdXMgaW5mb3JtYXRpb248L3RoPicsXG4gICAgICAgICAgICAgICAgJzx0ZCBzY29wZT1cInJvd1wiPjwlPSBfLmVzY2FwZShsZGRhLmdldChcIm1pc2NfaW5mb1wiKSkgJT48L3RkPicsXG4gICAgICAgICAgICAgICAgXCI8L3RyPlwiLFxuICAgICAgICAgICAgICAgIFwiPCUgfSAlPlwiLFxuICAgICAgICAgICAgICAgICc8JSBpZiAoaXRlbS5nZXQoXCJ0YWdzXCIpKSB7ICU+JyxcbiAgICAgICAgICAgICAgICBcIjx0cj5cIixcbiAgICAgICAgICAgICAgICAnPHRoIHNjb3BlPVwicm93XCI+VGFnczwvdGg+JyxcbiAgICAgICAgICAgICAgICAnPHRkIHNjb3BlPVwicm93XCI+PCU9IF8uZXNjYXBlKGl0ZW0uZ2V0KFwidGFnc1wiKSkgJT48L3RkPicsXG4gICAgICAgICAgICAgICAgXCI8L3RyPlwiLFxuICAgICAgICAgICAgICAgIFwiPCUgfSAlPlwiLFxuICAgICAgICAgICAgICAgIFwiPC90YWJsZT5cIixcbiAgICAgICAgICAgICAgICBcIjxkaXY+XCIsXG4gICAgICAgICAgICAgICAgJzxwcmUgY2xhc3M9XCJwZWVrXCI+JyxcbiAgICAgICAgICAgICAgICBcIjwvcHJlPlwiLFxuICAgICAgICAgICAgICAgIFwiPC9kaXY+XCIsXG4gICAgICAgICAgICAgICAgLy8gREFUQVNFVCBFTkRcbiAgICAgICAgICAgICAgICBcIjwvZGl2PlwiLFxuICAgICAgICAgICAgICAgIC8vIENPTlRBSU5FUiBFTkRcbiAgICAgICAgICAgICAgICBcIjwvZGl2PlwiXG4gICAgICAgICAgICBdLmpvaW4oXCJcIilcbiAgICAgICAgKTtcbiAgICB9LFxuXG4gICAgdGVtcGxhdGVNb2RpZnlEYXRhc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF8udGVtcGxhdGUoXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgLy8gQ09OVEFJTkVSIFNUQVJUXG4gICAgICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJsaWJyYXJ5X3N0eWxlX2NvbnRhaW5lclwiPicsXG4gICAgICAgICAgICAgICAgJzxkaXYgaWQ9XCJsaWJyYXJ5X3Rvb2xiYXJcIj4nLFxuICAgICAgICAgICAgICAgICc8YnV0dG9uIGRhdGEtdG9nZ2xlPVwidG9vbHRpcFwiIGRhdGEtcGxhY2VtZW50PVwidG9wXCIgdGl0bGU9XCJDYW5jZWwgbW9kaWZpY2F0aW9uc1wiIGNsYXNzPVwiYnRuIGJ0bi1kZWZhdWx0IHRvb2xidG5fY2FuY2VsX21vZGlmaWNhdGlvbnMgcHJpbWFyeS1idXR0b24gdG9vbGJhci1pdGVtXCIgdHlwZT1cImJ1dHRvblwiPicsXG4gICAgICAgICAgICAgICAgJzxzcGFuIGNsYXNzPVwiZmEgZmEtdGltZXNcIj48L3NwYW4+JyxcbiAgICAgICAgICAgICAgICBcIiZuYnNwO0NhbmNlbFwiLFxuICAgICAgICAgICAgICAgIFwiPC9idXR0b24+XCIsXG4gICAgICAgICAgICAgICAgJzxidXR0b24gZGF0YS10b2dnbGU9XCJ0b29sdGlwXCIgZGF0YS1wbGFjZW1lbnQ9XCJ0b3BcIiB0aXRsZT1cIlNhdmUgbW9kaWZpY2F0aW9uc1wiIGNsYXNzPVwiYnRuIGJ0bi1kZWZhdWx0IHRvb2xidG5fc2F2ZV9tb2RpZmljYXRpb25zIHByaW1hcnktYnV0dG9uIHRvb2xiYXItaXRlbVwiIHR5cGU9XCJidXR0b25cIj4nLFxuICAgICAgICAgICAgICAgICc8c3BhbiBjbGFzcz1cImZhIGZhLWZsb3BweS1vXCI+PC9zcGFuPicsXG4gICAgICAgICAgICAgICAgXCImbmJzcDtTYXZlXCIsXG4gICAgICAgICAgICAgICAgXCI8L2J1dHRvbj5cIixcbiAgICAgICAgICAgICAgICBcIjwvZGl2PlwiLFxuXG4gICAgICAgICAgICAgICAgLy8gQlJFQURDUlVNQlNcbiAgICAgICAgICAgICAgICAnPG9sIGNsYXNzPVwiYnJlYWRjcnVtYlwiPicsXG4gICAgICAgICAgICAgICAgJzxsaT48YSB0aXRsZT1cIlJldHVybiB0byB0aGUgbGlzdCBvZiBsaWJyYXJpZXNcIiBocmVmPVwiI1wiPkxpYnJhcmllczwvYT48L2xpPicsXG4gICAgICAgICAgICAgICAgJzwlIF8uZWFjaChpdGVtLmdldChcImZ1bGxfcGF0aFwiKSwgZnVuY3Rpb24ocGF0aF9pdGVtKSB7ICU+JyxcbiAgICAgICAgICAgICAgICBcIjwlIGlmIChwYXRoX2l0ZW1bMF0gIT0gaXRlbS5pZCkgeyAlPlwiLFxuICAgICAgICAgICAgICAgICc8bGk+PGEgdGl0bGU9XCJSZXR1cm4gdG8gdGhpcyBmb2xkZXJcIiBocmVmPVwiIy9mb2xkZXJzLzwlLSBwYXRoX2l0ZW1bMF0gJT5cIj48JS0gcGF0aF9pdGVtWzFdICU+PC9hPiA8L2xpPiAnLFxuICAgICAgICAgICAgICAgIFwiPCUgfSBlbHNlIHsgJT5cIixcbiAgICAgICAgICAgICAgICAnPGxpIGNsYXNzPVwiYWN0aXZlXCI+PHNwYW4gdGl0bGU9XCJZb3UgYXJlIGhlcmVcIj48JS0gcGF0aF9pdGVtWzFdICU+PC9zcGFuPjwvbGk+JyxcbiAgICAgICAgICAgICAgICBcIjwlIH0gJT5cIixcbiAgICAgICAgICAgICAgICBcIjwlIH0pOyAlPlwiLFxuICAgICAgICAgICAgICAgIFwiPC9vbD5cIixcblxuICAgICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiZGF0YXNldF90YWJsZVwiPicsXG4gICAgICAgICAgICAgICAgJzx0YWJsZSBjbGFzcz1cImdyaWQgdGFibGUgdGFibGUtc3RyaXBlZCB0YWJsZS1jb25kZW5zZWRcIj4nLFxuICAgICAgICAgICAgICAgIFwiPHRyPlwiLFxuICAgICAgICAgICAgICAgICc8dGggY2xhc3M9XCJkYXRhc2V0LWZpcnN0LWNvbHVtblwiIHNjb3BlPVwicm93XCIgaWQ9XCJpZF9yb3dcIiBkYXRhLWlkPVwiPCU9IF8uZXNjYXBlKGl0ZW0uZ2V0KFwibGRkYV9pZFwiKSkgJT5cIj5OYW1lPC90aD4nLFxuICAgICAgICAgICAgICAgICc8dGQ+PGlucHV0IGNsYXNzPVwiaW5wdXRfZGF0YXNldF9uYW1lIGZvcm0tY29udHJvbFwiIHR5cGU9XCJ0ZXh0XCIgcGxhY2Vob2xkZXI9XCJuYW1lXCIgdmFsdWU9XCI8JT0gXy5lc2NhcGUoaXRlbS5nZXQoXCJuYW1lXCIpKSAlPlwiPjwvdGQ+JyxcbiAgICAgICAgICAgICAgICBcIjwvdHI+XCIsXG4gICAgICAgICAgICAgICAgXCI8dHI+XCIsXG4gICAgICAgICAgICAgICAgJzx0aCBzY29wZT1cInJvd1wiPkRhdGEgdHlwZTwvdGg+JyxcbiAgICAgICAgICAgICAgICBcIjx0ZD5cIixcbiAgICAgICAgICAgICAgICAnPHNwYW4gaWQ9XCJkYXRhc2V0X2V4dGVuc2lvbl9zZWxlY3RcIiBjbGFzcz1cImRhdGFzZXQtZXh0ZW5zaW9uLXNlbGVjdFwiIC8+JyxcbiAgICAgICAgICAgICAgICBcIjwvdGQ+XCIsXG4gICAgICAgICAgICAgICAgXCI8L3RyPlwiLFxuICAgICAgICAgICAgICAgIFwiPHRyPlwiLFxuICAgICAgICAgICAgICAgICc8dGggc2NvcGU9XCJyb3dcIj5HZW5vbWUgYnVpbGQ8L3RoPicsXG4gICAgICAgICAgICAgICAgXCI8dGQ+XCIsXG4gICAgICAgICAgICAgICAgJzxzcGFuIGlkPVwiZGF0YXNldF9nZW5vbWVfc2VsZWN0XCIgY2xhc3M9XCJkYXRhc2V0LWdlbm9tZS1zZWxlY3RcIiAvPicsXG4gICAgICAgICAgICAgICAgXCI8L3RkPlwiLFxuICAgICAgICAgICAgICAgIFwiPC90cj5cIixcbiAgICAgICAgICAgICAgICBcIjx0cj5cIixcbiAgICAgICAgICAgICAgICAnPHRoIHNjb3BlPVwicm93XCI+U2l6ZTwvdGg+JyxcbiAgICAgICAgICAgICAgICAnPHRkPjwlPSBfLmVzY2FwZShpdGVtLmdldChcImZpbGVfc2l6ZVwiKSkgJT48L3RkPicsXG4gICAgICAgICAgICAgICAgXCI8L3RyPlwiLFxuICAgICAgICAgICAgICAgIFwiPHRyPlwiLFxuICAgICAgICAgICAgICAgICc8dGggc2NvcGU9XCJyb3dcIj5EYXRlIHVwbG9hZGVkIChVVEMpPC90aD4nLFxuICAgICAgICAgICAgICAgICc8dGQ+PCU9IF8uZXNjYXBlKGl0ZW0uZ2V0KFwiZGF0ZV91cGxvYWRlZFwiKSkgJT48L3RkPicsXG4gICAgICAgICAgICAgICAgXCI8L3RyPlwiLFxuICAgICAgICAgICAgICAgIFwiPHRyPlwiLFxuICAgICAgICAgICAgICAgICc8dGggc2NvcGU9XCJyb3dcIj5VcGxvYWRlZCBieTwvdGg+JyxcbiAgICAgICAgICAgICAgICAnPHRkPjwlPSBfLmVzY2FwZShpdGVtLmdldChcInVwbG9hZGVkX2J5XCIpKSAlPjwvdGQ+JyxcbiAgICAgICAgICAgICAgICBcIjwvdHI+XCIsXG4gICAgICAgICAgICAgICAgJzx0ciBzY29wZT1cInJvd1wiPicsXG4gICAgICAgICAgICAgICAgJzx0aCBzY29wZT1cInJvd1wiPkRhdGEgTGluZXM8L3RoPicsXG4gICAgICAgICAgICAgICAgJzx0ZCBzY29wZT1cInJvd1wiPjwlPSBfLmVzY2FwZShpdGVtLmdldChcIm1ldGFkYXRhX2RhdGFfbGluZXNcIikpICU+PC90ZD4nLFxuICAgICAgICAgICAgICAgIFwiPC90cj5cIixcbiAgICAgICAgICAgICAgICAnPHRoIHNjb3BlPVwicm93XCI+Q29tbWVudCBMaW5lczwvdGg+JyxcbiAgICAgICAgICAgICAgICAnPCUgaWYgKGl0ZW0uZ2V0KFwibWV0YWRhdGFfY29tbWVudF9saW5lc1wiKSA9PT0gXCJcIikgeyAlPicsXG4gICAgICAgICAgICAgICAgJzx0ZCBzY29wZT1cInJvd1wiPjwlPSBfLmVzY2FwZShpdGVtLmdldChcIm1ldGFkYXRhX2NvbW1lbnRfbGluZXNcIikpICU+PC90ZD4nLFxuICAgICAgICAgICAgICAgIFwiPCUgfSBlbHNlIHsgJT5cIixcbiAgICAgICAgICAgICAgICAnPHRkIHNjb3BlPVwicm93XCI+dW5rbm93bjwvdGQ+JyxcbiAgICAgICAgICAgICAgICBcIjwlIH0gJT5cIixcbiAgICAgICAgICAgICAgICBcIjwvdHI+XCIsXG4gICAgICAgICAgICAgICAgXCI8dHI+XCIsXG4gICAgICAgICAgICAgICAgJzx0aCBzY29wZT1cInJvd1wiPk51bWJlciBvZiBDb2x1bW5zPC90aD4nLFxuICAgICAgICAgICAgICAgICc8dGQgc2NvcGU9XCJyb3dcIj48JT0gXy5lc2NhcGUoaXRlbS5nZXQoXCJtZXRhZGF0YV9jb2x1bW5zXCIpKSAlPjwvdGQ+JyxcbiAgICAgICAgICAgICAgICBcIjwvdHI+XCIsXG4gICAgICAgICAgICAgICAgXCI8dHI+XCIsXG4gICAgICAgICAgICAgICAgJzx0aCBzY29wZT1cInJvd1wiPkNvbHVtbiBUeXBlczwvdGg+JyxcbiAgICAgICAgICAgICAgICAnPHRkIHNjb3BlPVwicm93XCI+PCU9IF8uZXNjYXBlKGl0ZW0uZ2V0KFwibWV0YWRhdGFfY29sdW1uX3R5cGVzXCIpKSAlPjwvdGQ+JyxcbiAgICAgICAgICAgICAgICBcIjwvdHI+XCIsXG4gICAgICAgICAgICAgICAgXCI8dHI+XCIsXG4gICAgICAgICAgICAgICAgJzx0aCBzY29wZT1cInJvd1wiPk1lc3NhZ2U8L3RoPicsXG4gICAgICAgICAgICAgICAgJzx0ZCBzY29wZT1cInJvd1wiPjwlPSBfLmVzY2FwZShpdGVtLmdldChcIm1lc3NhZ2VcIikpICU+PC90ZD4nLFxuICAgICAgICAgICAgICAgIFwiPC90cj5cIixcbiAgICAgICAgICAgICAgICBcIjx0cj5cIixcbiAgICAgICAgICAgICAgICAnPHRoIHNjb3BlPVwicm93XCI+TWlzYy4gYmx1cmI8L3RoPicsXG4gICAgICAgICAgICAgICAgJzx0ZCBzY29wZT1cInJvd1wiPjwlPSBfLmVzY2FwZShpdGVtLmdldChcIm1pc2NfYmx1cmJcIikpICU+PC90ZD4nLFxuICAgICAgICAgICAgICAgIFwiPC90cj5cIixcbiAgICAgICAgICAgICAgICBcIjx0cj5cIixcbiAgICAgICAgICAgICAgICAnPHRoIHNjb3BlPVwicm93XCI+TWlzYy4gaW5mb3JtYXRpb248L3RoPicsXG4gICAgICAgICAgICAgICAgJzx0ZD48aW5wdXQgY2xhc3M9XCJpbnB1dF9kYXRhc2V0X21pc2NfaW5mbyBmb3JtLWNvbnRyb2xcIiB0eXBlPVwidGV4dFwiIHBsYWNlaG9sZGVyPVwiaW5mb1wiIHZhbHVlPVwiPCU9IF8uZXNjYXBlKGl0ZW0uZ2V0KFwibWlzY19pbmZvXCIpKSAlPlwiPjwvdGQ+JyxcbiAgICAgICAgICAgICAgICBcIjwvdHI+XCIsXG4gICAgICAgICAgICAgICAgLy9UT0RPOiBhZGQgZnVuY3Rpb25hbGl0eSB0byBtb2RpZnkgdGFncyBoZXJlXG4gICAgICAgICAgICAgICAgJzwlIGlmIChpdGVtLmdldChcInRhZ3NcIikpIHsgJT4nLFxuICAgICAgICAgICAgICAgIFwiPHRyPlwiLFxuICAgICAgICAgICAgICAgICc8dGggc2NvcGU9XCJyb3dcIj5UYWdzPC90aD4nLFxuICAgICAgICAgICAgICAgICc8dGQgc2NvcGU9XCJyb3dcIj48JT0gXy5lc2NhcGUoaXRlbS5nZXQoXCJ0YWdzXCIpKSAlPjwvdGQ+JyxcbiAgICAgICAgICAgICAgICBcIjwvdHI+XCIsXG4gICAgICAgICAgICAgICAgXCI8JSB9ICU+XCIsXG4gICAgICAgICAgICAgICAgXCI8L3RhYmxlPlwiLFxuICAgICAgICAgICAgICAgIFwiPGRpdj5cIixcbiAgICAgICAgICAgICAgICAnPHByZSBjbGFzcz1cInBlZWtcIj4nLFxuICAgICAgICAgICAgICAgIFwiPC9wcmU+XCIsXG4gICAgICAgICAgICAgICAgXCI8L2Rpdj5cIixcbiAgICAgICAgICAgICAgICBcIjwvZGl2PlwiLFxuICAgICAgICAgICAgICAgIC8vIENPTlRBSU5FUiBFTkRcbiAgICAgICAgICAgICAgICBcIjwvZGl2PlwiXG4gICAgICAgICAgICBdLmpvaW4oXCJcIilcbiAgICAgICAgKTtcbiAgICB9LFxuXG4gICAgdGVtcGxhdGVEYXRhc2V0UGVybWlzc2lvbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gXy50ZW1wbGF0ZShcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAvLyBDT05UQUlORVIgU1RBUlRcbiAgICAgICAgICAgICAgICAnPGRpdiBjbGFzcz1cImxpYnJhcnlfc3R5bGVfY29udGFpbmVyXCI+JyxcbiAgICAgICAgICAgICAgICAnPGRpdiBpZD1cImxpYnJhcnlfdG9vbGJhclwiPicsXG4gICAgICAgICAgICAgICAgJzxhIGhyZWY9XCIjZm9sZGVycy88JS0gaXRlbS5nZXQoXCJmb2xkZXJfaWRcIikgJT4vZGF0YXNldHMvPCUtIGl0ZW0uaWQgJT5cIj4nLFxuICAgICAgICAgICAgICAgICc8YnV0dG9uIGRhdGEtdG9nZ2xlPVwidG9vbHRpcFwiIGRhdGEtcGxhY2VtZW50PVwidG9wXCIgdGl0bGU9XCJHbyBiYWNrIHRvIGRhdGFzZXRcIiBjbGFzcz1cImJ0biBidG4tZGVmYXVsdCBwcmltYXJ5LWJ1dHRvbiB0b29sYmFyLWl0ZW1cIiB0eXBlPVwiYnV0dG9uXCI+JyxcbiAgICAgICAgICAgICAgICAnPHNwYW4gY2xhc3M9XCJmYSBmYS1maWxlLW9cIj48L3NwYW4+JyxcbiAgICAgICAgICAgICAgICBcIiZuYnNwO0RhdGFzZXQgRGV0YWlsc1wiLFxuICAgICAgICAgICAgICAgIFwiPC9idXR0b24+XCIsXG4gICAgICAgICAgICAgICAgXCI8YT5cIixcbiAgICAgICAgICAgICAgICBcIjwvZGl2PlwiLFxuXG4gICAgICAgICAgICAgICAgLy8gQlJFQURDUlVNQlNcbiAgICAgICAgICAgICAgICAnPG9sIGNsYXNzPVwiYnJlYWRjcnVtYlwiPicsXG4gICAgICAgICAgICAgICAgJzxsaT48YSB0aXRsZT1cIlJldHVybiB0byB0aGUgbGlzdCBvZiBsaWJyYXJpZXNcIiBocmVmPVwiI1wiPkxpYnJhcmllczwvYT48L2xpPicsXG4gICAgICAgICAgICAgICAgJzwlIF8uZWFjaChpdGVtLmdldChcImZ1bGxfcGF0aFwiKSwgZnVuY3Rpb24ocGF0aF9pdGVtKSB7ICU+JyxcbiAgICAgICAgICAgICAgICBcIjwlIGlmIChwYXRoX2l0ZW1bMF0gIT0gaXRlbS5pZCkgeyAlPlwiLFxuICAgICAgICAgICAgICAgICc8bGk+PGEgdGl0bGU9XCJSZXR1cm4gdG8gdGhpcyBmb2xkZXJcIiBocmVmPVwiIy9mb2xkZXJzLzwlLSBwYXRoX2l0ZW1bMF0gJT5cIj48JS0gcGF0aF9pdGVtWzFdICU+PC9hPiA8L2xpPiAnLFxuICAgICAgICAgICAgICAgIFwiPCUgfSBlbHNlIHsgJT5cIixcbiAgICAgICAgICAgICAgICAnPGxpIGNsYXNzPVwiYWN0aXZlXCI+PHNwYW4gdGl0bGU9XCJZb3UgYXJlIGhlcmVcIj48JS0gcGF0aF9pdGVtWzFdICU+PC9zcGFuPjwvbGk+JyxcbiAgICAgICAgICAgICAgICBcIjwlIH0gJT5cIixcbiAgICAgICAgICAgICAgICBcIjwlIH0pOyAlPlwiLFxuICAgICAgICAgICAgICAgIFwiPC9vbD5cIixcblxuICAgICAgICAgICAgICAgICc8aDE+RGF0YXNldDogPCU9IF8uZXNjYXBlKGl0ZW0uZ2V0KFwibmFtZVwiKSkgJT48L2gxPicsXG4gICAgICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJhbGVydCBhbGVydC13YXJuaW5nXCI+JyxcbiAgICAgICAgICAgICAgICBcIjwlIGlmIChpc19hZG1pbikgeyAlPlwiLFxuICAgICAgICAgICAgICAgIFwiWW91IGFyZSBsb2dnZWQgaW4gYXMgYW4gPHN0cm9uZz5hZG1pbmlzdHJhdG9yPC9zdHJvbmc+IHRoZXJlZm9yZSB5b3UgY2FuIG1hbmFnZSBhbnkgZGF0YXNldCBvbiB0aGlzIEdhbGF4eSBpbnN0YW5jZS4gUGxlYXNlIG1ha2Ugc3VyZSB5b3UgdW5kZXJzdGFuZCB0aGUgY29uc2VxdWVuY2VzLlwiLFxuICAgICAgICAgICAgICAgIFwiPCUgfSBlbHNlIHsgJT5cIixcbiAgICAgICAgICAgICAgICBcIllvdSBjYW4gYXNzaWduIGFueSBudW1iZXIgb2Ygcm9sZXMgdG8gYW55IG9mIHRoZSBmb2xsb3dpbmcgcGVybWlzc2lvbiB0eXBlcy4gSG93ZXZlciBwbGVhc2UgcmVhZCBjYXJlZnVsbHkgdGhlIGltcGxpY2F0aW9ucyBvZiBzdWNoIGFjdGlvbnMuXCIsXG4gICAgICAgICAgICAgICAgXCI8JSB9ICU+XCIsXG4gICAgICAgICAgICAgICAgXCI8L2Rpdj5cIixcbiAgICAgICAgICAgICAgICAnPGRpdiBjbGFzcz1cImRhdGFzZXRfdGFibGVcIj4nLFxuICAgICAgICAgICAgICAgIFwiPGgyPkxpYnJhcnktcmVsYXRlZCBwZXJtaXNzaW9uczwvaDI+XCIsXG4gICAgICAgICAgICAgICAgXCI8aDQ+Um9sZXMgdGhhdCBjYW4gbW9kaWZ5IHRoZSBsaWJyYXJ5IGl0ZW08L2g0PlwiLFxuICAgICAgICAgICAgICAgICc8ZGl2IGlkPVwibW9kaWZ5X3Blcm1cIiBjbGFzcz1cIm1vZGlmeV9wZXJtIHJvbGVzLXNlbGVjdGlvblwiPjwvZGl2PicsXG4gICAgICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJhbGVydCBhbGVydC1pbmZvIHJvbGVzLXNlbGVjdGlvblwiPlVzZXIgd2l0aCA8c3Ryb25nPmFueTwvc3Ryb25nPiBvZiB0aGVzZSByb2xlcyBjYW4gbW9kaWZ5IG5hbWUsIG1ldGFkYXRhLCBhbmQgb3RoZXIgaW5mb3JtYXRpb24gYWJvdXQgdGhpcyBsaWJyYXJ5IGl0ZW0uPC9kaXY+JyxcbiAgICAgICAgICAgICAgICBcIjxoci8+XCIsXG4gICAgICAgICAgICAgICAgXCI8aDI+RGF0YXNldC1yZWxhdGVkIHBlcm1pc3Npb25zPC9oMj5cIixcbiAgICAgICAgICAgICAgICAnPGRpdiBjbGFzcz1cImFsZXJ0IGFsZXJ0LXdhcm5pbmdcIj5DaGFuZ2VzIG1hZGUgYmVsb3cgd2lsbCBhZmZlY3QgPHN0cm9uZz5ldmVyeTwvc3Ryb25nPiBsaWJyYXJ5IGl0ZW0gdGhhdCB3YXMgY3JlYXRlZCBmcm9tIHRoaXMgZGF0YXNldCBhbmQgYWxzbyBldmVyeSBoaXN0b3J5IHRoaXMgZGF0YXNldCBpcyBwYXJ0IG9mLjwvZGl2PicsXG4gICAgICAgICAgICAgICAgJzwlIGlmICghaXRlbS5nZXQoXCJpc191bnJlc3RyaWN0ZWRcIikpIHsgJT4nLFxuICAgICAgICAgICAgICAgICc8cD5Zb3UgY2FuIDxzcGFuIGNsYXNzPVwicmVtb3ZlLXJlc3RyaWN0aW9uc1wiPjxhIGhyZWY9XCJcIj5yZW1vdmUgYWxsIGFjY2VzcyByZXN0cmljdGlvbnM8L2E+PC9zcGFuPiBvbiB0aGlzIGRhdGFzZXQuPC9wPicsXG4gICAgICAgICAgICAgICAgXCI8JSB9IGVsc2UgeyAlPlwiLFxuICAgICAgICAgICAgICAgICc8cD5Zb3UgY2FuIDxzcGFuIGNsYXNzPVwibWFrZS1wcml2YXRlXCI+PGEgaHJlZj1cIlwiPm1ha2UgdGhpcyBkYXRhc2V0IHByaXZhdGU8L2E+PC9zcGFuPiB0byB5b3UuPC9wPicsXG4gICAgICAgICAgICAgICAgXCI8JSB9ICU+XCIsXG4gICAgICAgICAgICAgICAgXCI8aDQ+Um9sZXMgdGhhdCBjYW4gYWNjZXNzIHRoZSBkYXRhc2V0PC9oND5cIixcbiAgICAgICAgICAgICAgICAnPGRpdiBpZD1cImFjY2Vzc19wZXJtXCIgY2xhc3M9XCJhY2Nlc3NfcGVybSByb2xlcy1zZWxlY3Rpb25cIj48L2Rpdj4nLFxuICAgICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiYWxlcnQgYWxlcnQtaW5mbyByb2xlcy1zZWxlY3Rpb25cIj4nLFxuICAgICAgICAgICAgICAgIFwiVXNlciBoYXMgdG8gaGF2ZSA8c3Ryb25nPmFsbCB0aGVzZSByb2xlczwvc3Ryb25nPiBpbiBvcmRlciB0byBhY2Nlc3MgdGhpcyBkYXRhc2V0LlwiLFxuICAgICAgICAgICAgICAgIFwiIFVzZXJzIHdpdGhvdXQgYWNjZXNzIHBlcm1pc3Npb24gPHN0cm9uZz5jYW5ub3Q8L3N0cm9uZz4gaGF2ZSBvdGhlciBwZXJtaXNzaW9ucyBvbiB0aGlzIGRhdGFzZXQuXCIsXG4gICAgICAgICAgICAgICAgXCIgSWYgdGhlcmUgYXJlIG5vIGFjY2VzcyByb2xlcyBzZXQgb24gdGhlIGRhdGFzZXQgaXQgaXMgY29uc2lkZXJlZCA8c3Ryb25nPnVucmVzdHJpY3RlZDwvc3Ryb25nPi5cIixcbiAgICAgICAgICAgICAgICBcIjwvZGl2PlwiLFxuICAgICAgICAgICAgICAgIFwiPGg0PlJvbGVzIHRoYXQgY2FuIG1hbmFnZSBwZXJtaXNzaW9ucyBvbiB0aGUgZGF0YXNldDwvaDQ+XCIsXG4gICAgICAgICAgICAgICAgJzxkaXYgaWQ9XCJtYW5hZ2VfcGVybVwiIGNsYXNzPVwibWFuYWdlX3Blcm0gcm9sZXMtc2VsZWN0aW9uXCI+PC9kaXY+JyxcbiAgICAgICAgICAgICAgICAnPGRpdiBjbGFzcz1cImFsZXJ0IGFsZXJ0LWluZm8gcm9sZXMtc2VsZWN0aW9uXCI+JyxcbiAgICAgICAgICAgICAgICBcIlVzZXIgd2l0aCA8c3Ryb25nPmFueTwvc3Ryb25nPiBvZiB0aGVzZSByb2xlcyBjYW4gbWFuYWdlIHBlcm1pc3Npb25zIG9mIHRoaXMgZGF0YXNldC4gSWYgeW91IHJlbW92ZSB5b3Vyc2VsZiB5b3Ugd2lsbCBsb3NlIHRoZSBhYmlsaXR5IG1hbmFnZSB0aGlzIGRhdGFzZXQgdW5sZXNzIHlvdSBhcmUgYW4gYWRtaW4uXCIsXG4gICAgICAgICAgICAgICAgXCI8L2Rpdj5cIixcbiAgICAgICAgICAgICAgICAnPGJ1dHRvbiBkYXRhLXRvZ2dsZT1cInRvb2x0aXBcIiBkYXRhLXBsYWNlbWVudD1cInRvcFwiIHRpdGxlPVwiU2F2ZSBtb2RpZmljYXRpb25zIG1hZGUgb24gdGhpcyBwYWdlXCIgY2xhc3M9XCJidG4gYnRuLWRlZmF1bHQgdG9vbGJ0bl9zYXZlX3Blcm1pc3Npb25zIHByaW1hcnktYnV0dG9uXCIgdHlwZT1cImJ1dHRvblwiPicsXG4gICAgICAgICAgICAgICAgJzxzcGFuIGNsYXNzPVwiZmEgZmEtZmxvcHB5LW9cIj48L3NwYW4+JyxcbiAgICAgICAgICAgICAgICBcIiZuYnNwO1NhdmVcIixcbiAgICAgICAgICAgICAgICBcIjwvYnV0dG9uPlwiLFxuICAgICAgICAgICAgICAgIFwiPC9kaXY+XCIsXG4gICAgICAgICAgICAgICAgLy8gQ09OVEFJTkVSIEVORFxuICAgICAgICAgICAgICAgIFwiPC9kaXY+XCJcbiAgICAgICAgICAgIF0uam9pbihcIlwiKVxuICAgICAgICApO1xuICAgIH0sXG5cbiAgICB0ZW1wbGF0ZUJ1bGtJbXBvcnRJbk1vZGFsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF8udGVtcGxhdGUoXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCI8ZGl2PlwiLFxuICAgICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwibGlicmFyeS1tb2RhbC1pdGVtXCI+JyxcbiAgICAgICAgICAgICAgICBcIlNlbGVjdCBoaXN0b3J5OiBcIixcbiAgICAgICAgICAgICAgICAnPHNlbGVjdCBpZD1cImRhdGFzZXRfaW1wb3J0X3NpbmdsZVwiIG5hbWU9XCJkYXRhc2V0X2ltcG9ydF9zaW5nbGVcIiBzdHlsZT1cIndpZHRoOjUwJTsgbWFyZ2luLWJvdHRvbTogMWVtOyBcIiBhdXRvZm9jdXM+JyxcbiAgICAgICAgICAgICAgICBcIjwlIF8uZWFjaChoaXN0b3JpZXMsIGZ1bmN0aW9uKGhpc3RvcnkpIHsgJT5cIixcbiAgICAgICAgICAgICAgICAnPG9wdGlvbiB2YWx1ZT1cIjwlPSBfLmVzY2FwZShoaXN0b3J5LmdldChcImlkXCIpKSAlPlwiPjwlPSBfLmVzY2FwZShoaXN0b3J5LmdldChcIm5hbWVcIikpICU+PC9vcHRpb24+JyxcbiAgICAgICAgICAgICAgICBcIjwlIH0pOyAlPlwiLFxuICAgICAgICAgICAgICAgIFwiPC9zZWxlY3Q+XCIsXG4gICAgICAgICAgICAgICAgXCI8L2Rpdj5cIixcbiAgICAgICAgICAgICAgICAnPGRpdiBjbGFzcz1cImxpYnJhcnktbW9kYWwtaXRlbVwiPicsXG4gICAgICAgICAgICAgICAgXCJvciBjcmVhdGUgbmV3OiBcIixcbiAgICAgICAgICAgICAgICAnPGlucHV0IHR5cGU9XCJ0ZXh0XCIgbmFtZT1cImhpc3RvcnlfbmFtZVwiIHZhbHVlPVwiXCIgcGxhY2Vob2xkZXI9XCJuYW1lIG9mIHRoZSBuZXcgaGlzdG9yeVwiIHN0eWxlPVwid2lkdGg6NTAlO1wiPicsXG4gICAgICAgICAgICAgICAgXCI8L2lucHV0PlwiLFxuICAgICAgICAgICAgICAgIFwiPC9kaXY+XCIsXG4gICAgICAgICAgICAgICAgXCI8L2Rpdj5cIlxuICAgICAgICAgICAgXS5qb2luKFwiXCIpXG4gICAgICAgICk7XG4gICAgfVxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgICBMaWJyYXJ5RGF0YXNldFZpZXc6IExpYnJhcnlEYXRhc2V0Vmlld1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBnYWxheHkvc2NyaXB0cy9tdmMvbGlicmFyeS9saWJyYXJ5LWRhdGFzZXQtdmlldy5qcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTs7O0FBQUE7QUFDQTs7O0FBQUE7QUFDQTs7O0FBQUE7QUFDQTs7O0FBQUE7QUFDQTs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFUQTtBQUNBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQ0E7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUF4QkE7QUEwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVkE7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBSkE7QUFhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWxCQTtBQW9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUlBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWZBO0FBa0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFGQTtBQUtBO0FBRUE7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFGQTtBQUtBO0FBRUE7QUFDQTtBQUZBO0FBS0E7QUFFQTtBQUNBO0FBRkE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQXhCQTtBQTBCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBaEJBO0FBa0JBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVpBO0FBY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBTUE7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQWJBO0FBZUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBVkE7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBeUJBO0FBQ0E7QUFDQTtBQWdCQTtBQUNBO0FBK0hBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFTQTtBQUNBO0FBWUE7QUFDQTtBQXlGQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBV0E7QUFDQTtBQXdFQTtBQUNBO0FBWUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBU0E7QUFDQTtBQWlEQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFtQkE7QUFoa0NBO0FBQ0E7QUFra0NBO0FBQ0E7QUFEQTtBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///127\n");

/***/ }),

/***/ 128:
/*!**********************************************!*\
  !*** ./galaxy/scripts/libs/jquery/jstree.js ***!
  \**********************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*globals jQuery, define, exports, require, window, document */\n(function (factory) {\n\t\"use strict\";\n\tif (true) {\n\t\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ 0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t}\n\telse if(typeof exports === 'object') {\n\t\tfactory(require('jquery'));\n\t}\n\telse {\n\t\tfactory(jQuery);\n\t}\n}(function ($, undefined) {\n\t\"use strict\";\n/*!\n * jsTree 3.0.3\n * http://jstree.com/\n *\n * Copyright (c) 2014 Ivan Bozhanov (http://vakata.com)\n *\n * Licensed same as jquery - under the terms of the MIT License\n *   http://www.opensource.org/licenses/mit-license.php\n */\n/*!\n * if using jslint please allow for the jQuery global and use following options: \n * jslint: browser: true, ass: true, bitwise: true, continue: true, nomen: true, plusplus: true, regexp: true, unparam: true, todo: true, white: true\n */\n\n\t// prevent another load? maybe there is a better way?\n\tif($.jstree) {\n\t\treturn;\n\t}\n\n\t/**\n\t * ### jsTree core functionality\n\t */\n\n\t// internal variables\n\tvar instance_counter = 0,\n\t\tccp_node = false,\n\t\tccp_mode = false,\n\t\tccp_inst = false,\n\t\tthemes_loaded = [],\n\t\tsrc = $('script:last').attr('src'),\n\t\t_d = document, _node = _d.createElement('LI'), _temp1, _temp2;\n\n\t_node.setAttribute('role', 'treeitem');\n\t_temp1 = _d.createElement('I');\n\t_temp1.className = 'jstree-icon jstree-ocl';\n\t_node.appendChild(_temp1);\n\t_temp1 = _d.createElement('A');\n\t_temp1.className = 'jstree-anchor';\n\t_temp1.setAttribute('href','#');\n\t_temp2 = _d.createElement('I');\n\t_temp2.className = 'jstree-icon jstree-themeicon';\n\t_temp1.appendChild(_temp2);\n\t_node.appendChild(_temp1);\n\t_temp1 = _temp2 = null;\n\n\n\t/**\n\t * holds all jstree related functions and variables, including the actual class and methods to create, access and manipulate instances.\n\t * @name $.jstree\n\t */\n\t$.jstree = {\n\t\t/** \n\t\t * specifies the jstree version in use\n\t\t * @name $.jstree.version\n\t\t */\n\t\tversion : '3.0.3',\n\t\t/**\n\t\t * holds all the default options used when creating new instances\n\t\t * @name $.jstree.defaults\n\t\t */\n\t\tdefaults : {\n\t\t\t/**\n\t\t\t * configure which plugins will be active on an instance. Should be an array of strings, where each element is a plugin name. The default is `[]`\n\t\t\t * @name $.jstree.defaults.plugins\n\t\t\t */\n\t\t\tplugins : []\n\t\t},\n\t\t/**\n\t\t * stores all loaded jstree plugins (used internally)\n\t\t * @name $.jstree.plugins\n\t\t */\n\t\tplugins : {},\n\t\tpath : src && src.indexOf('/') !== -1 ? src.replace(/\\/[^\\/]+$/,'') : '',\n\t\tidregex : /[\\\\:&!^|()\\[\\]<>@*'+~#\";.,=\\- \\/${}%]/g\n\t};\n\t/**\n\t * creates a jstree instance\n\t * @name $.jstree.create(el [, options])\n\t * @param {DOMElement|jQuery|String} el the element to create the instance on, can be jQuery extended or a selector\n\t * @param {Object} options options for this instance (extends `$.jstree.defaults`)\n\t * @return {jsTree} the new instance\n\t */\n\t$.jstree.create = function (el, options) {\n\t\tvar tmp = new $.jstree.core(++instance_counter),\n\t\t\topt = options;\n\t\toptions = $.extend(true, {}, $.jstree.defaults, options);\n\t\tif(opt && opt.plugins) {\n\t\t\toptions.plugins = opt.plugins;\n\t\t}\n\t\t$.each(options.plugins, function (i, k) {\n\t\t\tif(i !== 'core') {\n\t\t\t\ttmp = tmp.plugin(k, options[k]);\n\t\t\t}\n\t\t});\n\t\ttmp.init(el, options);\n\t\treturn tmp;\n\t};\n\t/**\n\t * the jstree class constructor, used only internally\n\t * @private\n\t * @name $.jstree.core(id)\n\t * @param {Number} id this instance's index\n\t */\n\t$.jstree.core = function (id) {\n\t\tthis._id = id;\n\t\tthis._cnt = 0;\n\t\tthis._wrk = null;\n\t\tthis._data = {\n\t\t\tcore : {\n\t\t\t\tthemes : {\n\t\t\t\t\tname : false,\n\t\t\t\t\tdots : false,\n\t\t\t\t\ticons : false\n\t\t\t\t},\n\t\t\t\tselected : [],\n\t\t\t\tlast_error : {},\n\t\t\t\tworking : false,\n\t\t\t\tworker_queue : []\n\t\t\t}\n\t\t};\n\t};\n\t/**\n\t * get a reference to an existing instance\n\t *\n\t * __Examples__\n\t *\n\t *\t// provided a container with an ID of \"tree\", and a nested node with an ID of \"branch\"\n\t *\t// all of there will return the same instance\n\t *\t$.jstree.reference('tree');\n\t *\t$.jstree.reference('#tree');\n\t *\t$.jstree.reference($('#tree'));\n\t *\t$.jstree.reference(document.getElementByID('tree'));\n\t *\t$.jstree.reference('branch');\n\t *\t$.jstree.reference('#branch');\n\t *\t$.jstree.reference($('#branch'));\n\t *\t$.jstree.reference(document.getElementByID('branch'));\n\t *\n\t * @name $.jstree.reference(needle)\n\t * @param {DOMElement|jQuery|String} needle\n\t * @return {jsTree|null} the instance or `null` if not found\n\t */\n\t$.jstree.reference = function (needle) {\n\t\tvar tmp = null,\n\t\t\tobj = null;\n\t\tif(needle && needle.id) { needle = needle.id; }\n\n\t\tif(!obj || !obj.length) {\n\t\t\ttry { obj = $(needle); } catch (ignore) { }\n\t\t}\n\t\tif(!obj || !obj.length) {\n\t\t\ttry { obj = $('#' + needle.replace($.jstree.idregex,'\\\\$&')); } catch (ignore) { }\n\t\t}\n\t\tif(obj && obj.length && (obj = obj.closest('.jstree')).length && (obj = obj.data('jstree'))) {\n\t\t\ttmp = obj;\n\t\t}\n\t\telse {\n\t\t\t$('.jstree').each(function () {\n\t\t\t\tvar inst = $(this).data('jstree');\n\t\t\t\tif(inst && inst._model.data[needle]) {\n\t\t\t\t\ttmp = inst;\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn tmp;\n\t};\n\t/**\n\t * Create an instance, get an instance or invoke a command on a instance. \n\t * \n\t * If there is no instance associated with the current node a new one is created and `arg` is used to extend `$.jstree.defaults` for this new instance. There would be no return value (chaining is not broken).\n\t * \n\t * If there is an existing instance and `arg` is a string the command specified by `arg` is executed on the instance, with any additional arguments passed to the function. If the function returns a value it will be returned (chaining could break depending on function).\n\t * \n\t * If there is an existing instance and `arg` is not a string the instance itself is returned (similar to `$.jstree.reference`).\n\t * \n\t * In any other case - nothing is returned and chaining is not broken.\n\t *\n\t * __Examples__\n\t *\n\t *\t$('#tree1').jstree(); // creates an instance\n\t *\t$('#tree2').jstree({ plugins : [] }); // create an instance with some options\n\t *\t$('#tree1').jstree('open_node', '#branch_1'); // call a method on an existing instance, passing additional arguments\n\t *\t$('#tree2').jstree(); // get an existing instance (or create an instance)\n\t *\t$('#tree2').jstree(true); // get an existing instance (will not create new instance)\n\t *\t$('#branch_1').jstree().select_node('#branch_1'); // get an instance (using a nested element and call a method)\n\t *\n\t * @name $().jstree([arg])\n\t * @param {String|Object} arg\n\t * @return {Mixed}\n\t */\n\t$.fn.jstree = function (arg) {\n\t\t// check for string argument\n\t\tvar is_method\t= (typeof arg === 'string'),\n\t\t\targs\t\t= Array.prototype.slice.call(arguments, 1),\n\t\t\tresult\t\t= null;\n\t\tthis.each(function () {\n\t\t\t// get the instance (if there is one) and method (if it exists)\n\t\t\tvar instance = $.jstree.reference(this),\n\t\t\t\tmethod = is_method && instance ? instance[arg] : null;\n\t\t\t// if calling a method, and method is available - execute on the instance\n\t\t\tresult = is_method && method ?\n\t\t\t\tmethod.apply(instance, args) :\n\t\t\t\tnull;\n\t\t\t// if there is no instance and no method is being called - create one\n\t\t\tif(!instance && !is_method && (arg === undefined || $.isPlainObject(arg))) {\n\t\t\t\t$(this).data('jstree', new $.jstree.create(this, arg));\n\t\t\t}\n\t\t\t// if there is an instance and no method is called - return the instance\n\t\t\tif( (instance && !is_method) || arg === true ) {\n\t\t\t\tresult = instance || false;\n\t\t\t}\n\t\t\t// if there was a method call which returned a result - break and return the value\n\t\t\tif(result !== null && result !== undefined) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t});\n\t\t// if there was a method call with a valid return value - return that, otherwise continue the chain\n\t\treturn result !== null && result !== undefined ?\n\t\t\tresult : this;\n\t};\n\t/**\n\t * used to find elements containing an instance\n\t *\n\t * __Examples__\n\t *\n\t *\t$('div:jstree').each(function () {\n\t *\t\t$(this).jstree('destroy');\n\t *\t});\n\t *\n\t * @name $(':jstree')\n\t * @return {jQuery}\n\t */\n\t$.expr[':'].jstree = $.expr.createPseudo(function(search) {\n\t\treturn function(a) {\n\t\t\treturn $(a).hasClass('jstree') &&\n\t\t\t\t$(a).data('jstree') !== undefined;\n\t\t};\n\t});\n\n\t/**\n\t * stores all defaults for the core\n\t * @name $.jstree.defaults.core\n\t */\n\t$.jstree.defaults.core = {\n\t\t/**\n\t\t * data configuration\n\t\t * \n\t\t * If left as `false` the HTML inside the jstree container element is used to populate the tree (that should be an unordered list with list items).\n\t\t *\n\t\t * You can also pass in a HTML string or a JSON array here.\n\t\t * \n\t\t * It is possible to pass in a standard jQuery-like AJAX config and jstree will automatically determine if the response is JSON or HTML and use that to populate the tree. \n\t\t * In addition to the standard jQuery ajax options here you can suppy functions for `data` and `url`, the functions will be run in the current instance's scope and a param will be passed indicating which node is being loaded, the return value of those functions will be used.\n\t\t * \n\t\t * The last option is to specify a function, that function will receive the node being loaded as argument and a second param which is a function which should be called with the result.\n\t\t *\n\t\t * __Examples__\n\t\t *\n\t\t *\t// AJAX\n\t\t *\t$('#tree').jstree({\n\t\t *\t\t'core' : {\n\t\t *\t\t\t'data' : {\n\t\t *\t\t\t\t'url' : '/get/children/',\n\t\t *\t\t\t\t'data' : function (node) {\n\t\t *\t\t\t\t\treturn { 'id' : node.id };\n\t\t *\t\t\t\t}\n\t\t *\t\t\t}\n\t\t *\t\t});\n\t\t *\n\t\t *\t// direct data\n\t\t *\t$('#tree').jstree({\n\t\t *\t\t'core' : {\n\t\t *\t\t\t'data' : [\n\t\t *\t\t\t\t'Simple root node',\n\t\t *\t\t\t\t{\n\t\t *\t\t\t\t\t'id' : 'node_2',\n\t\t *\t\t\t\t\t'text' : 'Root node with options',\n\t\t *\t\t\t\t\t'state' : { 'opened' : true, 'selected' : true },\n\t\t *\t\t\t\t\t'children' : [ { 'text' : 'Child 1' }, 'Child 2']\n\t\t *\t\t\t\t}\n\t\t *\t\t\t]\n\t\t *\t\t});\n\t\t *\t\n\t\t *\t// function\n\t\t *\t$('#tree').jstree({\n\t\t *\t\t'core' : {\n\t\t *\t\t\t'data' : function (obj, callback) {\n\t\t *\t\t\t\tcallback.call(this, ['Root 1', 'Root 2']);\n\t\t *\t\t\t}\n\t\t *\t\t});\n\t\t * \n\t\t * @name $.jstree.defaults.core.data\n\t\t */\n\t\tdata\t\t\t: false,\n\t\t/**\n\t\t * configure the various strings used throughout the tree\n\t\t *\n\t\t * You can use an object where the key is the string you need to replace and the value is your replacement.\n\t\t * Another option is to specify a function which will be called with an argument of the needed string and should return the replacement.\n\t\t * If left as `false` no replacement is made.\n\t\t *\n\t\t * __Examples__\n\t\t *\n\t\t *\t$('#tree').jstree({\n\t\t *\t\t'core' : {\n\t\t *\t\t\t'strings' : {\n\t\t *\t\t\t\t'Loading ...' : 'Please wait ...'\n\t\t *\t\t\t}\n\t\t *\t\t}\n\t\t *\t});\n\t\t *\n\t\t * @name $.jstree.defaults.core.strings\n\t\t */\n\t\tstrings\t\t\t: false,\n\t\t/**\n\t\t * determines what happens when a user tries to modify the structure of the tree\n\t\t * If left as `false` all operations like create, rename, delete, move or copy are prevented.\n\t\t * You can set this to `true` to allow all interactions or use a function to have better control.\n\t\t *\n\t\t * __Examples__\n\t\t *\n\t\t *\t$('#tree').jstree({\n\t\t *\t\t'core' : {\n\t\t *\t\t\t'check_callback' : function (operation, node, node_parent, node_position, more) {\n\t\t *\t\t\t\t// operation can be 'create_node', 'rename_node', 'delete_node', 'move_node' or 'copy_node'\n\t\t *\t\t\t\t// in case of 'rename_node' node_position is filled with the new node name\n\t\t *\t\t\t\treturn operation === 'rename_node' ? true : false;\n\t\t *\t\t\t}\n\t\t *\t\t}\n\t\t *\t});\n\t\t * \n\t\t * @name $.jstree.defaults.core.check_callback\n\t\t */\n\t\tcheck_callback\t: false,\n\t\t/**\n\t\t * a callback called with a single object parameter in the instance's scope when something goes wrong (operation prevented, ajax failed, etc)\n\t\t * @name $.jstree.defaults.core.error\n\t\t */\n\t\terror\t\t\t: $.noop,\n\t\t/**\n\t\t * the open / close animation duration in milliseconds - set this to `false` to disable the animation (default is `200`)\n\t\t * @name $.jstree.defaults.core.animation\n\t\t */\n\t\tanimation\t\t: 200,\n\t\t/**\n\t\t * a boolean indicating if multiple nodes can be selected\n\t\t * @name $.jstree.defaults.core.multiple\n\t\t */\n\t\tmultiple\t\t: true,\n\t\t/**\n\t\t * theme configuration object\n\t\t * @name $.jstree.defaults.core.themes\n\t\t */\n\t\tthemes\t\t\t: {\n\t\t\t/**\n\t\t\t * the name of the theme to use (if left as `false` the default theme is used)\n\t\t\t * @name $.jstree.defaults.core.themes.name\n\t\t\t */\n\t\t\tname\t\t\t: false,\n\t\t\t/**\n\t\t\t * the URL of the theme's CSS file, leave this as `false` if you have manually included the theme CSS (recommended). You can set this to `true` too which will try to autoload the theme.\n\t\t\t * @name $.jstree.defaults.core.themes.url\n\t\t\t */\n\t\t\turl\t\t\t\t: false,\n\t\t\t/**\n\t\t\t * the location of all jstree themes - only used if `url` is set to `true`\n\t\t\t * @name $.jstree.defaults.core.themes.dir\n\t\t\t */\n\t\t\tdir\t\t\t\t: false,\n\t\t\t/**\n\t\t\t * a boolean indicating if connecting dots are shown\n\t\t\t * @name $.jstree.defaults.core.themes.dots\n\t\t\t */\n\t\t\tdots\t\t\t: true,\n\t\t\t/**\n\t\t\t * a boolean indicating if node icons are shown\n\t\t\t * @name $.jstree.defaults.core.themes.icons\n\t\t\t */\n\t\t\ticons\t\t\t: true,\n\t\t\t/**\n\t\t\t * a boolean indicating if the tree background is striped\n\t\t\t * @name $.jstree.defaults.core.themes.stripes\n\t\t\t */\n\t\t\tstripes\t\t\t: false,\n\t\t\t/**\n\t\t\t * a string (or boolean `false`) specifying the theme variant to use (if the theme supports variants)\n\t\t\t * @name $.jstree.defaults.core.themes.variant\n\t\t\t */\n\t\t\tvariant\t\t\t: false,\n\t\t\t/**\n\t\t\t * a boolean specifying if a reponsive version of the theme should kick in on smaller screens (if the theme supports it). Defaults to `false`.\n\t\t\t * @name $.jstree.defaults.core.themes.responsive\n\t\t\t */\n\t\t\tresponsive\t\t: false\n\t\t},\n\t\t/**\n\t\t * if left as `true` all parents of all selected nodes will be opened once the tree loads (so that all selected nodes are visible to the user)\n\t\t * @name $.jstree.defaults.core.expand_selected_onload\n\t\t */\n\t\texpand_selected_onload : true,\n\t\t/**\n\t\t * if left as `true` web workers will be used to parse incoming JSON data where possible, so that the UI will not be blocked by large requests. Workers are however about 30% slower. Defaults to `true`\n\t\t * @name $.jstree.defaults.core.worker\n\t\t */\n\t\tworker : true,\n\t\t/**\n\t\t * Force node text to plain text (and escape HTML). Defaults to `false`\n\t\t * @name $.jstree.defaults.core.force_text\n\t\t */\n\t\tforce_text : false\n\t};\n\t$.jstree.core.prototype = {\n\t\t/**\n\t\t * used to decorate an instance with a plugin. Used internally.\n\t\t * @private\n\t\t * @name plugin(deco [, opts])\n\t\t * @param  {String} deco the plugin to decorate with\n\t\t * @param  {Object} opts options for the plugin\n\t\t * @return {jsTree}\n\t\t */\n\t\tplugin : function (deco, opts) {\n\t\t\tvar Child = $.jstree.plugins[deco];\n\t\t\tif(Child) {\n\t\t\t\tthis._data[deco] = {};\n\t\t\t\tChild.prototype = this;\n\t\t\t\treturn new Child(opts, this);\n\t\t\t}\n\t\t\treturn this;\n\t\t},\n\t\t/**\n\t\t * used to decorate an instance with a plugin. Used internally.\n\t\t * @private\n\t\t * @name init(el, optons)\n\t\t * @param {DOMElement|jQuery|String} el the element we are transforming\n\t\t * @param {Object} options options for this instance\n\t\t * @trigger init.jstree, loading.jstree, loaded.jstree, ready.jstree, changed.jstree\n\t\t */\n\t\tinit : function (el, options) {\n\t\t\tthis._model = {\n\t\t\t\tdata : {\n\t\t\t\t\t'#' : {\n\t\t\t\t\t\tid : '#',\n\t\t\t\t\t\tparent : null,\n\t\t\t\t\t\tparents : [],\n\t\t\t\t\t\tchildren : [],\n\t\t\t\t\t\tchildren_d : [],\n\t\t\t\t\t\tstate : { loaded : false }\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tchanged : [],\n\t\t\t\tforce_full_redraw : false,\n\t\t\t\tredraw_timeout : false,\n\t\t\t\tdefault_state : {\n\t\t\t\t\tloaded : true,\n\t\t\t\t\topened : false,\n\t\t\t\t\tselected : false,\n\t\t\t\t\tdisabled : false\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tthis.element = $(el).addClass('jstree jstree-' + this._id);\n\t\t\tthis.settings = options;\n\t\t\tthis.element.bind(\"destroyed\", $.proxy(this.teardown, this));\n\n\t\t\tthis._data.core.ready = false;\n\t\t\tthis._data.core.loaded = false;\n\t\t\tthis._data.core.rtl = (this.element.css(\"direction\") === \"rtl\");\n\t\t\tthis.element[this._data.core.rtl ? 'addClass' : 'removeClass'](\"jstree-rtl\");\n\t\t\tthis.element.attr('role','tree');\n\n\t\t\tthis.bind();\n\t\t\t/**\n\t\t\t * triggered after all events are bound\n\t\t\t * @event\n\t\t\t * @name init.jstree\n\t\t\t */\n\t\t\tthis.trigger(\"init\");\n\n\t\t\tthis._data.core.original_container_html = this.element.find(\" > ul > li\").clone(true);\n\t\t\tthis._data.core.original_container_html\n\t\t\t\t.find(\"li\").addBack()\n\t\t\t\t.contents().filter(function() {\n\t\t\t\t\treturn this.nodeType === 3 && (!this.nodeValue || /^\\s+$/.test(this.nodeValue));\n\t\t\t\t})\n\t\t\t\t.remove();\n\t\t\tthis.element.html(\"<\"+\"ul class='jstree-container-ul jstree-children'><\"+\"li class='jstree-initial-node jstree-loading jstree-leaf jstree-last'><i class='jstree-icon jstree-ocl'></i><\"+\"a class='jstree-anchor' href='#'><i class='jstree-icon jstree-themeicon-hidden'></i>\" + this.get_string(\"Loading ...\") + \"</a></li></ul>\");\n\t\t\tthis._data.core.li_height = this.get_container_ul().children(\"li:eq(0)\").height() || 24;\n\t\t\t/**\n\t\t\t * triggered after the loading text is shown and before loading starts\n\t\t\t * @event\n\t\t\t * @name loading.jstree\n\t\t\t */\n\t\t\tthis.trigger(\"loading\");\n\t\t\tthis.load_node('#');\n\t\t},\n\t\t/**\n\t\t * destroy an instance\n\t\t * @name destroy()\n\t\t * @param  {Boolean} keep_html if not set to `true` the container will be emptied, otherwise the current DOM elements will be kept intact\n\t\t */\n\t\tdestroy : function (keep_html) {\n\t\t\tif(!keep_html) { this.element.empty(); }\n\t\t\tthis.element.unbind(\"destroyed\", this.teardown);\n\t\t\tthis.teardown();\n\t\t},\n\t\t/**\n\t\t * part of the destroying of an instance. Used internally.\n\t\t * @private\n\t\t * @name teardown()\n\t\t */\n\t\tteardown : function () {\n\t\t\tthis.unbind();\n\t\t\tthis.element\n\t\t\t\t.removeClass('jstree')\n\t\t\t\t.removeData('jstree')\n\t\t\t\t.find(\"[class^='jstree']\")\n\t\t\t\t\t.addBack()\n\t\t\t\t\t.attr(\"class\", function () { return this.className.replace(/jstree[^ ]*|$/ig,''); });\n\t\t\tthis.element = null;\n\t\t},\n\t\t/**\n\t\t * bind all events. Used internally.\n\t\t * @private\n\t\t * @name bind()\n\t\t */\n\t\tbind : function () {\n\t\t\tthis.element\n\t\t\t\t.on(\"dblclick.jstree\", function () {\n\t\t\t\t\t\tif(document.selection && document.selection.empty) {\n\t\t\t\t\t\t\tdocument.selection.empty();\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif(window.getSelection) {\n\t\t\t\t\t\t\t\tvar sel = window.getSelection();\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tsel.removeAllRanges();\n\t\t\t\t\t\t\t\t\tsel.collapse();\n\t\t\t\t\t\t\t\t} catch (ignore) { }\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t.on(\"click.jstree\", \".jstree-ocl\", $.proxy(function (e) {\n\t\t\t\t\t\tthis.toggle_node(e.target);\n\t\t\t\t\t}, this))\n\t\t\t\t.on(\"click.jstree\", \".jstree-anchor\", $.proxy(function (e) {\n\t\t\t\t\t\te.preventDefault();\n\t\t\t\t\t\t$(e.currentTarget).focus();\n\t\t\t\t\t\tthis.activate_node(e.currentTarget, e);\n\t\t\t\t\t}, this))\n\t\t\t\t.on('keydown.jstree', '.jstree-anchor', $.proxy(function (e) {\n\t\t\t\t\t\tif(e.target.tagName === \"INPUT\") { return true; }\n\t\t\t\t\t\tvar o = null;\n\t\t\t\t\t\tswitch(e.which) {\n\t\t\t\t\t\t\tcase 13:\n\t\t\t\t\t\t\tcase 32:\n\t\t\t\t\t\t\t\te.type = \"click\";\n\t\t\t\t\t\t\t\t$(e.currentTarget).trigger(e);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 37:\n\t\t\t\t\t\t\t\te.preventDefault();\n\t\t\t\t\t\t\t\tif(this.is_open(e.currentTarget)) {\n\t\t\t\t\t\t\t\t\tthis.close_node(e.currentTarget);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\to = this.get_prev_dom(e.currentTarget);\n\t\t\t\t\t\t\t\t\tif(o && o.length) { o.children('.jstree-anchor').focus(); }\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 38:\n\t\t\t\t\t\t\t\te.preventDefault();\n\t\t\t\t\t\t\t\to = this.get_prev_dom(e.currentTarget);\n\t\t\t\t\t\t\t\tif(o && o.length) { o.children('.jstree-anchor').focus(); }\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 39:\n\t\t\t\t\t\t\t\te.preventDefault();\n\t\t\t\t\t\t\t\tif(this.is_closed(e.currentTarget)) {\n\t\t\t\t\t\t\t\t\tthis.open_node(e.currentTarget, function (o) { this.get_node(o, true).children('.jstree-anchor').focus(); });\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\to = this.get_next_dom(e.currentTarget);\n\t\t\t\t\t\t\t\t\tif(o && o.length) { o.children('.jstree-anchor').focus(); }\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 40:\n\t\t\t\t\t\t\t\te.preventDefault();\n\t\t\t\t\t\t\t\to = this.get_next_dom(e.currentTarget);\n\t\t\t\t\t\t\t\tif(o && o.length) { o.children('.jstree-anchor').focus(); }\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t// delete\n\t\t\t\t\t\t\tcase 46:\n\t\t\t\t\t\t\t\te.preventDefault();\n\t\t\t\t\t\t\t\to = this.get_node(e.currentTarget);\n\t\t\t\t\t\t\t\tif(o && o.id && o.id !== '#') {\n\t\t\t\t\t\t\t\t\to = this.is_selected(o) ? this.get_selected() : o;\n\t\t\t\t\t\t\t\t\t// this.delete_node(o);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t// f2\n\t\t\t\t\t\t\tcase 113:\n\t\t\t\t\t\t\t\te.preventDefault();\n\t\t\t\t\t\t\t\to = this.get_node(e.currentTarget);\n\t\t\t\t\t\t\t\t/*!\n\t\t\t\t\t\t\t\tif(o && o.id && o.id !== '#') {\n\t\t\t\t\t\t\t\t\t// this.edit(o);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t*/\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t// console.log(e.which);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}, this))\n\t\t\t\t.on(\"load_node.jstree\", $.proxy(function (e, data) {\n\t\t\t\t\t\tif(data.status) {\n\t\t\t\t\t\t\tif(data.node.id === '#' && !this._data.core.loaded) {\n\t\t\t\t\t\t\t\tthis._data.core.loaded = true;\n\t\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t\t * triggered after the root node is loaded for the first time\n\t\t\t\t\t\t\t\t * @event\n\t\t\t\t\t\t\t\t * @name loaded.jstree\n\t\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\t\tthis.trigger(\"loaded\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(!this._data.core.ready && !this.get_container_ul().find('.jstree-loading:eq(0)').length) {\n\t\t\t\t\t\t\t\tthis._data.core.ready = true;\n\t\t\t\t\t\t\t\tif(this._data.core.selected.length) {\n\t\t\t\t\t\t\t\t\tif(this.settings.core.expand_selected_onload) {\n\t\t\t\t\t\t\t\t\t\tvar tmp = [], i, j;\n\t\t\t\t\t\t\t\t\t\tfor(i = 0, j = this._data.core.selected.length; i < j; i++) {\n\t\t\t\t\t\t\t\t\t\t\ttmp = tmp.concat(this._model.data[this._data.core.selected[i]].parents);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\ttmp = $.vakata.array_unique(tmp);\n\t\t\t\t\t\t\t\t\t\tfor(i = 0, j = tmp.length; i < j; i++) {\n\t\t\t\t\t\t\t\t\t\t\tthis.open_node(tmp[i], false, 0);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tthis.trigger('changed', { 'action' : 'ready', 'selected' : this._data.core.selected });\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t\t * triggered after all nodes are finished loading\n\t\t\t\t\t\t\t\t * @event\n\t\t\t\t\t\t\t\t * @name ready.jstree\n\t\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\t\tsetTimeout($.proxy(function () { this.trigger(\"ready\"); }, this), 0);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}, this))\n\t\t\t\t// THEME RELATED\n\t\t\t\t.on(\"init.jstree\", $.proxy(function () {\n\t\t\t\t\t\tvar s = this.settings.core.themes;\n\t\t\t\t\t\tthis._data.core.themes.dots\t\t\t= s.dots;\n\t\t\t\t\t\tthis._data.core.themes.stripes\t\t= s.stripes;\n\t\t\t\t\t\tthis._data.core.themes.icons\t\t= s.icons;\n\t\t\t\t\t\tthis.set_theme(s.name || \"default\", s.url);\n\t\t\t\t\t\tthis.set_theme_variant(s.variant);\n\t\t\t\t\t}, this))\n\t\t\t\t.on(\"loading.jstree\", $.proxy(function () {\n\t\t\t\t\t\tthis[ this._data.core.themes.dots ? \"show_dots\" : \"hide_dots\" ]();\n\t\t\t\t\t\tthis[ this._data.core.themes.icons ? \"show_icons\" : \"hide_icons\" ]();\n\t\t\t\t\t\tthis[ this._data.core.themes.stripes ? \"show_stripes\" : \"hide_stripes\" ]();\n\t\t\t\t\t}, this))\n\t\t\t\t.on('blur.jstree', '.jstree-anchor', $.proxy(function (e) {\n\t\t\t\t\t\t$(e.currentTarget).filter('.jstree-hovered').mouseleave();\n\t\t\t\t\t}, this))\n\t\t\t\t.on('focus.jstree', '.jstree-anchor', $.proxy(function (e) {\n\t\t\t\t\t\tthis.element.find('.jstree-hovered').not(e.currentTarget).mouseleave();\n\t\t\t\t\t\t$(e.currentTarget).mouseenter();\n\t\t\t\t\t}, this))\n\t\t\t\t.on('mouseenter.jstree', '.jstree-anchor', $.proxy(function (e) {\n\t\t\t\t\t\tthis.hover_node(e.currentTarget);\n\t\t\t\t\t}, this))\n\t\t\t\t.on('mouseleave.jstree', '.jstree-anchor', $.proxy(function (e) {\n\t\t\t\t\t\tthis.dehover_node(e.currentTarget);\n\t\t\t\t\t}, this));\n\t\t},\n\t\t/**\n\t\t * part of the destroying of an instance. Used internally.\n\t\t * @private\n\t\t * @name unbind()\n\t\t */\n\t\tunbind : function () {\n\t\t\tthis.element.off('.jstree');\n\t\t\t$(document).off('.jstree-' + this._id);\n\t\t},\n\t\t/**\n\t\t * trigger an event. Used internally.\n\t\t * @private\n\t\t * @name trigger(ev [, data])\n\t\t * @param  {String} ev the name of the event to trigger\n\t\t * @param  {Object} data additional data to pass with the event\n\t\t */\n\t\ttrigger : function (ev, data) {\n\t\t\tif(!data) {\n\t\t\t\tdata = {};\n\t\t\t}\n\t\t\tdata.instance = this;\n\t\t\tthis.element.triggerHandler(ev.replace('.jstree','') + '.jstree', data);\n\t\t},\n\t\t/**\n\t\t * returns the jQuery extended instance container\n\t\t * @name get_container()\n\t\t * @return {jQuery}\n\t\t */\n\t\tget_container : function () {\n\t\t\treturn this.element;\n\t\t},\n\t\t/**\n\t\t * returns the jQuery extended main UL node inside the instance container. Used internally.\n\t\t * @private\n\t\t * @name get_container_ul()\n\t\t * @return {jQuery}\n\t\t */\n\t\tget_container_ul : function () {\n\t\t\treturn this.element.children(\".jstree-children:eq(0)\");\n\t\t},\n\t\t/**\n\t\t * gets string replacements (localization). Used internally.\n\t\t * @private\n\t\t * @name get_string(key)\n\t\t * @param  {String} key\n\t\t * @return {String}\n\t\t */\n\t\tget_string : function (key) {\n\t\t\tvar a = this.settings.core.strings;\n\t\t\tif($.isFunction(a)) { return a.call(this, key); }\n\t\t\tif(a && a[key]) { return a[key]; }\n\t\t\treturn key;\n\t\t},\n\t\t/**\n\t\t * gets the first child of a DOM node. Used internally.\n\t\t * @private\n\t\t * @name _firstChild(dom)\n\t\t * @param  {DOMElement} dom\n\t\t * @return {DOMElement}\n\t\t */\n\t\t_firstChild : function (dom) {\n\t\t\tdom = dom ? dom.firstChild : null;\n\t\t\twhile(dom !== null && dom.nodeType !== 1) {\n\t\t\t\tdom = dom.nextSibling;\n\t\t\t}\n\t\t\treturn dom;\n\t\t},\n\t\t/**\n\t\t * gets the next sibling of a DOM node. Used internally.\n\t\t * @private\n\t\t * @name _nextSibling(dom)\n\t\t * @param  {DOMElement} dom\n\t\t * @return {DOMElement}\n\t\t */\n\t\t_nextSibling : function (dom) {\n\t\t\tdom = dom ? dom.nextSibling : null;\n\t\t\twhile(dom !== null && dom.nodeType !== 1) {\n\t\t\t\tdom = dom.nextSibling;\n\t\t\t}\n\t\t\treturn dom;\n\t\t},\n\t\t/**\n\t\t * gets the previous sibling of a DOM node. Used internally.\n\t\t * @private\n\t\t * @name _previousSibling(dom)\n\t\t * @param  {DOMElement} dom\n\t\t * @return {DOMElement}\n\t\t */\n\t\t_previousSibling : function (dom) {\n\t\t\tdom = dom ? dom.previousSibling : null;\n\t\t\twhile(dom !== null && dom.nodeType !== 1) {\n\t\t\t\tdom = dom.previousSibling;\n\t\t\t}\n\t\t\treturn dom;\n\t\t},\n\t\t/**\n\t\t * get the JSON representation of a node (or the actual jQuery extended DOM node) by using any input (child DOM element, ID string, selector, etc)\n\t\t * @name get_node(obj [, as_dom])\n\t\t * @param  {mixed} obj\n\t\t * @param  {Boolean} as_dom\n\t\t * @return {Object|jQuery}\n\t\t */\n\t\tget_node : function (obj, as_dom) {\n\t\t\tif(obj && obj.id) {\n\t\t\t\tobj = obj.id;\n\t\t\t}\n\t\t\tvar dom;\n\t\t\ttry {\n\t\t\t\tif(this._model.data[obj]) {\n\t\t\t\t\tobj = this._model.data[obj];\n\t\t\t\t}\n\t\t\t\telse if(((dom = $(obj, this.element)).length || (dom = $('#' + obj.replace($.jstree.idregex,'\\\\$&'), this.element)).length) && this._model.data[dom.closest('.jstree-node').attr('id')]) {\n\t\t\t\t\tobj = this._model.data[dom.closest('.jstree-node').attr('id')];\n\t\t\t\t}\n\t\t\t\telse if((dom = $(obj, this.element)).length && dom.hasClass('jstree')) {\n\t\t\t\t\tobj = this._model.data['#'];\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tif(as_dom) {\n\t\t\t\t\tobj = obj.id === '#' ? this.element : $('#' + obj.id.replace($.jstree.idregex,'\\\\$&'), this.element);\n\t\t\t\t}\n\t\t\t\treturn obj;\n\t\t\t} catch (ex) { return false; }\n\t\t},\n\t\t/**\n\t\t * get the path to a node, either consisting of node texts, or of node IDs, optionally glued together (otherwise an array)\n\t\t * @name get_path(obj [, glue, ids])\n\t\t * @param  {mixed} obj the node\n\t\t * @param  {String} glue if you want the path as a string - pass the glue here (for example '/'), if a falsy value is supplied here, an array is returned\n\t\t * @param  {Boolean} ids if set to true build the path using ID, otherwise node text is used\n\t\t * @return {mixed}\n\t\t */\n\t\tget_path : function (obj, glue, ids) {\n\t\t\tobj = obj.parents ? obj : this.get_node(obj);\n\t\t\tif(!obj || obj.id === '#' || !obj.parents) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tvar i, j, p = [];\n\t\t\tp.push(ids ? obj.id : obj.text);\n\t\t\tfor(i = 0, j = obj.parents.length; i < j; i++) {\n\t\t\t\tp.push(ids ? obj.parents[i] : this.get_text(obj.parents[i]));\n\t\t\t}\n\t\t\tp = p.reverse().slice(1);\n\t\t\treturn glue ? p.join(glue) : p;\n\t\t},\n\t\t/**\n\t\t * get the next visible node that is below the `obj` node. If `strict` is set to `true` only sibling nodes are returned.\n\t\t * @name get_next_dom(obj [, strict])\n\t\t * @param  {mixed} obj\n\t\t * @param  {Boolean} strict\n\t\t * @return {jQuery}\n\t\t */\n\t\tget_next_dom : function (obj, strict) {\n\t\t\tvar tmp;\n\t\t\tobj = this.get_node(obj, true);\n\t\t\tif(obj[0] === this.element[0]) {\n\t\t\t\ttmp = this._firstChild(this.get_container_ul()[0]);\n\t\t\t\treturn tmp ? $(tmp) : false;\n\t\t\t}\n\t\t\tif(!obj || !obj.length) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif(strict) {\n\t\t\t\ttmp = this._nextSibling(obj[0]);\n\t\t\t\treturn tmp ? $(tmp) : false;\n\t\t\t}\n\t\t\tif(obj.hasClass(\"jstree-open\")) {\n\t\t\t\ttmp = this._firstChild(obj.children('.jstree-children')[0]);\n\t\t\t\treturn tmp ? $(tmp) : false;\n\t\t\t}\n\t\t\tif((tmp = this._nextSibling(obj[0])) !== null) {\n\t\t\t\treturn $(tmp);\n\t\t\t}\n\t\t\treturn obj.parentsUntil(\".jstree\",\".jstree-node\").next(\".jstree-node\").eq(0);\n\t\t},\n\t\t/**\n\t\t * get the previous visible node that is above the `obj` node. If `strict` is set to `true` only sibling nodes are returned.\n\t\t * @name get_prev_dom(obj [, strict])\n\t\t * @param  {mixed} obj\n\t\t * @param  {Boolean} strict\n\t\t * @return {jQuery}\n\t\t */\n\t\tget_prev_dom : function (obj, strict) {\n\t\t\tvar tmp;\n\t\t\tobj = this.get_node(obj, true);\n\t\t\tif(obj[0] === this.element[0]) {\n\t\t\t\ttmp = this.get_container_ul()[0].lastChild;\n\t\t\t\treturn tmp ? $(tmp) : false;\n\t\t\t}\n\t\t\tif(!obj || !obj.length) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif(strict) {\n\t\t\t\ttmp = this._previousSibling(obj[0]);\n\t\t\t\treturn tmp ? $(tmp) : false;\n\t\t\t}\n\t\t\tif((tmp = this._previousSibling(obj[0])) !== null) {\n\t\t\t\tobj = $(tmp);\n\t\t\t\twhile(obj.hasClass(\"jstree-open\")) {\n\t\t\t\t\tobj = obj.children(\".jstree-children:eq(0)\").children(\".jstree-node:last\");\n\t\t\t\t}\n\t\t\t\treturn obj;\n\t\t\t}\n\t\t\ttmp = obj[0].parentNode.parentNode;\n\t\t\treturn tmp && tmp.className && tmp.className.indexOf('jstree-node') !== -1 ? $(tmp) : false;\n\t\t},\n\t\t/**\n\t\t * get the parent ID of a node\n\t\t * @name get_parent(obj)\n\t\t * @param  {mixed} obj\n\t\t * @return {String}\n\t\t */\n\t\tget_parent : function (obj) {\n\t\t\tobj = this.get_node(obj);\n\t\t\tif(!obj || obj.id === '#') {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn obj.parent;\n\t\t},\n\t\t/**\n\t\t * get a jQuery collection of all the children of a node (node must be rendered)\n\t\t * @name get_children_dom(obj)\n\t\t * @param  {mixed} obj\n\t\t * @return {jQuery}\n\t\t */\n\t\tget_children_dom : function (obj) {\n\t\t\tobj = this.get_node(obj, true);\n\t\t\tif(obj[0] === this.element[0]) {\n\t\t\t\treturn this.get_container_ul().children(\".jstree-node\");\n\t\t\t}\n\t\t\tif(!obj || !obj.length) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn obj.children(\".jstree-children\").children(\".jstree-node\");\n\t\t},\n\t\t/**\n\t\t * checks if a node has children\n\t\t * @name is_parent(obj)\n\t\t * @param  {mixed} obj\n\t\t * @return {Boolean}\n\t\t */\n\t\tis_parent : function (obj) {\n\t\t\tobj = this.get_node(obj);\n\t\t\treturn obj && (obj.state.loaded === false || obj.children.length > 0);\n\t\t},\n\t\t/**\n\t\t * checks if a node is loaded (its children are available)\n\t\t * @name is_loaded(obj)\n\t\t * @param  {mixed} obj\n\t\t * @return {Boolean}\n\t\t */\n\t\tis_loaded : function (obj) {\n\t\t\tobj = this.get_node(obj);\n\t\t\treturn obj && obj.state.loaded;\n\t\t},\n\t\t/**\n\t\t * check if a node is currently loading (fetching children)\n\t\t * @name is_loading(obj)\n\t\t * @param  {mixed} obj\n\t\t * @return {Boolean}\n\t\t */\n\t\tis_loading : function (obj) {\n\t\t\tobj = this.get_node(obj);\n\t\t\treturn obj && obj.state && obj.state.loading;\n\t\t},\n\t\t/**\n\t\t * check if a node is opened\n\t\t * @name is_open(obj)\n\t\t * @param  {mixed} obj\n\t\t * @return {Boolean}\n\t\t */\n\t\tis_open : function (obj) {\n\t\t\tobj = this.get_node(obj);\n\t\t\treturn obj && obj.state.opened;\n\t\t},\n\t\t/**\n\t\t * check if a node is in a closed state\n\t\t * @name is_closed(obj)\n\t\t * @param  {mixed} obj\n\t\t * @return {Boolean}\n\t\t */\n\t\tis_closed : function (obj) {\n\t\t\tobj = this.get_node(obj);\n\t\t\treturn obj && this.is_parent(obj) && !obj.state.opened;\n\t\t},\n\t\t/**\n\t\t * check if a node has no children\n\t\t * @name is_leaf(obj)\n\t\t * @param  {mixed} obj\n\t\t * @return {Boolean}\n\t\t */\n\t\tis_leaf : function (obj) {\n\t\t\treturn !this.is_parent(obj);\n\t\t},\n\t\t/**\n\t\t * loads a node (fetches its children using the `core.data` setting). Multiple nodes can be passed to by using an array.\n\t\t * @name load_node(obj [, callback])\n\t\t * @param  {mixed} obj\n\t\t * @param  {function} callback a function to be executed once loading is complete, the function is executed in the instance's scope and receives two arguments - the node and a boolean status\n\t\t * @return {Boolean}\n\t\t * @trigger load_node.jstree\n\t\t */\n\t\tload_node : function (obj, callback) {\n\t\t\tvar k, l, i, j, c;\n\t\t\tif($.isArray(obj)) {\n\t\t\t\tthis._load_nodes(obj.slice(), callback);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tobj = this.get_node(obj);\n\t\t\tif(!obj) {\n\t\t\t\tif(callback) { callback.call(this, obj, false); }\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t// if(obj.state.loading) { } // the node is already loading - just wait for it to load and invoke callback? but if called implicitly it should be loaded again?\n\t\t\tif(obj.state.loaded) {\n\t\t\t\tobj.state.loaded = false;\n\t\t\t\tfor(k = 0, l = obj.children_d.length; k < l; k++) {\n\t\t\t\t\tfor(i = 0, j = obj.parents.length; i < j; i++) {\n\t\t\t\t\t\tthis._model.data[obj.parents[i]].children_d = $.vakata.array_remove_item(this._model.data[obj.parents[i]].children_d, obj.children_d[k]);\n\t\t\t\t\t}\n\t\t\t\t\tif(this._model.data[obj.children_d[k]].state.selected) {\n\t\t\t\t\t\tc = true;\n\t\t\t\t\t\tthis._data.core.selected = $.vakata.array_remove_item(this._data.core.selected, obj.children_d[k]);\n\t\t\t\t\t}\n\t\t\t\t\tdelete this._model.data[obj.children_d[k]];\n\t\t\t\t}\n\t\t\t\tobj.children = [];\n\t\t\t\tobj.children_d = [];\n\t\t\t\tif(c) {\n\t\t\t\t\tthis.trigger('changed', { 'action' : 'load_node', 'node' : obj, 'selected' : this._data.core.selected });\n\t\t\t\t}\n\t\t\t}\n\t\t\tobj.state.loading = true;\n\t\t\tthis.get_node(obj, true).addClass(\"jstree-loading\");\n\t\t\tthis._load_node(obj, $.proxy(function (status) {\n\t\t\t\tobj = this._model.data[obj.id];\n\t\t\t\tobj.state.loading = false;\n\t\t\t\tobj.state.loaded = status;\n\t\t\t\tvar dom = this.get_node(obj, true);\n\t\t\t\tif(obj.state.loaded && !obj.children.length && dom && dom.length && !dom.hasClass('jstree-leaf')) {\n\t\t\t\t\tdom.removeClass('jstree-closed jstree-open').addClass('jstree-leaf');\n\t\t\t\t}\n\t\t\t\tdom.removeClass(\"jstree-loading\");\n\t\t\t\t/**\n\t\t\t\t * triggered after a node is loaded\n\t\t\t\t * @event\n\t\t\t\t * @name load_node.jstree\n\t\t\t\t * @param {Object} node the node that was loading\n\t\t\t\t * @param {Boolean} status was the node loaded successfully\n\t\t\t\t */\n\t\t\t\tthis.trigger('load_node', { \"node\" : obj, \"status\" : status });\n\t\t\t\tif(callback) {\n\t\t\t\t\tcallback.call(this, obj, status);\n\t\t\t\t}\n\t\t\t}, this));\n\t\t\treturn true;\n\t\t},\n\t\t/**\n\t\t * load an array of nodes (will also load unavailable nodes as soon as the appear in the structure). Used internally.\n\t\t * @private\n\t\t * @name _load_nodes(nodes [, callback])\n\t\t * @param  {array} nodes\n\t\t * @param  {function} callback a function to be executed once loading is complete, the function is executed in the instance's scope and receives one argument - the array passed to _load_nodes\n\t\t */\n\t\t_load_nodes : function (nodes, callback, is_callback) {\n\t\t\tvar r = true,\n\t\t\t\tc = function () { this._load_nodes(nodes, callback, true); },\n\t\t\t\tm = this._model.data, i, j;\n\t\t\tfor(i = 0, j = nodes.length; i < j; i++) {\n\t\t\t\tif(m[nodes[i]] && (!m[nodes[i]].state.loaded || !is_callback)) {\n\t\t\t\t\tif(!this.is_loading(nodes[i])) {\n\t\t\t\t\t\tthis.load_node(nodes[i], c);\n\t\t\t\t\t}\n\t\t\t\t\tr = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(r) {\n\t\t\t\tif(callback && !callback.done) {\n\t\t\t\t\tcallback.call(this, nodes);\n\t\t\t\t\tcallback.done = true;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * handles the actual loading of a node. Used only internally.\n\t\t * @private\n\t\t * @name _load_node(obj [, callback])\n\t\t * @param  {mixed} obj\n\t\t * @param  {function} callback a function to be executed once loading is complete, the function is executed in the instance's scope and receives one argument - a boolean status\n\t\t * @return {Boolean}\n\t\t */\n\t\t_load_node : function (obj, callback) {\n\t\t\tvar s = this.settings.core.data, t;\n\t\t\t// use original HTML\n\t\t\tif(!s) {\n\t\t\t\tif(obj.id === '#') {\n\t\t\t\t\treturn this._append_html_data(obj, this._data.core.original_container_html.clone(true), function (status) {\n\t\t\t\t\t\tcallback.call(this, status);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn callback.call(this, false);\n\t\t\t\t}\n\t\t\t\t// return callback.call(this, obj.id === '#' ? this._append_html_data(obj, this._data.core.original_container_html.clone(true)) : false);\n\t\t\t}\n\t\t\tif($.isFunction(s)) {\n\t\t\t\treturn s.call(this, obj, $.proxy(function (d) {\n\t\t\t\t\tif(d === false) {\n\t\t\t\t\t\tcallback.call(this, false);\n\t\t\t\t\t}\n\t\t\t\t\tthis[typeof d === 'string' ? '_append_html_data' : '_append_json_data'](obj, typeof d === 'string' ? $(d) : d, function (status) {\n\t\t\t\t\t\tcallback.call(this, status);\n\t\t\t\t\t});\n\t\t\t\t\t// return d === false ? callback.call(this, false) : callback.call(this, this[typeof d === 'string' ? '_append_html_data' : '_append_json_data'](obj, typeof d === 'string' ? $(d) : d));\n\t\t\t\t}, this));\n\t\t\t}\n\t\t\tif(typeof s === 'object') {\n\t\t\t\tif(s.url) {\n\t\t\t\t\ts = $.extend(true, {}, s);\n\t\t\t\t\tif($.isFunction(s.url)) {\n\t\t\t\t\t\ts.url = s.url.call(this, obj);\n\t\t\t\t\t}\n\t\t\t\t\tif($.isFunction(s.data)) {\n\t\t\t\t\t\ts.data = s.data.call(this, obj);\n\t\t\t\t\t}\n\t\t\t\t\treturn $.ajax(s)\n\t\t\t\t\t\t.done($.proxy(function (d,t,x) {\n\t\t\t\t\t\t\t\tvar type = x.getResponseHeader('Content-Type');\n\t\t\t\t\t\t\t\tif(type.indexOf('json') !== -1 || typeof d === \"object\") {\n\t\t\t\t\t\t\t\t\treturn this._append_json_data(obj, d, function (status) { callback.call(this, status); });\n\t\t\t\t\t\t\t\t\t//return callback.call(this, this._append_json_data(obj, d));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(type.indexOf('html') !== -1 || typeof d === \"string\") {\n\t\t\t\t\t\t\t\t\treturn this._append_html_data(obj, $(d), function (status) { callback.call(this, status); });\n\t\t\t\t\t\t\t\t\t// return callback.call(this, this._append_html_data(obj, $(d)));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tthis._data.core.last_error = { 'error' : 'ajax', 'plugin' : 'core', 'id' : 'core_04', 'reason' : 'Could not load node', 'data' : JSON.stringify({ 'id' : obj.id, 'xhr' : x }) };\n\t\t\t\t\t\t\t\tthis.settings.core.error.call(this, this._data.core.last_error);\n\t\t\t\t\t\t\t\treturn callback.call(this, false);\n\t\t\t\t\t\t\t}, this))\n\t\t\t\t\t\t.fail($.proxy(function (f) {\n\t\t\t\t\t\t\t\tcallback.call(this, false);\n\t\t\t\t\t\t\t\tthis._data.core.last_error = { 'error' : 'ajax', 'plugin' : 'core', 'id' : 'core_04', 'reason' : 'Could not load node', 'data' : JSON.stringify({ 'id' : obj.id, 'xhr' : f }) };\n\t\t\t\t\t\t\t\tthis.settings.core.error.call(this, this._data.core.last_error);\n\t\t\t\t\t\t\t}, this));\n\t\t\t\t}\n\t\t\t\tt = ($.isArray(s) || $.isPlainObject(s)) ? JSON.parse(JSON.stringify(s)) : s;\n\t\t\t\tif(obj.id === '#') {\n\t\t\t\t\treturn this._append_json_data(obj, t, function (status) {\n\t\t\t\t\t\tcallback.call(this, status);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthis._data.core.last_error = { 'error' : 'nodata', 'plugin' : 'core', 'id' : 'core_05', 'reason' : 'Could not load node', 'data' : JSON.stringify({ 'id' : obj.id }) };\n\t\t\t\t\tthis.settings.core.error.call(this, this._data.core.last_error);\n\t\t\t\t\treturn callback.call(this, false);\n\t\t\t\t}\n\t\t\t\t//return callback.call(this, (obj.id === \"#\" ? this._append_json_data(obj, t) : false) );\n\t\t\t}\n\t\t\tif(typeof s === 'string') {\n\t\t\t\tif(obj.id === '#') {\n\t\t\t\t\treturn this._append_html_data(obj, $(s), function (status) {\n\t\t\t\t\t\tcallback.call(this, status);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthis._data.core.last_error = { 'error' : 'nodata', 'plugin' : 'core', 'id' : 'core_06', 'reason' : 'Could not load node', 'data' : JSON.stringify({ 'id' : obj.id }) };\n\t\t\t\t\tthis.settings.core.error.call(this, this._data.core.last_error);\n\t\t\t\t\treturn callback.call(this, false);\n\t\t\t\t}\n\t\t\t\t//return callback.call(this, (obj.id === \"#\" ? this._append_html_data(obj, $(s)) : false) );\n\t\t\t}\n\t\t\treturn callback.call(this, false);\n\t\t},\n\t\t/**\n\t\t * adds a node to the list of nodes to redraw. Used only internally.\n\t\t * @private\n\t\t * @name _node_changed(obj [, callback])\n\t\t * @param  {mixed} obj\n\t\t */\n\t\t_node_changed : function (obj) {\n\t\t\tobj = this.get_node(obj);\n\t\t\tif(obj) {\n\t\t\t\tthis._model.changed.push(obj.id);\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * appends HTML content to the tree. Used internally.\n\t\t * @private\n\t\t * @name _append_html_data(obj, data)\n\t\t * @param  {mixed} obj the node to append to\n\t\t * @param  {String} data the HTML string to parse and append\n\t\t * @trigger model.jstree, changed.jstree\n\t\t */\n\t\t_append_html_data : function (dom, data, cb) {\n\t\t\tdom = this.get_node(dom);\n\t\t\tdom.children = [];\n\t\t\tdom.children_d = [];\n\t\t\tvar dat = data.is('ul') ? data.children() : data,\n\t\t\t\tpar = dom.id,\n\t\t\t\tchd = [],\n\t\t\t\tdpc = [],\n\t\t\t\tm = this._model.data,\n\t\t\t\tp = m[par],\n\t\t\t\ts = this._data.core.selected.length,\n\t\t\t\ttmp, i, j;\n\t\t\tdat.each($.proxy(function (i, v) {\n\t\t\t\ttmp = this._parse_model_from_html($(v), par, p.parents.concat());\n\t\t\t\tif(tmp) {\n\t\t\t\t\tchd.push(tmp);\n\t\t\t\t\tdpc.push(tmp);\n\t\t\t\t\tif(m[tmp].children_d.length) {\n\t\t\t\t\t\tdpc = dpc.concat(m[tmp].children_d);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}, this));\n\t\t\tp.children = chd;\n\t\t\tp.children_d = dpc;\n\t\t\tfor(i = 0, j = p.parents.length; i < j; i++) {\n\t\t\t\tm[p.parents[i]].children_d = m[p.parents[i]].children_d.concat(dpc);\n\t\t\t}\n\t\t\t/**\n\t\t\t * triggered when new data is inserted to the tree model\n\t\t\t * @event\n\t\t\t * @name model.jstree\n\t\t\t * @param {Array} nodes an array of node IDs\n\t\t\t * @param {String} parent the parent ID of the nodes\n\t\t\t */\n\t\t\tthis.trigger('model', { \"nodes\" : dpc, 'parent' : par });\n\t\t\tif(par !== '#') {\n\t\t\t\tthis._node_changed(par);\n\t\t\t\tthis.redraw();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.get_container_ul().children('.jstree-initial-node').remove();\n\t\t\t\tthis.redraw(true);\n\t\t\t}\n\t\t\tif(this._data.core.selected.length !== s) {\n\t\t\t\tthis.trigger('changed', { 'action' : 'model', 'selected' : this._data.core.selected });\n\t\t\t}\n\t\t\tcb.call(this, true);\n\t\t},\n\t\t/**\n\t\t * appends JSON content to the tree. Used internally.\n\t\t * @private\n\t\t * @name _append_json_data(obj, data)\n\t\t * @param  {mixed} obj the node to append to\n\t\t * @param  {String} data the JSON object to parse and append\n\t\t * @trigger model.jstree, changed.jstree\n\t\t */\n\t\t_append_json_data : function (dom, data, cb) {\n\t\t\tdom = this.get_node(dom);\n\t\t\tdom.children = [];\n\t\t\tdom.children_d = [];\n\t\t\t// *%$@!!!\n\t\t\tif(data.d) {\n\t\t\t\tdata = data.d;\n\t\t\t\tif(typeof data === \"string\") {\n\t\t\t\t\tdata = JSON.parse(data);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!$.isArray(data)) { data = [data]; }\n\t\t\tvar w = null,\n\t\t\t\targs = {\n\t\t\t\t\t'df'\t: this._model.default_state,\n\t\t\t\t\t'dat'\t: data,\n\t\t\t\t\t'par'\t: dom.id,\n\t\t\t\t\t'm'\t\t: this._model.data,\n\t\t\t\t\t't_id'\t: this._id,\n\t\t\t\t\t't_cnt'\t: this._cnt,\n\t\t\t\t\t'sel'\t: this._data.core.selected\n\t\t\t\t},\n\t\t\t\tfunc = function (data, undefined) {\n\t\t\t\t\tif(data.data) { data = data.data; }\n\t\t\t\t\tvar dat = data.dat,\n\t\t\t\t\t\tpar = data.par,\n\t\t\t\t\t\tchd = [],\n\t\t\t\t\t\tdpc = [],\n\t\t\t\t\t\tadd = [],\n\t\t\t\t\t\tdf = data.df,\n\t\t\t\t\t\tt_id = data.t_id,\n\t\t\t\t\t\tt_cnt = data.t_cnt,\n\t\t\t\t\t\tm = data.m,\n\t\t\t\t\t\tp = m[par],\n\t\t\t\t\t\tsel = data.sel,\n\t\t\t\t\t\ttmp, i, j, rslt,\n\t\t\t\t\t\tparse_flat = function (d, p, ps) {\n\t\t\t\t\t\t\tif(!ps) { ps = []; }\n\t\t\t\t\t\t\telse { ps = ps.concat(); }\n\t\t\t\t\t\t\tif(p) { ps.unshift(p); }\n\t\t\t\t\t\t\tvar tid = d.id.toString(),\n\t\t\t\t\t\t\t\ti, j, c, e,\n\t\t\t\t\t\t\t\ttmp = {\n\t\t\t\t\t\t\t\t\tid\t\t\t: tid,\n\t\t\t\t\t\t\t\t\ttext\t\t: d.text || '',\n\t\t\t\t\t\t\t\t\ticon\t\t: d.icon !== undefined ? d.icon : true,\n\t\t\t\t\t\t\t\t\tparent\t\t: p,\n\t\t\t\t\t\t\t\t\tparents\t\t: ps,\n\t\t\t\t\t\t\t\t\tchildren\t: d.children || [],\n\t\t\t\t\t\t\t\t\tchildren_d\t: d.children_d || [],\n\t\t\t\t\t\t\t\t\tdata\t\t: d.data,\n\t\t\t\t\t\t\t\t\tstate\t\t: { },\n\t\t\t\t\t\t\t\t\tli_attr\t\t: { id : false },\n\t\t\t\t\t\t\t\t\ta_attr\t\t: { href : '#' },\n\t\t\t\t\t\t\t\t\toriginal\t: false\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tfor(i in df) {\n\t\t\t\t\t\t\t\tif(df.hasOwnProperty(i)) {\n\t\t\t\t\t\t\t\t\ttmp.state[i] = df[i];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(d && d.data && d.data.jstree && d.data.jstree.icon) {\n\t\t\t\t\t\t\t\ttmp.icon = d.data.jstree.icon;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(d && d.data) {\n\t\t\t\t\t\t\t\ttmp.data = d.data;\n\t\t\t\t\t\t\t\tif(d.data.jstree) {\n\t\t\t\t\t\t\t\t\tfor(i in d.data.jstree) {\n\t\t\t\t\t\t\t\t\t\tif(d.data.jstree.hasOwnProperty(i)) {\n\t\t\t\t\t\t\t\t\t\t\ttmp.state[i] = d.data.jstree[i];\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(d && typeof d.state === 'object') {\n\t\t\t\t\t\t\t\tfor (i in d.state) {\n\t\t\t\t\t\t\t\t\tif(d.state.hasOwnProperty(i)) {\n\t\t\t\t\t\t\t\t\t\ttmp.state[i] = d.state[i];\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(d && typeof d.li_attr === 'object') {\n\t\t\t\t\t\t\t\tfor (i in d.li_attr) {\n\t\t\t\t\t\t\t\t\tif(d.li_attr.hasOwnProperty(i)) {\n\t\t\t\t\t\t\t\t\t\ttmp.li_attr[i] = d.li_attr[i];\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(!tmp.li_attr.id) {\n\t\t\t\t\t\t\t\ttmp.li_attr.id = tid;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(d && typeof d.a_attr === 'object') {\n\t\t\t\t\t\t\t\tfor (i in d.a_attr) {\n\t\t\t\t\t\t\t\t\tif(d.a_attr.hasOwnProperty(i)) {\n\t\t\t\t\t\t\t\t\t\ttmp.a_attr[i] = d.a_attr[i];\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(d && d.children && d.children === true) {\n\t\t\t\t\t\t\t\ttmp.state.loaded = false;\n\t\t\t\t\t\t\t\ttmp.children = [];\n\t\t\t\t\t\t\t\ttmp.children_d = [];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tm[tmp.id] = tmp;\n\t\t\t\t\t\t\tfor(i = 0, j = tmp.children.length; i < j; i++) {\n\t\t\t\t\t\t\t\tc = parse_flat(m[tmp.children[i]], tmp.id, ps);\n\t\t\t\t\t\t\t\te = m[c];\n\t\t\t\t\t\t\t\ttmp.children_d.push(c);\n\t\t\t\t\t\t\t\tif(e.children_d.length) {\n\t\t\t\t\t\t\t\t\ttmp.children_d = tmp.children_d.concat(e.children_d);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdelete d.data;\n\t\t\t\t\t\t\tdelete d.children;\n\t\t\t\t\t\t\tm[tmp.id].original = d;\n\t\t\t\t\t\t\tif(tmp.state.selected) {\n\t\t\t\t\t\t\t\tadd.push(tmp.id);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn tmp.id;\n\t\t\t\t\t\t},\n\t\t\t\t\t\tparse_nest = function (d, p, ps) {\n\t\t\t\t\t\t\tif(!ps) { ps = []; }\n\t\t\t\t\t\t\telse { ps = ps.concat(); }\n\t\t\t\t\t\t\tif(p) { ps.unshift(p); }\n\t\t\t\t\t\t\tvar tid = false, i, j, c, e, tmp;\n\t\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\t\ttid = 'j' + t_id + '_' + (++t_cnt);\n\t\t\t\t\t\t\t} while(m[tid]);\n\n\t\t\t\t\t\t\ttmp = {\n\t\t\t\t\t\t\t\tid\t\t\t: false,\n\t\t\t\t\t\t\t\ttext\t\t: typeof d === 'string' ? d : '',\n\t\t\t\t\t\t\t\ticon\t\t: typeof d === 'object' && d.icon !== undefined ? d.icon : true,\n\t\t\t\t\t\t\t\tparent\t\t: p,\n\t\t\t\t\t\t\t\tparents\t\t: ps,\n\t\t\t\t\t\t\t\tchildren\t: [],\n\t\t\t\t\t\t\t\tchildren_d\t: [],\n\t\t\t\t\t\t\t\tdata\t\t: null,\n\t\t\t\t\t\t\t\tstate\t\t: { },\n\t\t\t\t\t\t\t\tli_attr\t\t: { id : false },\n\t\t\t\t\t\t\t\ta_attr\t\t: { href : '#' },\n\t\t\t\t\t\t\t\toriginal\t: false\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tfor(i in df) {\n\t\t\t\t\t\t\t\tif(df.hasOwnProperty(i)) {\n\t\t\t\t\t\t\t\t\ttmp.state[i] = df[i];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(d && d.id) { tmp.id = d.id.toString(); }\n\t\t\t\t\t\t\tif(d && d.text) { tmp.text = d.text; }\n\t\t\t\t\t\t\tif(d && d.data && d.data.jstree && d.data.jstree.icon) {\n\t\t\t\t\t\t\t\ttmp.icon = d.data.jstree.icon;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(d && d.data) {\n\t\t\t\t\t\t\t\ttmp.data = d.data;\n\t\t\t\t\t\t\t\tif(d.data.jstree) {\n\t\t\t\t\t\t\t\t\tfor(i in d.data.jstree) {\n\t\t\t\t\t\t\t\t\t\tif(d.data.jstree.hasOwnProperty(i)) {\n\t\t\t\t\t\t\t\t\t\t\ttmp.state[i] = d.data.jstree[i];\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(d && typeof d.state === 'object') {\n\t\t\t\t\t\t\t\tfor (i in d.state) {\n\t\t\t\t\t\t\t\t\tif(d.state.hasOwnProperty(i)) {\n\t\t\t\t\t\t\t\t\t\ttmp.state[i] = d.state[i];\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(d && typeof d.li_attr === 'object') {\n\t\t\t\t\t\t\t\tfor (i in d.li_attr) {\n\t\t\t\t\t\t\t\t\tif(d.li_attr.hasOwnProperty(i)) {\n\t\t\t\t\t\t\t\t\t\ttmp.li_attr[i] = d.li_attr[i];\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(tmp.li_attr.id && !tmp.id) {\n\t\t\t\t\t\t\t\ttmp.id = tmp.li_attr.id.toString();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(!tmp.id) {\n\t\t\t\t\t\t\t\ttmp.id = tid;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(!tmp.li_attr.id) {\n\t\t\t\t\t\t\t\ttmp.li_attr.id = tmp.id;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(d && typeof d.a_attr === 'object') {\n\t\t\t\t\t\t\t\tfor (i in d.a_attr) {\n\t\t\t\t\t\t\t\t\tif(d.a_attr.hasOwnProperty(i)) {\n\t\t\t\t\t\t\t\t\t\ttmp.a_attr[i] = d.a_attr[i];\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(d && d.children && d.children.length) {\n\t\t\t\t\t\t\t\tfor(i = 0, j = d.children.length; i < j; i++) {\n\t\t\t\t\t\t\t\t\tc = parse_nest(d.children[i], tmp.id, ps);\n\t\t\t\t\t\t\t\t\te = m[c];\n\t\t\t\t\t\t\t\t\ttmp.children.push(c);\n\t\t\t\t\t\t\t\t\tif(e.children_d.length) {\n\t\t\t\t\t\t\t\t\t\ttmp.children_d = tmp.children_d.concat(e.children_d);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\ttmp.children_d = tmp.children_d.concat(tmp.children);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(d && d.children && d.children === true) {\n\t\t\t\t\t\t\t\ttmp.state.loaded = false;\n\t\t\t\t\t\t\t\ttmp.children = [];\n\t\t\t\t\t\t\t\ttmp.children_d = [];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdelete d.data;\n\t\t\t\t\t\t\tdelete d.children;\n\t\t\t\t\t\t\ttmp.original = d;\n\t\t\t\t\t\t\tm[tmp.id] = tmp;\n\t\t\t\t\t\t\tif(tmp.state.selected) {\n\t\t\t\t\t\t\t\tadd.push(tmp.id);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn tmp.id;\n\t\t\t\t\t\t};\n\n\t\t\t\t\tif(dat.length && dat[0].id !== undefined && dat[0].parent !== undefined) {\n\t\t\t\t\t\t// Flat JSON support (for easy import from DB):\n\t\t\t\t\t\t// 1) convert to object (foreach)\n\t\t\t\t\t\tfor(i = 0, j = dat.length; i < j; i++) {\n\t\t\t\t\t\t\tif(!dat[i].children) {\n\t\t\t\t\t\t\t\tdat[i].children = [];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tm[dat[i].id.toString()] = dat[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// 2) populate children (foreach)\n\t\t\t\t\t\tfor(i = 0, j = dat.length; i < j; i++) {\n\t\t\t\t\t\t\tm[dat[i].parent.toString()].children.push(dat[i].id.toString());\n\t\t\t\t\t\t\t// populate parent.children_d\n\t\t\t\t\t\t\tp.children_d.push(dat[i].id.toString());\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// 3) normalize && populate parents and children_d with recursion\n\t\t\t\t\t\tfor(i = 0, j = p.children.length; i < j; i++) {\n\t\t\t\t\t\t\ttmp = parse_flat(m[p.children[i]], par, p.parents.concat());\n\t\t\t\t\t\t\tdpc.push(tmp);\n\t\t\t\t\t\t\tif(m[tmp].children_d.length) {\n\t\t\t\t\t\t\t\tdpc = dpc.concat(m[tmp].children_d);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor(i = 0, j = p.parents.length; i < j; i++) {\n\t\t\t\t\t\t\tm[p.parents[i]].children_d = m[p.parents[i]].children_d.concat(dpc);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// ?) three_state selection - p.state.selected && t - (if three_state foreach(dat => ch) -> foreach(parents) if(parent.selected) child.selected = true;\n\t\t\t\t\t\trslt = {\n\t\t\t\t\t\t\t'cnt' : t_cnt,\n\t\t\t\t\t\t\t'mod' : m,\n\t\t\t\t\t\t\t'sel' : sel,\n\t\t\t\t\t\t\t'par' : par,\n\t\t\t\t\t\t\t'dpc' : dpc,\n\t\t\t\t\t\t\t'add' : add\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tfor(i = 0, j = dat.length; i < j; i++) {\n\t\t\t\t\t\t\ttmp = parse_nest(dat[i], par, p.parents.concat());\n\t\t\t\t\t\t\tif(tmp) {\n\t\t\t\t\t\t\t\tchd.push(tmp);\n\t\t\t\t\t\t\t\tdpc.push(tmp);\n\t\t\t\t\t\t\t\tif(m[tmp].children_d.length) {\n\t\t\t\t\t\t\t\t\tdpc = dpc.concat(m[tmp].children_d);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tp.children = chd;\n\t\t\t\t\t\tp.children_d = dpc;\n\t\t\t\t\t\tfor(i = 0, j = p.parents.length; i < j; i++) {\n\t\t\t\t\t\t\tm[p.parents[i]].children_d = m[p.parents[i]].children_d.concat(dpc);\n\t\t\t\t\t\t}\n\t\t\t\t\t\trslt = {\n\t\t\t\t\t\t\t'cnt' : t_cnt,\n\t\t\t\t\t\t\t'mod' : m,\n\t\t\t\t\t\t\t'sel' : sel,\n\t\t\t\t\t\t\t'par' : par,\n\t\t\t\t\t\t\t'dpc' : dpc,\n\t\t\t\t\t\t\t'add' : add\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t\treturn rslt;\n\t\t\t\t},\n\t\t\t\trslt = function (rslt, worker) {\n\t\t\t\t\tthis._cnt = rslt.cnt;\n\t\t\t\t\tthis._model.data = rslt.mod; // breaks the reference in load_node - careful\n\n\t\t\t\t\tif(worker) {\n\t\t\t\t\t\tvar i, j, a = rslt.add, r = rslt.sel, s = this._data.core.selected.slice(), m = this._model.data;\n\t\t\t\t\t\t// if selection was changed while calculating in worker\n\t\t\t\t\t\tif(r.length !== s.length || $.vakata.array_unique(r.concat(s)).length !== r.length) {\n\t\t\t\t\t\t\t// deselect nodes that are no longer selected\n\t\t\t\t\t\t\tfor(i = 0, j = r.length; i < j; i++) {\n\t\t\t\t\t\t\t\tif($.inArray(r[i], a) === -1 && $.inArray(r[i], s) === -1) {\n\t\t\t\t\t\t\t\t\tm[r[i]].state.selected = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// select nodes that were selected in the mean time\n\t\t\t\t\t\t\tfor(i = 0, j = s.length; i < j; i++) {\n\t\t\t\t\t\t\t\tif($.inArray(s[i], r) === -1) {\n\t\t\t\t\t\t\t\t\tm[s[i]].state.selected = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(rslt.add.length) {\n\t\t\t\t\t\tthis._data.core.selected = this._data.core.selected.concat(rslt.add);\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.trigger('model', { \"nodes\" : rslt.dpc, 'parent' : rslt.par });\n\n\t\t\t\t\tif(rslt.par !== '#') {\n\t\t\t\t\t\tthis._node_changed(rslt.par);\n\t\t\t\t\t\tthis.redraw();\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// this.get_container_ul().children('.jstree-initial-node').remove();\n\t\t\t\t\t\tthis.redraw(true);\n\t\t\t\t\t}\n\t\t\t\t\tif(rslt.add.length) {\n\t\t\t\t\t\tthis.trigger('changed', { 'action' : 'model', 'selected' : this._data.core.selected });\n\t\t\t\t\t}\n\t\t\t\t\tcb.call(this, true);\n\t\t\t\t};\n\t\t\tif(this.settings.core.worker && window.Blob && window.URL && window.Worker) {\n\t\t\t\ttry {\n\t\t\t\t\tif(this._wrk === null) {\n\t\t\t\t\t\tthis._wrk = window.URL.createObjectURL(\n\t\t\t\t\t\t\tnew window.Blob(\n\t\t\t\t\t\t\t\t['self.onmessage = ' + func.toString().replace(/return ([^;}]+)[\\s;}]+$/, 'postMessage($1);}')],\n\t\t\t\t\t\t\t\t{type:\"text/javascript\"}\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tw = new window.Worker(this._wrk);\n\t\t\t\t\tw.onmessage = $.proxy(function (e) {\n\t\t\t\t\t\trslt.call(this, e.data, true);\n\t\t\t\t\t\tthis._data.core.working = false;\n\t\t\t\t\t\tif(this._data.core.worker_queue.length) {\n\t\t\t\t\t\t\tthis._append_json_data.apply(this, this._data.core.worker_queue.shift());\n\t\t\t\t\t\t}\n\t\t\t\t\t}, this);\n\t\t\t\t\tif(!this._data.core.working) {\n\t\t\t\t\t\tthis._data.core.working = true;\n\t\t\t\t\t\tw.postMessage(args);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tthis._data.core.worker_queue.push([dom, data, cb]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch(e) {\n\t\t\t\t\trslt.call(this, func(args), false);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\trslt.call(this, func(args), false);\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * parses a node from a jQuery object and appends them to the in memory tree model. Used internally.\n\t\t * @private\n\t\t * @name _parse_model_from_html(d [, p, ps])\n\t\t * @param  {jQuery} d the jQuery object to parse\n\t\t * @param  {String} p the parent ID\n\t\t * @param  {Array} ps list of all parents\n\t\t * @return {String} the ID of the object added to the model\n\t\t */\n\t\t_parse_model_from_html : function (d, p, ps) {\n\t\t\tif(!ps) { ps = []; }\n\t\t\telse { ps = [].concat(ps); }\n\t\t\tif(p) { ps.unshift(p); }\n\t\t\tvar c, e, m = this._model.data,\n\t\t\t\tdata = {\n\t\t\t\t\tid\t\t\t: false,\n\t\t\t\t\ttext\t\t: false,\n\t\t\t\t\ticon\t\t: true,\n\t\t\t\t\tparent\t\t: p,\n\t\t\t\t\tparents\t\t: ps,\n\t\t\t\t\tchildren\t: [],\n\t\t\t\t\tchildren_d\t: [],\n\t\t\t\t\tdata\t\t: null,\n\t\t\t\t\tstate\t\t: { },\n\t\t\t\t\tli_attr\t\t: { id : false },\n\t\t\t\t\ta_attr\t\t: { href : '#' },\n\t\t\t\t\toriginal\t: false\n\t\t\t\t}, i, tmp, tid;\n\t\t\tfor(i in this._model.default_state) {\n\t\t\t\tif(this._model.default_state.hasOwnProperty(i)) {\n\t\t\t\t\tdata.state[i] = this._model.default_state[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\ttmp = $.vakata.attributes(d, true);\n\t\t\t$.each(tmp, function (i, v) {\n\t\t\t\tv = $.trim(v);\n\t\t\t\tif(!v.length) { return true; }\n\t\t\t\tdata.li_attr[i] = v;\n\t\t\t\tif(i === 'id') {\n\t\t\t\t\tdata.id = v.toString();\n\t\t\t\t}\n\t\t\t});\n\t\t\ttmp = d.children('a').eq(0);\n\t\t\tif(tmp.length) {\n\t\t\t\ttmp = $.vakata.attributes(tmp, true);\n\t\t\t\t$.each(tmp, function (i, v) {\n\t\t\t\t\tv = $.trim(v);\n\t\t\t\t\tif(v.length) {\n\t\t\t\t\t\tdata.a_attr[i] = v;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\ttmp = d.children(\"a:eq(0)\").length ? d.children(\"a:eq(0)\").clone() : d.clone();\n\t\t\ttmp.children(\"ins, i, ul\").remove();\n\t\t\ttmp = tmp.html();\n\t\t\ttmp = $('<div />').html(tmp);\n\t\t\tdata.text = this.settings.core.force_text ? tmp.text() : tmp.html();\n\t\t\ttmp = d.data();\n\t\t\tdata.data = tmp ? $.extend(true, {}, tmp) : null;\n\t\t\tdata.state.opened = d.hasClass('jstree-open');\n\t\t\tdata.state.selected = d.children('a').hasClass('jstree-clicked');\n\t\t\tdata.state.disabled = d.children('a').hasClass('jstree-disabled');\n\t\t\tif(data.data && data.data.jstree) {\n\t\t\t\tfor(i in data.data.jstree) {\n\t\t\t\t\tif(data.data.jstree.hasOwnProperty(i)) {\n\t\t\t\t\t\tdata.state[i] = data.data.jstree[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\ttmp = d.children(\"a\").children(\".jstree-themeicon\");\n\t\t\tif(tmp.length) {\n\t\t\t\tdata.icon = tmp.hasClass('jstree-themeicon-hidden') ? false : tmp.attr('rel');\n\t\t\t}\n\t\t\tif(data.state.icon) {\n\t\t\t\tdata.icon = data.state.icon;\n\t\t\t}\n\t\t\ttmp = d.children(\"ul\").children(\"li\");\n\t\t\tdo {\n\t\t\t\ttid = 'j' + this._id + '_' + (++this._cnt);\n\t\t\t} while(m[tid]);\n\t\t\tdata.id = data.li_attr.id ? data.li_attr.id.toString() : tid;\n\t\t\tif(tmp.length) {\n\t\t\t\ttmp.each($.proxy(function (i, v) {\n\t\t\t\t\tc = this._parse_model_from_html($(v), data.id, ps);\n\t\t\t\t\te = this._model.data[c];\n\t\t\t\t\tdata.children.push(c);\n\t\t\t\t\tif(e.children_d.length) {\n\t\t\t\t\t\tdata.children_d = data.children_d.concat(e.children_d);\n\t\t\t\t\t}\n\t\t\t\t}, this));\n\t\t\t\tdata.children_d = data.children_d.concat(data.children);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif(d.hasClass('jstree-closed')) {\n\t\t\t\t\tdata.state.loaded = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(data.li_attr['class']) {\n\t\t\t\tdata.li_attr['class'] = data.li_attr['class'].replace('jstree-closed','').replace('jstree-open','');\n\t\t\t}\n\t\t\tif(data.a_attr['class']) {\n\t\t\t\tdata.a_attr['class'] = data.a_attr['class'].replace('jstree-clicked','').replace('jstree-disabled','');\n\t\t\t}\n\t\t\tm[data.id] = data;\n\t\t\tif(data.state.selected) {\n\t\t\t\tthis._data.core.selected.push(data.id);\n\t\t\t}\n\t\t\treturn data.id;\n\t\t},\n\t\t/**\n\t\t * parses a node from a JSON object (used when dealing with flat data, which has no nesting of children, but has id and parent properties) and appends it to the in memory tree model. Used internally.\n\t\t * @private\n\t\t * @name _parse_model_from_flat_json(d [, p, ps])\n\t\t * @param  {Object} d the JSON object to parse\n\t\t * @param  {String} p the parent ID\n\t\t * @param  {Array} ps list of all parents\n\t\t * @return {String} the ID of the object added to the model\n\t\t */\n\t\t_parse_model_from_flat_json : function (d, p, ps) {\n\t\t\tif(!ps) { ps = []; }\n\t\t\telse { ps = ps.concat(); }\n\t\t\tif(p) { ps.unshift(p); }\n\t\t\tvar tid = d.id.toString(),\n\t\t\t\tm = this._model.data,\n\t\t\t\tdf = this._model.default_state,\n\t\t\t\ti, j, c, e,\n\t\t\t\ttmp = {\n\t\t\t\t\tid\t\t\t: tid,\n\t\t\t\t\ttext\t\t: d.text || '',\n\t\t\t\t\ticon\t\t: d.icon !== undefined ? d.icon : true,\n\t\t\t\t\tparent\t\t: p,\n\t\t\t\t\tparents\t\t: ps,\n\t\t\t\t\tchildren\t: d.children || [],\n\t\t\t\t\tchildren_d\t: d.children_d || [],\n\t\t\t\t\tdata\t\t: d.data,\n\t\t\t\t\tstate\t\t: { },\n\t\t\t\t\tli_attr\t\t: { id : false },\n\t\t\t\t\ta_attr\t\t: { href : '#' },\n\t\t\t\t\toriginal\t: false\n\t\t\t\t};\n\t\t\tfor(i in df) {\n\t\t\t\tif(df.hasOwnProperty(i)) {\n\t\t\t\t\ttmp.state[i] = df[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(d && d.data && d.data.jstree && d.data.jstree.icon) {\n\t\t\t\ttmp.icon = d.data.jstree.icon;\n\t\t\t}\n\t\t\tif(d && d.data) {\n\t\t\t\ttmp.data = d.data;\n\t\t\t\tif(d.data.jstree) {\n\t\t\t\t\tfor(i in d.data.jstree) {\n\t\t\t\t\t\tif(d.data.jstree.hasOwnProperty(i)) {\n\t\t\t\t\t\t\ttmp.state[i] = d.data.jstree[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(d && typeof d.state === 'object') {\n\t\t\t\tfor (i in d.state) {\n\t\t\t\t\tif(d.state.hasOwnProperty(i)) {\n\t\t\t\t\t\ttmp.state[i] = d.state[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(d && typeof d.li_attr === 'object') {\n\t\t\t\tfor (i in d.li_attr) {\n\t\t\t\t\tif(d.li_attr.hasOwnProperty(i)) {\n\t\t\t\t\t\ttmp.li_attr[i] = d.li_attr[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!tmp.li_attr.id) {\n\t\t\t\ttmp.li_attr.id = tid;\n\t\t\t}\n\t\t\tif(d && typeof d.a_attr === 'object') {\n\t\t\t\tfor (i in d.a_attr) {\n\t\t\t\t\tif(d.a_attr.hasOwnProperty(i)) {\n\t\t\t\t\t\ttmp.a_attr[i] = d.a_attr[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(d && d.children && d.children === true) {\n\t\t\t\ttmp.state.loaded = false;\n\t\t\t\ttmp.children = [];\n\t\t\t\ttmp.children_d = [];\n\t\t\t}\n\t\t\tm[tmp.id] = tmp;\n\t\t\tfor(i = 0, j = tmp.children.length; i < j; i++) {\n\t\t\t\tc = this._parse_model_from_flat_json(m[tmp.children[i]], tmp.id, ps);\n\t\t\t\te = m[c];\n\t\t\t\ttmp.children_d.push(c);\n\t\t\t\tif(e.children_d.length) {\n\t\t\t\t\ttmp.children_d = tmp.children_d.concat(e.children_d);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdelete d.data;\n\t\t\tdelete d.children;\n\t\t\tm[tmp.id].original = d;\n\t\t\tif(tmp.state.selected) {\n\t\t\t\tthis._data.core.selected.push(tmp.id);\n\t\t\t}\n\t\t\treturn tmp.id;\n\t\t},\n\t\t/**\n\t\t * parses a node from a JSON object and appends it to the in memory tree model. Used internally.\n\t\t * @private\n\t\t * @name _parse_model_from_json(d [, p, ps])\n\t\t * @param  {Object} d the JSON object to parse\n\t\t * @param  {String} p the parent ID\n\t\t * @param  {Array} ps list of all parents\n\t\t * @return {String} the ID of the object added to the model\n\t\t */\n\t\t_parse_model_from_json : function (d, p, ps) {\n\t\t\tif(!ps) { ps = []; }\n\t\t\telse { ps = ps.concat(); }\n\t\t\tif(p) { ps.unshift(p); }\n\t\t\tvar tid = false, i, j, c, e, m = this._model.data, df = this._model.default_state, tmp;\n\t\t\tdo {\n\t\t\t\ttid = 'j' + this._id + '_' + (++this._cnt);\n\t\t\t} while(m[tid]);\n\n\t\t\ttmp = {\n\t\t\t\tid\t\t\t: false,\n\t\t\t\ttext\t\t: typeof d === 'string' ? d : '',\n\t\t\t\ticon\t\t: typeof d === 'object' && d.icon !== undefined ? d.icon : true,\n\t\t\t\tparent\t\t: p,\n\t\t\t\tparents\t\t: ps,\n\t\t\t\tchildren\t: [],\n\t\t\t\tchildren_d\t: [],\n\t\t\t\tdata\t\t: null,\n\t\t\t\tstate\t\t: { },\n\t\t\t\tli_attr\t\t: { id : false },\n\t\t\t\ta_attr\t\t: { href : '#' },\n\t\t\t\toriginal\t: false\n\t\t\t};\n\t\t\tfor(i in df) {\n\t\t\t\tif(df.hasOwnProperty(i)) {\n\t\t\t\t\ttmp.state[i] = df[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(d && d.id) { tmp.id = d.id.toString(); }\n\t\t\tif(d && d.text) { tmp.text = d.text; }\n\t\t\tif(d && d.data && d.data.jstree && d.data.jstree.icon) {\n\t\t\t\ttmp.icon = d.data.jstree.icon;\n\t\t\t}\n\t\t\tif(d && d.data) {\n\t\t\t\ttmp.data = d.data;\n\t\t\t\tif(d.data.jstree) {\n\t\t\t\t\tfor(i in d.data.jstree) {\n\t\t\t\t\t\tif(d.data.jstree.hasOwnProperty(i)) {\n\t\t\t\t\t\t\ttmp.state[i] = d.data.jstree[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(d && typeof d.state === 'object') {\n\t\t\t\tfor (i in d.state) {\n\t\t\t\t\tif(d.state.hasOwnProperty(i)) {\n\t\t\t\t\t\ttmp.state[i] = d.state[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(d && typeof d.li_attr === 'object') {\n\t\t\t\tfor (i in d.li_attr) {\n\t\t\t\t\tif(d.li_attr.hasOwnProperty(i)) {\n\t\t\t\t\t\ttmp.li_attr[i] = d.li_attr[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(tmp.li_attr.id && !tmp.id) {\n\t\t\t\ttmp.id = tmp.li_attr.id.toString();\n\t\t\t}\n\t\t\tif(!tmp.id) {\n\t\t\t\ttmp.id = tid;\n\t\t\t}\n\t\t\tif(!tmp.li_attr.id) {\n\t\t\t\ttmp.li_attr.id = tmp.id;\n\t\t\t}\n\t\t\tif(d && typeof d.a_attr === 'object') {\n\t\t\t\tfor (i in d.a_attr) {\n\t\t\t\t\tif(d.a_attr.hasOwnProperty(i)) {\n\t\t\t\t\t\ttmp.a_attr[i] = d.a_attr[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(d && d.children && d.children.length) {\n\t\t\t\tfor(i = 0, j = d.children.length; i < j; i++) {\n\t\t\t\t\tc = this._parse_model_from_json(d.children[i], tmp.id, ps);\n\t\t\t\t\te = m[c];\n\t\t\t\t\ttmp.children.push(c);\n\t\t\t\t\tif(e.children_d.length) {\n\t\t\t\t\t\ttmp.children_d = tmp.children_d.concat(e.children_d);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttmp.children_d = tmp.children_d.concat(tmp.children);\n\t\t\t}\n\t\t\tif(d && d.children && d.children === true) {\n\t\t\t\ttmp.state.loaded = false;\n\t\t\t\ttmp.children = [];\n\t\t\t\ttmp.children_d = [];\n\t\t\t}\n\t\t\tdelete d.data;\n\t\t\tdelete d.children;\n\t\t\ttmp.original = d;\n\t\t\tm[tmp.id] = tmp;\n\t\t\tif(tmp.state.selected) {\n\t\t\t\tthis._data.core.selected.push(tmp.id);\n\t\t\t}\n\t\t\treturn tmp.id;\n\t\t},\n\t\t/**\n\t\t * redraws all nodes that need to be redrawn. Used internally.\n\t\t * @private\n\t\t * @name _redraw()\n\t\t * @trigger redraw.jstree\n\t\t */\n\t\t_redraw : function () {\n\t\t\tvar nodes = this._model.force_full_redraw ? this._model.data['#'].children.concat([]) : this._model.changed.concat([]),\n\t\t\t\tf = document.createElement('UL'), tmp, i, j;\n\t\t\tfor(i = 0, j = nodes.length; i < j; i++) {\n\t\t\t\ttmp = this.redraw_node(nodes[i], true, this._model.force_full_redraw);\n\t\t\t\tif(tmp && this._model.force_full_redraw) {\n\t\t\t\t\tf.appendChild(tmp);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(this._model.force_full_redraw) {\n\t\t\t\tf.className = this.get_container_ul()[0].className;\n\t\t\t\tthis.element.empty().append(f);\n\t\t\t\t//this.get_container_ul()[0].appendChild(f);\n\t\t\t}\n\t\t\tthis._model.force_full_redraw = false;\n\t\t\tthis._model.changed = [];\n\t\t\t/**\n\t\t\t * triggered after nodes are redrawn\n\t\t\t * @event\n\t\t\t * @name redraw.jstree\n\t\t\t * @param {array} nodes the redrawn nodes\n\t\t\t */\n\t\t\tthis.trigger('redraw', { \"nodes\" : nodes });\n\t\t},\n\t\t/**\n\t\t * redraws all nodes that need to be redrawn or optionally - the whole tree\n\t\t * @name redraw([full])\n\t\t * @param {Boolean} full if set to `true` all nodes are redrawn.\n\t\t */\n\t\tredraw : function (full) {\n\t\t\tif(full) {\n\t\t\t\tthis._model.force_full_redraw = true;\n\t\t\t}\n\t\t\t//if(this._model.redraw_timeout) {\n\t\t\t//\tclearTimeout(this._model.redraw_timeout);\n\t\t\t//}\n\t\t\t//this._model.redraw_timeout = setTimeout($.proxy(this._redraw, this),0);\n\t\t\tthis._redraw();\n\t\t},\n\t\t/**\n\t\t * redraws a single node. Used internally.\n\t\t * @private\n\t\t * @name redraw_node(node, deep, is_callback)\n\t\t * @param {mixed} node the node to redraw\n\t\t * @param {Boolean} deep should child nodes be redrawn too\n\t\t * @param {Boolean} is_callback is this a recursion call\n\t\t */\n\t\tredraw_node : function (node, deep, is_callback) {\n\t\t\tvar obj = this.get_node(node),\n\t\t\t\tpar = false,\n\t\t\t\tind = false,\n\t\t\t\told = false,\n\t\t\t\ti = false,\n\t\t\t\tj = false,\n\t\t\t\tk = false,\n\t\t\t\tc = '',\n\t\t\t\td = document,\n\t\t\t\tm = this._model.data,\n\t\t\t\tf = false,\n\t\t\t\ts = false,\n\t\t\t\ttmp = null;\n\t\t\tif(!obj) { return false; }\n\t\t\tif(obj.id === '#') {  return this.redraw(true); }\n\t\t\tdeep = deep || obj.children.length === 0;\n\t\t\tnode = !document.querySelector ? document.getElementById(obj.id) : this.element[0].querySelector('#' + (\"0123456789\".indexOf(obj.id[0]) !== -1 ? '\\\\3' + obj.id[0] + ' ' + obj.id.substr(1).replace($.jstree.idregex,'\\\\$&') : obj.id.replace($.jstree.idregex,'\\\\$&')) ); //, this.element);\n\t\t\tif(!node) {\n\t\t\t\tdeep = true;\n\t\t\t\t//node = d.createElement('LI');\n\t\t\t\tif(!is_callback) {\n\t\t\t\t\tpar = obj.parent !== '#' ? $('#' + obj.parent.replace($.jstree.idregex,'\\\\$&'), this.element)[0] : null;\n\t\t\t\t\tif(par !== null && (!par || !m[obj.parent].state.opened)) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tind = $.inArray(obj.id, par === null ? m['#'].children : m[obj.parent].children);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnode = $(node);\n\t\t\t\tif(!is_callback) {\n\t\t\t\t\tpar = node.parent().parent()[0];\n\t\t\t\t\tif(par === this.element[0]) {\n\t\t\t\t\t\tpar = null;\n\t\t\t\t\t}\n\t\t\t\t\tind = node.index();\n\t\t\t\t}\n\t\t\t\t// m[obj.id].data = node.data(); // use only node's data, no need to touch jquery storage\n\t\t\t\tif(!deep && obj.children.length && !node.children('.jstree-children').length) {\n\t\t\t\t\tdeep = true;\n\t\t\t\t}\n\t\t\t\tif(!deep) {\n\t\t\t\t\told = node.children('.jstree-children')[0];\n\t\t\t\t}\n\t\t\t\ts = node.attr('aria-selected');\n\t\t\t\tf = node.children('.jstree-anchor')[0] === document.activeElement;\n\t\t\t\tnode.remove();\n\t\t\t\t//node = d.createElement('LI');\n\t\t\t\t//node = node[0];\n\t\t\t}\n\t\t\tnode = _node.cloneNode(true);\n\t\t\t// node is DOM, deep is boolean\n\n\t\t\tc = 'jstree-node ';\n\t\t\tfor(i in obj.li_attr) {\n\t\t\t\tif(obj.li_attr.hasOwnProperty(i)) {\n\t\t\t\t\tif(i === 'id') { continue; }\n\t\t\t\t\tif(i !== 'class') {\n\t\t\t\t\t\tnode.setAttribute(i, obj.li_attr[i]);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tc += obj.li_attr[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(s && s !== \"false\") {\n\t\t\t\tnode.setAttribute('aria-selected', true);\n\t\t\t}\n\t\t\tif(obj.state.loaded && !obj.children.length) {\n\t\t\t\tc += ' jstree-leaf';\n\t\t\t}\n\t\t\telse {\n\t\t\t\tc += obj.state.opened && obj.state.loaded ? ' jstree-open' : ' jstree-closed';\n\t\t\t\tnode.setAttribute('aria-expanded', (obj.state.opened && obj.state.loaded) );\n\t\t\t}\n\t\t\tif(obj.parent !== null && m[obj.parent].children[m[obj.parent].children.length - 1] === obj.id) {\n\t\t\t\tc += ' jstree-last';\n\t\t\t}\n\t\t\tnode.id = obj.id;\n\t\t\tnode.className = c;\n\t\t\tc = ( obj.state.selected ? ' jstree-clicked' : '') + ( obj.state.disabled ? ' jstree-disabled' : '');\n\t\t\tfor(j in obj.a_attr) {\n\t\t\t\tif(obj.a_attr.hasOwnProperty(j)) {\n\t\t\t\t\tif(j === 'href' && obj.a_attr[j] === '#') { continue; }\n\t\t\t\t\tif(j !== 'class') {\n\t\t\t\t\t\tnode.childNodes[1].setAttribute(j, obj.a_attr[j]);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tc += ' ' + obj.a_attr[j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(c.length) {\n\t\t\t\tnode.childNodes[1].className = 'jstree-anchor ' + c;\n\t\t\t}\n\t\t\tif((obj.icon && obj.icon !== true) || obj.icon === false) {\n\t\t\t\tif(obj.icon === false) {\n\t\t\t\t\tnode.childNodes[1].childNodes[0].className += ' jstree-themeicon-hidden';\n\t\t\t\t}\n\t\t\t\telse if(obj.icon.indexOf('/') === -1 && obj.icon.indexOf('.') === -1) {\n\t\t\t\t\tnode.childNodes[1].childNodes[0].className += ' ' + obj.icon + ' jstree-themeicon-custom';\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tnode.childNodes[1].childNodes[0].style.backgroundImage = 'url('+obj.icon+')';\n\t\t\t\t\tnode.childNodes[1].childNodes[0].style.backgroundPosition = 'center center';\n\t\t\t\t\tnode.childNodes[1].childNodes[0].style.backgroundSize = 'auto';\n\t\t\t\t\tnode.childNodes[1].childNodes[0].className += ' jstree-themeicon-custom';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(this.settings.core.force_text) {\n\t\t\t\tnode.childNodes[1].appendChild(d.createTextNode(obj.text));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnode.childNodes[1].innerHTML += obj.text;\n\t\t\t}\n\n\t\t\tif(deep && obj.children.length && obj.state.opened && obj.state.loaded) {\n\t\t\t\tk = d.createElement('UL');\n\t\t\t\tk.setAttribute('role', 'group');\n\t\t\t\tk.className = 'jstree-children';\n\t\t\t\tfor(i = 0, j = obj.children.length; i < j; i++) {\n\t\t\t\t\tk.appendChild(this.redraw_node(obj.children[i], deep, true));\n\t\t\t\t}\n\t\t\t\tnode.appendChild(k);\n\t\t\t}\n\t\t\tif(old) {\n\t\t\t\tnode.appendChild(old);\n\t\t\t}\n\t\t\tif(!is_callback) {\n\t\t\t\t// append back using par / ind\n\t\t\t\tif(!par) {\n\t\t\t\t\tpar = this.element[0];\n\t\t\t\t}\n\t\t\t\tfor(i = 0, j = par.childNodes.length; i < j; i++) {\n\t\t\t\t\tif(par.childNodes[i] && par.childNodes[i].className && par.childNodes[i].className.indexOf('jstree-children') !== -1) {\n\t\t\t\t\t\ttmp = par.childNodes[i];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!tmp) {\n\t\t\t\t\ttmp = d.createElement('UL');\n\t\t\t\t\ttmp.setAttribute('role', 'group');\n\t\t\t\t\ttmp.className = 'jstree-children';\n\t\t\t\t\tpar.appendChild(tmp);\n\t\t\t\t}\n\t\t\t\tpar = tmp;\n\n\t\t\t\tif(ind < par.childNodes.length) {\n\t\t\t\t\tpar.insertBefore(node, par.childNodes[ind]);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tpar.appendChild(node);\n\t\t\t\t}\n\t\t\t\tif(f) {\n\t\t\t\t\tnode.childNodes[1].focus();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(obj.state.opened && !obj.state.loaded) {\n\t\t\t\tobj.state.opened = false;\n\t\t\t\tsetTimeout($.proxy(function () {\n\t\t\t\t\tthis.open_node(obj.id, false, 0);\n\t\t\t\t}, this), 0);\n\t\t\t}\n\t\t\treturn node;\n\t\t},\n\t\t/**\n\t\t * opens a node, revaling its children. If the node is not loaded it will be loaded and opened once ready.\n\t\t * @name open_node(obj [, callback, animation])\n\t\t * @param {mixed} obj the node to open\n\t\t * @param {Function} callback a function to execute once the node is opened\n\t\t * @param {Number} animation the animation duration in milliseconds when opening the node (overrides the `core.animation` setting). Use `false` for no animation.\n\t\t * @trigger open_node.jstree, after_open.jstree, before_open.jstree\n\t\t */\n\t\topen_node : function (obj, callback, animation) {\n\t\t\tvar t1, t2, d, t;\n\t\t\tif($.isArray(obj)) {\n\t\t\t\tobj = obj.slice();\n\t\t\t\tfor(t1 = 0, t2 = obj.length; t1 < t2; t1++) {\n\t\t\t\t\tthis.open_node(obj[t1], callback, animation);\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tobj = this.get_node(obj);\n\t\t\tif(!obj || obj.id === '#') {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tanimation = animation === undefined ? this.settings.core.animation : animation;\n\t\t\tif(!this.is_closed(obj)) {\n\t\t\t\tif(callback) {\n\t\t\t\t\tcallback.call(this, obj, false);\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif(!this.is_loaded(obj)) {\n\t\t\t\tif(this.is_loading(obj)) {\n\t\t\t\t\treturn setTimeout($.proxy(function () {\n\t\t\t\t\t\tthis.open_node(obj, callback, animation);\n\t\t\t\t\t}, this), 500);\n\t\t\t\t}\n\t\t\t\tthis.load_node(obj, function (o, ok) {\n\t\t\t\t\treturn ok ? this.open_node(o, callback, animation) : (callback ? callback.call(this, o, false) : false);\n\t\t\t\t});\n\t\t\t}\n\t\t\telse {\n\t\t\t\td = this.get_node(obj, true);\n\t\t\t\tt = this;\n\t\t\t\tif(d.length) {\n\t\t\t\t\tif(obj.children.length && !this._firstChild(d.children('.jstree-children')[0])) {\n\t\t\t\t\t\tobj.state.opened = true;\n\t\t\t\t\t\tthis.redraw_node(obj, true);\n\t\t\t\t\t\td = this.get_node(obj, true);\n\t\t\t\t\t}\n\t\t\t\t\tif(!animation) {\n\t\t\t\t\t\tthis.trigger('before_open', { \"node\" : obj });\n\t\t\t\t\t\td[0].className = d[0].className.replace('jstree-closed', 'jstree-open');\n\t\t\t\t\t\td[0].setAttribute(\"aria-expanded\", true);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tthis.trigger('before_open', { \"node\" : obj });\n\t\t\t\t\t\td\n\t\t\t\t\t\t\t.children(\".jstree-children\").css(\"display\",\"none\").end()\n\t\t\t\t\t\t\t.removeClass(\"jstree-closed\").addClass(\"jstree-open\").attr(\"aria-expanded\", true)\n\t\t\t\t\t\t\t.children(\".jstree-children\").stop(true, true)\n\t\t\t\t\t\t\t\t.slideDown(animation, function () {\n\t\t\t\t\t\t\t\t\tthis.style.display = \"\";\n\t\t\t\t\t\t\t\t\tt.trigger(\"after_open\", { \"node\" : obj });\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tobj.state.opened = true;\n\t\t\t\tif(callback) {\n\t\t\t\t\tcallback.call(this, obj, true);\n\t\t\t\t}\n\t\t\t\tif(!d.length) {\n\t\t\t\t\t/**\n\t\t\t\t\t * triggered when a node is about to be opened (if the node is supposed to be in the DOM, it will be, but it won't be visible yet)\n\t\t\t\t\t * @event\n\t\t\t\t\t * @name before_open.jstree\n\t\t\t\t\t * @param {Object} node the opened node\n\t\t\t\t\t */\n\t\t\t\t\tthis.trigger('before_open', { \"node\" : obj });\n\t\t\t\t}\n\t\t\t\t/**\n\t\t\t\t * triggered when a node is opened (if there is an animation it will not be completed yet)\n\t\t\t\t * @event\n\t\t\t\t * @name open_node.jstree\n\t\t\t\t * @param {Object} node the opened node\n\t\t\t\t */\n\t\t\t\tthis.trigger('open_node', { \"node\" : obj });\n\t\t\t\tif(!animation || !d.length) {\n\t\t\t\t\t/**\n\t\t\t\t\t * triggered when a node is opened and the animation is complete\n\t\t\t\t\t * @event\n\t\t\t\t\t * @name after_open.jstree\n\t\t\t\t\t * @param {Object} node the opened node\n\t\t\t\t\t */\n\t\t\t\t\tthis.trigger(\"after_open\", { \"node\" : obj });\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * opens every parent of a node (node should be loaded)\n\t\t * @name _open_to(obj)\n\t\t * @param {mixed} obj the node to reveal\n\t\t * @private\n\t\t */\n\t\t_open_to : function (obj) {\n\t\t\tobj = this.get_node(obj);\n\t\t\tif(!obj || obj.id === '#') {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tvar i, j, p = obj.parents;\n\t\t\tfor(i = 0, j = p.length; i < j; i+=1) {\n\t\t\t\tif(i !== '#') {\n\t\t\t\t\tthis.open_node(p[i], false, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn $('#' + obj.id.replace($.jstree.idregex,'\\\\$&'), this.element);\n\t\t},\n\t\t/**\n\t\t * closes a node, hiding its children\n\t\t * @name close_node(obj [, animation])\n\t\t * @param {mixed} obj the node to close\n\t\t * @param {Number} animation the animation duration in milliseconds when closing the node (overrides the `core.animation` setting). Use `false` for no animation.\n\t\t * @trigger close_node.jstree, after_close.jstree\n\t\t */\n\t\tclose_node : function (obj, animation) {\n\t\t\tvar t1, t2, t, d;\n\t\t\tif($.isArray(obj)) {\n\t\t\t\tobj = obj.slice();\n\t\t\t\tfor(t1 = 0, t2 = obj.length; t1 < t2; t1++) {\n\t\t\t\t\tthis.close_node(obj[t1], animation);\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tobj = this.get_node(obj);\n\t\t\tif(!obj || obj.id === '#') {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif(this.is_closed(obj)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tanimation = animation === undefined ? this.settings.core.animation : animation;\n\t\t\tt = this;\n\t\t\td = this.get_node(obj, true);\n\t\t\tif(d.length) {\n\t\t\t\tif(!animation) {\n\t\t\t\t\td[0].className = d[0].className.replace('jstree-open', 'jstree-closed');\n\t\t\t\t\td.attr(\"aria-expanded\", false).children('.jstree-children').remove();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\td\n\t\t\t\t\t\t.children(\".jstree-children\").attr(\"style\",\"display:block !important\").end()\n\t\t\t\t\t\t.removeClass(\"jstree-open\").addClass(\"jstree-closed\").attr(\"aria-expanded\", false)\n\t\t\t\t\t\t.children(\".jstree-children\").stop(true, true).slideUp(animation, function () {\n\t\t\t\t\t\t\tthis.style.display = \"\";\n\t\t\t\t\t\t\td.children('.jstree-children').remove();\n\t\t\t\t\t\t\tt.trigger(\"after_close\", { \"node\" : obj });\n\t\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t\tobj.state.opened = false;\n\t\t\t/**\n\t\t\t * triggered when a node is closed (if there is an animation it will not be complete yet)\n\t\t\t * @event\n\t\t\t * @name close_node.jstree\n\t\t\t * @param {Object} node the closed node\n\t\t\t */\n\t\t\tthis.trigger('close_node',{ \"node\" : obj });\n\t\t\tif(!animation || !d.length) {\n\t\t\t\t/**\n\t\t\t\t * triggered when a node is closed and the animation is complete\n\t\t\t\t * @event\n\t\t\t\t * @name after_close.jstree\n\t\t\t\t * @param {Object} node the closed node\n\t\t\t\t */\n\t\t\t\tthis.trigger(\"after_close\", { \"node\" : obj });\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * toggles a node - closing it if it is open, opening it if it is closed\n\t\t * @name toggle_node(obj)\n\t\t * @param {mixed} obj the node to toggle\n\t\t */\n\t\ttoggle_node : function (obj) {\n\t\t\tvar t1, t2;\n\t\t\tif($.isArray(obj)) {\n\t\t\t\tobj = obj.slice();\n\t\t\t\tfor(t1 = 0, t2 = obj.length; t1 < t2; t1++) {\n\t\t\t\t\tthis.toggle_node(obj[t1]);\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif(this.is_closed(obj)) {\n\t\t\t\treturn this.open_node(obj);\n\t\t\t}\n\t\t\tif(this.is_open(obj)) {\n\t\t\t\treturn this.close_node(obj);\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * opens all nodes within a node (or the tree), revaling their children. If the node is not loaded it will be loaded and opened once ready.\n\t\t * @name open_all([obj, animation, original_obj])\n\t\t * @param {mixed} obj the node to open recursively, omit to open all nodes in the tree\n\t\t * @param {Number} animation the animation duration in milliseconds when opening the nodes, the default is no animation\n\t\t * @param {jQuery} reference to the node that started the process (internal use)\n\t\t * @trigger open_all.jstree\n\t\t */\n\t\topen_all : function (obj, animation, original_obj) {\n\t\t\tif(!obj) { obj = '#'; }\n\t\t\tobj = this.get_node(obj);\n\t\t\tif(!obj) { return false; }\n\t\t\tvar dom = obj.id === '#' ? this.get_container_ul() : this.get_node(obj, true), i, j, _this;\n\t\t\tif(!dom.length) {\n\t\t\t\tfor(i = 0, j = obj.children_d.length; i < j; i++) {\n\t\t\t\t\tif(this.is_closed(this._model.data[obj.children_d[i]])) {\n\t\t\t\t\t\tthis._model.data[obj.children_d[i]].state.opened = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this.trigger('open_all', { \"node\" : obj });\n\t\t\t}\n\t\t\toriginal_obj = original_obj || dom;\n\t\t\t_this = this;\n\t\t\tdom = this.is_closed(obj) ? dom.find('.jstree-closed').addBack() : dom.find('.jstree-closed');\n\t\t\tdom.each(function () {\n\t\t\t\t_this.open_node(\n\t\t\t\t\tthis,\n\t\t\t\t\tfunction(node, status) { if(status && this.is_parent(node)) { this.open_all(node, animation, original_obj); } },\n\t\t\t\t\tanimation || 0\n\t\t\t\t);\n\t\t\t});\n\t\t\tif(original_obj.find('.jstree-closed').length === 0) {\n\t\t\t\t/**\n\t\t\t\t * triggered when an `open_all` call completes\n\t\t\t\t * @event\n\t\t\t\t * @name open_all.jstree\n\t\t\t\t * @param {Object} node the opened node\n\t\t\t\t */\n\t\t\t\tthis.trigger('open_all', { \"node\" : this.get_node(original_obj) });\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * closes all nodes within a node (or the tree), revaling their children\n\t\t * @name close_all([obj, animation])\n\t\t * @param {mixed} obj the node to close recursively, omit to close all nodes in the tree\n\t\t * @param {Number} animation the animation duration in milliseconds when closing the nodes, the default is no animation\n\t\t * @trigger close_all.jstree\n\t\t */\n\t\tclose_all : function (obj, animation) {\n\t\t\tif(!obj) { obj = '#'; }\n\t\t\tobj = this.get_node(obj);\n\t\t\tif(!obj) { return false; }\n\t\t\tvar dom = obj.id === '#' ? this.get_container_ul() : this.get_node(obj, true),\n\t\t\t\t_this = this, i, j;\n\t\t\tif(!dom.length) {\n\t\t\t\tfor(i = 0, j = obj.children_d.length; i < j; i++) {\n\t\t\t\t\tthis._model.data[obj.children_d[i]].state.opened = false;\n\t\t\t\t}\n\t\t\t\treturn this.trigger('close_all', { \"node\" : obj });\n\t\t\t}\n\t\t\tdom = this.is_open(obj) ? dom.find('.jstree-open').addBack() : dom.find('.jstree-open');\n\t\t\t$(dom.get().reverse()).each(function () { _this.close_node(this, animation || 0); });\n\t\t\t/**\n\t\t\t * triggered when an `close_all` call completes\n\t\t\t * @event\n\t\t\t * @name close_all.jstree\n\t\t\t * @param {Object} node the closed node\n\t\t\t */\n\t\t\tthis.trigger('close_all', { \"node\" : obj });\n\t\t},\n\t\t/**\n\t\t * checks if a node is disabled (not selectable)\n\t\t * @name is_disabled(obj)\n\t\t * @param  {mixed} obj\n\t\t * @return {Boolean}\n\t\t */\n\t\tis_disabled : function (obj) {\n\t\t\tobj = this.get_node(obj);\n\t\t\treturn obj && obj.state && obj.state.disabled;\n\t\t},\n\t\t/**\n\t\t * enables a node - so that it can be selected\n\t\t * @name enable_node(obj)\n\t\t * @param {mixed} obj the node to enable\n\t\t * @trigger enable_node.jstree\n\t\t */\n\t\tenable_node : function (obj) {\n\t\t\tvar t1, t2;\n\t\t\tif($.isArray(obj)) {\n\t\t\t\tobj = obj.slice();\n\t\t\t\tfor(t1 = 0, t2 = obj.length; t1 < t2; t1++) {\n\t\t\t\t\tthis.enable_node(obj[t1]);\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tobj = this.get_node(obj);\n\t\t\tif(!obj || obj.id === '#') {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tobj.state.disabled = false;\n\t\t\tthis.get_node(obj,true).children('.jstree-anchor').removeClass('jstree-disabled');\n\t\t\t/**\n\t\t\t * triggered when an node is enabled\n\t\t\t * @event\n\t\t\t * @name enable_node.jstree\n\t\t\t * @param {Object} node the enabled node\n\t\t\t */\n\t\t\tthis.trigger('enable_node', { 'node' : obj });\n\t\t},\n\t\t/**\n\t\t * disables a node - so that it can not be selected\n\t\t * @name disable_node(obj)\n\t\t * @param {mixed} obj the node to disable\n\t\t * @trigger disable_node.jstree\n\t\t */\n\t\tdisable_node : function (obj) {\n\t\t\tvar t1, t2;\n\t\t\tif($.isArray(obj)) {\n\t\t\t\tobj = obj.slice();\n\t\t\t\tfor(t1 = 0, t2 = obj.length; t1 < t2; t1++) {\n\t\t\t\t\tthis.disable_node(obj[t1]);\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tobj = this.get_node(obj);\n\t\t\tif(!obj || obj.id === '#') {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tobj.state.disabled = true;\n\t\t\tthis.get_node(obj,true).children('.jstree-anchor').addClass('jstree-disabled');\n\t\t\t/**\n\t\t\t * triggered when an node is disabled\n\t\t\t * @event\n\t\t\t * @name disable_node.jstree\n\t\t\t * @param {Object} node the disabled node\n\t\t\t */\n\t\t\tthis.trigger('disable_node', { 'node' : obj });\n\t\t},\n\t\t/**\n\t\t * called when a node is selected by the user. Used internally.\n\t\t * @private\n\t\t * @name activate_node(obj, e)\n\t\t * @param {mixed} obj the node\n\t\t * @param {Object} e the related event\n\t\t * @trigger activate_node.jstree\n\t\t */\n\t\tactivate_node : function (obj, e) {\n\t\t\tif(this.is_disabled(obj)) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// ensure last_clicked is still in the DOM, make it fresh (maybe it was moved?) and make sure it is still selected, if not - make last_clicked the last selected node\n\t\t\tthis._data.core.last_clicked = this._data.core.last_clicked && this._data.core.last_clicked.id !== undefined ? this.get_node(this._data.core.last_clicked.id) : null;\n\t\t\tif(this._data.core.last_clicked && !this._data.core.last_clicked.state.selected) { this._data.core.last_clicked = null; }\n\t\t\tif(!this._data.core.last_clicked && this._data.core.selected.length) { this._data.core.last_clicked = this.get_node(this._data.core.selected[this._data.core.selected.length - 1]); }\n\n\t\t\tif(!this.settings.core.multiple || (!e.metaKey && !e.ctrlKey && !e.shiftKey) || (e.shiftKey && (!this._data.core.last_clicked || !this.get_parent(obj) || this.get_parent(obj) !== this._data.core.last_clicked.parent ) )) {\n\t\t\t\tif(!this.settings.core.multiple && (e.metaKey || e.ctrlKey || e.shiftKey) && this.is_selected(obj)) {\n\t\t\t\t\tthis.deselect_node(obj, false, e);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthis.deselect_all(true);\n\t\t\t\t\tthis.select_node(obj, false, false, e);\n\t\t\t\t\tthis._data.core.last_clicked = this.get_node(obj);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif(e.shiftKey) {\n\t\t\t\t\tvar o = this.get_node(obj).id,\n\t\t\t\t\t\tl = this._data.core.last_clicked.id,\n\t\t\t\t\t\tp = this.get_node(this._data.core.last_clicked.parent).children,\n\t\t\t\t\t\tc = false,\n\t\t\t\t\t\ti, j;\n\t\t\t\t\tfor(i = 0, j = p.length; i < j; i += 1) {\n\t\t\t\t\t\t// separate IFs work whem o and l are the same\n\t\t\t\t\t\tif(p[i] === o) {\n\t\t\t\t\t\t\tc = !c;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(p[i] === l) {\n\t\t\t\t\t\t\tc = !c;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(c || p[i] === o || p[i] === l) {\n\t\t\t\t\t\t\tthis.select_node(p[i], false, false, e);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tthis.deselect_node(p[i], false, e);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif(!this.is_selected(obj)) {\n\t\t\t\t\t\tthis.select_node(obj, false, false, e);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tthis.deselect_node(obj, false, e);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t/**\n\t\t\t * triggered when an node is clicked or intercated with by the user\n\t\t\t * @event\n\t\t\t * @name activate_node.jstree\n\t\t\t * @param {Object} node\n\t\t\t */\n\t\t\tthis.trigger('activate_node', { 'node' : this.get_node(obj) });\n\t\t},\n\t\t/**\n\t\t * applies the hover state on a node, called when a node is hovered by the user. Used internally.\n\t\t * @private\n\t\t * @name hover_node(obj)\n\t\t * @param {mixed} obj\n\t\t * @trigger hover_node.jstree\n\t\t */\n\t\thover_node : function (obj) {\n\t\t\tobj = this.get_node(obj, true);\n\t\t\tif(!obj || !obj.length || obj.children('.jstree-hovered').length) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tvar o = this.element.find('.jstree-hovered'), t = this.element;\n\t\t\tif(o && o.length) { this.dehover_node(o); }\n\n\t\t\tobj.children('.jstree-anchor').addClass('jstree-hovered');\n\t\t\t/**\n\t\t\t * triggered when an node is hovered\n\t\t\t * @event\n\t\t\t * @name hover_node.jstree\n\t\t\t * @param {Object} node\n\t\t\t */\n\t\t\tthis.trigger('hover_node', { 'node' : this.get_node(obj) });\n\t\t\tsetTimeout(function () { t.attr('aria-activedescendant', obj[0].id); obj.attr('aria-selected', true); }, 0);\n\t\t},\n\t\t/**\n\t\t * removes the hover state from a nodecalled when a node is no longer hovered by the user. Used internally.\n\t\t * @private\n\t\t * @name dehover_node(obj)\n\t\t * @param {mixed} obj\n\t\t * @trigger dehover_node.jstree\n\t\t */\n\t\tdehover_node : function (obj) {\n\t\t\tobj = this.get_node(obj, true);\n\t\t\tif(!obj || !obj.length || !obj.children('.jstree-hovered').length) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tobj.attr('aria-selected', false).children('.jstree-anchor').removeClass('jstree-hovered');\n\t\t\t/**\n\t\t\t * triggered when an node is no longer hovered\n\t\t\t * @event\n\t\t\t * @name dehover_node.jstree\n\t\t\t * @param {Object} node\n\t\t\t */\n\t\t\tthis.trigger('dehover_node', { 'node' : this.get_node(obj) });\n\t\t},\n\t\t/**\n\t\t * select a node\n\t\t * @name select_node(obj [, supress_event, prevent_open])\n\t\t * @param {mixed} obj an array can be used to select multiple nodes\n\t\t * @param {Boolean} supress_event if set to `true` the `changed.jstree` event won't be triggered\n\t\t * @param {Boolean} prevent_open if set to `true` parents of the selected node won't be opened\n\t\t * @trigger select_node.jstree, changed.jstree\n\t\t */\n\t\tselect_node : function (obj, supress_event, prevent_open, e) {\n\t\t\tvar dom, t1, t2, th;\n\t\t\tif($.isArray(obj)) {\n\t\t\t\tobj = obj.slice();\n\t\t\t\tfor(t1 = 0, t2 = obj.length; t1 < t2; t1++) {\n\t\t\t\t\tthis.select_node(obj[t1], supress_event, prevent_open, e);\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tobj = this.get_node(obj);\n\t\t\tif(!obj || obj.id === '#') {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tdom = this.get_node(obj, true);\n\t\t\tif(!obj.state.selected) {\n\t\t\t\tobj.state.selected = true;\n\t\t\t\tthis._data.core.selected.push(obj.id);\n\t\t\t\tif(!prevent_open) {\n\t\t\t\t\tdom = this._open_to(obj);\n\t\t\t\t}\n\t\t\t\tif(dom && dom.length) {\n\t\t\t\t\tdom.children('.jstree-anchor').addClass('jstree-clicked');\n\t\t\t\t}\n\t\t\t\t/**\n\t\t\t\t * triggered when an node is selected\n\t\t\t\t * @event\n\t\t\t\t * @name select_node.jstree\n\t\t\t\t * @param {Object} node\n\t\t\t\t * @param {Array} selected the current selection\n\t\t\t\t * @param {Object} event the event (if any) that triggered this select_node\n\t\t\t\t */\n\t\t\t\tthis.trigger('select_node', { 'node' : obj, 'selected' : this._data.core.selected, 'event' : e });\n\t\t\t\tif(!supress_event) {\n\t\t\t\t\t/**\n\t\t\t\t\t * triggered when selection changes\n\t\t\t\t\t * @event\n\t\t\t\t\t * @name changed.jstree\n\t\t\t\t\t * @param {Object} node\n\t\t\t\t\t * @param {Object} action the action that caused the selection to change\n\t\t\t\t\t * @param {Array} selected the current selection\n\t\t\t\t\t * @param {Object} event the event (if any) that triggered this changed event\n\t\t\t\t\t */\n\t\t\t\t\tthis.trigger('changed', { 'action' : 'select_node', 'node' : obj, 'selected' : this._data.core.selected, 'event' : e });\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * deselect a node\n\t\t * @name deselect_node(obj [, supress_event])\n\t\t * @param {mixed} obj an array can be used to deselect multiple nodes\n\t\t * @param {Boolean} supress_event if set to `true` the `changed.jstree` event won't be triggered\n\t\t * @trigger deselect_node.jstree, changed.jstree\n\t\t */\n\t\tdeselect_node : function (obj, supress_event, e) {\n\t\t\tvar t1, t2, dom;\n\t\t\tif($.isArray(obj)) {\n\t\t\t\tobj = obj.slice();\n\t\t\t\tfor(t1 = 0, t2 = obj.length; t1 < t2; t1++) {\n\t\t\t\t\tthis.deselect_node(obj[t1], supress_event, e);\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tobj = this.get_node(obj);\n\t\t\tif(!obj || obj.id === '#') {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tdom = this.get_node(obj, true);\n\t\t\tif(obj.state.selected) {\n\t\t\t\tobj.state.selected = false;\n\t\t\t\tthis._data.core.selected = $.vakata.array_remove_item(this._data.core.selected, obj.id);\n\t\t\t\tif(dom.length) {\n\t\t\t\t\tdom.children('.jstree-anchor').removeClass('jstree-clicked');\n\t\t\t\t}\n\t\t\t\t/**\n\t\t\t\t * triggered when an node is deselected\n\t\t\t\t * @event\n\t\t\t\t * @name deselect_node.jstree\n\t\t\t\t * @param {Object} node\n\t\t\t\t * @param {Array} selected the current selection\n\t\t\t\t * @param {Object} event the event (if any) that triggered this deselect_node\n\t\t\t\t */\n\t\t\t\tthis.trigger('deselect_node', { 'node' : obj, 'selected' : this._data.core.selected, 'event' : e });\n\t\t\t\tif(!supress_event) {\n\t\t\t\t\tthis.trigger('changed', { 'action' : 'deselect_node', 'node' : obj, 'selected' : this._data.core.selected, 'event' : e });\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * select all nodes in the tree\n\t\t * @name select_all([supress_event])\n\t\t * @param {Boolean} supress_event if set to `true` the `changed.jstree` event won't be triggered\n\t\t * @trigger select_all.jstree, changed.jstree\n\t\t */\n\t\tselect_all : function (supress_event) {\n\t\t\tvar tmp = this._data.core.selected.concat([]), i, j;\n\t\t\tthis._data.core.selected = this._model.data['#'].children_d.concat();\n\t\t\tfor(i = 0, j = this._data.core.selected.length; i < j; i++) {\n\t\t\t\tif(this._model.data[this._data.core.selected[i]]) {\n\t\t\t\t\tthis._model.data[this._data.core.selected[i]].state.selected = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.redraw(true);\n\t\t\t/**\n\t\t\t * triggered when all nodes are selected\n\t\t\t * @event\n\t\t\t * @name select_all.jstree\n\t\t\t * @param {Array} selected the current selection\n\t\t\t */\n\t\t\tthis.trigger('select_all', { 'selected' : this._data.core.selected });\n\t\t\tif(!supress_event) {\n\t\t\t\tthis.trigger('changed', { 'action' : 'select_all', 'selected' : this._data.core.selected, 'old_selection' : tmp });\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * deselect all selected nodes\n\t\t * @name deselect_all([supress_event])\n\t\t * @param {Boolean} supress_event if set to `true` the `changed.jstree` event won't be triggered\n\t\t * @trigger deselect_all.jstree, changed.jstree\n\t\t */\n\t\tdeselect_all : function (supress_event) {\n\t\t\tvar tmp = this._data.core.selected.concat([]), i, j;\n\t\t\tfor(i = 0, j = this._data.core.selected.length; i < j; i++) {\n\t\t\t\tif(this._model.data[this._data.core.selected[i]]) {\n\t\t\t\t\tthis._model.data[this._data.core.selected[i]].state.selected = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._data.core.selected = [];\n\t\t\tthis.element.find('.jstree-clicked').removeClass('jstree-clicked');\n\t\t\t/**\n\t\t\t * triggered when all nodes are deselected\n\t\t\t * @event\n\t\t\t * @name deselect_all.jstree\n\t\t\t * @param {Object} node the previous selection\n\t\t\t * @param {Array} selected the current selection\n\t\t\t */\n\t\t\tthis.trigger('deselect_all', { 'selected' : this._data.core.selected, 'node' : tmp });\n\t\t\tif(!supress_event) {\n\t\t\t\tthis.trigger('changed', { 'action' : 'deselect_all', 'selected' : this._data.core.selected, 'old_selection' : tmp });\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * checks if a node is selected\n\t\t * @name is_selected(obj)\n\t\t * @param  {mixed}  obj\n\t\t * @return {Boolean}\n\t\t */\n\t\tis_selected : function (obj) {\n\t\t\tobj = this.get_node(obj);\n\t\t\tif(!obj || obj.id === '#') {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn obj.state.selected;\n\t\t},\n\t\t/**\n\t\t * get an array of all selected nodes\n\t\t * @name get_selected([full])\n\t\t * @param  {mixed}  full if set to `true` the returned array will consist of the full node objects, otherwise - only IDs will be returned\n\t\t * @return {Array}\n\t\t */\n\t\tget_selected : function (full) {\n\t\t\treturn full ? $.map(this._data.core.selected, $.proxy(function (i) { return this.get_node(i); }, this)) : this._data.core.selected.slice();\n\t\t},\n\t\t/**\n\t\t * get an array of all top level selected nodes (ignoring children of selected nodes)\n\t\t * @name get_top_selected([full])\n\t\t * @param  {mixed}  full if set to `true` the returned array will consist of the full node objects, otherwise - only IDs will be returned\n\t\t * @return {Array}\n\t\t */\n\t\tget_top_selected : function (full) {\n\t\t\tvar tmp = this.get_selected(true),\n\t\t\t\tobj = {}, i, j, k, l;\n\t\t\tfor(i = 0, j = tmp.length; i < j; i++) {\n\t\t\t\tobj[tmp[i].id] = tmp[i];\n\t\t\t}\n\t\t\tfor(i = 0, j = tmp.length; i < j; i++) {\n\t\t\t\tfor(k = 0, l = tmp[i].children_d.length; k < l; k++) {\n\t\t\t\t\tif(obj[tmp[i].children_d[k]]) {\n\t\t\t\t\t\tdelete obj[tmp[i].children_d[k]];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\ttmp = [];\n\t\t\tfor(i in obj) {\n\t\t\t\tif(obj.hasOwnProperty(i)) {\n\t\t\t\t\ttmp.push(i);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn full ? $.map(tmp, $.proxy(function (i) { return this.get_node(i); }, this)) : tmp;\n\t\t},\n\t\t/**\n\t\t * get an array of all bottom level selected nodes (ignoring selected parents)\n\t\t * @name get_bottom_selected([full])\n\t\t * @param  {mixed}  full if set to `true` the returned array will consist of the full node objects, otherwise - only IDs will be returned\n\t\t * @return {Array}\n\t\t */\n\t\tget_bottom_selected : function (full) {\n\t\t\tvar tmp = this.get_selected(true),\n\t\t\t\tobj = [], i, j;\n\t\t\tfor(i = 0, j = tmp.length; i < j; i++) {\n\t\t\t\tif(!tmp[i].children.length) {\n\t\t\t\t\tobj.push(tmp[i].id);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn full ? $.map(obj, $.proxy(function (i) { return this.get_node(i); }, this)) : obj;\n\t\t},\n\t\t/**\n\t\t * gets the current state of the tree so that it can be restored later with `set_state(state)`. Used internally.\n\t\t * @name get_state()\n\t\t * @private\n\t\t * @return {Object}\n\t\t */\n\t\tget_state : function () {\n\t\t\tvar state\t= {\n\t\t\t\t'core' : {\n\t\t\t\t\t'open' : [],\n\t\t\t\t\t'scroll' : {\n\t\t\t\t\t\t'left' : this.element.scrollLeft(),\n\t\t\t\t\t\t'top' : this.element.scrollTop()\n\t\t\t\t\t},\n\t\t\t\t\t/*!\n\t\t\t\t\t'themes' : {\n\t\t\t\t\t\t'name' : this.get_theme(),\n\t\t\t\t\t\t'icons' : this._data.core.themes.icons,\n\t\t\t\t\t\t'dots' : this._data.core.themes.dots\n\t\t\t\t\t},\n\t\t\t\t\t*/\n\t\t\t\t\t'selected' : []\n\t\t\t\t}\n\t\t\t}, i;\n\t\t\tfor(i in this._model.data) {\n\t\t\t\tif(this._model.data.hasOwnProperty(i)) {\n\t\t\t\t\tif(i !== '#') {\n\t\t\t\t\t\tif(this._model.data[i].state.opened) {\n\t\t\t\t\t\t\tstate.core.open.push(i);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(this._model.data[i].state.selected) {\n\t\t\t\t\t\t\tstate.core.selected.push(i);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn state;\n\t\t},\n\t\t/**\n\t\t * sets the state of the tree. Used internally.\n\t\t * @name set_state(state [, callback])\n\t\t * @private\n\t\t * @param {Object} state the state to restore\n\t\t * @param {Function} callback an optional function to execute once the state is restored.\n\t\t * @trigger set_state.jstree\n\t\t */\n\t\tset_state : function (state, callback) {\n\t\t\tif(state) {\n\t\t\t\tif(state.core) {\n\t\t\t\t\tvar res, n, t, _this;\n\t\t\t\t\tif(state.core.open) {\n\t\t\t\t\t\tif(!$.isArray(state.core.open)) {\n\t\t\t\t\t\t\tdelete state.core.open;\n\t\t\t\t\t\t\tthis.set_state(state, callback);\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tres = true;\n\t\t\t\t\t\tn = false;\n\t\t\t\t\t\tt = this;\n\t\t\t\t\t\t$.each(state.core.open.concat([]), function (i, v) {\n\t\t\t\t\t\t\tn = t.get_node(v);\n\t\t\t\t\t\t\tif(n) {\n\t\t\t\t\t\t\t\tif(t.is_loaded(v)) {\n\t\t\t\t\t\t\t\t\tif(t.is_closed(v)) {\n\t\t\t\t\t\t\t\t\t\tt.open_node(v, false, 0);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif(state && state.core && state.core.open) {\n\t\t\t\t\t\t\t\t\t\t$.vakata.array_remove_item(state.core.open, v);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tif(!t.is_loading(v)) {\n\t\t\t\t\t\t\t\t\t\tt.open_node(v, $.proxy(function (o, s) {\n\t\t\t\t\t\t\t\t\t\t\tif(!s && state && state.core && state.core.open) {\n\t\t\t\t\t\t\t\t\t\t\t\t$.vakata.array_remove_item(state.core.open, o.id);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tthis.set_state(state, callback);\n\t\t\t\t\t\t\t\t\t\t}, t), 0);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t// there will be some async activity - so wait for it\n\t\t\t\t\t\t\t\t\tres = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t\tif(res) {\n\t\t\t\t\t\t\tdelete state.core.open;\n\t\t\t\t\t\t\tthis.set_state(state, callback);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tif(state.core.scroll) {\n\t\t\t\t\t\tif(state.core.scroll && state.core.scroll.left !== undefined) {\n\t\t\t\t\t\t\tthis.element.scrollLeft(state.core.scroll.left);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(state.core.scroll && state.core.scroll.top !== undefined) {\n\t\t\t\t\t\t\tthis.element.scrollTop(state.core.scroll.top);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdelete state.core.scroll;\n\t\t\t\t\t\tthis.set_state(state, callback);\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\t/*!\n\t\t\t\t\tif(state.core.themes) {\n\t\t\t\t\t\tif(state.core.themes.name) {\n\t\t\t\t\t\t\tthis.set_theme(state.core.themes.name);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(typeof state.core.themes.dots !== 'undefined') {\n\t\t\t\t\t\t\tthis[ state.core.themes.dots ? \"show_dots\" : \"hide_dots\" ]();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(typeof state.core.themes.icons !== 'undefined') {\n\t\t\t\t\t\t\tthis[ state.core.themes.icons ? \"show_icons\" : \"hide_icons\" ]();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdelete state.core.themes;\n\t\t\t\t\t\tdelete state.core.open;\n\t\t\t\t\t\tthis.set_state(state, callback);\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\t*/\n\t\t\t\t\tif(state.core.selected) {\n\t\t\t\t\t\t_this = this;\n\t\t\t\t\t\tthis.deselect_all();\n\t\t\t\t\t\t$.each(state.core.selected, function (i, v) {\n\t\t\t\t\t\t\t_this.select_node(v);\n\t\t\t\t\t\t});\n\t\t\t\t\t\tdelete state.core.selected;\n\t\t\t\t\t\tthis.set_state(state, callback);\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tif($.isEmptyObject(state.core)) {\n\t\t\t\t\t\tdelete state.core;\n\t\t\t\t\t\tthis.set_state(state, callback);\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif($.isEmptyObject(state)) {\n\t\t\t\t\tstate = null;\n\t\t\t\t\tif(callback) { callback.call(this); }\n\t\t\t\t\t/**\n\t\t\t\t\t * triggered when a `set_state` call completes\n\t\t\t\t\t * @event\n\t\t\t\t\t * @name set_state.jstree\n\t\t\t\t\t */\n\t\t\t\t\tthis.trigger('set_state');\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t},\n\t\t/**\n\t\t * refreshes the tree - all nodes are reloaded with calls to `load_node`.\n\t\t * @name refresh()\n\t\t * @param {Boolean} skip_loading an option to skip showing the loading indicator\n\t\t * @param {Mixed} forget_state if set to `true` state will not be reapplied, if set to a function (receiving the current state as argument) the result of that function will be used as state\n\t\t * @trigger refresh.jstree\n\t\t */\n\t\trefresh : function (skip_loading, forget_state) {\n\t\t\tthis._data.core.state = forget_state === true ? {} : this.get_state();\n\t\t\tif(forget_state && $.isFunction(forget_state)) { this._data.core.state = forget_state.call(this, this._data.core.state); }\n\t\t\tthis._cnt = 0;\n\t\t\tthis._model.data = {\n\t\t\t\t'#' : {\n\t\t\t\t\tid : '#',\n\t\t\t\t\tparent : null,\n\t\t\t\t\tparents : [],\n\t\t\t\t\tchildren : [],\n\t\t\t\t\tchildren_d : [],\n\t\t\t\t\tstate : { loaded : false }\n\t\t\t\t}\n\t\t\t};\n\t\t\tvar c = this.get_container_ul()[0].className;\n\t\t\tif(!skip_loading) {\n\t\t\t\tthis.element.html(\"<\"+\"ul class='\"+c+\"'><\"+\"li class='jstree-initial-node jstree-loading jstree-leaf jstree-last'><i class='jstree-icon jstree-ocl'></i><\"+\"a class='jstree-anchor' href='#'><i class='jstree-icon jstree-themeicon-hidden'></i>\" + this.get_string(\"Loading ...\") + \"</a></li></ul>\");\n\t\t\t}\n\t\t\tthis.load_node('#', function (o, s) {\n\t\t\t\tif(s) {\n\t\t\t\t\tthis.get_container_ul()[0].className = c;\n\t\t\t\t\tthis.set_state($.extend(true, {}, this._data.core.state), function () {\n\t\t\t\t\t\t/**\n\t\t\t\t\t\t * triggered when a `refresh` call completes\n\t\t\t\t\t\t * @event\n\t\t\t\t\t\t * @name refresh.jstree\n\t\t\t\t\t\t */\n\t\t\t\t\t\tthis.trigger('refresh');\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tthis._data.core.state = null;\n\t\t\t});\n\t\t},\n\t\t/**\n\t\t * refreshes a node in the tree (reload its children) all opened nodes inside that node are reloaded with calls to `load_node`.\n\t\t * @name refresh_node(obj)\n\t\t * @param  {mixed} obj the node\n\t\t * @trigger refresh_node.jstree\n\t\t */\n\t\trefresh_node : function (obj) {\n\t\t\tobj = this.get_node(obj);\n\t\t\tif(!obj || obj.id === '#') { return false; }\n\t\t\tvar opened = [], to_load = [], s = this._data.core.selected.concat([]);\n\t\t\tto_load.push(obj.id);\n\t\t\tif(obj.state.opened === true) { opened.push(obj.id); }\n\t\t\tthis.get_node(obj, true).find('.jstree-open').each(function() { opened.push(this.id); });\n\t\t\tthis._load_nodes(to_load, $.proxy(function (nodes) {\n\t\t\t\tthis.open_node(opened, false, 0);\n\t\t\t\tthis.select_node(this._data.core.selected);\n\t\t\t\t/**\n\t\t\t\t * triggered when a node is refreshed\n\t\t\t\t * @event\n\t\t\t\t * @name refresh_node.jstree\n\t\t\t\t * @param {Object} node - the refreshed node\n\t\t\t\t * @param {Array} nodes - an array of the IDs of the nodes that were reloaded\n\t\t\t\t */\n\t\t\t\tthis.trigger('refresh_node', { 'node' : obj, 'nodes' : nodes });\n\t\t\t}, this));\n\t\t},\n\t\t/**\n\t\t * set (change) the ID of a node\n\t\t * @name set_id(obj, id)\n\t\t * @param  {mixed} obj the node\n\t\t * @param  {String} id the new ID\n\t\t * @return {Boolean}\n\t\t */\n\t\tset_id : function (obj, id) {\n\t\t\tobj = this.get_node(obj);\n\t\t\tif(!obj || obj.id === '#') { return false; }\n\t\t\tvar i, j, m = this._model.data;\n\t\t\tid = id.toString();\n\t\t\t// update parents (replace current ID with new one in children and children_d)\n\t\t\tm[obj.parent].children[$.inArray(obj.id, m[obj.parent].children)] = id;\n\t\t\tfor(i = 0, j = obj.parents.length; i < j; i++) {\n\t\t\t\tm[obj.parents[i]].children_d[$.inArray(obj.id, m[obj.parents[i]].children_d)] = id;\n\t\t\t}\n\t\t\t// update children (replace current ID with new one in parent and parents)\n\t\t\tfor(i = 0, j = obj.children.length; i < j; i++) {\n\t\t\t\tm[obj.children[i]].parent = id;\n\t\t\t}\n\t\t\tfor(i = 0, j = obj.children_d.length; i < j; i++) {\n\t\t\t\tm[obj.children_d[i]].parents[$.inArray(obj.id, m[obj.children_d[i]].parents)] = id;\n\t\t\t}\n\t\t\ti = $.inArray(obj.id, this._data.core.selected);\n\t\t\tif(i !== -1) { this._data.core.selected[i] = id; }\n\t\t\t// update model and obj itself (obj.id, this._model.data[KEY])\n\t\t\ti = this.get_node(obj.id, true);\n\t\t\tif(i) {\n\t\t\t\ti.attr('id', id);\n\t\t\t}\n\t\t\tdelete m[obj.id];\n\t\t\tobj.id = id;\n\t\t\tm[id] = obj;\n\t\t\treturn true;\n\t\t},\n\t\t/**\n\t\t * get the text value of a node\n\t\t * @name get_text(obj)\n\t\t * @param  {mixed} obj the node\n\t\t * @return {String}\n\t\t */\n\t\tget_text : function (obj) {\n\t\t\tobj = this.get_node(obj);\n\t\t\treturn (!obj || obj.id === '#') ? false : obj.text;\n\t\t},\n\t\t/**\n\t\t * set the text value of a node. Used internally, please use `rename_node(obj, val)`.\n\t\t * @private\n\t\t * @name set_text(obj, val)\n\t\t * @param  {mixed} obj the node, you can pass an array to set the text on multiple nodes\n\t\t * @param  {String} val the new text value\n\t\t * @return {Boolean}\n\t\t * @trigger set_text.jstree\n\t\t */\n\t\tset_text : function (obj, val) {\n\t\t\tvar t1, t2;\n\t\t\tif($.isArray(obj)) {\n\t\t\t\tobj = obj.slice();\n\t\t\t\tfor(t1 = 0, t2 = obj.length; t1 < t2; t1++) {\n\t\t\t\t\tthis.set_text(obj[t1], val);\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tobj = this.get_node(obj);\n\t\t\tif(!obj || obj.id === '#') { return false; }\n\t\t\tobj.text = val;\n\t\t\tif(this.get_node(obj, true).length) {\n\t\t\t\tthis.redraw_node(obj.id);\n\t\t\t}\n\t\t\t/**\n\t\t\t * triggered when a node text value is changed\n\t\t\t * @event\n\t\t\t * @name set_text.jstree\n\t\t\t * @param {Object} obj\n\t\t\t * @param {String} text the new value\n\t\t\t */\n\t\t\tthis.trigger('set_text',{ \"obj\" : obj, \"text\" : val });\n\t\t\treturn true;\n\t\t},\n\t\t/**\n\t\t * gets a JSON representation of a node (or the whole tree)\n\t\t * @name get_json([obj, options])\n\t\t * @param  {mixed} obj\n\t\t * @param  {Object} options\n\t\t * @param  {Boolean} options.no_state do not return state information\n\t\t * @param  {Boolean} options.no_id do not return ID\n\t\t * @param  {Boolean} options.no_children do not include children\n\t\t * @param  {Boolean} options.no_data do not include node data\n\t\t * @param  {Boolean} options.flat return flat JSON instead of nested\n\t\t * @return {Object}\n\t\t */\n\t\tget_json : function (obj, options, flat) {\n\t\t\tobj = this.get_node(obj || '#');\n\t\t\tif(!obj) { return false; }\n\t\t\tif(options && options.flat && !flat) { flat = []; }\n\t\t\tvar tmp = {\n\t\t\t\t'id' : obj.id,\n\t\t\t\t'text' : obj.text,\n\t\t\t\t'icon' : this.get_icon(obj),\n\t\t\t\t'li_attr' : obj.li_attr,\n\t\t\t\t'a_attr' : obj.a_attr,\n\t\t\t\t'state' : {},\n\t\t\t\t'data' : options && options.no_data ? false : obj.data\n\t\t\t\t//( this.get_node(obj, true).length ? this.get_node(obj, true).data() : obj.data ),\n\t\t\t}, i, j;\n\t\t\tif(options && options.flat) {\n\t\t\t\ttmp.parent = obj.parent;\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttmp.children = [];\n\t\t\t}\n\t\t\tif(!options || !options.no_state) {\n\t\t\t\tfor(i in obj.state) {\n\t\t\t\t\tif(obj.state.hasOwnProperty(i)) {\n\t\t\t\t\t\ttmp.state[i] = obj.state[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(options && options.no_id) {\n\t\t\t\tdelete tmp.id;\n\t\t\t\tif(tmp.li_attr && tmp.li_attr.id) {\n\t\t\t\t\tdelete tmp.li_attr.id;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(options && options.flat && obj.id !== '#') {\n\t\t\t\tflat.push(tmp);\n\t\t\t}\n\t\t\tif(!options || !options.no_children) {\n\t\t\t\tfor(i = 0, j = obj.children.length; i < j; i++) {\n\t\t\t\t\tif(options && options.flat) {\n\t\t\t\t\t\tthis.get_json(obj.children[i], options, flat);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\ttmp.children.push(this.get_json(obj.children[i], options));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn options && options.flat ? flat : (obj.id === '#' ? tmp.children : tmp);\n\t\t},\n\t\t/**\n\t\t * create a new node (do not confuse with load_node)\n\t\t * @name create_node([obj, node, pos, callback, is_loaded])\n\t\t * @param  {mixed}   par       the parent node (to create a root node use either \"#\" (string) or `null`)\n\t\t * @param  {mixed}   node      the data for the new node (a valid JSON object, or a simple string with the name)\n\t\t * @param  {mixed}   pos       the index at which to insert the node, \"first\" and \"last\" are also supported, default is \"last\"\n\t\t * @param  {Function} callback a function to be called once the node is created\n\t\t * @param  {Boolean} is_loaded internal argument indicating if the parent node was succesfully loaded\n\t\t * @return {String}            the ID of the newly create node\n\t\t * @trigger model.jstree, create_node.jstree\n\t\t */\n\t\tcreate_node : function (par, node, pos, callback, is_loaded) {\n\t\t\tif(par === null) { par = \"#\"; }\n\t\t\tpar = this.get_node(par);\n\t\t\tif(!par) { return false; }\n\t\t\tpos = pos === undefined ? \"last\" : pos;\n\t\t\tif(!pos.toString().match(/^(before|after)$/) && !is_loaded && !this.is_loaded(par)) {\n\t\t\t\treturn this.load_node(par, function () { this.create_node(par, node, pos, callback, true); });\n\t\t\t}\n\t\t\tif(!node) { node = { \"text\" : this.get_string('New node') }; }\n\t\t\tif(node.text === undefined) { node.text = this.get_string('New node'); }\n\t\t\tvar tmp, dpc, i, j;\n\n\t\t\tif(par.id === '#') {\n\t\t\t\tif(pos === \"before\") { pos = \"first\"; }\n\t\t\t\tif(pos === \"after\") { pos = \"last\"; }\n\t\t\t}\n\t\t\tswitch(pos) {\n\t\t\t\tcase \"before\":\n\t\t\t\t\ttmp = this.get_node(par.parent);\n\t\t\t\t\tpos = $.inArray(par.id, tmp.children);\n\t\t\t\t\tpar = tmp;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"after\" :\n\t\t\t\t\ttmp = this.get_node(par.parent);\n\t\t\t\t\tpos = $.inArray(par.id, tmp.children) + 1;\n\t\t\t\t\tpar = tmp;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"inside\":\n\t\t\t\tcase \"first\":\n\t\t\t\t\tpos = 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"last\":\n\t\t\t\t\tpos = par.children.length;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tif(!pos) { pos = 0; }\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(pos > par.children.length) { pos = par.children.length; }\n\t\t\tif(!node.id) { node.id = true; }\n\t\t\tif(!this.check(\"create_node\", node, par, pos)) {\n\t\t\t\tthis.settings.core.error.call(this, this._data.core.last_error);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif(node.id === true) { delete node.id; }\n\t\t\tnode = this._parse_model_from_json(node, par.id, par.parents.concat());\n\t\t\tif(!node) { return false; }\n\t\t\ttmp = this.get_node(node);\n\t\t\tdpc = [];\n\t\t\tdpc.push(node);\n\t\t\tdpc = dpc.concat(tmp.children_d);\n\t\t\tthis.trigger('model', { \"nodes\" : dpc, \"parent\" : par.id });\n\n\t\t\tpar.children_d = par.children_d.concat(dpc);\n\t\t\tfor(i = 0, j = par.parents.length; i < j; i++) {\n\t\t\t\tthis._model.data[par.parents[i]].children_d = this._model.data[par.parents[i]].children_d.concat(dpc);\n\t\t\t}\n\t\t\tnode = tmp;\n\t\t\ttmp = [];\n\t\t\tfor(i = 0, j = par.children.length; i < j; i++) {\n\t\t\t\ttmp[i >= pos ? i+1 : i] = par.children[i];\n\t\t\t}\n\t\t\ttmp[pos] = node.id;\n\t\t\tpar.children = tmp;\n\n\t\t\tthis.redraw_node(par, true);\n\t\t\tif(callback) { callback.call(this, this.get_node(node)); }\n\t\t\t/**\n\t\t\t * triggered when a node is created\n\t\t\t * @event\n\t\t\t * @name create_node.jstree\n\t\t\t * @param {Object} node\n\t\t\t * @param {String} parent the parent's ID\n\t\t\t * @param {Number} position the position of the new node among the parent's children\n\t\t\t */\n\t\t\tthis.trigger('create_node', { \"node\" : this.get_node(node), \"parent\" : par.id, \"position\" : pos });\n\t\t\treturn node.id;\n\t\t},\n\t\t/**\n\t\t * set the text value of a node\n\t\t * @name rename_node(obj, val)\n\t\t * @param  {mixed} obj the node, you can pass an array to rename multiple nodes to the same name\n\t\t * @param  {String} val the new text value\n\t\t * @return {Boolean}\n\t\t * @trigger rename_node.jstree\n\t\t */\n\t\trename_node : function (obj, val) {\n\t\t\tvar t1, t2, old;\n\t\t\tif($.isArray(obj)) {\n\t\t\t\tobj = obj.slice();\n\t\t\t\tfor(t1 = 0, t2 = obj.length; t1 < t2; t1++) {\n\t\t\t\t\tthis.rename_node(obj[t1], val);\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tobj = this.get_node(obj);\n\t\t\tif(!obj || obj.id === '#') { return false; }\n\t\t\told = obj.text;\n\t\t\tif(!this.check(\"rename_node\", obj, this.get_parent(obj), val)) {\n\t\t\t\tthis.settings.core.error.call(this, this._data.core.last_error);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tthis.set_text(obj, val); // .apply(this, Array.prototype.slice.call(arguments))\n\t\t\t/**\n\t\t\t * triggered when a node is renamed\n\t\t\t * @event\n\t\t\t * @name rename_node.jstree\n\t\t\t * @param {Object} node\n\t\t\t * @param {String} text the new value\n\t\t\t * @param {String} old the old value\n\t\t\t */\n\t\t\tthis.trigger('rename_node', { \"node\" : obj, \"text\" : val, \"old\" : old });\n\t\t\treturn true;\n\t\t},\n\t\t/**\n\t\t * remove a node\n\t\t * @name delete_node(obj)\n\t\t * @param  {mixed} obj the node, you can pass an array to delete multiple nodes\n\t\t * @return {Boolean}\n\t\t * @trigger delete_node.jstree, changed.jstree\n\t\t */\n\t\tdelete_node : function (obj) {\n\t\t\tvar t1, t2, par, pos, tmp, i, j, k, l, c;\n\t\t\tif($.isArray(obj)) {\n\t\t\t\tobj = obj.slice();\n\t\t\t\tfor(t1 = 0, t2 = obj.length; t1 < t2; t1++) {\n\t\t\t\t\tthis.delete_node(obj[t1]);\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tobj = this.get_node(obj);\n\t\t\tif(!obj || obj.id === '#') { return false; }\n\t\t\tpar = this.get_node(obj.parent);\n\t\t\tpos = $.inArray(obj.id, par.children);\n\t\t\tc = false;\n\t\t\tif(!this.check(\"delete_node\", obj, par, pos)) {\n\t\t\t\tthis.settings.core.error.call(this, this._data.core.last_error);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif(pos !== -1) {\n\t\t\t\tpar.children = $.vakata.array_remove(par.children, pos);\n\t\t\t}\n\t\t\ttmp = obj.children_d.concat([]);\n\t\t\ttmp.push(obj.id);\n\t\t\tfor(k = 0, l = tmp.length; k < l; k++) {\n\t\t\t\tfor(i = 0, j = obj.parents.length; i < j; i++) {\n\t\t\t\t\tpos = $.inArray(tmp[k], this._model.data[obj.parents[i]].children_d);\n\t\t\t\t\tif(pos !== -1) {\n\t\t\t\t\t\tthis._model.data[obj.parents[i]].children_d = $.vakata.array_remove(this._model.data[obj.parents[i]].children_d, pos);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(this._model.data[tmp[k]].state.selected) {\n\t\t\t\t\tc = true;\n\t\t\t\t\tpos = $.inArray(tmp[k], this._data.core.selected);\n\t\t\t\t\tif(pos !== -1) {\n\t\t\t\t\t\tthis._data.core.selected = $.vakata.array_remove(this._data.core.selected, pos);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t/**\n\t\t\t * triggered when a node is deleted\n\t\t\t * @event\n\t\t\t * @name delete_node.jstree\n\t\t\t * @param {Object} node\n\t\t\t * @param {String} parent the parent's ID\n\t\t\t */\n\t\t\tthis.trigger('delete_node', { \"node\" : obj, \"parent\" : par.id });\n\t\t\tif(c) {\n\t\t\t\tthis.trigger('changed', { 'action' : 'delete_node', 'node' : obj, 'selected' : this._data.core.selected, 'parent' : par.id });\n\t\t\t}\n\t\t\tfor(k = 0, l = tmp.length; k < l; k++) {\n\t\t\t\tdelete this._model.data[tmp[k]];\n\t\t\t}\n\t\t\tthis.redraw_node(par, true);\n\t\t\treturn true;\n\t\t},\n\t\t/**\n\t\t * check if an operation is premitted on the tree. Used internally.\n\t\t * @private\n\t\t * @name check(chk, obj, par, pos)\n\t\t * @param  {String} chk the operation to check, can be \"create_node\", \"rename_node\", \"delete_node\", \"copy_node\" or \"move_node\"\n\t\t * @param  {mixed} obj the node\n\t\t * @param  {mixed} par the parent\n\t\t * @param  {mixed} pos the position to insert at, or if \"rename_node\" - the new name\n\t\t * @param  {mixed} more some various additional information, for example if a \"move_node\" operations is triggered by DND this will be the hovered node\n\t\t * @return {Boolean}\n\t\t */\n\t\tcheck : function (chk, obj, par, pos, more) {\n\t\t\tobj = obj && obj.id ? obj : this.get_node(obj);\n\t\t\tpar = par && par.id ? par : this.get_node(par);\n\t\t\tvar tmp = chk.match(/^move_node|copy_node|create_node$/i) ? par : obj,\n\t\t\t\tchc = this.settings.core.check_callback;\n\t\t\tif(chk === \"move_node\" || chk === \"copy_node\") {\n\t\t\t\tif((!more || !more.is_multi) && (obj.id === par.id || $.inArray(obj.id, par.children) === pos || $.inArray(par.id, obj.children_d) !== -1)) {\n\t\t\t\t\tthis._data.core.last_error = { 'error' : 'check', 'plugin' : 'core', 'id' : 'core_01', 'reason' : 'Moving parent inside child', 'data' : JSON.stringify({ 'chk' : chk, 'pos' : pos, 'obj' : obj && obj.id ? obj.id : false, 'par' : par && par.id ? par.id : false }) };\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(tmp && tmp.data) { tmp = tmp.data; }\n\t\t\tif(tmp && tmp.functions && (tmp.functions[chk] === false || tmp.functions[chk] === true)) {\n\t\t\t\tif(tmp.functions[chk] === false) {\n\t\t\t\t\tthis._data.core.last_error = { 'error' : 'check', 'plugin' : 'core', 'id' : 'core_02', 'reason' : 'Node data prevents function: ' + chk, 'data' : JSON.stringify({ 'chk' : chk, 'pos' : pos, 'obj' : obj && obj.id ? obj.id : false, 'par' : par && par.id ? par.id : false }) };\n\t\t\t\t}\n\t\t\t\treturn tmp.functions[chk];\n\t\t\t}\n\t\t\tif(chc === false || ($.isFunction(chc) && chc.call(this, chk, obj, par, pos, more) === false) || (chc && chc[chk] === false)) {\n\t\t\t\tthis._data.core.last_error = { 'error' : 'check', 'plugin' : 'core', 'id' : 'core_03', 'reason' : 'User config for core.check_callback prevents function: ' + chk, 'data' : JSON.stringify({ 'chk' : chk, 'pos' : pos, 'obj' : obj && obj.id ? obj.id : false, 'par' : par && par.id ? par.id : false }) };\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\t\t/**\n\t\t * get the last error\n\t\t * @name last_error()\n\t\t * @return {Object}\n\t\t */\n\t\tlast_error : function () {\n\t\t\treturn this._data.core.last_error;\n\t\t},\n\t\t/**\n\t\t * move a node to a new parent\n\t\t * @name move_node(obj, par [, pos, callback, is_loaded])\n\t\t * @param  {mixed} obj the node to move, pass an array to move multiple nodes\n\t\t * @param  {mixed} par the new parent\n\t\t * @param  {mixed} pos the position to insert at (besides integer values, \"first\" and \"last\" are supported, as well as \"before\" and \"after\"), defaults to integer `0`\n\t\t * @param  {function} callback a function to call once the move is completed, receives 3 arguments - the node, the new parent and the position\n\t\t * @param  {Boolean} internal parameter indicating if the parent node has been loaded\n\t\t * @trigger move_node.jstree\n\t\t */\n\t\tmove_node : function (obj, par, pos, callback, is_loaded) {\n\t\t\tvar t1, t2, old_par, old_pos, new_par, old_ins, is_multi, dpc, tmp, i, j, k, l, p;\n\n\t\t\tpar = this.get_node(par);\n\t\t\tpos = pos === undefined ? 0 : pos;\n\t\t\tif(!par) { return false; }\n\t\t\tif(!pos.toString().match(/^(before|after)$/) && !is_loaded && !this.is_loaded(par)) {\n\t\t\t\treturn this.load_node(par, function () { this.move_node(obj, par, pos, callback, true); });\n\t\t\t}\n\n\t\t\tif($.isArray(obj)) {\n\t\t\t\tobj = obj.reverse().slice();\n\t\t\t\tfor(t1 = 0, t2 = obj.length; t1 < t2; t1++) {\n\t\t\t\t\tthis.move_node(obj[t1], par, pos, callback, is_loaded);\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tobj = obj && obj.id ? obj : this.get_node(obj);\n\n\t\t\tif(!obj || obj.id === '#') { return false; }\n\n\t\t\told_par = (obj.parent || '#').toString();\n\t\t\tnew_par = (!pos.toString().match(/^(before|after)$/) || par.id === '#') ? par : this.get_node(par.parent);\n\t\t\told_ins = obj.instance ? obj.instance : (this._model.data[obj.id] ? this : $.jstree.reference(obj.id));\n\t\t\tis_multi = !old_ins || !old_ins._id || (this._id !== old_ins._id);\n\t\t\told_pos = old_ins && old_ins._id && old_par && old_ins._model.data[old_par] && old_ins._model.data[old_par].children ? $.inArray(obj.id, old_ins._model.data[old_par].children) : -1;\n\t\t\tif(is_multi) {\n\t\t\t\tif(this.copy_node(obj, par, pos, callback, is_loaded)) {\n\t\t\t\t\tif(old_ins) { old_ins.delete_node(obj); }\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t//var m = this._model.data;\n\t\t\tif(new_par.id === '#') {\n\t\t\t\tif(pos === \"before\") { pos = \"first\"; }\n\t\t\t\tif(pos === \"after\") { pos = \"last\"; }\n\t\t\t}\n\t\t\tswitch(pos) {\n\t\t\t\tcase \"before\":\n\t\t\t\t\tpos = $.inArray(par.id, new_par.children);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"after\" :\n\t\t\t\t\tpos = $.inArray(par.id, new_par.children) + 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"inside\":\n\t\t\t\tcase \"first\":\n\t\t\t\t\tpos = 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"last\":\n\t\t\t\t\tpos = new_par.children.length;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tif(!pos) { pos = 0; }\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(pos > new_par.children.length) { pos = new_par.children.length; }\n\t\t\tif(!this.check(\"move_node\", obj, new_par, pos, { 'core' : true, 'is_multi' : (old_ins && old_ins._id && old_ins._id !== this._id), 'is_foreign' : (!old_ins || !old_ins._id) })) {\n\t\t\t\tthis.settings.core.error.call(this, this._data.core.last_error);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif(obj.parent === new_par.id) {\n\t\t\t\tdpc = new_par.children.concat();\n\t\t\t\ttmp = $.inArray(obj.id, dpc);\n\t\t\t\tif(tmp !== -1) {\n\t\t\t\t\tdpc = $.vakata.array_remove(dpc, tmp);\n\t\t\t\t\tif(pos > tmp) { pos--; }\n\t\t\t\t}\n\t\t\t\ttmp = [];\n\t\t\t\tfor(i = 0, j = dpc.length; i < j; i++) {\n\t\t\t\t\ttmp[i >= pos ? i+1 : i] = dpc[i];\n\t\t\t\t}\n\t\t\t\ttmp[pos] = obj.id;\n\t\t\t\tnew_par.children = tmp;\n\t\t\t\tthis._node_changed(new_par.id);\n\t\t\t\tthis.redraw(new_par.id === '#');\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// clean old parent and up\n\t\t\t\ttmp = obj.children_d.concat();\n\t\t\t\ttmp.push(obj.id);\n\t\t\t\tfor(i = 0, j = obj.parents.length; i < j; i++) {\n\t\t\t\t\tdpc = [];\n\t\t\t\t\tp = old_ins._model.data[obj.parents[i]].children_d;\n\t\t\t\t\tfor(k = 0, l = p.length; k < l; k++) {\n\t\t\t\t\t\tif($.inArray(p[k], tmp) === -1) {\n\t\t\t\t\t\t\tdpc.push(p[k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\told_ins._model.data[obj.parents[i]].children_d = dpc;\n\t\t\t\t}\n\t\t\t\told_ins._model.data[old_par].children = $.vakata.array_remove_item(old_ins._model.data[old_par].children, obj.id);\n\n\t\t\t\t// insert into new parent and up\n\t\t\t\tfor(i = 0, j = new_par.parents.length; i < j; i++) {\n\t\t\t\t\tthis._model.data[new_par.parents[i]].children_d = this._model.data[new_par.parents[i]].children_d.concat(tmp);\n\t\t\t\t}\n\t\t\t\tdpc = [];\n\t\t\t\tfor(i = 0, j = new_par.children.length; i < j; i++) {\n\t\t\t\t\tdpc[i >= pos ? i+1 : i] = new_par.children[i];\n\t\t\t\t}\n\t\t\t\tdpc[pos] = obj.id;\n\t\t\t\tnew_par.children = dpc;\n\t\t\t\tnew_par.children_d.push(obj.id);\n\t\t\t\tnew_par.children_d = new_par.children_d.concat(obj.children_d);\n\n\t\t\t\t// update object\n\t\t\t\tobj.parent = new_par.id;\n\t\t\t\ttmp = new_par.parents.concat();\n\t\t\t\ttmp.unshift(new_par.id);\n\t\t\t\tp = obj.parents.length;\n\t\t\t\tobj.parents = tmp;\n\n\t\t\t\t// update object children\n\t\t\t\ttmp = tmp.concat();\n\t\t\t\tfor(i = 0, j = obj.children_d.length; i < j; i++) {\n\t\t\t\t\tthis._model.data[obj.children_d[i]].parents = this._model.data[obj.children_d[i]].parents.slice(0,p*-1);\n\t\t\t\t\tArray.prototype.push.apply(this._model.data[obj.children_d[i]].parents, tmp);\n\t\t\t\t}\n\n\t\t\t\tthis._node_changed(old_par);\n\t\t\t\tthis._node_changed(new_par.id);\n\t\t\t\tthis.redraw(old_par === '#' || new_par.id === '#');\n\t\t\t}\n\t\t\tif(callback) { callback.call(this, obj, new_par, pos); }\n\t\t\t/**\n\t\t\t * triggered when a node is moved\n\t\t\t * @event\n\t\t\t * @name move_node.jstree\n\t\t\t * @param {Object} node\n\t\t\t * @param {String} parent the parent's ID\n\t\t\t * @param {Number} position the position of the node among the parent's children\n\t\t\t * @param {String} old_parent the old parent of the node\n\t\t\t * @param {Number} old_position the old position of the node\n\t\t\t * @param {Boolean} is_multi do the node and new parent belong to different instances\n\t\t\t * @param {jsTree} old_instance the instance the node came from\n\t\t\t * @param {jsTree} new_instance the instance of the new parent\n\t\t\t */\n\t\t\tthis.trigger('move_node', { \"node\" : obj, \"parent\" : new_par.id, \"position\" : pos, \"old_parent\" : old_par, \"old_position\" : old_pos, 'is_multi' : (old_ins && old_ins._id && old_ins._id !== this._id), 'is_foreign' : (!old_ins || !old_ins._id), 'old_instance' : old_ins, 'new_instance' : this });\n\t\t\treturn true;\n\t\t},\n\t\t/**\n\t\t * copy a node to a new parent\n\t\t * @name copy_node(obj, par [, pos, callback, is_loaded])\n\t\t * @param  {mixed} obj the node to copy, pass an array to copy multiple nodes\n\t\t * @param  {mixed} par the new parent\n\t\t * @param  {mixed} pos the position to insert at (besides integer values, \"first\" and \"last\" are supported, as well as \"before\" and \"after\"), defaults to integer `0`\n\t\t * @param  {function} callback a function to call once the move is completed, receives 3 arguments - the node, the new parent and the position\n\t\t * @param  {Boolean} internal parameter indicating if the parent node has been loaded\n\t\t * @trigger model.jstree copy_node.jstree\n\t\t */\n\t\tcopy_node : function (obj, par, pos, callback, is_loaded) {\n\t\t\tvar t1, t2, dpc, tmp, i, j, node, old_par, new_par, old_ins, is_multi;\n\n\t\t\tpar = this.get_node(par);\n\t\t\tpos = pos === undefined ? 0 : pos;\n\t\t\tif(!par) { return false; }\n\t\t\tif(!pos.toString().match(/^(before|after)$/) && !is_loaded && !this.is_loaded(par)) {\n\t\t\t\treturn this.load_node(par, function () { this.copy_node(obj, par, pos, callback, true); });\n\t\t\t}\n\n\t\t\tif($.isArray(obj)) {\n\t\t\t\tobj = obj.reverse().slice();\n\t\t\t\tfor(t1 = 0, t2 = obj.length; t1 < t2; t1++) {\n\t\t\t\t\tthis.copy_node(obj[t1], par, pos, callback, is_loaded);\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tobj = obj && obj.id ? obj : this.get_node(obj);\n\t\t\tif(!obj || obj.id === '#') { return false; }\n\n\t\t\told_par = (obj.parent || '#').toString();\n\t\t\tnew_par = (!pos.toString().match(/^(before|after)$/) || par.id === '#') ? par : this.get_node(par.parent);\n\t\t\told_ins = obj.instance ? obj.instance : (this._model.data[obj.id] ? this : $.jstree.reference(obj.id));\n\t\t\tis_multi = !old_ins || !old_ins._id || (this._id !== old_ins._id);\n\t\t\tif(new_par.id === '#') {\n\t\t\t\tif(pos === \"before\") { pos = \"first\"; }\n\t\t\t\tif(pos === \"after\") { pos = \"last\"; }\n\t\t\t}\n\t\t\tswitch(pos) {\n\t\t\t\tcase \"before\":\n\t\t\t\t\tpos = $.inArray(par.id, new_par.children);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"after\" :\n\t\t\t\t\tpos = $.inArray(par.id, new_par.children) + 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"inside\":\n\t\t\t\tcase \"first\":\n\t\t\t\t\tpos = 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"last\":\n\t\t\t\t\tpos = new_par.children.length;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tif(!pos) { pos = 0; }\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(pos > new_par.children.length) { pos = new_par.children.length; }\n\t\t\tif(!this.check(\"copy_node\", obj, new_par, pos, { 'core' : true, 'is_multi' : (old_ins && old_ins._id && old_ins._id !== this._id), 'is_foreign' : (!old_ins || !old_ins._id) })) {\n\t\t\t\tthis.settings.core.error.call(this, this._data.core.last_error);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tnode = old_ins ? old_ins.get_json(obj, { no_id : true, no_data : true, no_state : true }) : obj;\n\t\t\tif(!node) { return false; }\n\t\t\tif(node.id === true) { delete node.id; }\n\t\t\tnode = this._parse_model_from_json(node, new_par.id, new_par.parents.concat());\n\t\t\tif(!node) { return false; }\n\t\t\ttmp = this.get_node(node);\n\t\t\tif(obj && obj.state && obj.state.loaded === false) { tmp.state.loaded = false; }\n\t\t\tdpc = [];\n\t\t\tdpc.push(node);\n\t\t\tdpc = dpc.concat(tmp.children_d);\n\t\t\tthis.trigger('model', { \"nodes\" : dpc, \"parent\" : new_par.id });\n\n\t\t\t// insert into new parent and up\n\t\t\tfor(i = 0, j = new_par.parents.length; i < j; i++) {\n\t\t\t\tthis._model.data[new_par.parents[i]].children_d = this._model.data[new_par.parents[i]].children_d.concat(dpc);\n\t\t\t}\n\t\t\tdpc = [];\n\t\t\tfor(i = 0, j = new_par.children.length; i < j; i++) {\n\t\t\t\tdpc[i >= pos ? i+1 : i] = new_par.children[i];\n\t\t\t}\n\t\t\tdpc[pos] = tmp.id;\n\t\t\tnew_par.children = dpc;\n\t\t\tnew_par.children_d.push(tmp.id);\n\t\t\tnew_par.children_d = new_par.children_d.concat(tmp.children_d);\n\n\t\t\tthis._node_changed(new_par.id);\n\t\t\tthis.redraw(new_par.id === '#');\n\t\t\tif(callback) { callback.call(this, tmp, new_par, pos); }\n\t\t\t/**\n\t\t\t * triggered when a node is copied\n\t\t\t * @event\n\t\t\t * @name copy_node.jstree\n\t\t\t * @param {Object} node the copied node\n\t\t\t * @param {Object} original the original node\n\t\t\t * @param {String} parent the parent's ID\n\t\t\t * @param {Number} position the position of the node among the parent's children\n\t\t\t * @param {String} old_parent the old parent of the node\n\t\t\t * @param {Number} old_position the position of the original node\n\t\t\t * @param {Boolean} is_multi do the node and new parent belong to different instances\n\t\t\t * @param {jsTree} old_instance the instance the node came from\n\t\t\t * @param {jsTree} new_instance the instance of the new parent\n\t\t\t */\n\t\t\tthis.trigger('copy_node', { \"node\" : tmp, \"original\" : obj, \"parent\" : new_par.id, \"position\" : pos, \"old_parent\" : old_par, \"old_position\" : old_ins && old_ins._id && old_par && old_ins._model.data[old_par] && old_ins._model.data[old_par].children ? $.inArray(obj.id, old_ins._model.data[old_par].children) : -1,'is_multi' : (old_ins && old_ins._id && old_ins._id !== this._id), 'is_foreign' : (!old_ins || !old_ins._id), 'old_instance' : old_ins, 'new_instance' : this });\n\t\t\treturn tmp.id;\n\t\t},\n\t\t/**\n\t\t * cut a node (a later call to `paste(obj)` would move the node)\n\t\t * @name cut(obj)\n\t\t * @param  {mixed} obj multiple objects can be passed using an array\n\t\t * @trigger cut.jstree\n\t\t */\n\t\tcut : function (obj) {\n\t\t\tif(!obj) { obj = this._data.core.selected.concat(); }\n\t\t\tif(!$.isArray(obj)) { obj = [obj]; }\n\t\t\tif(!obj.length) { return false; }\n\t\t\tvar tmp = [], o, t1, t2;\n\t\t\tfor(t1 = 0, t2 = obj.length; t1 < t2; t1++) {\n\t\t\t\to = this.get_node(obj[t1]);\n\t\t\t\tif(o && o.id && o.id !== '#') { tmp.push(o); }\n\t\t\t}\n\t\t\tif(!tmp.length) { return false; }\n\t\t\tccp_node = tmp;\n\t\t\tccp_inst = this;\n\t\t\tccp_mode = 'move_node';\n\t\t\t/**\n\t\t\t * triggered when nodes are added to the buffer for moving\n\t\t\t * @event\n\t\t\t * @name cut.jstree\n\t\t\t * @param {Array} node\n\t\t\t */\n\t\t\tthis.trigger('cut', { \"node\" : obj });\n\t\t},\n\t\t/**\n\t\t * copy a node (a later call to `paste(obj)` would copy the node)\n\t\t * @name copy(obj)\n\t\t * @param  {mixed} obj multiple objects can be passed using an array\n\t\t * @trigger copy.jstre\n\t\t */\n\t\tcopy : function (obj) {\n\t\t\tif(!obj) { obj = this._data.core.selected.concat(); }\n\t\t\tif(!$.isArray(obj)) { obj = [obj]; }\n\t\t\tif(!obj.length) { return false; }\n\t\t\tvar tmp = [], o, t1, t2;\n\t\t\tfor(t1 = 0, t2 = obj.length; t1 < t2; t1++) {\n\t\t\t\to = this.get_node(obj[t1]);\n\t\t\t\tif(o && o.id && o.id !== '#') { tmp.push(o); }\n\t\t\t}\n\t\t\tif(!tmp.length) { return false; }\n\t\t\tccp_node = tmp;\n\t\t\tccp_inst = this;\n\t\t\tccp_mode = 'copy_node';\n\t\t\t/**\n\t\t\t * triggered when nodes are added to the buffer for copying\n\t\t\t * @event\n\t\t\t * @name copy.jstree\n\t\t\t * @param {Array} node\n\t\t\t */\n\t\t\tthis.trigger('copy', { \"node\" : obj });\n\t\t},\n\t\t/**\n\t\t * get the current buffer (any nodes that are waiting for a paste operation)\n\t\t * @name get_buffer()\n\t\t * @return {Object} an object consisting of `mode` (\"copy_node\" or \"move_node\"), `node` (an array of objects) and `inst` (the instance)\n\t\t */\n\t\tget_buffer : function () {\n\t\t\treturn { 'mode' : ccp_mode, 'node' : ccp_node, 'inst' : ccp_inst };\n\t\t},\n\t\t/**\n\t\t * check if there is something in the buffer to paste\n\t\t * @name can_paste()\n\t\t * @return {Boolean}\n\t\t */\n\t\tcan_paste : function () {\n\t\t\treturn ccp_mode !== false && ccp_node !== false; // && ccp_inst._model.data[ccp_node];\n\t\t},\n\t\t/**\n\t\t * copy or move the previously cut or copied nodes to a new parent\n\t\t * @name paste(obj [, pos])\n\t\t * @param  {mixed} obj the new parent\n\t\t * @param  {mixed} pos the position to insert at (besides integer, \"first\" and \"last\" are supported), defaults to integer `0`\n\t\t * @trigger paste.jstree\n\t\t */\n\t\tpaste : function (obj, pos) {\n\t\t\tobj = this.get_node(obj);\n\t\t\tif(!obj || !ccp_mode || !ccp_mode.match(/^(copy_node|move_node)$/) || !ccp_node) { return false; }\n\t\t\tif(this[ccp_mode](ccp_node, obj, pos)) {\n\t\t\t\t/**\n\t\t\t\t * triggered when paste is invoked\n\t\t\t\t * @event\n\t\t\t\t * @name paste.jstree\n\t\t\t\t * @param {String} parent the ID of the receiving node\n\t\t\t\t * @param {Array} node the nodes in the buffer\n\t\t\t\t * @param {String} mode the performed operation - \"copy_node\" or \"move_node\"\n\t\t\t\t */\n\t\t\t\tthis.trigger('paste', { \"parent\" : obj.id, \"node\" : ccp_node, \"mode\" : ccp_mode });\n\t\t\t}\n\t\t\tccp_node = false;\n\t\t\tccp_mode = false;\n\t\t\tccp_inst = false;\n\t\t},\n\t\t/**\n\t\t * put a node in edit mode (input field to rename the node)\n\t\t * @name edit(obj [, default_text])\n\t\t * @param  {mixed} obj\n\t\t * @param  {String} default_text the text to populate the input with (if omitted the node text value is used)\n\t\t */\n\t\tedit : function (obj, default_text) {\n\t\t\tobj = this.get_node(obj);\n\t\t\tif(!obj) { return false; }\n\t\t\tif(this.settings.core.check_callback === false) {\n\t\t\t\tthis._data.core.last_error = { 'error' : 'check', 'plugin' : 'core', 'id' : 'core_07', 'reason' : 'Could not edit node because of check_callback' };\n\t\t\t\tthis.settings.core.error.call(this, this._data.core.last_error);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tdefault_text = typeof default_text === 'string' ? default_text : obj.text;\n\t\t\tthis.set_text(obj, \"\");\n\t\t\tobj = this._open_to(obj);\n\n\t\t\tvar rtl = this._data.core.rtl,\n\t\t\t\tw  = this.element.width(),\n\t\t\t\ta  = obj.children('.jstree-anchor'),\n\t\t\t\ts  = $('<span>'),\n\t\t\t\t/*!\n\t\t\t\toi = obj.children(\"i:visible\"),\n\t\t\t\tai = a.children(\"i:visible\"),\n\t\t\t\tw1 = oi.width() * oi.length,\n\t\t\t\tw2 = ai.width() * ai.length,\n\t\t\t\t*/\n\t\t\t\tt  = default_text,\n\t\t\t\th1 = $(\"<\"+\"div />\", { css : { \"position\" : \"absolute\", \"top\" : \"-200px\", \"left\" : (rtl ? \"0px\" : \"-1000px\"), \"visibility\" : \"hidden\" } }).appendTo(\"body\"),\n\t\t\t\th2 = $(\"<\"+\"input />\", {\n\t\t\t\t\t\t\"value\" : t,\n\t\t\t\t\t\t\"class\" : \"jstree-rename-input\",\n\t\t\t\t\t\t// \"size\" : t.length,\n\t\t\t\t\t\t\"css\" : {\n\t\t\t\t\t\t\t\"padding\" : \"0\",\n\t\t\t\t\t\t\t\"border\" : \"1px solid silver\",\n\t\t\t\t\t\t\t\"box-sizing\" : \"border-box\",\n\t\t\t\t\t\t\t\"display\" : \"inline-block\",\n\t\t\t\t\t\t\t\"height\" : (this._data.core.li_height) + \"px\",\n\t\t\t\t\t\t\t\"lineHeight\" : (this._data.core.li_height) + \"px\",\n\t\t\t\t\t\t\t\"width\" : \"150px\" // will be set a bit further down\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"blur\" : $.proxy(function () {\n\t\t\t\t\t\t\tvar i = s.children(\".jstree-rename-input\"),\n\t\t\t\t\t\t\t\tv = i.val();\n\t\t\t\t\t\t\tif(v === \"\") { v = t; }\n\t\t\t\t\t\t\th1.remove();\n\t\t\t\t\t\t\ts.replaceWith(a);\n\t\t\t\t\t\t\ts.remove();\n\t\t\t\t\t\t\tthis.set_text(obj, t);\n\t\t\t\t\t\t\tif(this.rename_node(obj, $('<div></div>').text(v)[this.settings.core.force_text ? 'text' : 'html']()) === false) {\n\t\t\t\t\t\t\t\tthis.set_text(obj, t); // move this up? and fix #483\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}, this),\n\t\t\t\t\t\t\"keydown\" : function (event) {\n\t\t\t\t\t\t\tvar key = event.which;\n\t\t\t\t\t\t\tif(key === 27) {\n\t\t\t\t\t\t\t\tthis.value = t;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(key === 27 || key === 13 || key === 37 || key === 38 || key === 39 || key === 40 || key === 32) {\n\t\t\t\t\t\t\t\tevent.stopImmediatePropagation();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(key === 27 || key === 13) {\n\t\t\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t\t\t\tthis.blur();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"click\" : function (e) { e.stopImmediatePropagation(); },\n\t\t\t\t\t\t\"mousedown\" : function (e) { e.stopImmediatePropagation(); },\n\t\t\t\t\t\t\"keyup\" : function (event) {\n\t\t\t\t\t\t\th2.width(Math.min(h1.text(\"pW\" + this.value).width(),w));\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"keypress\" : function(event) {\n\t\t\t\t\t\t\tif(event.which === 13) { return false; }\n\t\t\t\t\t\t}\n\t\t\t\t\t}),\n\t\t\t\tfn = {\n\t\t\t\t\t\tfontFamily\t\t: a.css('fontFamily')\t\t|| '',\n\t\t\t\t\t\tfontSize\t\t: a.css('fontSize')\t\t\t|| '',\n\t\t\t\t\t\tfontWeight\t\t: a.css('fontWeight')\t\t|| '',\n\t\t\t\t\t\tfontStyle\t\t: a.css('fontStyle')\t\t|| '',\n\t\t\t\t\t\tfontStretch\t\t: a.css('fontStretch')\t\t|| '',\n\t\t\t\t\t\tfontVariant\t\t: a.css('fontVariant')\t\t|| '',\n\t\t\t\t\t\tletterSpacing\t: a.css('letterSpacing')\t|| '',\n\t\t\t\t\t\twordSpacing\t\t: a.css('wordSpacing')\t\t|| ''\n\t\t\t\t};\n\t\t\ts.attr('class', a.attr('class')).append(a.contents().clone()).append(h2);\n\t\t\ta.replaceWith(s);\n\t\t\th1.css(fn);\n\t\t\th2.css(fn).width(Math.min(h1.text(\"pW\" + h2[0].value).width(),w))[0].select();\n\t\t},\n\n\n\t\t/**\n\t\t * changes the theme\n\t\t * @name set_theme(theme_name [, theme_url])\n\t\t * @param {String} theme_name the name of the new theme to apply\n\t\t * @param {mixed} theme_url  the location of the CSS file for this theme. Omit or set to `false` if you manually included the file. Set to `true` to autoload from the `core.themes.dir` directory.\n\t\t * @trigger set_theme.jstree\n\t\t */\n\t\tset_theme : function (theme_name, theme_url) {\n\t\t\tif(!theme_name) { return false; }\n\t\t\tif(theme_url === true) {\n\t\t\t\tvar dir = this.settings.core.themes.dir;\n\t\t\t\tif(!dir) { dir = $.jstree.path + '/themes'; }\n\t\t\t\ttheme_url = dir + '/' + theme_name + '/style.css';\n\t\t\t}\n\t\t\tif(theme_url && $.inArray(theme_url, themes_loaded) === -1) {\n\t\t\t\t$('head').append('<'+'link rel=\"stylesheet\" href=\"' + theme_url + '\" type=\"text/css\" />');\n\t\t\t\tthemes_loaded.push(theme_url);\n\t\t\t}\n\t\t\tif(this._data.core.themes.name) {\n\t\t\t\tthis.element.removeClass('jstree-' + this._data.core.themes.name);\n\t\t\t}\n\t\t\tthis._data.core.themes.name = theme_name;\n\t\t\tthis.element.addClass('jstree-' + theme_name);\n\t\t\tthis.element[this.settings.core.themes.responsive ? 'addClass' : 'removeClass' ]('jstree-' + theme_name + '-responsive');\n\t\t\t/**\n\t\t\t * triggered when a theme is set\n\t\t\t * @event\n\t\t\t * @name set_theme.jstree\n\t\t\t * @param {String} theme the new theme\n\t\t\t */\n\t\t\tthis.trigger('set_theme', { 'theme' : theme_name });\n\t\t},\n\t\t/**\n\t\t * gets the name of the currently applied theme name\n\t\t * @name get_theme()\n\t\t * @return {String}\n\t\t */\n\t\tget_theme : function () { return this._data.core.themes.name; },\n\t\t/**\n\t\t * changes the theme variant (if the theme has variants)\n\t\t * @name set_theme_variant(variant_name)\n\t\t * @param {String|Boolean} variant_name the variant to apply (if `false` is used the current variant is removed)\n\t\t */\n\t\tset_theme_variant : function (variant_name) {\n\t\t\tif(this._data.core.themes.variant) {\n\t\t\t\tthis.element.removeClass('jstree-' + this._data.core.themes.name + '-' + this._data.core.themes.variant);\n\t\t\t}\n\t\t\tthis._data.core.themes.variant = variant_name;\n\t\t\tif(variant_name) {\n\t\t\t\tthis.element.addClass('jstree-' + this._data.core.themes.name + '-' + this._data.core.themes.variant);\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * gets the name of the currently applied theme variant\n\t\t * @name get_theme()\n\t\t * @return {String}\n\t\t */\n\t\tget_theme_variant : function () { return this._data.core.themes.variant; },\n\t\t/**\n\t\t * shows a striped background on the container (if the theme supports it)\n\t\t * @name show_stripes()\n\t\t */\n\t\tshow_stripes : function () { this._data.core.themes.stripes = true; this.get_container_ul().addClass(\"jstree-striped\"); },\n\t\t/**\n\t\t * hides the striped background on the container\n\t\t * @name hide_stripes()\n\t\t */\n\t\thide_stripes : function () { this._data.core.themes.stripes = false; this.get_container_ul().removeClass(\"jstree-striped\"); },\n\t\t/**\n\t\t * toggles the striped background on the container\n\t\t * @name toggle_stripes()\n\t\t */\n\t\ttoggle_stripes : function () { if(this._data.core.themes.stripes) { this.hide_stripes(); } else { this.show_stripes(); } },\n\t\t/**\n\t\t * shows the connecting dots (if the theme supports it)\n\t\t * @name show_dots()\n\t\t */\n\t\tshow_dots : function () { this._data.core.themes.dots = true; this.get_container_ul().removeClass(\"jstree-no-dots\"); },\n\t\t/**\n\t\t * hides the connecting dots\n\t\t * @name hide_dots()\n\t\t */\n\t\thide_dots : function () { this._data.core.themes.dots = false; this.get_container_ul().addClass(\"jstree-no-dots\"); },\n\t\t/**\n\t\t * toggles the connecting dots\n\t\t * @name toggle_dots()\n\t\t */\n\t\ttoggle_dots : function () { if(this._data.core.themes.dots) { this.hide_dots(); } else { this.show_dots(); } },\n\t\t/**\n\t\t * show the node icons\n\t\t * @name show_icons()\n\t\t */\n\t\tshow_icons : function () { this._data.core.themes.icons = true; this.get_container_ul().removeClass(\"jstree-no-icons\"); },\n\t\t/**\n\t\t * hide the node icons\n\t\t * @name hide_icons()\n\t\t */\n\t\thide_icons : function () { this._data.core.themes.icons = false; this.get_container_ul().addClass(\"jstree-no-icons\"); },\n\t\t/**\n\t\t * toggle the node icons\n\t\t * @name toggle_icons()\n\t\t */\n\t\ttoggle_icons : function () { if(this._data.core.themes.icons) { this.hide_icons(); } else { this.show_icons(); } },\n\t\t/**\n\t\t * set the node icon for a node\n\t\t * @name set_icon(obj, icon)\n\t\t * @param {mixed} obj\n\t\t * @param {String} icon the new icon - can be a path to an icon or a className, if using an image that is in the current directory use a `./` prefix, otherwise it will be detected as a class\n\t\t */\n\t\tset_icon : function (obj, icon) {\n\t\t\tvar t1, t2, dom, old;\n\t\t\tif($.isArray(obj)) {\n\t\t\t\tobj = obj.slice();\n\t\t\t\tfor(t1 = 0, t2 = obj.length; t1 < t2; t1++) {\n\t\t\t\t\tthis.set_icon(obj[t1], icon);\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tobj = this.get_node(obj);\n\t\t\tif(!obj || obj.id === '#') { return false; }\n\t\t\told = obj.icon;\n\t\t\tobj.icon = icon;\n\t\t\tdom = this.get_node(obj, true).children(\".jstree-anchor\").children(\".jstree-themeicon\");\n\t\t\tif(icon === false) {\n\t\t\t\tthis.hide_icon(obj);\n\t\t\t}\n\t\t\telse if(icon === true) {\n\t\t\t\tdom.removeClass('jstree-themeicon-custom ' + old).css(\"background\",\"\").removeAttr(\"rel\");\n\t\t\t}\n\t\t\telse if(icon.indexOf(\"/\") === -1 && icon.indexOf(\".\") === -1) {\n\t\t\t\tdom.removeClass(old).css(\"background\",\"\");\n\t\t\t\tdom.addClass(icon + ' jstree-themeicon-custom').attr(\"rel\",icon);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdom.removeClass(old).css(\"background\",\"\");\n\t\t\t\tdom.addClass('jstree-themeicon-custom').css(\"background\", \"url('\" + icon + \"') center center no-repeat\").attr(\"rel\",icon);\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\t\t/**\n\t\t * get the node icon for a node\n\t\t * @name get_icon(obj)\n\t\t * @param {mixed} obj\n\t\t * @return {String}\n\t\t */\n\t\tget_icon : function (obj) {\n\t\t\tobj = this.get_node(obj);\n\t\t\treturn (!obj || obj.id === '#') ? false : obj.icon;\n\t\t},\n\t\t/**\n\t\t * hide the icon on an individual node\n\t\t * @name hide_icon(obj)\n\t\t * @param {mixed} obj\n\t\t */\n\t\thide_icon : function (obj) {\n\t\t\tvar t1, t2;\n\t\t\tif($.isArray(obj)) {\n\t\t\t\tobj = obj.slice();\n\t\t\t\tfor(t1 = 0, t2 = obj.length; t1 < t2; t1++) {\n\t\t\t\t\tthis.hide_icon(obj[t1]);\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tobj = this.get_node(obj);\n\t\t\tif(!obj || obj === '#') { return false; }\n\t\t\tobj.icon = false;\n\t\t\tthis.get_node(obj, true).children(\".jstree-anchor\").children(\".jstree-themeicon\").addClass('jstree-themeicon-hidden');\n\t\t\treturn true;\n\t\t},\n\t\t/**\n\t\t * show the icon on an individual node\n\t\t * @name show_icon(obj)\n\t\t * @param {mixed} obj\n\t\t */\n\t\tshow_icon : function (obj) {\n\t\t\tvar t1, t2, dom;\n\t\t\tif($.isArray(obj)) {\n\t\t\t\tobj = obj.slice();\n\t\t\t\tfor(t1 = 0, t2 = obj.length; t1 < t2; t1++) {\n\t\t\t\t\tthis.show_icon(obj[t1]);\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tobj = this.get_node(obj);\n\t\t\tif(!obj || obj === '#') { return false; }\n\t\t\tdom = this.get_node(obj, true);\n\t\t\tobj.icon = dom.length ? dom.children(\".jstree-anchor\").children(\".jstree-themeicon\").attr('rel') : true;\n\t\t\tif(!obj.icon) { obj.icon = true; }\n\t\t\tdom.children(\".jstree-anchor\").children(\".jstree-themeicon\").removeClass('jstree-themeicon-hidden');\n\t\t\treturn true;\n\t\t}\n\t};\n\n\t// helpers\n\t$.vakata = {};\n\t// collect attributes\n\t$.vakata.attributes = function(node, with_values) {\n\t\tnode = $(node)[0];\n\t\tvar attr = with_values ? {} : [];\n\t\tif(node && node.attributes) {\n\t\t\t$.each(node.attributes, function (i, v) {\n\t\t\t\tif($.inArray(v.nodeName.toLowerCase(),['style','contenteditable','hasfocus','tabindex']) !== -1) { return; }\n\t\t\t\tif(v.nodeValue !== null && $.trim(v.nodeValue) !== '') {\n\t\t\t\t\tif(with_values) { attr[v.nodeName] = v.nodeValue; }\n\t\t\t\t\telse { attr.push(v.nodeName); }\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn attr;\n\t};\n\t$.vakata.array_unique = function(array) {\n\t\tvar a = [], i, j, l;\n\t\tfor(i = 0, l = array.length; i < l; i++) {\n\t\t\tfor(j = 0; j <= i; j++) {\n\t\t\t\tif(array[i] === array[j]) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(j === i) { a.push(array[i]); }\n\t\t}\n\t\treturn a;\n\t};\n\t// remove item from array\n\t$.vakata.array_remove = function(array, from, to) {\n\t\tvar rest = array.slice((to || from) + 1 || array.length);\n\t\tarray.length = from < 0 ? array.length + from : from;\n\t\tarray.push.apply(array, rest);\n\t\treturn array;\n\t};\n\t// remove item from array\n\t$.vakata.array_remove_item = function(array, item) {\n\t\tvar tmp = $.inArray(item, array);\n\t\treturn tmp !== -1 ? $.vakata.array_remove(array, tmp) : array;\n\t};\n\n/**\n * ### Checkbox plugin\n *\n * This plugin renders checkbox icons in front of each node, making multiple selection much easier. \n * It also supports tri-state behavior, meaning that if a node has a few of its children checked it will be rendered as undetermined, and state will be propagated up.\n */\n\n\tvar _i = document.createElement('I');\n\t_i.className = 'jstree-icon jstree-checkbox';\n\t/**\n\t * stores all defaults for the checkbox plugin\n\t * @name $.jstree.defaults.checkbox\n\t * @plugin checkbox\n\t */\n\t$.jstree.defaults.checkbox = {\n\t\t/**\n\t\t * a boolean indicating if checkboxes should be visible (can be changed at a later time using `show_checkboxes()` and `hide_checkboxes`). Defaults to `true`.\n\t\t * @name $.jstree.defaults.checkbox.visible\n\t\t * @plugin checkbox\n\t\t */\n\t\tvisible\t\t\t\t: true,\n\t\t/**\n\t\t * a boolean indicating if checkboxes should cascade down and have an undetermined state. Defaults to `true`.\n\t\t * @name $.jstree.defaults.checkbox.three_state\n\t\t * @plugin checkbox\n\t\t */\n\t\tthree_state\t\t\t: true,\n\t\t/**\n\t\t * a boolean indicating if clicking anywhere on the node should act as clicking on the checkbox. Defaults to `true`.\n\t\t * @name $.jstree.defaults.checkbox.whole_node\n\t\t * @plugin checkbox\n\t\t */\n\t\twhole_node\t\t\t: true,\n\t\t/**\n\t\t * a boolean indicating if the selected style of a node should be kept, or removed. Defaults to `true`.\n\t\t * @name $.jstree.defaults.checkbox.keep_selected_style\n\t\t * @plugin checkbox\n\t\t */\n\t\tkeep_selected_style\t: true,\n\t\t/**\n\t\t * This setting controls how cascading and undetermined nodes are applied. \n\t\t * If 'up' is in the string - cascading up is enabled, if 'down' is in the string - cascading down is enabled, if 'undetermined' is in the string - undetermined nodes will be used. \n\t\t * If `three_state` is set to `true` this setting is automatically set to 'up+down+undetermined'. Defaults to ''.\n\t\t * @name $.jstree.defaults.checkbox.cascade\n\t\t * @plugin checkbox\n\t\t */\n\t\tcascade\t\t\t\t: '',\n\t\t/**\n\t\t * This setting controls if checkbox are bound to the general tree selection or to an internal array maintained by the checkbox plugin. Defaults to `true`, only set to `false` if you know exactly what you are doing. \n\t\t * @name $.jstree.defaults.checkbox.tie_selection\n\t\t * @plugin checkbox\n\t\t */\n\t\ttie_selection\t\t: true\n\t};\n\t$.jstree.plugins.checkbox = function (options, parent) {\n\t\tthis.bind = function () {\n\t\t\tparent.bind.call(this);\n\t\t\tthis._data.checkbox.uto = false;\n\t\t\tthis._data.checkbox.selected = [];\n\t\t\tif(this.settings.checkbox.three_state) {\n\t\t\t\tthis.settings.checkbox.cascade = 'up+down+undetermined';\n\t\t\t}\n\t\t\tthis.element\n\t\t\t\t.on(\"init.jstree\", $.proxy(function () {\n\t\t\t\t\t\tthis._data.checkbox.visible = this.settings.checkbox.visible;\n\t\t\t\t\t\tif(!this.settings.checkbox.keep_selected_style) {\n\t\t\t\t\t\t\tthis.element.addClass('jstree-checkbox-no-clicked');\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(this.settings.checkbox.tie_selection) {\n\t\t\t\t\t\t\tthis.element.addClass('jstree-checkbox-selection');\n\t\t\t\t\t\t}\n\t\t\t\t\t}, this))\n\t\t\t\t.on(\"loading.jstree\", $.proxy(function () {\n\t\t\t\t\t\tthis[ this._data.checkbox.visible ? 'show_checkboxes' : 'hide_checkboxes' ]();\n\t\t\t\t\t}, this));\n\t\t\tif(this.settings.checkbox.cascade.indexOf('undetermined') !== -1) {\n\t\t\t\tthis.element\n\t\t\t\t\t.on('changed.jstree uncheck_node.jstree check_node.jstree uncheck_all.jstree check_all.jstree move_node.jstree copy_node.jstree redraw.jstree open_node.jstree', $.proxy(function () {\n\t\t\t\t\t\t\t// only if undetermined is in setting\n\t\t\t\t\t\t\tif(this._data.checkbox.uto) { clearTimeout(this._data.checkbox.uto); }\n\t\t\t\t\t\t\tthis._data.checkbox.uto = setTimeout($.proxy(this._undetermined, this), 50);\n\t\t\t\t\t\t}, this));\n\t\t\t}\n\t\t\tif(!this.settings.checkbox.tie_selection) {\n\t\t\t\tthis.element\n\t\t\t\t\t.on('model.jstree', $.proxy(function (e, data) {\n\t\t\t\t\t\tvar m = this._model.data,\n\t\t\t\t\t\t\tp = m[data.parent],\n\t\t\t\t\t\t\tdpc = data.nodes,\n\t\t\t\t\t\t\ti, j;\n\t\t\t\t\t\tfor(i = 0, j = dpc.length; i < j; i++) {\n\t\t\t\t\t\t\tm[dpc[i]].state.checked = (m[dpc[i]].original && m[dpc[i]].original.state && m[dpc[i]].original.state.checked);\n\t\t\t\t\t\t\tif(m[dpc[i]].state.checked) {\n\t\t\t\t\t\t\t\tthis._data.checkbox.selected.push(dpc[i]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}, this));\n\t\t\t}\n\t\t\tif(this.settings.checkbox.cascade.indexOf('up') !== -1 || this.settings.checkbox.cascade.indexOf('down') !== -1) {\n\t\t\t\tthis.element\n\t\t\t\t\t.on('model.jstree', $.proxy(function (e, data) {\n\t\t\t\t\t\t\tvar m = this._model.data,\n\t\t\t\t\t\t\t\tp = m[data.parent],\n\t\t\t\t\t\t\t\tdpc = data.nodes,\n\t\t\t\t\t\t\t\tchd = [],\n\t\t\t\t\t\t\t\tc, i, j, k, l, tmp, s = this.settings.checkbox.cascade, t = this.settings.checkbox.tie_selection;\n\n\t\t\t\t\t\t\tif(s.indexOf('down') !== -1) {\n\t\t\t\t\t\t\t\t// apply down\n\t\t\t\t\t\t\t\tif(p.state[ t ? 'selected' : 'checked' ]) {\n\t\t\t\t\t\t\t\t\tfor(i = 0, j = dpc.length; i < j; i++) {\n\t\t\t\t\t\t\t\t\t\tm[dpc[i]].state[ t ? 'selected' : 'checked' ] = true;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tthis._data[ t ? 'core' : 'checkbox' ].selected = this._data[ t ? 'core' : 'checkbox' ].selected.concat(dpc);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tfor(i = 0, j = dpc.length; i < j; i++) {\n\t\t\t\t\t\t\t\t\t\tif(m[dpc[i]].state[ t ? 'selected' : 'checked' ]) {\n\t\t\t\t\t\t\t\t\t\t\tfor(k = 0, l = m[dpc[i]].children_d.length; k < l; k++) {\n\t\t\t\t\t\t\t\t\t\t\t\tm[m[dpc[i]].children_d[k]].state[ t ? 'selected' : 'checked' ] = true;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tthis._data[ t ? 'core' : 'checkbox' ].selected = this._data[ t ? 'core' : 'checkbox' ].selected.concat(m[dpc[i]].children_d);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif(s.indexOf('up') !== -1) {\n\t\t\t\t\t\t\t\t// apply up\n\t\t\t\t\t\t\t\tfor(i = 0, j = p.children_d.length; i < j; i++) {\n\t\t\t\t\t\t\t\t\tif(!m[p.children_d[i]].children.length) {\n\t\t\t\t\t\t\t\t\t\tchd.push(m[p.children_d[i]].parent);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tchd = $.vakata.array_unique(chd);\n\t\t\t\t\t\t\t\tfor(k = 0, l = chd.length; k < l; k++) {\n\t\t\t\t\t\t\t\t\tp = m[chd[k]];\n\t\t\t\t\t\t\t\t\twhile(p && p.id !== '#') {\n\t\t\t\t\t\t\t\t\t\tc = 0;\n\t\t\t\t\t\t\t\t\t\tfor(i = 0, j = p.children.length; i < j; i++) {\n\t\t\t\t\t\t\t\t\t\t\tc += m[p.children[i]].state[ t ? 'selected' : 'checked' ];\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif(c === j) {\n\t\t\t\t\t\t\t\t\t\t\tp.state[ t ? 'selected' : 'checked' ] = true;\n\t\t\t\t\t\t\t\t\t\t\tthis._data[ t ? 'core' : 'checkbox' ].selected.push(p.id);\n\t\t\t\t\t\t\t\t\t\t\ttmp = this.get_node(p, true);\n\t\t\t\t\t\t\t\t\t\t\tif(tmp && tmp.length) {\n\t\t\t\t\t\t\t\t\t\t\t\ttmp.children('.jstree-anchor').addClass( t ? 'jstree-clicked' : 'jstree-checked');\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tp = this.get_node(p.parent);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tthis._data[ t ? 'core' : 'checkbox' ].selected = $.vakata.array_unique(this._data[ t ? 'core' : 'checkbox' ].selected);\n\t\t\t\t\t\t}, this))\n\t\t\t\t\t.on(this.settings.checkbox.tie_selection ? 'select_node.jstree' : 'check_node.jstree', $.proxy(function (e, data) {\n\t\t\t\t\t\t\tvar obj = data.node,\n\t\t\t\t\t\t\t\tm = this._model.data,\n\t\t\t\t\t\t\t\tpar = this.get_node(obj.parent),\n\t\t\t\t\t\t\t\tdom = this.get_node(obj, true),\n\t\t\t\t\t\t\t\ti, j, c, tmp, s = this.settings.checkbox.cascade, t = this.settings.checkbox.tie_selection;\n\n\t\t\t\t\t\t\t// apply down\n\t\t\t\t\t\t\tif(s.indexOf('down') !== -1) {\n\t\t\t\t\t\t\t\tthis._data[ t ? 'core' : 'checkbox' ].selected = $.vakata.array_unique(this._data[ t ? 'core' : 'checkbox' ].selected.concat(obj.children_d));\n\t\t\t\t\t\t\t\tfor(i = 0, j = obj.children_d.length; i < j; i++) {\n\t\t\t\t\t\t\t\t\ttmp = m[obj.children_d[i]];\n\t\t\t\t\t\t\t\t\ttmp.state[ t ? 'selected' : 'checked' ] = true;\n\t\t\t\t\t\t\t\t\tif(tmp && tmp.original && tmp.original.state && tmp.original.state.undetermined) {\n\t\t\t\t\t\t\t\t\t\ttmp.original.state.undetermined = false;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// apply up\n\t\t\t\t\t\t\tif(s.indexOf('up') !== -1) {\n\t\t\t\t\t\t\t\twhile(par && par.id !== '#') {\n\t\t\t\t\t\t\t\t\tc = 0;\n\t\t\t\t\t\t\t\t\tfor(i = 0, j = par.children.length; i < j; i++) {\n\t\t\t\t\t\t\t\t\t\tc += m[par.children[i]].state[ t ? 'selected' : 'checked' ];\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif(c === j) {\n\t\t\t\t\t\t\t\t\t\tpar.state[ t ? 'selected' : 'checked' ] = true;\n\t\t\t\t\t\t\t\t\t\tthis._data[ t ? 'core' : 'checkbox' ].selected.push(par.id);\n\t\t\t\t\t\t\t\t\t\ttmp = this.get_node(par, true);\n\t\t\t\t\t\t\t\t\t\tif(tmp && tmp.length) {\n\t\t\t\t\t\t\t\t\t\t\ttmp.children('.jstree-anchor').addClass(t ? 'jstree-clicked' : 'jstree-checked');\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tpar = this.get_node(par.parent);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// apply down (process .children separately?)\n\t\t\t\t\t\t\tif(s.indexOf('down') !== -1 && dom.length) {\n\t\t\t\t\t\t\t\tdom.find('.jstree-anchor').addClass(t ? 'jstree-clicked' : 'jstree-checked');\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}, this))\n\t\t\t\t\t.on(this.settings.checkbox.tie_selection ? 'deselect_all.jstree' : 'uncheck_all.jstree', $.proxy(function (e, data) {\n\t\t\t\t\t\t\tvar obj = this.get_node('#'),\n\t\t\t\t\t\t\t\tm = this._model.data,\n\t\t\t\t\t\t\t\ti, j, tmp;\n\t\t\t\t\t\t\tfor(i = 0, j = obj.children_d.length; i < j; i++) {\n\t\t\t\t\t\t\t\ttmp = m[obj.children_d[i]];\n\t\t\t\t\t\t\t\tif(tmp && tmp.original && tmp.original.state && tmp.original.state.undetermined) {\n\t\t\t\t\t\t\t\t\ttmp.original.state.undetermined = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}, this))\n\t\t\t\t\t.on(this.settings.checkbox.tie_selection ? 'deselect_node.jstree' : 'uncheck_node.jstree', $.proxy(function (e, data) {\n\t\t\t\t\t\t\tvar obj = data.node,\n\t\t\t\t\t\t\t\tdom = this.get_node(obj, true),\n\t\t\t\t\t\t\t\ti, j, tmp, s = this.settings.checkbox.cascade, t = this.settings.checkbox.tie_selection;\n\t\t\t\t\t\t\tif(obj && obj.original && obj.original.state && obj.original.state.undetermined) {\n\t\t\t\t\t\t\t\tobj.original.state.undetermined = false;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// apply down\n\t\t\t\t\t\t\tif(s.indexOf('down') !== -1) {\n\t\t\t\t\t\t\t\tfor(i = 0, j = obj.children_d.length; i < j; i++) {\n\t\t\t\t\t\t\t\t\ttmp = this._model.data[obj.children_d[i]];\n\t\t\t\t\t\t\t\t\ttmp.state[ t ? 'selected' : 'checked' ] = false;\n\t\t\t\t\t\t\t\t\tif(tmp && tmp.original && tmp.original.state && tmp.original.state.undetermined) {\n\t\t\t\t\t\t\t\t\t\ttmp.original.state.undetermined = false;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// apply up\n\t\t\t\t\t\t\tif(s.indexOf('up') !== -1) {\n\t\t\t\t\t\t\t\tfor(i = 0, j = obj.parents.length; i < j; i++) {\n\t\t\t\t\t\t\t\t\ttmp = this._model.data[obj.parents[i]];\n\t\t\t\t\t\t\t\t\ttmp.state[ t ? 'selected' : 'checked' ] = false;\n\t\t\t\t\t\t\t\t\tif(tmp && tmp.original && tmp.original.state && tmp.original.state.undetermined) {\n\t\t\t\t\t\t\t\t\t\ttmp.original.state.undetermined = false;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\ttmp = this.get_node(obj.parents[i], true);\n\t\t\t\t\t\t\t\t\tif(tmp && tmp.length) {\n\t\t\t\t\t\t\t\t\t\ttmp.children('.jstree-anchor').removeClass(t ? 'jstree-clicked' : 'jstree-checked');\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttmp = [];\n\t\t\t\t\t\t\tfor(i = 0, j = this._data[ t ? 'core' : 'checkbox' ].selected.length; i < j; i++) {\n\t\t\t\t\t\t\t\t// apply down + apply up\n\t\t\t\t\t\t\t\tif(\n\t\t\t\t\t\t\t\t\t(s.indexOf('down') === -1 || $.inArray(this._data[ t ? 'core' : 'checkbox' ].selected[i], obj.children_d) === -1) &&\n\t\t\t\t\t\t\t\t\t(s.indexOf('up') === -1 || $.inArray(this._data[ t ? 'core' : 'checkbox' ].selected[i], obj.parents) === -1)\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\ttmp.push(this._data[ t ? 'core' : 'checkbox' ].selected[i]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tthis._data[ t ? 'core' : 'checkbox' ].selected = $.vakata.array_unique(tmp);\n\n\t\t\t\t\t\t\t// apply down (process .children separately?)\n\t\t\t\t\t\t\tif(s.indexOf('down') !== -1 && dom.length) {\n\t\t\t\t\t\t\t\tdom.find('.jstree-anchor').removeClass(t ? 'jstree-clicked' : 'jstree-checked');\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}, this));\n\t\t\t}\n\t\t\tif(this.settings.checkbox.cascade.indexOf('up') !== -1) {\n\t\t\t\tthis.element\n\t\t\t\t\t.on('delete_node.jstree', $.proxy(function (e, data) {\n\t\t\t\t\t\t\t// apply up (whole handler)\n\t\t\t\t\t\t\tvar p = this.get_node(data.parent),\n\t\t\t\t\t\t\t\tm = this._model.data,\n\t\t\t\t\t\t\t\ti, j, c, tmp, t = this.settings.checkbox.tie_selection;\n\t\t\t\t\t\t\twhile(p && p.id !== '#') {\n\t\t\t\t\t\t\t\tc = 0;\n\t\t\t\t\t\t\t\tfor(i = 0, j = p.children.length; i < j; i++) {\n\t\t\t\t\t\t\t\t\tc += m[p.children[i]].state[ t ? 'selected' : 'checked' ];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(c === j) {\n\t\t\t\t\t\t\t\t\tp.state[ t ? 'selected' : 'checked' ] = true;\n\t\t\t\t\t\t\t\t\tthis._data[ t ? 'core' : 'checkbox' ].selected.push(p.id);\n\t\t\t\t\t\t\t\t\ttmp = this.get_node(p, true);\n\t\t\t\t\t\t\t\t\tif(tmp && tmp.length) {\n\t\t\t\t\t\t\t\t\t\ttmp.children('.jstree-anchor').addClass(t ? 'jstree-clicked' : 'jstree-checked');\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tp = this.get_node(p.parent);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}, this))\n\t\t\t\t\t.on('move_node.jstree', $.proxy(function (e, data) {\n\t\t\t\t\t\t\t// apply up (whole handler)\n\t\t\t\t\t\t\tvar is_multi = data.is_multi,\n\t\t\t\t\t\t\t\told_par = data.old_parent,\n\t\t\t\t\t\t\t\tnew_par = this.get_node(data.parent),\n\t\t\t\t\t\t\t\tm = this._model.data,\n\t\t\t\t\t\t\t\tp, c, i, j, tmp, t = this.settings.checkbox.tie_selection;\n\t\t\t\t\t\t\tif(!is_multi) {\n\t\t\t\t\t\t\t\tp = this.get_node(old_par);\n\t\t\t\t\t\t\t\twhile(p && p.id !== '#') {\n\t\t\t\t\t\t\t\t\tc = 0;\n\t\t\t\t\t\t\t\t\tfor(i = 0, j = p.children.length; i < j; i++) {\n\t\t\t\t\t\t\t\t\t\tc += m[p.children[i]].state[ t ? 'selected' : 'checked' ];\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif(c === j) {\n\t\t\t\t\t\t\t\t\t\tp.state[ t ? 'selected' : 'checked' ] = true;\n\t\t\t\t\t\t\t\t\t\tthis._data[ t ? 'core' : 'checkbox' ].selected.push(p.id);\n\t\t\t\t\t\t\t\t\t\ttmp = this.get_node(p, true);\n\t\t\t\t\t\t\t\t\t\tif(tmp && tmp.length) {\n\t\t\t\t\t\t\t\t\t\t\ttmp.children('.jstree-anchor').addClass(t ? 'jstree-clicked' : 'jstree-checked');\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tp = this.get_node(p.parent);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tp = new_par;\n\t\t\t\t\t\t\twhile(p && p.id !== '#') {\n\t\t\t\t\t\t\t\tc = 0;\n\t\t\t\t\t\t\t\tfor(i = 0, j = p.children.length; i < j; i++) {\n\t\t\t\t\t\t\t\t\tc += m[p.children[i]].state[ t ? 'selected' : 'checked' ];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(c === j) {\n\t\t\t\t\t\t\t\t\tif(!p.state[ t ? 'selected' : 'checked' ]) {\n\t\t\t\t\t\t\t\t\t\tp.state[ t ? 'selected' : 'checked' ] = true;\n\t\t\t\t\t\t\t\t\t\tthis._data[ t ? 'core' : 'checkbox' ].selected.push(p.id);\n\t\t\t\t\t\t\t\t\t\ttmp = this.get_node(p, true);\n\t\t\t\t\t\t\t\t\t\tif(tmp && tmp.length) {\n\t\t\t\t\t\t\t\t\t\t\ttmp.children('.jstree-anchor').addClass(t ? 'jstree-clicked' : 'jstree-checked');\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tif(p.state[ t ? 'selected' : 'checked' ]) {\n\t\t\t\t\t\t\t\t\t\tp.state[ t ? 'selected' : 'checked' ] = false;\n\t\t\t\t\t\t\t\t\t\tthis._data[ t ? 'core' : 'checkbox' ].selected = $.vakata.array_remove_item(this._data[ t ? 'core' : 'checkbox' ].selected, p.id);\n\t\t\t\t\t\t\t\t\t\ttmp = this.get_node(p, true);\n\t\t\t\t\t\t\t\t\t\tif(tmp && tmp.length) {\n\t\t\t\t\t\t\t\t\t\t\ttmp.children('.jstree-anchor').removeClass(t ? 'jstree-clicked' : 'jstree-checked');\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tp = this.get_node(p.parent);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}, this));\n\t\t\t}\n\t\t};\n\t\t/**\n\t\t * set the undetermined state where and if necessary. Used internally.\n\t\t * @private\n\t\t * @name _undetermined()\n\t\t * @plugin checkbox\n\t\t */\n\t\tthis._undetermined = function () {\n\t\t\tvar i, j, m = this._model.data, t = this.settings.checkbox.tie_selection, s = this._data[ t ? 'core' : 'checkbox' ].selected, p = [], tt = this;\n\t\t\tfor(i = 0, j = s.length; i < j; i++) {\n\t\t\t\tif(m[s[i]] && m[s[i]].parents) {\n\t\t\t\t\tp = p.concat(m[s[i]].parents);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// attempt for server side undetermined state\n\t\t\tthis.element.find('.jstree-closed').not(':has(.jstree-children)')\n\t\t\t\t.each(function () {\n\t\t\t\t\tvar tmp = tt.get_node(this), tmp2;\n\t\t\t\t\tif(!tmp.state.loaded) {\n\t\t\t\t\t\tif(tmp.original && tmp.original.state && tmp.original.state.undetermined && tmp.original.state.undetermined === true) {\n\t\t\t\t\t\t\tp.push(tmp.id);\n\t\t\t\t\t\t\tp = p.concat(tmp.parents);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tfor(i = 0, j = tmp.children_d.length; i < j; i++) {\n\t\t\t\t\t\t\ttmp2 = m[tmp.children_d[i]];\n\t\t\t\t\t\t\tif(!tmp2.state.loaded && tmp2.original && tmp2.original.state && tmp2.original.state.undetermined && tmp2.original.state.undetermined === true) {\n\t\t\t\t\t\t\t\tp.push(tmp2.id);\n\t\t\t\t\t\t\t\tp = p.concat(tmp2.parents);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\tp = $.vakata.array_unique(p);\n\t\t\tp = $.vakata.array_remove_item(p,'#');\n\n\t\t\tthis.element.find('.jstree-undetermined').removeClass('jstree-undetermined');\n\t\t\tfor(i = 0, j = p.length; i < j; i++) {\n\t\t\t\tif(!m[p[i]].state[ t ? 'selected' : 'checked' ]) {\n\t\t\t\t\ts = this.get_node(p[i], true);\n\t\t\t\t\tif(s && s.length) {\n\t\t\t\t\t\ts.children('.jstree-anchor').children('.jstree-checkbox').addClass('jstree-undetermined');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tthis.redraw_node = function(obj, deep, is_callback) {\n\t\t\tobj = parent.redraw_node.call(this, obj, deep, is_callback);\n\t\t\tif(obj) {\n\t\t\t\tvar i, j, tmp = null;\n\t\t\t\tfor(i = 0, j = obj.childNodes.length; i < j; i++) {\n\t\t\t\t\tif(obj.childNodes[i] && obj.childNodes[i].className && obj.childNodes[i].className.indexOf(\"jstree-anchor\") !== -1) {\n\t\t\t\t\t\ttmp = obj.childNodes[i];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(tmp) {\n\t\t\t\t\tif(!this.settings.checkbox.tie_selection && this._model.data[obj.id].state.checked) { tmp.className += ' jstree-checked'; }\n\t\t\t\t\ttmp.insertBefore(_i.cloneNode(false), tmp.childNodes[0]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!is_callback && this.settings.checkbox.cascade.indexOf('undetermined') !== -1) {\n\t\t\t\tif(this._data.checkbox.uto) { clearTimeout(this._data.checkbox.uto); }\n\t\t\t\tthis._data.checkbox.uto = setTimeout($.proxy(this._undetermined, this), 50);\n\t\t\t}\n\t\t\treturn obj;\n\t\t};\n\t\t/**\n\t\t * show the node checkbox icons\n\t\t * @name show_checkboxes()\n\t\t * @plugin checkbox\n\t\t */\n\t\tthis.show_checkboxes = function () { this._data.core.themes.checkboxes = true; this.get_container_ul().removeClass(\"jstree-no-checkboxes\"); };\n\t\t/**\n\t\t * hide the node checkbox icons\n\t\t * @name hide_checkboxes()\n\t\t * @plugin checkbox\n\t\t */\n\t\tthis.hide_checkboxes = function () { this._data.core.themes.checkboxes = false; this.get_container_ul().addClass(\"jstree-no-checkboxes\"); };\n\t\t/**\n\t\t * toggle the node icons\n\t\t * @name toggle_checkboxes()\n\t\t * @plugin checkbox\n\t\t */\n\t\tthis.toggle_checkboxes = function () { if(this._data.core.themes.checkboxes) { this.hide_checkboxes(); } else { this.show_checkboxes(); } };\n\t\t/**\n\t\t * checks if a node is in an undetermined state\n\t\t * @name is_undetermined(obj)\n\t\t * @param  {mixed} obj\n\t\t * @return {Boolean}\n\t\t */\n\t\tthis.is_undetermined = function (obj) {\n\t\t\tobj = this.get_node(obj);\n\t\t\tvar s = this.settings.checkbox.cascade, i, j, t = this.settings.checkbox.tie_selection, d = this._data[ t ? 'core' : 'checkbox' ].selected, m = this._model.data;\n\t\t\tif(!obj || obj.state[ t ? 'selected' : 'checked' ] === true || s.indexOf('undetermined') === -1 || (s.indexOf('down') === -1 && s.indexOf('up') === -1)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif(!obj.state.loaded && obj.original.state.undetermined === true) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tfor(i = 0, j = obj.children_d.length; i < j; i++) {\n\t\t\t\tif($.inArray(obj.children_d[i], d) !== -1 || (!m[obj.children_d[i]].state.loaded && m[obj.children_d[i]].original.state.undetermined)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\n\t\tthis.activate_node = function (obj, e) {\n\t\t\tif(this.settings.checkbox.tie_selection && (this.settings.checkbox.whole_node || $(e.target).hasClass('jstree-checkbox'))) {\n\t\t\t\te.ctrlKey = true;\n\t\t\t}\n\t\t\tif(this.settings.checkbox.tie_selection || (!this.settings.checkbox.whole_node && !$(e.target).hasClass('jstree-checkbox'))) {\n\t\t\t\treturn parent.activate_node.call(this, obj, e);\n\t\t\t}\n\t\t\tif(this.is_checked(obj)) {\n\t\t\t\tthis.uncheck_node(obj, e);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.check_node(obj, e);\n\t\t\t}\n\t\t\tthis.trigger('activate_node', { 'node' : this.get_node(obj) });\n\t\t};\n\n\t\t/**\n\t\t * check a node (only if tie_selection in checkbox settings is false, otherwise select_node will be called internally)\n\t\t * @name check_node(obj)\n\t\t * @param {mixed} obj an array can be used to check multiple nodes\n\t\t * @trigger check_node.jstree\n\t\t * @plugin checkbox\n\t\t */\n\t\tthis.check_node = function (obj, e) {\n\t\t\tif(this.settings.checkbox.tie_selection) { return this.select_node(obj, false, true, e); }\n\t\t\tvar dom, t1, t2, th;\n\t\t\tif($.isArray(obj)) {\n\t\t\t\tobj = obj.slice();\n\t\t\t\tfor(t1 = 0, t2 = obj.length; t1 < t2; t1++) {\n\t\t\t\t\tthis.check_node(obj[t1], e);\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tobj = this.get_node(obj);\n\t\t\tif(!obj || obj.id === '#') {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tdom = this.get_node(obj, true);\n\t\t\tif(!obj.state.checked) {\n\t\t\t\tobj.state.checked = true;\n\t\t\t\tthis._data.checkbox.selected.push(obj.id);\n\t\t\t\tif(dom && dom.length) {\n\t\t\t\t\tdom.children('.jstree-anchor').addClass('jstree-checked');\n\t\t\t\t}\n\t\t\t\t/**\n\t\t\t\t * triggered when an node is checked (only if tie_selection in checkbox settings is false)\n\t\t\t\t * @event\n\t\t\t\t * @name check_node.jstree\n\t\t\t\t * @param {Object} node\n\t\t\t\t * @param {Array} selected the current selection\n\t\t\t\t * @param {Object} event the event (if any) that triggered this check_node\n\t\t\t\t * @plugin checkbox\n\t\t\t\t */\n\t\t\t\tthis.trigger('check_node', { 'node' : obj, 'selected' : this._data.checkbox.selected, 'event' : e });\n\t\t\t}\n\t\t};\n\t\t/**\n\t\t * uncheck a node (only if tie_selection in checkbox settings is false, otherwise deselect_node will be called internally)\n\t\t * @name deselect_node(obj)\n\t\t * @param {mixed} obj an array can be used to deselect multiple nodes\n\t\t * @trigger uncheck_node.jstree\n\t\t * @plugin checkbox\n\t\t */\n\t\tthis.uncheck_node = function (obj, e) {\n\t\t\tif(this.settings.checkbox.tie_selection) { return this.deselect_node(obj, false, e); }\n\t\t\tvar t1, t2, dom;\n\t\t\tif($.isArray(obj)) {\n\t\t\t\tobj = obj.slice();\n\t\t\t\tfor(t1 = 0, t2 = obj.length; t1 < t2; t1++) {\n\t\t\t\t\tthis.uncheck_node(obj[t1], e);\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tobj = this.get_node(obj);\n\t\t\tif(!obj || obj.id === '#') {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tdom = this.get_node(obj, true);\n\t\t\tif(obj.state.checked) {\n\t\t\t\tobj.state.checked = false;\n\t\t\t\tthis._data.checkbox.selected = $.vakata.array_remove_item(this._data.checkbox.selected, obj.id);\n\t\t\t\tif(dom.length) {\n\t\t\t\t\tdom.children('.jstree-anchor').removeClass('jstree-checked');\n\t\t\t\t}\n\t\t\t\t/**\n\t\t\t\t * triggered when an node is unchecked (only if tie_selection in checkbox settings is false)\n\t\t\t\t * @event\n\t\t\t\t * @name uncheck_node.jstree\n\t\t\t\t * @param {Object} node\n\t\t\t\t * @param {Array} selected the current selection\n\t\t\t\t * @param {Object} event the event (if any) that triggered this uncheck_node\n\t\t\t\t * @plugin checkbox\n\t\t\t\t */\n\t\t\t\tthis.trigger('uncheck_node', { 'node' : obj, 'selected' : this._data.checkbox.selected, 'event' : e });\n\t\t\t}\n\t\t};\n\t\t/**\n\t\t * checks all nodes in the tree (only if tie_selection in checkbox settings is false, otherwise select_all will be called internally)\n\t\t * @name check_all()\n\t\t * @trigger check_all.jstree, changed.jstree\n\t\t * @plugin checkbox\n\t\t */\n\t\tthis.check_all = function () {\n\t\t\tif(this.settings.checkbox.tie_selection) { return this.select_all(); }\n\t\t\tvar tmp = this._data.checkbox.selected.concat([]), i, j;\n\t\t\tthis._data.checkbox.selected = this._model.data['#'].children_d.concat();\n\t\t\tfor(i = 0, j = this._data.checkbox.selected.length; i < j; i++) {\n\t\t\t\tif(this._model.data[this._data.checkbox.selected[i]]) {\n\t\t\t\t\tthis._model.data[this._data.checkbox.selected[i]].state.checked = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.redraw(true);\n\t\t\t/**\n\t\t\t * triggered when all nodes are checked (only if tie_selection in checkbox settings is false)\n\t\t\t * @event\n\t\t\t * @name check_all.jstree\n\t\t\t * @param {Array} selected the current selection\n\t\t\t * @plugin checkbox\n\t\t\t */\n\t\t\tthis.trigger('check_all', { 'selected' : this._data.checkbox.selected });\n\t\t};\n\t\t/**\n\t\t * uncheck all checked nodes (only if tie_selection in checkbox settings is false, otherwise deselect_all will be called internally)\n\t\t * @name uncheck_all()\n\t\t * @trigger uncheck_all.jstree\n\t\t * @plugin checkbox\n\t\t */\n\t\tthis.uncheck_all = function () {\n\t\t\tif(this.settings.checkbox.tie_selection) { return this.deselect_all(); }\n\t\t\tvar tmp = this._data.checkbox.selected.concat([]), i, j;\n\t\t\tfor(i = 0, j = this._data.checkbox.selected.length; i < j; i++) {\n\t\t\t\tif(this._model.data[this._data.checkbox.selected[i]]) {\n\t\t\t\t\tthis._model.data[this._data.checkbox.selected[i]].state.checked = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._data.checkbox.selected = [];\n\t\t\tthis.element.find('.jstree-checked').removeClass('jstree-checked');\n\t\t\t/**\n\t\t\t * triggered when all nodes are unchecked (only if tie_selection in checkbox settings is false)\n\t\t\t * @event\n\t\t\t * @name uncheck_all.jstree\n\t\t\t * @param {Object} node the previous selection\n\t\t\t * @param {Array} selected the current selection\n\t\t\t * @plugin checkbox\n\t\t\t */\n\t\t\tthis.trigger('uncheck_all', { 'selected' : this._data.checkbox.selected, 'node' : tmp });\n\t\t};\n\t\t/**\n\t\t * checks if a node is checked (if tie_selection is on in the settings this function will return the same as is_selected)\n\t\t * @name is_checked(obj)\n\t\t * @param  {mixed}  obj\n\t\t * @return {Boolean}\n\t\t * @plugin checkbox\n\t\t */\n\t\tthis.is_checked = function (obj) {\n\t\t\tif(this.settings.checkbox.tie_selection) { return this.is_selected(obj); }\n\t\t\tobj = this.get_node(obj);\n\t\t\tif(!obj || obj.id === '#') { return false; }\n\t\t\treturn obj.state.checked;\n\t\t};\n\t\t/**\n\t\t * get an array of all checked nodes (if tie_selection is on in the settings this function will return the same as get_selected)\n\t\t * @name get_checked([full])\n\t\t * @param  {mixed}  full if set to `true` the returned array will consist of the full node objects, otherwise - only IDs will be returned\n\t\t * @return {Array}\n\t\t * @plugin checkbox\n\t\t */\n\t\tthis.get_checked = function (full) {\n\t\t\tif(this.settings.checkbox.tie_selection) { return this.get_selected(full); }\n\t\t\treturn full ? $.map(this._data.checkbox.selected, $.proxy(function (i) { return this.get_node(i); }, this)) : this._data.checkbox.selected;\n\t\t};\n\t\t/**\n\t\t * get an array of all top level checked nodes (ignoring children of checked nodes) (if tie_selection is on in the settings this function will return the same as get_top_selected)\n\t\t * @name get_top_checked([full])\n\t\t * @param  {mixed}  full if set to `true` the returned array will consist of the full node objects, otherwise - only IDs will be returned\n\t\t * @return {Array}\n\t\t * @plugin checkbox\n\t\t */\n\t\tthis.get_top_checked = function (full) {\n\t\t\tif(this.settings.checkbox.tie_selection) { return this.get_top_selected(full); }\n\t\t\tvar tmp = this.get_checked(true),\n\t\t\t\tobj = {}, i, j, k, l;\n\t\t\tfor(i = 0, j = tmp.length; i < j; i++) {\n\t\t\t\tobj[tmp[i].id] = tmp[i];\n\t\t\t}\n\t\t\tfor(i = 0, j = tmp.length; i < j; i++) {\n\t\t\t\tfor(k = 0, l = tmp[i].children_d.length; k < l; k++) {\n\t\t\t\t\tif(obj[tmp[i].children_d[k]]) {\n\t\t\t\t\t\tdelete obj[tmp[i].children_d[k]];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\ttmp = [];\n\t\t\tfor(i in obj) {\n\t\t\t\tif(obj.hasOwnProperty(i)) {\n\t\t\t\t\ttmp.push(i);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn full ? $.map(tmp, $.proxy(function (i) { return this.get_node(i); }, this)) : tmp;\n\t\t};\n\t\t/**\n\t\t * get an array of all bottom level checked nodes (ignoring selected parents) (if tie_selection is on in the settings this function will return the same as get_bottom_selected)\n\t\t * @name get_bottom_checked([full])\n\t\t * @param  {mixed}  full if set to `true` the returned array will consist of the full node objects, otherwise - only IDs will be returned\n\t\t * @return {Array}\n\t\t * @plugin checkbox\n\t\t */\n\t\tthis.get_bottom_checked = function (full) {\n\t\t\tif(this.settings.checkbox.tie_selection) { return this.get_bottom_selected(full); }\n\t\t\tvar tmp = this.get_checked(true),\n\t\t\t\tobj = [], i, j;\n\t\t\tfor(i = 0, j = tmp.length; i < j; i++) {\n\t\t\t\tif(!tmp[i].children.length) {\n\t\t\t\t\tobj.push(tmp[i].id);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn full ? $.map(obj, $.proxy(function (i) { return this.get_node(i); }, this)) : obj;\n\t\t};\n\t};\n\n\t// include the checkbox plugin by default\n\t// $.jstree.defaults.plugins.push(\"checkbox\");\n\n/**\n * ### Contextmenu plugin\n *\n * Shows a context menu when a node is right-clicked.\n */\n// TODO: move logic outside of function + check multiple move\n\n\t/**\n\t * stores all defaults for the contextmenu plugin\n\t * @name $.jstree.defaults.contextmenu\n\t * @plugin contextmenu\n\t */\n\t$.jstree.defaults.contextmenu = {\n\t\t/**\n\t\t * a boolean indicating if the node should be selected when the context menu is invoked on it. Defaults to `true`.\n\t\t * @name $.jstree.defaults.contextmenu.select_node\n\t\t * @plugin contextmenu\n\t\t */\n\t\tselect_node : true,\n\t\t/**\n\t\t * a boolean indicating if the menu should be shown aligned with the node. Defaults to `true`, otherwise the mouse coordinates are used.\n\t\t * @name $.jstree.defaults.contextmenu.show_at_node\n\t\t * @plugin contextmenu\n\t\t */\n\t\tshow_at_node : true,\n\t\t/**\n\t\t * an object of actions, or a function that accepts a node and a callback function and calls the callback function with an object of actions available for that node (you can also return the items too).\n\t\t * \n\t\t * Each action consists of a key (a unique name) and a value which is an object with the following properties (only label and action are required):\n\t\t * \n\t\t * * `separator_before` - a boolean indicating if there should be a separator before this item\n\t\t * * `separator_after` - a boolean indicating if there should be a separator after this item\n\t\t * * `_disabled` - a boolean indicating if this action should be disabled\n\t\t * * `label` - a string - the name of the action (could be a function returning a string)\n\t\t * * `action` - a function to be executed if this item is chosen\n\t\t * * `icon` - a string, can be a path to an icon or a className, if using an image that is in the current directory use a `./` prefix, otherwise it will be detected as a class\n\t\t * * `shortcut` - keyCode which will trigger the action if the menu is open (for example `113` for rename, which equals F2)\n\t\t * * `shortcut_label` - shortcut label (like for example `F2` for rename)\n\t\t * \n\t\t * @name $.jstree.defaults.contextmenu.items\n\t\t * @plugin contextmenu\n\t\t */\n\t\titems : function (o, cb) { // Could be an object directly\n\t\t\treturn {\n\t\t\t\t\"create\" : {\n\t\t\t\t\t\"separator_before\"\t: false,\n\t\t\t\t\t\"separator_after\"\t: true,\n\t\t\t\t\t\"_disabled\"\t\t\t: false, //(this.check(\"create_node\", data.reference, {}, \"last\")),\n\t\t\t\t\t\"label\"\t\t\t\t: \"Create\",\n\t\t\t\t\t\"action\"\t\t\t: function (data) {\n\t\t\t\t\t\tvar inst = $.jstree.reference(data.reference),\n\t\t\t\t\t\t\tobj = inst.get_node(data.reference);\n\t\t\t\t\t\tinst.create_node(obj, {}, \"last\", function (new_node) {\n\t\t\t\t\t\t\tsetTimeout(function () { inst.edit(new_node); },0);\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"rename\" : {\n\t\t\t\t\t\"separator_before\"\t: false,\n\t\t\t\t\t\"separator_after\"\t: false,\n\t\t\t\t\t\"_disabled\"\t\t\t: false, //(this.check(\"rename_node\", data.reference, this.get_parent(data.reference), \"\")),\n\t\t\t\t\t\"label\"\t\t\t\t: \"Rename\",\n\t\t\t\t\t/*\n\t\t\t\t\t\"shortcut\"\t\t\t: 113,\n\t\t\t\t\t\"shortcut_label\"\t: 'F2',\n\t\t\t\t\t\"icon\"\t\t\t\t: \"glyphicon glyphicon-leaf\",\n\t\t\t\t\t*/\n\t\t\t\t\t\"action\"\t\t\t: function (data) {\n\t\t\t\t\t\tvar inst = $.jstree.reference(data.reference),\n\t\t\t\t\t\t\tobj = inst.get_node(data.reference);\n\t\t\t\t\t\tinst.edit(obj);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"remove\" : {\n\t\t\t\t\t\"separator_before\"\t: false,\n\t\t\t\t\t\"icon\"\t\t\t\t: false,\n\t\t\t\t\t\"separator_after\"\t: false,\n\t\t\t\t\t\"_disabled\"\t\t\t: false, //(this.check(\"delete_node\", data.reference, this.get_parent(data.reference), \"\")),\n\t\t\t\t\t\"label\"\t\t\t\t: \"Delete\",\n\t\t\t\t\t\"action\"\t\t\t: function (data) {\n\t\t\t\t\t\tvar inst = $.jstree.reference(data.reference),\n\t\t\t\t\t\t\tobj = inst.get_node(data.reference);\n\t\t\t\t\t\tif(inst.is_selected(obj)) {\n\t\t\t\t\t\t\tinst.delete_node(inst.get_selected());\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tinst.delete_node(obj);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"ccp\" : {\n\t\t\t\t\t\"separator_before\"\t: true,\n\t\t\t\t\t\"icon\"\t\t\t\t: false,\n\t\t\t\t\t\"separator_after\"\t: false,\n\t\t\t\t\t\"label\"\t\t\t\t: \"Edit\",\n\t\t\t\t\t\"action\"\t\t\t: false,\n\t\t\t\t\t\"submenu\" : {\n\t\t\t\t\t\t\"cut\" : {\n\t\t\t\t\t\t\t\"separator_before\"\t: false,\n\t\t\t\t\t\t\t\"separator_after\"\t: false,\n\t\t\t\t\t\t\t\"label\"\t\t\t\t: \"Cut\",\n\t\t\t\t\t\t\t\"action\"\t\t\t: function (data) {\n\t\t\t\t\t\t\t\tvar inst = $.jstree.reference(data.reference),\n\t\t\t\t\t\t\t\t\tobj = inst.get_node(data.reference);\n\t\t\t\t\t\t\t\tif(inst.is_selected(obj)) {\n\t\t\t\t\t\t\t\t\tinst.cut(inst.get_selected());\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tinst.cut(obj);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"copy\" : {\n\t\t\t\t\t\t\t\"separator_before\"\t: false,\n\t\t\t\t\t\t\t\"icon\"\t\t\t\t: false,\n\t\t\t\t\t\t\t\"separator_after\"\t: false,\n\t\t\t\t\t\t\t\"label\"\t\t\t\t: \"Copy\",\n\t\t\t\t\t\t\t\"action\"\t\t\t: function (data) {\n\t\t\t\t\t\t\t\tvar inst = $.jstree.reference(data.reference),\n\t\t\t\t\t\t\t\t\tobj = inst.get_node(data.reference);\n\t\t\t\t\t\t\t\tif(inst.is_selected(obj)) {\n\t\t\t\t\t\t\t\t\tinst.copy(inst.get_selected());\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tinst.copy(obj);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"paste\" : {\n\t\t\t\t\t\t\t\"separator_before\"\t: false,\n\t\t\t\t\t\t\t\"icon\"\t\t\t\t: false,\n\t\t\t\t\t\t\t\"_disabled\"\t\t\t: function (data) {\n\t\t\t\t\t\t\t\treturn !$.jstree.reference(data.reference).can_paste();\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"separator_after\"\t: false,\n\t\t\t\t\t\t\t\"label\"\t\t\t\t: \"Paste\",\n\t\t\t\t\t\t\t\"action\"\t\t\t: function (data) {\n\t\t\t\t\t\t\t\tvar inst = $.jstree.reference(data.reference),\n\t\t\t\t\t\t\t\t\tobj = inst.get_node(data.reference);\n\t\t\t\t\t\t\t\tinst.paste(obj);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t};\n\n\t$.jstree.plugins.contextmenu = function (options, parent) {\n\t\tthis.bind = function () {\n\t\t\tparent.bind.call(this);\n\n\t\t\tvar last_ts = 0;\n\t\t\tthis.element\n\t\t\t\t.on(\"contextmenu.jstree\", \".jstree-anchor\", $.proxy(function (e) {\n\t\t\t\t\t\te.preventDefault();\n\t\t\t\t\t\tlast_ts = e.ctrlKey ? e.timeStamp : 0;\n\t\t\t\t\t\tif(!this.is_loading(e.currentTarget)) {\n\t\t\t\t\t\t\tthis.show_contextmenu(e.currentTarget, e.pageX, e.pageY, e);\n\t\t\t\t\t\t}\n\t\t\t\t\t}, this))\n\t\t\t\t.on(\"click.jstree\", \".jstree-anchor\", $.proxy(function (e) {\n\t\t\t\t\t\tif(this._data.contextmenu.visible && (!last_ts || e.timeStamp - last_ts > 250)) { // work around safari & macOS ctrl+click\n\t\t\t\t\t\t\t$.vakata.context.hide();\n\t\t\t\t\t\t}\n\t\t\t\t\t}, this));\n\t\t\t/*\n\t\t\tif(!('oncontextmenu' in document.body) && ('ontouchstart' in document.body)) {\n\t\t\t\tvar el = null, tm = null;\n\t\t\t\tthis.element\n\t\t\t\t\t.on(\"touchstart\", \".jstree-anchor\", function (e) {\n\t\t\t\t\t\tel = e.currentTarget;\n\t\t\t\t\t\ttm = +new Date();\n\t\t\t\t\t\t$(document).one(\"touchend\", function (e) {\n\t\t\t\t\t\t\te.target = document.elementFromPoint(e.originalEvent.targetTouches[0].pageX - window.pageXOffset, e.originalEvent.targetTouches[0].pageY - window.pageYOffset);\n\t\t\t\t\t\t\te.currentTarget = e.target;\n\t\t\t\t\t\t\ttm = ((+(new Date())) - tm);\n\t\t\t\t\t\t\tif(e.target === el && tm > 600 && tm < 1000) {\n\t\t\t\t\t\t\t\te.preventDefault();\n\t\t\t\t\t\t\t\t$(el).trigger('contextmenu', e);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tel = null;\n\t\t\t\t\t\t\ttm = null;\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t}\n\t\t\t*/\n\t\t\t$(document).on(\"context_hide.vakata\", $.proxy(function () { this._data.contextmenu.visible = false; }, this));\n\t\t};\n\t\tthis.teardown = function () {\n\t\t\tif(this._data.contextmenu.visible) {\n\t\t\t\t$.vakata.context.hide();\n\t\t\t}\n\t\t\tparent.teardown.call(this);\n\t\t};\n\n\t\t/**\n\t\t * prepare and show the context menu for a node\n\t\t * @name show_contextmenu(obj [, x, y])\n\t\t * @param {mixed} obj the node\n\t\t * @param {Number} x the x-coordinate relative to the document to show the menu at\n\t\t * @param {Number} y the y-coordinate relative to the document to show the menu at\n\t\t * @param {Object} e the event if available that triggered the contextmenu\n\t\t * @plugin contextmenu\n\t\t * @trigger show_contextmenu.jstree\n\t\t */\n\t\tthis.show_contextmenu = function (obj, x, y, e) {\n\t\t\tobj = this.get_node(obj);\n\t\t\tif(!obj || obj.id === '#') { return false; }\n\t\t\tvar s = this.settings.contextmenu,\n\t\t\t\td = this.get_node(obj, true),\n\t\t\t\ta = d.children(\".jstree-anchor\"),\n\t\t\t\to = false,\n\t\t\t\ti = false;\n\t\t\tif(s.show_at_node || x === undefined || y === undefined) {\n\t\t\t\to = a.offset();\n\t\t\t\tx = o.left;\n\t\t\t\ty = o.top + this._data.core.li_height;\n\t\t\t}\n\t\t\tif(this.settings.contextmenu.select_node && !this.is_selected(obj)) {\n\t\t\t\tthis.activate_node(obj, e);\n\t\t\t}\n\n\t\t\ti = s.items;\n\t\t\tif($.isFunction(i)) {\n\t\t\t\ti = i.call(this, obj, $.proxy(function (i) {\n\t\t\t\t\tthis._show_contextmenu(obj, x, y, i);\n\t\t\t\t}, this));\n\t\t\t}\n\t\t\tif($.isPlainObject(i)) {\n\t\t\t\tthis._show_contextmenu(obj, x, y, i);\n\t\t\t}\n\t\t};\n\t\t/**\n\t\t * show the prepared context menu for a node\n\t\t * @name _show_contextmenu(obj, x, y, i)\n\t\t * @param {mixed} obj the node\n\t\t * @param {Number} x the x-coordinate relative to the document to show the menu at\n\t\t * @param {Number} y the y-coordinate relative to the document to show the menu at\n\t\t * @param {Number} i the object of items to show\n\t\t * @plugin contextmenu\n\t\t * @trigger show_contextmenu.jstree\n\t\t * @private\n\t\t */\n\t\tthis._show_contextmenu = function (obj, x, y, i) {\n\t\t\tvar d = this.get_node(obj, true),\n\t\t\t\ta = d.children(\".jstree-anchor\");\n\t\t\t$(document).one(\"context_show.vakata\", $.proxy(function (e, data) {\n\t\t\t\tvar cls = 'jstree-contextmenu jstree-' + this.get_theme() + '-contextmenu';\n\t\t\t\t$(data.element).addClass(cls);\n\t\t\t}, this));\n\t\t\tthis._data.contextmenu.visible = true;\n\t\t\t$.vakata.context.show(a, { 'x' : x, 'y' : y }, i);\n\t\t\t/**\n\t\t\t * triggered when the contextmenu is shown for a node\n\t\t\t * @event\n\t\t\t * @name show_contextmenu.jstree\n\t\t\t * @param {Object} node the node\n\t\t\t * @param {Number} x the x-coordinate of the menu relative to the document\n\t\t\t * @param {Number} y the y-coordinate of the menu relative to the document\n\t\t\t * @plugin contextmenu\n\t\t\t */\n\t\t\tthis.trigger('show_contextmenu', { \"node\" : obj, \"x\" : x, \"y\" : y });\n\t\t};\n\t};\n\n\t// contextmenu helper\n\t(function ($) {\n\t\tvar right_to_left = false,\n\t\t\tvakata_context = {\n\t\t\t\telement\t\t: false,\n\t\t\t\treference\t: false,\n\t\t\t\tposition_x\t: 0,\n\t\t\t\tposition_y\t: 0,\n\t\t\t\titems\t\t: [],\n\t\t\t\thtml\t\t: \"\",\n\t\t\t\tis_visible\t: false\n\t\t\t};\n\n\t\t$.vakata.context = {\n\t\t\tsettings : {\n\t\t\t\thide_onmouseleave\t: 0,\n\t\t\t\ticons\t\t\t\t: true\n\t\t\t},\n\t\t\t_trigger : function (event_name) {\n\t\t\t\t$(document).triggerHandler(\"context_\" + event_name + \".vakata\", {\n\t\t\t\t\t\"reference\"\t: vakata_context.reference,\n\t\t\t\t\t\"element\"\t: vakata_context.element,\n\t\t\t\t\t\"position\"\t: {\n\t\t\t\t\t\t\"x\" : vakata_context.position_x,\n\t\t\t\t\t\t\"y\" : vakata_context.position_y\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t},\n\t\t\t_execute : function (i) {\n\t\t\t\ti = vakata_context.items[i];\n\t\t\t\treturn i && (!i._disabled || ($.isFunction(i._disabled) && !i._disabled({ \"item\" : i, \"reference\" : vakata_context.reference, \"element\" : vakata_context.element }))) && i.action ? i.action.call(null, {\n\t\t\t\t\t\t\t\"item\"\t\t: i,\n\t\t\t\t\t\t\t\"reference\"\t: vakata_context.reference,\n\t\t\t\t\t\t\t\"element\"\t: vakata_context.element,\n\t\t\t\t\t\t\t\"position\"\t: {\n\t\t\t\t\t\t\t\t\"x\" : vakata_context.position_x,\n\t\t\t\t\t\t\t\t\"y\" : vakata_context.position_y\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}) : false;\n\t\t\t},\n\t\t\t_parse : function (o, is_callback) {\n\t\t\t\tif(!o) { return false; }\n\t\t\t\tif(!is_callback) {\n\t\t\t\t\tvakata_context.html\t\t= \"\";\n\t\t\t\t\tvakata_context.items\t= [];\n\t\t\t\t}\n\t\t\t\tvar str = \"\",\n\t\t\t\t\tsep = false,\n\t\t\t\t\ttmp;\n\n\t\t\t\tif(is_callback) { str += \"<\"+\"ul>\"; }\n\t\t\t\t$.each(o, function (i, val) {\n\t\t\t\t\tif(!val) { return true; }\n\t\t\t\t\tvakata_context.items.push(val);\n\t\t\t\t\tif(!sep && val.separator_before) {\n\t\t\t\t\t\tstr += \"<\"+\"li class='vakata-context-separator'><\"+\"a href='#' \" + ($.vakata.context.settings.icons ? '' : 'style=\"margin-left:0px;\"') + \">&#160;<\"+\"/a><\"+\"/li>\";\n\t\t\t\t\t}\n\t\t\t\t\tsep = false;\n\t\t\t\t\tstr += \"<\"+\"li class='\" + (val._class || \"\") + (val._disabled === true || ($.isFunction(val._disabled) && val._disabled({ \"item\" : val, \"reference\" : vakata_context.reference, \"element\" : vakata_context.element })) ? \" vakata-contextmenu-disabled \" : \"\") + \"' \"+(val.shortcut?\" data-shortcut='\"+val.shortcut+\"' \":'')+\">\";\n\t\t\t\t\tstr += \"<\"+\"a href='#' rel='\" + (vakata_context.items.length - 1) + \"'>\";\n\t\t\t\t\tif($.vakata.context.settings.icons) {\n\t\t\t\t\t\tstr += \"<\"+\"i \";\n\t\t\t\t\t\tif(val.icon) {\n\t\t\t\t\t\t\tif(val.icon.indexOf(\"/\") !== -1 || val.icon.indexOf(\".\") !== -1) { str += \" style='background:url(\\\"\" + val.icon + \"\\\") center center no-repeat' \"; }\n\t\t\t\t\t\t\telse { str += \" class='\" + val.icon + \"' \"; }\n\t\t\t\t\t\t}\n\t\t\t\t\t\tstr += \"><\"+\"/i><\"+\"span class='vakata-contextmenu-sep'>&#160;<\"+\"/span>\";\n\t\t\t\t\t}\n\t\t\t\t\tstr += ($.isFunction(val.label) ? val.label({ \"item\" : i, \"reference\" : vakata_context.reference, \"element\" : vakata_context.element }) : val.label) + (val.shortcut?' <span class=\"vakata-contextmenu-shortcut vakata-contextmenu-shortcut-'+val.shortcut+'\">'+ (val.shortcut_label || '') +'</span>':'') + \"<\"+\"/a>\";\n\t\t\t\t\tif(val.submenu) {\n\t\t\t\t\t\ttmp = $.vakata.context._parse(val.submenu, true);\n\t\t\t\t\t\tif(tmp) { str += tmp; }\n\t\t\t\t\t}\n\t\t\t\t\tstr += \"<\"+\"/li>\";\n\t\t\t\t\tif(val.separator_after) {\n\t\t\t\t\t\tstr += \"<\"+\"li class='vakata-context-separator'><\"+\"a href='#' \" + ($.vakata.context.settings.icons ? '' : 'style=\"margin-left:0px;\"') + \">&#160;<\"+\"/a><\"+\"/li>\";\n\t\t\t\t\t\tsep = true;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tstr  = str.replace(/<li class\\='vakata-context-separator'\\><\\/li\\>$/,\"\");\n\t\t\t\tif(is_callback) { str += \"</ul>\"; }\n\t\t\t\t/**\n\t\t\t\t * triggered on the document when the contextmenu is parsed (HTML is built)\n\t\t\t\t * @event\n\t\t\t\t * @plugin contextmenu\n\t\t\t\t * @name context_parse.vakata\n\t\t\t\t * @param {jQuery} reference the element that was right clicked\n\t\t\t\t * @param {jQuery} element the DOM element of the menu itself\n\t\t\t\t * @param {Object} position the x & y coordinates of the menu\n\t\t\t\t */\n\t\t\t\tif(!is_callback) { vakata_context.html = str; $.vakata.context._trigger(\"parse\"); }\n\t\t\t\treturn str.length > 10 ? str : false;\n\t\t\t},\n\t\t\t_show_submenu : function (o) {\n\t\t\t\to = $(o);\n\t\t\t\tif(!o.length || !o.children(\"ul\").length) { return; }\n\t\t\t\tvar e = o.children(\"ul\"),\n\t\t\t\t\tx = o.offset().left + o.outerWidth(),\n\t\t\t\t\ty = o.offset().top,\n\t\t\t\t\tw = e.width(),\n\t\t\t\t\th = e.height(),\n\t\t\t\t\tdw = $(window).width() + $(window).scrollLeft(),\n\t\t\t\t\tdh = $(window).height() + $(window).scrollTop();\n\t\t\t\t//        -       \n\t\t\t\tif(right_to_left) {\n\t\t\t\t\to[x - (w + 10 + o.outerWidth()) < 0 ? \"addClass\" : \"removeClass\"](\"vakata-context-left\");\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\to[x + w + 10 > dw ? \"addClass\" : \"removeClass\"](\"vakata-context-right\");\n\t\t\t\t}\n\t\t\t\tif(y + h + 10 > dh) {\n\t\t\t\t\te.css(\"bottom\",\"-1px\");\n\t\t\t\t}\n\t\t\t\te.show();\n\t\t\t},\n\t\t\tshow : function (reference, position, data) {\n\t\t\t\tvar o, e, x, y, w, h, dw, dh, cond = true;\n\t\t\t\tif(vakata_context.element && vakata_context.element.length) {\n\t\t\t\t\tvakata_context.element.width('');\n\t\t\t\t}\n\t\t\t\tswitch(cond) {\n\t\t\t\t\tcase (!position && !reference):\n\t\t\t\t\t\treturn false;\n\t\t\t\t\tcase (!!position && !!reference):\n\t\t\t\t\t\tvakata_context.reference\t= reference;\n\t\t\t\t\t\tvakata_context.position_x\t= position.x;\n\t\t\t\t\t\tvakata_context.position_y\t= position.y;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase (!position && !!reference):\n\t\t\t\t\t\tvakata_context.reference\t= reference;\n\t\t\t\t\t\to = reference.offset();\n\t\t\t\t\t\tvakata_context.position_x\t= o.left + reference.outerHeight();\n\t\t\t\t\t\tvakata_context.position_y\t= o.top;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase (!!position && !reference):\n\t\t\t\t\t\tvakata_context.position_x\t= position.x;\n\t\t\t\t\t\tvakata_context.position_y\t= position.y;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(!!reference && !data && $(reference).data('vakata_contextmenu')) {\n\t\t\t\t\tdata = $(reference).data('vakata_contextmenu');\n\t\t\t\t}\n\t\t\t\tif($.vakata.context._parse(data)) {\n\t\t\t\t\tvakata_context.element.html(vakata_context.html);\n\t\t\t\t}\n\t\t\t\tif(vakata_context.items.length) {\n\t\t\t\t\te = vakata_context.element;\n\t\t\t\t\tx = vakata_context.position_x;\n\t\t\t\t\ty = vakata_context.position_y;\n\t\t\t\t\tw = e.width();\n\t\t\t\t\th = e.height();\n\t\t\t\t\tdw = $(window).width() + $(window).scrollLeft();\n\t\t\t\t\tdh = $(window).height() + $(window).scrollTop();\n\t\t\t\t\tif(right_to_left) {\n\t\t\t\t\t\tx -= e.outerWidth();\n\t\t\t\t\t\tif(x < $(window).scrollLeft() + 20) {\n\t\t\t\t\t\t\tx = $(window).scrollLeft() + 20;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(x + w + 20 > dw) {\n\t\t\t\t\t\tx = dw - (w + 20);\n\t\t\t\t\t}\n\t\t\t\t\tif(y + h + 20 > dh) {\n\t\t\t\t\t\ty = dh - (h + 20);\n\t\t\t\t\t}\n\n\t\t\t\t\tvakata_context.element\n\t\t\t\t\t\t.css({ \"left\" : x, \"top\" : y })\n\t\t\t\t\t\t.show()\n\t\t\t\t\t\t.find('a:eq(0)').focus().parent().addClass(\"vakata-context-hover\");\n\t\t\t\t\tvakata_context.is_visible = true;\n\t\t\t\t\t/**\n\t\t\t\t\t * triggered on the document when the contextmenu is shown\n\t\t\t\t\t * @event\n\t\t\t\t\t * @plugin contextmenu\n\t\t\t\t\t * @name context_show.vakata\n\t\t\t\t\t * @param {jQuery} reference the element that was right clicked\n\t\t\t\t\t * @param {jQuery} element the DOM element of the menu itself\n\t\t\t\t\t * @param {Object} position the x & y coordinates of the menu\n\t\t\t\t\t */\n\t\t\t\t\t$.vakata.context._trigger(\"show\");\n\t\t\t\t}\n\t\t\t},\n\t\t\thide : function () {\n\t\t\t\tif(vakata_context.is_visible) {\n\t\t\t\t\tvakata_context.element.hide().find(\"ul\").hide().end().find(':focus').blur();\n\t\t\t\t\tvakata_context.is_visible = false;\n\t\t\t\t\t/**\n\t\t\t\t\t * triggered on the document when the contextmenu is hidden\n\t\t\t\t\t * @event\n\t\t\t\t\t * @plugin contextmenu\n\t\t\t\t\t * @name context_hide.vakata\n\t\t\t\t\t * @param {jQuery} reference the element that was right clicked\n\t\t\t\t\t * @param {jQuery} element the DOM element of the menu itself\n\t\t\t\t\t * @param {Object} position the x & y coordinates of the menu\n\t\t\t\t\t */\n\t\t\t\t\t$.vakata.context._trigger(\"hide\");\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\t$(function () {\n\t\t\tright_to_left = $(\"body\").css(\"direction\") === \"rtl\";\n\t\t\tvar to = false;\n\n\t\t\tvakata_context.element = $(\"<ul class='vakata-context'></ul>\");\n\t\t\tvakata_context.element\n\t\t\t\t.on(\"mouseenter\", \"li\", function (e) {\n\t\t\t\t\te.stopImmediatePropagation();\n\n\t\t\t\t\tif($.contains(this, e.relatedTarget)) {\n\t\t\t\t\t\t//   delegate mouseleave -\n\t\t\t\t\t\t// $(this).find(\".vakata-context-hover\").removeClass(\"vakata-context-hover\");\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(to) { clearTimeout(to); }\n\t\t\t\t\tvakata_context.element.find(\".vakata-context-hover\").removeClass(\"vakata-context-hover\").end();\n\n\t\t\t\t\t$(this)\n\t\t\t\t\t\t.siblings().find(\"ul\").hide().end().end()\n\t\t\t\t\t\t.parentsUntil(\".vakata-context\", \"li\").addBack().addClass(\"vakata-context-hover\");\n\t\t\t\t\t$.vakata.context._show_submenu(this);\n\t\t\t\t})\n\t\t\t\t//  -   ?\n\t\t\t\t.on(\"mouseleave\", \"li\", function (e) {\n\t\t\t\t\tif($.contains(this, e.relatedTarget)) { return; }\n\t\t\t\t\t$(this).find(\".vakata-context-hover\").addBack().removeClass(\"vakata-context-hover\");\n\t\t\t\t})\n\t\t\t\t.on(\"mouseleave\", function (e) {\n\t\t\t\t\t$(this).find(\".vakata-context-hover\").removeClass(\"vakata-context-hover\");\n\t\t\t\t\tif($.vakata.context.settings.hide_onmouseleave) {\n\t\t\t\t\t\tto = setTimeout(\n\t\t\t\t\t\t\t(function (t) {\n\t\t\t\t\t\t\t\treturn function () { $.vakata.context.hide(); };\n\t\t\t\t\t\t\t}(this)), $.vakata.context.settings.hide_onmouseleave);\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.on(\"click\", \"a\", function (e) {\n\t\t\t\t\te.preventDefault();\n\t\t\t\t//})\n\t\t\t\t//.on(\"mouseup\", \"a\", function (e) {\n\t\t\t\t\tif(!$(this).blur().parent().hasClass(\"vakata-context-disabled\") && $.vakata.context._execute($(this).attr(\"rel\")) !== false) {\n\t\t\t\t\t\t$.vakata.context.hide();\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.on('keydown', 'a', function (e) {\n\t\t\t\t\t\tvar o = null;\n\t\t\t\t\t\tswitch(e.which) {\n\t\t\t\t\t\t\tcase 13:\n\t\t\t\t\t\t\tcase 32:\n\t\t\t\t\t\t\t\te.type = \"mouseup\";\n\t\t\t\t\t\t\t\te.preventDefault();\n\t\t\t\t\t\t\t\t$(e.currentTarget).trigger(e);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 37:\n\t\t\t\t\t\t\t\tif(vakata_context.is_visible) {\n\t\t\t\t\t\t\t\t\tvakata_context.element.find(\".vakata-context-hover\").last().parents(\"li:eq(0)\").find(\"ul\").hide().find(\".vakata-context-hover\").removeClass(\"vakata-context-hover\").end().end().children('a').focus();\n\t\t\t\t\t\t\t\t\te.stopImmediatePropagation();\n\t\t\t\t\t\t\t\t\te.preventDefault();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 38:\n\t\t\t\t\t\t\t\tif(vakata_context.is_visible) {\n\t\t\t\t\t\t\t\t\to = vakata_context.element.find(\"ul:visible\").addBack().last().children(\".vakata-context-hover\").removeClass(\"vakata-context-hover\").prevAll(\"li:not(.vakata-context-separator)\").first();\n\t\t\t\t\t\t\t\t\tif(!o.length) { o = vakata_context.element.find(\"ul:visible\").addBack().last().children(\"li:not(.vakata-context-separator)\").last(); }\n\t\t\t\t\t\t\t\t\to.addClass(\"vakata-context-hover\").children('a').focus();\n\t\t\t\t\t\t\t\t\te.stopImmediatePropagation();\n\t\t\t\t\t\t\t\t\te.preventDefault();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 39:\n\t\t\t\t\t\t\t\tif(vakata_context.is_visible) {\n\t\t\t\t\t\t\t\t\tvakata_context.element.find(\".vakata-context-hover\").last().children(\"ul\").show().children(\"li:not(.vakata-context-separator)\").removeClass(\"vakata-context-hover\").first().addClass(\"vakata-context-hover\").children('a').focus();\n\t\t\t\t\t\t\t\t\te.stopImmediatePropagation();\n\t\t\t\t\t\t\t\t\te.preventDefault();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 40:\n\t\t\t\t\t\t\t\tif(vakata_context.is_visible) {\n\t\t\t\t\t\t\t\t\to = vakata_context.element.find(\"ul:visible\").addBack().last().children(\".vakata-context-hover\").removeClass(\"vakata-context-hover\").nextAll(\"li:not(.vakata-context-separator)\").first();\n\t\t\t\t\t\t\t\t\tif(!o.length) { o = vakata_context.element.find(\"ul:visible\").addBack().last().children(\"li:not(.vakata-context-separator)\").first(); }\n\t\t\t\t\t\t\t\t\to.addClass(\"vakata-context-hover\").children('a').focus();\n\t\t\t\t\t\t\t\t\te.stopImmediatePropagation();\n\t\t\t\t\t\t\t\t\te.preventDefault();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 27:\n\t\t\t\t\t\t\t\t$.vakata.context.hide();\n\t\t\t\t\t\t\t\te.preventDefault();\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t//console.log(e.which);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t.on('keydown', function (e) {\n\t\t\t\t\te.preventDefault();\n\t\t\t\t\tvar a = vakata_context.element.find('.vakata-contextmenu-shortcut-' + e.which).parent();\n\t\t\t\t\tif(a.parent().not('.vakata-context-disabled')) {\n\t\t\t\t\t\ta.mouseup();\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.appendTo(\"body\");\n\n\t\t\t$(document)\n\t\t\t\t.on(\"mousedown\", function (e) {\n\t\t\t\t\tif(vakata_context.is_visible && !$.contains(vakata_context.element[0], e.target)) { $.vakata.context.hide(); }\n\t\t\t\t})\n\t\t\t\t.on(\"context_show.vakata\", function (e, data) {\n\t\t\t\t\tvakata_context.element.find(\"li:has(ul)\").children(\"a\").addClass(\"vakata-context-parent\");\n\t\t\t\t\tif(right_to_left) {\n\t\t\t\t\t\tvakata_context.element.addClass(\"vakata-context-rtl\").css(\"direction\", \"rtl\");\n\t\t\t\t\t}\n\t\t\t\t\t// also apply a RTL class?\n\t\t\t\t\tvakata_context.element.find(\"ul\").hide().end();\n\t\t\t\t});\n\t\t});\n\t}($));\n\t// $.jstree.defaults.plugins.push(\"contextmenu\");\n\n/**\n * ### Drag'n'drop plugin\n *\n * Enables dragging and dropping of nodes in the tree, resulting in a move or copy operations.\n */\n\n\t/**\n\t * stores all defaults for the drag'n'drop plugin\n\t * @name $.jstree.defaults.dnd\n\t * @plugin dnd\n\t */\n\t$.jstree.defaults.dnd = {\n\t\t/**\n\t\t * a boolean indicating if a copy should be possible while dragging (by pressint the meta key or Ctrl). Defaults to `true`.\n\t\t * @name $.jstree.defaults.dnd.copy\n\t\t * @plugin dnd\n\t\t */\n\t\tcopy : true,\n\t\t/**\n\t\t * a number indicating how long a node should remain hovered while dragging to be opened. Defaults to `500`.\n\t\t * @name $.jstree.defaults.dnd.open_timeout\n\t\t * @plugin dnd\n\t\t */\n\t\topen_timeout : 500,\n\t\t/**\n\t\t * a function invoked each time a node is about to be dragged, invoked in the tree's scope and receives the nodes about to be dragged as an argument (array) - return `false` to prevent dragging\n\t\t * @name $.jstree.defaults.dnd.is_draggable\n\t\t * @plugin dnd\n\t\t */\n\t\tis_draggable : true,\n\t\t/**\n\t\t * a boolean indicating if checks should constantly be made while the user is dragging the node (as opposed to checking only on drop), default is `true`\n\t\t * @name $.jstree.defaults.dnd.check_while_dragging\n\t\t * @plugin dnd\n\t\t */\n\t\tcheck_while_dragging : true,\n\t\t/**\n\t\t * a boolean indicating if nodes from this tree should only be copied with dnd (as opposed to moved), default is `false`\n\t\t * @name $.jstree.defaults.dnd.always_copy\n\t\t * @plugin dnd\n\t\t */\n\t\talways_copy : false,\n\t\t/**\n\t\t * when dropping a node \"inside\", this setting indicates the position the node should go to - it can be an integer or a string: \"first\" (same as 0) or \"last\", default is `0`\n\t\t * @name $.jstree.defaults.dnd.inside_pos\n\t\t * @plugin dnd\n\t\t */\n\t\tinside_pos : 0\n\t};\n\t// TODO: now check works by checking for each node individually, how about max_children, unique, etc?\n\t// TODO: drop somewhere else - maybe demo only?\n\t$.jstree.plugins.dnd = function (options, parent) {\n\t\tthis.bind = function () {\n\t\t\tparent.bind.call(this);\n\n\t\t\tthis.element\n\t\t\t\t.on('mousedown.jstree touchstart.jstree', '.jstree-anchor', $.proxy(function (e) {\n\t\t\t\t\tvar obj = this.get_node(e.target),\n\t\t\t\t\t\tmlt = this.is_selected(obj) ? this.get_selected().length : 1;\n\t\t\t\t\tif(obj && obj.id && obj.id !== \"#\" && (e.which === 1 || e.type === \"touchstart\") &&\n\t\t\t\t\t\t(this.settings.dnd.is_draggable === true || ($.isFunction(this.settings.dnd.is_draggable) && this.settings.dnd.is_draggable.call(this, (mlt > 1 ? this.get_selected(true) : [obj]))))\n\t\t\t\t\t) {\n\t\t\t\t\t\tthis.element.trigger('mousedown.jstree');\n\t\t\t\t\t\treturn $.vakata.dnd.start(e, { 'jstree' : true, 'origin' : this, 'obj' : this.get_node(obj,true), 'nodes' : mlt > 1 ? this.get_selected() : [obj.id] }, '<div id=\"jstree-dnd\" class=\"jstree-' + this.get_theme() + ( this.settings.core.themes.responsive ? ' jstree-dnd-responsive' : '' ) + '\"><i class=\"jstree-icon jstree-er\"></i>' + (mlt > 1 ? mlt + ' ' + this.get_string('nodes') : this.get_text(e.currentTarget, true)) + '<ins class=\"jstree-copy\" style=\"display:none;\">+</ins></div>');\n\t\t\t\t\t}\n\t\t\t\t}, this));\n\t\t};\n\t};\n\n\t$(function() {\n\t\t// bind only once for all instances\n\t\tvar lastmv = false,\n\t\t\tlaster = false,\n\t\t\topento = false,\n\t\t\tmarker = $('<div id=\"jstree-marker\">&#160;</div>').hide().appendTo('body');\n\n\t\t$(document)\n\t\t\t.bind('dnd_start.vakata', function (e, data) {\n\t\t\t\tlastmv = false;\n\t\t\t})\n\t\t\t.bind('dnd_move.vakata', function (e, data) {\n\t\t\t\tif(opento) { clearTimeout(opento); }\n\t\t\t\tif(!data || !data.data || !data.data.jstree) { return; }\n\n\t\t\t\t// if we are hovering the marker image do nothing (can happen on \"inside\" drags)\n\t\t\t\tif(data.event.target.id && data.event.target.id === 'jstree-marker') {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tvar ins = $.jstree.reference(data.event.target),\n\t\t\t\t\tref = false,\n\t\t\t\t\toff = false,\n\t\t\t\t\trel = false,\n\t\t\t\t\tl, t, h, p, i, o, ok, t1, t2, op, ps, pr, ip, tm;\n\t\t\t\t// if we are over an instance\n\t\t\t\tif(ins && ins._data && ins._data.dnd) {\n\t\t\t\t\tmarker.attr('class', 'jstree-' + ins.get_theme() + ( ins.settings.core.themes.responsive ? ' jstree-dnd-responsive' : '' ));\n\t\t\t\t\tdata.helper\n\t\t\t\t\t\t.children().attr('class', 'jstree-' + ins.get_theme() + ( ins.settings.core.themes.responsive ? ' jstree-dnd-responsive' : '' ))\n\t\t\t\t\t\t.find('.jstree-copy:eq(0)')[ data.data.origin && (data.data.origin.settings.dnd.always_copy || (data.data.origin.settings.dnd.copy && (data.event.metaKey || data.event.ctrlKey))) ? 'show' : 'hide' ]();\n\n\n\t\t\t\t\t// if are hovering the container itself add a new root node\n\t\t\t\t\tif( (data.event.target === ins.element[0] || data.event.target === ins.get_container_ul()[0]) && ins.get_container_ul().children().length === 0) {\n\t\t\t\t\t\tok = true;\n\t\t\t\t\t\tfor(t1 = 0, t2 = data.data.nodes.length; t1 < t2; t1++) {\n\t\t\t\t\t\t\tok = ok && ins.check( (data.data.origin && (data.data.origin.settings.dnd.always_copy || (data.data.origin.settings.dnd.copy && (data.event.metaKey || data.event.ctrlKey)) ) ? \"copy_node\" : \"move_node\"), (data.data.origin && data.data.origin !== ins ? data.data.origin.get_node(data.data.nodes[t1]) : data.data.nodes[t1]), '#', 'last', { 'dnd' : true, 'ref' : ins.get_node('#'), 'pos' : 'i', 'is_multi' : (data.data.origin && data.data.origin !== ins), 'is_foreign' : (!data.data.origin) });\n\t\t\t\t\t\t\tif(!ok) { break; }\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(ok) {\n\t\t\t\t\t\t\tlastmv = { 'ins' : ins, 'par' : '#', 'pos' : 'last' };\n\t\t\t\t\t\t\tmarker.hide();\n\t\t\t\t\t\t\tdata.helper.find('.jstree-icon:eq(0)').removeClass('jstree-er').addClass('jstree-ok');\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// if we are hovering a tree node\n\t\t\t\t\t\tref = $(data.event.target).closest('.jstree-anchor');\n\t\t\t\t\t\tif(ref && ref.length && ref.parent().is('.jstree-closed, .jstree-open, .jstree-leaf')) {\n\t\t\t\t\t\t\toff = ref.offset();\n\t\t\t\t\t\t\trel = data.event.pageY - off.top;\n\t\t\t\t\t\t\th = ref.height();\n\t\t\t\t\t\t\tif(rel < h / 3) {\n\t\t\t\t\t\t\t\to = ['b', 'i', 'a'];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if(rel > h - h / 3) {\n\t\t\t\t\t\t\t\to = ['a', 'i', 'b'];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\to = rel > h / 2 ? ['i', 'a', 'b'] : ['i', 'b', 'a'];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t$.each(o, function (j, v) {\n\t\t\t\t\t\t\t\tswitch(v) {\n\t\t\t\t\t\t\t\t\tcase 'b':\n\t\t\t\t\t\t\t\t\t\tl = off.left - 6;\n\t\t\t\t\t\t\t\t\t\tt = off.top;\n\t\t\t\t\t\t\t\t\t\tp = ins.get_parent(ref);\n\t\t\t\t\t\t\t\t\t\ti = ref.parent().index();\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\tcase 'i':\n\t\t\t\t\t\t\t\t\t\tip = ins.settings.dnd.inside_pos;\n\t\t\t\t\t\t\t\t\t\ttm = ins.get_node(ref.parent());\n\t\t\t\t\t\t\t\t\t\tl = off.left - 2;\n\t\t\t\t\t\t\t\t\t\tt = off.top + h / 2 + 1;\n\t\t\t\t\t\t\t\t\t\tp = tm.id;\n\t\t\t\t\t\t\t\t\t\ti = ip === 'first' ? 0 : (ip === 'last' ? tm.children.length : Math.min(ip, tm.children.length));\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\tcase 'a':\n\t\t\t\t\t\t\t\t\t\tl = off.left - 6;\n\t\t\t\t\t\t\t\t\t\tt = off.top + h;\n\t\t\t\t\t\t\t\t\t\tp = ins.get_parent(ref);\n\t\t\t\t\t\t\t\t\t\ti = ref.parent().index() + 1;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t/*!\n\t\t\t\t\t\t\t\t// TODO: moving inside, but the node is not yet loaded?\n\t\t\t\t\t\t\t\t// the check will work anyway, as when moving the node will be loaded first and checked again\n\t\t\t\t\t\t\t\tif(v === 'i' && !ins.is_loaded(p)) { }\n\t\t\t\t\t\t\t\t*/\n\t\t\t\t\t\t\t\tok = true;\n\t\t\t\t\t\t\t\tfor(t1 = 0, t2 = data.data.nodes.length; t1 < t2; t1++) {\n\t\t\t\t\t\t\t\t\top = data.data.origin && (data.data.origin.settings.dnd.always_copy || (data.data.origin.settings.dnd.copy && (data.event.metaKey || data.event.ctrlKey))) ? \"copy_node\" : \"move_node\";\n\t\t\t\t\t\t\t\t\tps = i;\n\t\t\t\t\t\t\t\t\tif(op === \"move_node\" && v === 'a' && (data.data.origin && data.data.origin === ins) && p === ins.get_parent(data.data.nodes[t1])) {\n\t\t\t\t\t\t\t\t\t\tpr = ins.get_node(p);\n\t\t\t\t\t\t\t\t\t\tif(ps > $.inArray(data.data.nodes[t1], pr.children)) {\n\t\t\t\t\t\t\t\t\t\t\tps -= 1;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tok = ok && ( (ins && ins.settings && ins.settings.dnd && ins.settings.dnd.check_while_dragging === false) || ins.check(op, (data.data.origin && data.data.origin !== ins ? data.data.origin.get_node(data.data.nodes[t1]) : data.data.nodes[t1]), p, ps, { 'dnd' : true, 'ref' : ins.get_node(ref.parent()), 'pos' : v, 'is_multi' : (data.data.origin && data.data.origin !== ins), 'is_foreign' : (!data.data.origin) }) );\n\t\t\t\t\t\t\t\t\tif(!ok) {\n\t\t\t\t\t\t\t\t\t\tif(ins && ins.last_error) { laster = ins.last_error(); }\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(ok) {\n\t\t\t\t\t\t\t\t\tif(v === 'i' && ref.parent().is('.jstree-closed') && ins.settings.dnd.open_timeout) {\n\t\t\t\t\t\t\t\t\t\topento = setTimeout((function (x, z) { return function () { x.open_node(z); }; }(ins, ref)), ins.settings.dnd.open_timeout);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tlastmv = { 'ins' : ins, 'par' : p, 'pos' : v === 'i' && ip === 'last' && i === 0 && !ins.is_loaded(tm) ? 'last' : i };\n\t\t\t\t\t\t\t\t\tmarker.css({ 'left' : l + 'px', 'top' : t + 'px' }).show();\n\t\t\t\t\t\t\t\t\tdata.helper.find('.jstree-icon:eq(0)').removeClass('jstree-er').addClass('jstree-ok');\n\t\t\t\t\t\t\t\t\tlaster = {};\n\t\t\t\t\t\t\t\t\to = true;\n\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tif(o === true) { return; }\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlastmv = false;\n\t\t\t\tdata.helper.find('.jstree-icon').removeClass('jstree-ok').addClass('jstree-er');\n\t\t\t\tmarker.hide();\n\t\t\t})\n\t\t\t.bind('dnd_scroll.vakata', function (e, data) {\n\t\t\t\tif(!data || !data.data || !data.data.jstree) { return; }\n\t\t\t\tmarker.hide();\n\t\t\t\tlastmv = false;\n\t\t\t\tdata.helper.find('.jstree-icon:eq(0)').removeClass('jstree-ok').addClass('jstree-er');\n\t\t\t})\n\t\t\t.bind('dnd_stop.vakata', function (e, data) {\n\t\t\t\tif(opento) { clearTimeout(opento); }\n\t\t\t\tif(!data || !data.data || !data.data.jstree) { return; }\n\t\t\t\tmarker.hide();\n\t\t\t\tvar i, j, nodes = [];\n\t\t\t\tif(lastmv) {\n\t\t\t\t\tfor(i = 0, j = data.data.nodes.length; i < j; i++) {\n\t\t\t\t\t\tnodes[i] = data.data.origin ? data.data.origin.get_node(data.data.nodes[i]) : data.data.nodes[i];\n\t\t\t\t\t\tif(data.data.origin) {\n\t\t\t\t\t\t\tnodes[i].instance = data.data.origin;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlastmv.ins[ data.data.origin && (data.data.origin.settings.dnd.always_copy || (data.data.origin.settings.dnd.copy && (data.event.metaKey || data.event.ctrlKey))) ? 'copy_node' : 'move_node' ](nodes, lastmv.par, lastmv.pos);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ti = $(data.event.target).closest('.jstree');\n\t\t\t\t\tif(i.length && laster && laster.error && laster.error === 'check') {\n\t\t\t\t\t\ti = i.jstree(true);\n\t\t\t\t\t\tif(i) {\n\t\t\t\t\t\t\ti.settings.core.error.call(this, laster);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})\n\t\t\t.bind('keyup keydown', function (e, data) {\n\t\t\t\tdata = $.vakata.dnd._get();\n\t\t\t\tif(data && data.data && data.data.jstree) {\n\t\t\t\t\tdata.helper.find('.jstree-copy:eq(0)')[ data.data.origin && (data.data.origin.settings.dnd.always_copy || (data.data.origin.settings.dnd.copy && (e.metaKey || e.ctrlKey))) ? 'show' : 'hide' ]();\n\t\t\t\t}\n\t\t\t});\n\t});\n\n\t// helpers\n\t(function ($) {\n\t\t// private variable\n\t\tvar vakata_dnd = {\n\t\t\telement\t: false,\n\t\t\ttarget\t: false,\n\t\t\tis_down\t: false,\n\t\t\tis_drag\t: false,\n\t\t\thelper\t: false,\n\t\t\thelper_w: 0,\n\t\t\tdata\t: false,\n\t\t\tinit_x\t: 0,\n\t\t\tinit_y\t: 0,\n\t\t\tscroll_l: 0,\n\t\t\tscroll_t: 0,\n\t\t\tscroll_e: false,\n\t\t\tscroll_i: false,\n\t\t\tis_touch: false\n\t\t};\n\t\t$.vakata.dnd = {\n\t\t\tsettings : {\n\t\t\t\tscroll_speed\t\t: 10,\n\t\t\t\tscroll_proximity\t: 20,\n\t\t\t\thelper_left\t\t\t: 5,\n\t\t\t\thelper_top\t\t\t: 10,\n\t\t\t\tthreshold\t\t\t: 5,\n\t\t\t\tthreshold_touch\t\t: 50\n\t\t\t},\n\t\t\t_trigger : function (event_name, e) {\n\t\t\t\tvar data = $.vakata.dnd._get();\n\t\t\t\tdata.event = e;\n\t\t\t\t$(document).triggerHandler(\"dnd_\" + event_name + \".vakata\", data);\n\t\t\t},\n\t\t\t_get : function () {\n\t\t\t\treturn {\n\t\t\t\t\t\"data\"\t\t: vakata_dnd.data,\n\t\t\t\t\t\"element\"\t: vakata_dnd.element,\n\t\t\t\t\t\"helper\"\t: vakata_dnd.helper\n\t\t\t\t};\n\t\t\t},\n\t\t\t_clean : function () {\n\t\t\t\tif(vakata_dnd.helper) { vakata_dnd.helper.remove(); }\n\t\t\t\tif(vakata_dnd.scroll_i) { clearInterval(vakata_dnd.scroll_i); vakata_dnd.scroll_i = false; }\n\t\t\t\tvakata_dnd = {\n\t\t\t\t\telement\t: false,\n\t\t\t\t\ttarget\t: false,\n\t\t\t\t\tis_down\t: false,\n\t\t\t\t\tis_drag\t: false,\n\t\t\t\t\thelper\t: false,\n\t\t\t\t\thelper_w: 0,\n\t\t\t\t\tdata\t: false,\n\t\t\t\t\tinit_x\t: 0,\n\t\t\t\t\tinit_y\t: 0,\n\t\t\t\t\tscroll_l: 0,\n\t\t\t\t\tscroll_t: 0,\n\t\t\t\t\tscroll_e: false,\n\t\t\t\t\tscroll_i: false,\n\t\t\t\t\tis_touch: false\n\t\t\t\t};\n\t\t\t\t$(document).off(\"mousemove touchmove\", $.vakata.dnd.drag);\n\t\t\t\t$(document).off(\"mouseup touchend\", $.vakata.dnd.stop);\n\t\t\t},\n\t\t\t_scroll : function (init_only) {\n\t\t\t\tif(!vakata_dnd.scroll_e || (!vakata_dnd.scroll_l && !vakata_dnd.scroll_t)) {\n\t\t\t\t\tif(vakata_dnd.scroll_i) { clearInterval(vakata_dnd.scroll_i); vakata_dnd.scroll_i = false; }\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif(!vakata_dnd.scroll_i) {\n\t\t\t\t\tvakata_dnd.scroll_i = setInterval($.vakata.dnd._scroll, 100);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif(init_only === true) { return false; }\n\n\t\t\t\tvar i = vakata_dnd.scroll_e.scrollTop(),\n\t\t\t\t\tj = vakata_dnd.scroll_e.scrollLeft();\n\t\t\t\tvakata_dnd.scroll_e.scrollTop(i + vakata_dnd.scroll_t * $.vakata.dnd.settings.scroll_speed);\n\t\t\t\tvakata_dnd.scroll_e.scrollLeft(j + vakata_dnd.scroll_l * $.vakata.dnd.settings.scroll_speed);\n\t\t\t\tif(i !== vakata_dnd.scroll_e.scrollTop() || j !== vakata_dnd.scroll_e.scrollLeft()) {\n\t\t\t\t\t/**\n\t\t\t\t\t * triggered on the document when a drag causes an element to scroll\n\t\t\t\t\t * @event\n\t\t\t\t\t * @plugin dnd\n\t\t\t\t\t * @name dnd_scroll.vakata\n\t\t\t\t\t * @param {Mixed} data any data supplied with the call to $.vakata.dnd.start\n\t\t\t\t\t * @param {DOM} element the DOM element being dragged\n\t\t\t\t\t * @param {jQuery} helper the helper shown next to the mouse\n\t\t\t\t\t * @param {jQuery} event the element that is scrolling\n\t\t\t\t\t */\n\t\t\t\t\t$.vakata.dnd._trigger(\"scroll\", vakata_dnd.scroll_e);\n\t\t\t\t}\n\t\t\t},\n\t\t\tstart : function (e, data, html) {\n\t\t\t\tif(e.type === \"touchstart\" && e.originalEvent && e.originalEvent.changedTouches && e.originalEvent.changedTouches[0]) {\n\t\t\t\t\te.pageX = e.originalEvent.changedTouches[0].pageX;\n\t\t\t\t\te.pageY = e.originalEvent.changedTouches[0].pageY;\n\t\t\t\t\te.target = document.elementFromPoint(e.originalEvent.changedTouches[0].pageX - window.pageXOffset, e.originalEvent.changedTouches[0].pageY - window.pageYOffset);\n\t\t\t\t}\n\t\t\t\tif(vakata_dnd.is_drag) { $.vakata.dnd.stop({}); }\n\t\t\t\ttry {\n\t\t\t\t\te.currentTarget.unselectable = \"on\";\n\t\t\t\t\te.currentTarget.onselectstart = function() { return false; };\n\t\t\t\t\tif(e.currentTarget.style) { e.currentTarget.style.MozUserSelect = \"none\"; }\n\t\t\t\t} catch(ignore) { }\n\t\t\t\tvakata_dnd.init_x\t= e.pageX;\n\t\t\t\tvakata_dnd.init_y\t= e.pageY;\n\t\t\t\tvakata_dnd.data\t\t= data;\n\t\t\t\tvakata_dnd.is_down\t= true;\n\t\t\t\tvakata_dnd.element\t= e.currentTarget;\n\t\t\t\tvakata_dnd.target\t= e.target;\n\t\t\t\tvakata_dnd.is_touch\t= e.type === \"touchstart\";\n\t\t\t\tif(html !== false) {\n\t\t\t\t\tvakata_dnd.helper = $(\"<div id='vakata-dnd'></div>\").html(html).css({\n\t\t\t\t\t\t\"display\"\t\t: \"block\",\n\t\t\t\t\t\t\"margin\"\t\t: \"0\",\n\t\t\t\t\t\t\"padding\"\t\t: \"0\",\n\t\t\t\t\t\t\"position\"\t\t: \"absolute\",\n\t\t\t\t\t\t\"top\"\t\t\t: \"-2000px\",\n\t\t\t\t\t\t\"lineHeight\"\t: \"16px\",\n\t\t\t\t\t\t\"zIndex\"\t\t: \"10000\"\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\t$(document).bind(\"mousemove touchmove\", $.vakata.dnd.drag);\n\t\t\t\t$(document).bind(\"mouseup touchend\", $.vakata.dnd.stop);\n\t\t\t\treturn false;\n\t\t\t},\n\t\t\tdrag : function (e) {\n\t\t\t\tif(e.type === \"touchmove\" && e.originalEvent && e.originalEvent.changedTouches && e.originalEvent.changedTouches[0]) {\n\t\t\t\t\te.pageX = e.originalEvent.changedTouches[0].pageX;\n\t\t\t\t\te.pageY = e.originalEvent.changedTouches[0].pageY;\n\t\t\t\t\te.target = document.elementFromPoint(e.originalEvent.changedTouches[0].pageX - window.pageXOffset, e.originalEvent.changedTouches[0].pageY - window.pageYOffset);\n\t\t\t\t}\n\t\t\t\tif(!vakata_dnd.is_down) { return; }\n\t\t\t\tif(!vakata_dnd.is_drag) {\n\t\t\t\t\tif(\n\t\t\t\t\t\tMath.abs(e.pageX - vakata_dnd.init_x) > (vakata_dnd.is_touch ? $.vakata.dnd.settings.threshold_touch : $.vakata.dnd.settings.threshold) ||\n\t\t\t\t\t\tMath.abs(e.pageY - vakata_dnd.init_y) > (vakata_dnd.is_touch ? $.vakata.dnd.settings.threshold_touch : $.vakata.dnd.settings.threshold)\n\t\t\t\t\t) {\n\t\t\t\t\t\tif(vakata_dnd.helper) {\n\t\t\t\t\t\t\tvakata_dnd.helper.appendTo(\"body\");\n\t\t\t\t\t\t\tvakata_dnd.helper_w = vakata_dnd.helper.outerWidth();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvakata_dnd.is_drag = true;\n\t\t\t\t\t\t/**\n\t\t\t\t\t\t * triggered on the document when a drag starts\n\t\t\t\t\t\t * @event\n\t\t\t\t\t\t * @plugin dnd\n\t\t\t\t\t\t * @name dnd_start.vakata\n\t\t\t\t\t\t * @param {Mixed} data any data supplied with the call to $.vakata.dnd.start\n\t\t\t\t\t\t * @param {DOM} element the DOM element being dragged\n\t\t\t\t\t\t * @param {jQuery} helper the helper shown next to the mouse\n\t\t\t\t\t\t * @param {Object} event the event that caused the start (probably mousemove)\n\t\t\t\t\t\t */\n\t\t\t\t\t\t$.vakata.dnd._trigger(\"start\", e);\n\t\t\t\t\t}\n\t\t\t\t\telse { return; }\n\t\t\t\t}\n\n\t\t\t\tvar d  = false, w  = false,\n\t\t\t\t\tdh = false, wh = false,\n\t\t\t\t\tdw = false, ww = false,\n\t\t\t\t\tdt = false, dl = false,\n\t\t\t\t\tht = false, hl = false;\n\n\t\t\t\tvakata_dnd.scroll_t = 0;\n\t\t\t\tvakata_dnd.scroll_l = 0;\n\t\t\t\tvakata_dnd.scroll_e = false;\n\t\t\t\t$($(e.target).parentsUntil(\"body\").addBack().get().reverse())\n\t\t\t\t\t.filter(function () {\n\t\t\t\t\t\treturn\t(/^auto|scroll$/).test($(this).css(\"overflow\")) &&\n\t\t\t\t\t\t\t\t(this.scrollHeight > this.offsetHeight || this.scrollWidth > this.offsetWidth);\n\t\t\t\t\t})\n\t\t\t\t\t.each(function () {\n\t\t\t\t\t\tvar t = $(this), o = t.offset();\n\t\t\t\t\t\tif(this.scrollHeight > this.offsetHeight) {\n\t\t\t\t\t\t\tif(o.top + t.height() - e.pageY < $.vakata.dnd.settings.scroll_proximity)\t{ vakata_dnd.scroll_t = 1; }\n\t\t\t\t\t\t\tif(e.pageY - o.top < $.vakata.dnd.settings.scroll_proximity)\t\t\t\t{ vakata_dnd.scroll_t = -1; }\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(this.scrollWidth > this.offsetWidth) {\n\t\t\t\t\t\t\tif(o.left + t.width() - e.pageX < $.vakata.dnd.settings.scroll_proximity)\t{ vakata_dnd.scroll_l = 1; }\n\t\t\t\t\t\t\tif(e.pageX - o.left < $.vakata.dnd.settings.scroll_proximity)\t\t\t\t{ vakata_dnd.scroll_l = -1; }\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(vakata_dnd.scroll_t || vakata_dnd.scroll_l) {\n\t\t\t\t\t\t\tvakata_dnd.scroll_e = $(this);\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\tif(!vakata_dnd.scroll_e) {\n\t\t\t\t\td  = $(document); w = $(window);\n\t\t\t\t\tdh = d.height(); wh = w.height();\n\t\t\t\t\tdw = d.width(); ww = w.width();\n\t\t\t\t\tdt = d.scrollTop(); dl = d.scrollLeft();\n\t\t\t\t\tif(dh > wh && e.pageY - dt < $.vakata.dnd.settings.scroll_proximity)\t\t{ vakata_dnd.scroll_t = -1;  }\n\t\t\t\t\tif(dh > wh && wh - (e.pageY - dt) < $.vakata.dnd.settings.scroll_proximity)\t{ vakata_dnd.scroll_t = 1; }\n\t\t\t\t\tif(dw > ww && e.pageX - dl < $.vakata.dnd.settings.scroll_proximity)\t\t{ vakata_dnd.scroll_l = -1; }\n\t\t\t\t\tif(dw > ww && ww - (e.pageX - dl) < $.vakata.dnd.settings.scroll_proximity)\t{ vakata_dnd.scroll_l = 1; }\n\t\t\t\t\tif(vakata_dnd.scroll_t || vakata_dnd.scroll_l) {\n\t\t\t\t\t\tvakata_dnd.scroll_e = d;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(vakata_dnd.scroll_e) { $.vakata.dnd._scroll(true); }\n\n\t\t\t\tif(vakata_dnd.helper) {\n\t\t\t\t\tht = parseInt(e.pageY + $.vakata.dnd.settings.helper_top, 10);\n\t\t\t\t\thl = parseInt(e.pageX + $.vakata.dnd.settings.helper_left, 10);\n\t\t\t\t\tif(dh && ht + 25 > dh) { ht = dh - 50; }\n\t\t\t\t\tif(dw && hl + vakata_dnd.helper_w > dw) { hl = dw - (vakata_dnd.helper_w + 2); }\n\t\t\t\t\tvakata_dnd.helper.css({\n\t\t\t\t\t\tleft\t: hl + \"px\",\n\t\t\t\t\t\ttop\t\t: ht + \"px\"\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\t/**\n\t\t\t\t * triggered on the document when a drag is in progress\n\t\t\t\t * @event\n\t\t\t\t * @plugin dnd\n\t\t\t\t * @name dnd_move.vakata\n\t\t\t\t * @param {Mixed} data any data supplied with the call to $.vakata.dnd.start\n\t\t\t\t * @param {DOM} element the DOM element being dragged\n\t\t\t\t * @param {jQuery} helper the helper shown next to the mouse\n\t\t\t\t * @param {Object} event the event that caused this to trigger (most likely mousemove)\n\t\t\t\t */\n\t\t\t\t$.vakata.dnd._trigger(\"move\", e);\n\t\t\t\treturn false;\n\t\t\t},\n\t\t\tstop : function (e) {\n\t\t\t\tif(e.type === \"touchend\" && e.originalEvent && e.originalEvent.changedTouches && e.originalEvent.changedTouches[0]) {\n\t\t\t\t\te.pageX = e.originalEvent.changedTouches[0].pageX;\n\t\t\t\t\te.pageY = e.originalEvent.changedTouches[0].pageY;\n\t\t\t\t\te.target = document.elementFromPoint(e.originalEvent.changedTouches[0].pageX - window.pageXOffset, e.originalEvent.changedTouches[0].pageY - window.pageYOffset);\n\t\t\t\t}\n\t\t\t\tif(vakata_dnd.is_drag) {\n\t\t\t\t\t/**\n\t\t\t\t\t * triggered on the document when a drag stops (the dragged element is dropped)\n\t\t\t\t\t * @event\n\t\t\t\t\t * @plugin dnd\n\t\t\t\t\t * @name dnd_stop.vakata\n\t\t\t\t\t * @param {Mixed} data any data supplied with the call to $.vakata.dnd.start\n\t\t\t\t\t * @param {DOM} element the DOM element being dragged\n\t\t\t\t\t * @param {jQuery} helper the helper shown next to the mouse\n\t\t\t\t\t * @param {Object} event the event that caused the stop\n\t\t\t\t\t */\n\t\t\t\t\t$.vakata.dnd._trigger(\"stop\", e);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif(e.type === \"touchend\" && e.target === vakata_dnd.target) {\n\t\t\t\t\t\tvar to = setTimeout(function () { $(e.target).click(); }, 100);\n\t\t\t\t\t\t$(e.target).one('click', function() { if(to) { clearTimeout(to); } });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t$.vakata.dnd._clean();\n\t\t\t\treturn false;\n\t\t\t}\n\t\t};\n\t}($));\n\n\t// include the dnd plugin by default\n\t// $.jstree.defaults.plugins.push(\"dnd\");\n\n\n/**\n * ### Search plugin\n *\n * Adds search functionality to jsTree.\n */\n\n\t/**\n\t * stores all defaults for the search plugin\n\t * @name $.jstree.defaults.search\n\t * @plugin search\n\t */\n\t$.jstree.defaults.search = {\n\t\t/**\n\t\t * a jQuery-like AJAX config, which jstree uses if a server should be queried for results. \n\t\t * \n\t\t * A `str` (which is the search string) parameter will be added with the request. The expected result is a JSON array with nodes that need to be opened so that matching nodes will be revealed.\n\t\t * Leave this setting as `false` to not query the server. You can also set this to a function, which will be invoked in the instance's scope and receive 2 parameters - the search string and the callback to call with the array of nodes to load.\n\t\t * @name $.jstree.defaults.search.ajax\n\t\t * @plugin search\n\t\t */\n\t\tajax : false,\n\t\t/**\n\t\t * Indicates if the search should be fuzzy or not (should `chnd3` match `child node 3`). Default is `false`.\n\t\t * @name $.jstree.defaults.search.fuzzy\n\t\t * @plugin search\n\t\t */\n\t\tfuzzy : false,\n\t\t/**\n\t\t * Indicates if the search should be case sensitive. Default is `false`.\n\t\t * @name $.jstree.defaults.search.case_sensitive\n\t\t * @plugin search\n\t\t */\n\t\tcase_sensitive : false,\n\t\t/**\n\t\t * Indicates if the tree should be filtered to show only matching nodes (keep in mind this can be a heavy on large trees in old browsers). Default is `false`.\n\t\t * @name $.jstree.defaults.search.show_only_matches\n\t\t * @plugin search\n\t\t */\n\t\tshow_only_matches : false,\n\t\t/**\n\t\t * Indicates if all nodes opened to reveal the search result, should be closed when the search is cleared or a new search is performed. Default is `true`.\n\t\t * @name $.jstree.defaults.search.close_opened_onclear\n\t\t * @plugin search\n\t\t */\n\t\tclose_opened_onclear : true,\n\t\t/**\n\t\t * Indicates if only leaf nodes should be included in search results. Default is `false`.\n\t\t * @name $.jstree.defaults.search.search_leaves_only\n\t\t * @plugin search\n\t\t */\n\t\tsearch_leaves_only : false,\n\t\t/**\n\t\t * If set to a function it wil be called in the instance's scope with two arguments - search string and node (where node will be every node in the structure, so use with caution).\n\t\t * If the function returns a truthy value the node will be considered a match (it might not be displayed if search_only_leaves is set to true and the node is not a leaf). Default is `false`.\n\t\t * @name $.jstree.defaults.search.search_callback\n\t\t * @plugin search\n\t\t */\n\t\tsearch_callback : false\n\t};\n\n\t$.jstree.plugins.search = function (options, parent) {\n\t\tthis.bind = function () {\n\t\t\tparent.bind.call(this);\n\n\t\t\tthis._data.search.str = \"\";\n\t\t\tthis._data.search.dom = $();\n\t\t\tthis._data.search.res = [];\n\t\t\tthis._data.search.opn = [];\n\n\t\t\tthis.element.on('before_open.jstree', $.proxy(function (e, data) {\n\t\t\t\tvar i, j, f, r = this._data.search.res, s = [], o = $();\n\t\t\t\tif(r && r.length) {\n\t\t\t\t\tthis._data.search.dom = $(this.element[0].querySelectorAll('#' + $.map(r, function (v) { return \"0123456789\".indexOf(v[0]) !== -1 ? '\\\\3' + v[0] + ' ' + v.substr(1).replace($.jstree.idregex,'\\\\$&') : v.replace($.jstree.idregex,'\\\\$&'); }).join(', #')));\n\t\t\t\t\tthis._data.search.dom.children(\".jstree-anchor\").addClass('jstree-search');\n\t\t\t\t\tif(this.settings.search.show_only_matches && this._data.search.res.length) {\n\t\t\t\t\t\tfor(i = 0, j = r.length; i < j; i++) {\n\t\t\t\t\t\t\ts = s.concat(this.get_node(r[i]).parents);\n\t\t\t\t\t\t}\n\t\t\t\t\t\ts = $.vakata.array_remove_item($.vakata.array_unique(s),'#');\n\t\t\t\t\t\to = s.length ? $(this.element[0].querySelectorAll('#' + $.map(s, function (v) { return \"0123456789\".indexOf(v[0]) !== -1 ? '\\\\3' + v[0] + ' ' + v.substr(1).replace($.jstree.idregex,'\\\\$&') : v.replace($.jstree.idregex,'\\\\$&'); }).join(', #'))) : $();\n\n\t\t\t\t\t\tthis.element.find(\".jstree-node\").hide().filter('.jstree-last').filter(function() { return this.nextSibling; }).removeClass('jstree-last');\n\t\t\t\t\t\to = o.add(this._data.search.dom);\n\t\t\t\t\t\to.parentsUntil(\".jstree\").addBack().show()\n\t\t\t\t\t\t\t.filter(\".jstree-children\").each(function () { $(this).children(\".jstree-node:visible\").eq(-1).addClass(\"jstree-last\"); });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}, this));\n\t\t\tif(this.settings.search.show_only_matches) {\n\t\t\t\tthis.element\n\t\t\t\t\t.on(\"search.jstree\", function (e, data) {\n\t\t\t\t\t\tif(data.nodes.length) {\n\t\t\t\t\t\t\t$(this).find(\".jstree-node\").hide().filter('.jstree-last').filter(function() { return this.nextSibling; }).removeClass('jstree-last');\n\t\t\t\t\t\t\tdata.nodes.parentsUntil(\".jstree\").addBack().show()\n\t\t\t\t\t\t\t\t.filter(\".jstree-children\").each(function () { $(this).children(\".jstree-node:visible\").eq(-1).addClass(\"jstree-last\"); });\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t\t.on(\"clear_search.jstree\", function (e, data) {\n\t\t\t\t\t\tif(data.nodes.length) {\n\t\t\t\t\t\t\t$(this).find(\".jstree-node\").css(\"display\",\"\").filter('.jstree-last').filter(function() { return this.nextSibling; }).removeClass('jstree-last');\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t}\n\t\t};\n\t\t/**\n\t\t * used to search the tree nodes for a given string\n\t\t * @name search(str [, skip_async])\n\t\t * @param {String} str the search string\n\t\t * @param {Boolean} skip_async if set to true server will not be queried even if configured\n\t\t * @plugin search\n\t\t * @trigger search.jstree\n\t\t */\n\t\tthis.search = function (str, skip_async) {\n\t\t\tif(str === false || $.trim(str.toString()) === \"\") {\n\t\t\t\treturn this.clear_search();\n\t\t\t}\n\t\t\tstr = str.toString();\n\t\t\tvar s = this.settings.search,\n\t\t\t\ta = s.ajax ? s.ajax : false,\n\t\t\t\tf = null,\n\t\t\t\tr = [],\n\t\t\t\tp = [], i, j;\n\t\t\tif(this._data.search.res.length) {\n\t\t\t\tthis.clear_search();\n\t\t\t}\n\t\t\tif(!skip_async && a !== false) {\n\t\t\t\tif($.isFunction(a)) {\n\t\t\t\t\treturn a.call(this, str, $.proxy(function (d) {\n\t\t\t\t\t\t\tif(d && d.d) { d = d.d; }\n\t\t\t\t\t\t\tthis._load_nodes(!$.isArray(d) ? [] : $.vakata.array_unique(d), function () {\n\t\t\t\t\t\t\t\tthis.search(str, true);\n\t\t\t\t\t\t\t}, true);\n\t\t\t\t\t\t}, this));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ta = $.extend({}, a);\n\t\t\t\t\tif(!a.data) { a.data = {}; }\n\t\t\t\t\ta.data.str = str;\n\t\t\t\t\treturn $.ajax(a)\n\t\t\t\t\t\t.fail($.proxy(function () {\n\t\t\t\t\t\t\tthis._data.core.last_error = { 'error' : 'ajax', 'plugin' : 'search', 'id' : 'search_01', 'reason' : 'Could not load search parents', 'data' : JSON.stringify(a) };\n\t\t\t\t\t\t\tthis.settings.core.error.call(this, this._data.core.last_error);\n\t\t\t\t\t\t}, this))\n\t\t\t\t\t\t.done($.proxy(function (d) {\n\t\t\t\t\t\t\tif(d && d.d) { d = d.d; }\n\t\t\t\t\t\t\tthis._load_nodes(!$.isArray(d) ? [] : $.vakata.array_unique(d), function () {\n\t\t\t\t\t\t\t\tthis.search(str, true);\n\t\t\t\t\t\t\t}, true);\n\t\t\t\t\t\t}, this));\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._data.search.str = str;\n\t\t\tthis._data.search.dom = $();\n\t\t\tthis._data.search.res = [];\n\t\t\tthis._data.search.opn = [];\n\n\t\t\tf = new $.vakata.search(str, true, { caseSensitive : s.case_sensitive, fuzzy : s.fuzzy });\n\n\t\t\t$.each(this._model.data, function (i, v) {\n\t\t\t\tif(v.text && ( (s.search_callback && s.search_callback.call(this, str, v)) || (!s.search_callback && f.search(v.text).isMatch) ) && (!s.search_leaves_only || (v.state.loaded && v.children.length === 0)) ) {\n\t\t\t\t\tr.push(i);\n\t\t\t\t\tp = p.concat(v.parents);\n\t\t\t\t}\n\t\t\t});\n\t\t\tif(r.length) {\n\t\t\t\tp = $.vakata.array_unique(p);\n\t\t\t\tthis._search_open(p);\n\t\t\t\tthis._data.search.dom = $(this.element[0].querySelectorAll('#' + $.map(r, function (v) { return \"0123456789\".indexOf(v[0]) !== -1 ? '\\\\3' + v[0] + ' ' + v.substr(1).replace($.jstree.idregex,'\\\\$&') : v.replace($.jstree.idregex,'\\\\$&'); }).join(', #')));\n\t\t\t\tthis._data.search.res = r;\n\t\t\t\tthis._data.search.dom.children(\".jstree-anchor\").addClass('jstree-search');\n\t\t\t}\n\t\t\t/**\n\t\t\t * triggered after search is complete\n\t\t\t * @event\n\t\t\t * @name search.jstree\n\t\t\t * @param {jQuery} nodes a jQuery collection of matching nodes\n\t\t\t * @param {String} str the search string\n\t\t\t * @param {Array} res a collection of objects represeing the matching nodes\n\t\t\t * @plugin search\n\t\t\t */\n\t\t\tthis.trigger('search', { nodes : this._data.search.dom, str : str, res : this._data.search.res });\n\t\t};\n\t\t/**\n\t\t * used to clear the last search (removes classes and shows all nodes if filtering is on)\n\t\t * @name clear_search()\n\t\t * @plugin search\n\t\t * @trigger clear_search.jstree\n\t\t */\n\t\tthis.clear_search = function () {\n\t\t\tthis._data.search.dom.children(\".jstree-anchor\").removeClass(\"jstree-search\");\n\t\t\tif(this.settings.search.close_opened_onclear) {\n\t\t\t\tthis.close_node(this._data.search.opn, 0);\n\t\t\t}\n\t\t\t/**\n\t\t\t * triggered after search is complete\n\t\t\t * @event\n\t\t\t * @name clear_search.jstree\n\t\t\t * @param {jQuery} nodes a jQuery collection of matching nodes (the result from the last search)\n\t\t\t * @param {String} str the search string (the last search string)\n\t\t\t * @param {Array} res a collection of objects represeing the matching nodes (the result from the last search)\n\t\t\t * @plugin search\n\t\t\t */\n\t\t\tthis.trigger('clear_search', { 'nodes' : this._data.search.dom, str : this._data.search.str, res : this._data.search.res });\n\t\t\tthis._data.search.str = \"\";\n\t\t\tthis._data.search.res = [];\n\t\t\tthis._data.search.opn = [];\n\t\t\tthis._data.search.dom = $();\n\t\t};\n\t\t/**\n\t\t * opens nodes that need to be opened to reveal the search results. Used only internally.\n\t\t * @private\n\t\t * @name _search_open(d)\n\t\t * @param {Array} d an array of node IDs\n\t\t * @plugin search\n\t\t */\n\t\tthis._search_open = function (d) {\n\t\t\tvar t = this;\n\t\t\t$.each(d.concat([]), function (i, v) {\n\t\t\t\tif(v === \"#\") { return true; }\n\t\t\t\ttry { v = $('#' + v.replace($.jstree.idregex,'\\\\$&'), t.element); } catch(ignore) { }\n\t\t\t\tif(v && v.length) {\n\t\t\t\t\tif(t.is_closed(v)) {\n\t\t\t\t\t\tt._data.search.opn.push(v[0].id);\n\t\t\t\t\t\tt.open_node(v, function () { t._search_open(d); }, 0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t};\n\t};\n\n\t// helpers\n\t(function ($) {\n\t\t// from http://kiro.me/projects/fuse.html\n\t\t$.vakata.search = function(pattern, txt, options) {\n\t\t\toptions = options || {};\n\t\t\tif(options.fuzzy !== false) {\n\t\t\t\toptions.fuzzy = true;\n\t\t\t}\n\t\t\tpattern = options.caseSensitive ? pattern : pattern.toLowerCase();\n\t\t\tvar MATCH_LOCATION\t= options.location || 0,\n\t\t\t\tMATCH_DISTANCE\t= options.distance || 100,\n\t\t\t\tMATCH_THRESHOLD\t= options.threshold || 0.6,\n\t\t\t\tpatternLen = pattern.length,\n\t\t\t\tmatchmask, pattern_alphabet, match_bitapScore, search;\n\t\t\tif(patternLen > 32) {\n\t\t\t\toptions.fuzzy = false;\n\t\t\t}\n\t\t\tif(options.fuzzy) {\n\t\t\t\tmatchmask = 1 << (patternLen - 1);\n\t\t\t\tpattern_alphabet = (function () {\n\t\t\t\t\tvar mask = {},\n\t\t\t\t\t\ti = 0;\n\t\t\t\t\tfor (i = 0; i < patternLen; i++) {\n\t\t\t\t\t\tmask[pattern.charAt(i)] = 0;\n\t\t\t\t\t}\n\t\t\t\t\tfor (i = 0; i < patternLen; i++) {\n\t\t\t\t\t\tmask[pattern.charAt(i)] |= 1 << (patternLen - i - 1);\n\t\t\t\t\t}\n\t\t\t\t\treturn mask;\n\t\t\t\t}());\n\t\t\t\tmatch_bitapScore = function (e, x) {\n\t\t\t\t\tvar accuracy = e / patternLen,\n\t\t\t\t\t\tproximity = Math.abs(MATCH_LOCATION - x);\n\t\t\t\t\tif(!MATCH_DISTANCE) {\n\t\t\t\t\t\treturn proximity ? 1.0 : accuracy;\n\t\t\t\t\t}\n\t\t\t\t\treturn accuracy + (proximity / MATCH_DISTANCE);\n\t\t\t\t};\n\t\t\t}\n\t\t\tsearch = function (text) {\n\t\t\t\ttext = options.caseSensitive ? text : text.toLowerCase();\n\t\t\t\tif(pattern === text || text.indexOf(pattern) !== -1) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tisMatch: true,\n\t\t\t\t\t\tscore: 0\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tif(!options.fuzzy) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tisMatch: false,\n\t\t\t\t\t\tscore: 1\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tvar i, j,\n\t\t\t\t\ttextLen = text.length,\n\t\t\t\t\tscoreThreshold = MATCH_THRESHOLD,\n\t\t\t\t\tbestLoc = text.indexOf(pattern, MATCH_LOCATION),\n\t\t\t\t\tbinMin, binMid,\n\t\t\t\t\tbinMax = patternLen + textLen,\n\t\t\t\t\tlastRd, start, finish, rd, charMatch,\n\t\t\t\t\tscore = 1,\n\t\t\t\t\tlocations = [];\n\t\t\t\tif (bestLoc !== -1) {\n\t\t\t\t\tscoreThreshold = Math.min(match_bitapScore(0, bestLoc), scoreThreshold);\n\t\t\t\t\tbestLoc = text.lastIndexOf(pattern, MATCH_LOCATION + patternLen);\n\t\t\t\t\tif (bestLoc !== -1) {\n\t\t\t\t\t\tscoreThreshold = Math.min(match_bitapScore(0, bestLoc), scoreThreshold);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbestLoc = -1;\n\t\t\t\tfor (i = 0; i < patternLen; i++) {\n\t\t\t\t\tbinMin = 0;\n\t\t\t\t\tbinMid = binMax;\n\t\t\t\t\twhile (binMin < binMid) {\n\t\t\t\t\t\tif (match_bitapScore(i, MATCH_LOCATION + binMid) <= scoreThreshold) {\n\t\t\t\t\t\t\tbinMin = binMid;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tbinMax = binMid;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbinMid = Math.floor((binMax - binMin) / 2 + binMin);\n\t\t\t\t\t}\n\t\t\t\t\tbinMax = binMid;\n\t\t\t\t\tstart = Math.max(1, MATCH_LOCATION - binMid + 1);\n\t\t\t\t\tfinish = Math.min(MATCH_LOCATION + binMid, textLen) + patternLen;\n\t\t\t\t\trd = new Array(finish + 2);\n\t\t\t\t\trd[finish + 1] = (1 << i) - 1;\n\t\t\t\t\tfor (j = finish; j >= start; j--) {\n\t\t\t\t\t\tcharMatch = pattern_alphabet[text.charAt(j - 1)];\n\t\t\t\t\t\tif (i === 0) {\n\t\t\t\t\t\t\trd[j] = ((rd[j + 1] << 1) | 1) & charMatch;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\trd[j] = ((rd[j + 1] << 1) | 1) & charMatch | (((lastRd[j + 1] | lastRd[j]) << 1) | 1) | lastRd[j + 1];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (rd[j] & matchmask) {\n\t\t\t\t\t\t\tscore = match_bitapScore(i, j - 1);\n\t\t\t\t\t\t\tif (score <= scoreThreshold) {\n\t\t\t\t\t\t\t\tscoreThreshold = score;\n\t\t\t\t\t\t\t\tbestLoc = j - 1;\n\t\t\t\t\t\t\t\tlocations.push(bestLoc);\n\t\t\t\t\t\t\t\tif (bestLoc > MATCH_LOCATION) {\n\t\t\t\t\t\t\t\t\tstart = Math.max(1, 2 * MATCH_LOCATION - bestLoc);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (match_bitapScore(i + 1, MATCH_LOCATION) > scoreThreshold) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tlastRd = rd;\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\tisMatch: bestLoc >= 0,\n\t\t\t\t\tscore: score\n\t\t\t\t};\n\t\t\t};\n\t\t\treturn txt === true ? { 'search' : search } : search(txt);\n\t\t};\n\t}($));\n\n\t// include the search plugin by default\n\t// $.jstree.defaults.plugins.push(\"search\");\n\n/**\n * ### Sort plugin\n *\n * Autmatically sorts all siblings in the tree according to a sorting function.\n */\n\n\t/**\n\t * the settings function used to sort the nodes.\n\t * It is executed in the tree's context, accepts two nodes as arguments and should return `1` or `-1`.\n\t * @name $.jstree.defaults.sort\n\t * @plugin sort\n\t */\n\t$.jstree.defaults.sort = function (a, b) {\n\t\t//return this.get_type(a) === this.get_type(b) ? (this.get_text(a) > this.get_text(b) ? 1 : -1) : this.get_type(a) >= this.get_type(b);\n\t\treturn this.get_text(a) > this.get_text(b) ? 1 : -1;\n\t};\n\t$.jstree.plugins.sort = function (options, parent) {\n\t\tthis.bind = function () {\n\t\t\tparent.bind.call(this);\n\t\t\tthis.element\n\t\t\t\t.on(\"model.jstree\", $.proxy(function (e, data) {\n\t\t\t\t\t\tthis.sort(data.parent, true);\n\t\t\t\t\t}, this))\n\t\t\t\t.on(\"rename_node.jstree create_node.jstree\", $.proxy(function (e, data) {\n\t\t\t\t\t\tthis.sort(data.parent || data.node.parent, false);\n\t\t\t\t\t\tthis.redraw_node(data.parent || data.node.parent, true);\n\t\t\t\t\t}, this))\n\t\t\t\t.on(\"move_node.jstree copy_node.jstree\", $.proxy(function (e, data) {\n\t\t\t\t\t\tthis.sort(data.parent, false);\n\t\t\t\t\t\tthis.redraw_node(data.parent, true);\n\t\t\t\t\t}, this));\n\t\t};\n\t\t/**\n\t\t * used to sort a node's children\n\t\t * @private\n\t\t * @name sort(obj [, deep])\n\t\t * @param  {mixed} obj the node\n\t\t * @param {Boolean} deep if set to `true` nodes are sorted recursively.\n\t\t * @plugin sort\n\t\t * @trigger search.jstree\n\t\t */\n\t\tthis.sort = function (obj, deep) {\n\t\t\tvar i, j;\n\t\t\tobj = this.get_node(obj);\n\t\t\tif(obj && obj.children && obj.children.length) {\n\t\t\t\tobj.children.sort($.proxy(this.settings.sort, this));\n\t\t\t\tif(deep) {\n\t\t\t\t\tfor(i = 0, j = obj.children_d.length; i < j; i++) {\n\t\t\t\t\t\tthis.sort(obj.children_d[i], false);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t};\n\n\t// include the sort plugin by default\n\t// $.jstree.defaults.plugins.push(\"sort\");\n\n/**\n * ### State plugin\n *\n * Saves the state of the tree (selected nodes, opened nodes) on the user's computer using available options (localStorage, cookies, etc)\n */\n\n\tvar to = false;\n\t/**\n\t * stores all defaults for the state plugin\n\t * @name $.jstree.defaults.state\n\t * @plugin state\n\t */\n\t$.jstree.defaults.state = {\n\t\t/**\n\t\t * A string for the key to use when saving the current tree (change if using multiple trees in your project). Defaults to `jstree`.\n\t\t * @name $.jstree.defaults.state.key\n\t\t * @plugin state\n\t\t */\n\t\tkey\t\t: 'jstree',\n\t\t/**\n\t\t * A space separated list of events that trigger a state save. Defaults to `changed.jstree open_node.jstree close_node.jstree`.\n\t\t * @name $.jstree.defaults.state.events\n\t\t * @plugin state\n\t\t */\n\t\tevents\t: 'changed.jstree open_node.jstree close_node.jstree',\n\t\t/**\n\t\t * Time in milliseconds after which the state will expire. Defaults to 'false' meaning - no expire.\n\t\t * @name $.jstree.defaults.state.ttl\n\t\t * @plugin state\n\t\t */\n\t\tttl\t\t: false,\n\t\t/**\n\t\t * A function that will be executed prior to restoring state with one argument - the state object. Can be used to clear unwanted parts of the state.\n\t\t * @name $.jstree.defaults.state.filter\n\t\t * @plugin state\n\t\t */\n\t\tfilter\t: false\n\t};\n\t$.jstree.plugins.state = function (options, parent) {\n\t\tthis.bind = function () {\n\t\t\tparent.bind.call(this);\n\t\t\tvar bind = $.proxy(function () {\n\t\t\t\tthis.element.on(this.settings.state.events, $.proxy(function () {\n\t\t\t\t\tif(to) { clearTimeout(to); }\n\t\t\t\t\tto = setTimeout($.proxy(function () { this.save_state(); }, this), 100);\n\t\t\t\t}, this));\n\t\t\t}, this);\n\t\t\tthis.element\n\t\t\t\t.on(\"ready.jstree\", $.proxy(function (e, data) {\n\t\t\t\t\t\tthis.element.one(\"restore_state.jstree\", bind);\n\t\t\t\t\t\tif(!this.restore_state()) { bind(); }\n\t\t\t\t\t}, this));\n\t\t};\n\t\t/**\n\t\t * save the state\n\t\t * @name save_state()\n\t\t * @plugin state\n\t\t */\n\t\tthis.save_state = function () {\n\t\t\tvar st = { 'state' : this.get_state(), 'ttl' : this.settings.state.ttl, 'sec' : +(new Date()) };\n\t\t\t$.vakata.storage.set(this.settings.state.key, JSON.stringify(st));\n\t\t};\n\t\t/**\n\t\t * restore the state from the user's computer\n\t\t * @name restore_state()\n\t\t * @plugin state\n\t\t */\n\t\tthis.restore_state = function () {\n\t\t\tvar k = $.vakata.storage.get(this.settings.state.key);\n\t\t\tif(!!k) { try { k = JSON.parse(k); } catch(ex) { return false; } }\n\t\t\tif(!!k && k.ttl && k.sec && +(new Date()) - k.sec > k.ttl) { return false; }\n\t\t\tif(!!k && k.state) { k = k.state; }\n\t\t\tif(!!k && $.isFunction(this.settings.state.filter)) { k = this.settings.state.filter.call(this, k); }\n\t\t\tif(!!k) {\n\t\t\t\tthis.element.one(\"set_state.jstree\", function (e, data) { data.instance.trigger('restore_state', { 'state' : $.extend(true, {}, k) }); });\n\t\t\t\tthis.set_state(k);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\t\t/**\n\t\t * clear the state on the user's computer\n\t\t * @name clear_state()\n\t\t * @plugin state\n\t\t */\n\t\tthis.clear_state = function () {\n\t\t\treturn $.vakata.storage.del(this.settings.state.key);\n\t\t};\n\t};\n\n\t(function ($, undefined) {\n\t\t$.vakata.storage = {\n\t\t\t// simply specifying the functions in FF throws an error\n\t\t\tset : function (key, val) { return window.localStorage.setItem(key, val); },\n\t\t\tget : function (key) { return window.localStorage.getItem(key); },\n\t\t\tdel : function (key) { return window.localStorage.removeItem(key); }\n\t\t};\n\t}($));\n\n\t// include the state plugin by default\n\t// $.jstree.defaults.plugins.push(\"state\");\n\n/**\n * ### Types plugin\n *\n * Makes it possible to add predefined types for groups of nodes, which make it possible to easily control nesting rules and icon for each group.\n */\n\n\t/**\n\t * An object storing all types as key value pairs, where the key is the type name and the value is an object that could contain following keys (all optional).\n\t * \n\t * * `max_children` the maximum number of immediate children this node type can have. Do not specify or set to `-1` for unlimited.\n\t * * `max_depth` the maximum number of nesting this node type can have. A value of `1` would mean that the node can have children, but no grandchildren. Do not specify or set to `-1` for unlimited.\n\t * * `valid_children` an array of node type strings, that nodes of this type can have as children. Do not specify or set to `-1` for no limits.\n\t * * `icon` a string - can be a path to an icon or a className, if using an image that is in the current directory use a `./` prefix, otherwise it will be detected as a class. Omit to use the default icon from your theme.\n\t *\n\t * There are two predefined types:\n\t * \n\t * * `#` represents the root of the tree, for example `max_children` would control the maximum number of root nodes.\n\t * * `default` represents the default node - any settings here will be applied to all nodes that do not have a type specified.\n\t * \n\t * @name $.jstree.defaults.types\n\t * @plugin types\n\t */\n\t$.jstree.defaults.types = {\n\t\t'#' : {},\n\t\t'default' : {}\n\t};\n\n\t$.jstree.plugins.types = function (options, parent) {\n\t\tthis.init = function (el, options) {\n\t\t\tvar i, j;\n\t\t\tif(options && options.types && options.types['default']) {\n\t\t\t\tfor(i in options.types) {\n\t\t\t\t\tif(i !== \"default\" && i !== \"#\" && options.types.hasOwnProperty(i)) {\n\t\t\t\t\t\tfor(j in options.types['default']) {\n\t\t\t\t\t\t\tif(options.types['default'].hasOwnProperty(j) && options.types[i][j] === undefined) {\n\t\t\t\t\t\t\t\toptions.types[i][j] = options.types['default'][j];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tparent.init.call(this, el, options);\n\t\t\tthis._model.data['#'].type = '#';\n\t\t};\n\t\tthis.refresh = function (skip_loading, forget_state) {\n\t\t\tparent.refresh.call(this, skip_loading, forget_state);\n\t\t\tthis._model.data['#'].type = '#';\n\t\t};\n\t\tthis.bind = function () {\n\t\t\tthis.element\n\t\t\t\t.on('model.jstree', $.proxy(function (e, data) {\n\t\t\t\t\t\tvar m = this._model.data,\n\t\t\t\t\t\t\tdpc = data.nodes,\n\t\t\t\t\t\t\tt = this.settings.types,\n\t\t\t\t\t\t\ti, j, c = 'default';\n\t\t\t\t\t\tfor(i = 0, j = dpc.length; i < j; i++) {\n\t\t\t\t\t\t\tc = 'default';\n\t\t\t\t\t\t\tif(m[dpc[i]].original && m[dpc[i]].original.type && t[m[dpc[i]].original.type]) {\n\t\t\t\t\t\t\t\tc = m[dpc[i]].original.type;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(m[dpc[i]].data && m[dpc[i]].data.jstree && m[dpc[i]].data.jstree.type && t[m[dpc[i]].data.jstree.type]) {\n\t\t\t\t\t\t\t\tc = m[dpc[i]].data.jstree.type;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tm[dpc[i]].type = c;\n\t\t\t\t\t\t\tif(m[dpc[i]].icon === true && t[c].icon !== undefined) {\n\t\t\t\t\t\t\t\tm[dpc[i]].icon = t[c].icon;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tm['#'].type = '#';\n\t\t\t\t\t}, this));\n\t\t\tparent.bind.call(this);\n\t\t};\n\t\tthis.get_json = function (obj, options, flat) {\n\t\t\tvar i, j,\n\t\t\t\tm = this._model.data,\n\t\t\t\topt = options ? $.extend(true, {}, options, {no_id:false}) : {},\n\t\t\t\ttmp = parent.get_json.call(this, obj, opt, flat);\n\t\t\tif(tmp === false) { return false; }\n\t\t\tif($.isArray(tmp)) {\n\t\t\t\tfor(i = 0, j = tmp.length; i < j; i++) {\n\t\t\t\t\ttmp[i].type = tmp[i].id && m[tmp[i].id] && m[tmp[i].id].type ? m[tmp[i].id].type : \"default\";\n\t\t\t\t\tif(options && options.no_id) {\n\t\t\t\t\t\tdelete tmp[i].id;\n\t\t\t\t\t\tif(tmp[i].li_attr && tmp[i].li_attr.id) {\n\t\t\t\t\t\t\tdelete tmp[i].li_attr.id;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttmp.type = tmp.id && m[tmp.id] && m[tmp.id].type ? m[tmp.id].type : \"default\";\n\t\t\t\tif(options && options.no_id) {\n\t\t\t\t\ttmp = this._delete_ids(tmp);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tmp;\n\t\t};\n\t\tthis._delete_ids = function (tmp) {\n\t\t\tif($.isArray(tmp)) {\n\t\t\t\tfor(var i = 0, j = tmp.length; i < j; i++) {\n\t\t\t\t\ttmp[i] = this._delete_ids(tmp[i]);\n\t\t\t\t}\n\t\t\t\treturn tmp;\n\t\t\t}\n\t\t\tdelete tmp.id;\n\t\t\tif(tmp.li_attr && tmp.li_attr.id) {\n\t\t\t\tdelete tmp.li_attr.id;\n\t\t\t}\n\t\t\tif(tmp.children && $.isArray(tmp.children)) {\n\t\t\t\ttmp.children = this._delete_ids(tmp.children);\n\t\t\t}\n\t\t\treturn tmp;\n\t\t};\n\t\tthis.check = function (chk, obj, par, pos, more) {\n\t\t\tif(parent.check.call(this, chk, obj, par, pos, more) === false) { return false; }\n\t\t\tobj = obj && obj.id ? obj : this.get_node(obj);\n\t\t\tpar = par && par.id ? par : this.get_node(par);\n\t\t\tvar m = obj && obj.id ? $.jstree.reference(obj.id) : null, tmp, d, i, j;\n\t\t\tm = m && m._model && m._model.data ? m._model.data : null;\n\t\t\tswitch(chk) {\n\t\t\t\tcase \"create_node\":\n\t\t\t\tcase \"move_node\":\n\t\t\t\tcase \"copy_node\":\n\t\t\t\t\tif(chk !== 'move_node' || $.inArray(obj.id, par.children) === -1) {\n\t\t\t\t\t\ttmp = this.get_rules(par);\n\t\t\t\t\t\tif(tmp.max_children !== undefined && tmp.max_children !== -1 && tmp.max_children === par.children.length) {\n\t\t\t\t\t\t\tthis._data.core.last_error = { 'error' : 'check', 'plugin' : 'types', 'id' : 'types_01', 'reason' : 'max_children prevents function: ' + chk, 'data' : JSON.stringify({ 'chk' : chk, 'pos' : pos, 'obj' : obj && obj.id ? obj.id : false, 'par' : par && par.id ? par.id : false }) };\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(tmp.valid_children !== undefined && tmp.valid_children !== -1 && $.inArray(obj.type, tmp.valid_children) === -1) {\n\t\t\t\t\t\t\tthis._data.core.last_error = { 'error' : 'check', 'plugin' : 'types', 'id' : 'types_02', 'reason' : 'valid_children prevents function: ' + chk, 'data' : JSON.stringify({ 'chk' : chk, 'pos' : pos, 'obj' : obj && obj.id ? obj.id : false, 'par' : par && par.id ? par.id : false }) };\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(m && obj.children_d && obj.parents) {\n\t\t\t\t\t\t\td = 0;\n\t\t\t\t\t\t\tfor(i = 0, j = obj.children_d.length; i < j; i++) {\n\t\t\t\t\t\t\t\td = Math.max(d, m[obj.children_d[i]].parents.length);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\td = d - obj.parents.length + 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(d <= 0 || d === undefined) { d = 1; }\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\tif(tmp.max_depth !== undefined && tmp.max_depth !== -1 && tmp.max_depth < d) {\n\t\t\t\t\t\t\t\tthis._data.core.last_error = { 'error' : 'check', 'plugin' : 'types', 'id' : 'types_03', 'reason' : 'max_depth prevents function: ' + chk, 'data' : JSON.stringify({ 'chk' : chk, 'pos' : pos, 'obj' : obj && obj.id ? obj.id : false, 'par' : par && par.id ? par.id : false }) };\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tpar = this.get_node(par.parent);\n\t\t\t\t\t\t\ttmp = this.get_rules(par);\n\t\t\t\t\t\t\td++;\n\t\t\t\t\t\t} while(par);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\treturn true;\n\t\t};\n\t\t/**\n\t\t * used to retrieve the type settings object for a node\n\t\t * @name get_rules(obj)\n\t\t * @param {mixed} obj the node to find the rules for\n\t\t * @return {Object}\n\t\t * @plugin types\n\t\t */\n\t\tthis.get_rules = function (obj) {\n\t\t\tobj = this.get_node(obj);\n\t\t\tif(!obj) { return false; }\n\t\t\tvar tmp = this.get_type(obj, true);\n\t\t\tif(tmp.max_depth === undefined) { tmp.max_depth = -1; }\n\t\t\tif(tmp.max_children === undefined) { tmp.max_children = -1; }\n\t\t\tif(tmp.valid_children === undefined) { tmp.valid_children = -1; }\n\t\t\treturn tmp;\n\t\t};\n\t\t/**\n\t\t * used to retrieve the type string or settings object for a node\n\t\t * @name get_type(obj [, rules])\n\t\t * @param {mixed} obj the node to find the rules for\n\t\t * @param {Boolean} rules if set to `true` instead of a string the settings object will be returned\n\t\t * @return {String|Object}\n\t\t * @plugin types\n\t\t */\n\t\tthis.get_type = function (obj, rules) {\n\t\t\tobj = this.get_node(obj);\n\t\t\treturn (!obj) ? false : ( rules ? $.extend({ 'type' : obj.type }, this.settings.types[obj.type]) : obj.type);\n\t\t};\n\t\t/**\n\t\t * used to change a node's type\n\t\t * @name set_type(obj, type)\n\t\t * @param {mixed} obj the node to change\n\t\t * @param {String} type the new type\n\t\t * @plugin types\n\t\t */\n\t\tthis.set_type = function (obj, type) {\n\t\t\tvar t, t1, t2, old_type, old_icon;\n\t\t\tif($.isArray(obj)) {\n\t\t\t\tobj = obj.slice();\n\t\t\t\tfor(t1 = 0, t2 = obj.length; t1 < t2; t1++) {\n\t\t\t\t\tthis.set_type(obj[t1], type);\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tt = this.settings.types;\n\t\t\tobj = this.get_node(obj);\n\t\t\tif(!t[type] || !obj) { return false; }\n\t\t\told_type = obj.type;\n\t\t\told_icon = this.get_icon(obj);\n\t\t\tobj.type = type;\n\t\t\tif(old_icon === true || (t[old_type] && t[old_type].icon && old_icon === t[old_type].icon)) {\n\t\t\t\tthis.set_icon(obj, t[type].icon !== undefined ? t[type].icon : true);\n\t\t\t}\n\t\t\treturn true;\n\t\t};\n\t};\n\t// include the types plugin by default\n\t// $.jstree.defaults.plugins.push(\"types\");\n\n/**\n * ### Unique plugin\n *\n * Enforces that no nodes with the same name can coexist as siblings.\n */\n\n\t/**\n\t * stores all defaults for the unique plugin\n\t * @name $.jstree.defaults.unique\n\t * @plugin unique\n\t */\n\t$.jstree.defaults.unique = {\n\t\t/**\n\t\t * Indicates if the comparison should be case sensitive. Default is `false`.\n\t\t * @name $.jstree.defaults.unique.case_sensitive\n\t\t * @plugin unique\n\t\t */\n\t\tcase_sensitive : false,\n\t\t/**\n\t\t * A callback executed in the instance's scope when a new node is created and the name is already taken, the two arguments are the conflicting name and the counter. The default will produce results like `New node (2)`.\n\t\t * @name $.jstree.defaults.unique.duplicate\n\t\t * @plugin unique\n\t\t */\n\t\tduplicate : function (name, counter) {\n\t\t\treturn name + ' (' + counter + ')';\n\t\t}\n\t};\n\n\t$.jstree.plugins.unique = function (options, parent) {\n\t\tthis.check = function (chk, obj, par, pos, more) {\n\t\t\tif(parent.check.call(this, chk, obj, par, pos, more) === false) { return false; }\n\t\t\tobj = obj && obj.id ? obj : this.get_node(obj);\n\t\t\tpar = par && par.id ? par : this.get_node(par);\n\t\t\tif(!par || !par.children) { return true; }\n\t\t\tvar n = chk === \"rename_node\" ? pos : obj.text,\n\t\t\t\tc = [],\n\t\t\t\ts = this.settings.unique.case_sensitive,\n\t\t\t\tm = this._model.data, i, j;\n\t\t\tfor(i = 0, j = par.children.length; i < j; i++) {\n\t\t\t\tc.push(s ? m[par.children[i]].text : m[par.children[i]].text.toLowerCase());\n\t\t\t}\n\t\t\tif(!s) { n = n.toLowerCase(); }\n\t\t\tswitch(chk) {\n\t\t\t\tcase \"delete_node\":\n\t\t\t\t\treturn true;\n\t\t\t\tcase \"rename_node\":\n\t\t\t\t\ti = ($.inArray(n, c) === -1 || (obj.text && obj.text[ s ? 'toString' : 'toLowerCase']() === n));\n\t\t\t\t\tif(!i) {\n\t\t\t\t\t\tthis._data.core.last_error = { 'error' : 'check', 'plugin' : 'unique', 'id' : 'unique_01', 'reason' : 'Child with name ' + n + ' already exists. Preventing: ' + chk, 'data' : JSON.stringify({ 'chk' : chk, 'pos' : pos, 'obj' : obj && obj.id ? obj.id : false, 'par' : par && par.id ? par.id : false }) };\n\t\t\t\t\t}\n\t\t\t\t\treturn i;\n\t\t\t\tcase \"create_node\":\n\t\t\t\t\ti = ($.inArray(n, c) === -1);\n\t\t\t\t\tif(!i) {\n\t\t\t\t\t\tthis._data.core.last_error = { 'error' : 'check', 'plugin' : 'unique', 'id' : 'unique_04', 'reason' : 'Child with name ' + n + ' already exists. Preventing: ' + chk, 'data' : JSON.stringify({ 'chk' : chk, 'pos' : pos, 'obj' : obj && obj.id ? obj.id : false, 'par' : par && par.id ? par.id : false }) };\n\t\t\t\t\t}\n\t\t\t\t\treturn i;\n\t\t\t\tcase \"copy_node\":\n\t\t\t\t\ti = ($.inArray(n, c) === -1);\n\t\t\t\t\tif(!i) {\n\t\t\t\t\t\tthis._data.core.last_error = { 'error' : 'check', 'plugin' : 'unique', 'id' : 'unique_02', 'reason' : 'Child with name ' + n + ' already exists. Preventing: ' + chk, 'data' : JSON.stringify({ 'chk' : chk, 'pos' : pos, 'obj' : obj && obj.id ? obj.id : false, 'par' : par && par.id ? par.id : false }) };\n\t\t\t\t\t}\n\t\t\t\t\treturn i;\n\t\t\t\tcase \"move_node\":\n\t\t\t\t\ti = (obj.parent === par.id || $.inArray(n, c) === -1);\n\t\t\t\t\tif(!i) {\n\t\t\t\t\t\tthis._data.core.last_error = { 'error' : 'check', 'plugin' : 'unique', 'id' : 'unique_03', 'reason' : 'Child with name ' + n + ' already exists. Preventing: ' + chk, 'data' : JSON.stringify({ 'chk' : chk, 'pos' : pos, 'obj' : obj && obj.id ? obj.id : false, 'par' : par && par.id ? par.id : false }) };\n\t\t\t\t\t}\n\t\t\t\t\treturn i;\n\t\t\t}\n\t\t\treturn true;\n\t\t};\n\t\tthis.create_node = function (par, node, pos, callback, is_loaded) {\n\t\t\tif(!node || node.text === undefined) {\n\t\t\t\tif(par === null) {\n\t\t\t\t\tpar = \"#\";\n\t\t\t\t}\n\t\t\t\tpar = this.get_node(par);\n\t\t\t\tif(!par) {\n\t\t\t\t\treturn parent.create_node.call(this, par, node, pos, callback, is_loaded);\n\t\t\t\t}\n\t\t\t\tpos = pos === undefined ? \"last\" : pos;\n\t\t\t\tif(!pos.toString().match(/^(before|after)$/) && !is_loaded && !this.is_loaded(par)) {\n\t\t\t\t\treturn parent.create_node.call(this, par, node, pos, callback, is_loaded);\n\t\t\t\t}\n\t\t\t\tif(!node) { node = {}; }\n\t\t\t\tvar tmp, n, dpc, i, j, m = this._model.data, s = this.settings.unique.case_sensitive, cb = this.settings.unique.duplicate;\n\t\t\t\tn = tmp = this.get_string('New node');\n\t\t\t\tdpc = [];\n\t\t\t\tfor(i = 0, j = par.children.length; i < j; i++) {\n\t\t\t\t\tdpc.push(s ? m[par.children[i]].text : m[par.children[i]].text.toLowerCase());\n\t\t\t\t}\n\t\t\t\ti = 1;\n\t\t\t\twhile($.inArray(s ? n : n.toLowerCase(), dpc) !== -1) {\n\t\t\t\t\tn = cb.call(this, tmp, (++i)).toString();\n\t\t\t\t}\n\t\t\t\tnode.text = n;\n\t\t\t}\n\t\t\treturn parent.create_node.call(this, par, node, pos, callback, is_loaded);\n\t\t};\n\t};\n\n\t// include the unique plugin by default\n\t// $.jstree.defaults.plugins.push(\"unique\");\n\n\n/**\n * ### Wholerow plugin\n *\n * Makes each node appear block level. Making selection easier. May cause slow down for large trees in old browsers.\n */\n\n\tvar div = document.createElement('DIV');\n\tdiv.setAttribute('unselectable','on');\n\tdiv.className = 'jstree-wholerow';\n\tdiv.innerHTML = '&#160;';\n\t$.jstree.plugins.wholerow = function (options, parent) {\n\t\tthis.bind = function () {\n\t\t\tparent.bind.call(this);\n\n\t\t\tthis.element\n\t\t\t\t.on('ready.jstree set_state.jstree', $.proxy(function () {\n\t\t\t\t\t\tthis.hide_dots();\n\t\t\t\t\t}, this))\n\t\t\t\t.on(\"init.jstree loading.jstree ready.jstree\", $.proxy(function () {\n\t\t\t\t\t\t//div.style.height = this._data.core.li_height + 'px';\n\t\t\t\t\t\tthis.get_container_ul().addClass('jstree-wholerow-ul');\n\t\t\t\t\t}, this))\n\t\t\t\t.on(\"deselect_all.jstree\", $.proxy(function (e, data) {\n\t\t\t\t\t\tthis.element.find('.jstree-wholerow-clicked').removeClass('jstree-wholerow-clicked');\n\t\t\t\t\t}, this))\n\t\t\t\t.on(\"changed.jstree\", $.proxy(function (e, data) {\n\t\t\t\t\t\tthis.element.find('.jstree-wholerow-clicked').removeClass('jstree-wholerow-clicked');\n\t\t\t\t\t\tvar tmp = false, i, j;\n\t\t\t\t\t\tfor(i = 0, j = data.selected.length; i < j; i++) {\n\t\t\t\t\t\t\ttmp = this.get_node(data.selected[i], true);\n\t\t\t\t\t\t\tif(tmp && tmp.length) {\n\t\t\t\t\t\t\t\ttmp.children('.jstree-wholerow').addClass('jstree-wholerow-clicked');\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}, this))\n\t\t\t\t.on(\"open_node.jstree\", $.proxy(function (e, data) {\n\t\t\t\t\t\tthis.get_node(data.node, true).find('.jstree-clicked').parent().children('.jstree-wholerow').addClass('jstree-wholerow-clicked');\n\t\t\t\t\t}, this))\n\t\t\t\t.on(\"hover_node.jstree dehover_node.jstree\", $.proxy(function (e, data) {\n\t\t\t\t\t\tthis.get_node(data.node, true).children('.jstree-wholerow')[e.type === \"hover_node\"?\"addClass\":\"removeClass\"]('jstree-wholerow-hovered');\n\t\t\t\t\t}, this))\n\t\t\t\t.on(\"contextmenu.jstree\", \".jstree-wholerow\", $.proxy(function (e) {\n\t\t\t\t\t\te.preventDefault();\n\t\t\t\t\t\tvar tmp = $.Event('contextmenu', { metaKey : e.metaKey, ctrlKey : e.ctrlKey, altKey : e.altKey, shiftKey : e.shiftKey, pageX : e.pageX, pageY : e.pageY });\n\t\t\t\t\t\t$(e.currentTarget).closest(\".jstree-node\").children(\".jstree-anchor:eq(0)\").trigger(tmp);\n\t\t\t\t\t}, this))\n\t\t\t\t.on(\"click.jstree\", \".jstree-wholerow\", function (e) {\n\t\t\t\t\t\te.stopImmediatePropagation();\n\t\t\t\t\t\tvar tmp = $.Event('click', { metaKey : e.metaKey, ctrlKey : e.ctrlKey, altKey : e.altKey, shiftKey : e.shiftKey });\n\t\t\t\t\t\t$(e.currentTarget).closest(\".jstree-node\").children(\".jstree-anchor:eq(0)\").trigger(tmp).focus();\n\t\t\t\t\t})\n\t\t\t\t.on(\"click.jstree\", \".jstree-leaf > .jstree-ocl\", $.proxy(function (e) {\n\t\t\t\t\t\te.stopImmediatePropagation();\n\t\t\t\t\t\tvar tmp = $.Event('click', { metaKey : e.metaKey, ctrlKey : e.ctrlKey, altKey : e.altKey, shiftKey : e.shiftKey });\n\t\t\t\t\t\t$(e.currentTarget).closest(\".jstree-node\").children(\".jstree-anchor:eq(0)\").trigger(tmp).focus();\n\t\t\t\t\t}, this))\n\t\t\t\t.on(\"mouseover.jstree\", \".jstree-wholerow, .jstree-icon\", $.proxy(function (e) {\n\t\t\t\t\t\te.stopImmediatePropagation();\n\t\t\t\t\t\tthis.hover_node(e.currentTarget);\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}, this))\n\t\t\t\t.on(\"mouseleave.jstree\", \".jstree-node\", $.proxy(function (e) {\n\t\t\t\t\t\tthis.dehover_node(e.currentTarget);\n\t\t\t\t\t}, this));\n\t\t};\n\t\tthis.teardown = function () {\n\t\t\tif(this.settings.wholerow) {\n\t\t\t\tthis.element.find(\".jstree-wholerow\").remove();\n\t\t\t}\n\t\t\tparent.teardown.call(this);\n\t\t};\n\t\tthis.redraw_node = function(obj, deep, callback) {\n\t\t\tobj = parent.redraw_node.call(this, obj, deep, callback);\n\t\t\tif(obj) {\n\t\t\t\tvar tmp = div.cloneNode(true);\n\t\t\t\t//tmp.style.height = this._data.core.li_height + 'px';\n\t\t\t\tif($.inArray(obj.id, this._data.core.selected) !== -1) { tmp.className += ' jstree-wholerow-clicked'; }\n\t\t\t\tobj.insertBefore(tmp, obj.childNodes[0]);\n\t\t\t}\n\t\t\treturn obj;\n\t\t};\n\t};\n\t// include the wholerow plugin by default\n\t// $.jstree.defaults.plugins.push(\"wholerow\");\n\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTI4LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vZ2FsYXh5L3NjcmlwdHMvbGlicy9qcXVlcnkvanN0cmVlLmpzPzUwODgiXSwic291cmNlc0NvbnRlbnQiOlsiLypnbG9iYWxzIGpRdWVyeSwgZGVmaW5lLCBleHBvcnRzLCByZXF1aXJlLCB3aW5kb3csIGRvY3VtZW50ICovXG4oZnVuY3Rpb24gKGZhY3RvcnkpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcblx0XHRkZWZpbmUoWydqcXVlcnknXSwgZmFjdG9yeSk7XG5cdH1cblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcblx0XHRmYWN0b3J5KHJlcXVpcmUoJ2pxdWVyeScpKTtcblx0fVxuXHRlbHNlIHtcblx0XHRmYWN0b3J5KGpRdWVyeSk7XG5cdH1cbn0oZnVuY3Rpb24gKCQsIHVuZGVmaW5lZCkge1xuXHRcInVzZSBzdHJpY3RcIjtcbi8qIVxuICoganNUcmVlIDMuMC4zXG4gKiBodHRwOi8vanN0cmVlLmNvbS9cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQgSXZhbiBCb3poYW5vdiAoaHR0cDovL3Zha2F0YS5jb20pXG4gKlxuICogTGljZW5zZWQgc2FtZSBhcyBqcXVlcnkgLSB1bmRlciB0aGUgdGVybXMgb2YgdGhlIE1JVCBMaWNlbnNlXG4gKiAgIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG4gKi9cbi8qIVxuICogaWYgdXNpbmcganNsaW50IHBsZWFzZSBhbGxvdyBmb3IgdGhlIGpRdWVyeSBnbG9iYWwgYW5kIHVzZSBmb2xsb3dpbmcgb3B0aW9uczogXG4gKiBqc2xpbnQ6IGJyb3dzZXI6IHRydWUsIGFzczogdHJ1ZSwgYml0d2lzZTogdHJ1ZSwgY29udGludWU6IHRydWUsIG5vbWVuOiB0cnVlLCBwbHVzcGx1czogdHJ1ZSwgcmVnZXhwOiB0cnVlLCB1bnBhcmFtOiB0cnVlLCB0b2RvOiB0cnVlLCB3aGl0ZTogdHJ1ZVxuICovXG5cblx0Ly8gcHJldmVudCBhbm90aGVyIGxvYWQ/IG1heWJlIHRoZXJlIGlzIGEgYmV0dGVyIHdheT9cblx0aWYoJC5qc3RyZWUpIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvKipcblx0ICogIyMjIGpzVHJlZSBjb3JlIGZ1bmN0aW9uYWxpdHlcblx0ICovXG5cblx0Ly8gaW50ZXJuYWwgdmFyaWFibGVzXG5cdHZhciBpbnN0YW5jZV9jb3VudGVyID0gMCxcblx0XHRjY3Bfbm9kZSA9IGZhbHNlLFxuXHRcdGNjcF9tb2RlID0gZmFsc2UsXG5cdFx0Y2NwX2luc3QgPSBmYWxzZSxcblx0XHR0aGVtZXNfbG9hZGVkID0gW10sXG5cdFx0c3JjID0gJCgnc2NyaXB0Omxhc3QnKS5hdHRyKCdzcmMnKSxcblx0XHRfZCA9IGRvY3VtZW50LCBfbm9kZSA9IF9kLmNyZWF0ZUVsZW1lbnQoJ0xJJyksIF90ZW1wMSwgX3RlbXAyO1xuXG5cdF9ub2RlLnNldEF0dHJpYnV0ZSgncm9sZScsICd0cmVlaXRlbScpO1xuXHRfdGVtcDEgPSBfZC5jcmVhdGVFbGVtZW50KCdJJyk7XG5cdF90ZW1wMS5jbGFzc05hbWUgPSAnanN0cmVlLWljb24ganN0cmVlLW9jbCc7XG5cdF9ub2RlLmFwcGVuZENoaWxkKF90ZW1wMSk7XG5cdF90ZW1wMSA9IF9kLmNyZWF0ZUVsZW1lbnQoJ0EnKTtcblx0X3RlbXAxLmNsYXNzTmFtZSA9ICdqc3RyZWUtYW5jaG9yJztcblx0X3RlbXAxLnNldEF0dHJpYnV0ZSgnaHJlZicsJyMnKTtcblx0X3RlbXAyID0gX2QuY3JlYXRlRWxlbWVudCgnSScpO1xuXHRfdGVtcDIuY2xhc3NOYW1lID0gJ2pzdHJlZS1pY29uIGpzdHJlZS10aGVtZWljb24nO1xuXHRfdGVtcDEuYXBwZW5kQ2hpbGQoX3RlbXAyKTtcblx0X25vZGUuYXBwZW5kQ2hpbGQoX3RlbXAxKTtcblx0X3RlbXAxID0gX3RlbXAyID0gbnVsbDtcblxuXG5cdC8qKlxuXHQgKiBob2xkcyBhbGwganN0cmVlIHJlbGF0ZWQgZnVuY3Rpb25zIGFuZCB2YXJpYWJsZXMsIGluY2x1ZGluZyB0aGUgYWN0dWFsIGNsYXNzIGFuZCBtZXRob2RzIHRvIGNyZWF0ZSwgYWNjZXNzIGFuZCBtYW5pcHVsYXRlIGluc3RhbmNlcy5cblx0ICogQG5hbWUgJC5qc3RyZWVcblx0ICovXG5cdCQuanN0cmVlID0ge1xuXHRcdC8qKiBcblx0XHQgKiBzcGVjaWZpZXMgdGhlIGpzdHJlZSB2ZXJzaW9uIGluIHVzZVxuXHRcdCAqIEBuYW1lICQuanN0cmVlLnZlcnNpb25cblx0XHQgKi9cblx0XHR2ZXJzaW9uIDogJzMuMC4zJyxcblx0XHQvKipcblx0XHQgKiBob2xkcyBhbGwgdGhlIGRlZmF1bHQgb3B0aW9ucyB1c2VkIHdoZW4gY3JlYXRpbmcgbmV3IGluc3RhbmNlc1xuXHRcdCAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzXG5cdFx0ICovXG5cdFx0ZGVmYXVsdHMgOiB7XG5cdFx0XHQvKipcblx0XHRcdCAqIGNvbmZpZ3VyZSB3aGljaCBwbHVnaW5zIHdpbGwgYmUgYWN0aXZlIG9uIGFuIGluc3RhbmNlLiBTaG91bGQgYmUgYW4gYXJyYXkgb2Ygc3RyaW5ncywgd2hlcmUgZWFjaCBlbGVtZW50IGlzIGEgcGx1Z2luIG5hbWUuIFRoZSBkZWZhdWx0IGlzIGBbXWBcblx0XHRcdCAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLnBsdWdpbnNcblx0XHRcdCAqL1xuXHRcdFx0cGx1Z2lucyA6IFtdXG5cdFx0fSxcblx0XHQvKipcblx0XHQgKiBzdG9yZXMgYWxsIGxvYWRlZCBqc3RyZWUgcGx1Z2lucyAodXNlZCBpbnRlcm5hbGx5KVxuXHRcdCAqIEBuYW1lICQuanN0cmVlLnBsdWdpbnNcblx0XHQgKi9cblx0XHRwbHVnaW5zIDoge30sXG5cdFx0cGF0aCA6IHNyYyAmJiBzcmMuaW5kZXhPZignLycpICE9PSAtMSA/IHNyYy5yZXBsYWNlKC9cXC9bXlxcL10rJC8sJycpIDogJycsXG5cdFx0aWRyZWdleCA6IC9bXFxcXDomIV58KClcXFtcXF08PkAqJyt+I1wiOy4sPVxcLSBcXC8ke30lXS9nXG5cdH07XG5cdC8qKlxuXHQgKiBjcmVhdGVzIGEganN0cmVlIGluc3RhbmNlXG5cdCAqIEBuYW1lICQuanN0cmVlLmNyZWF0ZShlbCBbLCBvcHRpb25zXSlcblx0ICogQHBhcmFtIHtET01FbGVtZW50fGpRdWVyeXxTdHJpbmd9IGVsIHRoZSBlbGVtZW50IHRvIGNyZWF0ZSB0aGUgaW5zdGFuY2Ugb24sIGNhbiBiZSBqUXVlcnkgZXh0ZW5kZWQgb3IgYSBzZWxlY3RvclxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBvcHRpb25zIGZvciB0aGlzIGluc3RhbmNlIChleHRlbmRzIGAkLmpzdHJlZS5kZWZhdWx0c2ApXG5cdCAqIEByZXR1cm4ge2pzVHJlZX0gdGhlIG5ldyBpbnN0YW5jZVxuXHQgKi9cblx0JC5qc3RyZWUuY3JlYXRlID0gZnVuY3Rpb24gKGVsLCBvcHRpb25zKSB7XG5cdFx0dmFyIHRtcCA9IG5ldyAkLmpzdHJlZS5jb3JlKCsraW5zdGFuY2VfY291bnRlciksXG5cdFx0XHRvcHQgPSBvcHRpb25zO1xuXHRcdG9wdGlvbnMgPSAkLmV4dGVuZCh0cnVlLCB7fSwgJC5qc3RyZWUuZGVmYXVsdHMsIG9wdGlvbnMpO1xuXHRcdGlmKG9wdCAmJiBvcHQucGx1Z2lucykge1xuXHRcdFx0b3B0aW9ucy5wbHVnaW5zID0gb3B0LnBsdWdpbnM7XG5cdFx0fVxuXHRcdCQuZWFjaChvcHRpb25zLnBsdWdpbnMsIGZ1bmN0aW9uIChpLCBrKSB7XG5cdFx0XHRpZihpICE9PSAnY29yZScpIHtcblx0XHRcdFx0dG1wID0gdG1wLnBsdWdpbihrLCBvcHRpb25zW2tdKTtcblx0XHRcdH1cblx0XHR9KTtcblx0XHR0bXAuaW5pdChlbCwgb3B0aW9ucyk7XG5cdFx0cmV0dXJuIHRtcDtcblx0fTtcblx0LyoqXG5cdCAqIHRoZSBqc3RyZWUgY2xhc3MgY29uc3RydWN0b3IsIHVzZWQgb25seSBpbnRlcm5hbGx5XG5cdCAqIEBwcml2YXRlXG5cdCAqIEBuYW1lICQuanN0cmVlLmNvcmUoaWQpXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBpZCB0aGlzIGluc3RhbmNlJ3MgaW5kZXhcblx0ICovXG5cdCQuanN0cmVlLmNvcmUgPSBmdW5jdGlvbiAoaWQpIHtcblx0XHR0aGlzLl9pZCA9IGlkO1xuXHRcdHRoaXMuX2NudCA9IDA7XG5cdFx0dGhpcy5fd3JrID0gbnVsbDtcblx0XHR0aGlzLl9kYXRhID0ge1xuXHRcdFx0Y29yZSA6IHtcblx0XHRcdFx0dGhlbWVzIDoge1xuXHRcdFx0XHRcdG5hbWUgOiBmYWxzZSxcblx0XHRcdFx0XHRkb3RzIDogZmFsc2UsXG5cdFx0XHRcdFx0aWNvbnMgOiBmYWxzZVxuXHRcdFx0XHR9LFxuXHRcdFx0XHRzZWxlY3RlZCA6IFtdLFxuXHRcdFx0XHRsYXN0X2Vycm9yIDoge30sXG5cdFx0XHRcdHdvcmtpbmcgOiBmYWxzZSxcblx0XHRcdFx0d29ya2VyX3F1ZXVlIDogW11cblx0XHRcdH1cblx0XHR9O1xuXHR9O1xuXHQvKipcblx0ICogZ2V0IGEgcmVmZXJlbmNlIHRvIGFuIGV4aXN0aW5nIGluc3RhbmNlXG5cdCAqXG5cdCAqIF9fRXhhbXBsZXNfX1xuXHQgKlxuXHQgKlx0Ly8gcHJvdmlkZWQgYSBjb250YWluZXIgd2l0aCBhbiBJRCBvZiBcInRyZWVcIiwgYW5kIGEgbmVzdGVkIG5vZGUgd2l0aCBhbiBJRCBvZiBcImJyYW5jaFwiXG5cdCAqXHQvLyBhbGwgb2YgdGhlcmUgd2lsbCByZXR1cm4gdGhlIHNhbWUgaW5zdGFuY2Vcblx0ICpcdCQuanN0cmVlLnJlZmVyZW5jZSgndHJlZScpO1xuXHQgKlx0JC5qc3RyZWUucmVmZXJlbmNlKCcjdHJlZScpO1xuXHQgKlx0JC5qc3RyZWUucmVmZXJlbmNlKCQoJyN0cmVlJykpO1xuXHQgKlx0JC5qc3RyZWUucmVmZXJlbmNlKGRvY3VtZW50LmdldEVsZW1lbnRCeUlEKCd0cmVlJykpO1xuXHQgKlx0JC5qc3RyZWUucmVmZXJlbmNlKCdicmFuY2gnKTtcblx0ICpcdCQuanN0cmVlLnJlZmVyZW5jZSgnI2JyYW5jaCcpO1xuXHQgKlx0JC5qc3RyZWUucmVmZXJlbmNlKCQoJyNicmFuY2gnKSk7XG5cdCAqXHQkLmpzdHJlZS5yZWZlcmVuY2UoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SUQoJ2JyYW5jaCcpKTtcblx0ICpcblx0ICogQG5hbWUgJC5qc3RyZWUucmVmZXJlbmNlKG5lZWRsZSlcblx0ICogQHBhcmFtIHtET01FbGVtZW50fGpRdWVyeXxTdHJpbmd9IG5lZWRsZVxuXHQgKiBAcmV0dXJuIHtqc1RyZWV8bnVsbH0gdGhlIGluc3RhbmNlIG9yIGBudWxsYCBpZiBub3QgZm91bmRcblx0ICovXG5cdCQuanN0cmVlLnJlZmVyZW5jZSA9IGZ1bmN0aW9uIChuZWVkbGUpIHtcblx0XHR2YXIgdG1wID0gbnVsbCxcblx0XHRcdG9iaiA9IG51bGw7XG5cdFx0aWYobmVlZGxlICYmIG5lZWRsZS5pZCkgeyBuZWVkbGUgPSBuZWVkbGUuaWQ7IH1cblxuXHRcdGlmKCFvYmogfHwgIW9iai5sZW5ndGgpIHtcblx0XHRcdHRyeSB7IG9iaiA9ICQobmVlZGxlKTsgfSBjYXRjaCAoaWdub3JlKSB7IH1cblx0XHR9XG5cdFx0aWYoIW9iaiB8fCAhb2JqLmxlbmd0aCkge1xuXHRcdFx0dHJ5IHsgb2JqID0gJCgnIycgKyBuZWVkbGUucmVwbGFjZSgkLmpzdHJlZS5pZHJlZ2V4LCdcXFxcJCYnKSk7IH0gY2F0Y2ggKGlnbm9yZSkgeyB9XG5cdFx0fVxuXHRcdGlmKG9iaiAmJiBvYmoubGVuZ3RoICYmIChvYmogPSBvYmouY2xvc2VzdCgnLmpzdHJlZScpKS5sZW5ndGggJiYgKG9iaiA9IG9iai5kYXRhKCdqc3RyZWUnKSkpIHtcblx0XHRcdHRtcCA9IG9iajtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHQkKCcuanN0cmVlJykuZWFjaChmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHZhciBpbnN0ID0gJCh0aGlzKS5kYXRhKCdqc3RyZWUnKTtcblx0XHRcdFx0aWYoaW5zdCAmJiBpbnN0Ll9tb2RlbC5kYXRhW25lZWRsZV0pIHtcblx0XHRcdFx0XHR0bXAgPSBpbnN0O1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXHRcdHJldHVybiB0bXA7XG5cdH07XG5cdC8qKlxuXHQgKiBDcmVhdGUgYW4gaW5zdGFuY2UsIGdldCBhbiBpbnN0YW5jZSBvciBpbnZva2UgYSBjb21tYW5kIG9uIGEgaW5zdGFuY2UuIFxuXHQgKiBcblx0ICogSWYgdGhlcmUgaXMgbm8gaW5zdGFuY2UgYXNzb2NpYXRlZCB3aXRoIHRoZSBjdXJyZW50IG5vZGUgYSBuZXcgb25lIGlzIGNyZWF0ZWQgYW5kIGBhcmdgIGlzIHVzZWQgdG8gZXh0ZW5kIGAkLmpzdHJlZS5kZWZhdWx0c2AgZm9yIHRoaXMgbmV3IGluc3RhbmNlLiBUaGVyZSB3b3VsZCBiZSBubyByZXR1cm4gdmFsdWUgKGNoYWluaW5nIGlzIG5vdCBicm9rZW4pLlxuXHQgKiBcblx0ICogSWYgdGhlcmUgaXMgYW4gZXhpc3RpbmcgaW5zdGFuY2UgYW5kIGBhcmdgIGlzIGEgc3RyaW5nIHRoZSBjb21tYW5kIHNwZWNpZmllZCBieSBgYXJnYCBpcyBleGVjdXRlZCBvbiB0aGUgaW5zdGFuY2UsIHdpdGggYW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIHBhc3NlZCB0byB0aGUgZnVuY3Rpb24uIElmIHRoZSBmdW5jdGlvbiByZXR1cm5zIGEgdmFsdWUgaXQgd2lsbCBiZSByZXR1cm5lZCAoY2hhaW5pbmcgY291bGQgYnJlYWsgZGVwZW5kaW5nIG9uIGZ1bmN0aW9uKS5cblx0ICogXG5cdCAqIElmIHRoZXJlIGlzIGFuIGV4aXN0aW5nIGluc3RhbmNlIGFuZCBgYXJnYCBpcyBub3QgYSBzdHJpbmcgdGhlIGluc3RhbmNlIGl0c2VsZiBpcyByZXR1cm5lZCAoc2ltaWxhciB0byBgJC5qc3RyZWUucmVmZXJlbmNlYCkuXG5cdCAqIFxuXHQgKiBJbiBhbnkgb3RoZXIgY2FzZSAtIG5vdGhpbmcgaXMgcmV0dXJuZWQgYW5kIGNoYWluaW5nIGlzIG5vdCBicm9rZW4uXG5cdCAqXG5cdCAqIF9fRXhhbXBsZXNfX1xuXHQgKlxuXHQgKlx0JCgnI3RyZWUxJykuanN0cmVlKCk7IC8vIGNyZWF0ZXMgYW4gaW5zdGFuY2Vcblx0ICpcdCQoJyN0cmVlMicpLmpzdHJlZSh7IHBsdWdpbnMgOiBbXSB9KTsgLy8gY3JlYXRlIGFuIGluc3RhbmNlIHdpdGggc29tZSBvcHRpb25zXG5cdCAqXHQkKCcjdHJlZTEnKS5qc3RyZWUoJ29wZW5fbm9kZScsICcjYnJhbmNoXzEnKTsgLy8gY2FsbCBhIG1ldGhvZCBvbiBhbiBleGlzdGluZyBpbnN0YW5jZSwgcGFzc2luZyBhZGRpdGlvbmFsIGFyZ3VtZW50c1xuXHQgKlx0JCgnI3RyZWUyJykuanN0cmVlKCk7IC8vIGdldCBhbiBleGlzdGluZyBpbnN0YW5jZSAob3IgY3JlYXRlIGFuIGluc3RhbmNlKVxuXHQgKlx0JCgnI3RyZWUyJykuanN0cmVlKHRydWUpOyAvLyBnZXQgYW4gZXhpc3RpbmcgaW5zdGFuY2UgKHdpbGwgbm90IGNyZWF0ZSBuZXcgaW5zdGFuY2UpXG5cdCAqXHQkKCcjYnJhbmNoXzEnKS5qc3RyZWUoKS5zZWxlY3Rfbm9kZSgnI2JyYW5jaF8xJyk7IC8vIGdldCBhbiBpbnN0YW5jZSAodXNpbmcgYSBuZXN0ZWQgZWxlbWVudCBhbmQgY2FsbCBhIG1ldGhvZClcblx0ICpcblx0ICogQG5hbWUgJCgpLmpzdHJlZShbYXJnXSlcblx0ICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBhcmdcblx0ICogQHJldHVybiB7TWl4ZWR9XG5cdCAqL1xuXHQkLmZuLmpzdHJlZSA9IGZ1bmN0aW9uIChhcmcpIHtcblx0XHQvLyBjaGVjayBmb3Igc3RyaW5nIGFyZ3VtZW50XG5cdFx0dmFyIGlzX21ldGhvZFx0PSAodHlwZW9mIGFyZyA9PT0gJ3N0cmluZycpLFxuXHRcdFx0YXJnc1x0XHQ9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSksXG5cdFx0XHRyZXN1bHRcdFx0PSBudWxsO1xuXHRcdHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG5cdFx0XHQvLyBnZXQgdGhlIGluc3RhbmNlIChpZiB0aGVyZSBpcyBvbmUpIGFuZCBtZXRob2QgKGlmIGl0IGV4aXN0cylcblx0XHRcdHZhciBpbnN0YW5jZSA9ICQuanN0cmVlLnJlZmVyZW5jZSh0aGlzKSxcblx0XHRcdFx0bWV0aG9kID0gaXNfbWV0aG9kICYmIGluc3RhbmNlID8gaW5zdGFuY2VbYXJnXSA6IG51bGw7XG5cdFx0XHQvLyBpZiBjYWxsaW5nIGEgbWV0aG9kLCBhbmQgbWV0aG9kIGlzIGF2YWlsYWJsZSAtIGV4ZWN1dGUgb24gdGhlIGluc3RhbmNlXG5cdFx0XHRyZXN1bHQgPSBpc19tZXRob2QgJiYgbWV0aG9kID9cblx0XHRcdFx0bWV0aG9kLmFwcGx5KGluc3RhbmNlLCBhcmdzKSA6XG5cdFx0XHRcdG51bGw7XG5cdFx0XHQvLyBpZiB0aGVyZSBpcyBubyBpbnN0YW5jZSBhbmQgbm8gbWV0aG9kIGlzIGJlaW5nIGNhbGxlZCAtIGNyZWF0ZSBvbmVcblx0XHRcdGlmKCFpbnN0YW5jZSAmJiAhaXNfbWV0aG9kICYmIChhcmcgPT09IHVuZGVmaW5lZCB8fCAkLmlzUGxhaW5PYmplY3QoYXJnKSkpIHtcblx0XHRcdFx0JCh0aGlzKS5kYXRhKCdqc3RyZWUnLCBuZXcgJC5qc3RyZWUuY3JlYXRlKHRoaXMsIGFyZykpO1xuXHRcdFx0fVxuXHRcdFx0Ly8gaWYgdGhlcmUgaXMgYW4gaW5zdGFuY2UgYW5kIG5vIG1ldGhvZCBpcyBjYWxsZWQgLSByZXR1cm4gdGhlIGluc3RhbmNlXG5cdFx0XHRpZiggKGluc3RhbmNlICYmICFpc19tZXRob2QpIHx8IGFyZyA9PT0gdHJ1ZSApIHtcblx0XHRcdFx0cmVzdWx0ID0gaW5zdGFuY2UgfHwgZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHQvLyBpZiB0aGVyZSB3YXMgYSBtZXRob2QgY2FsbCB3aGljaCByZXR1cm5lZCBhIHJlc3VsdCAtIGJyZWFrIGFuZCByZXR1cm4gdGhlIHZhbHVlXG5cdFx0XHRpZihyZXN1bHQgIT09IG51bGwgJiYgcmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdC8vIGlmIHRoZXJlIHdhcyBhIG1ldGhvZCBjYWxsIHdpdGggYSB2YWxpZCByZXR1cm4gdmFsdWUgLSByZXR1cm4gdGhhdCwgb3RoZXJ3aXNlIGNvbnRpbnVlIHRoZSBjaGFpblxuXHRcdHJldHVybiByZXN1bHQgIT09IG51bGwgJiYgcmVzdWx0ICE9PSB1bmRlZmluZWQgP1xuXHRcdFx0cmVzdWx0IDogdGhpcztcblx0fTtcblx0LyoqXG5cdCAqIHVzZWQgdG8gZmluZCBlbGVtZW50cyBjb250YWluaW5nIGFuIGluc3RhbmNlXG5cdCAqXG5cdCAqIF9fRXhhbXBsZXNfX1xuXHQgKlxuXHQgKlx0JCgnZGl2OmpzdHJlZScpLmVhY2goZnVuY3Rpb24gKCkge1xuXHQgKlx0XHQkKHRoaXMpLmpzdHJlZSgnZGVzdHJveScpO1xuXHQgKlx0fSk7XG5cdCAqXG5cdCAqIEBuYW1lICQoJzpqc3RyZWUnKVxuXHQgKiBAcmV0dXJuIHtqUXVlcnl9XG5cdCAqL1xuXHQkLmV4cHJbJzonXS5qc3RyZWUgPSAkLmV4cHIuY3JlYXRlUHNldWRvKGZ1bmN0aW9uKHNlYXJjaCkge1xuXHRcdHJldHVybiBmdW5jdGlvbihhKSB7XG5cdFx0XHRyZXR1cm4gJChhKS5oYXNDbGFzcygnanN0cmVlJykgJiZcblx0XHRcdFx0JChhKS5kYXRhKCdqc3RyZWUnKSAhPT0gdW5kZWZpbmVkO1xuXHRcdH07XG5cdH0pO1xuXG5cdC8qKlxuXHQgKiBzdG9yZXMgYWxsIGRlZmF1bHRzIGZvciB0aGUgY29yZVxuXHQgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5jb3JlXG5cdCAqL1xuXHQkLmpzdHJlZS5kZWZhdWx0cy5jb3JlID0ge1xuXHRcdC8qKlxuXHRcdCAqIGRhdGEgY29uZmlndXJhdGlvblxuXHRcdCAqIFxuXHRcdCAqIElmIGxlZnQgYXMgYGZhbHNlYCB0aGUgSFRNTCBpbnNpZGUgdGhlIGpzdHJlZSBjb250YWluZXIgZWxlbWVudCBpcyB1c2VkIHRvIHBvcHVsYXRlIHRoZSB0cmVlICh0aGF0IHNob3VsZCBiZSBhbiB1bm9yZGVyZWQgbGlzdCB3aXRoIGxpc3QgaXRlbXMpLlxuXHRcdCAqXG5cdFx0ICogWW91IGNhbiBhbHNvIHBhc3MgaW4gYSBIVE1MIHN0cmluZyBvciBhIEpTT04gYXJyYXkgaGVyZS5cblx0XHQgKiBcblx0XHQgKiBJdCBpcyBwb3NzaWJsZSB0byBwYXNzIGluIGEgc3RhbmRhcmQgalF1ZXJ5LWxpa2UgQUpBWCBjb25maWcgYW5kIGpzdHJlZSB3aWxsIGF1dG9tYXRpY2FsbHkgZGV0ZXJtaW5lIGlmIHRoZSByZXNwb25zZSBpcyBKU09OIG9yIEhUTUwgYW5kIHVzZSB0aGF0IHRvIHBvcHVsYXRlIHRoZSB0cmVlLiBcblx0XHQgKiBJbiBhZGRpdGlvbiB0byB0aGUgc3RhbmRhcmQgalF1ZXJ5IGFqYXggb3B0aW9ucyBoZXJlIHlvdSBjYW4gc3VwcHkgZnVuY3Rpb25zIGZvciBgZGF0YWAgYW5kIGB1cmxgLCB0aGUgZnVuY3Rpb25zIHdpbGwgYmUgcnVuIGluIHRoZSBjdXJyZW50IGluc3RhbmNlJ3Mgc2NvcGUgYW5kIGEgcGFyYW0gd2lsbCBiZSBwYXNzZWQgaW5kaWNhdGluZyB3aGljaCBub2RlIGlzIGJlaW5nIGxvYWRlZCwgdGhlIHJldHVybiB2YWx1ZSBvZiB0aG9zZSBmdW5jdGlvbnMgd2lsbCBiZSB1c2VkLlxuXHRcdCAqIFxuXHRcdCAqIFRoZSBsYXN0IG9wdGlvbiBpcyB0byBzcGVjaWZ5IGEgZnVuY3Rpb24sIHRoYXQgZnVuY3Rpb24gd2lsbCByZWNlaXZlIHRoZSBub2RlIGJlaW5nIGxvYWRlZCBhcyBhcmd1bWVudCBhbmQgYSBzZWNvbmQgcGFyYW0gd2hpY2ggaXMgYSBmdW5jdGlvbiB3aGljaCBzaG91bGQgYmUgY2FsbGVkIHdpdGggdGhlIHJlc3VsdC5cblx0XHQgKlxuXHRcdCAqIF9fRXhhbXBsZXNfX1xuXHRcdCAqXG5cdFx0ICpcdC8vIEFKQVhcblx0XHQgKlx0JCgnI3RyZWUnKS5qc3RyZWUoe1xuXHRcdCAqXHRcdCdjb3JlJyA6IHtcblx0XHQgKlx0XHRcdCdkYXRhJyA6IHtcblx0XHQgKlx0XHRcdFx0J3VybCcgOiAnL2dldC9jaGlsZHJlbi8nLFxuXHRcdCAqXHRcdFx0XHQnZGF0YScgOiBmdW5jdGlvbiAobm9kZSkge1xuXHRcdCAqXHRcdFx0XHRcdHJldHVybiB7ICdpZCcgOiBub2RlLmlkIH07XG5cdFx0ICpcdFx0XHRcdH1cblx0XHQgKlx0XHRcdH1cblx0XHQgKlx0XHR9KTtcblx0XHQgKlxuXHRcdCAqXHQvLyBkaXJlY3QgZGF0YVxuXHRcdCAqXHQkKCcjdHJlZScpLmpzdHJlZSh7XG5cdFx0ICpcdFx0J2NvcmUnIDoge1xuXHRcdCAqXHRcdFx0J2RhdGEnIDogW1xuXHRcdCAqXHRcdFx0XHQnU2ltcGxlIHJvb3Qgbm9kZScsXG5cdFx0ICpcdFx0XHRcdHtcblx0XHQgKlx0XHRcdFx0XHQnaWQnIDogJ25vZGVfMicsXG5cdFx0ICpcdFx0XHRcdFx0J3RleHQnIDogJ1Jvb3Qgbm9kZSB3aXRoIG9wdGlvbnMnLFxuXHRcdCAqXHRcdFx0XHRcdCdzdGF0ZScgOiB7ICdvcGVuZWQnIDogdHJ1ZSwgJ3NlbGVjdGVkJyA6IHRydWUgfSxcblx0XHQgKlx0XHRcdFx0XHQnY2hpbGRyZW4nIDogWyB7ICd0ZXh0JyA6ICdDaGlsZCAxJyB9LCAnQ2hpbGQgMiddXG5cdFx0ICpcdFx0XHRcdH1cblx0XHQgKlx0XHRcdF1cblx0XHQgKlx0XHR9KTtcblx0XHQgKlx0XG5cdFx0ICpcdC8vIGZ1bmN0aW9uXG5cdFx0ICpcdCQoJyN0cmVlJykuanN0cmVlKHtcblx0XHQgKlx0XHQnY29yZScgOiB7XG5cdFx0ICpcdFx0XHQnZGF0YScgOiBmdW5jdGlvbiAob2JqLCBjYWxsYmFjaykge1xuXHRcdCAqXHRcdFx0XHRjYWxsYmFjay5jYWxsKHRoaXMsIFsnUm9vdCAxJywgJ1Jvb3QgMiddKTtcblx0XHQgKlx0XHRcdH1cblx0XHQgKlx0XHR9KTtcblx0XHQgKiBcblx0XHQgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5jb3JlLmRhdGFcblx0XHQgKi9cblx0XHRkYXRhXHRcdFx0OiBmYWxzZSxcblx0XHQvKipcblx0XHQgKiBjb25maWd1cmUgdGhlIHZhcmlvdXMgc3RyaW5ncyB1c2VkIHRocm91Z2hvdXQgdGhlIHRyZWVcblx0XHQgKlxuXHRcdCAqIFlvdSBjYW4gdXNlIGFuIG9iamVjdCB3aGVyZSB0aGUga2V5IGlzIHRoZSBzdHJpbmcgeW91IG5lZWQgdG8gcmVwbGFjZSBhbmQgdGhlIHZhbHVlIGlzIHlvdXIgcmVwbGFjZW1lbnQuXG5cdFx0ICogQW5vdGhlciBvcHRpb24gaXMgdG8gc3BlY2lmeSBhIGZ1bmN0aW9uIHdoaWNoIHdpbGwgYmUgY2FsbGVkIHdpdGggYW4gYXJndW1lbnQgb2YgdGhlIG5lZWRlZCBzdHJpbmcgYW5kIHNob3VsZCByZXR1cm4gdGhlIHJlcGxhY2VtZW50LlxuXHRcdCAqIElmIGxlZnQgYXMgYGZhbHNlYCBubyByZXBsYWNlbWVudCBpcyBtYWRlLlxuXHRcdCAqXG5cdFx0ICogX19FeGFtcGxlc19fXG5cdFx0ICpcblx0XHQgKlx0JCgnI3RyZWUnKS5qc3RyZWUoe1xuXHRcdCAqXHRcdCdjb3JlJyA6IHtcblx0XHQgKlx0XHRcdCdzdHJpbmdzJyA6IHtcblx0XHQgKlx0XHRcdFx0J0xvYWRpbmcgLi4uJyA6ICdQbGVhc2Ugd2FpdCAuLi4nXG5cdFx0ICpcdFx0XHR9XG5cdFx0ICpcdFx0fVxuXHRcdCAqXHR9KTtcblx0XHQgKlxuXHRcdCAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLmNvcmUuc3RyaW5nc1xuXHRcdCAqL1xuXHRcdHN0cmluZ3NcdFx0XHQ6IGZhbHNlLFxuXHRcdC8qKlxuXHRcdCAqIGRldGVybWluZXMgd2hhdCBoYXBwZW5zIHdoZW4gYSB1c2VyIHRyaWVzIHRvIG1vZGlmeSB0aGUgc3RydWN0dXJlIG9mIHRoZSB0cmVlXG5cdFx0ICogSWYgbGVmdCBhcyBgZmFsc2VgIGFsbCBvcGVyYXRpb25zIGxpa2UgY3JlYXRlLCByZW5hbWUsIGRlbGV0ZSwgbW92ZSBvciBjb3B5IGFyZSBwcmV2ZW50ZWQuXG5cdFx0ICogWW91IGNhbiBzZXQgdGhpcyB0byBgdHJ1ZWAgdG8gYWxsb3cgYWxsIGludGVyYWN0aW9ucyBvciB1c2UgYSBmdW5jdGlvbiB0byBoYXZlIGJldHRlciBjb250cm9sLlxuXHRcdCAqXG5cdFx0ICogX19FeGFtcGxlc19fXG5cdFx0ICpcblx0XHQgKlx0JCgnI3RyZWUnKS5qc3RyZWUoe1xuXHRcdCAqXHRcdCdjb3JlJyA6IHtcblx0XHQgKlx0XHRcdCdjaGVja19jYWxsYmFjaycgOiBmdW5jdGlvbiAob3BlcmF0aW9uLCBub2RlLCBub2RlX3BhcmVudCwgbm9kZV9wb3NpdGlvbiwgbW9yZSkge1xuXHRcdCAqXHRcdFx0XHQvLyBvcGVyYXRpb24gY2FuIGJlICdjcmVhdGVfbm9kZScsICdyZW5hbWVfbm9kZScsICdkZWxldGVfbm9kZScsICdtb3ZlX25vZGUnIG9yICdjb3B5X25vZGUnXG5cdFx0ICpcdFx0XHRcdC8vIGluIGNhc2Ugb2YgJ3JlbmFtZV9ub2RlJyBub2RlX3Bvc2l0aW9uIGlzIGZpbGxlZCB3aXRoIHRoZSBuZXcgbm9kZSBuYW1lXG5cdFx0ICpcdFx0XHRcdHJldHVybiBvcGVyYXRpb24gPT09ICdyZW5hbWVfbm9kZScgPyB0cnVlIDogZmFsc2U7XG5cdFx0ICpcdFx0XHR9XG5cdFx0ICpcdFx0fVxuXHRcdCAqXHR9KTtcblx0XHQgKiBcblx0XHQgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5jb3JlLmNoZWNrX2NhbGxiYWNrXG5cdFx0ICovXG5cdFx0Y2hlY2tfY2FsbGJhY2tcdDogZmFsc2UsXG5cdFx0LyoqXG5cdFx0ICogYSBjYWxsYmFjayBjYWxsZWQgd2l0aCBhIHNpbmdsZSBvYmplY3QgcGFyYW1ldGVyIGluIHRoZSBpbnN0YW5jZSdzIHNjb3BlIHdoZW4gc29tZXRoaW5nIGdvZXMgd3JvbmcgKG9wZXJhdGlvbiBwcmV2ZW50ZWQsIGFqYXggZmFpbGVkLCBldGMpXG5cdFx0ICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuY29yZS5lcnJvclxuXHRcdCAqL1xuXHRcdGVycm9yXHRcdFx0OiAkLm5vb3AsXG5cdFx0LyoqXG5cdFx0ICogdGhlIG9wZW4gLyBjbG9zZSBhbmltYXRpb24gZHVyYXRpb24gaW4gbWlsbGlzZWNvbmRzIC0gc2V0IHRoaXMgdG8gYGZhbHNlYCB0byBkaXNhYmxlIHRoZSBhbmltYXRpb24gKGRlZmF1bHQgaXMgYDIwMGApXG5cdFx0ICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuY29yZS5hbmltYXRpb25cblx0XHQgKi9cblx0XHRhbmltYXRpb25cdFx0OiAyMDAsXG5cdFx0LyoqXG5cdFx0ICogYSBib29sZWFuIGluZGljYXRpbmcgaWYgbXVsdGlwbGUgbm9kZXMgY2FuIGJlIHNlbGVjdGVkXG5cdFx0ICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuY29yZS5tdWx0aXBsZVxuXHRcdCAqL1xuXHRcdG11bHRpcGxlXHRcdDogdHJ1ZSxcblx0XHQvKipcblx0XHQgKiB0aGVtZSBjb25maWd1cmF0aW9uIG9iamVjdFxuXHRcdCAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLmNvcmUudGhlbWVzXG5cdFx0ICovXG5cdFx0dGhlbWVzXHRcdFx0OiB7XG5cdFx0XHQvKipcblx0XHRcdCAqIHRoZSBuYW1lIG9mIHRoZSB0aGVtZSB0byB1c2UgKGlmIGxlZnQgYXMgYGZhbHNlYCB0aGUgZGVmYXVsdCB0aGVtZSBpcyB1c2VkKVxuXHRcdFx0ICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuY29yZS50aGVtZXMubmFtZVxuXHRcdFx0ICovXG5cdFx0XHRuYW1lXHRcdFx0OiBmYWxzZSxcblx0XHRcdC8qKlxuXHRcdFx0ICogdGhlIFVSTCBvZiB0aGUgdGhlbWUncyBDU1MgZmlsZSwgbGVhdmUgdGhpcyBhcyBgZmFsc2VgIGlmIHlvdSBoYXZlIG1hbnVhbGx5IGluY2x1ZGVkIHRoZSB0aGVtZSBDU1MgKHJlY29tbWVuZGVkKS4gWW91IGNhbiBzZXQgdGhpcyB0byBgdHJ1ZWAgdG9vIHdoaWNoIHdpbGwgdHJ5IHRvIGF1dG9sb2FkIHRoZSB0aGVtZS5cblx0XHRcdCAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLmNvcmUudGhlbWVzLnVybFxuXHRcdFx0ICovXG5cdFx0XHR1cmxcdFx0XHRcdDogZmFsc2UsXG5cdFx0XHQvKipcblx0XHRcdCAqIHRoZSBsb2NhdGlvbiBvZiBhbGwganN0cmVlIHRoZW1lcyAtIG9ubHkgdXNlZCBpZiBgdXJsYCBpcyBzZXQgdG8gYHRydWVgXG5cdFx0XHQgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5jb3JlLnRoZW1lcy5kaXJcblx0XHRcdCAqL1xuXHRcdFx0ZGlyXHRcdFx0XHQ6IGZhbHNlLFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBhIGJvb2xlYW4gaW5kaWNhdGluZyBpZiBjb25uZWN0aW5nIGRvdHMgYXJlIHNob3duXG5cdFx0XHQgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5jb3JlLnRoZW1lcy5kb3RzXG5cdFx0XHQgKi9cblx0XHRcdGRvdHNcdFx0XHQ6IHRydWUsXG5cdFx0XHQvKipcblx0XHRcdCAqIGEgYm9vbGVhbiBpbmRpY2F0aW5nIGlmIG5vZGUgaWNvbnMgYXJlIHNob3duXG5cdFx0XHQgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5jb3JlLnRoZW1lcy5pY29uc1xuXHRcdFx0ICovXG5cdFx0XHRpY29uc1x0XHRcdDogdHJ1ZSxcblx0XHRcdC8qKlxuXHRcdFx0ICogYSBib29sZWFuIGluZGljYXRpbmcgaWYgdGhlIHRyZWUgYmFja2dyb3VuZCBpcyBzdHJpcGVkXG5cdFx0XHQgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5jb3JlLnRoZW1lcy5zdHJpcGVzXG5cdFx0XHQgKi9cblx0XHRcdHN0cmlwZXNcdFx0XHQ6IGZhbHNlLFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBhIHN0cmluZyAob3IgYm9vbGVhbiBgZmFsc2VgKSBzcGVjaWZ5aW5nIHRoZSB0aGVtZSB2YXJpYW50IHRvIHVzZSAoaWYgdGhlIHRoZW1lIHN1cHBvcnRzIHZhcmlhbnRzKVxuXHRcdFx0ICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuY29yZS50aGVtZXMudmFyaWFudFxuXHRcdFx0ICovXG5cdFx0XHR2YXJpYW50XHRcdFx0OiBmYWxzZSxcblx0XHRcdC8qKlxuXHRcdFx0ICogYSBib29sZWFuIHNwZWNpZnlpbmcgaWYgYSByZXBvbnNpdmUgdmVyc2lvbiBvZiB0aGUgdGhlbWUgc2hvdWxkIGtpY2sgaW4gb24gc21hbGxlciBzY3JlZW5zIChpZiB0aGUgdGhlbWUgc3VwcG9ydHMgaXQpLiBEZWZhdWx0cyB0byBgZmFsc2VgLlxuXHRcdFx0ICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuY29yZS50aGVtZXMucmVzcG9uc2l2ZVxuXHRcdFx0ICovXG5cdFx0XHRyZXNwb25zaXZlXHRcdDogZmFsc2Vcblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIGlmIGxlZnQgYXMgYHRydWVgIGFsbCBwYXJlbnRzIG9mIGFsbCBzZWxlY3RlZCBub2RlcyB3aWxsIGJlIG9wZW5lZCBvbmNlIHRoZSB0cmVlIGxvYWRzIChzbyB0aGF0IGFsbCBzZWxlY3RlZCBub2RlcyBhcmUgdmlzaWJsZSB0byB0aGUgdXNlcilcblx0XHQgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5jb3JlLmV4cGFuZF9zZWxlY3RlZF9vbmxvYWRcblx0XHQgKi9cblx0XHRleHBhbmRfc2VsZWN0ZWRfb25sb2FkIDogdHJ1ZSxcblx0XHQvKipcblx0XHQgKiBpZiBsZWZ0IGFzIGB0cnVlYCB3ZWIgd29ya2VycyB3aWxsIGJlIHVzZWQgdG8gcGFyc2UgaW5jb21pbmcgSlNPTiBkYXRhIHdoZXJlIHBvc3NpYmxlLCBzbyB0aGF0IHRoZSBVSSB3aWxsIG5vdCBiZSBibG9ja2VkIGJ5IGxhcmdlIHJlcXVlc3RzLiBXb3JrZXJzIGFyZSBob3dldmVyIGFib3V0IDMwJSBzbG93ZXIuIERlZmF1bHRzIHRvIGB0cnVlYFxuXHRcdCAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLmNvcmUud29ya2VyXG5cdFx0ICovXG5cdFx0d29ya2VyIDogdHJ1ZSxcblx0XHQvKipcblx0XHQgKiBGb3JjZSBub2RlIHRleHQgdG8gcGxhaW4gdGV4dCAoYW5kIGVzY2FwZSBIVE1MKS4gRGVmYXVsdHMgdG8gYGZhbHNlYFxuXHRcdCAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLmNvcmUuZm9yY2VfdGV4dFxuXHRcdCAqL1xuXHRcdGZvcmNlX3RleHQgOiBmYWxzZVxuXHR9O1xuXHQkLmpzdHJlZS5jb3JlLnByb3RvdHlwZSA9IHtcblx0XHQvKipcblx0XHQgKiB1c2VkIHRvIGRlY29yYXRlIGFuIGluc3RhbmNlIHdpdGggYSBwbHVnaW4uIFVzZWQgaW50ZXJuYWxseS5cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqIEBuYW1lIHBsdWdpbihkZWNvIFssIG9wdHNdKVxuXHRcdCAqIEBwYXJhbSAge1N0cmluZ30gZGVjbyB0aGUgcGx1Z2luIHRvIGRlY29yYXRlIHdpdGhcblx0XHQgKiBAcGFyYW0gIHtPYmplY3R9IG9wdHMgb3B0aW9ucyBmb3IgdGhlIHBsdWdpblxuXHRcdCAqIEByZXR1cm4ge2pzVHJlZX1cblx0XHQgKi9cblx0XHRwbHVnaW4gOiBmdW5jdGlvbiAoZGVjbywgb3B0cykge1xuXHRcdFx0dmFyIENoaWxkID0gJC5qc3RyZWUucGx1Z2luc1tkZWNvXTtcblx0XHRcdGlmKENoaWxkKSB7XG5cdFx0XHRcdHRoaXMuX2RhdGFbZGVjb10gPSB7fTtcblx0XHRcdFx0Q2hpbGQucHJvdG90eXBlID0gdGhpcztcblx0XHRcdFx0cmV0dXJuIG5ldyBDaGlsZChvcHRzLCB0aGlzKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogdXNlZCB0byBkZWNvcmF0ZSBhbiBpbnN0YW5jZSB3aXRoIGEgcGx1Z2luLiBVc2VkIGludGVybmFsbHkuXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKiBAbmFtZSBpbml0KGVsLCBvcHRvbnMpXG5cdFx0ICogQHBhcmFtIHtET01FbGVtZW50fGpRdWVyeXxTdHJpbmd9IGVsIHRoZSBlbGVtZW50IHdlIGFyZSB0cmFuc2Zvcm1pbmdcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBvcHRpb25zIGZvciB0aGlzIGluc3RhbmNlXG5cdFx0ICogQHRyaWdnZXIgaW5pdC5qc3RyZWUsIGxvYWRpbmcuanN0cmVlLCBsb2FkZWQuanN0cmVlLCByZWFkeS5qc3RyZWUsIGNoYW5nZWQuanN0cmVlXG5cdFx0ICovXG5cdFx0aW5pdCA6IGZ1bmN0aW9uIChlbCwgb3B0aW9ucykge1xuXHRcdFx0dGhpcy5fbW9kZWwgPSB7XG5cdFx0XHRcdGRhdGEgOiB7XG5cdFx0XHRcdFx0JyMnIDoge1xuXHRcdFx0XHRcdFx0aWQgOiAnIycsXG5cdFx0XHRcdFx0XHRwYXJlbnQgOiBudWxsLFxuXHRcdFx0XHRcdFx0cGFyZW50cyA6IFtdLFxuXHRcdFx0XHRcdFx0Y2hpbGRyZW4gOiBbXSxcblx0XHRcdFx0XHRcdGNoaWxkcmVuX2QgOiBbXSxcblx0XHRcdFx0XHRcdHN0YXRlIDogeyBsb2FkZWQgOiBmYWxzZSB9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LFxuXHRcdFx0XHRjaGFuZ2VkIDogW10sXG5cdFx0XHRcdGZvcmNlX2Z1bGxfcmVkcmF3IDogZmFsc2UsXG5cdFx0XHRcdHJlZHJhd190aW1lb3V0IDogZmFsc2UsXG5cdFx0XHRcdGRlZmF1bHRfc3RhdGUgOiB7XG5cdFx0XHRcdFx0bG9hZGVkIDogdHJ1ZSxcblx0XHRcdFx0XHRvcGVuZWQgOiBmYWxzZSxcblx0XHRcdFx0XHRzZWxlY3RlZCA6IGZhbHNlLFxuXHRcdFx0XHRcdGRpc2FibGVkIDogZmFsc2Vcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdFx0dGhpcy5lbGVtZW50ID0gJChlbCkuYWRkQ2xhc3MoJ2pzdHJlZSBqc3RyZWUtJyArIHRoaXMuX2lkKTtcblx0XHRcdHRoaXMuc2V0dGluZ3MgPSBvcHRpb25zO1xuXHRcdFx0dGhpcy5lbGVtZW50LmJpbmQoXCJkZXN0cm95ZWRcIiwgJC5wcm94eSh0aGlzLnRlYXJkb3duLCB0aGlzKSk7XG5cblx0XHRcdHRoaXMuX2RhdGEuY29yZS5yZWFkeSA9IGZhbHNlO1xuXHRcdFx0dGhpcy5fZGF0YS5jb3JlLmxvYWRlZCA9IGZhbHNlO1xuXHRcdFx0dGhpcy5fZGF0YS5jb3JlLnJ0bCA9ICh0aGlzLmVsZW1lbnQuY3NzKFwiZGlyZWN0aW9uXCIpID09PSBcInJ0bFwiKTtcblx0XHRcdHRoaXMuZWxlbWVudFt0aGlzLl9kYXRhLmNvcmUucnRsID8gJ2FkZENsYXNzJyA6ICdyZW1vdmVDbGFzcyddKFwianN0cmVlLXJ0bFwiKTtcblx0XHRcdHRoaXMuZWxlbWVudC5hdHRyKCdyb2xlJywndHJlZScpO1xuXG5cdFx0XHR0aGlzLmJpbmQoKTtcblx0XHRcdC8qKlxuXHRcdFx0ICogdHJpZ2dlcmVkIGFmdGVyIGFsbCBldmVudHMgYXJlIGJvdW5kXG5cdFx0XHQgKiBAZXZlbnRcblx0XHRcdCAqIEBuYW1lIGluaXQuanN0cmVlXG5cdFx0XHQgKi9cblx0XHRcdHRoaXMudHJpZ2dlcihcImluaXRcIik7XG5cblx0XHRcdHRoaXMuX2RhdGEuY29yZS5vcmlnaW5hbF9jb250YWluZXJfaHRtbCA9IHRoaXMuZWxlbWVudC5maW5kKFwiID4gdWwgPiBsaVwiKS5jbG9uZSh0cnVlKTtcblx0XHRcdHRoaXMuX2RhdGEuY29yZS5vcmlnaW5hbF9jb250YWluZXJfaHRtbFxuXHRcdFx0XHQuZmluZChcImxpXCIpLmFkZEJhY2soKVxuXHRcdFx0XHQuY29udGVudHMoKS5maWx0ZXIoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMubm9kZVR5cGUgPT09IDMgJiYgKCF0aGlzLm5vZGVWYWx1ZSB8fCAvXlxccyskLy50ZXN0KHRoaXMubm9kZVZhbHVlKSk7XG5cdFx0XHRcdH0pXG5cdFx0XHRcdC5yZW1vdmUoKTtcblx0XHRcdHRoaXMuZWxlbWVudC5odG1sKFwiPFwiK1widWwgY2xhc3M9J2pzdHJlZS1jb250YWluZXItdWwganN0cmVlLWNoaWxkcmVuJz48XCIrXCJsaSBjbGFzcz0nanN0cmVlLWluaXRpYWwtbm9kZSBqc3RyZWUtbG9hZGluZyBqc3RyZWUtbGVhZiBqc3RyZWUtbGFzdCc+PGkgY2xhc3M9J2pzdHJlZS1pY29uIGpzdHJlZS1vY2wnPjwvaT48XCIrXCJhIGNsYXNzPSdqc3RyZWUtYW5jaG9yJyBocmVmPScjJz48aSBjbGFzcz0nanN0cmVlLWljb24ganN0cmVlLXRoZW1laWNvbi1oaWRkZW4nPjwvaT5cIiArIHRoaXMuZ2V0X3N0cmluZyhcIkxvYWRpbmcgLi4uXCIpICsgXCI8L2E+PC9saT48L3VsPlwiKTtcblx0XHRcdHRoaXMuX2RhdGEuY29yZS5saV9oZWlnaHQgPSB0aGlzLmdldF9jb250YWluZXJfdWwoKS5jaGlsZHJlbihcImxpOmVxKDApXCIpLmhlaWdodCgpIHx8IDI0O1xuXHRcdFx0LyoqXG5cdFx0XHQgKiB0cmlnZ2VyZWQgYWZ0ZXIgdGhlIGxvYWRpbmcgdGV4dCBpcyBzaG93biBhbmQgYmVmb3JlIGxvYWRpbmcgc3RhcnRzXG5cdFx0XHQgKiBAZXZlbnRcblx0XHRcdCAqIEBuYW1lIGxvYWRpbmcuanN0cmVlXG5cdFx0XHQgKi9cblx0XHRcdHRoaXMudHJpZ2dlcihcImxvYWRpbmdcIik7XG5cdFx0XHR0aGlzLmxvYWRfbm9kZSgnIycpO1xuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogZGVzdHJveSBhbiBpbnN0YW5jZVxuXHRcdCAqIEBuYW1lIGRlc3Ryb3koKVxuXHRcdCAqIEBwYXJhbSAge0Jvb2xlYW59IGtlZXBfaHRtbCBpZiBub3Qgc2V0IHRvIGB0cnVlYCB0aGUgY29udGFpbmVyIHdpbGwgYmUgZW1wdGllZCwgb3RoZXJ3aXNlIHRoZSBjdXJyZW50IERPTSBlbGVtZW50cyB3aWxsIGJlIGtlcHQgaW50YWN0XG5cdFx0ICovXG5cdFx0ZGVzdHJveSA6IGZ1bmN0aW9uIChrZWVwX2h0bWwpIHtcblx0XHRcdGlmKCFrZWVwX2h0bWwpIHsgdGhpcy5lbGVtZW50LmVtcHR5KCk7IH1cblx0XHRcdHRoaXMuZWxlbWVudC51bmJpbmQoXCJkZXN0cm95ZWRcIiwgdGhpcy50ZWFyZG93bik7XG5cdFx0XHR0aGlzLnRlYXJkb3duKCk7XG5cdFx0fSxcblx0XHQvKipcblx0XHQgKiBwYXJ0IG9mIHRoZSBkZXN0cm95aW5nIG9mIGFuIGluc3RhbmNlLiBVc2VkIGludGVybmFsbHkuXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKiBAbmFtZSB0ZWFyZG93bigpXG5cdFx0ICovXG5cdFx0dGVhcmRvd24gOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR0aGlzLnVuYmluZCgpO1xuXHRcdFx0dGhpcy5lbGVtZW50XG5cdFx0XHRcdC5yZW1vdmVDbGFzcygnanN0cmVlJylcblx0XHRcdFx0LnJlbW92ZURhdGEoJ2pzdHJlZScpXG5cdFx0XHRcdC5maW5kKFwiW2NsYXNzXj0nanN0cmVlJ11cIilcblx0XHRcdFx0XHQuYWRkQmFjaygpXG5cdFx0XHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmNsYXNzTmFtZS5yZXBsYWNlKC9qc3RyZWVbXiBdKnwkL2lnLCcnKTsgfSk7XG5cdFx0XHR0aGlzLmVsZW1lbnQgPSBudWxsO1xuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogYmluZCBhbGwgZXZlbnRzLiBVc2VkIGludGVybmFsbHkuXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKiBAbmFtZSBiaW5kKClcblx0XHQgKi9cblx0XHRiaW5kIDogZnVuY3Rpb24gKCkge1xuXHRcdFx0dGhpcy5lbGVtZW50XG5cdFx0XHRcdC5vbihcImRibGNsaWNrLmpzdHJlZVwiLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0XHRpZihkb2N1bWVudC5zZWxlY3Rpb24gJiYgZG9jdW1lbnQuc2VsZWN0aW9uLmVtcHR5KSB7XG5cdFx0XHRcdFx0XHRcdGRvY3VtZW50LnNlbGVjdGlvbi5lbXB0eSgpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGlmKHdpbmRvdy5nZXRTZWxlY3Rpb24pIHtcblx0XHRcdFx0XHRcdFx0XHR2YXIgc2VsID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuXHRcdFx0XHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRzZWwucmVtb3ZlQWxsUmFuZ2VzKCk7XG5cdFx0XHRcdFx0XHRcdFx0XHRzZWwuY29sbGFwc2UoKTtcblx0XHRcdFx0XHRcdFx0XHR9IGNhdGNoIChpZ25vcmUpIHsgfVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSlcblx0XHRcdFx0Lm9uKFwiY2xpY2suanN0cmVlXCIsIFwiLmpzdHJlZS1vY2xcIiwgJC5wcm94eShmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHRcdFx0dGhpcy50b2dnbGVfbm9kZShlLnRhcmdldCk7XG5cdFx0XHRcdFx0fSwgdGhpcykpXG5cdFx0XHRcdC5vbihcImNsaWNrLmpzdHJlZVwiLCBcIi5qc3RyZWUtYW5jaG9yXCIsICQucHJveHkoZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHRcdCQoZS5jdXJyZW50VGFyZ2V0KS5mb2N1cygpO1xuXHRcdFx0XHRcdFx0dGhpcy5hY3RpdmF0ZV9ub2RlKGUuY3VycmVudFRhcmdldCwgZSk7XG5cdFx0XHRcdFx0fSwgdGhpcykpXG5cdFx0XHRcdC5vbigna2V5ZG93bi5qc3RyZWUnLCAnLmpzdHJlZS1hbmNob3InLCAkLnByb3h5KGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRcdFx0XHRpZihlLnRhcmdldC50YWdOYW1lID09PSBcIklOUFVUXCIpIHsgcmV0dXJuIHRydWU7IH1cblx0XHRcdFx0XHRcdHZhciBvID0gbnVsbDtcblx0XHRcdFx0XHRcdHN3aXRjaChlLndoaWNoKSB7XG5cdFx0XHRcdFx0XHRcdGNhc2UgMTM6XG5cdFx0XHRcdFx0XHRcdGNhc2UgMzI6XG5cdFx0XHRcdFx0XHRcdFx0ZS50eXBlID0gXCJjbGlja1wiO1xuXHRcdFx0XHRcdFx0XHRcdCQoZS5jdXJyZW50VGFyZ2V0KS50cmlnZ2VyKGUpO1xuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRjYXNlIDM3OlxuXHRcdFx0XHRcdFx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHRcdFx0XHRpZih0aGlzLmlzX29wZW4oZS5jdXJyZW50VGFyZ2V0KSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0dGhpcy5jbG9zZV9ub2RlKGUuY3VycmVudFRhcmdldCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0byA9IHRoaXMuZ2V0X3ByZXZfZG9tKGUuY3VycmVudFRhcmdldCk7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZihvICYmIG8ubGVuZ3RoKSB7IG8uY2hpbGRyZW4oJy5qc3RyZWUtYW5jaG9yJykuZm9jdXMoKTsgfVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0Y2FzZSAzODpcblx0XHRcdFx0XHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0XHRcdFx0byA9IHRoaXMuZ2V0X3ByZXZfZG9tKGUuY3VycmVudFRhcmdldCk7XG5cdFx0XHRcdFx0XHRcdFx0aWYobyAmJiBvLmxlbmd0aCkgeyBvLmNoaWxkcmVuKCcuanN0cmVlLWFuY2hvcicpLmZvY3VzKCk7IH1cblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0Y2FzZSAzOTpcblx0XHRcdFx0XHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0XHRcdFx0aWYodGhpcy5pc19jbG9zZWQoZS5jdXJyZW50VGFyZ2V0KSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0dGhpcy5vcGVuX25vZGUoZS5jdXJyZW50VGFyZ2V0LCBmdW5jdGlvbiAobykgeyB0aGlzLmdldF9ub2RlKG8sIHRydWUpLmNoaWxkcmVuKCcuanN0cmVlLWFuY2hvcicpLmZvY3VzKCk7IH0pO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdG8gPSB0aGlzLmdldF9uZXh0X2RvbShlLmN1cnJlbnRUYXJnZXQpO1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYobyAmJiBvLmxlbmd0aCkgeyBvLmNoaWxkcmVuKCcuanN0cmVlLWFuY2hvcicpLmZvY3VzKCk7IH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdGNhc2UgNDA6XG5cdFx0XHRcdFx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdFx0XHRcdG8gPSB0aGlzLmdldF9uZXh0X2RvbShlLmN1cnJlbnRUYXJnZXQpO1xuXHRcdFx0XHRcdFx0XHRcdGlmKG8gJiYgby5sZW5ndGgpIHsgby5jaGlsZHJlbignLmpzdHJlZS1hbmNob3InKS5mb2N1cygpOyB9XG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdC8vIGRlbGV0ZVxuXHRcdFx0XHRcdFx0XHRjYXNlIDQ2OlxuXHRcdFx0XHRcdFx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHRcdFx0XHRvID0gdGhpcy5nZXRfbm9kZShlLmN1cnJlbnRUYXJnZXQpO1xuXHRcdFx0XHRcdFx0XHRcdGlmKG8gJiYgby5pZCAmJiBvLmlkICE9PSAnIycpIHtcblx0XHRcdFx0XHRcdFx0XHRcdG8gPSB0aGlzLmlzX3NlbGVjdGVkKG8pID8gdGhpcy5nZXRfc2VsZWN0ZWQoKSA6IG87XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyB0aGlzLmRlbGV0ZV9ub2RlKG8pO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0Ly8gZjJcblx0XHRcdFx0XHRcdFx0Y2FzZSAxMTM6XG5cdFx0XHRcdFx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdFx0XHRcdG8gPSB0aGlzLmdldF9ub2RlKGUuY3VycmVudFRhcmdldCk7XG5cdFx0XHRcdFx0XHRcdFx0LyohXG5cdFx0XHRcdFx0XHRcdFx0aWYobyAmJiBvLmlkICYmIG8uaWQgIT09ICcjJykge1xuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gdGhpcy5lZGl0KG8pO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHQqL1xuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0XHRcdC8vIGNvbnNvbGUubG9nKGUud2hpY2gpO1xuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sIHRoaXMpKVxuXHRcdFx0XHQub24oXCJsb2FkX25vZGUuanN0cmVlXCIsICQucHJveHkoZnVuY3Rpb24gKGUsIGRhdGEpIHtcblx0XHRcdFx0XHRcdGlmKGRhdGEuc3RhdHVzKSB7XG5cdFx0XHRcdFx0XHRcdGlmKGRhdGEubm9kZS5pZCA9PT0gJyMnICYmICF0aGlzLl9kYXRhLmNvcmUubG9hZGVkKSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5fZGF0YS5jb3JlLmxvYWRlZCA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdFx0LyoqXG5cdFx0XHRcdFx0XHRcdFx0ICogdHJpZ2dlcmVkIGFmdGVyIHRoZSByb290IG5vZGUgaXMgbG9hZGVkIGZvciB0aGUgZmlyc3QgdGltZVxuXHRcdFx0XHRcdFx0XHRcdCAqIEBldmVudFxuXHRcdFx0XHRcdFx0XHRcdCAqIEBuYW1lIGxvYWRlZC5qc3RyZWVcblx0XHRcdFx0XHRcdFx0XHQgKi9cblx0XHRcdFx0XHRcdFx0XHR0aGlzLnRyaWdnZXIoXCJsb2FkZWRcIik7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0aWYoIXRoaXMuX2RhdGEuY29yZS5yZWFkeSAmJiAhdGhpcy5nZXRfY29udGFpbmVyX3VsKCkuZmluZCgnLmpzdHJlZS1sb2FkaW5nOmVxKDApJykubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5fZGF0YS5jb3JlLnJlYWR5ID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0XHRpZih0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZih0aGlzLnNldHRpbmdzLmNvcmUuZXhwYW5kX3NlbGVjdGVkX29ubG9hZCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR2YXIgdG1wID0gW10sIGksIGo7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGZvcihpID0gMCwgaiA9IHRoaXMuX2RhdGEuY29yZS5zZWxlY3RlZC5sZW5ndGg7IGkgPCBqOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0bXAgPSB0bXAuY29uY2F0KHRoaXMuX21vZGVsLmRhdGFbdGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkW2ldXS5wYXJlbnRzKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0bXAgPSAkLnZha2F0YS5hcnJheV91bmlxdWUodG1wKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0Zm9yKGkgPSAwLCBqID0gdG1wLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRoaXMub3Blbl9ub2RlKHRtcFtpXSwgZmFsc2UsIDApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR0aGlzLnRyaWdnZXIoJ2NoYW5nZWQnLCB7ICdhY3Rpb24nIDogJ3JlYWR5JywgJ3NlbGVjdGVkJyA6IHRoaXMuX2RhdGEuY29yZS5zZWxlY3RlZCB9KTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0LyoqXG5cdFx0XHRcdFx0XHRcdFx0ICogdHJpZ2dlcmVkIGFmdGVyIGFsbCBub2RlcyBhcmUgZmluaXNoZWQgbG9hZGluZ1xuXHRcdFx0XHRcdFx0XHRcdCAqIEBldmVudFxuXHRcdFx0XHRcdFx0XHRcdCAqIEBuYW1lIHJlYWR5LmpzdHJlZVxuXHRcdFx0XHRcdFx0XHRcdCAqL1xuXHRcdFx0XHRcdFx0XHRcdHNldFRpbWVvdXQoJC5wcm94eShmdW5jdGlvbiAoKSB7IHRoaXMudHJpZ2dlcihcInJlYWR5XCIpOyB9LCB0aGlzKSwgMCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LCB0aGlzKSlcblx0XHRcdFx0Ly8gVEhFTUUgUkVMQVRFRFxuXHRcdFx0XHQub24oXCJpbml0LmpzdHJlZVwiLCAkLnByb3h5KGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRcdHZhciBzID0gdGhpcy5zZXR0aW5ncy5jb3JlLnRoZW1lcztcblx0XHRcdFx0XHRcdHRoaXMuX2RhdGEuY29yZS50aGVtZXMuZG90c1x0XHRcdD0gcy5kb3RzO1xuXHRcdFx0XHRcdFx0dGhpcy5fZGF0YS5jb3JlLnRoZW1lcy5zdHJpcGVzXHRcdD0gcy5zdHJpcGVzO1xuXHRcdFx0XHRcdFx0dGhpcy5fZGF0YS5jb3JlLnRoZW1lcy5pY29uc1x0XHQ9IHMuaWNvbnM7XG5cdFx0XHRcdFx0XHR0aGlzLnNldF90aGVtZShzLm5hbWUgfHwgXCJkZWZhdWx0XCIsIHMudXJsKTtcblx0XHRcdFx0XHRcdHRoaXMuc2V0X3RoZW1lX3ZhcmlhbnQocy52YXJpYW50KTtcblx0XHRcdFx0XHR9LCB0aGlzKSlcblx0XHRcdFx0Lm9uKFwibG9hZGluZy5qc3RyZWVcIiwgJC5wcm94eShmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0XHR0aGlzWyB0aGlzLl9kYXRhLmNvcmUudGhlbWVzLmRvdHMgPyBcInNob3dfZG90c1wiIDogXCJoaWRlX2RvdHNcIiBdKCk7XG5cdFx0XHRcdFx0XHR0aGlzWyB0aGlzLl9kYXRhLmNvcmUudGhlbWVzLmljb25zID8gXCJzaG93X2ljb25zXCIgOiBcImhpZGVfaWNvbnNcIiBdKCk7XG5cdFx0XHRcdFx0XHR0aGlzWyB0aGlzLl9kYXRhLmNvcmUudGhlbWVzLnN0cmlwZXMgPyBcInNob3dfc3RyaXBlc1wiIDogXCJoaWRlX3N0cmlwZXNcIiBdKCk7XG5cdFx0XHRcdFx0fSwgdGhpcykpXG5cdFx0XHRcdC5vbignYmx1ci5qc3RyZWUnLCAnLmpzdHJlZS1hbmNob3InLCAkLnByb3h5KGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRcdFx0XHQkKGUuY3VycmVudFRhcmdldCkuZmlsdGVyKCcuanN0cmVlLWhvdmVyZWQnKS5tb3VzZWxlYXZlKCk7XG5cdFx0XHRcdFx0fSwgdGhpcykpXG5cdFx0XHRcdC5vbignZm9jdXMuanN0cmVlJywgJy5qc3RyZWUtYW5jaG9yJywgJC5wcm94eShmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHRcdFx0dGhpcy5lbGVtZW50LmZpbmQoJy5qc3RyZWUtaG92ZXJlZCcpLm5vdChlLmN1cnJlbnRUYXJnZXQpLm1vdXNlbGVhdmUoKTtcblx0XHRcdFx0XHRcdCQoZS5jdXJyZW50VGFyZ2V0KS5tb3VzZWVudGVyKCk7XG5cdFx0XHRcdFx0fSwgdGhpcykpXG5cdFx0XHRcdC5vbignbW91c2VlbnRlci5qc3RyZWUnLCAnLmpzdHJlZS1hbmNob3InLCAkLnByb3h5KGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRcdFx0XHR0aGlzLmhvdmVyX25vZGUoZS5jdXJyZW50VGFyZ2V0KTtcblx0XHRcdFx0XHR9LCB0aGlzKSlcblx0XHRcdFx0Lm9uKCdtb3VzZWxlYXZlLmpzdHJlZScsICcuanN0cmVlLWFuY2hvcicsICQucHJveHkoZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0XHRcdHRoaXMuZGVob3Zlcl9ub2RlKGUuY3VycmVudFRhcmdldCk7XG5cdFx0XHRcdFx0fSwgdGhpcykpO1xuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogcGFydCBvZiB0aGUgZGVzdHJveWluZyBvZiBhbiBpbnN0YW5jZS4gVXNlZCBpbnRlcm5hbGx5LlxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICogQG5hbWUgdW5iaW5kKClcblx0XHQgKi9cblx0XHR1bmJpbmQgOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR0aGlzLmVsZW1lbnQub2ZmKCcuanN0cmVlJyk7XG5cdFx0XHQkKGRvY3VtZW50KS5vZmYoJy5qc3RyZWUtJyArIHRoaXMuX2lkKTtcblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIHRyaWdnZXIgYW4gZXZlbnQuIFVzZWQgaW50ZXJuYWxseS5cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqIEBuYW1lIHRyaWdnZXIoZXYgWywgZGF0YV0pXG5cdFx0ICogQHBhcmFtICB7U3RyaW5nfSBldiB0aGUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gdHJpZ2dlclxuXHRcdCAqIEBwYXJhbSAge09iamVjdH0gZGF0YSBhZGRpdGlvbmFsIGRhdGEgdG8gcGFzcyB3aXRoIHRoZSBldmVudFxuXHRcdCAqL1xuXHRcdHRyaWdnZXIgOiBmdW5jdGlvbiAoZXYsIGRhdGEpIHtcblx0XHRcdGlmKCFkYXRhKSB7XG5cdFx0XHRcdGRhdGEgPSB7fTtcblx0XHRcdH1cblx0XHRcdGRhdGEuaW5zdGFuY2UgPSB0aGlzO1xuXHRcdFx0dGhpcy5lbGVtZW50LnRyaWdnZXJIYW5kbGVyKGV2LnJlcGxhY2UoJy5qc3RyZWUnLCcnKSArICcuanN0cmVlJywgZGF0YSk7XG5cdFx0fSxcblx0XHQvKipcblx0XHQgKiByZXR1cm5zIHRoZSBqUXVlcnkgZXh0ZW5kZWQgaW5zdGFuY2UgY29udGFpbmVyXG5cdFx0ICogQG5hbWUgZ2V0X2NvbnRhaW5lcigpXG5cdFx0ICogQHJldHVybiB7alF1ZXJ5fVxuXHRcdCAqL1xuXHRcdGdldF9jb250YWluZXIgOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lbGVtZW50O1xuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogcmV0dXJucyB0aGUgalF1ZXJ5IGV4dGVuZGVkIG1haW4gVUwgbm9kZSBpbnNpZGUgdGhlIGluc3RhbmNlIGNvbnRhaW5lci4gVXNlZCBpbnRlcm5hbGx5LlxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICogQG5hbWUgZ2V0X2NvbnRhaW5lcl91bCgpXG5cdFx0ICogQHJldHVybiB7alF1ZXJ5fVxuXHRcdCAqL1xuXHRcdGdldF9jb250YWluZXJfdWwgOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lbGVtZW50LmNoaWxkcmVuKFwiLmpzdHJlZS1jaGlsZHJlbjplcSgwKVwiKTtcblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIGdldHMgc3RyaW5nIHJlcGxhY2VtZW50cyAobG9jYWxpemF0aW9uKS4gVXNlZCBpbnRlcm5hbGx5LlxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICogQG5hbWUgZ2V0X3N0cmluZyhrZXkpXG5cdFx0ICogQHBhcmFtICB7U3RyaW5nfSBrZXlcblx0XHQgKiBAcmV0dXJuIHtTdHJpbmd9XG5cdFx0ICovXG5cdFx0Z2V0X3N0cmluZyA6IGZ1bmN0aW9uIChrZXkpIHtcblx0XHRcdHZhciBhID0gdGhpcy5zZXR0aW5ncy5jb3JlLnN0cmluZ3M7XG5cdFx0XHRpZigkLmlzRnVuY3Rpb24oYSkpIHsgcmV0dXJuIGEuY2FsbCh0aGlzLCBrZXkpOyB9XG5cdFx0XHRpZihhICYmIGFba2V5XSkgeyByZXR1cm4gYVtrZXldOyB9XG5cdFx0XHRyZXR1cm4ga2V5O1xuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogZ2V0cyB0aGUgZmlyc3QgY2hpbGQgb2YgYSBET00gbm9kZS4gVXNlZCBpbnRlcm5hbGx5LlxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICogQG5hbWUgX2ZpcnN0Q2hpbGQoZG9tKVxuXHRcdCAqIEBwYXJhbSAge0RPTUVsZW1lbnR9IGRvbVxuXHRcdCAqIEByZXR1cm4ge0RPTUVsZW1lbnR9XG5cdFx0ICovXG5cdFx0X2ZpcnN0Q2hpbGQgOiBmdW5jdGlvbiAoZG9tKSB7XG5cdFx0XHRkb20gPSBkb20gPyBkb20uZmlyc3RDaGlsZCA6IG51bGw7XG5cdFx0XHR3aGlsZShkb20gIT09IG51bGwgJiYgZG9tLm5vZGVUeXBlICE9PSAxKSB7XG5cdFx0XHRcdGRvbSA9IGRvbS5uZXh0U2libGluZztcblx0XHRcdH1cblx0XHRcdHJldHVybiBkb207XG5cdFx0fSxcblx0XHQvKipcblx0XHQgKiBnZXRzIHRoZSBuZXh0IHNpYmxpbmcgb2YgYSBET00gbm9kZS4gVXNlZCBpbnRlcm5hbGx5LlxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICogQG5hbWUgX25leHRTaWJsaW5nKGRvbSlcblx0XHQgKiBAcGFyYW0gIHtET01FbGVtZW50fSBkb21cblx0XHQgKiBAcmV0dXJuIHtET01FbGVtZW50fVxuXHRcdCAqL1xuXHRcdF9uZXh0U2libGluZyA6IGZ1bmN0aW9uIChkb20pIHtcblx0XHRcdGRvbSA9IGRvbSA/IGRvbS5uZXh0U2libGluZyA6IG51bGw7XG5cdFx0XHR3aGlsZShkb20gIT09IG51bGwgJiYgZG9tLm5vZGVUeXBlICE9PSAxKSB7XG5cdFx0XHRcdGRvbSA9IGRvbS5uZXh0U2libGluZztcblx0XHRcdH1cblx0XHRcdHJldHVybiBkb207XG5cdFx0fSxcblx0XHQvKipcblx0XHQgKiBnZXRzIHRoZSBwcmV2aW91cyBzaWJsaW5nIG9mIGEgRE9NIG5vZGUuIFVzZWQgaW50ZXJuYWxseS5cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqIEBuYW1lIF9wcmV2aW91c1NpYmxpbmcoZG9tKVxuXHRcdCAqIEBwYXJhbSAge0RPTUVsZW1lbnR9IGRvbVxuXHRcdCAqIEByZXR1cm4ge0RPTUVsZW1lbnR9XG5cdFx0ICovXG5cdFx0X3ByZXZpb3VzU2libGluZyA6IGZ1bmN0aW9uIChkb20pIHtcblx0XHRcdGRvbSA9IGRvbSA/IGRvbS5wcmV2aW91c1NpYmxpbmcgOiBudWxsO1xuXHRcdFx0d2hpbGUoZG9tICE9PSBudWxsICYmIGRvbS5ub2RlVHlwZSAhPT0gMSkge1xuXHRcdFx0XHRkb20gPSBkb20ucHJldmlvdXNTaWJsaW5nO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGRvbTtcblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIGdldCB0aGUgSlNPTiByZXByZXNlbnRhdGlvbiBvZiBhIG5vZGUgKG9yIHRoZSBhY3R1YWwgalF1ZXJ5IGV4dGVuZGVkIERPTSBub2RlKSBieSB1c2luZyBhbnkgaW5wdXQgKGNoaWxkIERPTSBlbGVtZW50LCBJRCBzdHJpbmcsIHNlbGVjdG9yLCBldGMpXG5cdFx0ICogQG5hbWUgZ2V0X25vZGUob2JqIFssIGFzX2RvbV0pXG5cdFx0ICogQHBhcmFtICB7bWl4ZWR9IG9ialxuXHRcdCAqIEBwYXJhbSAge0Jvb2xlYW59IGFzX2RvbVxuXHRcdCAqIEByZXR1cm4ge09iamVjdHxqUXVlcnl9XG5cdFx0ICovXG5cdFx0Z2V0X25vZGUgOiBmdW5jdGlvbiAob2JqLCBhc19kb20pIHtcblx0XHRcdGlmKG9iaiAmJiBvYmouaWQpIHtcblx0XHRcdFx0b2JqID0gb2JqLmlkO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGRvbTtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGlmKHRoaXMuX21vZGVsLmRhdGFbb2JqXSkge1xuXHRcdFx0XHRcdG9iaiA9IHRoaXMuX21vZGVsLmRhdGFbb2JqXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIGlmKCgoZG9tID0gJChvYmosIHRoaXMuZWxlbWVudCkpLmxlbmd0aCB8fCAoZG9tID0gJCgnIycgKyBvYmoucmVwbGFjZSgkLmpzdHJlZS5pZHJlZ2V4LCdcXFxcJCYnKSwgdGhpcy5lbGVtZW50KSkubGVuZ3RoKSAmJiB0aGlzLl9tb2RlbC5kYXRhW2RvbS5jbG9zZXN0KCcuanN0cmVlLW5vZGUnKS5hdHRyKCdpZCcpXSkge1xuXHRcdFx0XHRcdG9iaiA9IHRoaXMuX21vZGVsLmRhdGFbZG9tLmNsb3Nlc3QoJy5qc3RyZWUtbm9kZScpLmF0dHIoJ2lkJyldO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgaWYoKGRvbSA9ICQob2JqLCB0aGlzLmVsZW1lbnQpKS5sZW5ndGggJiYgZG9tLmhhc0NsYXNzKCdqc3RyZWUnKSkge1xuXHRcdFx0XHRcdG9iaiA9IHRoaXMuX21vZGVsLmRhdGFbJyMnXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZihhc19kb20pIHtcblx0XHRcdFx0XHRvYmogPSBvYmouaWQgPT09ICcjJyA/IHRoaXMuZWxlbWVudCA6ICQoJyMnICsgb2JqLmlkLnJlcGxhY2UoJC5qc3RyZWUuaWRyZWdleCwnXFxcXCQmJyksIHRoaXMuZWxlbWVudCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIG9iajtcblx0XHRcdH0gY2F0Y2ggKGV4KSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogZ2V0IHRoZSBwYXRoIHRvIGEgbm9kZSwgZWl0aGVyIGNvbnNpc3Rpbmcgb2Ygbm9kZSB0ZXh0cywgb3Igb2Ygbm9kZSBJRHMsIG9wdGlvbmFsbHkgZ2x1ZWQgdG9nZXRoZXIgKG90aGVyd2lzZSBhbiBhcnJheSlcblx0XHQgKiBAbmFtZSBnZXRfcGF0aChvYmogWywgZ2x1ZSwgaWRzXSlcblx0XHQgKiBAcGFyYW0gIHttaXhlZH0gb2JqIHRoZSBub2RlXG5cdFx0ICogQHBhcmFtICB7U3RyaW5nfSBnbHVlIGlmIHlvdSB3YW50IHRoZSBwYXRoIGFzIGEgc3RyaW5nIC0gcGFzcyB0aGUgZ2x1ZSBoZXJlIChmb3IgZXhhbXBsZSAnLycpLCBpZiBhIGZhbHN5IHZhbHVlIGlzIHN1cHBsaWVkIGhlcmUsIGFuIGFycmF5IGlzIHJldHVybmVkXG5cdFx0ICogQHBhcmFtICB7Qm9vbGVhbn0gaWRzIGlmIHNldCB0byB0cnVlIGJ1aWxkIHRoZSBwYXRoIHVzaW5nIElELCBvdGhlcndpc2Ugbm9kZSB0ZXh0IGlzIHVzZWRcblx0XHQgKiBAcmV0dXJuIHttaXhlZH1cblx0XHQgKi9cblx0XHRnZXRfcGF0aCA6IGZ1bmN0aW9uIChvYmosIGdsdWUsIGlkcykge1xuXHRcdFx0b2JqID0gb2JqLnBhcmVudHMgPyBvYmogOiB0aGlzLmdldF9ub2RlKG9iaik7XG5cdFx0XHRpZighb2JqIHx8IG9iai5pZCA9PT0gJyMnIHx8ICFvYmoucGFyZW50cykge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHR2YXIgaSwgaiwgcCA9IFtdO1xuXHRcdFx0cC5wdXNoKGlkcyA/IG9iai5pZCA6IG9iai50ZXh0KTtcblx0XHRcdGZvcihpID0gMCwgaiA9IG9iai5wYXJlbnRzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuXHRcdFx0XHRwLnB1c2goaWRzID8gb2JqLnBhcmVudHNbaV0gOiB0aGlzLmdldF90ZXh0KG9iai5wYXJlbnRzW2ldKSk7XG5cdFx0XHR9XG5cdFx0XHRwID0gcC5yZXZlcnNlKCkuc2xpY2UoMSk7XG5cdFx0XHRyZXR1cm4gZ2x1ZSA/IHAuam9pbihnbHVlKSA6IHA7XG5cdFx0fSxcblx0XHQvKipcblx0XHQgKiBnZXQgdGhlIG5leHQgdmlzaWJsZSBub2RlIHRoYXQgaXMgYmVsb3cgdGhlIGBvYmpgIG5vZGUuIElmIGBzdHJpY3RgIGlzIHNldCB0byBgdHJ1ZWAgb25seSBzaWJsaW5nIG5vZGVzIGFyZSByZXR1cm5lZC5cblx0XHQgKiBAbmFtZSBnZXRfbmV4dF9kb20ob2JqIFssIHN0cmljdF0pXG5cdFx0ICogQHBhcmFtICB7bWl4ZWR9IG9ialxuXHRcdCAqIEBwYXJhbSAge0Jvb2xlYW59IHN0cmljdFxuXHRcdCAqIEByZXR1cm4ge2pRdWVyeX1cblx0XHQgKi9cblx0XHRnZXRfbmV4dF9kb20gOiBmdW5jdGlvbiAob2JqLCBzdHJpY3QpIHtcblx0XHRcdHZhciB0bXA7XG5cdFx0XHRvYmogPSB0aGlzLmdldF9ub2RlKG9iaiwgdHJ1ZSk7XG5cdFx0XHRpZihvYmpbMF0gPT09IHRoaXMuZWxlbWVudFswXSkge1xuXHRcdFx0XHR0bXAgPSB0aGlzLl9maXJzdENoaWxkKHRoaXMuZ2V0X2NvbnRhaW5lcl91bCgpWzBdKTtcblx0XHRcdFx0cmV0dXJuIHRtcCA/ICQodG1wKSA6IGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0aWYoIW9iaiB8fCAhb2JqLmxlbmd0aCkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHRpZihzdHJpY3QpIHtcblx0XHRcdFx0dG1wID0gdGhpcy5fbmV4dFNpYmxpbmcob2JqWzBdKTtcblx0XHRcdFx0cmV0dXJuIHRtcCA/ICQodG1wKSA6IGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0aWYob2JqLmhhc0NsYXNzKFwianN0cmVlLW9wZW5cIikpIHtcblx0XHRcdFx0dG1wID0gdGhpcy5fZmlyc3RDaGlsZChvYmouY2hpbGRyZW4oJy5qc3RyZWUtY2hpbGRyZW4nKVswXSk7XG5cdFx0XHRcdHJldHVybiB0bXAgPyAkKHRtcCkgOiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdGlmKCh0bXAgPSB0aGlzLl9uZXh0U2libGluZyhvYmpbMF0pKSAhPT0gbnVsbCkge1xuXHRcdFx0XHRyZXR1cm4gJCh0bXApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG9iai5wYXJlbnRzVW50aWwoXCIuanN0cmVlXCIsXCIuanN0cmVlLW5vZGVcIikubmV4dChcIi5qc3RyZWUtbm9kZVwiKS5lcSgwKTtcblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIGdldCB0aGUgcHJldmlvdXMgdmlzaWJsZSBub2RlIHRoYXQgaXMgYWJvdmUgdGhlIGBvYmpgIG5vZGUuIElmIGBzdHJpY3RgIGlzIHNldCB0byBgdHJ1ZWAgb25seSBzaWJsaW5nIG5vZGVzIGFyZSByZXR1cm5lZC5cblx0XHQgKiBAbmFtZSBnZXRfcHJldl9kb20ob2JqIFssIHN0cmljdF0pXG5cdFx0ICogQHBhcmFtICB7bWl4ZWR9IG9ialxuXHRcdCAqIEBwYXJhbSAge0Jvb2xlYW59IHN0cmljdFxuXHRcdCAqIEByZXR1cm4ge2pRdWVyeX1cblx0XHQgKi9cblx0XHRnZXRfcHJldl9kb20gOiBmdW5jdGlvbiAob2JqLCBzdHJpY3QpIHtcblx0XHRcdHZhciB0bXA7XG5cdFx0XHRvYmogPSB0aGlzLmdldF9ub2RlKG9iaiwgdHJ1ZSk7XG5cdFx0XHRpZihvYmpbMF0gPT09IHRoaXMuZWxlbWVudFswXSkge1xuXHRcdFx0XHR0bXAgPSB0aGlzLmdldF9jb250YWluZXJfdWwoKVswXS5sYXN0Q2hpbGQ7XG5cdFx0XHRcdHJldHVybiB0bXAgPyAkKHRtcCkgOiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdGlmKCFvYmogfHwgIW9iai5sZW5ndGgpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0aWYoc3RyaWN0KSB7XG5cdFx0XHRcdHRtcCA9IHRoaXMuX3ByZXZpb3VzU2libGluZyhvYmpbMF0pO1xuXHRcdFx0XHRyZXR1cm4gdG1wID8gJCh0bXApIDogZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHRpZigodG1wID0gdGhpcy5fcHJldmlvdXNTaWJsaW5nKG9ialswXSkpICE9PSBudWxsKSB7XG5cdFx0XHRcdG9iaiA9ICQodG1wKTtcblx0XHRcdFx0d2hpbGUob2JqLmhhc0NsYXNzKFwianN0cmVlLW9wZW5cIikpIHtcblx0XHRcdFx0XHRvYmogPSBvYmouY2hpbGRyZW4oXCIuanN0cmVlLWNoaWxkcmVuOmVxKDApXCIpLmNoaWxkcmVuKFwiLmpzdHJlZS1ub2RlOmxhc3RcIik7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIG9iajtcblx0XHRcdH1cblx0XHRcdHRtcCA9IG9ialswXS5wYXJlbnROb2RlLnBhcmVudE5vZGU7XG5cdFx0XHRyZXR1cm4gdG1wICYmIHRtcC5jbGFzc05hbWUgJiYgdG1wLmNsYXNzTmFtZS5pbmRleE9mKCdqc3RyZWUtbm9kZScpICE9PSAtMSA/ICQodG1wKSA6IGZhbHNlO1xuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogZ2V0IHRoZSBwYXJlbnQgSUQgb2YgYSBub2RlXG5cdFx0ICogQG5hbWUgZ2V0X3BhcmVudChvYmopXG5cdFx0ICogQHBhcmFtICB7bWl4ZWR9IG9ialxuXHRcdCAqIEByZXR1cm4ge1N0cmluZ31cblx0XHQgKi9cblx0XHRnZXRfcGFyZW50IDogZnVuY3Rpb24gKG9iaikge1xuXHRcdFx0b2JqID0gdGhpcy5nZXRfbm9kZShvYmopO1xuXHRcdFx0aWYoIW9iaiB8fCBvYmouaWQgPT09ICcjJykge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gb2JqLnBhcmVudDtcblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIGdldCBhIGpRdWVyeSBjb2xsZWN0aW9uIG9mIGFsbCB0aGUgY2hpbGRyZW4gb2YgYSBub2RlIChub2RlIG11c3QgYmUgcmVuZGVyZWQpXG5cdFx0ICogQG5hbWUgZ2V0X2NoaWxkcmVuX2RvbShvYmopXG5cdFx0ICogQHBhcmFtICB7bWl4ZWR9IG9ialxuXHRcdCAqIEByZXR1cm4ge2pRdWVyeX1cblx0XHQgKi9cblx0XHRnZXRfY2hpbGRyZW5fZG9tIDogZnVuY3Rpb24gKG9iaikge1xuXHRcdFx0b2JqID0gdGhpcy5nZXRfbm9kZShvYmosIHRydWUpO1xuXHRcdFx0aWYob2JqWzBdID09PSB0aGlzLmVsZW1lbnRbMF0pIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZ2V0X2NvbnRhaW5lcl91bCgpLmNoaWxkcmVuKFwiLmpzdHJlZS1ub2RlXCIpO1xuXHRcdFx0fVxuXHRcdFx0aWYoIW9iaiB8fCAhb2JqLmxlbmd0aCkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gb2JqLmNoaWxkcmVuKFwiLmpzdHJlZS1jaGlsZHJlblwiKS5jaGlsZHJlbihcIi5qc3RyZWUtbm9kZVwiKTtcblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIGNoZWNrcyBpZiBhIG5vZGUgaGFzIGNoaWxkcmVuXG5cdFx0ICogQG5hbWUgaXNfcGFyZW50KG9iailcblx0XHQgKiBAcGFyYW0gIHttaXhlZH0gb2JqXG5cdFx0ICogQHJldHVybiB7Qm9vbGVhbn1cblx0XHQgKi9cblx0XHRpc19wYXJlbnQgOiBmdW5jdGlvbiAob2JqKSB7XG5cdFx0XHRvYmogPSB0aGlzLmdldF9ub2RlKG9iaik7XG5cdFx0XHRyZXR1cm4gb2JqICYmIChvYmouc3RhdGUubG9hZGVkID09PSBmYWxzZSB8fCBvYmouY2hpbGRyZW4ubGVuZ3RoID4gMCk7XG5cdFx0fSxcblx0XHQvKipcblx0XHQgKiBjaGVja3MgaWYgYSBub2RlIGlzIGxvYWRlZCAoaXRzIGNoaWxkcmVuIGFyZSBhdmFpbGFibGUpXG5cdFx0ICogQG5hbWUgaXNfbG9hZGVkKG9iailcblx0XHQgKiBAcGFyYW0gIHttaXhlZH0gb2JqXG5cdFx0ICogQHJldHVybiB7Qm9vbGVhbn1cblx0XHQgKi9cblx0XHRpc19sb2FkZWQgOiBmdW5jdGlvbiAob2JqKSB7XG5cdFx0XHRvYmogPSB0aGlzLmdldF9ub2RlKG9iaik7XG5cdFx0XHRyZXR1cm4gb2JqICYmIG9iai5zdGF0ZS5sb2FkZWQ7XG5cdFx0fSxcblx0XHQvKipcblx0XHQgKiBjaGVjayBpZiBhIG5vZGUgaXMgY3VycmVudGx5IGxvYWRpbmcgKGZldGNoaW5nIGNoaWxkcmVuKVxuXHRcdCAqIEBuYW1lIGlzX2xvYWRpbmcob2JqKVxuXHRcdCAqIEBwYXJhbSAge21peGVkfSBvYmpcblx0XHQgKiBAcmV0dXJuIHtCb29sZWFufVxuXHRcdCAqL1xuXHRcdGlzX2xvYWRpbmcgOiBmdW5jdGlvbiAob2JqKSB7XG5cdFx0XHRvYmogPSB0aGlzLmdldF9ub2RlKG9iaik7XG5cdFx0XHRyZXR1cm4gb2JqICYmIG9iai5zdGF0ZSAmJiBvYmouc3RhdGUubG9hZGluZztcblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIGNoZWNrIGlmIGEgbm9kZSBpcyBvcGVuZWRcblx0XHQgKiBAbmFtZSBpc19vcGVuKG9iailcblx0XHQgKiBAcGFyYW0gIHttaXhlZH0gb2JqXG5cdFx0ICogQHJldHVybiB7Qm9vbGVhbn1cblx0XHQgKi9cblx0XHRpc19vcGVuIDogZnVuY3Rpb24gKG9iaikge1xuXHRcdFx0b2JqID0gdGhpcy5nZXRfbm9kZShvYmopO1xuXHRcdFx0cmV0dXJuIG9iaiAmJiBvYmouc3RhdGUub3BlbmVkO1xuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogY2hlY2sgaWYgYSBub2RlIGlzIGluIGEgY2xvc2VkIHN0YXRlXG5cdFx0ICogQG5hbWUgaXNfY2xvc2VkKG9iailcblx0XHQgKiBAcGFyYW0gIHttaXhlZH0gb2JqXG5cdFx0ICogQHJldHVybiB7Qm9vbGVhbn1cblx0XHQgKi9cblx0XHRpc19jbG9zZWQgOiBmdW5jdGlvbiAob2JqKSB7XG5cdFx0XHRvYmogPSB0aGlzLmdldF9ub2RlKG9iaik7XG5cdFx0XHRyZXR1cm4gb2JqICYmIHRoaXMuaXNfcGFyZW50KG9iaikgJiYgIW9iai5zdGF0ZS5vcGVuZWQ7XG5cdFx0fSxcblx0XHQvKipcblx0XHQgKiBjaGVjayBpZiBhIG5vZGUgaGFzIG5vIGNoaWxkcmVuXG5cdFx0ICogQG5hbWUgaXNfbGVhZihvYmopXG5cdFx0ICogQHBhcmFtICB7bWl4ZWR9IG9ialxuXHRcdCAqIEByZXR1cm4ge0Jvb2xlYW59XG5cdFx0ICovXG5cdFx0aXNfbGVhZiA6IGZ1bmN0aW9uIChvYmopIHtcblx0XHRcdHJldHVybiAhdGhpcy5pc19wYXJlbnQob2JqKTtcblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIGxvYWRzIGEgbm9kZSAoZmV0Y2hlcyBpdHMgY2hpbGRyZW4gdXNpbmcgdGhlIGBjb3JlLmRhdGFgIHNldHRpbmcpLiBNdWx0aXBsZSBub2RlcyBjYW4gYmUgcGFzc2VkIHRvIGJ5IHVzaW5nIGFuIGFycmF5LlxuXHRcdCAqIEBuYW1lIGxvYWRfbm9kZShvYmogWywgY2FsbGJhY2tdKVxuXHRcdCAqIEBwYXJhbSAge21peGVkfSBvYmpcblx0XHQgKiBAcGFyYW0gIHtmdW5jdGlvbn0gY2FsbGJhY2sgYSBmdW5jdGlvbiB0byBiZSBleGVjdXRlZCBvbmNlIGxvYWRpbmcgaXMgY29tcGxldGUsIHRoZSBmdW5jdGlvbiBpcyBleGVjdXRlZCBpbiB0aGUgaW5zdGFuY2UncyBzY29wZSBhbmQgcmVjZWl2ZXMgdHdvIGFyZ3VtZW50cyAtIHRoZSBub2RlIGFuZCBhIGJvb2xlYW4gc3RhdHVzXG5cdFx0ICogQHJldHVybiB7Qm9vbGVhbn1cblx0XHQgKiBAdHJpZ2dlciBsb2FkX25vZGUuanN0cmVlXG5cdFx0ICovXG5cdFx0bG9hZF9ub2RlIDogZnVuY3Rpb24gKG9iaiwgY2FsbGJhY2spIHtcblx0XHRcdHZhciBrLCBsLCBpLCBqLCBjO1xuXHRcdFx0aWYoJC5pc0FycmF5KG9iaikpIHtcblx0XHRcdFx0dGhpcy5fbG9hZF9ub2RlcyhvYmouc2xpY2UoKSwgY2FsbGJhY2spO1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdG9iaiA9IHRoaXMuZ2V0X25vZGUob2JqKTtcblx0XHRcdGlmKCFvYmopIHtcblx0XHRcdFx0aWYoY2FsbGJhY2spIHsgY2FsbGJhY2suY2FsbCh0aGlzLCBvYmosIGZhbHNlKTsgfVxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHQvLyBpZihvYmouc3RhdGUubG9hZGluZykgeyB9IC8vIHRoZSBub2RlIGlzIGFscmVhZHkgbG9hZGluZyAtIGp1c3Qgd2FpdCBmb3IgaXQgdG8gbG9hZCBhbmQgaW52b2tlIGNhbGxiYWNrPyBidXQgaWYgY2FsbGVkIGltcGxpY2l0bHkgaXQgc2hvdWxkIGJlIGxvYWRlZCBhZ2Fpbj9cblx0XHRcdGlmKG9iai5zdGF0ZS5sb2FkZWQpIHtcblx0XHRcdFx0b2JqLnN0YXRlLmxvYWRlZCA9IGZhbHNlO1xuXHRcdFx0XHRmb3IoayA9IDAsIGwgPSBvYmouY2hpbGRyZW5fZC5sZW5ndGg7IGsgPCBsOyBrKyspIHtcblx0XHRcdFx0XHRmb3IoaSA9IDAsIGogPSBvYmoucGFyZW50cy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcblx0XHRcdFx0XHRcdHRoaXMuX21vZGVsLmRhdGFbb2JqLnBhcmVudHNbaV1dLmNoaWxkcmVuX2QgPSAkLnZha2F0YS5hcnJheV9yZW1vdmVfaXRlbSh0aGlzLl9tb2RlbC5kYXRhW29iai5wYXJlbnRzW2ldXS5jaGlsZHJlbl9kLCBvYmouY2hpbGRyZW5fZFtrXSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmKHRoaXMuX21vZGVsLmRhdGFbb2JqLmNoaWxkcmVuX2Rba11dLnN0YXRlLnNlbGVjdGVkKSB7XG5cdFx0XHRcdFx0XHRjID0gdHJ1ZTtcblx0XHRcdFx0XHRcdHRoaXMuX2RhdGEuY29yZS5zZWxlY3RlZCA9ICQudmFrYXRhLmFycmF5X3JlbW92ZV9pdGVtKHRoaXMuX2RhdGEuY29yZS5zZWxlY3RlZCwgb2JqLmNoaWxkcmVuX2Rba10pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRkZWxldGUgdGhpcy5fbW9kZWwuZGF0YVtvYmouY2hpbGRyZW5fZFtrXV07XG5cdFx0XHRcdH1cblx0XHRcdFx0b2JqLmNoaWxkcmVuID0gW107XG5cdFx0XHRcdG9iai5jaGlsZHJlbl9kID0gW107XG5cdFx0XHRcdGlmKGMpIHtcblx0XHRcdFx0XHR0aGlzLnRyaWdnZXIoJ2NoYW5nZWQnLCB7ICdhY3Rpb24nIDogJ2xvYWRfbm9kZScsICdub2RlJyA6IG9iaiwgJ3NlbGVjdGVkJyA6IHRoaXMuX2RhdGEuY29yZS5zZWxlY3RlZCB9KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0b2JqLnN0YXRlLmxvYWRpbmcgPSB0cnVlO1xuXHRcdFx0dGhpcy5nZXRfbm9kZShvYmosIHRydWUpLmFkZENsYXNzKFwianN0cmVlLWxvYWRpbmdcIik7XG5cdFx0XHR0aGlzLl9sb2FkX25vZGUob2JqLCAkLnByb3h5KGZ1bmN0aW9uIChzdGF0dXMpIHtcblx0XHRcdFx0b2JqID0gdGhpcy5fbW9kZWwuZGF0YVtvYmouaWRdO1xuXHRcdFx0XHRvYmouc3RhdGUubG9hZGluZyA9IGZhbHNlO1xuXHRcdFx0XHRvYmouc3RhdGUubG9hZGVkID0gc3RhdHVzO1xuXHRcdFx0XHR2YXIgZG9tID0gdGhpcy5nZXRfbm9kZShvYmosIHRydWUpO1xuXHRcdFx0XHRpZihvYmouc3RhdGUubG9hZGVkICYmICFvYmouY2hpbGRyZW4ubGVuZ3RoICYmIGRvbSAmJiBkb20ubGVuZ3RoICYmICFkb20uaGFzQ2xhc3MoJ2pzdHJlZS1sZWFmJykpIHtcblx0XHRcdFx0XHRkb20ucmVtb3ZlQ2xhc3MoJ2pzdHJlZS1jbG9zZWQganN0cmVlLW9wZW4nKS5hZGRDbGFzcygnanN0cmVlLWxlYWYnKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRkb20ucmVtb3ZlQ2xhc3MoXCJqc3RyZWUtbG9hZGluZ1wiKTtcblx0XHRcdFx0LyoqXG5cdFx0XHRcdCAqIHRyaWdnZXJlZCBhZnRlciBhIG5vZGUgaXMgbG9hZGVkXG5cdFx0XHRcdCAqIEBldmVudFxuXHRcdFx0XHQgKiBAbmFtZSBsb2FkX25vZGUuanN0cmVlXG5cdFx0XHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBub2RlIHRoZSBub2RlIHRoYXQgd2FzIGxvYWRpbmdcblx0XHRcdFx0ICogQHBhcmFtIHtCb29sZWFufSBzdGF0dXMgd2FzIHRoZSBub2RlIGxvYWRlZCBzdWNjZXNzZnVsbHlcblx0XHRcdFx0ICovXG5cdFx0XHRcdHRoaXMudHJpZ2dlcignbG9hZF9ub2RlJywgeyBcIm5vZGVcIiA6IG9iaiwgXCJzdGF0dXNcIiA6IHN0YXR1cyB9KTtcblx0XHRcdFx0aWYoY2FsbGJhY2spIHtcblx0XHRcdFx0XHRjYWxsYmFjay5jYWxsKHRoaXMsIG9iaiwgc3RhdHVzKTtcblx0XHRcdFx0fVxuXHRcdFx0fSwgdGhpcykpO1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSxcblx0XHQvKipcblx0XHQgKiBsb2FkIGFuIGFycmF5IG9mIG5vZGVzICh3aWxsIGFsc28gbG9hZCB1bmF2YWlsYWJsZSBub2RlcyBhcyBzb29uIGFzIHRoZSBhcHBlYXIgaW4gdGhlIHN0cnVjdHVyZSkuIFVzZWQgaW50ZXJuYWxseS5cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqIEBuYW1lIF9sb2FkX25vZGVzKG5vZGVzIFssIGNhbGxiYWNrXSlcblx0XHQgKiBAcGFyYW0gIHthcnJheX0gbm9kZXNcblx0XHQgKiBAcGFyYW0gIHtmdW5jdGlvbn0gY2FsbGJhY2sgYSBmdW5jdGlvbiB0byBiZSBleGVjdXRlZCBvbmNlIGxvYWRpbmcgaXMgY29tcGxldGUsIHRoZSBmdW5jdGlvbiBpcyBleGVjdXRlZCBpbiB0aGUgaW5zdGFuY2UncyBzY29wZSBhbmQgcmVjZWl2ZXMgb25lIGFyZ3VtZW50IC0gdGhlIGFycmF5IHBhc3NlZCB0byBfbG9hZF9ub2Rlc1xuXHRcdCAqL1xuXHRcdF9sb2FkX25vZGVzIDogZnVuY3Rpb24gKG5vZGVzLCBjYWxsYmFjaywgaXNfY2FsbGJhY2spIHtcblx0XHRcdHZhciByID0gdHJ1ZSxcblx0XHRcdFx0YyA9IGZ1bmN0aW9uICgpIHsgdGhpcy5fbG9hZF9ub2Rlcyhub2RlcywgY2FsbGJhY2ssIHRydWUpOyB9LFxuXHRcdFx0XHRtID0gdGhpcy5fbW9kZWwuZGF0YSwgaSwgajtcblx0XHRcdGZvcihpID0gMCwgaiA9IG5vZGVzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuXHRcdFx0XHRpZihtW25vZGVzW2ldXSAmJiAoIW1bbm9kZXNbaV1dLnN0YXRlLmxvYWRlZCB8fCAhaXNfY2FsbGJhY2spKSB7XG5cdFx0XHRcdFx0aWYoIXRoaXMuaXNfbG9hZGluZyhub2Rlc1tpXSkpIHtcblx0XHRcdFx0XHRcdHRoaXMubG9hZF9ub2RlKG5vZGVzW2ldLCBjKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ciA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZihyKSB7XG5cdFx0XHRcdGlmKGNhbGxiYWNrICYmICFjYWxsYmFjay5kb25lKSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2suY2FsbCh0aGlzLCBub2Rlcyk7XG5cdFx0XHRcdFx0Y2FsbGJhY2suZG9uZSA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIGhhbmRsZXMgdGhlIGFjdHVhbCBsb2FkaW5nIG9mIGEgbm9kZS4gVXNlZCBvbmx5IGludGVybmFsbHkuXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKiBAbmFtZSBfbG9hZF9ub2RlKG9iaiBbLCBjYWxsYmFja10pXG5cdFx0ICogQHBhcmFtICB7bWl4ZWR9IG9ialxuXHRcdCAqIEBwYXJhbSAge2Z1bmN0aW9ufSBjYWxsYmFjayBhIGZ1bmN0aW9uIHRvIGJlIGV4ZWN1dGVkIG9uY2UgbG9hZGluZyBpcyBjb21wbGV0ZSwgdGhlIGZ1bmN0aW9uIGlzIGV4ZWN1dGVkIGluIHRoZSBpbnN0YW5jZSdzIHNjb3BlIGFuZCByZWNlaXZlcyBvbmUgYXJndW1lbnQgLSBhIGJvb2xlYW4gc3RhdHVzXG5cdFx0ICogQHJldHVybiB7Qm9vbGVhbn1cblx0XHQgKi9cblx0XHRfbG9hZF9ub2RlIDogZnVuY3Rpb24gKG9iaiwgY2FsbGJhY2spIHtcblx0XHRcdHZhciBzID0gdGhpcy5zZXR0aW5ncy5jb3JlLmRhdGEsIHQ7XG5cdFx0XHQvLyB1c2Ugb3JpZ2luYWwgSFRNTFxuXHRcdFx0aWYoIXMpIHtcblx0XHRcdFx0aWYob2JqLmlkID09PSAnIycpIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5fYXBwZW5kX2h0bWxfZGF0YShvYmosIHRoaXMuX2RhdGEuY29yZS5vcmlnaW5hbF9jb250YWluZXJfaHRtbC5jbG9uZSh0cnVlKSwgZnVuY3Rpb24gKHN0YXR1cykge1xuXHRcdFx0XHRcdFx0Y2FsbGJhY2suY2FsbCh0aGlzLCBzdGF0dXMpO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdHJldHVybiBjYWxsYmFjay5jYWxsKHRoaXMsIGZhbHNlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyByZXR1cm4gY2FsbGJhY2suY2FsbCh0aGlzLCBvYmouaWQgPT09ICcjJyA/IHRoaXMuX2FwcGVuZF9odG1sX2RhdGEob2JqLCB0aGlzLl9kYXRhLmNvcmUub3JpZ2luYWxfY29udGFpbmVyX2h0bWwuY2xvbmUodHJ1ZSkpIDogZmFsc2UpO1xuXHRcdFx0fVxuXHRcdFx0aWYoJC5pc0Z1bmN0aW9uKHMpKSB7XG5cdFx0XHRcdHJldHVybiBzLmNhbGwodGhpcywgb2JqLCAkLnByb3h5KGZ1bmN0aW9uIChkKSB7XG5cdFx0XHRcdFx0aWYoZCA9PT0gZmFsc2UpIHtcblx0XHRcdFx0XHRcdGNhbGxiYWNrLmNhbGwodGhpcywgZmFsc2UpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0aGlzW3R5cGVvZiBkID09PSAnc3RyaW5nJyA/ICdfYXBwZW5kX2h0bWxfZGF0YScgOiAnX2FwcGVuZF9qc29uX2RhdGEnXShvYmosIHR5cGVvZiBkID09PSAnc3RyaW5nJyA/ICQoZCkgOiBkLCBmdW5jdGlvbiAoc3RhdHVzKSB7XG5cdFx0XHRcdFx0XHRjYWxsYmFjay5jYWxsKHRoaXMsIHN0YXR1cyk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0Ly8gcmV0dXJuIGQgPT09IGZhbHNlID8gY2FsbGJhY2suY2FsbCh0aGlzLCBmYWxzZSkgOiBjYWxsYmFjay5jYWxsKHRoaXMsIHRoaXNbdHlwZW9mIGQgPT09ICdzdHJpbmcnID8gJ19hcHBlbmRfaHRtbF9kYXRhJyA6ICdfYXBwZW5kX2pzb25fZGF0YSddKG9iaiwgdHlwZW9mIGQgPT09ICdzdHJpbmcnID8gJChkKSA6IGQpKTtcblx0XHRcdFx0fSwgdGhpcykpO1xuXHRcdFx0fVxuXHRcdFx0aWYodHlwZW9mIHMgPT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdGlmKHMudXJsKSB7XG5cdFx0XHRcdFx0cyA9ICQuZXh0ZW5kKHRydWUsIHt9LCBzKTtcblx0XHRcdFx0XHRpZigkLmlzRnVuY3Rpb24ocy51cmwpKSB7XG5cdFx0XHRcdFx0XHRzLnVybCA9IHMudXJsLmNhbGwodGhpcywgb2JqKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYoJC5pc0Z1bmN0aW9uKHMuZGF0YSkpIHtcblx0XHRcdFx0XHRcdHMuZGF0YSA9IHMuZGF0YS5jYWxsKHRoaXMsIG9iaik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiAkLmFqYXgocylcblx0XHRcdFx0XHRcdC5kb25lKCQucHJveHkoZnVuY3Rpb24gKGQsdCx4KSB7XG5cdFx0XHRcdFx0XHRcdFx0dmFyIHR5cGUgPSB4LmdldFJlc3BvbnNlSGVhZGVyKCdDb250ZW50LVR5cGUnKTtcblx0XHRcdFx0XHRcdFx0XHRpZih0eXBlLmluZGV4T2YoJ2pzb24nKSAhPT0gLTEgfHwgdHlwZW9mIGQgPT09IFwib2JqZWN0XCIpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiB0aGlzLl9hcHBlbmRfanNvbl9kYXRhKG9iaiwgZCwgZnVuY3Rpb24gKHN0YXR1cykgeyBjYWxsYmFjay5jYWxsKHRoaXMsIHN0YXR1cyk7IH0pO1xuXHRcdFx0XHRcdFx0XHRcdFx0Ly9yZXR1cm4gY2FsbGJhY2suY2FsbCh0aGlzLCB0aGlzLl9hcHBlbmRfanNvbl9kYXRhKG9iaiwgZCkpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRpZih0eXBlLmluZGV4T2YoJ2h0bWwnKSAhPT0gLTEgfHwgdHlwZW9mIGQgPT09IFwic3RyaW5nXCIpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiB0aGlzLl9hcHBlbmRfaHRtbF9kYXRhKG9iaiwgJChkKSwgZnVuY3Rpb24gKHN0YXR1cykgeyBjYWxsYmFjay5jYWxsKHRoaXMsIHN0YXR1cyk7IH0pO1xuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gcmV0dXJuIGNhbGxiYWNrLmNhbGwodGhpcywgdGhpcy5fYXBwZW5kX2h0bWxfZGF0YShvYmosICQoZCkpKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5fZGF0YS5jb3JlLmxhc3RfZXJyb3IgPSB7ICdlcnJvcicgOiAnYWpheCcsICdwbHVnaW4nIDogJ2NvcmUnLCAnaWQnIDogJ2NvcmVfMDQnLCAncmVhc29uJyA6ICdDb3VsZCBub3QgbG9hZCBub2RlJywgJ2RhdGEnIDogSlNPTi5zdHJpbmdpZnkoeyAnaWQnIDogb2JqLmlkLCAneGhyJyA6IHggfSkgfTtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLnNldHRpbmdzLmNvcmUuZXJyb3IuY2FsbCh0aGlzLCB0aGlzLl9kYXRhLmNvcmUubGFzdF9lcnJvcik7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIGNhbGxiYWNrLmNhbGwodGhpcywgZmFsc2UpO1xuXHRcdFx0XHRcdFx0XHR9LCB0aGlzKSlcblx0XHRcdFx0XHRcdC5mYWlsKCQucHJveHkoZnVuY3Rpb24gKGYpIHtcblx0XHRcdFx0XHRcdFx0XHRjYWxsYmFjay5jYWxsKHRoaXMsIGZhbHNlKTtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLl9kYXRhLmNvcmUubGFzdF9lcnJvciA9IHsgJ2Vycm9yJyA6ICdhamF4JywgJ3BsdWdpbicgOiAnY29yZScsICdpZCcgOiAnY29yZV8wNCcsICdyZWFzb24nIDogJ0NvdWxkIG5vdCBsb2FkIG5vZGUnLCAnZGF0YScgOiBKU09OLnN0cmluZ2lmeSh7ICdpZCcgOiBvYmouaWQsICd4aHInIDogZiB9KSB9O1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuc2V0dGluZ3MuY29yZS5lcnJvci5jYWxsKHRoaXMsIHRoaXMuX2RhdGEuY29yZS5sYXN0X2Vycm9yKTtcblx0XHRcdFx0XHRcdFx0fSwgdGhpcykpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHQgPSAoJC5pc0FycmF5KHMpIHx8ICQuaXNQbGFpbk9iamVjdChzKSkgPyBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHMpKSA6IHM7XG5cdFx0XHRcdGlmKG9iai5pZCA9PT0gJyMnKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuX2FwcGVuZF9qc29uX2RhdGEob2JqLCB0LCBmdW5jdGlvbiAoc3RhdHVzKSB7XG5cdFx0XHRcdFx0XHRjYWxsYmFjay5jYWxsKHRoaXMsIHN0YXR1cyk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy5fZGF0YS5jb3JlLmxhc3RfZXJyb3IgPSB7ICdlcnJvcicgOiAnbm9kYXRhJywgJ3BsdWdpbicgOiAnY29yZScsICdpZCcgOiAnY29yZV8wNScsICdyZWFzb24nIDogJ0NvdWxkIG5vdCBsb2FkIG5vZGUnLCAnZGF0YScgOiBKU09OLnN0cmluZ2lmeSh7ICdpZCcgOiBvYmouaWQgfSkgfTtcblx0XHRcdFx0XHR0aGlzLnNldHRpbmdzLmNvcmUuZXJyb3IuY2FsbCh0aGlzLCB0aGlzLl9kYXRhLmNvcmUubGFzdF9lcnJvcik7XG5cdFx0XHRcdFx0cmV0dXJuIGNhbGxiYWNrLmNhbGwodGhpcywgZmFsc2UpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vcmV0dXJuIGNhbGxiYWNrLmNhbGwodGhpcywgKG9iai5pZCA9PT0gXCIjXCIgPyB0aGlzLl9hcHBlbmRfanNvbl9kYXRhKG9iaiwgdCkgOiBmYWxzZSkgKTtcblx0XHRcdH1cblx0XHRcdGlmKHR5cGVvZiBzID09PSAnc3RyaW5nJykge1xuXHRcdFx0XHRpZihvYmouaWQgPT09ICcjJykge1xuXHRcdFx0XHRcdHJldHVybiB0aGlzLl9hcHBlbmRfaHRtbF9kYXRhKG9iaiwgJChzKSwgZnVuY3Rpb24gKHN0YXR1cykge1xuXHRcdFx0XHRcdFx0Y2FsbGJhY2suY2FsbCh0aGlzLCBzdGF0dXMpO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMuX2RhdGEuY29yZS5sYXN0X2Vycm9yID0geyAnZXJyb3InIDogJ25vZGF0YScsICdwbHVnaW4nIDogJ2NvcmUnLCAnaWQnIDogJ2NvcmVfMDYnLCAncmVhc29uJyA6ICdDb3VsZCBub3QgbG9hZCBub2RlJywgJ2RhdGEnIDogSlNPTi5zdHJpbmdpZnkoeyAnaWQnIDogb2JqLmlkIH0pIH07XG5cdFx0XHRcdFx0dGhpcy5zZXR0aW5ncy5jb3JlLmVycm9yLmNhbGwodGhpcywgdGhpcy5fZGF0YS5jb3JlLmxhc3RfZXJyb3IpO1xuXHRcdFx0XHRcdHJldHVybiBjYWxsYmFjay5jYWxsKHRoaXMsIGZhbHNlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvL3JldHVybiBjYWxsYmFjay5jYWxsKHRoaXMsIChvYmouaWQgPT09IFwiI1wiID8gdGhpcy5fYXBwZW5kX2h0bWxfZGF0YShvYmosICQocykpIDogZmFsc2UpICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gY2FsbGJhY2suY2FsbCh0aGlzLCBmYWxzZSk7XG5cdFx0fSxcblx0XHQvKipcblx0XHQgKiBhZGRzIGEgbm9kZSB0byB0aGUgbGlzdCBvZiBub2RlcyB0byByZWRyYXcuIFVzZWQgb25seSBpbnRlcm5hbGx5LlxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICogQG5hbWUgX25vZGVfY2hhbmdlZChvYmogWywgY2FsbGJhY2tdKVxuXHRcdCAqIEBwYXJhbSAge21peGVkfSBvYmpcblx0XHQgKi9cblx0XHRfbm9kZV9jaGFuZ2VkIDogZnVuY3Rpb24gKG9iaikge1xuXHRcdFx0b2JqID0gdGhpcy5nZXRfbm9kZShvYmopO1xuXHRcdFx0aWYob2JqKSB7XG5cdFx0XHRcdHRoaXMuX21vZGVsLmNoYW5nZWQucHVzaChvYmouaWQpO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogYXBwZW5kcyBIVE1MIGNvbnRlbnQgdG8gdGhlIHRyZWUuIFVzZWQgaW50ZXJuYWxseS5cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqIEBuYW1lIF9hcHBlbmRfaHRtbF9kYXRhKG9iaiwgZGF0YSlcblx0XHQgKiBAcGFyYW0gIHttaXhlZH0gb2JqIHRoZSBub2RlIHRvIGFwcGVuZCB0b1xuXHRcdCAqIEBwYXJhbSAge1N0cmluZ30gZGF0YSB0aGUgSFRNTCBzdHJpbmcgdG8gcGFyc2UgYW5kIGFwcGVuZFxuXHRcdCAqIEB0cmlnZ2VyIG1vZGVsLmpzdHJlZSwgY2hhbmdlZC5qc3RyZWVcblx0XHQgKi9cblx0XHRfYXBwZW5kX2h0bWxfZGF0YSA6IGZ1bmN0aW9uIChkb20sIGRhdGEsIGNiKSB7XG5cdFx0XHRkb20gPSB0aGlzLmdldF9ub2RlKGRvbSk7XG5cdFx0XHRkb20uY2hpbGRyZW4gPSBbXTtcblx0XHRcdGRvbS5jaGlsZHJlbl9kID0gW107XG5cdFx0XHR2YXIgZGF0ID0gZGF0YS5pcygndWwnKSA/IGRhdGEuY2hpbGRyZW4oKSA6IGRhdGEsXG5cdFx0XHRcdHBhciA9IGRvbS5pZCxcblx0XHRcdFx0Y2hkID0gW10sXG5cdFx0XHRcdGRwYyA9IFtdLFxuXHRcdFx0XHRtID0gdGhpcy5fbW9kZWwuZGF0YSxcblx0XHRcdFx0cCA9IG1bcGFyXSxcblx0XHRcdFx0cyA9IHRoaXMuX2RhdGEuY29yZS5zZWxlY3RlZC5sZW5ndGgsXG5cdFx0XHRcdHRtcCwgaSwgajtcblx0XHRcdGRhdC5lYWNoKCQucHJveHkoZnVuY3Rpb24gKGksIHYpIHtcblx0XHRcdFx0dG1wID0gdGhpcy5fcGFyc2VfbW9kZWxfZnJvbV9odG1sKCQodiksIHBhciwgcC5wYXJlbnRzLmNvbmNhdCgpKTtcblx0XHRcdFx0aWYodG1wKSB7XG5cdFx0XHRcdFx0Y2hkLnB1c2godG1wKTtcblx0XHRcdFx0XHRkcGMucHVzaCh0bXApO1xuXHRcdFx0XHRcdGlmKG1bdG1wXS5jaGlsZHJlbl9kLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0ZHBjID0gZHBjLmNvbmNhdChtW3RtcF0uY2hpbGRyZW5fZCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9LCB0aGlzKSk7XG5cdFx0XHRwLmNoaWxkcmVuID0gY2hkO1xuXHRcdFx0cC5jaGlsZHJlbl9kID0gZHBjO1xuXHRcdFx0Zm9yKGkgPSAwLCBqID0gcC5wYXJlbnRzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuXHRcdFx0XHRtW3AucGFyZW50c1tpXV0uY2hpbGRyZW5fZCA9IG1bcC5wYXJlbnRzW2ldXS5jaGlsZHJlbl9kLmNvbmNhdChkcGMpO1xuXHRcdFx0fVxuXHRcdFx0LyoqXG5cdFx0XHQgKiB0cmlnZ2VyZWQgd2hlbiBuZXcgZGF0YSBpcyBpbnNlcnRlZCB0byB0aGUgdHJlZSBtb2RlbFxuXHRcdFx0ICogQGV2ZW50XG5cdFx0XHQgKiBAbmFtZSBtb2RlbC5qc3RyZWVcblx0XHRcdCAqIEBwYXJhbSB7QXJyYXl9IG5vZGVzIGFuIGFycmF5IG9mIG5vZGUgSURzXG5cdFx0XHQgKiBAcGFyYW0ge1N0cmluZ30gcGFyZW50IHRoZSBwYXJlbnQgSUQgb2YgdGhlIG5vZGVzXG5cdFx0XHQgKi9cblx0XHRcdHRoaXMudHJpZ2dlcignbW9kZWwnLCB7IFwibm9kZXNcIiA6IGRwYywgJ3BhcmVudCcgOiBwYXIgfSk7XG5cdFx0XHRpZihwYXIgIT09ICcjJykge1xuXHRcdFx0XHR0aGlzLl9ub2RlX2NoYW5nZWQocGFyKTtcblx0XHRcdFx0dGhpcy5yZWRyYXcoKTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHR0aGlzLmdldF9jb250YWluZXJfdWwoKS5jaGlsZHJlbignLmpzdHJlZS1pbml0aWFsLW5vZGUnKS5yZW1vdmUoKTtcblx0XHRcdFx0dGhpcy5yZWRyYXcodHJ1ZSk7XG5cdFx0XHR9XG5cdFx0XHRpZih0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQubGVuZ3RoICE9PSBzKSB7XG5cdFx0XHRcdHRoaXMudHJpZ2dlcignY2hhbmdlZCcsIHsgJ2FjdGlvbicgOiAnbW9kZWwnLCAnc2VsZWN0ZWQnIDogdGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkIH0pO1xuXHRcdFx0fVxuXHRcdFx0Y2IuY2FsbCh0aGlzLCB0cnVlKTtcblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIGFwcGVuZHMgSlNPTiBjb250ZW50IHRvIHRoZSB0cmVlLiBVc2VkIGludGVybmFsbHkuXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKiBAbmFtZSBfYXBwZW5kX2pzb25fZGF0YShvYmosIGRhdGEpXG5cdFx0ICogQHBhcmFtICB7bWl4ZWR9IG9iaiB0aGUgbm9kZSB0byBhcHBlbmQgdG9cblx0XHQgKiBAcGFyYW0gIHtTdHJpbmd9IGRhdGEgdGhlIEpTT04gb2JqZWN0IHRvIHBhcnNlIGFuZCBhcHBlbmRcblx0XHQgKiBAdHJpZ2dlciBtb2RlbC5qc3RyZWUsIGNoYW5nZWQuanN0cmVlXG5cdFx0ICovXG5cdFx0X2FwcGVuZF9qc29uX2RhdGEgOiBmdW5jdGlvbiAoZG9tLCBkYXRhLCBjYikge1xuXHRcdFx0ZG9tID0gdGhpcy5nZXRfbm9kZShkb20pO1xuXHRcdFx0ZG9tLmNoaWxkcmVuID0gW107XG5cdFx0XHRkb20uY2hpbGRyZW5fZCA9IFtdO1xuXHRcdFx0Ly8gKiUkQCEhIVxuXHRcdFx0aWYoZGF0YS5kKSB7XG5cdFx0XHRcdGRhdGEgPSBkYXRhLmQ7XG5cdFx0XHRcdGlmKHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiKSB7XG5cdFx0XHRcdFx0ZGF0YSA9IEpTT04ucGFyc2UoZGF0YSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmKCEkLmlzQXJyYXkoZGF0YSkpIHsgZGF0YSA9IFtkYXRhXTsgfVxuXHRcdFx0dmFyIHcgPSBudWxsLFxuXHRcdFx0XHRhcmdzID0ge1xuXHRcdFx0XHRcdCdkZidcdDogdGhpcy5fbW9kZWwuZGVmYXVsdF9zdGF0ZSxcblx0XHRcdFx0XHQnZGF0J1x0OiBkYXRhLFxuXHRcdFx0XHRcdCdwYXInXHQ6IGRvbS5pZCxcblx0XHRcdFx0XHQnbSdcdFx0OiB0aGlzLl9tb2RlbC5kYXRhLFxuXHRcdFx0XHRcdCd0X2lkJ1x0OiB0aGlzLl9pZCxcblx0XHRcdFx0XHQndF9jbnQnXHQ6IHRoaXMuX2NudCxcblx0XHRcdFx0XHQnc2VsJ1x0OiB0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWRcblx0XHRcdFx0fSxcblx0XHRcdFx0ZnVuYyA9IGZ1bmN0aW9uIChkYXRhLCB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRpZihkYXRhLmRhdGEpIHsgZGF0YSA9IGRhdGEuZGF0YTsgfVxuXHRcdFx0XHRcdHZhciBkYXQgPSBkYXRhLmRhdCxcblx0XHRcdFx0XHRcdHBhciA9IGRhdGEucGFyLFxuXHRcdFx0XHRcdFx0Y2hkID0gW10sXG5cdFx0XHRcdFx0XHRkcGMgPSBbXSxcblx0XHRcdFx0XHRcdGFkZCA9IFtdLFxuXHRcdFx0XHRcdFx0ZGYgPSBkYXRhLmRmLFxuXHRcdFx0XHRcdFx0dF9pZCA9IGRhdGEudF9pZCxcblx0XHRcdFx0XHRcdHRfY250ID0gZGF0YS50X2NudCxcblx0XHRcdFx0XHRcdG0gPSBkYXRhLm0sXG5cdFx0XHRcdFx0XHRwID0gbVtwYXJdLFxuXHRcdFx0XHRcdFx0c2VsID0gZGF0YS5zZWwsXG5cdFx0XHRcdFx0XHR0bXAsIGksIGosIHJzbHQsXG5cdFx0XHRcdFx0XHRwYXJzZV9mbGF0ID0gZnVuY3Rpb24gKGQsIHAsIHBzKSB7XG5cdFx0XHRcdFx0XHRcdGlmKCFwcykgeyBwcyA9IFtdOyB9XG5cdFx0XHRcdFx0XHRcdGVsc2UgeyBwcyA9IHBzLmNvbmNhdCgpOyB9XG5cdFx0XHRcdFx0XHRcdGlmKHApIHsgcHMudW5zaGlmdChwKTsgfVxuXHRcdFx0XHRcdFx0XHR2YXIgdGlkID0gZC5pZC50b1N0cmluZygpLFxuXHRcdFx0XHRcdFx0XHRcdGksIGosIGMsIGUsXG5cdFx0XHRcdFx0XHRcdFx0dG1wID0ge1xuXHRcdFx0XHRcdFx0XHRcdFx0aWRcdFx0XHQ6IHRpZCxcblx0XHRcdFx0XHRcdFx0XHRcdHRleHRcdFx0OiBkLnRleHQgfHwgJycsXG5cdFx0XHRcdFx0XHRcdFx0XHRpY29uXHRcdDogZC5pY29uICE9PSB1bmRlZmluZWQgPyBkLmljb24gOiB0cnVlLFxuXHRcdFx0XHRcdFx0XHRcdFx0cGFyZW50XHRcdDogcCxcblx0XHRcdFx0XHRcdFx0XHRcdHBhcmVudHNcdFx0OiBwcyxcblx0XHRcdFx0XHRcdFx0XHRcdGNoaWxkcmVuXHQ6IGQuY2hpbGRyZW4gfHwgW10sXG5cdFx0XHRcdFx0XHRcdFx0XHRjaGlsZHJlbl9kXHQ6IGQuY2hpbGRyZW5fZCB8fCBbXSxcblx0XHRcdFx0XHRcdFx0XHRcdGRhdGFcdFx0OiBkLmRhdGEsXG5cdFx0XHRcdFx0XHRcdFx0XHRzdGF0ZVx0XHQ6IHsgfSxcblx0XHRcdFx0XHRcdFx0XHRcdGxpX2F0dHJcdFx0OiB7IGlkIDogZmFsc2UgfSxcblx0XHRcdFx0XHRcdFx0XHRcdGFfYXR0clx0XHQ6IHsgaHJlZiA6ICcjJyB9LFxuXHRcdFx0XHRcdFx0XHRcdFx0b3JpZ2luYWxcdDogZmFsc2Vcblx0XHRcdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0XHRmb3IoaSBpbiBkZikge1xuXHRcdFx0XHRcdFx0XHRcdGlmKGRmLmhhc093blByb3BlcnR5KGkpKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR0bXAuc3RhdGVbaV0gPSBkZltpXTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0aWYoZCAmJiBkLmRhdGEgJiYgZC5kYXRhLmpzdHJlZSAmJiBkLmRhdGEuanN0cmVlLmljb24pIHtcblx0XHRcdFx0XHRcdFx0XHR0bXAuaWNvbiA9IGQuZGF0YS5qc3RyZWUuaWNvbjtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRpZihkICYmIGQuZGF0YSkge1xuXHRcdFx0XHRcdFx0XHRcdHRtcC5kYXRhID0gZC5kYXRhO1xuXHRcdFx0XHRcdFx0XHRcdGlmKGQuZGF0YS5qc3RyZWUpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGZvcihpIGluIGQuZGF0YS5qc3RyZWUpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYoZC5kYXRhLmpzdHJlZS5oYXNPd25Qcm9wZXJ0eShpKSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRtcC5zdGF0ZVtpXSA9IGQuZGF0YS5qc3RyZWVbaV07XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0aWYoZCAmJiB0eXBlb2YgZC5zdGF0ZSA9PT0gJ29iamVjdCcpIHtcblx0XHRcdFx0XHRcdFx0XHRmb3IgKGkgaW4gZC5zdGF0ZSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYoZC5zdGF0ZS5oYXNPd25Qcm9wZXJ0eShpKSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0bXAuc3RhdGVbaV0gPSBkLnN0YXRlW2ldO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRpZihkICYmIHR5cGVvZiBkLmxpX2F0dHIgPT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdFx0XHRcdFx0Zm9yIChpIGluIGQubGlfYXR0cikge1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYoZC5saV9hdHRyLmhhc093blByb3BlcnR5KGkpKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRtcC5saV9hdHRyW2ldID0gZC5saV9hdHRyW2ldO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRpZighdG1wLmxpX2F0dHIuaWQpIHtcblx0XHRcdFx0XHRcdFx0XHR0bXAubGlfYXR0ci5pZCA9IHRpZDtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRpZihkICYmIHR5cGVvZiBkLmFfYXR0ciA9PT0gJ29iamVjdCcpIHtcblx0XHRcdFx0XHRcdFx0XHRmb3IgKGkgaW4gZC5hX2F0dHIpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGlmKGQuYV9hdHRyLmhhc093blByb3BlcnR5KGkpKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRtcC5hX2F0dHJbaV0gPSBkLmFfYXR0cltpXTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0aWYoZCAmJiBkLmNoaWxkcmVuICYmIGQuY2hpbGRyZW4gPT09IHRydWUpIHtcblx0XHRcdFx0XHRcdFx0XHR0bXAuc3RhdGUubG9hZGVkID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRcdFx0dG1wLmNoaWxkcmVuID0gW107XG5cdFx0XHRcdFx0XHRcdFx0dG1wLmNoaWxkcmVuX2QgPSBbXTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRtW3RtcC5pZF0gPSB0bXA7XG5cdFx0XHRcdFx0XHRcdGZvcihpID0gMCwgaiA9IHRtcC5jaGlsZHJlbi5sZW5ndGg7IGkgPCBqOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0XHRjID0gcGFyc2VfZmxhdChtW3RtcC5jaGlsZHJlbltpXV0sIHRtcC5pZCwgcHMpO1xuXHRcdFx0XHRcdFx0XHRcdGUgPSBtW2NdO1xuXHRcdFx0XHRcdFx0XHRcdHRtcC5jaGlsZHJlbl9kLnB1c2goYyk7XG5cdFx0XHRcdFx0XHRcdFx0aWYoZS5jaGlsZHJlbl9kLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0dG1wLmNoaWxkcmVuX2QgPSB0bXAuY2hpbGRyZW5fZC5jb25jYXQoZS5jaGlsZHJlbl9kKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0ZGVsZXRlIGQuZGF0YTtcblx0XHRcdFx0XHRcdFx0ZGVsZXRlIGQuY2hpbGRyZW47XG5cdFx0XHRcdFx0XHRcdG1bdG1wLmlkXS5vcmlnaW5hbCA9IGQ7XG5cdFx0XHRcdFx0XHRcdGlmKHRtcC5zdGF0ZS5zZWxlY3RlZCkge1xuXHRcdFx0XHRcdFx0XHRcdGFkZC5wdXNoKHRtcC5pZCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRtcC5pZDtcblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRwYXJzZV9uZXN0ID0gZnVuY3Rpb24gKGQsIHAsIHBzKSB7XG5cdFx0XHRcdFx0XHRcdGlmKCFwcykgeyBwcyA9IFtdOyB9XG5cdFx0XHRcdFx0XHRcdGVsc2UgeyBwcyA9IHBzLmNvbmNhdCgpOyB9XG5cdFx0XHRcdFx0XHRcdGlmKHApIHsgcHMudW5zaGlmdChwKTsgfVxuXHRcdFx0XHRcdFx0XHR2YXIgdGlkID0gZmFsc2UsIGksIGosIGMsIGUsIHRtcDtcblx0XHRcdFx0XHRcdFx0ZG8ge1xuXHRcdFx0XHRcdFx0XHRcdHRpZCA9ICdqJyArIHRfaWQgKyAnXycgKyAoKyt0X2NudCk7XG5cdFx0XHRcdFx0XHRcdH0gd2hpbGUobVt0aWRdKTtcblxuXHRcdFx0XHRcdFx0XHR0bXAgPSB7XG5cdFx0XHRcdFx0XHRcdFx0aWRcdFx0XHQ6IGZhbHNlLFxuXHRcdFx0XHRcdFx0XHRcdHRleHRcdFx0OiB0eXBlb2YgZCA9PT0gJ3N0cmluZycgPyBkIDogJycsXG5cdFx0XHRcdFx0XHRcdFx0aWNvblx0XHQ6IHR5cGVvZiBkID09PSAnb2JqZWN0JyAmJiBkLmljb24gIT09IHVuZGVmaW5lZCA/IGQuaWNvbiA6IHRydWUsXG5cdFx0XHRcdFx0XHRcdFx0cGFyZW50XHRcdDogcCxcblx0XHRcdFx0XHRcdFx0XHRwYXJlbnRzXHRcdDogcHMsXG5cdFx0XHRcdFx0XHRcdFx0Y2hpbGRyZW5cdDogW10sXG5cdFx0XHRcdFx0XHRcdFx0Y2hpbGRyZW5fZFx0OiBbXSxcblx0XHRcdFx0XHRcdFx0XHRkYXRhXHRcdDogbnVsbCxcblx0XHRcdFx0XHRcdFx0XHRzdGF0ZVx0XHQ6IHsgfSxcblx0XHRcdFx0XHRcdFx0XHRsaV9hdHRyXHRcdDogeyBpZCA6IGZhbHNlIH0sXG5cdFx0XHRcdFx0XHRcdFx0YV9hdHRyXHRcdDogeyBocmVmIDogJyMnIH0sXG5cdFx0XHRcdFx0XHRcdFx0b3JpZ2luYWxcdDogZmFsc2Vcblx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdFx0Zm9yKGkgaW4gZGYpIHtcblx0XHRcdFx0XHRcdFx0XHRpZihkZi5oYXNPd25Qcm9wZXJ0eShpKSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0dG1wLnN0YXRlW2ldID0gZGZbaV07XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGlmKGQgJiYgZC5pZCkgeyB0bXAuaWQgPSBkLmlkLnRvU3RyaW5nKCk7IH1cblx0XHRcdFx0XHRcdFx0aWYoZCAmJiBkLnRleHQpIHsgdG1wLnRleHQgPSBkLnRleHQ7IH1cblx0XHRcdFx0XHRcdFx0aWYoZCAmJiBkLmRhdGEgJiYgZC5kYXRhLmpzdHJlZSAmJiBkLmRhdGEuanN0cmVlLmljb24pIHtcblx0XHRcdFx0XHRcdFx0XHR0bXAuaWNvbiA9IGQuZGF0YS5qc3RyZWUuaWNvbjtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRpZihkICYmIGQuZGF0YSkge1xuXHRcdFx0XHRcdFx0XHRcdHRtcC5kYXRhID0gZC5kYXRhO1xuXHRcdFx0XHRcdFx0XHRcdGlmKGQuZGF0YS5qc3RyZWUpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGZvcihpIGluIGQuZGF0YS5qc3RyZWUpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYoZC5kYXRhLmpzdHJlZS5oYXNPd25Qcm9wZXJ0eShpKSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRtcC5zdGF0ZVtpXSA9IGQuZGF0YS5qc3RyZWVbaV07XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0aWYoZCAmJiB0eXBlb2YgZC5zdGF0ZSA9PT0gJ29iamVjdCcpIHtcblx0XHRcdFx0XHRcdFx0XHRmb3IgKGkgaW4gZC5zdGF0ZSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYoZC5zdGF0ZS5oYXNPd25Qcm9wZXJ0eShpKSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0bXAuc3RhdGVbaV0gPSBkLnN0YXRlW2ldO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRpZihkICYmIHR5cGVvZiBkLmxpX2F0dHIgPT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdFx0XHRcdFx0Zm9yIChpIGluIGQubGlfYXR0cikge1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYoZC5saV9hdHRyLmhhc093blByb3BlcnR5KGkpKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRtcC5saV9hdHRyW2ldID0gZC5saV9hdHRyW2ldO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRpZih0bXAubGlfYXR0ci5pZCAmJiAhdG1wLmlkKSB7XG5cdFx0XHRcdFx0XHRcdFx0dG1wLmlkID0gdG1wLmxpX2F0dHIuaWQudG9TdHJpbmcoKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRpZighdG1wLmlkKSB7XG5cdFx0XHRcdFx0XHRcdFx0dG1wLmlkID0gdGlkO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGlmKCF0bXAubGlfYXR0ci5pZCkge1xuXHRcdFx0XHRcdFx0XHRcdHRtcC5saV9hdHRyLmlkID0gdG1wLmlkO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGlmKGQgJiYgdHlwZW9mIGQuYV9hdHRyID09PSAnb2JqZWN0Jykge1xuXHRcdFx0XHRcdFx0XHRcdGZvciAoaSBpbiBkLmFfYXR0cikge1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYoZC5hX2F0dHIuaGFzT3duUHJvcGVydHkoaSkpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dG1wLmFfYXR0cltpXSA9IGQuYV9hdHRyW2ldO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRpZihkICYmIGQuY2hpbGRyZW4gJiYgZC5jaGlsZHJlbi5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdFx0XHRmb3IoaSA9IDAsIGogPSBkLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuXHRcdFx0XHRcdFx0XHRcdFx0YyA9IHBhcnNlX25lc3QoZC5jaGlsZHJlbltpXSwgdG1wLmlkLCBwcyk7XG5cdFx0XHRcdFx0XHRcdFx0XHRlID0gbVtjXTtcblx0XHRcdFx0XHRcdFx0XHRcdHRtcC5jaGlsZHJlbi5wdXNoKGMpO1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYoZS5jaGlsZHJlbl9kLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0bXAuY2hpbGRyZW5fZCA9IHRtcC5jaGlsZHJlbl9kLmNvbmNhdChlLmNoaWxkcmVuX2QpO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR0bXAuY2hpbGRyZW5fZCA9IHRtcC5jaGlsZHJlbl9kLmNvbmNhdCh0bXAuY2hpbGRyZW4pO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGlmKGQgJiYgZC5jaGlsZHJlbiAmJiBkLmNoaWxkcmVuID09PSB0cnVlKSB7XG5cdFx0XHRcdFx0XHRcdFx0dG1wLnN0YXRlLmxvYWRlZCA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0XHRcdHRtcC5jaGlsZHJlbiA9IFtdO1xuXHRcdFx0XHRcdFx0XHRcdHRtcC5jaGlsZHJlbl9kID0gW107XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0ZGVsZXRlIGQuZGF0YTtcblx0XHRcdFx0XHRcdFx0ZGVsZXRlIGQuY2hpbGRyZW47XG5cdFx0XHRcdFx0XHRcdHRtcC5vcmlnaW5hbCA9IGQ7XG5cdFx0XHRcdFx0XHRcdG1bdG1wLmlkXSA9IHRtcDtcblx0XHRcdFx0XHRcdFx0aWYodG1wLnN0YXRlLnNlbGVjdGVkKSB7XG5cdFx0XHRcdFx0XHRcdFx0YWRkLnB1c2godG1wLmlkKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdG1wLmlkO1xuXHRcdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdGlmKGRhdC5sZW5ndGggJiYgZGF0WzBdLmlkICE9PSB1bmRlZmluZWQgJiYgZGF0WzBdLnBhcmVudCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHQvLyBGbGF0IEpTT04gc3VwcG9ydCAoZm9yIGVhc3kgaW1wb3J0IGZyb20gREIpOlxuXHRcdFx0XHRcdFx0Ly8gMSkgY29udmVydCB0byBvYmplY3QgKGZvcmVhY2gpXG5cdFx0XHRcdFx0XHRmb3IoaSA9IDAsIGogPSBkYXQubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdGlmKCFkYXRbaV0uY2hpbGRyZW4pIHtcblx0XHRcdFx0XHRcdFx0XHRkYXRbaV0uY2hpbGRyZW4gPSBbXTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRtW2RhdFtpXS5pZC50b1N0cmluZygpXSA9IGRhdFtpXTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdC8vIDIpIHBvcHVsYXRlIGNoaWxkcmVuIChmb3JlYWNoKVxuXHRcdFx0XHRcdFx0Zm9yKGkgPSAwLCBqID0gZGF0Lmxlbmd0aDsgaSA8IGo7IGkrKykge1xuXHRcdFx0XHRcdFx0XHRtW2RhdFtpXS5wYXJlbnQudG9TdHJpbmcoKV0uY2hpbGRyZW4ucHVzaChkYXRbaV0uaWQudG9TdHJpbmcoKSk7XG5cdFx0XHRcdFx0XHRcdC8vIHBvcHVsYXRlIHBhcmVudC5jaGlsZHJlbl9kXG5cdFx0XHRcdFx0XHRcdHAuY2hpbGRyZW5fZC5wdXNoKGRhdFtpXS5pZC50b1N0cmluZygpKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdC8vIDMpIG5vcm1hbGl6ZSAmJiBwb3B1bGF0ZSBwYXJlbnRzIGFuZCBjaGlsZHJlbl9kIHdpdGggcmVjdXJzaW9uXG5cdFx0XHRcdFx0XHRmb3IoaSA9IDAsIGogPSBwLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuXHRcdFx0XHRcdFx0XHR0bXAgPSBwYXJzZV9mbGF0KG1bcC5jaGlsZHJlbltpXV0sIHBhciwgcC5wYXJlbnRzLmNvbmNhdCgpKTtcblx0XHRcdFx0XHRcdFx0ZHBjLnB1c2godG1wKTtcblx0XHRcdFx0XHRcdFx0aWYobVt0bXBdLmNoaWxkcmVuX2QubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRcdFx0ZHBjID0gZHBjLmNvbmNhdChtW3RtcF0uY2hpbGRyZW5fZCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGZvcihpID0gMCwgaiA9IHAucGFyZW50cy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0bVtwLnBhcmVudHNbaV1dLmNoaWxkcmVuX2QgPSBtW3AucGFyZW50c1tpXV0uY2hpbGRyZW5fZC5jb25jYXQoZHBjKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdC8vID8pIHRocmVlX3N0YXRlIHNlbGVjdGlvbiAtIHAuc3RhdGUuc2VsZWN0ZWQgJiYgdCAtIChpZiB0aHJlZV9zdGF0ZSBmb3JlYWNoKGRhdCA9PiBjaCkgLT4gZm9yZWFjaChwYXJlbnRzKSBpZihwYXJlbnQuc2VsZWN0ZWQpIGNoaWxkLnNlbGVjdGVkID0gdHJ1ZTtcblx0XHRcdFx0XHRcdHJzbHQgPSB7XG5cdFx0XHRcdFx0XHRcdCdjbnQnIDogdF9jbnQsXG5cdFx0XHRcdFx0XHRcdCdtb2QnIDogbSxcblx0XHRcdFx0XHRcdFx0J3NlbCcgOiBzZWwsXG5cdFx0XHRcdFx0XHRcdCdwYXInIDogcGFyLFxuXHRcdFx0XHRcdFx0XHQnZHBjJyA6IGRwYyxcblx0XHRcdFx0XHRcdFx0J2FkZCcgOiBhZGRcblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0Zm9yKGkgPSAwLCBqID0gZGF0Lmxlbmd0aDsgaSA8IGo7IGkrKykge1xuXHRcdFx0XHRcdFx0XHR0bXAgPSBwYXJzZV9uZXN0KGRhdFtpXSwgcGFyLCBwLnBhcmVudHMuY29uY2F0KCkpO1xuXHRcdFx0XHRcdFx0XHRpZih0bXApIHtcblx0XHRcdFx0XHRcdFx0XHRjaGQucHVzaCh0bXApO1xuXHRcdFx0XHRcdFx0XHRcdGRwYy5wdXNoKHRtcCk7XG5cdFx0XHRcdFx0XHRcdFx0aWYobVt0bXBdLmNoaWxkcmVuX2QubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRkcGMgPSBkcGMuY29uY2F0KG1bdG1wXS5jaGlsZHJlbl9kKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHAuY2hpbGRyZW4gPSBjaGQ7XG5cdFx0XHRcdFx0XHRwLmNoaWxkcmVuX2QgPSBkcGM7XG5cdFx0XHRcdFx0XHRmb3IoaSA9IDAsIGogPSBwLnBhcmVudHMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdG1bcC5wYXJlbnRzW2ldXS5jaGlsZHJlbl9kID0gbVtwLnBhcmVudHNbaV1dLmNoaWxkcmVuX2QuY29uY2F0KGRwYyk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRyc2x0ID0ge1xuXHRcdFx0XHRcdFx0XHQnY250JyA6IHRfY250LFxuXHRcdFx0XHRcdFx0XHQnbW9kJyA6IG0sXG5cdFx0XHRcdFx0XHRcdCdzZWwnIDogc2VsLFxuXHRcdFx0XHRcdFx0XHQncGFyJyA6IHBhcixcblx0XHRcdFx0XHRcdFx0J2RwYycgOiBkcGMsXG5cdFx0XHRcdFx0XHRcdCdhZGQnIDogYWRkXG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gcnNsdDtcblx0XHRcdFx0fSxcblx0XHRcdFx0cnNsdCA9IGZ1bmN0aW9uIChyc2x0LCB3b3JrZXIpIHtcblx0XHRcdFx0XHR0aGlzLl9jbnQgPSByc2x0LmNudDtcblx0XHRcdFx0XHR0aGlzLl9tb2RlbC5kYXRhID0gcnNsdC5tb2Q7IC8vIGJyZWFrcyB0aGUgcmVmZXJlbmNlIGluIGxvYWRfbm9kZSAtIGNhcmVmdWxcblxuXHRcdFx0XHRcdGlmKHdvcmtlcikge1xuXHRcdFx0XHRcdFx0dmFyIGksIGosIGEgPSByc2x0LmFkZCwgciA9IHJzbHQuc2VsLCBzID0gdGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkLnNsaWNlKCksIG0gPSB0aGlzLl9tb2RlbC5kYXRhO1xuXHRcdFx0XHRcdFx0Ly8gaWYgc2VsZWN0aW9uIHdhcyBjaGFuZ2VkIHdoaWxlIGNhbGN1bGF0aW5nIGluIHdvcmtlclxuXHRcdFx0XHRcdFx0aWYoci5sZW5ndGggIT09IHMubGVuZ3RoIHx8ICQudmFrYXRhLmFycmF5X3VuaXF1ZShyLmNvbmNhdChzKSkubGVuZ3RoICE9PSByLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0XHQvLyBkZXNlbGVjdCBub2RlcyB0aGF0IGFyZSBubyBsb25nZXIgc2VsZWN0ZWRcblx0XHRcdFx0XHRcdFx0Zm9yKGkgPSAwLCBqID0gci5sZW5ndGg7IGkgPCBqOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0XHRpZigkLmluQXJyYXkocltpXSwgYSkgPT09IC0xICYmICQuaW5BcnJheShyW2ldLCBzKSA9PT0gLTEpIHtcblx0XHRcdFx0XHRcdFx0XHRcdG1bcltpXV0uc3RhdGUuc2VsZWN0ZWQgPSBmYWxzZTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0Ly8gc2VsZWN0IG5vZGVzIHRoYXQgd2VyZSBzZWxlY3RlZCBpbiB0aGUgbWVhbiB0aW1lXG5cdFx0XHRcdFx0XHRcdGZvcihpID0gMCwgaiA9IHMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYoJC5pbkFycmF5KHNbaV0sIHIpID09PSAtMSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0bVtzW2ldXS5zdGF0ZS5zZWxlY3RlZCA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmKHJzbHQuYWRkLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0dGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkID0gdGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkLmNvbmNhdChyc2x0LmFkZCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0dGhpcy50cmlnZ2VyKCdtb2RlbCcsIHsgXCJub2Rlc1wiIDogcnNsdC5kcGMsICdwYXJlbnQnIDogcnNsdC5wYXIgfSk7XG5cblx0XHRcdFx0XHRpZihyc2x0LnBhciAhPT0gJyMnKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9ub2RlX2NoYW5nZWQocnNsdC5wYXIpO1xuXHRcdFx0XHRcdFx0dGhpcy5yZWRyYXcoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHQvLyB0aGlzLmdldF9jb250YWluZXJfdWwoKS5jaGlsZHJlbignLmpzdHJlZS1pbml0aWFsLW5vZGUnKS5yZW1vdmUoKTtcblx0XHRcdFx0XHRcdHRoaXMucmVkcmF3KHRydWUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZihyc2x0LmFkZC5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdHRoaXMudHJpZ2dlcignY2hhbmdlZCcsIHsgJ2FjdGlvbicgOiAnbW9kZWwnLCAnc2VsZWN0ZWQnIDogdGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkIH0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjYi5jYWxsKHRoaXMsIHRydWUpO1xuXHRcdFx0XHR9O1xuXHRcdFx0aWYodGhpcy5zZXR0aW5ncy5jb3JlLndvcmtlciAmJiB3aW5kb3cuQmxvYiAmJiB3aW5kb3cuVVJMICYmIHdpbmRvdy5Xb3JrZXIpIHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRpZih0aGlzLl93cmsgPT09IG51bGwpIHtcblx0XHRcdFx0XHRcdHRoaXMuX3dyayA9IHdpbmRvdy5VUkwuY3JlYXRlT2JqZWN0VVJMKFxuXHRcdFx0XHRcdFx0XHRuZXcgd2luZG93LkJsb2IoXG5cdFx0XHRcdFx0XHRcdFx0WydzZWxmLm9ubWVzc2FnZSA9ICcgKyBmdW5jLnRvU3RyaW5nKCkucmVwbGFjZSgvcmV0dXJuIChbXjt9XSspW1xcczt9XSskLywgJ3Bvc3RNZXNzYWdlKCQxKTt9JyldLFxuXHRcdFx0XHRcdFx0XHRcdHt0eXBlOlwidGV4dC9qYXZhc2NyaXB0XCJ9XG5cdFx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHcgPSBuZXcgd2luZG93Lldvcmtlcih0aGlzLl93cmspO1xuXHRcdFx0XHRcdHcub25tZXNzYWdlID0gJC5wcm94eShmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHRcdFx0cnNsdC5jYWxsKHRoaXMsIGUuZGF0YSwgdHJ1ZSk7XG5cdFx0XHRcdFx0XHR0aGlzLl9kYXRhLmNvcmUud29ya2luZyA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0aWYodGhpcy5fZGF0YS5jb3JlLndvcmtlcl9xdWV1ZS5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5fYXBwZW5kX2pzb25fZGF0YS5hcHBseSh0aGlzLCB0aGlzLl9kYXRhLmNvcmUud29ya2VyX3F1ZXVlLnNoaWZ0KCkpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sIHRoaXMpO1xuXHRcdFx0XHRcdGlmKCF0aGlzLl9kYXRhLmNvcmUud29ya2luZykge1xuXHRcdFx0XHRcdFx0dGhpcy5fZGF0YS5jb3JlLndvcmtpbmcgPSB0cnVlO1xuXHRcdFx0XHRcdFx0dy5wb3N0TWVzc2FnZShhcmdzKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9kYXRhLmNvcmUud29ya2VyX3F1ZXVlLnB1c2goW2RvbSwgZGF0YSwgY2JdKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0Y2F0Y2goZSkge1xuXHRcdFx0XHRcdHJzbHQuY2FsbCh0aGlzLCBmdW5jKGFyZ3MpLCBmYWxzZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRyc2x0LmNhbGwodGhpcywgZnVuYyhhcmdzKSwgZmFsc2UpO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogcGFyc2VzIGEgbm9kZSBmcm9tIGEgalF1ZXJ5IG9iamVjdCBhbmQgYXBwZW5kcyB0aGVtIHRvIHRoZSBpbiBtZW1vcnkgdHJlZSBtb2RlbC4gVXNlZCBpbnRlcm5hbGx5LlxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICogQG5hbWUgX3BhcnNlX21vZGVsX2Zyb21faHRtbChkIFssIHAsIHBzXSlcblx0XHQgKiBAcGFyYW0gIHtqUXVlcnl9IGQgdGhlIGpRdWVyeSBvYmplY3QgdG8gcGFyc2Vcblx0XHQgKiBAcGFyYW0gIHtTdHJpbmd9IHAgdGhlIHBhcmVudCBJRFxuXHRcdCAqIEBwYXJhbSAge0FycmF5fSBwcyBsaXN0IG9mIGFsbCBwYXJlbnRzXG5cdFx0ICogQHJldHVybiB7U3RyaW5nfSB0aGUgSUQgb2YgdGhlIG9iamVjdCBhZGRlZCB0byB0aGUgbW9kZWxcblx0XHQgKi9cblx0XHRfcGFyc2VfbW9kZWxfZnJvbV9odG1sIDogZnVuY3Rpb24gKGQsIHAsIHBzKSB7XG5cdFx0XHRpZighcHMpIHsgcHMgPSBbXTsgfVxuXHRcdFx0ZWxzZSB7IHBzID0gW10uY29uY2F0KHBzKTsgfVxuXHRcdFx0aWYocCkgeyBwcy51bnNoaWZ0KHApOyB9XG5cdFx0XHR2YXIgYywgZSwgbSA9IHRoaXMuX21vZGVsLmRhdGEsXG5cdFx0XHRcdGRhdGEgPSB7XG5cdFx0XHRcdFx0aWRcdFx0XHQ6IGZhbHNlLFxuXHRcdFx0XHRcdHRleHRcdFx0OiBmYWxzZSxcblx0XHRcdFx0XHRpY29uXHRcdDogdHJ1ZSxcblx0XHRcdFx0XHRwYXJlbnRcdFx0OiBwLFxuXHRcdFx0XHRcdHBhcmVudHNcdFx0OiBwcyxcblx0XHRcdFx0XHRjaGlsZHJlblx0OiBbXSxcblx0XHRcdFx0XHRjaGlsZHJlbl9kXHQ6IFtdLFxuXHRcdFx0XHRcdGRhdGFcdFx0OiBudWxsLFxuXHRcdFx0XHRcdHN0YXRlXHRcdDogeyB9LFxuXHRcdFx0XHRcdGxpX2F0dHJcdFx0OiB7IGlkIDogZmFsc2UgfSxcblx0XHRcdFx0XHRhX2F0dHJcdFx0OiB7IGhyZWYgOiAnIycgfSxcblx0XHRcdFx0XHRvcmlnaW5hbFx0OiBmYWxzZVxuXHRcdFx0XHR9LCBpLCB0bXAsIHRpZDtcblx0XHRcdGZvcihpIGluIHRoaXMuX21vZGVsLmRlZmF1bHRfc3RhdGUpIHtcblx0XHRcdFx0aWYodGhpcy5fbW9kZWwuZGVmYXVsdF9zdGF0ZS5oYXNPd25Qcm9wZXJ0eShpKSkge1xuXHRcdFx0XHRcdGRhdGEuc3RhdGVbaV0gPSB0aGlzLl9tb2RlbC5kZWZhdWx0X3N0YXRlW2ldO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR0bXAgPSAkLnZha2F0YS5hdHRyaWJ1dGVzKGQsIHRydWUpO1xuXHRcdFx0JC5lYWNoKHRtcCwgZnVuY3Rpb24gKGksIHYpIHtcblx0XHRcdFx0diA9ICQudHJpbSh2KTtcblx0XHRcdFx0aWYoIXYubGVuZ3RoKSB7IHJldHVybiB0cnVlOyB9XG5cdFx0XHRcdGRhdGEubGlfYXR0cltpXSA9IHY7XG5cdFx0XHRcdGlmKGkgPT09ICdpZCcpIHtcblx0XHRcdFx0XHRkYXRhLmlkID0gdi50b1N0cmluZygpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHRcdHRtcCA9IGQuY2hpbGRyZW4oJ2EnKS5lcSgwKTtcblx0XHRcdGlmKHRtcC5sZW5ndGgpIHtcblx0XHRcdFx0dG1wID0gJC52YWthdGEuYXR0cmlidXRlcyh0bXAsIHRydWUpO1xuXHRcdFx0XHQkLmVhY2godG1wLCBmdW5jdGlvbiAoaSwgdikge1xuXHRcdFx0XHRcdHYgPSAkLnRyaW0odik7XG5cdFx0XHRcdFx0aWYodi5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdGRhdGEuYV9hdHRyW2ldID0gdjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdFx0dG1wID0gZC5jaGlsZHJlbihcImE6ZXEoMClcIikubGVuZ3RoID8gZC5jaGlsZHJlbihcImE6ZXEoMClcIikuY2xvbmUoKSA6IGQuY2xvbmUoKTtcblx0XHRcdHRtcC5jaGlsZHJlbihcImlucywgaSwgdWxcIikucmVtb3ZlKCk7XG5cdFx0XHR0bXAgPSB0bXAuaHRtbCgpO1xuXHRcdFx0dG1wID0gJCgnPGRpdiAvPicpLmh0bWwodG1wKTtcblx0XHRcdGRhdGEudGV4dCA9IHRoaXMuc2V0dGluZ3MuY29yZS5mb3JjZV90ZXh0ID8gdG1wLnRleHQoKSA6IHRtcC5odG1sKCk7XG5cdFx0XHR0bXAgPSBkLmRhdGEoKTtcblx0XHRcdGRhdGEuZGF0YSA9IHRtcCA/ICQuZXh0ZW5kKHRydWUsIHt9LCB0bXApIDogbnVsbDtcblx0XHRcdGRhdGEuc3RhdGUub3BlbmVkID0gZC5oYXNDbGFzcygnanN0cmVlLW9wZW4nKTtcblx0XHRcdGRhdGEuc3RhdGUuc2VsZWN0ZWQgPSBkLmNoaWxkcmVuKCdhJykuaGFzQ2xhc3MoJ2pzdHJlZS1jbGlja2VkJyk7XG5cdFx0XHRkYXRhLnN0YXRlLmRpc2FibGVkID0gZC5jaGlsZHJlbignYScpLmhhc0NsYXNzKCdqc3RyZWUtZGlzYWJsZWQnKTtcblx0XHRcdGlmKGRhdGEuZGF0YSAmJiBkYXRhLmRhdGEuanN0cmVlKSB7XG5cdFx0XHRcdGZvcihpIGluIGRhdGEuZGF0YS5qc3RyZWUpIHtcblx0XHRcdFx0XHRpZihkYXRhLmRhdGEuanN0cmVlLmhhc093blByb3BlcnR5KGkpKSB7XG5cdFx0XHRcdFx0XHRkYXRhLnN0YXRlW2ldID0gZGF0YS5kYXRhLmpzdHJlZVtpXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHRtcCA9IGQuY2hpbGRyZW4oXCJhXCIpLmNoaWxkcmVuKFwiLmpzdHJlZS10aGVtZWljb25cIik7XG5cdFx0XHRpZih0bXAubGVuZ3RoKSB7XG5cdFx0XHRcdGRhdGEuaWNvbiA9IHRtcC5oYXNDbGFzcygnanN0cmVlLXRoZW1laWNvbi1oaWRkZW4nKSA/IGZhbHNlIDogdG1wLmF0dHIoJ3JlbCcpO1xuXHRcdFx0fVxuXHRcdFx0aWYoZGF0YS5zdGF0ZS5pY29uKSB7XG5cdFx0XHRcdGRhdGEuaWNvbiA9IGRhdGEuc3RhdGUuaWNvbjtcblx0XHRcdH1cblx0XHRcdHRtcCA9IGQuY2hpbGRyZW4oXCJ1bFwiKS5jaGlsZHJlbihcImxpXCIpO1xuXHRcdFx0ZG8ge1xuXHRcdFx0XHR0aWQgPSAnaicgKyB0aGlzLl9pZCArICdfJyArICgrK3RoaXMuX2NudCk7XG5cdFx0XHR9IHdoaWxlKG1bdGlkXSk7XG5cdFx0XHRkYXRhLmlkID0gZGF0YS5saV9hdHRyLmlkID8gZGF0YS5saV9hdHRyLmlkLnRvU3RyaW5nKCkgOiB0aWQ7XG5cdFx0XHRpZih0bXAubGVuZ3RoKSB7XG5cdFx0XHRcdHRtcC5lYWNoKCQucHJveHkoZnVuY3Rpb24gKGksIHYpIHtcblx0XHRcdFx0XHRjID0gdGhpcy5fcGFyc2VfbW9kZWxfZnJvbV9odG1sKCQodiksIGRhdGEuaWQsIHBzKTtcblx0XHRcdFx0XHRlID0gdGhpcy5fbW9kZWwuZGF0YVtjXTtcblx0XHRcdFx0XHRkYXRhLmNoaWxkcmVuLnB1c2goYyk7XG5cdFx0XHRcdFx0aWYoZS5jaGlsZHJlbl9kLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0ZGF0YS5jaGlsZHJlbl9kID0gZGF0YS5jaGlsZHJlbl9kLmNvbmNhdChlLmNoaWxkcmVuX2QpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSwgdGhpcykpO1xuXHRcdFx0XHRkYXRhLmNoaWxkcmVuX2QgPSBkYXRhLmNoaWxkcmVuX2QuY29uY2F0KGRhdGEuY2hpbGRyZW4pO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGlmKGQuaGFzQ2xhc3MoJ2pzdHJlZS1jbG9zZWQnKSkge1xuXHRcdFx0XHRcdGRhdGEuc3RhdGUubG9hZGVkID0gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmKGRhdGEubGlfYXR0clsnY2xhc3MnXSkge1xuXHRcdFx0XHRkYXRhLmxpX2F0dHJbJ2NsYXNzJ10gPSBkYXRhLmxpX2F0dHJbJ2NsYXNzJ10ucmVwbGFjZSgnanN0cmVlLWNsb3NlZCcsJycpLnJlcGxhY2UoJ2pzdHJlZS1vcGVuJywnJyk7XG5cdFx0XHR9XG5cdFx0XHRpZihkYXRhLmFfYXR0clsnY2xhc3MnXSkge1xuXHRcdFx0XHRkYXRhLmFfYXR0clsnY2xhc3MnXSA9IGRhdGEuYV9hdHRyWydjbGFzcyddLnJlcGxhY2UoJ2pzdHJlZS1jbGlja2VkJywnJykucmVwbGFjZSgnanN0cmVlLWRpc2FibGVkJywnJyk7XG5cdFx0XHR9XG5cdFx0XHRtW2RhdGEuaWRdID0gZGF0YTtcblx0XHRcdGlmKGRhdGEuc3RhdGUuc2VsZWN0ZWQpIHtcblx0XHRcdFx0dGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkLnB1c2goZGF0YS5pZCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZGF0YS5pZDtcblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIHBhcnNlcyBhIG5vZGUgZnJvbSBhIEpTT04gb2JqZWN0ICh1c2VkIHdoZW4gZGVhbGluZyB3aXRoIGZsYXQgZGF0YSwgd2hpY2ggaGFzIG5vIG5lc3Rpbmcgb2YgY2hpbGRyZW4sIGJ1dCBoYXMgaWQgYW5kIHBhcmVudCBwcm9wZXJ0aWVzKSBhbmQgYXBwZW5kcyBpdCB0byB0aGUgaW4gbWVtb3J5IHRyZWUgbW9kZWwuIFVzZWQgaW50ZXJuYWxseS5cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqIEBuYW1lIF9wYXJzZV9tb2RlbF9mcm9tX2ZsYXRfanNvbihkIFssIHAsIHBzXSlcblx0XHQgKiBAcGFyYW0gIHtPYmplY3R9IGQgdGhlIEpTT04gb2JqZWN0IHRvIHBhcnNlXG5cdFx0ICogQHBhcmFtICB7U3RyaW5nfSBwIHRoZSBwYXJlbnQgSURcblx0XHQgKiBAcGFyYW0gIHtBcnJheX0gcHMgbGlzdCBvZiBhbGwgcGFyZW50c1xuXHRcdCAqIEByZXR1cm4ge1N0cmluZ30gdGhlIElEIG9mIHRoZSBvYmplY3QgYWRkZWQgdG8gdGhlIG1vZGVsXG5cdFx0ICovXG5cdFx0X3BhcnNlX21vZGVsX2Zyb21fZmxhdF9qc29uIDogZnVuY3Rpb24gKGQsIHAsIHBzKSB7XG5cdFx0XHRpZighcHMpIHsgcHMgPSBbXTsgfVxuXHRcdFx0ZWxzZSB7IHBzID0gcHMuY29uY2F0KCk7IH1cblx0XHRcdGlmKHApIHsgcHMudW5zaGlmdChwKTsgfVxuXHRcdFx0dmFyIHRpZCA9IGQuaWQudG9TdHJpbmcoKSxcblx0XHRcdFx0bSA9IHRoaXMuX21vZGVsLmRhdGEsXG5cdFx0XHRcdGRmID0gdGhpcy5fbW9kZWwuZGVmYXVsdF9zdGF0ZSxcblx0XHRcdFx0aSwgaiwgYywgZSxcblx0XHRcdFx0dG1wID0ge1xuXHRcdFx0XHRcdGlkXHRcdFx0OiB0aWQsXG5cdFx0XHRcdFx0dGV4dFx0XHQ6IGQudGV4dCB8fCAnJyxcblx0XHRcdFx0XHRpY29uXHRcdDogZC5pY29uICE9PSB1bmRlZmluZWQgPyBkLmljb24gOiB0cnVlLFxuXHRcdFx0XHRcdHBhcmVudFx0XHQ6IHAsXG5cdFx0XHRcdFx0cGFyZW50c1x0XHQ6IHBzLFxuXHRcdFx0XHRcdGNoaWxkcmVuXHQ6IGQuY2hpbGRyZW4gfHwgW10sXG5cdFx0XHRcdFx0Y2hpbGRyZW5fZFx0OiBkLmNoaWxkcmVuX2QgfHwgW10sXG5cdFx0XHRcdFx0ZGF0YVx0XHQ6IGQuZGF0YSxcblx0XHRcdFx0XHRzdGF0ZVx0XHQ6IHsgfSxcblx0XHRcdFx0XHRsaV9hdHRyXHRcdDogeyBpZCA6IGZhbHNlIH0sXG5cdFx0XHRcdFx0YV9hdHRyXHRcdDogeyBocmVmIDogJyMnIH0sXG5cdFx0XHRcdFx0b3JpZ2luYWxcdDogZmFsc2Vcblx0XHRcdFx0fTtcblx0XHRcdGZvcihpIGluIGRmKSB7XG5cdFx0XHRcdGlmKGRmLmhhc093blByb3BlcnR5KGkpKSB7XG5cdFx0XHRcdFx0dG1wLnN0YXRlW2ldID0gZGZbaV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmKGQgJiYgZC5kYXRhICYmIGQuZGF0YS5qc3RyZWUgJiYgZC5kYXRhLmpzdHJlZS5pY29uKSB7XG5cdFx0XHRcdHRtcC5pY29uID0gZC5kYXRhLmpzdHJlZS5pY29uO1xuXHRcdFx0fVxuXHRcdFx0aWYoZCAmJiBkLmRhdGEpIHtcblx0XHRcdFx0dG1wLmRhdGEgPSBkLmRhdGE7XG5cdFx0XHRcdGlmKGQuZGF0YS5qc3RyZWUpIHtcblx0XHRcdFx0XHRmb3IoaSBpbiBkLmRhdGEuanN0cmVlKSB7XG5cdFx0XHRcdFx0XHRpZihkLmRhdGEuanN0cmVlLmhhc093blByb3BlcnR5KGkpKSB7XG5cdFx0XHRcdFx0XHRcdHRtcC5zdGF0ZVtpXSA9IGQuZGF0YS5qc3RyZWVbaV07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZihkICYmIHR5cGVvZiBkLnN0YXRlID09PSAnb2JqZWN0Jykge1xuXHRcdFx0XHRmb3IgKGkgaW4gZC5zdGF0ZSkge1xuXHRcdFx0XHRcdGlmKGQuc3RhdGUuaGFzT3duUHJvcGVydHkoaSkpIHtcblx0XHRcdFx0XHRcdHRtcC5zdGF0ZVtpXSA9IGQuc3RhdGVbaV07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZihkICYmIHR5cGVvZiBkLmxpX2F0dHIgPT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdGZvciAoaSBpbiBkLmxpX2F0dHIpIHtcblx0XHRcdFx0XHRpZihkLmxpX2F0dHIuaGFzT3duUHJvcGVydHkoaSkpIHtcblx0XHRcdFx0XHRcdHRtcC5saV9hdHRyW2ldID0gZC5saV9hdHRyW2ldO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYoIXRtcC5saV9hdHRyLmlkKSB7XG5cdFx0XHRcdHRtcC5saV9hdHRyLmlkID0gdGlkO1xuXHRcdFx0fVxuXHRcdFx0aWYoZCAmJiB0eXBlb2YgZC5hX2F0dHIgPT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdGZvciAoaSBpbiBkLmFfYXR0cikge1xuXHRcdFx0XHRcdGlmKGQuYV9hdHRyLmhhc093blByb3BlcnR5KGkpKSB7XG5cdFx0XHRcdFx0XHR0bXAuYV9hdHRyW2ldID0gZC5hX2F0dHJbaV07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZihkICYmIGQuY2hpbGRyZW4gJiYgZC5jaGlsZHJlbiA9PT0gdHJ1ZSkge1xuXHRcdFx0XHR0bXAuc3RhdGUubG9hZGVkID0gZmFsc2U7XG5cdFx0XHRcdHRtcC5jaGlsZHJlbiA9IFtdO1xuXHRcdFx0XHR0bXAuY2hpbGRyZW5fZCA9IFtdO1xuXHRcdFx0fVxuXHRcdFx0bVt0bXAuaWRdID0gdG1wO1xuXHRcdFx0Zm9yKGkgPSAwLCBqID0gdG1wLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuXHRcdFx0XHRjID0gdGhpcy5fcGFyc2VfbW9kZWxfZnJvbV9mbGF0X2pzb24obVt0bXAuY2hpbGRyZW5baV1dLCB0bXAuaWQsIHBzKTtcblx0XHRcdFx0ZSA9IG1bY107XG5cdFx0XHRcdHRtcC5jaGlsZHJlbl9kLnB1c2goYyk7XG5cdFx0XHRcdGlmKGUuY2hpbGRyZW5fZC5sZW5ndGgpIHtcblx0XHRcdFx0XHR0bXAuY2hpbGRyZW5fZCA9IHRtcC5jaGlsZHJlbl9kLmNvbmNhdChlLmNoaWxkcmVuX2QpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRkZWxldGUgZC5kYXRhO1xuXHRcdFx0ZGVsZXRlIGQuY2hpbGRyZW47XG5cdFx0XHRtW3RtcC5pZF0ub3JpZ2luYWwgPSBkO1xuXHRcdFx0aWYodG1wLnN0YXRlLnNlbGVjdGVkKSB7XG5cdFx0XHRcdHRoaXMuX2RhdGEuY29yZS5zZWxlY3RlZC5wdXNoKHRtcC5pZCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdG1wLmlkO1xuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogcGFyc2VzIGEgbm9kZSBmcm9tIGEgSlNPTiBvYmplY3QgYW5kIGFwcGVuZHMgaXQgdG8gdGhlIGluIG1lbW9yeSB0cmVlIG1vZGVsLiBVc2VkIGludGVybmFsbHkuXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKiBAbmFtZSBfcGFyc2VfbW9kZWxfZnJvbV9qc29uKGQgWywgcCwgcHNdKVxuXHRcdCAqIEBwYXJhbSAge09iamVjdH0gZCB0aGUgSlNPTiBvYmplY3QgdG8gcGFyc2Vcblx0XHQgKiBAcGFyYW0gIHtTdHJpbmd9IHAgdGhlIHBhcmVudCBJRFxuXHRcdCAqIEBwYXJhbSAge0FycmF5fSBwcyBsaXN0IG9mIGFsbCBwYXJlbnRzXG5cdFx0ICogQHJldHVybiB7U3RyaW5nfSB0aGUgSUQgb2YgdGhlIG9iamVjdCBhZGRlZCB0byB0aGUgbW9kZWxcblx0XHQgKi9cblx0XHRfcGFyc2VfbW9kZWxfZnJvbV9qc29uIDogZnVuY3Rpb24gKGQsIHAsIHBzKSB7XG5cdFx0XHRpZighcHMpIHsgcHMgPSBbXTsgfVxuXHRcdFx0ZWxzZSB7IHBzID0gcHMuY29uY2F0KCk7IH1cblx0XHRcdGlmKHApIHsgcHMudW5zaGlmdChwKTsgfVxuXHRcdFx0dmFyIHRpZCA9IGZhbHNlLCBpLCBqLCBjLCBlLCBtID0gdGhpcy5fbW9kZWwuZGF0YSwgZGYgPSB0aGlzLl9tb2RlbC5kZWZhdWx0X3N0YXRlLCB0bXA7XG5cdFx0XHRkbyB7XG5cdFx0XHRcdHRpZCA9ICdqJyArIHRoaXMuX2lkICsgJ18nICsgKCsrdGhpcy5fY250KTtcblx0XHRcdH0gd2hpbGUobVt0aWRdKTtcblxuXHRcdFx0dG1wID0ge1xuXHRcdFx0XHRpZFx0XHRcdDogZmFsc2UsXG5cdFx0XHRcdHRleHRcdFx0OiB0eXBlb2YgZCA9PT0gJ3N0cmluZycgPyBkIDogJycsXG5cdFx0XHRcdGljb25cdFx0OiB0eXBlb2YgZCA9PT0gJ29iamVjdCcgJiYgZC5pY29uICE9PSB1bmRlZmluZWQgPyBkLmljb24gOiB0cnVlLFxuXHRcdFx0XHRwYXJlbnRcdFx0OiBwLFxuXHRcdFx0XHRwYXJlbnRzXHRcdDogcHMsXG5cdFx0XHRcdGNoaWxkcmVuXHQ6IFtdLFxuXHRcdFx0XHRjaGlsZHJlbl9kXHQ6IFtdLFxuXHRcdFx0XHRkYXRhXHRcdDogbnVsbCxcblx0XHRcdFx0c3RhdGVcdFx0OiB7IH0sXG5cdFx0XHRcdGxpX2F0dHJcdFx0OiB7IGlkIDogZmFsc2UgfSxcblx0XHRcdFx0YV9hdHRyXHRcdDogeyBocmVmIDogJyMnIH0sXG5cdFx0XHRcdG9yaWdpbmFsXHQ6IGZhbHNlXG5cdFx0XHR9O1xuXHRcdFx0Zm9yKGkgaW4gZGYpIHtcblx0XHRcdFx0aWYoZGYuaGFzT3duUHJvcGVydHkoaSkpIHtcblx0XHRcdFx0XHR0bXAuc3RhdGVbaV0gPSBkZltpXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYoZCAmJiBkLmlkKSB7IHRtcC5pZCA9IGQuaWQudG9TdHJpbmcoKTsgfVxuXHRcdFx0aWYoZCAmJiBkLnRleHQpIHsgdG1wLnRleHQgPSBkLnRleHQ7IH1cblx0XHRcdGlmKGQgJiYgZC5kYXRhICYmIGQuZGF0YS5qc3RyZWUgJiYgZC5kYXRhLmpzdHJlZS5pY29uKSB7XG5cdFx0XHRcdHRtcC5pY29uID0gZC5kYXRhLmpzdHJlZS5pY29uO1xuXHRcdFx0fVxuXHRcdFx0aWYoZCAmJiBkLmRhdGEpIHtcblx0XHRcdFx0dG1wLmRhdGEgPSBkLmRhdGE7XG5cdFx0XHRcdGlmKGQuZGF0YS5qc3RyZWUpIHtcblx0XHRcdFx0XHRmb3IoaSBpbiBkLmRhdGEuanN0cmVlKSB7XG5cdFx0XHRcdFx0XHRpZihkLmRhdGEuanN0cmVlLmhhc093blByb3BlcnR5KGkpKSB7XG5cdFx0XHRcdFx0XHRcdHRtcC5zdGF0ZVtpXSA9IGQuZGF0YS5qc3RyZWVbaV07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZihkICYmIHR5cGVvZiBkLnN0YXRlID09PSAnb2JqZWN0Jykge1xuXHRcdFx0XHRmb3IgKGkgaW4gZC5zdGF0ZSkge1xuXHRcdFx0XHRcdGlmKGQuc3RhdGUuaGFzT3duUHJvcGVydHkoaSkpIHtcblx0XHRcdFx0XHRcdHRtcC5zdGF0ZVtpXSA9IGQuc3RhdGVbaV07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZihkICYmIHR5cGVvZiBkLmxpX2F0dHIgPT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdGZvciAoaSBpbiBkLmxpX2F0dHIpIHtcblx0XHRcdFx0XHRpZihkLmxpX2F0dHIuaGFzT3duUHJvcGVydHkoaSkpIHtcblx0XHRcdFx0XHRcdHRtcC5saV9hdHRyW2ldID0gZC5saV9hdHRyW2ldO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYodG1wLmxpX2F0dHIuaWQgJiYgIXRtcC5pZCkge1xuXHRcdFx0XHR0bXAuaWQgPSB0bXAubGlfYXR0ci5pZC50b1N0cmluZygpO1xuXHRcdFx0fVxuXHRcdFx0aWYoIXRtcC5pZCkge1xuXHRcdFx0XHR0bXAuaWQgPSB0aWQ7XG5cdFx0XHR9XG5cdFx0XHRpZighdG1wLmxpX2F0dHIuaWQpIHtcblx0XHRcdFx0dG1wLmxpX2F0dHIuaWQgPSB0bXAuaWQ7XG5cdFx0XHR9XG5cdFx0XHRpZihkICYmIHR5cGVvZiBkLmFfYXR0ciA9PT0gJ29iamVjdCcpIHtcblx0XHRcdFx0Zm9yIChpIGluIGQuYV9hdHRyKSB7XG5cdFx0XHRcdFx0aWYoZC5hX2F0dHIuaGFzT3duUHJvcGVydHkoaSkpIHtcblx0XHRcdFx0XHRcdHRtcC5hX2F0dHJbaV0gPSBkLmFfYXR0cltpXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmKGQgJiYgZC5jaGlsZHJlbiAmJiBkLmNoaWxkcmVuLmxlbmd0aCkge1xuXHRcdFx0XHRmb3IoaSA9IDAsIGogPSBkLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuXHRcdFx0XHRcdGMgPSB0aGlzLl9wYXJzZV9tb2RlbF9mcm9tX2pzb24oZC5jaGlsZHJlbltpXSwgdG1wLmlkLCBwcyk7XG5cdFx0XHRcdFx0ZSA9IG1bY107XG5cdFx0XHRcdFx0dG1wLmNoaWxkcmVuLnB1c2goYyk7XG5cdFx0XHRcdFx0aWYoZS5jaGlsZHJlbl9kLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0dG1wLmNoaWxkcmVuX2QgPSB0bXAuY2hpbGRyZW5fZC5jb25jYXQoZS5jaGlsZHJlbl9kKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0dG1wLmNoaWxkcmVuX2QgPSB0bXAuY2hpbGRyZW5fZC5jb25jYXQodG1wLmNoaWxkcmVuKTtcblx0XHRcdH1cblx0XHRcdGlmKGQgJiYgZC5jaGlsZHJlbiAmJiBkLmNoaWxkcmVuID09PSB0cnVlKSB7XG5cdFx0XHRcdHRtcC5zdGF0ZS5sb2FkZWQgPSBmYWxzZTtcblx0XHRcdFx0dG1wLmNoaWxkcmVuID0gW107XG5cdFx0XHRcdHRtcC5jaGlsZHJlbl9kID0gW107XG5cdFx0XHR9XG5cdFx0XHRkZWxldGUgZC5kYXRhO1xuXHRcdFx0ZGVsZXRlIGQuY2hpbGRyZW47XG5cdFx0XHR0bXAub3JpZ2luYWwgPSBkO1xuXHRcdFx0bVt0bXAuaWRdID0gdG1wO1xuXHRcdFx0aWYodG1wLnN0YXRlLnNlbGVjdGVkKSB7XG5cdFx0XHRcdHRoaXMuX2RhdGEuY29yZS5zZWxlY3RlZC5wdXNoKHRtcC5pZCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdG1wLmlkO1xuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogcmVkcmF3cyBhbGwgbm9kZXMgdGhhdCBuZWVkIHRvIGJlIHJlZHJhd24uIFVzZWQgaW50ZXJuYWxseS5cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqIEBuYW1lIF9yZWRyYXcoKVxuXHRcdCAqIEB0cmlnZ2VyIHJlZHJhdy5qc3RyZWVcblx0XHQgKi9cblx0XHRfcmVkcmF3IDogZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIG5vZGVzID0gdGhpcy5fbW9kZWwuZm9yY2VfZnVsbF9yZWRyYXcgPyB0aGlzLl9tb2RlbC5kYXRhWycjJ10uY2hpbGRyZW4uY29uY2F0KFtdKSA6IHRoaXMuX21vZGVsLmNoYW5nZWQuY29uY2F0KFtdKSxcblx0XHRcdFx0ZiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ1VMJyksIHRtcCwgaSwgajtcblx0XHRcdGZvcihpID0gMCwgaiA9IG5vZGVzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuXHRcdFx0XHR0bXAgPSB0aGlzLnJlZHJhd19ub2RlKG5vZGVzW2ldLCB0cnVlLCB0aGlzLl9tb2RlbC5mb3JjZV9mdWxsX3JlZHJhdyk7XG5cdFx0XHRcdGlmKHRtcCAmJiB0aGlzLl9tb2RlbC5mb3JjZV9mdWxsX3JlZHJhdykge1xuXHRcdFx0XHRcdGYuYXBwZW5kQ2hpbGQodG1wKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYodGhpcy5fbW9kZWwuZm9yY2VfZnVsbF9yZWRyYXcpIHtcblx0XHRcdFx0Zi5jbGFzc05hbWUgPSB0aGlzLmdldF9jb250YWluZXJfdWwoKVswXS5jbGFzc05hbWU7XG5cdFx0XHRcdHRoaXMuZWxlbWVudC5lbXB0eSgpLmFwcGVuZChmKTtcblx0XHRcdFx0Ly90aGlzLmdldF9jb250YWluZXJfdWwoKVswXS5hcHBlbmRDaGlsZChmKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX21vZGVsLmZvcmNlX2Z1bGxfcmVkcmF3ID0gZmFsc2U7XG5cdFx0XHR0aGlzLl9tb2RlbC5jaGFuZ2VkID0gW107XG5cdFx0XHQvKipcblx0XHRcdCAqIHRyaWdnZXJlZCBhZnRlciBub2RlcyBhcmUgcmVkcmF3blxuXHRcdFx0ICogQGV2ZW50XG5cdFx0XHQgKiBAbmFtZSByZWRyYXcuanN0cmVlXG5cdFx0XHQgKiBAcGFyYW0ge2FycmF5fSBub2RlcyB0aGUgcmVkcmF3biBub2Rlc1xuXHRcdFx0ICovXG5cdFx0XHR0aGlzLnRyaWdnZXIoJ3JlZHJhdycsIHsgXCJub2Rlc1wiIDogbm9kZXMgfSk7XG5cdFx0fSxcblx0XHQvKipcblx0XHQgKiByZWRyYXdzIGFsbCBub2RlcyB0aGF0IG5lZWQgdG8gYmUgcmVkcmF3biBvciBvcHRpb25hbGx5IC0gdGhlIHdob2xlIHRyZWVcblx0XHQgKiBAbmFtZSByZWRyYXcoW2Z1bGxdKVxuXHRcdCAqIEBwYXJhbSB7Qm9vbGVhbn0gZnVsbCBpZiBzZXQgdG8gYHRydWVgIGFsbCBub2RlcyBhcmUgcmVkcmF3bi5cblx0XHQgKi9cblx0XHRyZWRyYXcgOiBmdW5jdGlvbiAoZnVsbCkge1xuXHRcdFx0aWYoZnVsbCkge1xuXHRcdFx0XHR0aGlzLl9tb2RlbC5mb3JjZV9mdWxsX3JlZHJhdyA9IHRydWU7XG5cdFx0XHR9XG5cdFx0XHQvL2lmKHRoaXMuX21vZGVsLnJlZHJhd190aW1lb3V0KSB7XG5cdFx0XHQvL1x0Y2xlYXJUaW1lb3V0KHRoaXMuX21vZGVsLnJlZHJhd190aW1lb3V0KTtcblx0XHRcdC8vfVxuXHRcdFx0Ly90aGlzLl9tb2RlbC5yZWRyYXdfdGltZW91dCA9IHNldFRpbWVvdXQoJC5wcm94eSh0aGlzLl9yZWRyYXcsIHRoaXMpLDApO1xuXHRcdFx0dGhpcy5fcmVkcmF3KCk7XG5cdFx0fSxcblx0XHQvKipcblx0XHQgKiByZWRyYXdzIGEgc2luZ2xlIG5vZGUuIFVzZWQgaW50ZXJuYWxseS5cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqIEBuYW1lIHJlZHJhd19ub2RlKG5vZGUsIGRlZXAsIGlzX2NhbGxiYWNrKVxuXHRcdCAqIEBwYXJhbSB7bWl4ZWR9IG5vZGUgdGhlIG5vZGUgdG8gcmVkcmF3XG5cdFx0ICogQHBhcmFtIHtCb29sZWFufSBkZWVwIHNob3VsZCBjaGlsZCBub2RlcyBiZSByZWRyYXduIHRvb1xuXHRcdCAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNfY2FsbGJhY2sgaXMgdGhpcyBhIHJlY3Vyc2lvbiBjYWxsXG5cdFx0ICovXG5cdFx0cmVkcmF3X25vZGUgOiBmdW5jdGlvbiAobm9kZSwgZGVlcCwgaXNfY2FsbGJhY2spIHtcblx0XHRcdHZhciBvYmogPSB0aGlzLmdldF9ub2RlKG5vZGUpLFxuXHRcdFx0XHRwYXIgPSBmYWxzZSxcblx0XHRcdFx0aW5kID0gZmFsc2UsXG5cdFx0XHRcdG9sZCA9IGZhbHNlLFxuXHRcdFx0XHRpID0gZmFsc2UsXG5cdFx0XHRcdGogPSBmYWxzZSxcblx0XHRcdFx0ayA9IGZhbHNlLFxuXHRcdFx0XHRjID0gJycsXG5cdFx0XHRcdGQgPSBkb2N1bWVudCxcblx0XHRcdFx0bSA9IHRoaXMuX21vZGVsLmRhdGEsXG5cdFx0XHRcdGYgPSBmYWxzZSxcblx0XHRcdFx0cyA9IGZhbHNlLFxuXHRcdFx0XHR0bXAgPSBudWxsO1xuXHRcdFx0aWYoIW9iaikgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRcdGlmKG9iai5pZCA9PT0gJyMnKSB7ICByZXR1cm4gdGhpcy5yZWRyYXcodHJ1ZSk7IH1cblx0XHRcdGRlZXAgPSBkZWVwIHx8IG9iai5jaGlsZHJlbi5sZW5ndGggPT09IDA7XG5cdFx0XHRub2RlID0gIWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IgPyBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChvYmouaWQpIDogdGhpcy5lbGVtZW50WzBdLnF1ZXJ5U2VsZWN0b3IoJyMnICsgKFwiMDEyMzQ1Njc4OVwiLmluZGV4T2Yob2JqLmlkWzBdKSAhPT0gLTEgPyAnXFxcXDMnICsgb2JqLmlkWzBdICsgJyAnICsgb2JqLmlkLnN1YnN0cigxKS5yZXBsYWNlKCQuanN0cmVlLmlkcmVnZXgsJ1xcXFwkJicpIDogb2JqLmlkLnJlcGxhY2UoJC5qc3RyZWUuaWRyZWdleCwnXFxcXCQmJykpICk7IC8vLCB0aGlzLmVsZW1lbnQpO1xuXHRcdFx0aWYoIW5vZGUpIHtcblx0XHRcdFx0ZGVlcCA9IHRydWU7XG5cdFx0XHRcdC8vbm9kZSA9IGQuY3JlYXRlRWxlbWVudCgnTEknKTtcblx0XHRcdFx0aWYoIWlzX2NhbGxiYWNrKSB7XG5cdFx0XHRcdFx0cGFyID0gb2JqLnBhcmVudCAhPT0gJyMnID8gJCgnIycgKyBvYmoucGFyZW50LnJlcGxhY2UoJC5qc3RyZWUuaWRyZWdleCwnXFxcXCQmJyksIHRoaXMuZWxlbWVudClbMF0gOiBudWxsO1xuXHRcdFx0XHRcdGlmKHBhciAhPT0gbnVsbCAmJiAoIXBhciB8fCAhbVtvYmoucGFyZW50XS5zdGF0ZS5vcGVuZWQpKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGluZCA9ICQuaW5BcnJheShvYmouaWQsIHBhciA9PT0gbnVsbCA/IG1bJyMnXS5jaGlsZHJlbiA6IG1bb2JqLnBhcmVudF0uY2hpbGRyZW4pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0bm9kZSA9ICQobm9kZSk7XG5cdFx0XHRcdGlmKCFpc19jYWxsYmFjaykge1xuXHRcdFx0XHRcdHBhciA9IG5vZGUucGFyZW50KCkucGFyZW50KClbMF07XG5cdFx0XHRcdFx0aWYocGFyID09PSB0aGlzLmVsZW1lbnRbMF0pIHtcblx0XHRcdFx0XHRcdHBhciA9IG51bGw7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGluZCA9IG5vZGUuaW5kZXgoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBtW29iai5pZF0uZGF0YSA9IG5vZGUuZGF0YSgpOyAvLyB1c2Ugb25seSBub2RlJ3MgZGF0YSwgbm8gbmVlZCB0byB0b3VjaCBqcXVlcnkgc3RvcmFnZVxuXHRcdFx0XHRpZighZGVlcCAmJiBvYmouY2hpbGRyZW4ubGVuZ3RoICYmICFub2RlLmNoaWxkcmVuKCcuanN0cmVlLWNoaWxkcmVuJykubGVuZ3RoKSB7XG5cdFx0XHRcdFx0ZGVlcCA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYoIWRlZXApIHtcblx0XHRcdFx0XHRvbGQgPSBub2RlLmNoaWxkcmVuKCcuanN0cmVlLWNoaWxkcmVuJylbMF07XG5cdFx0XHRcdH1cblx0XHRcdFx0cyA9IG5vZGUuYXR0cignYXJpYS1zZWxlY3RlZCcpO1xuXHRcdFx0XHRmID0gbm9kZS5jaGlsZHJlbignLmpzdHJlZS1hbmNob3InKVswXSA9PT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcblx0XHRcdFx0bm9kZS5yZW1vdmUoKTtcblx0XHRcdFx0Ly9ub2RlID0gZC5jcmVhdGVFbGVtZW50KCdMSScpO1xuXHRcdFx0XHQvL25vZGUgPSBub2RlWzBdO1xuXHRcdFx0fVxuXHRcdFx0bm9kZSA9IF9ub2RlLmNsb25lTm9kZSh0cnVlKTtcblx0XHRcdC8vIG5vZGUgaXMgRE9NLCBkZWVwIGlzIGJvb2xlYW5cblxuXHRcdFx0YyA9ICdqc3RyZWUtbm9kZSAnO1xuXHRcdFx0Zm9yKGkgaW4gb2JqLmxpX2F0dHIpIHtcblx0XHRcdFx0aWYob2JqLmxpX2F0dHIuaGFzT3duUHJvcGVydHkoaSkpIHtcblx0XHRcdFx0XHRpZihpID09PSAnaWQnKSB7IGNvbnRpbnVlOyB9XG5cdFx0XHRcdFx0aWYoaSAhPT0gJ2NsYXNzJykge1xuXHRcdFx0XHRcdFx0bm9kZS5zZXRBdHRyaWJ1dGUoaSwgb2JqLmxpX2F0dHJbaV0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdGMgKz0gb2JqLmxpX2F0dHJbaV07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZihzICYmIHMgIT09IFwiZmFsc2VcIikge1xuXHRcdFx0XHRub2RlLnNldEF0dHJpYnV0ZSgnYXJpYS1zZWxlY3RlZCcsIHRydWUpO1xuXHRcdFx0fVxuXHRcdFx0aWYob2JqLnN0YXRlLmxvYWRlZCAmJiAhb2JqLmNoaWxkcmVuLmxlbmd0aCkge1xuXHRcdFx0XHRjICs9ICcganN0cmVlLWxlYWYnO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGMgKz0gb2JqLnN0YXRlLm9wZW5lZCAmJiBvYmouc3RhdGUubG9hZGVkID8gJyBqc3RyZWUtb3BlbicgOiAnIGpzdHJlZS1jbG9zZWQnO1xuXHRcdFx0XHRub2RlLnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsIChvYmouc3RhdGUub3BlbmVkICYmIG9iai5zdGF0ZS5sb2FkZWQpICk7XG5cdFx0XHR9XG5cdFx0XHRpZihvYmoucGFyZW50ICE9PSBudWxsICYmIG1bb2JqLnBhcmVudF0uY2hpbGRyZW5bbVtvYmoucGFyZW50XS5jaGlsZHJlbi5sZW5ndGggLSAxXSA9PT0gb2JqLmlkKSB7XG5cdFx0XHRcdGMgKz0gJyBqc3RyZWUtbGFzdCc7XG5cdFx0XHR9XG5cdFx0XHRub2RlLmlkID0gb2JqLmlkO1xuXHRcdFx0bm9kZS5jbGFzc05hbWUgPSBjO1xuXHRcdFx0YyA9ICggb2JqLnN0YXRlLnNlbGVjdGVkID8gJyBqc3RyZWUtY2xpY2tlZCcgOiAnJykgKyAoIG9iai5zdGF0ZS5kaXNhYmxlZCA/ICcganN0cmVlLWRpc2FibGVkJyA6ICcnKTtcblx0XHRcdGZvcihqIGluIG9iai5hX2F0dHIpIHtcblx0XHRcdFx0aWYob2JqLmFfYXR0ci5oYXNPd25Qcm9wZXJ0eShqKSkge1xuXHRcdFx0XHRcdGlmKGogPT09ICdocmVmJyAmJiBvYmouYV9hdHRyW2pdID09PSAnIycpIHsgY29udGludWU7IH1cblx0XHRcdFx0XHRpZihqICE9PSAnY2xhc3MnKSB7XG5cdFx0XHRcdFx0XHRub2RlLmNoaWxkTm9kZXNbMV0uc2V0QXR0cmlidXRlKGosIG9iai5hX2F0dHJbal0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdGMgKz0gJyAnICsgb2JqLmFfYXR0cltqXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmKGMubGVuZ3RoKSB7XG5cdFx0XHRcdG5vZGUuY2hpbGROb2Rlc1sxXS5jbGFzc05hbWUgPSAnanN0cmVlLWFuY2hvciAnICsgYztcblx0XHRcdH1cblx0XHRcdGlmKChvYmouaWNvbiAmJiBvYmouaWNvbiAhPT0gdHJ1ZSkgfHwgb2JqLmljb24gPT09IGZhbHNlKSB7XG5cdFx0XHRcdGlmKG9iai5pY29uID09PSBmYWxzZSkge1xuXHRcdFx0XHRcdG5vZGUuY2hpbGROb2Rlc1sxXS5jaGlsZE5vZGVzWzBdLmNsYXNzTmFtZSArPSAnIGpzdHJlZS10aGVtZWljb24taGlkZGVuJztcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIGlmKG9iai5pY29uLmluZGV4T2YoJy8nKSA9PT0gLTEgJiYgb2JqLmljb24uaW5kZXhPZignLicpID09PSAtMSkge1xuXHRcdFx0XHRcdG5vZGUuY2hpbGROb2Rlc1sxXS5jaGlsZE5vZGVzWzBdLmNsYXNzTmFtZSArPSAnICcgKyBvYmouaWNvbiArICcganN0cmVlLXRoZW1laWNvbi1jdXN0b20nO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdG5vZGUuY2hpbGROb2Rlc1sxXS5jaGlsZE5vZGVzWzBdLnN0eWxlLmJhY2tncm91bmRJbWFnZSA9ICd1cmwoJytvYmouaWNvbisnKSc7XG5cdFx0XHRcdFx0bm9kZS5jaGlsZE5vZGVzWzFdLmNoaWxkTm9kZXNbMF0uc3R5bGUuYmFja2dyb3VuZFBvc2l0aW9uID0gJ2NlbnRlciBjZW50ZXInO1xuXHRcdFx0XHRcdG5vZGUuY2hpbGROb2Rlc1sxXS5jaGlsZE5vZGVzWzBdLnN0eWxlLmJhY2tncm91bmRTaXplID0gJ2F1dG8nO1xuXHRcdFx0XHRcdG5vZGUuY2hpbGROb2Rlc1sxXS5jaGlsZE5vZGVzWzBdLmNsYXNzTmFtZSArPSAnIGpzdHJlZS10aGVtZWljb24tY3VzdG9tJztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZih0aGlzLnNldHRpbmdzLmNvcmUuZm9yY2VfdGV4dCkge1xuXHRcdFx0XHRub2RlLmNoaWxkTm9kZXNbMV0uYXBwZW5kQ2hpbGQoZC5jcmVhdGVUZXh0Tm9kZShvYmoudGV4dCkpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdG5vZGUuY2hpbGROb2Rlc1sxXS5pbm5lckhUTUwgKz0gb2JqLnRleHQ7XG5cdFx0XHR9XG5cblx0XHRcdGlmKGRlZXAgJiYgb2JqLmNoaWxkcmVuLmxlbmd0aCAmJiBvYmouc3RhdGUub3BlbmVkICYmIG9iai5zdGF0ZS5sb2FkZWQpIHtcblx0XHRcdFx0ayA9IGQuY3JlYXRlRWxlbWVudCgnVUwnKTtcblx0XHRcdFx0ay5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAnZ3JvdXAnKTtcblx0XHRcdFx0ay5jbGFzc05hbWUgPSAnanN0cmVlLWNoaWxkcmVuJztcblx0XHRcdFx0Zm9yKGkgPSAwLCBqID0gb2JqLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuXHRcdFx0XHRcdGsuYXBwZW5kQ2hpbGQodGhpcy5yZWRyYXdfbm9kZShvYmouY2hpbGRyZW5baV0sIGRlZXAsIHRydWUpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRub2RlLmFwcGVuZENoaWxkKGspO1xuXHRcdFx0fVxuXHRcdFx0aWYob2xkKSB7XG5cdFx0XHRcdG5vZGUuYXBwZW5kQ2hpbGQob2xkKTtcblx0XHRcdH1cblx0XHRcdGlmKCFpc19jYWxsYmFjaykge1xuXHRcdFx0XHQvLyBhcHBlbmQgYmFjayB1c2luZyBwYXIgLyBpbmRcblx0XHRcdFx0aWYoIXBhcikge1xuXHRcdFx0XHRcdHBhciA9IHRoaXMuZWxlbWVudFswXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRmb3IoaSA9IDAsIGogPSBwYXIuY2hpbGROb2Rlcy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcblx0XHRcdFx0XHRpZihwYXIuY2hpbGROb2Rlc1tpXSAmJiBwYXIuY2hpbGROb2Rlc1tpXS5jbGFzc05hbWUgJiYgcGFyLmNoaWxkTm9kZXNbaV0uY2xhc3NOYW1lLmluZGV4T2YoJ2pzdHJlZS1jaGlsZHJlbicpICE9PSAtMSkge1xuXHRcdFx0XHRcdFx0dG1wID0gcGFyLmNoaWxkTm9kZXNbaV07XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYoIXRtcCkge1xuXHRcdFx0XHRcdHRtcCA9IGQuY3JlYXRlRWxlbWVudCgnVUwnKTtcblx0XHRcdFx0XHR0bXAuc2V0QXR0cmlidXRlKCdyb2xlJywgJ2dyb3VwJyk7XG5cdFx0XHRcdFx0dG1wLmNsYXNzTmFtZSA9ICdqc3RyZWUtY2hpbGRyZW4nO1xuXHRcdFx0XHRcdHBhci5hcHBlbmRDaGlsZCh0bXApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHBhciA9IHRtcDtcblxuXHRcdFx0XHRpZihpbmQgPCBwYXIuY2hpbGROb2Rlcy5sZW5ndGgpIHtcblx0XHRcdFx0XHRwYXIuaW5zZXJ0QmVmb3JlKG5vZGUsIHBhci5jaGlsZE5vZGVzW2luZF0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdHBhci5hcHBlbmRDaGlsZChub2RlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZihmKSB7XG5cdFx0XHRcdFx0bm9kZS5jaGlsZE5vZGVzWzFdLmZvY3VzKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmKG9iai5zdGF0ZS5vcGVuZWQgJiYgIW9iai5zdGF0ZS5sb2FkZWQpIHtcblx0XHRcdFx0b2JqLnN0YXRlLm9wZW5lZCA9IGZhbHNlO1xuXHRcdFx0XHRzZXRUaW1lb3V0KCQucHJveHkoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdHRoaXMub3Blbl9ub2RlKG9iai5pZCwgZmFsc2UsIDApO1xuXHRcdFx0XHR9LCB0aGlzKSwgMCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbm9kZTtcblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIG9wZW5zIGEgbm9kZSwgcmV2YWxpbmcgaXRzIGNoaWxkcmVuLiBJZiB0aGUgbm9kZSBpcyBub3QgbG9hZGVkIGl0IHdpbGwgYmUgbG9hZGVkIGFuZCBvcGVuZWQgb25jZSByZWFkeS5cblx0XHQgKiBAbmFtZSBvcGVuX25vZGUob2JqIFssIGNhbGxiYWNrLCBhbmltYXRpb25dKVxuXHRcdCAqIEBwYXJhbSB7bWl4ZWR9IG9iaiB0aGUgbm9kZSB0byBvcGVuXG5cdFx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgYSBmdW5jdGlvbiB0byBleGVjdXRlIG9uY2UgdGhlIG5vZGUgaXMgb3BlbmVkXG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IGFuaW1hdGlvbiB0aGUgYW5pbWF0aW9uIGR1cmF0aW9uIGluIG1pbGxpc2Vjb25kcyB3aGVuIG9wZW5pbmcgdGhlIG5vZGUgKG92ZXJyaWRlcyB0aGUgYGNvcmUuYW5pbWF0aW9uYCBzZXR0aW5nKS4gVXNlIGBmYWxzZWAgZm9yIG5vIGFuaW1hdGlvbi5cblx0XHQgKiBAdHJpZ2dlciBvcGVuX25vZGUuanN0cmVlLCBhZnRlcl9vcGVuLmpzdHJlZSwgYmVmb3JlX29wZW4uanN0cmVlXG5cdFx0ICovXG5cdFx0b3Blbl9ub2RlIDogZnVuY3Rpb24gKG9iaiwgY2FsbGJhY2ssIGFuaW1hdGlvbikge1xuXHRcdFx0dmFyIHQxLCB0MiwgZCwgdDtcblx0XHRcdGlmKCQuaXNBcnJheShvYmopKSB7XG5cdFx0XHRcdG9iaiA9IG9iai5zbGljZSgpO1xuXHRcdFx0XHRmb3IodDEgPSAwLCB0MiA9IG9iai5sZW5ndGg7IHQxIDwgdDI7IHQxKyspIHtcblx0XHRcdFx0XHR0aGlzLm9wZW5fbm9kZShvYmpbdDFdLCBjYWxsYmFjaywgYW5pbWF0aW9uKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdG9iaiA9IHRoaXMuZ2V0X25vZGUob2JqKTtcblx0XHRcdGlmKCFvYmogfHwgb2JqLmlkID09PSAnIycpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0YW5pbWF0aW9uID0gYW5pbWF0aW9uID09PSB1bmRlZmluZWQgPyB0aGlzLnNldHRpbmdzLmNvcmUuYW5pbWF0aW9uIDogYW5pbWF0aW9uO1xuXHRcdFx0aWYoIXRoaXMuaXNfY2xvc2VkKG9iaikpIHtcblx0XHRcdFx0aWYoY2FsbGJhY2spIHtcblx0XHRcdFx0XHRjYWxsYmFjay5jYWxsKHRoaXMsIG9iaiwgZmFsc2UpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdGlmKCF0aGlzLmlzX2xvYWRlZChvYmopKSB7XG5cdFx0XHRcdGlmKHRoaXMuaXNfbG9hZGluZyhvYmopKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHNldFRpbWVvdXQoJC5wcm94eShmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0XHR0aGlzLm9wZW5fbm9kZShvYmosIGNhbGxiYWNrLCBhbmltYXRpb24pO1xuXHRcdFx0XHRcdH0sIHRoaXMpLCA1MDApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMubG9hZF9ub2RlKG9iaiwgZnVuY3Rpb24gKG8sIG9rKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG9rID8gdGhpcy5vcGVuX25vZGUobywgY2FsbGJhY2ssIGFuaW1hdGlvbikgOiAoY2FsbGJhY2sgPyBjYWxsYmFjay5jYWxsKHRoaXMsIG8sIGZhbHNlKSA6IGZhbHNlKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0ZCA9IHRoaXMuZ2V0X25vZGUob2JqLCB0cnVlKTtcblx0XHRcdFx0dCA9IHRoaXM7XG5cdFx0XHRcdGlmKGQubGVuZ3RoKSB7XG5cdFx0XHRcdFx0aWYob2JqLmNoaWxkcmVuLmxlbmd0aCAmJiAhdGhpcy5fZmlyc3RDaGlsZChkLmNoaWxkcmVuKCcuanN0cmVlLWNoaWxkcmVuJylbMF0pKSB7XG5cdFx0XHRcdFx0XHRvYmouc3RhdGUub3BlbmVkID0gdHJ1ZTtcblx0XHRcdFx0XHRcdHRoaXMucmVkcmF3X25vZGUob2JqLCB0cnVlKTtcblx0XHRcdFx0XHRcdGQgPSB0aGlzLmdldF9ub2RlKG9iaiwgdHJ1ZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmKCFhbmltYXRpb24pIHtcblx0XHRcdFx0XHRcdHRoaXMudHJpZ2dlcignYmVmb3JlX29wZW4nLCB7IFwibm9kZVwiIDogb2JqIH0pO1xuXHRcdFx0XHRcdFx0ZFswXS5jbGFzc05hbWUgPSBkWzBdLmNsYXNzTmFtZS5yZXBsYWNlKCdqc3RyZWUtY2xvc2VkJywgJ2pzdHJlZS1vcGVuJyk7XG5cdFx0XHRcdFx0XHRkWzBdLnNldEF0dHJpYnV0ZShcImFyaWEtZXhwYW5kZWRcIiwgdHJ1ZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0dGhpcy50cmlnZ2VyKCdiZWZvcmVfb3BlbicsIHsgXCJub2RlXCIgOiBvYmogfSk7XG5cdFx0XHRcdFx0XHRkXG5cdFx0XHRcdFx0XHRcdC5jaGlsZHJlbihcIi5qc3RyZWUtY2hpbGRyZW5cIikuY3NzKFwiZGlzcGxheVwiLFwibm9uZVwiKS5lbmQoKVxuXHRcdFx0XHRcdFx0XHQucmVtb3ZlQ2xhc3MoXCJqc3RyZWUtY2xvc2VkXCIpLmFkZENsYXNzKFwianN0cmVlLW9wZW5cIikuYXR0cihcImFyaWEtZXhwYW5kZWRcIiwgdHJ1ZSlcblx0XHRcdFx0XHRcdFx0LmNoaWxkcmVuKFwiLmpzdHJlZS1jaGlsZHJlblwiKS5zdG9wKHRydWUsIHRydWUpXG5cdFx0XHRcdFx0XHRcdFx0LnNsaWRlRG93bihhbmltYXRpb24sIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHRoaXMuc3R5bGUuZGlzcGxheSA9IFwiXCI7XG5cdFx0XHRcdFx0XHRcdFx0XHR0LnRyaWdnZXIoXCJhZnRlcl9vcGVuXCIsIHsgXCJub2RlXCIgOiBvYmogfSk7XG5cdFx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdG9iai5zdGF0ZS5vcGVuZWQgPSB0cnVlO1xuXHRcdFx0XHRpZihjYWxsYmFjaykge1xuXHRcdFx0XHRcdGNhbGxiYWNrLmNhbGwodGhpcywgb2JqLCB0cnVlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZighZC5sZW5ndGgpIHtcblx0XHRcdFx0XHQvKipcblx0XHRcdFx0XHQgKiB0cmlnZ2VyZWQgd2hlbiBhIG5vZGUgaXMgYWJvdXQgdG8gYmUgb3BlbmVkIChpZiB0aGUgbm9kZSBpcyBzdXBwb3NlZCB0byBiZSBpbiB0aGUgRE9NLCBpdCB3aWxsIGJlLCBidXQgaXQgd29uJ3QgYmUgdmlzaWJsZSB5ZXQpXG5cdFx0XHRcdFx0ICogQGV2ZW50XG5cdFx0XHRcdFx0ICogQG5hbWUgYmVmb3JlX29wZW4uanN0cmVlXG5cdFx0XHRcdFx0ICogQHBhcmFtIHtPYmplY3R9IG5vZGUgdGhlIG9wZW5lZCBub2RlXG5cdFx0XHRcdFx0ICovXG5cdFx0XHRcdFx0dGhpcy50cmlnZ2VyKCdiZWZvcmVfb3BlbicsIHsgXCJub2RlXCIgOiBvYmogfSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0LyoqXG5cdFx0XHRcdCAqIHRyaWdnZXJlZCB3aGVuIGEgbm9kZSBpcyBvcGVuZWQgKGlmIHRoZXJlIGlzIGFuIGFuaW1hdGlvbiBpdCB3aWxsIG5vdCBiZSBjb21wbGV0ZWQgeWV0KVxuXHRcdFx0XHQgKiBAZXZlbnRcblx0XHRcdFx0ICogQG5hbWUgb3Blbl9ub2RlLmpzdHJlZVxuXHRcdFx0XHQgKiBAcGFyYW0ge09iamVjdH0gbm9kZSB0aGUgb3BlbmVkIG5vZGVcblx0XHRcdFx0ICovXG5cdFx0XHRcdHRoaXMudHJpZ2dlcignb3Blbl9ub2RlJywgeyBcIm5vZGVcIiA6IG9iaiB9KTtcblx0XHRcdFx0aWYoIWFuaW1hdGlvbiB8fCAhZC5sZW5ndGgpIHtcblx0XHRcdFx0XHQvKipcblx0XHRcdFx0XHQgKiB0cmlnZ2VyZWQgd2hlbiBhIG5vZGUgaXMgb3BlbmVkIGFuZCB0aGUgYW5pbWF0aW9uIGlzIGNvbXBsZXRlXG5cdFx0XHRcdFx0ICogQGV2ZW50XG5cdFx0XHRcdFx0ICogQG5hbWUgYWZ0ZXJfb3Blbi5qc3RyZWVcblx0XHRcdFx0XHQgKiBAcGFyYW0ge09iamVjdH0gbm9kZSB0aGUgb3BlbmVkIG5vZGVcblx0XHRcdFx0XHQgKi9cblx0XHRcdFx0XHR0aGlzLnRyaWdnZXIoXCJhZnRlcl9vcGVuXCIsIHsgXCJub2RlXCIgOiBvYmogfSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIG9wZW5zIGV2ZXJ5IHBhcmVudCBvZiBhIG5vZGUgKG5vZGUgc2hvdWxkIGJlIGxvYWRlZClcblx0XHQgKiBAbmFtZSBfb3Blbl90byhvYmopXG5cdFx0ICogQHBhcmFtIHttaXhlZH0gb2JqIHRoZSBub2RlIHRvIHJldmVhbFxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0X29wZW5fdG8gOiBmdW5jdGlvbiAob2JqKSB7XG5cdFx0XHRvYmogPSB0aGlzLmdldF9ub2RlKG9iaik7XG5cdFx0XHRpZighb2JqIHx8IG9iai5pZCA9PT0gJyMnKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdHZhciBpLCBqLCBwID0gb2JqLnBhcmVudHM7XG5cdFx0XHRmb3IoaSA9IDAsIGogPSBwLmxlbmd0aDsgaSA8IGo7IGkrPTEpIHtcblx0XHRcdFx0aWYoaSAhPT0gJyMnKSB7XG5cdFx0XHRcdFx0dGhpcy5vcGVuX25vZGUocFtpXSwgZmFsc2UsIDApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gJCgnIycgKyBvYmouaWQucmVwbGFjZSgkLmpzdHJlZS5pZHJlZ2V4LCdcXFxcJCYnKSwgdGhpcy5lbGVtZW50KTtcblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIGNsb3NlcyBhIG5vZGUsIGhpZGluZyBpdHMgY2hpbGRyZW5cblx0XHQgKiBAbmFtZSBjbG9zZV9ub2RlKG9iaiBbLCBhbmltYXRpb25dKVxuXHRcdCAqIEBwYXJhbSB7bWl4ZWR9IG9iaiB0aGUgbm9kZSB0byBjbG9zZVxuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSBhbmltYXRpb24gdGhlIGFuaW1hdGlvbiBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZHMgd2hlbiBjbG9zaW5nIHRoZSBub2RlIChvdmVycmlkZXMgdGhlIGBjb3JlLmFuaW1hdGlvbmAgc2V0dGluZykuIFVzZSBgZmFsc2VgIGZvciBubyBhbmltYXRpb24uXG5cdFx0ICogQHRyaWdnZXIgY2xvc2Vfbm9kZS5qc3RyZWUsIGFmdGVyX2Nsb3NlLmpzdHJlZVxuXHRcdCAqL1xuXHRcdGNsb3NlX25vZGUgOiBmdW5jdGlvbiAob2JqLCBhbmltYXRpb24pIHtcblx0XHRcdHZhciB0MSwgdDIsIHQsIGQ7XG5cdFx0XHRpZigkLmlzQXJyYXkob2JqKSkge1xuXHRcdFx0XHRvYmogPSBvYmouc2xpY2UoKTtcblx0XHRcdFx0Zm9yKHQxID0gMCwgdDIgPSBvYmoubGVuZ3RoOyB0MSA8IHQyOyB0MSsrKSB7XG5cdFx0XHRcdFx0dGhpcy5jbG9zZV9ub2RlKG9ialt0MV0sIGFuaW1hdGlvbik7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0XHRvYmogPSB0aGlzLmdldF9ub2RlKG9iaik7XG5cdFx0XHRpZighb2JqIHx8IG9iai5pZCA9PT0gJyMnKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdGlmKHRoaXMuaXNfY2xvc2VkKG9iaikpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0YW5pbWF0aW9uID0gYW5pbWF0aW9uID09PSB1bmRlZmluZWQgPyB0aGlzLnNldHRpbmdzLmNvcmUuYW5pbWF0aW9uIDogYW5pbWF0aW9uO1xuXHRcdFx0dCA9IHRoaXM7XG5cdFx0XHRkID0gdGhpcy5nZXRfbm9kZShvYmosIHRydWUpO1xuXHRcdFx0aWYoZC5sZW5ndGgpIHtcblx0XHRcdFx0aWYoIWFuaW1hdGlvbikge1xuXHRcdFx0XHRcdGRbMF0uY2xhc3NOYW1lID0gZFswXS5jbGFzc05hbWUucmVwbGFjZSgnanN0cmVlLW9wZW4nLCAnanN0cmVlLWNsb3NlZCcpO1xuXHRcdFx0XHRcdGQuYXR0cihcImFyaWEtZXhwYW5kZWRcIiwgZmFsc2UpLmNoaWxkcmVuKCcuanN0cmVlLWNoaWxkcmVuJykucmVtb3ZlKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0ZFxuXHRcdFx0XHRcdFx0LmNoaWxkcmVuKFwiLmpzdHJlZS1jaGlsZHJlblwiKS5hdHRyKFwic3R5bGVcIixcImRpc3BsYXk6YmxvY2sgIWltcG9ydGFudFwiKS5lbmQoKVxuXHRcdFx0XHRcdFx0LnJlbW92ZUNsYXNzKFwianN0cmVlLW9wZW5cIikuYWRkQ2xhc3MoXCJqc3RyZWUtY2xvc2VkXCIpLmF0dHIoXCJhcmlhLWV4cGFuZGVkXCIsIGZhbHNlKVxuXHRcdFx0XHRcdFx0LmNoaWxkcmVuKFwiLmpzdHJlZS1jaGlsZHJlblwiKS5zdG9wKHRydWUsIHRydWUpLnNsaWRlVXAoYW5pbWF0aW9uLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMuc3R5bGUuZGlzcGxheSA9IFwiXCI7XG5cdFx0XHRcdFx0XHRcdGQuY2hpbGRyZW4oJy5qc3RyZWUtY2hpbGRyZW4nKS5yZW1vdmUoKTtcblx0XHRcdFx0XHRcdFx0dC50cmlnZ2VyKFwiYWZ0ZXJfY2xvc2VcIiwgeyBcIm5vZGVcIiA6IG9iaiB9KTtcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRvYmouc3RhdGUub3BlbmVkID0gZmFsc2U7XG5cdFx0XHQvKipcblx0XHRcdCAqIHRyaWdnZXJlZCB3aGVuIGEgbm9kZSBpcyBjbG9zZWQgKGlmIHRoZXJlIGlzIGFuIGFuaW1hdGlvbiBpdCB3aWxsIG5vdCBiZSBjb21wbGV0ZSB5ZXQpXG5cdFx0XHQgKiBAZXZlbnRcblx0XHRcdCAqIEBuYW1lIGNsb3NlX25vZGUuanN0cmVlXG5cdFx0XHQgKiBAcGFyYW0ge09iamVjdH0gbm9kZSB0aGUgY2xvc2VkIG5vZGVcblx0XHRcdCAqL1xuXHRcdFx0dGhpcy50cmlnZ2VyKCdjbG9zZV9ub2RlJyx7IFwibm9kZVwiIDogb2JqIH0pO1xuXHRcdFx0aWYoIWFuaW1hdGlvbiB8fCAhZC5sZW5ndGgpIHtcblx0XHRcdFx0LyoqXG5cdFx0XHRcdCAqIHRyaWdnZXJlZCB3aGVuIGEgbm9kZSBpcyBjbG9zZWQgYW5kIHRoZSBhbmltYXRpb24gaXMgY29tcGxldGVcblx0XHRcdFx0ICogQGV2ZW50XG5cdFx0XHRcdCAqIEBuYW1lIGFmdGVyX2Nsb3NlLmpzdHJlZVxuXHRcdFx0XHQgKiBAcGFyYW0ge09iamVjdH0gbm9kZSB0aGUgY2xvc2VkIG5vZGVcblx0XHRcdFx0ICovXG5cdFx0XHRcdHRoaXMudHJpZ2dlcihcImFmdGVyX2Nsb3NlXCIsIHsgXCJub2RlXCIgOiBvYmogfSk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHQvKipcblx0XHQgKiB0b2dnbGVzIGEgbm9kZSAtIGNsb3NpbmcgaXQgaWYgaXQgaXMgb3Blbiwgb3BlbmluZyBpdCBpZiBpdCBpcyBjbG9zZWRcblx0XHQgKiBAbmFtZSB0b2dnbGVfbm9kZShvYmopXG5cdFx0ICogQHBhcmFtIHttaXhlZH0gb2JqIHRoZSBub2RlIHRvIHRvZ2dsZVxuXHRcdCAqL1xuXHRcdHRvZ2dsZV9ub2RlIDogZnVuY3Rpb24gKG9iaikge1xuXHRcdFx0dmFyIHQxLCB0Mjtcblx0XHRcdGlmKCQuaXNBcnJheShvYmopKSB7XG5cdFx0XHRcdG9iaiA9IG9iai5zbGljZSgpO1xuXHRcdFx0XHRmb3IodDEgPSAwLCB0MiA9IG9iai5sZW5ndGg7IHQxIDwgdDI7IHQxKyspIHtcblx0XHRcdFx0XHR0aGlzLnRvZ2dsZV9ub2RlKG9ialt0MV0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0aWYodGhpcy5pc19jbG9zZWQob2JqKSkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5vcGVuX25vZGUob2JqKTtcblx0XHRcdH1cblx0XHRcdGlmKHRoaXMuaXNfb3BlbihvYmopKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmNsb3NlX25vZGUob2JqKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIG9wZW5zIGFsbCBub2RlcyB3aXRoaW4gYSBub2RlIChvciB0aGUgdHJlZSksIHJldmFsaW5nIHRoZWlyIGNoaWxkcmVuLiBJZiB0aGUgbm9kZSBpcyBub3QgbG9hZGVkIGl0IHdpbGwgYmUgbG9hZGVkIGFuZCBvcGVuZWQgb25jZSByZWFkeS5cblx0XHQgKiBAbmFtZSBvcGVuX2FsbChbb2JqLCBhbmltYXRpb24sIG9yaWdpbmFsX29ial0pXG5cdFx0ICogQHBhcmFtIHttaXhlZH0gb2JqIHRoZSBub2RlIHRvIG9wZW4gcmVjdXJzaXZlbHksIG9taXQgdG8gb3BlbiBhbGwgbm9kZXMgaW4gdGhlIHRyZWVcblx0XHQgKiBAcGFyYW0ge051bWJlcn0gYW5pbWF0aW9uIHRoZSBhbmltYXRpb24gZHVyYXRpb24gaW4gbWlsbGlzZWNvbmRzIHdoZW4gb3BlbmluZyB0aGUgbm9kZXMsIHRoZSBkZWZhdWx0IGlzIG5vIGFuaW1hdGlvblxuXHRcdCAqIEBwYXJhbSB7alF1ZXJ5fSByZWZlcmVuY2UgdG8gdGhlIG5vZGUgdGhhdCBzdGFydGVkIHRoZSBwcm9jZXNzIChpbnRlcm5hbCB1c2UpXG5cdFx0ICogQHRyaWdnZXIgb3Blbl9hbGwuanN0cmVlXG5cdFx0ICovXG5cdFx0b3Blbl9hbGwgOiBmdW5jdGlvbiAob2JqLCBhbmltYXRpb24sIG9yaWdpbmFsX29iaikge1xuXHRcdFx0aWYoIW9iaikgeyBvYmogPSAnIyc7IH1cblx0XHRcdG9iaiA9IHRoaXMuZ2V0X25vZGUob2JqKTtcblx0XHRcdGlmKCFvYmopIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0XHR2YXIgZG9tID0gb2JqLmlkID09PSAnIycgPyB0aGlzLmdldF9jb250YWluZXJfdWwoKSA6IHRoaXMuZ2V0X25vZGUob2JqLCB0cnVlKSwgaSwgaiwgX3RoaXM7XG5cdFx0XHRpZighZG9tLmxlbmd0aCkge1xuXHRcdFx0XHRmb3IoaSA9IDAsIGogPSBvYmouY2hpbGRyZW5fZC5sZW5ndGg7IGkgPCBqOyBpKyspIHtcblx0XHRcdFx0XHRpZih0aGlzLmlzX2Nsb3NlZCh0aGlzLl9tb2RlbC5kYXRhW29iai5jaGlsZHJlbl9kW2ldXSkpIHtcblx0XHRcdFx0XHRcdHRoaXMuX21vZGVsLmRhdGFbb2JqLmNoaWxkcmVuX2RbaV1dLnN0YXRlLm9wZW5lZCA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzLnRyaWdnZXIoJ29wZW5fYWxsJywgeyBcIm5vZGVcIiA6IG9iaiB9KTtcblx0XHRcdH1cblx0XHRcdG9yaWdpbmFsX29iaiA9IG9yaWdpbmFsX29iaiB8fCBkb207XG5cdFx0XHRfdGhpcyA9IHRoaXM7XG5cdFx0XHRkb20gPSB0aGlzLmlzX2Nsb3NlZChvYmopID8gZG9tLmZpbmQoJy5qc3RyZWUtY2xvc2VkJykuYWRkQmFjaygpIDogZG9tLmZpbmQoJy5qc3RyZWUtY2xvc2VkJyk7XG5cdFx0XHRkb20uZWFjaChmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdF90aGlzLm9wZW5fbm9kZShcblx0XHRcdFx0XHR0aGlzLFxuXHRcdFx0XHRcdGZ1bmN0aW9uKG5vZGUsIHN0YXR1cykgeyBpZihzdGF0dXMgJiYgdGhpcy5pc19wYXJlbnQobm9kZSkpIHsgdGhpcy5vcGVuX2FsbChub2RlLCBhbmltYXRpb24sIG9yaWdpbmFsX29iaik7IH0gfSxcblx0XHRcdFx0XHRhbmltYXRpb24gfHwgMFxuXHRcdFx0XHQpO1xuXHRcdFx0fSk7XG5cdFx0XHRpZihvcmlnaW5hbF9vYmouZmluZCgnLmpzdHJlZS1jbG9zZWQnKS5sZW5ndGggPT09IDApIHtcblx0XHRcdFx0LyoqXG5cdFx0XHRcdCAqIHRyaWdnZXJlZCB3aGVuIGFuIGBvcGVuX2FsbGAgY2FsbCBjb21wbGV0ZXNcblx0XHRcdFx0ICogQGV2ZW50XG5cdFx0XHRcdCAqIEBuYW1lIG9wZW5fYWxsLmpzdHJlZVxuXHRcdFx0XHQgKiBAcGFyYW0ge09iamVjdH0gbm9kZSB0aGUgb3BlbmVkIG5vZGVcblx0XHRcdFx0ICovXG5cdFx0XHRcdHRoaXMudHJpZ2dlcignb3Blbl9hbGwnLCB7IFwibm9kZVwiIDogdGhpcy5nZXRfbm9kZShvcmlnaW5hbF9vYmopIH0pO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogY2xvc2VzIGFsbCBub2RlcyB3aXRoaW4gYSBub2RlIChvciB0aGUgdHJlZSksIHJldmFsaW5nIHRoZWlyIGNoaWxkcmVuXG5cdFx0ICogQG5hbWUgY2xvc2VfYWxsKFtvYmosIGFuaW1hdGlvbl0pXG5cdFx0ICogQHBhcmFtIHttaXhlZH0gb2JqIHRoZSBub2RlIHRvIGNsb3NlIHJlY3Vyc2l2ZWx5LCBvbWl0IHRvIGNsb3NlIGFsbCBub2RlcyBpbiB0aGUgdHJlZVxuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSBhbmltYXRpb24gdGhlIGFuaW1hdGlvbiBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZHMgd2hlbiBjbG9zaW5nIHRoZSBub2RlcywgdGhlIGRlZmF1bHQgaXMgbm8gYW5pbWF0aW9uXG5cdFx0ICogQHRyaWdnZXIgY2xvc2VfYWxsLmpzdHJlZVxuXHRcdCAqL1xuXHRcdGNsb3NlX2FsbCA6IGZ1bmN0aW9uIChvYmosIGFuaW1hdGlvbikge1xuXHRcdFx0aWYoIW9iaikgeyBvYmogPSAnIyc7IH1cblx0XHRcdG9iaiA9IHRoaXMuZ2V0X25vZGUob2JqKTtcblx0XHRcdGlmKCFvYmopIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0XHR2YXIgZG9tID0gb2JqLmlkID09PSAnIycgPyB0aGlzLmdldF9jb250YWluZXJfdWwoKSA6IHRoaXMuZ2V0X25vZGUob2JqLCB0cnVlKSxcblx0XHRcdFx0X3RoaXMgPSB0aGlzLCBpLCBqO1xuXHRcdFx0aWYoIWRvbS5sZW5ndGgpIHtcblx0XHRcdFx0Zm9yKGkgPSAwLCBqID0gb2JqLmNoaWxkcmVuX2QubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG5cdFx0XHRcdFx0dGhpcy5fbW9kZWwuZGF0YVtvYmouY2hpbGRyZW5fZFtpXV0uc3RhdGUub3BlbmVkID0gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXMudHJpZ2dlcignY2xvc2VfYWxsJywgeyBcIm5vZGVcIiA6IG9iaiB9KTtcblx0XHRcdH1cblx0XHRcdGRvbSA9IHRoaXMuaXNfb3BlbihvYmopID8gZG9tLmZpbmQoJy5qc3RyZWUtb3BlbicpLmFkZEJhY2soKSA6IGRvbS5maW5kKCcuanN0cmVlLW9wZW4nKTtcblx0XHRcdCQoZG9tLmdldCgpLnJldmVyc2UoKSkuZWFjaChmdW5jdGlvbiAoKSB7IF90aGlzLmNsb3NlX25vZGUodGhpcywgYW5pbWF0aW9uIHx8IDApOyB9KTtcblx0XHRcdC8qKlxuXHRcdFx0ICogdHJpZ2dlcmVkIHdoZW4gYW4gYGNsb3NlX2FsbGAgY2FsbCBjb21wbGV0ZXNcblx0XHRcdCAqIEBldmVudFxuXHRcdFx0ICogQG5hbWUgY2xvc2VfYWxsLmpzdHJlZVxuXHRcdFx0ICogQHBhcmFtIHtPYmplY3R9IG5vZGUgdGhlIGNsb3NlZCBub2RlXG5cdFx0XHQgKi9cblx0XHRcdHRoaXMudHJpZ2dlcignY2xvc2VfYWxsJywgeyBcIm5vZGVcIiA6IG9iaiB9KTtcblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIGNoZWNrcyBpZiBhIG5vZGUgaXMgZGlzYWJsZWQgKG5vdCBzZWxlY3RhYmxlKVxuXHRcdCAqIEBuYW1lIGlzX2Rpc2FibGVkKG9iailcblx0XHQgKiBAcGFyYW0gIHttaXhlZH0gb2JqXG5cdFx0ICogQHJldHVybiB7Qm9vbGVhbn1cblx0XHQgKi9cblx0XHRpc19kaXNhYmxlZCA6IGZ1bmN0aW9uIChvYmopIHtcblx0XHRcdG9iaiA9IHRoaXMuZ2V0X25vZGUob2JqKTtcblx0XHRcdHJldHVybiBvYmogJiYgb2JqLnN0YXRlICYmIG9iai5zdGF0ZS5kaXNhYmxlZDtcblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIGVuYWJsZXMgYSBub2RlIC0gc28gdGhhdCBpdCBjYW4gYmUgc2VsZWN0ZWRcblx0XHQgKiBAbmFtZSBlbmFibGVfbm9kZShvYmopXG5cdFx0ICogQHBhcmFtIHttaXhlZH0gb2JqIHRoZSBub2RlIHRvIGVuYWJsZVxuXHRcdCAqIEB0cmlnZ2VyIGVuYWJsZV9ub2RlLmpzdHJlZVxuXHRcdCAqL1xuXHRcdGVuYWJsZV9ub2RlIDogZnVuY3Rpb24gKG9iaikge1xuXHRcdFx0dmFyIHQxLCB0Mjtcblx0XHRcdGlmKCQuaXNBcnJheShvYmopKSB7XG5cdFx0XHRcdG9iaiA9IG9iai5zbGljZSgpO1xuXHRcdFx0XHRmb3IodDEgPSAwLCB0MiA9IG9iai5sZW5ndGg7IHQxIDwgdDI7IHQxKyspIHtcblx0XHRcdFx0XHR0aGlzLmVuYWJsZV9ub2RlKG9ialt0MV0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0b2JqID0gdGhpcy5nZXRfbm9kZShvYmopO1xuXHRcdFx0aWYoIW9iaiB8fCBvYmouaWQgPT09ICcjJykge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHRvYmouc3RhdGUuZGlzYWJsZWQgPSBmYWxzZTtcblx0XHRcdHRoaXMuZ2V0X25vZGUob2JqLHRydWUpLmNoaWxkcmVuKCcuanN0cmVlLWFuY2hvcicpLnJlbW92ZUNsYXNzKCdqc3RyZWUtZGlzYWJsZWQnKTtcblx0XHRcdC8qKlxuXHRcdFx0ICogdHJpZ2dlcmVkIHdoZW4gYW4gbm9kZSBpcyBlbmFibGVkXG5cdFx0XHQgKiBAZXZlbnRcblx0XHRcdCAqIEBuYW1lIGVuYWJsZV9ub2RlLmpzdHJlZVxuXHRcdFx0ICogQHBhcmFtIHtPYmplY3R9IG5vZGUgdGhlIGVuYWJsZWQgbm9kZVxuXHRcdFx0ICovXG5cdFx0XHR0aGlzLnRyaWdnZXIoJ2VuYWJsZV9ub2RlJywgeyAnbm9kZScgOiBvYmogfSk7XG5cdFx0fSxcblx0XHQvKipcblx0XHQgKiBkaXNhYmxlcyBhIG5vZGUgLSBzbyB0aGF0IGl0IGNhbiBub3QgYmUgc2VsZWN0ZWRcblx0XHQgKiBAbmFtZSBkaXNhYmxlX25vZGUob2JqKVxuXHRcdCAqIEBwYXJhbSB7bWl4ZWR9IG9iaiB0aGUgbm9kZSB0byBkaXNhYmxlXG5cdFx0ICogQHRyaWdnZXIgZGlzYWJsZV9ub2RlLmpzdHJlZVxuXHRcdCAqL1xuXHRcdGRpc2FibGVfbm9kZSA6IGZ1bmN0aW9uIChvYmopIHtcblx0XHRcdHZhciB0MSwgdDI7XG5cdFx0XHRpZigkLmlzQXJyYXkob2JqKSkge1xuXHRcdFx0XHRvYmogPSBvYmouc2xpY2UoKTtcblx0XHRcdFx0Zm9yKHQxID0gMCwgdDIgPSBvYmoubGVuZ3RoOyB0MSA8IHQyOyB0MSsrKSB7XG5cdFx0XHRcdFx0dGhpcy5kaXNhYmxlX25vZGUob2JqW3QxXSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0XHRvYmogPSB0aGlzLmdldF9ub2RlKG9iaik7XG5cdFx0XHRpZighb2JqIHx8IG9iai5pZCA9PT0gJyMnKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdG9iai5zdGF0ZS5kaXNhYmxlZCA9IHRydWU7XG5cdFx0XHR0aGlzLmdldF9ub2RlKG9iaix0cnVlKS5jaGlsZHJlbignLmpzdHJlZS1hbmNob3InKS5hZGRDbGFzcygnanN0cmVlLWRpc2FibGVkJyk7XG5cdFx0XHQvKipcblx0XHRcdCAqIHRyaWdnZXJlZCB3aGVuIGFuIG5vZGUgaXMgZGlzYWJsZWRcblx0XHRcdCAqIEBldmVudFxuXHRcdFx0ICogQG5hbWUgZGlzYWJsZV9ub2RlLmpzdHJlZVxuXHRcdFx0ICogQHBhcmFtIHtPYmplY3R9IG5vZGUgdGhlIGRpc2FibGVkIG5vZGVcblx0XHRcdCAqL1xuXHRcdFx0dGhpcy50cmlnZ2VyKCdkaXNhYmxlX25vZGUnLCB7ICdub2RlJyA6IG9iaiB9KTtcblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIGNhbGxlZCB3aGVuIGEgbm9kZSBpcyBzZWxlY3RlZCBieSB0aGUgdXNlci4gVXNlZCBpbnRlcm5hbGx5LlxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICogQG5hbWUgYWN0aXZhdGVfbm9kZShvYmosIGUpXG5cdFx0ICogQHBhcmFtIHttaXhlZH0gb2JqIHRoZSBub2RlXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IGUgdGhlIHJlbGF0ZWQgZXZlbnRcblx0XHQgKiBAdHJpZ2dlciBhY3RpdmF0ZV9ub2RlLmpzdHJlZVxuXHRcdCAqL1xuXHRcdGFjdGl2YXRlX25vZGUgOiBmdW5jdGlvbiAob2JqLCBlKSB7XG5cdFx0XHRpZih0aGlzLmlzX2Rpc2FibGVkKG9iaikpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBlbnN1cmUgbGFzdF9jbGlja2VkIGlzIHN0aWxsIGluIHRoZSBET00sIG1ha2UgaXQgZnJlc2ggKG1heWJlIGl0IHdhcyBtb3ZlZD8pIGFuZCBtYWtlIHN1cmUgaXQgaXMgc3RpbGwgc2VsZWN0ZWQsIGlmIG5vdCAtIG1ha2UgbGFzdF9jbGlja2VkIHRoZSBsYXN0IHNlbGVjdGVkIG5vZGVcblx0XHRcdHRoaXMuX2RhdGEuY29yZS5sYXN0X2NsaWNrZWQgPSB0aGlzLl9kYXRhLmNvcmUubGFzdF9jbGlja2VkICYmIHRoaXMuX2RhdGEuY29yZS5sYXN0X2NsaWNrZWQuaWQgIT09IHVuZGVmaW5lZCA/IHRoaXMuZ2V0X25vZGUodGhpcy5fZGF0YS5jb3JlLmxhc3RfY2xpY2tlZC5pZCkgOiBudWxsO1xuXHRcdFx0aWYodGhpcy5fZGF0YS5jb3JlLmxhc3RfY2xpY2tlZCAmJiAhdGhpcy5fZGF0YS5jb3JlLmxhc3RfY2xpY2tlZC5zdGF0ZS5zZWxlY3RlZCkgeyB0aGlzLl9kYXRhLmNvcmUubGFzdF9jbGlja2VkID0gbnVsbDsgfVxuXHRcdFx0aWYoIXRoaXMuX2RhdGEuY29yZS5sYXN0X2NsaWNrZWQgJiYgdGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkLmxlbmd0aCkgeyB0aGlzLl9kYXRhLmNvcmUubGFzdF9jbGlja2VkID0gdGhpcy5nZXRfbm9kZSh0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWRbdGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkLmxlbmd0aCAtIDFdKTsgfVxuXG5cdFx0XHRpZighdGhpcy5zZXR0aW5ncy5jb3JlLm11bHRpcGxlIHx8ICghZS5tZXRhS2V5ICYmICFlLmN0cmxLZXkgJiYgIWUuc2hpZnRLZXkpIHx8IChlLnNoaWZ0S2V5ICYmICghdGhpcy5fZGF0YS5jb3JlLmxhc3RfY2xpY2tlZCB8fCAhdGhpcy5nZXRfcGFyZW50KG9iaikgfHwgdGhpcy5nZXRfcGFyZW50KG9iaikgIT09IHRoaXMuX2RhdGEuY29yZS5sYXN0X2NsaWNrZWQucGFyZW50ICkgKSkge1xuXHRcdFx0XHRpZighdGhpcy5zZXR0aW5ncy5jb3JlLm11bHRpcGxlICYmIChlLm1ldGFLZXkgfHwgZS5jdHJsS2V5IHx8IGUuc2hpZnRLZXkpICYmIHRoaXMuaXNfc2VsZWN0ZWQob2JqKSkge1xuXHRcdFx0XHRcdHRoaXMuZGVzZWxlY3Rfbm9kZShvYmosIGZhbHNlLCBlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHR0aGlzLmRlc2VsZWN0X2FsbCh0cnVlKTtcblx0XHRcdFx0XHR0aGlzLnNlbGVjdF9ub2RlKG9iaiwgZmFsc2UsIGZhbHNlLCBlKTtcblx0XHRcdFx0XHR0aGlzLl9kYXRhLmNvcmUubGFzdF9jbGlja2VkID0gdGhpcy5nZXRfbm9kZShvYmopO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0aWYoZS5zaGlmdEtleSkge1xuXHRcdFx0XHRcdHZhciBvID0gdGhpcy5nZXRfbm9kZShvYmopLmlkLFxuXHRcdFx0XHRcdFx0bCA9IHRoaXMuX2RhdGEuY29yZS5sYXN0X2NsaWNrZWQuaWQsXG5cdFx0XHRcdFx0XHRwID0gdGhpcy5nZXRfbm9kZSh0aGlzLl9kYXRhLmNvcmUubGFzdF9jbGlja2VkLnBhcmVudCkuY2hpbGRyZW4sXG5cdFx0XHRcdFx0XHRjID0gZmFsc2UsXG5cdFx0XHRcdFx0XHRpLCBqO1xuXHRcdFx0XHRcdGZvcihpID0gMCwgaiA9IHAubGVuZ3RoOyBpIDwgajsgaSArPSAxKSB7XG5cdFx0XHRcdFx0XHQvLyBzZXBhcmF0ZSBJRnMgd29yayB3aGVtIG8gYW5kIGwgYXJlIHRoZSBzYW1lXG5cdFx0XHRcdFx0XHRpZihwW2ldID09PSBvKSB7XG5cdFx0XHRcdFx0XHRcdGMgPSAhYztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmKHBbaV0gPT09IGwpIHtcblx0XHRcdFx0XHRcdFx0YyA9ICFjO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYoYyB8fCBwW2ldID09PSBvIHx8IHBbaV0gPT09IGwpIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5zZWxlY3Rfbm9kZShwW2ldLCBmYWxzZSwgZmFsc2UsIGUpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMuZGVzZWxlY3Rfbm9kZShwW2ldLCBmYWxzZSwgZSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdGlmKCF0aGlzLmlzX3NlbGVjdGVkKG9iaikpIHtcblx0XHRcdFx0XHRcdHRoaXMuc2VsZWN0X25vZGUob2JqLCBmYWxzZSwgZmFsc2UsIGUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdHRoaXMuZGVzZWxlY3Rfbm9kZShvYmosIGZhbHNlLCBlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdC8qKlxuXHRcdFx0ICogdHJpZ2dlcmVkIHdoZW4gYW4gbm9kZSBpcyBjbGlja2VkIG9yIGludGVyY2F0ZWQgd2l0aCBieSB0aGUgdXNlclxuXHRcdFx0ICogQGV2ZW50XG5cdFx0XHQgKiBAbmFtZSBhY3RpdmF0ZV9ub2RlLmpzdHJlZVxuXHRcdFx0ICogQHBhcmFtIHtPYmplY3R9IG5vZGVcblx0XHRcdCAqL1xuXHRcdFx0dGhpcy50cmlnZ2VyKCdhY3RpdmF0ZV9ub2RlJywgeyAnbm9kZScgOiB0aGlzLmdldF9ub2RlKG9iaikgfSk7XG5cdFx0fSxcblx0XHQvKipcblx0XHQgKiBhcHBsaWVzIHRoZSBob3ZlciBzdGF0ZSBvbiBhIG5vZGUsIGNhbGxlZCB3aGVuIGEgbm9kZSBpcyBob3ZlcmVkIGJ5IHRoZSB1c2VyLiBVc2VkIGludGVybmFsbHkuXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKiBAbmFtZSBob3Zlcl9ub2RlKG9iailcblx0XHQgKiBAcGFyYW0ge21peGVkfSBvYmpcblx0XHQgKiBAdHJpZ2dlciBob3Zlcl9ub2RlLmpzdHJlZVxuXHRcdCAqL1xuXHRcdGhvdmVyX25vZGUgOiBmdW5jdGlvbiAob2JqKSB7XG5cdFx0XHRvYmogPSB0aGlzLmdldF9ub2RlKG9iaiwgdHJ1ZSk7XG5cdFx0XHRpZighb2JqIHx8ICFvYmoubGVuZ3RoIHx8IG9iai5jaGlsZHJlbignLmpzdHJlZS1ob3ZlcmVkJykubGVuZ3RoKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdHZhciBvID0gdGhpcy5lbGVtZW50LmZpbmQoJy5qc3RyZWUtaG92ZXJlZCcpLCB0ID0gdGhpcy5lbGVtZW50O1xuXHRcdFx0aWYobyAmJiBvLmxlbmd0aCkgeyB0aGlzLmRlaG92ZXJfbm9kZShvKTsgfVxuXG5cdFx0XHRvYmouY2hpbGRyZW4oJy5qc3RyZWUtYW5jaG9yJykuYWRkQ2xhc3MoJ2pzdHJlZS1ob3ZlcmVkJyk7XG5cdFx0XHQvKipcblx0XHRcdCAqIHRyaWdnZXJlZCB3aGVuIGFuIG5vZGUgaXMgaG92ZXJlZFxuXHRcdFx0ICogQGV2ZW50XG5cdFx0XHQgKiBAbmFtZSBob3Zlcl9ub2RlLmpzdHJlZVxuXHRcdFx0ICogQHBhcmFtIHtPYmplY3R9IG5vZGVcblx0XHRcdCAqL1xuXHRcdFx0dGhpcy50cmlnZ2VyKCdob3Zlcl9ub2RlJywgeyAnbm9kZScgOiB0aGlzLmdldF9ub2RlKG9iaikgfSk7XG5cdFx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgdC5hdHRyKCdhcmlhLWFjdGl2ZWRlc2NlbmRhbnQnLCBvYmpbMF0uaWQpOyBvYmouYXR0cignYXJpYS1zZWxlY3RlZCcsIHRydWUpOyB9LCAwKTtcblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIHJlbW92ZXMgdGhlIGhvdmVyIHN0YXRlIGZyb20gYSBub2RlY2FsbGVkIHdoZW4gYSBub2RlIGlzIG5vIGxvbmdlciBob3ZlcmVkIGJ5IHRoZSB1c2VyLiBVc2VkIGludGVybmFsbHkuXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKiBAbmFtZSBkZWhvdmVyX25vZGUob2JqKVxuXHRcdCAqIEBwYXJhbSB7bWl4ZWR9IG9ialxuXHRcdCAqIEB0cmlnZ2VyIGRlaG92ZXJfbm9kZS5qc3RyZWVcblx0XHQgKi9cblx0XHRkZWhvdmVyX25vZGUgOiBmdW5jdGlvbiAob2JqKSB7XG5cdFx0XHRvYmogPSB0aGlzLmdldF9ub2RlKG9iaiwgdHJ1ZSk7XG5cdFx0XHRpZighb2JqIHx8ICFvYmoubGVuZ3RoIHx8ICFvYmouY2hpbGRyZW4oJy5qc3RyZWUtaG92ZXJlZCcpLmxlbmd0aCkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHRvYmouYXR0cignYXJpYS1zZWxlY3RlZCcsIGZhbHNlKS5jaGlsZHJlbignLmpzdHJlZS1hbmNob3InKS5yZW1vdmVDbGFzcygnanN0cmVlLWhvdmVyZWQnKTtcblx0XHRcdC8qKlxuXHRcdFx0ICogdHJpZ2dlcmVkIHdoZW4gYW4gbm9kZSBpcyBubyBsb25nZXIgaG92ZXJlZFxuXHRcdFx0ICogQGV2ZW50XG5cdFx0XHQgKiBAbmFtZSBkZWhvdmVyX25vZGUuanN0cmVlXG5cdFx0XHQgKiBAcGFyYW0ge09iamVjdH0gbm9kZVxuXHRcdFx0ICovXG5cdFx0XHR0aGlzLnRyaWdnZXIoJ2RlaG92ZXJfbm9kZScsIHsgJ25vZGUnIDogdGhpcy5nZXRfbm9kZShvYmopIH0pO1xuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogc2VsZWN0IGEgbm9kZVxuXHRcdCAqIEBuYW1lIHNlbGVjdF9ub2RlKG9iaiBbLCBzdXByZXNzX2V2ZW50LCBwcmV2ZW50X29wZW5dKVxuXHRcdCAqIEBwYXJhbSB7bWl4ZWR9IG9iaiBhbiBhcnJheSBjYW4gYmUgdXNlZCB0byBzZWxlY3QgbXVsdGlwbGUgbm9kZXNcblx0XHQgKiBAcGFyYW0ge0Jvb2xlYW59IHN1cHJlc3NfZXZlbnQgaWYgc2V0IHRvIGB0cnVlYCB0aGUgYGNoYW5nZWQuanN0cmVlYCBldmVudCB3b24ndCBiZSB0cmlnZ2VyZWRcblx0XHQgKiBAcGFyYW0ge0Jvb2xlYW59IHByZXZlbnRfb3BlbiBpZiBzZXQgdG8gYHRydWVgIHBhcmVudHMgb2YgdGhlIHNlbGVjdGVkIG5vZGUgd29uJ3QgYmUgb3BlbmVkXG5cdFx0ICogQHRyaWdnZXIgc2VsZWN0X25vZGUuanN0cmVlLCBjaGFuZ2VkLmpzdHJlZVxuXHRcdCAqL1xuXHRcdHNlbGVjdF9ub2RlIDogZnVuY3Rpb24gKG9iaiwgc3VwcmVzc19ldmVudCwgcHJldmVudF9vcGVuLCBlKSB7XG5cdFx0XHR2YXIgZG9tLCB0MSwgdDIsIHRoO1xuXHRcdFx0aWYoJC5pc0FycmF5KG9iaikpIHtcblx0XHRcdFx0b2JqID0gb2JqLnNsaWNlKCk7XG5cdFx0XHRcdGZvcih0MSA9IDAsIHQyID0gb2JqLmxlbmd0aDsgdDEgPCB0MjsgdDErKykge1xuXHRcdFx0XHRcdHRoaXMuc2VsZWN0X25vZGUob2JqW3QxXSwgc3VwcmVzc19ldmVudCwgcHJldmVudF9vcGVuLCBlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdG9iaiA9IHRoaXMuZ2V0X25vZGUob2JqKTtcblx0XHRcdGlmKCFvYmogfHwgb2JqLmlkID09PSAnIycpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0ZG9tID0gdGhpcy5nZXRfbm9kZShvYmosIHRydWUpO1xuXHRcdFx0aWYoIW9iai5zdGF0ZS5zZWxlY3RlZCkge1xuXHRcdFx0XHRvYmouc3RhdGUuc2VsZWN0ZWQgPSB0cnVlO1xuXHRcdFx0XHR0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQucHVzaChvYmouaWQpO1xuXHRcdFx0XHRpZighcHJldmVudF9vcGVuKSB7XG5cdFx0XHRcdFx0ZG9tID0gdGhpcy5fb3Blbl90byhvYmopO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKGRvbSAmJiBkb20ubGVuZ3RoKSB7XG5cdFx0XHRcdFx0ZG9tLmNoaWxkcmVuKCcuanN0cmVlLWFuY2hvcicpLmFkZENsYXNzKCdqc3RyZWUtY2xpY2tlZCcpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8qKlxuXHRcdFx0XHQgKiB0cmlnZ2VyZWQgd2hlbiBhbiBub2RlIGlzIHNlbGVjdGVkXG5cdFx0XHRcdCAqIEBldmVudFxuXHRcdFx0XHQgKiBAbmFtZSBzZWxlY3Rfbm9kZS5qc3RyZWVcblx0XHRcdFx0ICogQHBhcmFtIHtPYmplY3R9IG5vZGVcblx0XHRcdFx0ICogQHBhcmFtIHtBcnJheX0gc2VsZWN0ZWQgdGhlIGN1cnJlbnQgc2VsZWN0aW9uXG5cdFx0XHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCB0aGUgZXZlbnQgKGlmIGFueSkgdGhhdCB0cmlnZ2VyZWQgdGhpcyBzZWxlY3Rfbm9kZVxuXHRcdFx0XHQgKi9cblx0XHRcdFx0dGhpcy50cmlnZ2VyKCdzZWxlY3Rfbm9kZScsIHsgJ25vZGUnIDogb2JqLCAnc2VsZWN0ZWQnIDogdGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkLCAnZXZlbnQnIDogZSB9KTtcblx0XHRcdFx0aWYoIXN1cHJlc3NfZXZlbnQpIHtcblx0XHRcdFx0XHQvKipcblx0XHRcdFx0XHQgKiB0cmlnZ2VyZWQgd2hlbiBzZWxlY3Rpb24gY2hhbmdlc1xuXHRcdFx0XHRcdCAqIEBldmVudFxuXHRcdFx0XHRcdCAqIEBuYW1lIGNoYW5nZWQuanN0cmVlXG5cdFx0XHRcdFx0ICogQHBhcmFtIHtPYmplY3R9IG5vZGVcblx0XHRcdFx0XHQgKiBAcGFyYW0ge09iamVjdH0gYWN0aW9uIHRoZSBhY3Rpb24gdGhhdCBjYXVzZWQgdGhlIHNlbGVjdGlvbiB0byBjaGFuZ2Vcblx0XHRcdFx0XHQgKiBAcGFyYW0ge0FycmF5fSBzZWxlY3RlZCB0aGUgY3VycmVudCBzZWxlY3Rpb25cblx0XHRcdFx0XHQgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgdGhlIGV2ZW50IChpZiBhbnkpIHRoYXQgdHJpZ2dlcmVkIHRoaXMgY2hhbmdlZCBldmVudFxuXHRcdFx0XHRcdCAqL1xuXHRcdFx0XHRcdHRoaXMudHJpZ2dlcignY2hhbmdlZCcsIHsgJ2FjdGlvbicgOiAnc2VsZWN0X25vZGUnLCAnbm9kZScgOiBvYmosICdzZWxlY3RlZCcgOiB0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQsICdldmVudCcgOiBlIH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHQvKipcblx0XHQgKiBkZXNlbGVjdCBhIG5vZGVcblx0XHQgKiBAbmFtZSBkZXNlbGVjdF9ub2RlKG9iaiBbLCBzdXByZXNzX2V2ZW50XSlcblx0XHQgKiBAcGFyYW0ge21peGVkfSBvYmogYW4gYXJyYXkgY2FuIGJlIHVzZWQgdG8gZGVzZWxlY3QgbXVsdGlwbGUgbm9kZXNcblx0XHQgKiBAcGFyYW0ge0Jvb2xlYW59IHN1cHJlc3NfZXZlbnQgaWYgc2V0IHRvIGB0cnVlYCB0aGUgYGNoYW5nZWQuanN0cmVlYCBldmVudCB3b24ndCBiZSB0cmlnZ2VyZWRcblx0XHQgKiBAdHJpZ2dlciBkZXNlbGVjdF9ub2RlLmpzdHJlZSwgY2hhbmdlZC5qc3RyZWVcblx0XHQgKi9cblx0XHRkZXNlbGVjdF9ub2RlIDogZnVuY3Rpb24gKG9iaiwgc3VwcmVzc19ldmVudCwgZSkge1xuXHRcdFx0dmFyIHQxLCB0MiwgZG9tO1xuXHRcdFx0aWYoJC5pc0FycmF5KG9iaikpIHtcblx0XHRcdFx0b2JqID0gb2JqLnNsaWNlKCk7XG5cdFx0XHRcdGZvcih0MSA9IDAsIHQyID0gb2JqLmxlbmd0aDsgdDEgPCB0MjsgdDErKykge1xuXHRcdFx0XHRcdHRoaXMuZGVzZWxlY3Rfbm9kZShvYmpbdDFdLCBzdXByZXNzX2V2ZW50LCBlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdG9iaiA9IHRoaXMuZ2V0X25vZGUob2JqKTtcblx0XHRcdGlmKCFvYmogfHwgb2JqLmlkID09PSAnIycpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0ZG9tID0gdGhpcy5nZXRfbm9kZShvYmosIHRydWUpO1xuXHRcdFx0aWYob2JqLnN0YXRlLnNlbGVjdGVkKSB7XG5cdFx0XHRcdG9iai5zdGF0ZS5zZWxlY3RlZCA9IGZhbHNlO1xuXHRcdFx0XHR0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQgPSAkLnZha2F0YS5hcnJheV9yZW1vdmVfaXRlbSh0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQsIG9iai5pZCk7XG5cdFx0XHRcdGlmKGRvbS5sZW5ndGgpIHtcblx0XHRcdFx0XHRkb20uY2hpbGRyZW4oJy5qc3RyZWUtYW5jaG9yJykucmVtb3ZlQ2xhc3MoJ2pzdHJlZS1jbGlja2VkJyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0LyoqXG5cdFx0XHRcdCAqIHRyaWdnZXJlZCB3aGVuIGFuIG5vZGUgaXMgZGVzZWxlY3RlZFxuXHRcdFx0XHQgKiBAZXZlbnRcblx0XHRcdFx0ICogQG5hbWUgZGVzZWxlY3Rfbm9kZS5qc3RyZWVcblx0XHRcdFx0ICogQHBhcmFtIHtPYmplY3R9IG5vZGVcblx0XHRcdFx0ICogQHBhcmFtIHtBcnJheX0gc2VsZWN0ZWQgdGhlIGN1cnJlbnQgc2VsZWN0aW9uXG5cdFx0XHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCB0aGUgZXZlbnQgKGlmIGFueSkgdGhhdCB0cmlnZ2VyZWQgdGhpcyBkZXNlbGVjdF9ub2RlXG5cdFx0XHRcdCAqL1xuXHRcdFx0XHR0aGlzLnRyaWdnZXIoJ2Rlc2VsZWN0X25vZGUnLCB7ICdub2RlJyA6IG9iaiwgJ3NlbGVjdGVkJyA6IHRoaXMuX2RhdGEuY29yZS5zZWxlY3RlZCwgJ2V2ZW50JyA6IGUgfSk7XG5cdFx0XHRcdGlmKCFzdXByZXNzX2V2ZW50KSB7XG5cdFx0XHRcdFx0dGhpcy50cmlnZ2VyKCdjaGFuZ2VkJywgeyAnYWN0aW9uJyA6ICdkZXNlbGVjdF9ub2RlJywgJ25vZGUnIDogb2JqLCAnc2VsZWN0ZWQnIDogdGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkLCAnZXZlbnQnIDogZSB9KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogc2VsZWN0IGFsbCBub2RlcyBpbiB0aGUgdHJlZVxuXHRcdCAqIEBuYW1lIHNlbGVjdF9hbGwoW3N1cHJlc3NfZXZlbnRdKVxuXHRcdCAqIEBwYXJhbSB7Qm9vbGVhbn0gc3VwcmVzc19ldmVudCBpZiBzZXQgdG8gYHRydWVgIHRoZSBgY2hhbmdlZC5qc3RyZWVgIGV2ZW50IHdvbid0IGJlIHRyaWdnZXJlZFxuXHRcdCAqIEB0cmlnZ2VyIHNlbGVjdF9hbGwuanN0cmVlLCBjaGFuZ2VkLmpzdHJlZVxuXHRcdCAqL1xuXHRcdHNlbGVjdF9hbGwgOiBmdW5jdGlvbiAoc3VwcmVzc19ldmVudCkge1xuXHRcdFx0dmFyIHRtcCA9IHRoaXMuX2RhdGEuY29yZS5zZWxlY3RlZC5jb25jYXQoW10pLCBpLCBqO1xuXHRcdFx0dGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkID0gdGhpcy5fbW9kZWwuZGF0YVsnIyddLmNoaWxkcmVuX2QuY29uY2F0KCk7XG5cdFx0XHRmb3IoaSA9IDAsIGogPSB0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG5cdFx0XHRcdGlmKHRoaXMuX21vZGVsLmRhdGFbdGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkW2ldXSkge1xuXHRcdFx0XHRcdHRoaXMuX21vZGVsLmRhdGFbdGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkW2ldXS5zdGF0ZS5zZWxlY3RlZCA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHRoaXMucmVkcmF3KHRydWUpO1xuXHRcdFx0LyoqXG5cdFx0XHQgKiB0cmlnZ2VyZWQgd2hlbiBhbGwgbm9kZXMgYXJlIHNlbGVjdGVkXG5cdFx0XHQgKiBAZXZlbnRcblx0XHRcdCAqIEBuYW1lIHNlbGVjdF9hbGwuanN0cmVlXG5cdFx0XHQgKiBAcGFyYW0ge0FycmF5fSBzZWxlY3RlZCB0aGUgY3VycmVudCBzZWxlY3Rpb25cblx0XHRcdCAqL1xuXHRcdFx0dGhpcy50cmlnZ2VyKCdzZWxlY3RfYWxsJywgeyAnc2VsZWN0ZWQnIDogdGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkIH0pO1xuXHRcdFx0aWYoIXN1cHJlc3NfZXZlbnQpIHtcblx0XHRcdFx0dGhpcy50cmlnZ2VyKCdjaGFuZ2VkJywgeyAnYWN0aW9uJyA6ICdzZWxlY3RfYWxsJywgJ3NlbGVjdGVkJyA6IHRoaXMuX2RhdGEuY29yZS5zZWxlY3RlZCwgJ29sZF9zZWxlY3Rpb24nIDogdG1wIH0pO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogZGVzZWxlY3QgYWxsIHNlbGVjdGVkIG5vZGVzXG5cdFx0ICogQG5hbWUgZGVzZWxlY3RfYWxsKFtzdXByZXNzX2V2ZW50XSlcblx0XHQgKiBAcGFyYW0ge0Jvb2xlYW59IHN1cHJlc3NfZXZlbnQgaWYgc2V0IHRvIGB0cnVlYCB0aGUgYGNoYW5nZWQuanN0cmVlYCBldmVudCB3b24ndCBiZSB0cmlnZ2VyZWRcblx0XHQgKiBAdHJpZ2dlciBkZXNlbGVjdF9hbGwuanN0cmVlLCBjaGFuZ2VkLmpzdHJlZVxuXHRcdCAqL1xuXHRcdGRlc2VsZWN0X2FsbCA6IGZ1bmN0aW9uIChzdXByZXNzX2V2ZW50KSB7XG5cdFx0XHR2YXIgdG1wID0gdGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkLmNvbmNhdChbXSksIGksIGo7XG5cdFx0XHRmb3IoaSA9IDAsIGogPSB0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG5cdFx0XHRcdGlmKHRoaXMuX21vZGVsLmRhdGFbdGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkW2ldXSkge1xuXHRcdFx0XHRcdHRoaXMuX21vZGVsLmRhdGFbdGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkW2ldXS5zdGF0ZS5zZWxlY3RlZCA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQgPSBbXTtcblx0XHRcdHRoaXMuZWxlbWVudC5maW5kKCcuanN0cmVlLWNsaWNrZWQnKS5yZW1vdmVDbGFzcygnanN0cmVlLWNsaWNrZWQnKTtcblx0XHRcdC8qKlxuXHRcdFx0ICogdHJpZ2dlcmVkIHdoZW4gYWxsIG5vZGVzIGFyZSBkZXNlbGVjdGVkXG5cdFx0XHQgKiBAZXZlbnRcblx0XHRcdCAqIEBuYW1lIGRlc2VsZWN0X2FsbC5qc3RyZWVcblx0XHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBub2RlIHRoZSBwcmV2aW91cyBzZWxlY3Rpb25cblx0XHRcdCAqIEBwYXJhbSB7QXJyYXl9IHNlbGVjdGVkIHRoZSBjdXJyZW50IHNlbGVjdGlvblxuXHRcdFx0ICovXG5cdFx0XHR0aGlzLnRyaWdnZXIoJ2Rlc2VsZWN0X2FsbCcsIHsgJ3NlbGVjdGVkJyA6IHRoaXMuX2RhdGEuY29yZS5zZWxlY3RlZCwgJ25vZGUnIDogdG1wIH0pO1xuXHRcdFx0aWYoIXN1cHJlc3NfZXZlbnQpIHtcblx0XHRcdFx0dGhpcy50cmlnZ2VyKCdjaGFuZ2VkJywgeyAnYWN0aW9uJyA6ICdkZXNlbGVjdF9hbGwnLCAnc2VsZWN0ZWQnIDogdGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkLCAnb2xkX3NlbGVjdGlvbicgOiB0bXAgfSk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHQvKipcblx0XHQgKiBjaGVja3MgaWYgYSBub2RlIGlzIHNlbGVjdGVkXG5cdFx0ICogQG5hbWUgaXNfc2VsZWN0ZWQob2JqKVxuXHRcdCAqIEBwYXJhbSAge21peGVkfSAgb2JqXG5cdFx0ICogQHJldHVybiB7Qm9vbGVhbn1cblx0XHQgKi9cblx0XHRpc19zZWxlY3RlZCA6IGZ1bmN0aW9uIChvYmopIHtcblx0XHRcdG9iaiA9IHRoaXMuZ2V0X25vZGUob2JqKTtcblx0XHRcdGlmKCFvYmogfHwgb2JqLmlkID09PSAnIycpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG9iai5zdGF0ZS5zZWxlY3RlZDtcblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIGdldCBhbiBhcnJheSBvZiBhbGwgc2VsZWN0ZWQgbm9kZXNcblx0XHQgKiBAbmFtZSBnZXRfc2VsZWN0ZWQoW2Z1bGxdKVxuXHRcdCAqIEBwYXJhbSAge21peGVkfSAgZnVsbCBpZiBzZXQgdG8gYHRydWVgIHRoZSByZXR1cm5lZCBhcnJheSB3aWxsIGNvbnNpc3Qgb2YgdGhlIGZ1bGwgbm9kZSBvYmplY3RzLCBvdGhlcndpc2UgLSBvbmx5IElEcyB3aWxsIGJlIHJldHVybmVkXG5cdFx0ICogQHJldHVybiB7QXJyYXl9XG5cdFx0ICovXG5cdFx0Z2V0X3NlbGVjdGVkIDogZnVuY3Rpb24gKGZ1bGwpIHtcblx0XHRcdHJldHVybiBmdWxsID8gJC5tYXAodGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkLCAkLnByb3h5KGZ1bmN0aW9uIChpKSB7IHJldHVybiB0aGlzLmdldF9ub2RlKGkpOyB9LCB0aGlzKSkgOiB0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQuc2xpY2UoKTtcblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIGdldCBhbiBhcnJheSBvZiBhbGwgdG9wIGxldmVsIHNlbGVjdGVkIG5vZGVzIChpZ25vcmluZyBjaGlsZHJlbiBvZiBzZWxlY3RlZCBub2Rlcylcblx0XHQgKiBAbmFtZSBnZXRfdG9wX3NlbGVjdGVkKFtmdWxsXSlcblx0XHQgKiBAcGFyYW0gIHttaXhlZH0gIGZ1bGwgaWYgc2V0IHRvIGB0cnVlYCB0aGUgcmV0dXJuZWQgYXJyYXkgd2lsbCBjb25zaXN0IG9mIHRoZSBmdWxsIG5vZGUgb2JqZWN0cywgb3RoZXJ3aXNlIC0gb25seSBJRHMgd2lsbCBiZSByZXR1cm5lZFxuXHRcdCAqIEByZXR1cm4ge0FycmF5fVxuXHRcdCAqL1xuXHRcdGdldF90b3Bfc2VsZWN0ZWQgOiBmdW5jdGlvbiAoZnVsbCkge1xuXHRcdFx0dmFyIHRtcCA9IHRoaXMuZ2V0X3NlbGVjdGVkKHRydWUpLFxuXHRcdFx0XHRvYmogPSB7fSwgaSwgaiwgaywgbDtcblx0XHRcdGZvcihpID0gMCwgaiA9IHRtcC5sZW5ndGg7IGkgPCBqOyBpKyspIHtcblx0XHRcdFx0b2JqW3RtcFtpXS5pZF0gPSB0bXBbaV07XG5cdFx0XHR9XG5cdFx0XHRmb3IoaSA9IDAsIGogPSB0bXAubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG5cdFx0XHRcdGZvcihrID0gMCwgbCA9IHRtcFtpXS5jaGlsZHJlbl9kLmxlbmd0aDsgayA8IGw7IGsrKykge1xuXHRcdFx0XHRcdGlmKG9ialt0bXBbaV0uY2hpbGRyZW5fZFtrXV0pIHtcblx0XHRcdFx0XHRcdGRlbGV0ZSBvYmpbdG1wW2ldLmNoaWxkcmVuX2Rba11dO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dG1wID0gW107XG5cdFx0XHRmb3IoaSBpbiBvYmopIHtcblx0XHRcdFx0aWYob2JqLmhhc093blByb3BlcnR5KGkpKSB7XG5cdFx0XHRcdFx0dG1wLnB1c2goaSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBmdWxsID8gJC5tYXAodG1wLCAkLnByb3h5KGZ1bmN0aW9uIChpKSB7IHJldHVybiB0aGlzLmdldF9ub2RlKGkpOyB9LCB0aGlzKSkgOiB0bXA7XG5cdFx0fSxcblx0XHQvKipcblx0XHQgKiBnZXQgYW4gYXJyYXkgb2YgYWxsIGJvdHRvbSBsZXZlbCBzZWxlY3RlZCBub2RlcyAoaWdub3Jpbmcgc2VsZWN0ZWQgcGFyZW50cylcblx0XHQgKiBAbmFtZSBnZXRfYm90dG9tX3NlbGVjdGVkKFtmdWxsXSlcblx0XHQgKiBAcGFyYW0gIHttaXhlZH0gIGZ1bGwgaWYgc2V0IHRvIGB0cnVlYCB0aGUgcmV0dXJuZWQgYXJyYXkgd2lsbCBjb25zaXN0IG9mIHRoZSBmdWxsIG5vZGUgb2JqZWN0cywgb3RoZXJ3aXNlIC0gb25seSBJRHMgd2lsbCBiZSByZXR1cm5lZFxuXHRcdCAqIEByZXR1cm4ge0FycmF5fVxuXHRcdCAqL1xuXHRcdGdldF9ib3R0b21fc2VsZWN0ZWQgOiBmdW5jdGlvbiAoZnVsbCkge1xuXHRcdFx0dmFyIHRtcCA9IHRoaXMuZ2V0X3NlbGVjdGVkKHRydWUpLFxuXHRcdFx0XHRvYmogPSBbXSwgaSwgajtcblx0XHRcdGZvcihpID0gMCwgaiA9IHRtcC5sZW5ndGg7IGkgPCBqOyBpKyspIHtcblx0XHRcdFx0aWYoIXRtcFtpXS5jaGlsZHJlbi5sZW5ndGgpIHtcblx0XHRcdFx0XHRvYmoucHVzaCh0bXBbaV0uaWQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZnVsbCA/ICQubWFwKG9iaiwgJC5wcm94eShmdW5jdGlvbiAoaSkgeyByZXR1cm4gdGhpcy5nZXRfbm9kZShpKTsgfSwgdGhpcykpIDogb2JqO1xuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogZ2V0cyB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgdHJlZSBzbyB0aGF0IGl0IGNhbiBiZSByZXN0b3JlZCBsYXRlciB3aXRoIGBzZXRfc3RhdGUoc3RhdGUpYC4gVXNlZCBpbnRlcm5hbGx5LlxuXHRcdCAqIEBuYW1lIGdldF9zdGF0ZSgpXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKiBAcmV0dXJuIHtPYmplY3R9XG5cdFx0ICovXG5cdFx0Z2V0X3N0YXRlIDogZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIHN0YXRlXHQ9IHtcblx0XHRcdFx0J2NvcmUnIDoge1xuXHRcdFx0XHRcdCdvcGVuJyA6IFtdLFxuXHRcdFx0XHRcdCdzY3JvbGwnIDoge1xuXHRcdFx0XHRcdFx0J2xlZnQnIDogdGhpcy5lbGVtZW50LnNjcm9sbExlZnQoKSxcblx0XHRcdFx0XHRcdCd0b3AnIDogdGhpcy5lbGVtZW50LnNjcm9sbFRvcCgpXG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHQvKiFcblx0XHRcdFx0XHQndGhlbWVzJyA6IHtcblx0XHRcdFx0XHRcdCduYW1lJyA6IHRoaXMuZ2V0X3RoZW1lKCksXG5cdFx0XHRcdFx0XHQnaWNvbnMnIDogdGhpcy5fZGF0YS5jb3JlLnRoZW1lcy5pY29ucyxcblx0XHRcdFx0XHRcdCdkb3RzJyA6IHRoaXMuX2RhdGEuY29yZS50aGVtZXMuZG90c1xuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0Ki9cblx0XHRcdFx0XHQnc2VsZWN0ZWQnIDogW11cblx0XHRcdFx0fVxuXHRcdFx0fSwgaTtcblx0XHRcdGZvcihpIGluIHRoaXMuX21vZGVsLmRhdGEpIHtcblx0XHRcdFx0aWYodGhpcy5fbW9kZWwuZGF0YS5oYXNPd25Qcm9wZXJ0eShpKSkge1xuXHRcdFx0XHRcdGlmKGkgIT09ICcjJykge1xuXHRcdFx0XHRcdFx0aWYodGhpcy5fbW9kZWwuZGF0YVtpXS5zdGF0ZS5vcGVuZWQpIHtcblx0XHRcdFx0XHRcdFx0c3RhdGUuY29yZS5vcGVuLnB1c2goaSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZih0aGlzLl9tb2RlbC5kYXRhW2ldLnN0YXRlLnNlbGVjdGVkKSB7XG5cdFx0XHRcdFx0XHRcdHN0YXRlLmNvcmUuc2VsZWN0ZWQucHVzaChpKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBzdGF0ZTtcblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIHNldHMgdGhlIHN0YXRlIG9mIHRoZSB0cmVlLiBVc2VkIGludGVybmFsbHkuXG5cdFx0ICogQG5hbWUgc2V0X3N0YXRlKHN0YXRlIFssIGNhbGxiYWNrXSlcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZSB0aGUgc3RhdGUgdG8gcmVzdG9yZVxuXHRcdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGFuIG9wdGlvbmFsIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgb25jZSB0aGUgc3RhdGUgaXMgcmVzdG9yZWQuXG5cdFx0ICogQHRyaWdnZXIgc2V0X3N0YXRlLmpzdHJlZVxuXHRcdCAqL1xuXHRcdHNldF9zdGF0ZSA6IGZ1bmN0aW9uIChzdGF0ZSwgY2FsbGJhY2spIHtcblx0XHRcdGlmKHN0YXRlKSB7XG5cdFx0XHRcdGlmKHN0YXRlLmNvcmUpIHtcblx0XHRcdFx0XHR2YXIgcmVzLCBuLCB0LCBfdGhpcztcblx0XHRcdFx0XHRpZihzdGF0ZS5jb3JlLm9wZW4pIHtcblx0XHRcdFx0XHRcdGlmKCEkLmlzQXJyYXkoc3RhdGUuY29yZS5vcGVuKSkge1xuXHRcdFx0XHRcdFx0XHRkZWxldGUgc3RhdGUuY29yZS5vcGVuO1xuXHRcdFx0XHRcdFx0XHR0aGlzLnNldF9zdGF0ZShzdGF0ZSwgY2FsbGJhY2spO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRyZXMgPSB0cnVlO1xuXHRcdFx0XHRcdFx0biA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0dCA9IHRoaXM7XG5cdFx0XHRcdFx0XHQkLmVhY2goc3RhdGUuY29yZS5vcGVuLmNvbmNhdChbXSksIGZ1bmN0aW9uIChpLCB2KSB7XG5cdFx0XHRcdFx0XHRcdG4gPSB0LmdldF9ub2RlKHYpO1xuXHRcdFx0XHRcdFx0XHRpZihuKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYodC5pc19sb2FkZWQodikpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGlmKHQuaXNfY2xvc2VkKHYpKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHQub3Blbl9ub2RlKHYsIGZhbHNlLCAwKTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdGlmKHN0YXRlICYmIHN0YXRlLmNvcmUgJiYgc3RhdGUuY29yZS5vcGVuKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdCQudmFrYXRhLmFycmF5X3JlbW92ZV9pdGVtKHN0YXRlLmNvcmUub3Blbiwgdik7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYoIXQuaXNfbG9hZGluZyh2KSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0Lm9wZW5fbm9kZSh2LCAkLnByb3h5KGZ1bmN0aW9uIChvLCBzKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYoIXMgJiYgc3RhdGUgJiYgc3RhdGUuY29yZSAmJiBzdGF0ZS5jb3JlLm9wZW4pIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdCQudmFrYXRhLmFycmF5X3JlbW92ZV9pdGVtKHN0YXRlLmNvcmUub3Blbiwgby5pZCk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRoaXMuc2V0X3N0YXRlKHN0YXRlLCBjYWxsYmFjayk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0sIHQpLCAwKTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdC8vIHRoZXJlIHdpbGwgYmUgc29tZSBhc3luYyBhY3Rpdml0eSAtIHNvIHdhaXQgZm9yIGl0XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXMgPSBmYWxzZTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0aWYocmVzKSB7XG5cdFx0XHRcdFx0XHRcdGRlbGV0ZSBzdGF0ZS5jb3JlLm9wZW47XG5cdFx0XHRcdFx0XHRcdHRoaXMuc2V0X3N0YXRlKHN0YXRlLCBjYWxsYmFjayk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmKHN0YXRlLmNvcmUuc2Nyb2xsKSB7XG5cdFx0XHRcdFx0XHRpZihzdGF0ZS5jb3JlLnNjcm9sbCAmJiBzdGF0ZS5jb3JlLnNjcm9sbC5sZWZ0ICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5lbGVtZW50LnNjcm9sbExlZnQoc3RhdGUuY29yZS5zY3JvbGwubGVmdCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZihzdGF0ZS5jb3JlLnNjcm9sbCAmJiBzdGF0ZS5jb3JlLnNjcm9sbC50b3AgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdFx0XHR0aGlzLmVsZW1lbnQuc2Nyb2xsVG9wKHN0YXRlLmNvcmUuc2Nyb2xsLnRvcCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRkZWxldGUgc3RhdGUuY29yZS5zY3JvbGw7XG5cdFx0XHRcdFx0XHR0aGlzLnNldF9zdGF0ZShzdGF0ZSwgY2FsbGJhY2spO1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQvKiFcblx0XHRcdFx0XHRpZihzdGF0ZS5jb3JlLnRoZW1lcykge1xuXHRcdFx0XHRcdFx0aWYoc3RhdGUuY29yZS50aGVtZXMubmFtZSkge1xuXHRcdFx0XHRcdFx0XHR0aGlzLnNldF90aGVtZShzdGF0ZS5jb3JlLnRoZW1lcy5uYW1lKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmKHR5cGVvZiBzdGF0ZS5jb3JlLnRoZW1lcy5kb3RzICE9PSAndW5kZWZpbmVkJykge1xuXHRcdFx0XHRcdFx0XHR0aGlzWyBzdGF0ZS5jb3JlLnRoZW1lcy5kb3RzID8gXCJzaG93X2RvdHNcIiA6IFwiaGlkZV9kb3RzXCIgXSgpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYodHlwZW9mIHN0YXRlLmNvcmUudGhlbWVzLmljb25zICE9PSAndW5kZWZpbmVkJykge1xuXHRcdFx0XHRcdFx0XHR0aGlzWyBzdGF0ZS5jb3JlLnRoZW1lcy5pY29ucyA/IFwic2hvd19pY29uc1wiIDogXCJoaWRlX2ljb25zXCIgXSgpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZGVsZXRlIHN0YXRlLmNvcmUudGhlbWVzO1xuXHRcdFx0XHRcdFx0ZGVsZXRlIHN0YXRlLmNvcmUub3Blbjtcblx0XHRcdFx0XHRcdHRoaXMuc2V0X3N0YXRlKHN0YXRlLCBjYWxsYmFjayk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdCovXG5cdFx0XHRcdFx0aWYoc3RhdGUuY29yZS5zZWxlY3RlZCkge1xuXHRcdFx0XHRcdFx0X3RoaXMgPSB0aGlzO1xuXHRcdFx0XHRcdFx0dGhpcy5kZXNlbGVjdF9hbGwoKTtcblx0XHRcdFx0XHRcdCQuZWFjaChzdGF0ZS5jb3JlLnNlbGVjdGVkLCBmdW5jdGlvbiAoaSwgdikge1xuXHRcdFx0XHRcdFx0XHRfdGhpcy5zZWxlY3Rfbm9kZSh2KTtcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0ZGVsZXRlIHN0YXRlLmNvcmUuc2VsZWN0ZWQ7XG5cdFx0XHRcdFx0XHR0aGlzLnNldF9zdGF0ZShzdGF0ZSwgY2FsbGJhY2spO1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZigkLmlzRW1wdHlPYmplY3Qoc3RhdGUuY29yZSkpIHtcblx0XHRcdFx0XHRcdGRlbGV0ZSBzdGF0ZS5jb3JlO1xuXHRcdFx0XHRcdFx0dGhpcy5zZXRfc3RhdGUoc3RhdGUsIGNhbGxiYWNrKTtcblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYoJC5pc0VtcHR5T2JqZWN0KHN0YXRlKSkge1xuXHRcdFx0XHRcdHN0YXRlID0gbnVsbDtcblx0XHRcdFx0XHRpZihjYWxsYmFjaykgeyBjYWxsYmFjay5jYWxsKHRoaXMpOyB9XG5cdFx0XHRcdFx0LyoqXG5cdFx0XHRcdFx0ICogdHJpZ2dlcmVkIHdoZW4gYSBgc2V0X3N0YXRlYCBjYWxsIGNvbXBsZXRlc1xuXHRcdFx0XHRcdCAqIEBldmVudFxuXHRcdFx0XHRcdCAqIEBuYW1lIHNldF9zdGF0ZS5qc3RyZWVcblx0XHRcdFx0XHQgKi9cblx0XHRcdFx0XHR0aGlzLnRyaWdnZXIoJ3NldF9zdGF0ZScpO1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIHJlZnJlc2hlcyB0aGUgdHJlZSAtIGFsbCBub2RlcyBhcmUgcmVsb2FkZWQgd2l0aCBjYWxscyB0byBgbG9hZF9ub2RlYC5cblx0XHQgKiBAbmFtZSByZWZyZXNoKClcblx0XHQgKiBAcGFyYW0ge0Jvb2xlYW59IHNraXBfbG9hZGluZyBhbiBvcHRpb24gdG8gc2tpcCBzaG93aW5nIHRoZSBsb2FkaW5nIGluZGljYXRvclxuXHRcdCAqIEBwYXJhbSB7TWl4ZWR9IGZvcmdldF9zdGF0ZSBpZiBzZXQgdG8gYHRydWVgIHN0YXRlIHdpbGwgbm90IGJlIHJlYXBwbGllZCwgaWYgc2V0IHRvIGEgZnVuY3Rpb24gKHJlY2VpdmluZyB0aGUgY3VycmVudCBzdGF0ZSBhcyBhcmd1bWVudCkgdGhlIHJlc3VsdCBvZiB0aGF0IGZ1bmN0aW9uIHdpbGwgYmUgdXNlZCBhcyBzdGF0ZVxuXHRcdCAqIEB0cmlnZ2VyIHJlZnJlc2guanN0cmVlXG5cdFx0ICovXG5cdFx0cmVmcmVzaCA6IGZ1bmN0aW9uIChza2lwX2xvYWRpbmcsIGZvcmdldF9zdGF0ZSkge1xuXHRcdFx0dGhpcy5fZGF0YS5jb3JlLnN0YXRlID0gZm9yZ2V0X3N0YXRlID09PSB0cnVlID8ge30gOiB0aGlzLmdldF9zdGF0ZSgpO1xuXHRcdFx0aWYoZm9yZ2V0X3N0YXRlICYmICQuaXNGdW5jdGlvbihmb3JnZXRfc3RhdGUpKSB7IHRoaXMuX2RhdGEuY29yZS5zdGF0ZSA9IGZvcmdldF9zdGF0ZS5jYWxsKHRoaXMsIHRoaXMuX2RhdGEuY29yZS5zdGF0ZSk7IH1cblx0XHRcdHRoaXMuX2NudCA9IDA7XG5cdFx0XHR0aGlzLl9tb2RlbC5kYXRhID0ge1xuXHRcdFx0XHQnIycgOiB7XG5cdFx0XHRcdFx0aWQgOiAnIycsXG5cdFx0XHRcdFx0cGFyZW50IDogbnVsbCxcblx0XHRcdFx0XHRwYXJlbnRzIDogW10sXG5cdFx0XHRcdFx0Y2hpbGRyZW4gOiBbXSxcblx0XHRcdFx0XHRjaGlsZHJlbl9kIDogW10sXG5cdFx0XHRcdFx0c3RhdGUgOiB7IGxvYWRlZCA6IGZhbHNlIH1cblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHRcdHZhciBjID0gdGhpcy5nZXRfY29udGFpbmVyX3VsKClbMF0uY2xhc3NOYW1lO1xuXHRcdFx0aWYoIXNraXBfbG9hZGluZykge1xuXHRcdFx0XHR0aGlzLmVsZW1lbnQuaHRtbChcIjxcIitcInVsIGNsYXNzPSdcIitjK1wiJz48XCIrXCJsaSBjbGFzcz0nanN0cmVlLWluaXRpYWwtbm9kZSBqc3RyZWUtbG9hZGluZyBqc3RyZWUtbGVhZiBqc3RyZWUtbGFzdCc+PGkgY2xhc3M9J2pzdHJlZS1pY29uIGpzdHJlZS1vY2wnPjwvaT48XCIrXCJhIGNsYXNzPSdqc3RyZWUtYW5jaG9yJyBocmVmPScjJz48aSBjbGFzcz0nanN0cmVlLWljb24ganN0cmVlLXRoZW1laWNvbi1oaWRkZW4nPjwvaT5cIiArIHRoaXMuZ2V0X3N0cmluZyhcIkxvYWRpbmcgLi4uXCIpICsgXCI8L2E+PC9saT48L3VsPlwiKTtcblx0XHRcdH1cblx0XHRcdHRoaXMubG9hZF9ub2RlKCcjJywgZnVuY3Rpb24gKG8sIHMpIHtcblx0XHRcdFx0aWYocykge1xuXHRcdFx0XHRcdHRoaXMuZ2V0X2NvbnRhaW5lcl91bCgpWzBdLmNsYXNzTmFtZSA9IGM7XG5cdFx0XHRcdFx0dGhpcy5zZXRfc3RhdGUoJC5leHRlbmQodHJ1ZSwge30sIHRoaXMuX2RhdGEuY29yZS5zdGF0ZSksIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRcdC8qKlxuXHRcdFx0XHRcdFx0ICogdHJpZ2dlcmVkIHdoZW4gYSBgcmVmcmVzaGAgY2FsbCBjb21wbGV0ZXNcblx0XHRcdFx0XHRcdCAqIEBldmVudFxuXHRcdFx0XHRcdFx0ICogQG5hbWUgcmVmcmVzaC5qc3RyZWVcblx0XHRcdFx0XHRcdCAqL1xuXHRcdFx0XHRcdFx0dGhpcy50cmlnZ2VyKCdyZWZyZXNoJyk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5fZGF0YS5jb3JlLnN0YXRlID0gbnVsbDtcblx0XHRcdH0pO1xuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogcmVmcmVzaGVzIGEgbm9kZSBpbiB0aGUgdHJlZSAocmVsb2FkIGl0cyBjaGlsZHJlbikgYWxsIG9wZW5lZCBub2RlcyBpbnNpZGUgdGhhdCBub2RlIGFyZSByZWxvYWRlZCB3aXRoIGNhbGxzIHRvIGBsb2FkX25vZGVgLlxuXHRcdCAqIEBuYW1lIHJlZnJlc2hfbm9kZShvYmopXG5cdFx0ICogQHBhcmFtICB7bWl4ZWR9IG9iaiB0aGUgbm9kZVxuXHRcdCAqIEB0cmlnZ2VyIHJlZnJlc2hfbm9kZS5qc3RyZWVcblx0XHQgKi9cblx0XHRyZWZyZXNoX25vZGUgOiBmdW5jdGlvbiAob2JqKSB7XG5cdFx0XHRvYmogPSB0aGlzLmdldF9ub2RlKG9iaik7XG5cdFx0XHRpZighb2JqIHx8IG9iai5pZCA9PT0gJyMnKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdFx0dmFyIG9wZW5lZCA9IFtdLCB0b19sb2FkID0gW10sIHMgPSB0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQuY29uY2F0KFtdKTtcblx0XHRcdHRvX2xvYWQucHVzaChvYmouaWQpO1xuXHRcdFx0aWYob2JqLnN0YXRlLm9wZW5lZCA9PT0gdHJ1ZSkgeyBvcGVuZWQucHVzaChvYmouaWQpOyB9XG5cdFx0XHR0aGlzLmdldF9ub2RlKG9iaiwgdHJ1ZSkuZmluZCgnLmpzdHJlZS1vcGVuJykuZWFjaChmdW5jdGlvbigpIHsgb3BlbmVkLnB1c2godGhpcy5pZCk7IH0pO1xuXHRcdFx0dGhpcy5fbG9hZF9ub2Rlcyh0b19sb2FkLCAkLnByb3h5KGZ1bmN0aW9uIChub2Rlcykge1xuXHRcdFx0XHR0aGlzLm9wZW5fbm9kZShvcGVuZWQsIGZhbHNlLCAwKTtcblx0XHRcdFx0dGhpcy5zZWxlY3Rfbm9kZSh0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQpO1xuXHRcdFx0XHQvKipcblx0XHRcdFx0ICogdHJpZ2dlcmVkIHdoZW4gYSBub2RlIGlzIHJlZnJlc2hlZFxuXHRcdFx0XHQgKiBAZXZlbnRcblx0XHRcdFx0ICogQG5hbWUgcmVmcmVzaF9ub2RlLmpzdHJlZVxuXHRcdFx0XHQgKiBAcGFyYW0ge09iamVjdH0gbm9kZSAtIHRoZSByZWZyZXNoZWQgbm9kZVxuXHRcdFx0XHQgKiBAcGFyYW0ge0FycmF5fSBub2RlcyAtIGFuIGFycmF5IG9mIHRoZSBJRHMgb2YgdGhlIG5vZGVzIHRoYXQgd2VyZSByZWxvYWRlZFxuXHRcdFx0XHQgKi9cblx0XHRcdFx0dGhpcy50cmlnZ2VyKCdyZWZyZXNoX25vZGUnLCB7ICdub2RlJyA6IG9iaiwgJ25vZGVzJyA6IG5vZGVzIH0pO1xuXHRcdFx0fSwgdGhpcykpO1xuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogc2V0IChjaGFuZ2UpIHRoZSBJRCBvZiBhIG5vZGVcblx0XHQgKiBAbmFtZSBzZXRfaWQob2JqLCBpZClcblx0XHQgKiBAcGFyYW0gIHttaXhlZH0gb2JqIHRoZSBub2RlXG5cdFx0ICogQHBhcmFtICB7U3RyaW5nfSBpZCB0aGUgbmV3IElEXG5cdFx0ICogQHJldHVybiB7Qm9vbGVhbn1cblx0XHQgKi9cblx0XHRzZXRfaWQgOiBmdW5jdGlvbiAob2JqLCBpZCkge1xuXHRcdFx0b2JqID0gdGhpcy5nZXRfbm9kZShvYmopO1xuXHRcdFx0aWYoIW9iaiB8fCBvYmouaWQgPT09ICcjJykgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRcdHZhciBpLCBqLCBtID0gdGhpcy5fbW9kZWwuZGF0YTtcblx0XHRcdGlkID0gaWQudG9TdHJpbmcoKTtcblx0XHRcdC8vIHVwZGF0ZSBwYXJlbnRzIChyZXBsYWNlIGN1cnJlbnQgSUQgd2l0aCBuZXcgb25lIGluIGNoaWxkcmVuIGFuZCBjaGlsZHJlbl9kKVxuXHRcdFx0bVtvYmoucGFyZW50XS5jaGlsZHJlblskLmluQXJyYXkob2JqLmlkLCBtW29iai5wYXJlbnRdLmNoaWxkcmVuKV0gPSBpZDtcblx0XHRcdGZvcihpID0gMCwgaiA9IG9iai5wYXJlbnRzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuXHRcdFx0XHRtW29iai5wYXJlbnRzW2ldXS5jaGlsZHJlbl9kWyQuaW5BcnJheShvYmouaWQsIG1bb2JqLnBhcmVudHNbaV1dLmNoaWxkcmVuX2QpXSA9IGlkO1xuXHRcdFx0fVxuXHRcdFx0Ly8gdXBkYXRlIGNoaWxkcmVuIChyZXBsYWNlIGN1cnJlbnQgSUQgd2l0aCBuZXcgb25lIGluIHBhcmVudCBhbmQgcGFyZW50cylcblx0XHRcdGZvcihpID0gMCwgaiA9IG9iai5jaGlsZHJlbi5sZW5ndGg7IGkgPCBqOyBpKyspIHtcblx0XHRcdFx0bVtvYmouY2hpbGRyZW5baV1dLnBhcmVudCA9IGlkO1xuXHRcdFx0fVxuXHRcdFx0Zm9yKGkgPSAwLCBqID0gb2JqLmNoaWxkcmVuX2QubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG5cdFx0XHRcdG1bb2JqLmNoaWxkcmVuX2RbaV1dLnBhcmVudHNbJC5pbkFycmF5KG9iai5pZCwgbVtvYmouY2hpbGRyZW5fZFtpXV0ucGFyZW50cyldID0gaWQ7XG5cdFx0XHR9XG5cdFx0XHRpID0gJC5pbkFycmF5KG9iai5pZCwgdGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkKTtcblx0XHRcdGlmKGkgIT09IC0xKSB7IHRoaXMuX2RhdGEuY29yZS5zZWxlY3RlZFtpXSA9IGlkOyB9XG5cdFx0XHQvLyB1cGRhdGUgbW9kZWwgYW5kIG9iaiBpdHNlbGYgKG9iai5pZCwgdGhpcy5fbW9kZWwuZGF0YVtLRVldKVxuXHRcdFx0aSA9IHRoaXMuZ2V0X25vZGUob2JqLmlkLCB0cnVlKTtcblx0XHRcdGlmKGkpIHtcblx0XHRcdFx0aS5hdHRyKCdpZCcsIGlkKTtcblx0XHRcdH1cblx0XHRcdGRlbGV0ZSBtW29iai5pZF07XG5cdFx0XHRvYmouaWQgPSBpZDtcblx0XHRcdG1baWRdID0gb2JqO1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSxcblx0XHQvKipcblx0XHQgKiBnZXQgdGhlIHRleHQgdmFsdWUgb2YgYSBub2RlXG5cdFx0ICogQG5hbWUgZ2V0X3RleHQob2JqKVxuXHRcdCAqIEBwYXJhbSAge21peGVkfSBvYmogdGhlIG5vZGVcblx0XHQgKiBAcmV0dXJuIHtTdHJpbmd9XG5cdFx0ICovXG5cdFx0Z2V0X3RleHQgOiBmdW5jdGlvbiAob2JqKSB7XG5cdFx0XHRvYmogPSB0aGlzLmdldF9ub2RlKG9iaik7XG5cdFx0XHRyZXR1cm4gKCFvYmogfHwgb2JqLmlkID09PSAnIycpID8gZmFsc2UgOiBvYmoudGV4dDtcblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIHNldCB0aGUgdGV4dCB2YWx1ZSBvZiBhIG5vZGUuIFVzZWQgaW50ZXJuYWxseSwgcGxlYXNlIHVzZSBgcmVuYW1lX25vZGUob2JqLCB2YWwpYC5cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqIEBuYW1lIHNldF90ZXh0KG9iaiwgdmFsKVxuXHRcdCAqIEBwYXJhbSAge21peGVkfSBvYmogdGhlIG5vZGUsIHlvdSBjYW4gcGFzcyBhbiBhcnJheSB0byBzZXQgdGhlIHRleHQgb24gbXVsdGlwbGUgbm9kZXNcblx0XHQgKiBAcGFyYW0gIHtTdHJpbmd9IHZhbCB0aGUgbmV3IHRleHQgdmFsdWVcblx0XHQgKiBAcmV0dXJuIHtCb29sZWFufVxuXHRcdCAqIEB0cmlnZ2VyIHNldF90ZXh0LmpzdHJlZVxuXHRcdCAqL1xuXHRcdHNldF90ZXh0IDogZnVuY3Rpb24gKG9iaiwgdmFsKSB7XG5cdFx0XHR2YXIgdDEsIHQyO1xuXHRcdFx0aWYoJC5pc0FycmF5KG9iaikpIHtcblx0XHRcdFx0b2JqID0gb2JqLnNsaWNlKCk7XG5cdFx0XHRcdGZvcih0MSA9IDAsIHQyID0gb2JqLmxlbmd0aDsgdDEgPCB0MjsgdDErKykge1xuXHRcdFx0XHRcdHRoaXMuc2V0X3RleHQob2JqW3QxXSwgdmFsKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdG9iaiA9IHRoaXMuZ2V0X25vZGUob2JqKTtcblx0XHRcdGlmKCFvYmogfHwgb2JqLmlkID09PSAnIycpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0XHRvYmoudGV4dCA9IHZhbDtcblx0XHRcdGlmKHRoaXMuZ2V0X25vZGUob2JqLCB0cnVlKS5sZW5ndGgpIHtcblx0XHRcdFx0dGhpcy5yZWRyYXdfbm9kZShvYmouaWQpO1xuXHRcdFx0fVxuXHRcdFx0LyoqXG5cdFx0XHQgKiB0cmlnZ2VyZWQgd2hlbiBhIG5vZGUgdGV4dCB2YWx1ZSBpcyBjaGFuZ2VkXG5cdFx0XHQgKiBAZXZlbnRcblx0XHRcdCAqIEBuYW1lIHNldF90ZXh0LmpzdHJlZVxuXHRcdFx0ICogQHBhcmFtIHtPYmplY3R9IG9ialxuXHRcdFx0ICogQHBhcmFtIHtTdHJpbmd9IHRleHQgdGhlIG5ldyB2YWx1ZVxuXHRcdFx0ICovXG5cdFx0XHR0aGlzLnRyaWdnZXIoJ3NldF90ZXh0Jyx7IFwib2JqXCIgOiBvYmosIFwidGV4dFwiIDogdmFsIH0pO1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSxcblx0XHQvKipcblx0XHQgKiBnZXRzIGEgSlNPTiByZXByZXNlbnRhdGlvbiBvZiBhIG5vZGUgKG9yIHRoZSB3aG9sZSB0cmVlKVxuXHRcdCAqIEBuYW1lIGdldF9qc29uKFtvYmosIG9wdGlvbnNdKVxuXHRcdCAqIEBwYXJhbSAge21peGVkfSBvYmpcblx0XHQgKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnNcblx0XHQgKiBAcGFyYW0gIHtCb29sZWFufSBvcHRpb25zLm5vX3N0YXRlIGRvIG5vdCByZXR1cm4gc3RhdGUgaW5mb3JtYXRpb25cblx0XHQgKiBAcGFyYW0gIHtCb29sZWFufSBvcHRpb25zLm5vX2lkIGRvIG5vdCByZXR1cm4gSURcblx0XHQgKiBAcGFyYW0gIHtCb29sZWFufSBvcHRpb25zLm5vX2NoaWxkcmVuIGRvIG5vdCBpbmNsdWRlIGNoaWxkcmVuXG5cdFx0ICogQHBhcmFtICB7Qm9vbGVhbn0gb3B0aW9ucy5ub19kYXRhIGRvIG5vdCBpbmNsdWRlIG5vZGUgZGF0YVxuXHRcdCAqIEBwYXJhbSAge0Jvb2xlYW59IG9wdGlvbnMuZmxhdCByZXR1cm4gZmxhdCBKU09OIGluc3RlYWQgb2YgbmVzdGVkXG5cdFx0ICogQHJldHVybiB7T2JqZWN0fVxuXHRcdCAqL1xuXHRcdGdldF9qc29uIDogZnVuY3Rpb24gKG9iaiwgb3B0aW9ucywgZmxhdCkge1xuXHRcdFx0b2JqID0gdGhpcy5nZXRfbm9kZShvYmogfHwgJyMnKTtcblx0XHRcdGlmKCFvYmopIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0XHRpZihvcHRpb25zICYmIG9wdGlvbnMuZmxhdCAmJiAhZmxhdCkgeyBmbGF0ID0gW107IH1cblx0XHRcdHZhciB0bXAgPSB7XG5cdFx0XHRcdCdpZCcgOiBvYmouaWQsXG5cdFx0XHRcdCd0ZXh0JyA6IG9iai50ZXh0LFxuXHRcdFx0XHQnaWNvbicgOiB0aGlzLmdldF9pY29uKG9iaiksXG5cdFx0XHRcdCdsaV9hdHRyJyA6IG9iai5saV9hdHRyLFxuXHRcdFx0XHQnYV9hdHRyJyA6IG9iai5hX2F0dHIsXG5cdFx0XHRcdCdzdGF0ZScgOiB7fSxcblx0XHRcdFx0J2RhdGEnIDogb3B0aW9ucyAmJiBvcHRpb25zLm5vX2RhdGEgPyBmYWxzZSA6IG9iai5kYXRhXG5cdFx0XHRcdC8vKCB0aGlzLmdldF9ub2RlKG9iaiwgdHJ1ZSkubGVuZ3RoID8gdGhpcy5nZXRfbm9kZShvYmosIHRydWUpLmRhdGEoKSA6IG9iai5kYXRhICksXG5cdFx0XHR9LCBpLCBqO1xuXHRcdFx0aWYob3B0aW9ucyAmJiBvcHRpb25zLmZsYXQpIHtcblx0XHRcdFx0dG1wLnBhcmVudCA9IG9iai5wYXJlbnQ7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0dG1wLmNoaWxkcmVuID0gW107XG5cdFx0XHR9XG5cdFx0XHRpZighb3B0aW9ucyB8fCAhb3B0aW9ucy5ub19zdGF0ZSkge1xuXHRcdFx0XHRmb3IoaSBpbiBvYmouc3RhdGUpIHtcblx0XHRcdFx0XHRpZihvYmouc3RhdGUuaGFzT3duUHJvcGVydHkoaSkpIHtcblx0XHRcdFx0XHRcdHRtcC5zdGF0ZVtpXSA9IG9iai5zdGF0ZVtpXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmKG9wdGlvbnMgJiYgb3B0aW9ucy5ub19pZCkge1xuXHRcdFx0XHRkZWxldGUgdG1wLmlkO1xuXHRcdFx0XHRpZih0bXAubGlfYXR0ciAmJiB0bXAubGlfYXR0ci5pZCkge1xuXHRcdFx0XHRcdGRlbGV0ZSB0bXAubGlfYXR0ci5pZDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYob3B0aW9ucyAmJiBvcHRpb25zLmZsYXQgJiYgb2JqLmlkICE9PSAnIycpIHtcblx0XHRcdFx0ZmxhdC5wdXNoKHRtcCk7XG5cdFx0XHR9XG5cdFx0XHRpZighb3B0aW9ucyB8fCAhb3B0aW9ucy5ub19jaGlsZHJlbikge1xuXHRcdFx0XHRmb3IoaSA9IDAsIGogPSBvYmouY2hpbGRyZW4ubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG5cdFx0XHRcdFx0aWYob3B0aW9ucyAmJiBvcHRpb25zLmZsYXQpIHtcblx0XHRcdFx0XHRcdHRoaXMuZ2V0X2pzb24ob2JqLmNoaWxkcmVuW2ldLCBvcHRpb25zLCBmbGF0KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHR0bXAuY2hpbGRyZW4ucHVzaCh0aGlzLmdldF9qc29uKG9iai5jaGlsZHJlbltpXSwgb3B0aW9ucykpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG9wdGlvbnMgJiYgb3B0aW9ucy5mbGF0ID8gZmxhdCA6IChvYmouaWQgPT09ICcjJyA/IHRtcC5jaGlsZHJlbiA6IHRtcCk7XG5cdFx0fSxcblx0XHQvKipcblx0XHQgKiBjcmVhdGUgYSBuZXcgbm9kZSAoZG8gbm90IGNvbmZ1c2Ugd2l0aCBsb2FkX25vZGUpXG5cdFx0ICogQG5hbWUgY3JlYXRlX25vZGUoW29iaiwgbm9kZSwgcG9zLCBjYWxsYmFjaywgaXNfbG9hZGVkXSlcblx0XHQgKiBAcGFyYW0gIHttaXhlZH0gICBwYXIgICAgICAgdGhlIHBhcmVudCBub2RlICh0byBjcmVhdGUgYSByb290IG5vZGUgdXNlIGVpdGhlciBcIiNcIiAoc3RyaW5nKSBvciBgbnVsbGApXG5cdFx0ICogQHBhcmFtICB7bWl4ZWR9ICAgbm9kZSAgICAgIHRoZSBkYXRhIGZvciB0aGUgbmV3IG5vZGUgKGEgdmFsaWQgSlNPTiBvYmplY3QsIG9yIGEgc2ltcGxlIHN0cmluZyB3aXRoIHRoZSBuYW1lKVxuXHRcdCAqIEBwYXJhbSAge21peGVkfSAgIHBvcyAgICAgICB0aGUgaW5kZXggYXQgd2hpY2ggdG8gaW5zZXJ0IHRoZSBub2RlLCBcImZpcnN0XCIgYW5kIFwibGFzdFwiIGFyZSBhbHNvIHN1cHBvcnRlZCwgZGVmYXVsdCBpcyBcImxhc3RcIlxuXHRcdCAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYWxsYmFjayBhIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBvbmNlIHRoZSBub2RlIGlzIGNyZWF0ZWRcblx0XHQgKiBAcGFyYW0gIHtCb29sZWFufSBpc19sb2FkZWQgaW50ZXJuYWwgYXJndW1lbnQgaW5kaWNhdGluZyBpZiB0aGUgcGFyZW50IG5vZGUgd2FzIHN1Y2Nlc2Z1bGx5IGxvYWRlZFxuXHRcdCAqIEByZXR1cm4ge1N0cmluZ30gICAgICAgICAgICB0aGUgSUQgb2YgdGhlIG5ld2x5IGNyZWF0ZSBub2RlXG5cdFx0ICogQHRyaWdnZXIgbW9kZWwuanN0cmVlLCBjcmVhdGVfbm9kZS5qc3RyZWVcblx0XHQgKi9cblx0XHRjcmVhdGVfbm9kZSA6IGZ1bmN0aW9uIChwYXIsIG5vZGUsIHBvcywgY2FsbGJhY2ssIGlzX2xvYWRlZCkge1xuXHRcdFx0aWYocGFyID09PSBudWxsKSB7IHBhciA9IFwiI1wiOyB9XG5cdFx0XHRwYXIgPSB0aGlzLmdldF9ub2RlKHBhcik7XG5cdFx0XHRpZighcGFyKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdFx0cG9zID0gcG9zID09PSB1bmRlZmluZWQgPyBcImxhc3RcIiA6IHBvcztcblx0XHRcdGlmKCFwb3MudG9TdHJpbmcoKS5tYXRjaCgvXihiZWZvcmV8YWZ0ZXIpJC8pICYmICFpc19sb2FkZWQgJiYgIXRoaXMuaXNfbG9hZGVkKHBhcikpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMubG9hZF9ub2RlKHBhciwgZnVuY3Rpb24gKCkgeyB0aGlzLmNyZWF0ZV9ub2RlKHBhciwgbm9kZSwgcG9zLCBjYWxsYmFjaywgdHJ1ZSk7IH0pO1xuXHRcdFx0fVxuXHRcdFx0aWYoIW5vZGUpIHsgbm9kZSA9IHsgXCJ0ZXh0XCIgOiB0aGlzLmdldF9zdHJpbmcoJ05ldyBub2RlJykgfTsgfVxuXHRcdFx0aWYobm9kZS50ZXh0ID09PSB1bmRlZmluZWQpIHsgbm9kZS50ZXh0ID0gdGhpcy5nZXRfc3RyaW5nKCdOZXcgbm9kZScpOyB9XG5cdFx0XHR2YXIgdG1wLCBkcGMsIGksIGo7XG5cblx0XHRcdGlmKHBhci5pZCA9PT0gJyMnKSB7XG5cdFx0XHRcdGlmKHBvcyA9PT0gXCJiZWZvcmVcIikgeyBwb3MgPSBcImZpcnN0XCI7IH1cblx0XHRcdFx0aWYocG9zID09PSBcImFmdGVyXCIpIHsgcG9zID0gXCJsYXN0XCI7IH1cblx0XHRcdH1cblx0XHRcdHN3aXRjaChwb3MpIHtcblx0XHRcdFx0Y2FzZSBcImJlZm9yZVwiOlxuXHRcdFx0XHRcdHRtcCA9IHRoaXMuZ2V0X25vZGUocGFyLnBhcmVudCk7XG5cdFx0XHRcdFx0cG9zID0gJC5pbkFycmF5KHBhci5pZCwgdG1wLmNoaWxkcmVuKTtcblx0XHRcdFx0XHRwYXIgPSB0bXA7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgXCJhZnRlclwiIDpcblx0XHRcdFx0XHR0bXAgPSB0aGlzLmdldF9ub2RlKHBhci5wYXJlbnQpO1xuXHRcdFx0XHRcdHBvcyA9ICQuaW5BcnJheShwYXIuaWQsIHRtcC5jaGlsZHJlbikgKyAxO1xuXHRcdFx0XHRcdHBhciA9IHRtcDtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBcImluc2lkZVwiOlxuXHRcdFx0XHRjYXNlIFwiZmlyc3RcIjpcblx0XHRcdFx0XHRwb3MgPSAwO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIFwibGFzdFwiOlxuXHRcdFx0XHRcdHBvcyA9IHBhci5jaGlsZHJlbi5sZW5ndGg7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0aWYoIXBvcykgeyBwb3MgPSAwOyB9XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRpZihwb3MgPiBwYXIuY2hpbGRyZW4ubGVuZ3RoKSB7IHBvcyA9IHBhci5jaGlsZHJlbi5sZW5ndGg7IH1cblx0XHRcdGlmKCFub2RlLmlkKSB7IG5vZGUuaWQgPSB0cnVlOyB9XG5cdFx0XHRpZighdGhpcy5jaGVjayhcImNyZWF0ZV9ub2RlXCIsIG5vZGUsIHBhciwgcG9zKSkge1xuXHRcdFx0XHR0aGlzLnNldHRpbmdzLmNvcmUuZXJyb3IuY2FsbCh0aGlzLCB0aGlzLl9kYXRhLmNvcmUubGFzdF9lcnJvcik7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdGlmKG5vZGUuaWQgPT09IHRydWUpIHsgZGVsZXRlIG5vZGUuaWQ7IH1cblx0XHRcdG5vZGUgPSB0aGlzLl9wYXJzZV9tb2RlbF9mcm9tX2pzb24obm9kZSwgcGFyLmlkLCBwYXIucGFyZW50cy5jb25jYXQoKSk7XG5cdFx0XHRpZighbm9kZSkgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRcdHRtcCA9IHRoaXMuZ2V0X25vZGUobm9kZSk7XG5cdFx0XHRkcGMgPSBbXTtcblx0XHRcdGRwYy5wdXNoKG5vZGUpO1xuXHRcdFx0ZHBjID0gZHBjLmNvbmNhdCh0bXAuY2hpbGRyZW5fZCk7XG5cdFx0XHR0aGlzLnRyaWdnZXIoJ21vZGVsJywgeyBcIm5vZGVzXCIgOiBkcGMsIFwicGFyZW50XCIgOiBwYXIuaWQgfSk7XG5cblx0XHRcdHBhci5jaGlsZHJlbl9kID0gcGFyLmNoaWxkcmVuX2QuY29uY2F0KGRwYyk7XG5cdFx0XHRmb3IoaSA9IDAsIGogPSBwYXIucGFyZW50cy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcblx0XHRcdFx0dGhpcy5fbW9kZWwuZGF0YVtwYXIucGFyZW50c1tpXV0uY2hpbGRyZW5fZCA9IHRoaXMuX21vZGVsLmRhdGFbcGFyLnBhcmVudHNbaV1dLmNoaWxkcmVuX2QuY29uY2F0KGRwYyk7XG5cdFx0XHR9XG5cdFx0XHRub2RlID0gdG1wO1xuXHRcdFx0dG1wID0gW107XG5cdFx0XHRmb3IoaSA9IDAsIGogPSBwYXIuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG5cdFx0XHRcdHRtcFtpID49IHBvcyA/IGkrMSA6IGldID0gcGFyLmNoaWxkcmVuW2ldO1xuXHRcdFx0fVxuXHRcdFx0dG1wW3Bvc10gPSBub2RlLmlkO1xuXHRcdFx0cGFyLmNoaWxkcmVuID0gdG1wO1xuXG5cdFx0XHR0aGlzLnJlZHJhd19ub2RlKHBhciwgdHJ1ZSk7XG5cdFx0XHRpZihjYWxsYmFjaykgeyBjYWxsYmFjay5jYWxsKHRoaXMsIHRoaXMuZ2V0X25vZGUobm9kZSkpOyB9XG5cdFx0XHQvKipcblx0XHRcdCAqIHRyaWdnZXJlZCB3aGVuIGEgbm9kZSBpcyBjcmVhdGVkXG5cdFx0XHQgKiBAZXZlbnRcblx0XHRcdCAqIEBuYW1lIGNyZWF0ZV9ub2RlLmpzdHJlZVxuXHRcdFx0ICogQHBhcmFtIHtPYmplY3R9IG5vZGVcblx0XHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBwYXJlbnQgdGhlIHBhcmVudCdzIElEXG5cdFx0XHQgKiBAcGFyYW0ge051bWJlcn0gcG9zaXRpb24gdGhlIHBvc2l0aW9uIG9mIHRoZSBuZXcgbm9kZSBhbW9uZyB0aGUgcGFyZW50J3MgY2hpbGRyZW5cblx0XHRcdCAqL1xuXHRcdFx0dGhpcy50cmlnZ2VyKCdjcmVhdGVfbm9kZScsIHsgXCJub2RlXCIgOiB0aGlzLmdldF9ub2RlKG5vZGUpLCBcInBhcmVudFwiIDogcGFyLmlkLCBcInBvc2l0aW9uXCIgOiBwb3MgfSk7XG5cdFx0XHRyZXR1cm4gbm9kZS5pZDtcblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIHNldCB0aGUgdGV4dCB2YWx1ZSBvZiBhIG5vZGVcblx0XHQgKiBAbmFtZSByZW5hbWVfbm9kZShvYmosIHZhbClcblx0XHQgKiBAcGFyYW0gIHttaXhlZH0gb2JqIHRoZSBub2RlLCB5b3UgY2FuIHBhc3MgYW4gYXJyYXkgdG8gcmVuYW1lIG11bHRpcGxlIG5vZGVzIHRvIHRoZSBzYW1lIG5hbWVcblx0XHQgKiBAcGFyYW0gIHtTdHJpbmd9IHZhbCB0aGUgbmV3IHRleHQgdmFsdWVcblx0XHQgKiBAcmV0dXJuIHtCb29sZWFufVxuXHRcdCAqIEB0cmlnZ2VyIHJlbmFtZV9ub2RlLmpzdHJlZVxuXHRcdCAqL1xuXHRcdHJlbmFtZV9ub2RlIDogZnVuY3Rpb24gKG9iaiwgdmFsKSB7XG5cdFx0XHR2YXIgdDEsIHQyLCBvbGQ7XG5cdFx0XHRpZigkLmlzQXJyYXkob2JqKSkge1xuXHRcdFx0XHRvYmogPSBvYmouc2xpY2UoKTtcblx0XHRcdFx0Zm9yKHQxID0gMCwgdDIgPSBvYmoubGVuZ3RoOyB0MSA8IHQyOyB0MSsrKSB7XG5cdFx0XHRcdFx0dGhpcy5yZW5hbWVfbm9kZShvYmpbdDFdLCB2YWwpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0b2JqID0gdGhpcy5nZXRfbm9kZShvYmopO1xuXHRcdFx0aWYoIW9iaiB8fCBvYmouaWQgPT09ICcjJykgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRcdG9sZCA9IG9iai50ZXh0O1xuXHRcdFx0aWYoIXRoaXMuY2hlY2soXCJyZW5hbWVfbm9kZVwiLCBvYmosIHRoaXMuZ2V0X3BhcmVudChvYmopLCB2YWwpKSB7XG5cdFx0XHRcdHRoaXMuc2V0dGluZ3MuY29yZS5lcnJvci5jYWxsKHRoaXMsIHRoaXMuX2RhdGEuY29yZS5sYXN0X2Vycm9yKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5zZXRfdGV4dChvYmosIHZhbCk7IC8vIC5hcHBseSh0aGlzLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpKVxuXHRcdFx0LyoqXG5cdFx0XHQgKiB0cmlnZ2VyZWQgd2hlbiBhIG5vZGUgaXMgcmVuYW1lZFxuXHRcdFx0ICogQGV2ZW50XG5cdFx0XHQgKiBAbmFtZSByZW5hbWVfbm9kZS5qc3RyZWVcblx0XHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBub2RlXG5cdFx0XHQgKiBAcGFyYW0ge1N0cmluZ30gdGV4dCB0aGUgbmV3IHZhbHVlXG5cdFx0XHQgKiBAcGFyYW0ge1N0cmluZ30gb2xkIHRoZSBvbGQgdmFsdWVcblx0XHRcdCAqL1xuXHRcdFx0dGhpcy50cmlnZ2VyKCdyZW5hbWVfbm9kZScsIHsgXCJub2RlXCIgOiBvYmosIFwidGV4dFwiIDogdmFsLCBcIm9sZFwiIDogb2xkIH0pO1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSxcblx0XHQvKipcblx0XHQgKiByZW1vdmUgYSBub2RlXG5cdFx0ICogQG5hbWUgZGVsZXRlX25vZGUob2JqKVxuXHRcdCAqIEBwYXJhbSAge21peGVkfSBvYmogdGhlIG5vZGUsIHlvdSBjYW4gcGFzcyBhbiBhcnJheSB0byBkZWxldGUgbXVsdGlwbGUgbm9kZXNcblx0XHQgKiBAcmV0dXJuIHtCb29sZWFufVxuXHRcdCAqIEB0cmlnZ2VyIGRlbGV0ZV9ub2RlLmpzdHJlZSwgY2hhbmdlZC5qc3RyZWVcblx0XHQgKi9cblx0XHRkZWxldGVfbm9kZSA6IGZ1bmN0aW9uIChvYmopIHtcblx0XHRcdHZhciB0MSwgdDIsIHBhciwgcG9zLCB0bXAsIGksIGosIGssIGwsIGM7XG5cdFx0XHRpZigkLmlzQXJyYXkob2JqKSkge1xuXHRcdFx0XHRvYmogPSBvYmouc2xpY2UoKTtcblx0XHRcdFx0Zm9yKHQxID0gMCwgdDIgPSBvYmoubGVuZ3RoOyB0MSA8IHQyOyB0MSsrKSB7XG5cdFx0XHRcdFx0dGhpcy5kZWxldGVfbm9kZShvYmpbdDFdKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdG9iaiA9IHRoaXMuZ2V0X25vZGUob2JqKTtcblx0XHRcdGlmKCFvYmogfHwgb2JqLmlkID09PSAnIycpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0XHRwYXIgPSB0aGlzLmdldF9ub2RlKG9iai5wYXJlbnQpO1xuXHRcdFx0cG9zID0gJC5pbkFycmF5KG9iai5pZCwgcGFyLmNoaWxkcmVuKTtcblx0XHRcdGMgPSBmYWxzZTtcblx0XHRcdGlmKCF0aGlzLmNoZWNrKFwiZGVsZXRlX25vZGVcIiwgb2JqLCBwYXIsIHBvcykpIHtcblx0XHRcdFx0dGhpcy5zZXR0aW5ncy5jb3JlLmVycm9yLmNhbGwodGhpcywgdGhpcy5fZGF0YS5jb3JlLmxhc3RfZXJyb3IpO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHRpZihwb3MgIT09IC0xKSB7XG5cdFx0XHRcdHBhci5jaGlsZHJlbiA9ICQudmFrYXRhLmFycmF5X3JlbW92ZShwYXIuY2hpbGRyZW4sIHBvcyk7XG5cdFx0XHR9XG5cdFx0XHR0bXAgPSBvYmouY2hpbGRyZW5fZC5jb25jYXQoW10pO1xuXHRcdFx0dG1wLnB1c2gob2JqLmlkKTtcblx0XHRcdGZvcihrID0gMCwgbCA9IHRtcC5sZW5ndGg7IGsgPCBsOyBrKyspIHtcblx0XHRcdFx0Zm9yKGkgPSAwLCBqID0gb2JqLnBhcmVudHMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG5cdFx0XHRcdFx0cG9zID0gJC5pbkFycmF5KHRtcFtrXSwgdGhpcy5fbW9kZWwuZGF0YVtvYmoucGFyZW50c1tpXV0uY2hpbGRyZW5fZCk7XG5cdFx0XHRcdFx0aWYocG9zICE9PSAtMSkge1xuXHRcdFx0XHRcdFx0dGhpcy5fbW9kZWwuZGF0YVtvYmoucGFyZW50c1tpXV0uY2hpbGRyZW5fZCA9ICQudmFrYXRhLmFycmF5X3JlbW92ZSh0aGlzLl9tb2RlbC5kYXRhW29iai5wYXJlbnRzW2ldXS5jaGlsZHJlbl9kLCBwb3MpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZih0aGlzLl9tb2RlbC5kYXRhW3RtcFtrXV0uc3RhdGUuc2VsZWN0ZWQpIHtcblx0XHRcdFx0XHRjID0gdHJ1ZTtcblx0XHRcdFx0XHRwb3MgPSAkLmluQXJyYXkodG1wW2tdLCB0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQpO1xuXHRcdFx0XHRcdGlmKHBvcyAhPT0gLTEpIHtcblx0XHRcdFx0XHRcdHRoaXMuX2RhdGEuY29yZS5zZWxlY3RlZCA9ICQudmFrYXRhLmFycmF5X3JlbW92ZSh0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQsIHBvcyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHQvKipcblx0XHRcdCAqIHRyaWdnZXJlZCB3aGVuIGEgbm9kZSBpcyBkZWxldGVkXG5cdFx0XHQgKiBAZXZlbnRcblx0XHRcdCAqIEBuYW1lIGRlbGV0ZV9ub2RlLmpzdHJlZVxuXHRcdFx0ICogQHBhcmFtIHtPYmplY3R9IG5vZGVcblx0XHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBwYXJlbnQgdGhlIHBhcmVudCdzIElEXG5cdFx0XHQgKi9cblx0XHRcdHRoaXMudHJpZ2dlcignZGVsZXRlX25vZGUnLCB7IFwibm9kZVwiIDogb2JqLCBcInBhcmVudFwiIDogcGFyLmlkIH0pO1xuXHRcdFx0aWYoYykge1xuXHRcdFx0XHR0aGlzLnRyaWdnZXIoJ2NoYW5nZWQnLCB7ICdhY3Rpb24nIDogJ2RlbGV0ZV9ub2RlJywgJ25vZGUnIDogb2JqLCAnc2VsZWN0ZWQnIDogdGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkLCAncGFyZW50JyA6IHBhci5pZCB9KTtcblx0XHRcdH1cblx0XHRcdGZvcihrID0gMCwgbCA9IHRtcC5sZW5ndGg7IGsgPCBsOyBrKyspIHtcblx0XHRcdFx0ZGVsZXRlIHRoaXMuX21vZGVsLmRhdGFbdG1wW2tdXTtcblx0XHRcdH1cblx0XHRcdHRoaXMucmVkcmF3X25vZGUocGFyLCB0cnVlKTtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogY2hlY2sgaWYgYW4gb3BlcmF0aW9uIGlzIHByZW1pdHRlZCBvbiB0aGUgdHJlZS4gVXNlZCBpbnRlcm5hbGx5LlxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICogQG5hbWUgY2hlY2soY2hrLCBvYmosIHBhciwgcG9zKVxuXHRcdCAqIEBwYXJhbSAge1N0cmluZ30gY2hrIHRoZSBvcGVyYXRpb24gdG8gY2hlY2ssIGNhbiBiZSBcImNyZWF0ZV9ub2RlXCIsIFwicmVuYW1lX25vZGVcIiwgXCJkZWxldGVfbm9kZVwiLCBcImNvcHlfbm9kZVwiIG9yIFwibW92ZV9ub2RlXCJcblx0XHQgKiBAcGFyYW0gIHttaXhlZH0gb2JqIHRoZSBub2RlXG5cdFx0ICogQHBhcmFtICB7bWl4ZWR9IHBhciB0aGUgcGFyZW50XG5cdFx0ICogQHBhcmFtICB7bWl4ZWR9IHBvcyB0aGUgcG9zaXRpb24gdG8gaW5zZXJ0IGF0LCBvciBpZiBcInJlbmFtZV9ub2RlXCIgLSB0aGUgbmV3IG5hbWVcblx0XHQgKiBAcGFyYW0gIHttaXhlZH0gbW9yZSBzb21lIHZhcmlvdXMgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiwgZm9yIGV4YW1wbGUgaWYgYSBcIm1vdmVfbm9kZVwiIG9wZXJhdGlvbnMgaXMgdHJpZ2dlcmVkIGJ5IERORCB0aGlzIHdpbGwgYmUgdGhlIGhvdmVyZWQgbm9kZVxuXHRcdCAqIEByZXR1cm4ge0Jvb2xlYW59XG5cdFx0ICovXG5cdFx0Y2hlY2sgOiBmdW5jdGlvbiAoY2hrLCBvYmosIHBhciwgcG9zLCBtb3JlKSB7XG5cdFx0XHRvYmogPSBvYmogJiYgb2JqLmlkID8gb2JqIDogdGhpcy5nZXRfbm9kZShvYmopO1xuXHRcdFx0cGFyID0gcGFyICYmIHBhci5pZCA/IHBhciA6IHRoaXMuZ2V0X25vZGUocGFyKTtcblx0XHRcdHZhciB0bXAgPSBjaGsubWF0Y2goL15tb3ZlX25vZGV8Y29weV9ub2RlfGNyZWF0ZV9ub2RlJC9pKSA/IHBhciA6IG9iaixcblx0XHRcdFx0Y2hjID0gdGhpcy5zZXR0aW5ncy5jb3JlLmNoZWNrX2NhbGxiYWNrO1xuXHRcdFx0aWYoY2hrID09PSBcIm1vdmVfbm9kZVwiIHx8IGNoayA9PT0gXCJjb3B5X25vZGVcIikge1xuXHRcdFx0XHRpZigoIW1vcmUgfHwgIW1vcmUuaXNfbXVsdGkpICYmIChvYmouaWQgPT09IHBhci5pZCB8fCAkLmluQXJyYXkob2JqLmlkLCBwYXIuY2hpbGRyZW4pID09PSBwb3MgfHwgJC5pbkFycmF5KHBhci5pZCwgb2JqLmNoaWxkcmVuX2QpICE9PSAtMSkpIHtcblx0XHRcdFx0XHR0aGlzLl9kYXRhLmNvcmUubGFzdF9lcnJvciA9IHsgJ2Vycm9yJyA6ICdjaGVjaycsICdwbHVnaW4nIDogJ2NvcmUnLCAnaWQnIDogJ2NvcmVfMDEnLCAncmVhc29uJyA6ICdNb3ZpbmcgcGFyZW50IGluc2lkZSBjaGlsZCcsICdkYXRhJyA6IEpTT04uc3RyaW5naWZ5KHsgJ2NoaycgOiBjaGssICdwb3MnIDogcG9zLCAnb2JqJyA6IG9iaiAmJiBvYmouaWQgPyBvYmouaWQgOiBmYWxzZSwgJ3BhcicgOiBwYXIgJiYgcGFyLmlkID8gcGFyLmlkIDogZmFsc2UgfSkgfTtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmKHRtcCAmJiB0bXAuZGF0YSkgeyB0bXAgPSB0bXAuZGF0YTsgfVxuXHRcdFx0aWYodG1wICYmIHRtcC5mdW5jdGlvbnMgJiYgKHRtcC5mdW5jdGlvbnNbY2hrXSA9PT0gZmFsc2UgfHwgdG1wLmZ1bmN0aW9uc1tjaGtdID09PSB0cnVlKSkge1xuXHRcdFx0XHRpZih0bXAuZnVuY3Rpb25zW2Noa10gPT09IGZhbHNlKSB7XG5cdFx0XHRcdFx0dGhpcy5fZGF0YS5jb3JlLmxhc3RfZXJyb3IgPSB7ICdlcnJvcicgOiAnY2hlY2snLCAncGx1Z2luJyA6ICdjb3JlJywgJ2lkJyA6ICdjb3JlXzAyJywgJ3JlYXNvbicgOiAnTm9kZSBkYXRhIHByZXZlbnRzIGZ1bmN0aW9uOiAnICsgY2hrLCAnZGF0YScgOiBKU09OLnN0cmluZ2lmeSh7ICdjaGsnIDogY2hrLCAncG9zJyA6IHBvcywgJ29iaicgOiBvYmogJiYgb2JqLmlkID8gb2JqLmlkIDogZmFsc2UsICdwYXInIDogcGFyICYmIHBhci5pZCA/IHBhci5pZCA6IGZhbHNlIH0pIH07XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRtcC5mdW5jdGlvbnNbY2hrXTtcblx0XHRcdH1cblx0XHRcdGlmKGNoYyA9PT0gZmFsc2UgfHwgKCQuaXNGdW5jdGlvbihjaGMpICYmIGNoYy5jYWxsKHRoaXMsIGNoaywgb2JqLCBwYXIsIHBvcywgbW9yZSkgPT09IGZhbHNlKSB8fCAoY2hjICYmIGNoY1tjaGtdID09PSBmYWxzZSkpIHtcblx0XHRcdFx0dGhpcy5fZGF0YS5jb3JlLmxhc3RfZXJyb3IgPSB7ICdlcnJvcicgOiAnY2hlY2snLCAncGx1Z2luJyA6ICdjb3JlJywgJ2lkJyA6ICdjb3JlXzAzJywgJ3JlYXNvbicgOiAnVXNlciBjb25maWcgZm9yIGNvcmUuY2hlY2tfY2FsbGJhY2sgcHJldmVudHMgZnVuY3Rpb246ICcgKyBjaGssICdkYXRhJyA6IEpTT04uc3RyaW5naWZ5KHsgJ2NoaycgOiBjaGssICdwb3MnIDogcG9zLCAnb2JqJyA6IG9iaiAmJiBvYmouaWQgPyBvYmouaWQgOiBmYWxzZSwgJ3BhcicgOiBwYXIgJiYgcGFyLmlkID8gcGFyLmlkIDogZmFsc2UgfSkgfTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSxcblx0XHQvKipcblx0XHQgKiBnZXQgdGhlIGxhc3QgZXJyb3Jcblx0XHQgKiBAbmFtZSBsYXN0X2Vycm9yKClcblx0XHQgKiBAcmV0dXJuIHtPYmplY3R9XG5cdFx0ICovXG5cdFx0bGFzdF9lcnJvciA6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiB0aGlzLl9kYXRhLmNvcmUubGFzdF9lcnJvcjtcblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIG1vdmUgYSBub2RlIHRvIGEgbmV3IHBhcmVudFxuXHRcdCAqIEBuYW1lIG1vdmVfbm9kZShvYmosIHBhciBbLCBwb3MsIGNhbGxiYWNrLCBpc19sb2FkZWRdKVxuXHRcdCAqIEBwYXJhbSAge21peGVkfSBvYmogdGhlIG5vZGUgdG8gbW92ZSwgcGFzcyBhbiBhcnJheSB0byBtb3ZlIG11bHRpcGxlIG5vZGVzXG5cdFx0ICogQHBhcmFtICB7bWl4ZWR9IHBhciB0aGUgbmV3IHBhcmVudFxuXHRcdCAqIEBwYXJhbSAge21peGVkfSBwb3MgdGhlIHBvc2l0aW9uIHRvIGluc2VydCBhdCAoYmVzaWRlcyBpbnRlZ2VyIHZhbHVlcywgXCJmaXJzdFwiIGFuZCBcImxhc3RcIiBhcmUgc3VwcG9ydGVkLCBhcyB3ZWxsIGFzIFwiYmVmb3JlXCIgYW5kIFwiYWZ0ZXJcIiksIGRlZmF1bHRzIHRvIGludGVnZXIgYDBgXG5cdFx0ICogQHBhcmFtICB7ZnVuY3Rpb259IGNhbGxiYWNrIGEgZnVuY3Rpb24gdG8gY2FsbCBvbmNlIHRoZSBtb3ZlIGlzIGNvbXBsZXRlZCwgcmVjZWl2ZXMgMyBhcmd1bWVudHMgLSB0aGUgbm9kZSwgdGhlIG5ldyBwYXJlbnQgYW5kIHRoZSBwb3NpdGlvblxuXHRcdCAqIEBwYXJhbSAge0Jvb2xlYW59IGludGVybmFsIHBhcmFtZXRlciBpbmRpY2F0aW5nIGlmIHRoZSBwYXJlbnQgbm9kZSBoYXMgYmVlbiBsb2FkZWRcblx0XHQgKiBAdHJpZ2dlciBtb3ZlX25vZGUuanN0cmVlXG5cdFx0ICovXG5cdFx0bW92ZV9ub2RlIDogZnVuY3Rpb24gKG9iaiwgcGFyLCBwb3MsIGNhbGxiYWNrLCBpc19sb2FkZWQpIHtcblx0XHRcdHZhciB0MSwgdDIsIG9sZF9wYXIsIG9sZF9wb3MsIG5ld19wYXIsIG9sZF9pbnMsIGlzX211bHRpLCBkcGMsIHRtcCwgaSwgaiwgaywgbCwgcDtcblxuXHRcdFx0cGFyID0gdGhpcy5nZXRfbm9kZShwYXIpO1xuXHRcdFx0cG9zID0gcG9zID09PSB1bmRlZmluZWQgPyAwIDogcG9zO1xuXHRcdFx0aWYoIXBhcikgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRcdGlmKCFwb3MudG9TdHJpbmcoKS5tYXRjaCgvXihiZWZvcmV8YWZ0ZXIpJC8pICYmICFpc19sb2FkZWQgJiYgIXRoaXMuaXNfbG9hZGVkKHBhcikpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMubG9hZF9ub2RlKHBhciwgZnVuY3Rpb24gKCkgeyB0aGlzLm1vdmVfbm9kZShvYmosIHBhciwgcG9zLCBjYWxsYmFjaywgdHJ1ZSk7IH0pO1xuXHRcdFx0fVxuXG5cdFx0XHRpZigkLmlzQXJyYXkob2JqKSkge1xuXHRcdFx0XHRvYmogPSBvYmoucmV2ZXJzZSgpLnNsaWNlKCk7XG5cdFx0XHRcdGZvcih0MSA9IDAsIHQyID0gb2JqLmxlbmd0aDsgdDEgPCB0MjsgdDErKykge1xuXHRcdFx0XHRcdHRoaXMubW92ZV9ub2RlKG9ialt0MV0sIHBhciwgcG9zLCBjYWxsYmFjaywgaXNfbG9hZGVkKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdG9iaiA9IG9iaiAmJiBvYmouaWQgPyBvYmogOiB0aGlzLmdldF9ub2RlKG9iaik7XG5cblx0XHRcdGlmKCFvYmogfHwgb2JqLmlkID09PSAnIycpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0XHRcdG9sZF9wYXIgPSAob2JqLnBhcmVudCB8fCAnIycpLnRvU3RyaW5nKCk7XG5cdFx0XHRuZXdfcGFyID0gKCFwb3MudG9TdHJpbmcoKS5tYXRjaCgvXihiZWZvcmV8YWZ0ZXIpJC8pIHx8IHBhci5pZCA9PT0gJyMnKSA/IHBhciA6IHRoaXMuZ2V0X25vZGUocGFyLnBhcmVudCk7XG5cdFx0XHRvbGRfaW5zID0gb2JqLmluc3RhbmNlID8gb2JqLmluc3RhbmNlIDogKHRoaXMuX21vZGVsLmRhdGFbb2JqLmlkXSA/IHRoaXMgOiAkLmpzdHJlZS5yZWZlcmVuY2Uob2JqLmlkKSk7XG5cdFx0XHRpc19tdWx0aSA9ICFvbGRfaW5zIHx8ICFvbGRfaW5zLl9pZCB8fCAodGhpcy5faWQgIT09IG9sZF9pbnMuX2lkKTtcblx0XHRcdG9sZF9wb3MgPSBvbGRfaW5zICYmIG9sZF9pbnMuX2lkICYmIG9sZF9wYXIgJiYgb2xkX2lucy5fbW9kZWwuZGF0YVtvbGRfcGFyXSAmJiBvbGRfaW5zLl9tb2RlbC5kYXRhW29sZF9wYXJdLmNoaWxkcmVuID8gJC5pbkFycmF5KG9iai5pZCwgb2xkX2lucy5fbW9kZWwuZGF0YVtvbGRfcGFyXS5jaGlsZHJlbikgOiAtMTtcblx0XHRcdGlmKGlzX211bHRpKSB7XG5cdFx0XHRcdGlmKHRoaXMuY29weV9ub2RlKG9iaiwgcGFyLCBwb3MsIGNhbGxiYWNrLCBpc19sb2FkZWQpKSB7XG5cdFx0XHRcdFx0aWYob2xkX2lucykgeyBvbGRfaW5zLmRlbGV0ZV9ub2RlKG9iaik7IH1cblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHQvL3ZhciBtID0gdGhpcy5fbW9kZWwuZGF0YTtcblx0XHRcdGlmKG5ld19wYXIuaWQgPT09ICcjJykge1xuXHRcdFx0XHRpZihwb3MgPT09IFwiYmVmb3JlXCIpIHsgcG9zID0gXCJmaXJzdFwiOyB9XG5cdFx0XHRcdGlmKHBvcyA9PT0gXCJhZnRlclwiKSB7IHBvcyA9IFwibGFzdFwiOyB9XG5cdFx0XHR9XG5cdFx0XHRzd2l0Y2gocG9zKSB7XG5cdFx0XHRcdGNhc2UgXCJiZWZvcmVcIjpcblx0XHRcdFx0XHRwb3MgPSAkLmluQXJyYXkocGFyLmlkLCBuZXdfcGFyLmNoaWxkcmVuKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBcImFmdGVyXCIgOlxuXHRcdFx0XHRcdHBvcyA9ICQuaW5BcnJheShwYXIuaWQsIG5ld19wYXIuY2hpbGRyZW4pICsgMTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBcImluc2lkZVwiOlxuXHRcdFx0XHRjYXNlIFwiZmlyc3RcIjpcblx0XHRcdFx0XHRwb3MgPSAwO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIFwibGFzdFwiOlxuXHRcdFx0XHRcdHBvcyA9IG5ld19wYXIuY2hpbGRyZW4ubGVuZ3RoO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdGlmKCFwb3MpIHsgcG9zID0gMDsgfVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0aWYocG9zID4gbmV3X3Bhci5jaGlsZHJlbi5sZW5ndGgpIHsgcG9zID0gbmV3X3Bhci5jaGlsZHJlbi5sZW5ndGg7IH1cblx0XHRcdGlmKCF0aGlzLmNoZWNrKFwibW92ZV9ub2RlXCIsIG9iaiwgbmV3X3BhciwgcG9zLCB7ICdjb3JlJyA6IHRydWUsICdpc19tdWx0aScgOiAob2xkX2lucyAmJiBvbGRfaW5zLl9pZCAmJiBvbGRfaW5zLl9pZCAhPT0gdGhpcy5faWQpLCAnaXNfZm9yZWlnbicgOiAoIW9sZF9pbnMgfHwgIW9sZF9pbnMuX2lkKSB9KSkge1xuXHRcdFx0XHR0aGlzLnNldHRpbmdzLmNvcmUuZXJyb3IuY2FsbCh0aGlzLCB0aGlzLl9kYXRhLmNvcmUubGFzdF9lcnJvcik7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdGlmKG9iai5wYXJlbnQgPT09IG5ld19wYXIuaWQpIHtcblx0XHRcdFx0ZHBjID0gbmV3X3Bhci5jaGlsZHJlbi5jb25jYXQoKTtcblx0XHRcdFx0dG1wID0gJC5pbkFycmF5KG9iai5pZCwgZHBjKTtcblx0XHRcdFx0aWYodG1wICE9PSAtMSkge1xuXHRcdFx0XHRcdGRwYyA9ICQudmFrYXRhLmFycmF5X3JlbW92ZShkcGMsIHRtcCk7XG5cdFx0XHRcdFx0aWYocG9zID4gdG1wKSB7IHBvcy0tOyB9XG5cdFx0XHRcdH1cblx0XHRcdFx0dG1wID0gW107XG5cdFx0XHRcdGZvcihpID0gMCwgaiA9IGRwYy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcblx0XHRcdFx0XHR0bXBbaSA+PSBwb3MgPyBpKzEgOiBpXSA9IGRwY1tpXTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0bXBbcG9zXSA9IG9iai5pZDtcblx0XHRcdFx0bmV3X3Bhci5jaGlsZHJlbiA9IHRtcDtcblx0XHRcdFx0dGhpcy5fbm9kZV9jaGFuZ2VkKG5ld19wYXIuaWQpO1xuXHRcdFx0XHR0aGlzLnJlZHJhdyhuZXdfcGFyLmlkID09PSAnIycpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdC8vIGNsZWFuIG9sZCBwYXJlbnQgYW5kIHVwXG5cdFx0XHRcdHRtcCA9IG9iai5jaGlsZHJlbl9kLmNvbmNhdCgpO1xuXHRcdFx0XHR0bXAucHVzaChvYmouaWQpO1xuXHRcdFx0XHRmb3IoaSA9IDAsIGogPSBvYmoucGFyZW50cy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcblx0XHRcdFx0XHRkcGMgPSBbXTtcblx0XHRcdFx0XHRwID0gb2xkX2lucy5fbW9kZWwuZGF0YVtvYmoucGFyZW50c1tpXV0uY2hpbGRyZW5fZDtcblx0XHRcdFx0XHRmb3IoayA9IDAsIGwgPSBwLmxlbmd0aDsgayA8IGw7IGsrKykge1xuXHRcdFx0XHRcdFx0aWYoJC5pbkFycmF5KHBba10sIHRtcCkgPT09IC0xKSB7XG5cdFx0XHRcdFx0XHRcdGRwYy5wdXNoKHBba10pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRvbGRfaW5zLl9tb2RlbC5kYXRhW29iai5wYXJlbnRzW2ldXS5jaGlsZHJlbl9kID0gZHBjO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG9sZF9pbnMuX21vZGVsLmRhdGFbb2xkX3Bhcl0uY2hpbGRyZW4gPSAkLnZha2F0YS5hcnJheV9yZW1vdmVfaXRlbShvbGRfaW5zLl9tb2RlbC5kYXRhW29sZF9wYXJdLmNoaWxkcmVuLCBvYmouaWQpO1xuXG5cdFx0XHRcdC8vIGluc2VydCBpbnRvIG5ldyBwYXJlbnQgYW5kIHVwXG5cdFx0XHRcdGZvcihpID0gMCwgaiA9IG5ld19wYXIucGFyZW50cy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcblx0XHRcdFx0XHR0aGlzLl9tb2RlbC5kYXRhW25ld19wYXIucGFyZW50c1tpXV0uY2hpbGRyZW5fZCA9IHRoaXMuX21vZGVsLmRhdGFbbmV3X3Bhci5wYXJlbnRzW2ldXS5jaGlsZHJlbl9kLmNvbmNhdCh0bXApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGRwYyA9IFtdO1xuXHRcdFx0XHRmb3IoaSA9IDAsIGogPSBuZXdfcGFyLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuXHRcdFx0XHRcdGRwY1tpID49IHBvcyA/IGkrMSA6IGldID0gbmV3X3Bhci5jaGlsZHJlbltpXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRkcGNbcG9zXSA9IG9iai5pZDtcblx0XHRcdFx0bmV3X3Bhci5jaGlsZHJlbiA9IGRwYztcblx0XHRcdFx0bmV3X3Bhci5jaGlsZHJlbl9kLnB1c2gob2JqLmlkKTtcblx0XHRcdFx0bmV3X3Bhci5jaGlsZHJlbl9kID0gbmV3X3Bhci5jaGlsZHJlbl9kLmNvbmNhdChvYmouY2hpbGRyZW5fZCk7XG5cblx0XHRcdFx0Ly8gdXBkYXRlIG9iamVjdFxuXHRcdFx0XHRvYmoucGFyZW50ID0gbmV3X3Bhci5pZDtcblx0XHRcdFx0dG1wID0gbmV3X3Bhci5wYXJlbnRzLmNvbmNhdCgpO1xuXHRcdFx0XHR0bXAudW5zaGlmdChuZXdfcGFyLmlkKTtcblx0XHRcdFx0cCA9IG9iai5wYXJlbnRzLmxlbmd0aDtcblx0XHRcdFx0b2JqLnBhcmVudHMgPSB0bXA7XG5cblx0XHRcdFx0Ly8gdXBkYXRlIG9iamVjdCBjaGlsZHJlblxuXHRcdFx0XHR0bXAgPSB0bXAuY29uY2F0KCk7XG5cdFx0XHRcdGZvcihpID0gMCwgaiA9IG9iai5jaGlsZHJlbl9kLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuXHRcdFx0XHRcdHRoaXMuX21vZGVsLmRhdGFbb2JqLmNoaWxkcmVuX2RbaV1dLnBhcmVudHMgPSB0aGlzLl9tb2RlbC5kYXRhW29iai5jaGlsZHJlbl9kW2ldXS5wYXJlbnRzLnNsaWNlKDAscCotMSk7XG5cdFx0XHRcdFx0QXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkodGhpcy5fbW9kZWwuZGF0YVtvYmouY2hpbGRyZW5fZFtpXV0ucGFyZW50cywgdG1wKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMuX25vZGVfY2hhbmdlZChvbGRfcGFyKTtcblx0XHRcdFx0dGhpcy5fbm9kZV9jaGFuZ2VkKG5ld19wYXIuaWQpO1xuXHRcdFx0XHR0aGlzLnJlZHJhdyhvbGRfcGFyID09PSAnIycgfHwgbmV3X3Bhci5pZCA9PT0gJyMnKTtcblx0XHRcdH1cblx0XHRcdGlmKGNhbGxiYWNrKSB7IGNhbGxiYWNrLmNhbGwodGhpcywgb2JqLCBuZXdfcGFyLCBwb3MpOyB9XG5cdFx0XHQvKipcblx0XHRcdCAqIHRyaWdnZXJlZCB3aGVuIGEgbm9kZSBpcyBtb3ZlZFxuXHRcdFx0ICogQGV2ZW50XG5cdFx0XHQgKiBAbmFtZSBtb3ZlX25vZGUuanN0cmVlXG5cdFx0XHQgKiBAcGFyYW0ge09iamVjdH0gbm9kZVxuXHRcdFx0ICogQHBhcmFtIHtTdHJpbmd9IHBhcmVudCB0aGUgcGFyZW50J3MgSURcblx0XHRcdCAqIEBwYXJhbSB7TnVtYmVyfSBwb3NpdGlvbiB0aGUgcG9zaXRpb24gb2YgdGhlIG5vZGUgYW1vbmcgdGhlIHBhcmVudCdzIGNoaWxkcmVuXG5cdFx0XHQgKiBAcGFyYW0ge1N0cmluZ30gb2xkX3BhcmVudCB0aGUgb2xkIHBhcmVudCBvZiB0aGUgbm9kZVxuXHRcdFx0ICogQHBhcmFtIHtOdW1iZXJ9IG9sZF9wb3NpdGlvbiB0aGUgb2xkIHBvc2l0aW9uIG9mIHRoZSBub2RlXG5cdFx0XHQgKiBAcGFyYW0ge0Jvb2xlYW59IGlzX211bHRpIGRvIHRoZSBub2RlIGFuZCBuZXcgcGFyZW50IGJlbG9uZyB0byBkaWZmZXJlbnQgaW5zdGFuY2VzXG5cdFx0XHQgKiBAcGFyYW0ge2pzVHJlZX0gb2xkX2luc3RhbmNlIHRoZSBpbnN0YW5jZSB0aGUgbm9kZSBjYW1lIGZyb21cblx0XHRcdCAqIEBwYXJhbSB7anNUcmVlfSBuZXdfaW5zdGFuY2UgdGhlIGluc3RhbmNlIG9mIHRoZSBuZXcgcGFyZW50XG5cdFx0XHQgKi9cblx0XHRcdHRoaXMudHJpZ2dlcignbW92ZV9ub2RlJywgeyBcIm5vZGVcIiA6IG9iaiwgXCJwYXJlbnRcIiA6IG5ld19wYXIuaWQsIFwicG9zaXRpb25cIiA6IHBvcywgXCJvbGRfcGFyZW50XCIgOiBvbGRfcGFyLCBcIm9sZF9wb3NpdGlvblwiIDogb2xkX3BvcywgJ2lzX211bHRpJyA6IChvbGRfaW5zICYmIG9sZF9pbnMuX2lkICYmIG9sZF9pbnMuX2lkICE9PSB0aGlzLl9pZCksICdpc19mb3JlaWduJyA6ICghb2xkX2lucyB8fCAhb2xkX2lucy5faWQpLCAnb2xkX2luc3RhbmNlJyA6IG9sZF9pbnMsICduZXdfaW5zdGFuY2UnIDogdGhpcyB9KTtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogY29weSBhIG5vZGUgdG8gYSBuZXcgcGFyZW50XG5cdFx0ICogQG5hbWUgY29weV9ub2RlKG9iaiwgcGFyIFssIHBvcywgY2FsbGJhY2ssIGlzX2xvYWRlZF0pXG5cdFx0ICogQHBhcmFtICB7bWl4ZWR9IG9iaiB0aGUgbm9kZSB0byBjb3B5LCBwYXNzIGFuIGFycmF5IHRvIGNvcHkgbXVsdGlwbGUgbm9kZXNcblx0XHQgKiBAcGFyYW0gIHttaXhlZH0gcGFyIHRoZSBuZXcgcGFyZW50XG5cdFx0ICogQHBhcmFtICB7bWl4ZWR9IHBvcyB0aGUgcG9zaXRpb24gdG8gaW5zZXJ0IGF0IChiZXNpZGVzIGludGVnZXIgdmFsdWVzLCBcImZpcnN0XCIgYW5kIFwibGFzdFwiIGFyZSBzdXBwb3J0ZWQsIGFzIHdlbGwgYXMgXCJiZWZvcmVcIiBhbmQgXCJhZnRlclwiKSwgZGVmYXVsdHMgdG8gaW50ZWdlciBgMGBcblx0XHQgKiBAcGFyYW0gIHtmdW5jdGlvbn0gY2FsbGJhY2sgYSBmdW5jdGlvbiB0byBjYWxsIG9uY2UgdGhlIG1vdmUgaXMgY29tcGxldGVkLCByZWNlaXZlcyAzIGFyZ3VtZW50cyAtIHRoZSBub2RlLCB0aGUgbmV3IHBhcmVudCBhbmQgdGhlIHBvc2l0aW9uXG5cdFx0ICogQHBhcmFtICB7Qm9vbGVhbn0gaW50ZXJuYWwgcGFyYW1ldGVyIGluZGljYXRpbmcgaWYgdGhlIHBhcmVudCBub2RlIGhhcyBiZWVuIGxvYWRlZFxuXHRcdCAqIEB0cmlnZ2VyIG1vZGVsLmpzdHJlZSBjb3B5X25vZGUuanN0cmVlXG5cdFx0ICovXG5cdFx0Y29weV9ub2RlIDogZnVuY3Rpb24gKG9iaiwgcGFyLCBwb3MsIGNhbGxiYWNrLCBpc19sb2FkZWQpIHtcblx0XHRcdHZhciB0MSwgdDIsIGRwYywgdG1wLCBpLCBqLCBub2RlLCBvbGRfcGFyLCBuZXdfcGFyLCBvbGRfaW5zLCBpc19tdWx0aTtcblxuXHRcdFx0cGFyID0gdGhpcy5nZXRfbm9kZShwYXIpO1xuXHRcdFx0cG9zID0gcG9zID09PSB1bmRlZmluZWQgPyAwIDogcG9zO1xuXHRcdFx0aWYoIXBhcikgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRcdGlmKCFwb3MudG9TdHJpbmcoKS5tYXRjaCgvXihiZWZvcmV8YWZ0ZXIpJC8pICYmICFpc19sb2FkZWQgJiYgIXRoaXMuaXNfbG9hZGVkKHBhcikpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMubG9hZF9ub2RlKHBhciwgZnVuY3Rpb24gKCkgeyB0aGlzLmNvcHlfbm9kZShvYmosIHBhciwgcG9zLCBjYWxsYmFjaywgdHJ1ZSk7IH0pO1xuXHRcdFx0fVxuXG5cdFx0XHRpZigkLmlzQXJyYXkob2JqKSkge1xuXHRcdFx0XHRvYmogPSBvYmoucmV2ZXJzZSgpLnNsaWNlKCk7XG5cdFx0XHRcdGZvcih0MSA9IDAsIHQyID0gb2JqLmxlbmd0aDsgdDEgPCB0MjsgdDErKykge1xuXHRcdFx0XHRcdHRoaXMuY29weV9ub2RlKG9ialt0MV0sIHBhciwgcG9zLCBjYWxsYmFjaywgaXNfbG9hZGVkKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdG9iaiA9IG9iaiAmJiBvYmouaWQgPyBvYmogOiB0aGlzLmdldF9ub2RlKG9iaik7XG5cdFx0XHRpZighb2JqIHx8IG9iai5pZCA9PT0gJyMnKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdFx0XHRvbGRfcGFyID0gKG9iai5wYXJlbnQgfHwgJyMnKS50b1N0cmluZygpO1xuXHRcdFx0bmV3X3BhciA9ICghcG9zLnRvU3RyaW5nKCkubWF0Y2goL14oYmVmb3JlfGFmdGVyKSQvKSB8fCBwYXIuaWQgPT09ICcjJykgPyBwYXIgOiB0aGlzLmdldF9ub2RlKHBhci5wYXJlbnQpO1xuXHRcdFx0b2xkX2lucyA9IG9iai5pbnN0YW5jZSA/IG9iai5pbnN0YW5jZSA6ICh0aGlzLl9tb2RlbC5kYXRhW29iai5pZF0gPyB0aGlzIDogJC5qc3RyZWUucmVmZXJlbmNlKG9iai5pZCkpO1xuXHRcdFx0aXNfbXVsdGkgPSAhb2xkX2lucyB8fCAhb2xkX2lucy5faWQgfHwgKHRoaXMuX2lkICE9PSBvbGRfaW5zLl9pZCk7XG5cdFx0XHRpZihuZXdfcGFyLmlkID09PSAnIycpIHtcblx0XHRcdFx0aWYocG9zID09PSBcImJlZm9yZVwiKSB7IHBvcyA9IFwiZmlyc3RcIjsgfVxuXHRcdFx0XHRpZihwb3MgPT09IFwiYWZ0ZXJcIikgeyBwb3MgPSBcImxhc3RcIjsgfVxuXHRcdFx0fVxuXHRcdFx0c3dpdGNoKHBvcykge1xuXHRcdFx0XHRjYXNlIFwiYmVmb3JlXCI6XG5cdFx0XHRcdFx0cG9zID0gJC5pbkFycmF5KHBhci5pZCwgbmV3X3Bhci5jaGlsZHJlbik7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgXCJhZnRlclwiIDpcblx0XHRcdFx0XHRwb3MgPSAkLmluQXJyYXkocGFyLmlkLCBuZXdfcGFyLmNoaWxkcmVuKSArIDE7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgXCJpbnNpZGVcIjpcblx0XHRcdFx0Y2FzZSBcImZpcnN0XCI6XG5cdFx0XHRcdFx0cG9zID0gMDtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBcImxhc3RcIjpcblx0XHRcdFx0XHRwb3MgPSBuZXdfcGFyLmNoaWxkcmVuLmxlbmd0aDtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRpZighcG9zKSB7IHBvcyA9IDA7IH1cblx0XHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdGlmKHBvcyA+IG5ld19wYXIuY2hpbGRyZW4ubGVuZ3RoKSB7IHBvcyA9IG5ld19wYXIuY2hpbGRyZW4ubGVuZ3RoOyB9XG5cdFx0XHRpZighdGhpcy5jaGVjayhcImNvcHlfbm9kZVwiLCBvYmosIG5ld19wYXIsIHBvcywgeyAnY29yZScgOiB0cnVlLCAnaXNfbXVsdGknIDogKG9sZF9pbnMgJiYgb2xkX2lucy5faWQgJiYgb2xkX2lucy5faWQgIT09IHRoaXMuX2lkKSwgJ2lzX2ZvcmVpZ24nIDogKCFvbGRfaW5zIHx8ICFvbGRfaW5zLl9pZCkgfSkpIHtcblx0XHRcdFx0dGhpcy5zZXR0aW5ncy5jb3JlLmVycm9yLmNhbGwodGhpcywgdGhpcy5fZGF0YS5jb3JlLmxhc3RfZXJyb3IpO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHRub2RlID0gb2xkX2lucyA/IG9sZF9pbnMuZ2V0X2pzb24ob2JqLCB7IG5vX2lkIDogdHJ1ZSwgbm9fZGF0YSA6IHRydWUsIG5vX3N0YXRlIDogdHJ1ZSB9KSA6IG9iajtcblx0XHRcdGlmKCFub2RlKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdFx0aWYobm9kZS5pZCA9PT0gdHJ1ZSkgeyBkZWxldGUgbm9kZS5pZDsgfVxuXHRcdFx0bm9kZSA9IHRoaXMuX3BhcnNlX21vZGVsX2Zyb21fanNvbihub2RlLCBuZXdfcGFyLmlkLCBuZXdfcGFyLnBhcmVudHMuY29uY2F0KCkpO1xuXHRcdFx0aWYoIW5vZGUpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0XHR0bXAgPSB0aGlzLmdldF9ub2RlKG5vZGUpO1xuXHRcdFx0aWYob2JqICYmIG9iai5zdGF0ZSAmJiBvYmouc3RhdGUubG9hZGVkID09PSBmYWxzZSkgeyB0bXAuc3RhdGUubG9hZGVkID0gZmFsc2U7IH1cblx0XHRcdGRwYyA9IFtdO1xuXHRcdFx0ZHBjLnB1c2gobm9kZSk7XG5cdFx0XHRkcGMgPSBkcGMuY29uY2F0KHRtcC5jaGlsZHJlbl9kKTtcblx0XHRcdHRoaXMudHJpZ2dlcignbW9kZWwnLCB7IFwibm9kZXNcIiA6IGRwYywgXCJwYXJlbnRcIiA6IG5ld19wYXIuaWQgfSk7XG5cblx0XHRcdC8vIGluc2VydCBpbnRvIG5ldyBwYXJlbnQgYW5kIHVwXG5cdFx0XHRmb3IoaSA9IDAsIGogPSBuZXdfcGFyLnBhcmVudHMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG5cdFx0XHRcdHRoaXMuX21vZGVsLmRhdGFbbmV3X3Bhci5wYXJlbnRzW2ldXS5jaGlsZHJlbl9kID0gdGhpcy5fbW9kZWwuZGF0YVtuZXdfcGFyLnBhcmVudHNbaV1dLmNoaWxkcmVuX2QuY29uY2F0KGRwYyk7XG5cdFx0XHR9XG5cdFx0XHRkcGMgPSBbXTtcblx0XHRcdGZvcihpID0gMCwgaiA9IG5ld19wYXIuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG5cdFx0XHRcdGRwY1tpID49IHBvcyA/IGkrMSA6IGldID0gbmV3X3Bhci5jaGlsZHJlbltpXTtcblx0XHRcdH1cblx0XHRcdGRwY1twb3NdID0gdG1wLmlkO1xuXHRcdFx0bmV3X3Bhci5jaGlsZHJlbiA9IGRwYztcblx0XHRcdG5ld19wYXIuY2hpbGRyZW5fZC5wdXNoKHRtcC5pZCk7XG5cdFx0XHRuZXdfcGFyLmNoaWxkcmVuX2QgPSBuZXdfcGFyLmNoaWxkcmVuX2QuY29uY2F0KHRtcC5jaGlsZHJlbl9kKTtcblxuXHRcdFx0dGhpcy5fbm9kZV9jaGFuZ2VkKG5ld19wYXIuaWQpO1xuXHRcdFx0dGhpcy5yZWRyYXcobmV3X3Bhci5pZCA9PT0gJyMnKTtcblx0XHRcdGlmKGNhbGxiYWNrKSB7IGNhbGxiYWNrLmNhbGwodGhpcywgdG1wLCBuZXdfcGFyLCBwb3MpOyB9XG5cdFx0XHQvKipcblx0XHRcdCAqIHRyaWdnZXJlZCB3aGVuIGEgbm9kZSBpcyBjb3BpZWRcblx0XHRcdCAqIEBldmVudFxuXHRcdFx0ICogQG5hbWUgY29weV9ub2RlLmpzdHJlZVxuXHRcdFx0ICogQHBhcmFtIHtPYmplY3R9IG5vZGUgdGhlIGNvcGllZCBub2RlXG5cdFx0XHQgKiBAcGFyYW0ge09iamVjdH0gb3JpZ2luYWwgdGhlIG9yaWdpbmFsIG5vZGVcblx0XHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBwYXJlbnQgdGhlIHBhcmVudCdzIElEXG5cdFx0XHQgKiBAcGFyYW0ge051bWJlcn0gcG9zaXRpb24gdGhlIHBvc2l0aW9uIG9mIHRoZSBub2RlIGFtb25nIHRoZSBwYXJlbnQncyBjaGlsZHJlblxuXHRcdFx0ICogQHBhcmFtIHtTdHJpbmd9IG9sZF9wYXJlbnQgdGhlIG9sZCBwYXJlbnQgb2YgdGhlIG5vZGVcblx0XHRcdCAqIEBwYXJhbSB7TnVtYmVyfSBvbGRfcG9zaXRpb24gdGhlIHBvc2l0aW9uIG9mIHRoZSBvcmlnaW5hbCBub2RlXG5cdFx0XHQgKiBAcGFyYW0ge0Jvb2xlYW59IGlzX211bHRpIGRvIHRoZSBub2RlIGFuZCBuZXcgcGFyZW50IGJlbG9uZyB0byBkaWZmZXJlbnQgaW5zdGFuY2VzXG5cdFx0XHQgKiBAcGFyYW0ge2pzVHJlZX0gb2xkX2luc3RhbmNlIHRoZSBpbnN0YW5jZSB0aGUgbm9kZSBjYW1lIGZyb21cblx0XHRcdCAqIEBwYXJhbSB7anNUcmVlfSBuZXdfaW5zdGFuY2UgdGhlIGluc3RhbmNlIG9mIHRoZSBuZXcgcGFyZW50XG5cdFx0XHQgKi9cblx0XHRcdHRoaXMudHJpZ2dlcignY29weV9ub2RlJywgeyBcIm5vZGVcIiA6IHRtcCwgXCJvcmlnaW5hbFwiIDogb2JqLCBcInBhcmVudFwiIDogbmV3X3Bhci5pZCwgXCJwb3NpdGlvblwiIDogcG9zLCBcIm9sZF9wYXJlbnRcIiA6IG9sZF9wYXIsIFwib2xkX3Bvc2l0aW9uXCIgOiBvbGRfaW5zICYmIG9sZF9pbnMuX2lkICYmIG9sZF9wYXIgJiYgb2xkX2lucy5fbW9kZWwuZGF0YVtvbGRfcGFyXSAmJiBvbGRfaW5zLl9tb2RlbC5kYXRhW29sZF9wYXJdLmNoaWxkcmVuID8gJC5pbkFycmF5KG9iai5pZCwgb2xkX2lucy5fbW9kZWwuZGF0YVtvbGRfcGFyXS5jaGlsZHJlbikgOiAtMSwnaXNfbXVsdGknIDogKG9sZF9pbnMgJiYgb2xkX2lucy5faWQgJiYgb2xkX2lucy5faWQgIT09IHRoaXMuX2lkKSwgJ2lzX2ZvcmVpZ24nIDogKCFvbGRfaW5zIHx8ICFvbGRfaW5zLl9pZCksICdvbGRfaW5zdGFuY2UnIDogb2xkX2lucywgJ25ld19pbnN0YW5jZScgOiB0aGlzIH0pO1xuXHRcdFx0cmV0dXJuIHRtcC5pZDtcblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIGN1dCBhIG5vZGUgKGEgbGF0ZXIgY2FsbCB0byBgcGFzdGUob2JqKWAgd291bGQgbW92ZSB0aGUgbm9kZSlcblx0XHQgKiBAbmFtZSBjdXQob2JqKVxuXHRcdCAqIEBwYXJhbSAge21peGVkfSBvYmogbXVsdGlwbGUgb2JqZWN0cyBjYW4gYmUgcGFzc2VkIHVzaW5nIGFuIGFycmF5XG5cdFx0ICogQHRyaWdnZXIgY3V0LmpzdHJlZVxuXHRcdCAqL1xuXHRcdGN1dCA6IGZ1bmN0aW9uIChvYmopIHtcblx0XHRcdGlmKCFvYmopIHsgb2JqID0gdGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkLmNvbmNhdCgpOyB9XG5cdFx0XHRpZighJC5pc0FycmF5KG9iaikpIHsgb2JqID0gW29ial07IH1cblx0XHRcdGlmKCFvYmoubGVuZ3RoKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdFx0dmFyIHRtcCA9IFtdLCBvLCB0MSwgdDI7XG5cdFx0XHRmb3IodDEgPSAwLCB0MiA9IG9iai5sZW5ndGg7IHQxIDwgdDI7IHQxKyspIHtcblx0XHRcdFx0byA9IHRoaXMuZ2V0X25vZGUob2JqW3QxXSk7XG5cdFx0XHRcdGlmKG8gJiYgby5pZCAmJiBvLmlkICE9PSAnIycpIHsgdG1wLnB1c2gobyk7IH1cblx0XHRcdH1cblx0XHRcdGlmKCF0bXAubGVuZ3RoKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdFx0Y2NwX25vZGUgPSB0bXA7XG5cdFx0XHRjY3BfaW5zdCA9IHRoaXM7XG5cdFx0XHRjY3BfbW9kZSA9ICdtb3ZlX25vZGUnO1xuXHRcdFx0LyoqXG5cdFx0XHQgKiB0cmlnZ2VyZWQgd2hlbiBub2RlcyBhcmUgYWRkZWQgdG8gdGhlIGJ1ZmZlciBmb3IgbW92aW5nXG5cdFx0XHQgKiBAZXZlbnRcblx0XHRcdCAqIEBuYW1lIGN1dC5qc3RyZWVcblx0XHRcdCAqIEBwYXJhbSB7QXJyYXl9IG5vZGVcblx0XHRcdCAqL1xuXHRcdFx0dGhpcy50cmlnZ2VyKCdjdXQnLCB7IFwibm9kZVwiIDogb2JqIH0pO1xuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogY29weSBhIG5vZGUgKGEgbGF0ZXIgY2FsbCB0byBgcGFzdGUob2JqKWAgd291bGQgY29weSB0aGUgbm9kZSlcblx0XHQgKiBAbmFtZSBjb3B5KG9iailcblx0XHQgKiBAcGFyYW0gIHttaXhlZH0gb2JqIG11bHRpcGxlIG9iamVjdHMgY2FuIGJlIHBhc3NlZCB1c2luZyBhbiBhcnJheVxuXHRcdCAqIEB0cmlnZ2VyIGNvcHkuanN0cmVcblx0XHQgKi9cblx0XHRjb3B5IDogZnVuY3Rpb24gKG9iaikge1xuXHRcdFx0aWYoIW9iaikgeyBvYmogPSB0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQuY29uY2F0KCk7IH1cblx0XHRcdGlmKCEkLmlzQXJyYXkob2JqKSkgeyBvYmogPSBbb2JqXTsgfVxuXHRcdFx0aWYoIW9iai5sZW5ndGgpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0XHR2YXIgdG1wID0gW10sIG8sIHQxLCB0Mjtcblx0XHRcdGZvcih0MSA9IDAsIHQyID0gb2JqLmxlbmd0aDsgdDEgPCB0MjsgdDErKykge1xuXHRcdFx0XHRvID0gdGhpcy5nZXRfbm9kZShvYmpbdDFdKTtcblx0XHRcdFx0aWYobyAmJiBvLmlkICYmIG8uaWQgIT09ICcjJykgeyB0bXAucHVzaChvKTsgfVxuXHRcdFx0fVxuXHRcdFx0aWYoIXRtcC5sZW5ndGgpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0XHRjY3Bfbm9kZSA9IHRtcDtcblx0XHRcdGNjcF9pbnN0ID0gdGhpcztcblx0XHRcdGNjcF9tb2RlID0gJ2NvcHlfbm9kZSc7XG5cdFx0XHQvKipcblx0XHRcdCAqIHRyaWdnZXJlZCB3aGVuIG5vZGVzIGFyZSBhZGRlZCB0byB0aGUgYnVmZmVyIGZvciBjb3B5aW5nXG5cdFx0XHQgKiBAZXZlbnRcblx0XHRcdCAqIEBuYW1lIGNvcHkuanN0cmVlXG5cdFx0XHQgKiBAcGFyYW0ge0FycmF5fSBub2RlXG5cdFx0XHQgKi9cblx0XHRcdHRoaXMudHJpZ2dlcignY29weScsIHsgXCJub2RlXCIgOiBvYmogfSk7XG5cdFx0fSxcblx0XHQvKipcblx0XHQgKiBnZXQgdGhlIGN1cnJlbnQgYnVmZmVyIChhbnkgbm9kZXMgdGhhdCBhcmUgd2FpdGluZyBmb3IgYSBwYXN0ZSBvcGVyYXRpb24pXG5cdFx0ICogQG5hbWUgZ2V0X2J1ZmZlcigpXG5cdFx0ICogQHJldHVybiB7T2JqZWN0fSBhbiBvYmplY3QgY29uc2lzdGluZyBvZiBgbW9kZWAgKFwiY29weV9ub2RlXCIgb3IgXCJtb3ZlX25vZGVcIiksIGBub2RlYCAoYW4gYXJyYXkgb2Ygb2JqZWN0cykgYW5kIGBpbnN0YCAodGhlIGluc3RhbmNlKVxuXHRcdCAqL1xuXHRcdGdldF9idWZmZXIgOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4geyAnbW9kZScgOiBjY3BfbW9kZSwgJ25vZGUnIDogY2NwX25vZGUsICdpbnN0JyA6IGNjcF9pbnN0IH07XG5cdFx0fSxcblx0XHQvKipcblx0XHQgKiBjaGVjayBpZiB0aGVyZSBpcyBzb21ldGhpbmcgaW4gdGhlIGJ1ZmZlciB0byBwYXN0ZVxuXHRcdCAqIEBuYW1lIGNhbl9wYXN0ZSgpXG5cdFx0ICogQHJldHVybiB7Qm9vbGVhbn1cblx0XHQgKi9cblx0XHRjYW5fcGFzdGUgOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gY2NwX21vZGUgIT09IGZhbHNlICYmIGNjcF9ub2RlICE9PSBmYWxzZTsgLy8gJiYgY2NwX2luc3QuX21vZGVsLmRhdGFbY2NwX25vZGVdO1xuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogY29weSBvciBtb3ZlIHRoZSBwcmV2aW91c2x5IGN1dCBvciBjb3BpZWQgbm9kZXMgdG8gYSBuZXcgcGFyZW50XG5cdFx0ICogQG5hbWUgcGFzdGUob2JqIFssIHBvc10pXG5cdFx0ICogQHBhcmFtICB7bWl4ZWR9IG9iaiB0aGUgbmV3IHBhcmVudFxuXHRcdCAqIEBwYXJhbSAge21peGVkfSBwb3MgdGhlIHBvc2l0aW9uIHRvIGluc2VydCBhdCAoYmVzaWRlcyBpbnRlZ2VyLCBcImZpcnN0XCIgYW5kIFwibGFzdFwiIGFyZSBzdXBwb3J0ZWQpLCBkZWZhdWx0cyB0byBpbnRlZ2VyIGAwYFxuXHRcdCAqIEB0cmlnZ2VyIHBhc3RlLmpzdHJlZVxuXHRcdCAqL1xuXHRcdHBhc3RlIDogZnVuY3Rpb24gKG9iaiwgcG9zKSB7XG5cdFx0XHRvYmogPSB0aGlzLmdldF9ub2RlKG9iaik7XG5cdFx0XHRpZighb2JqIHx8ICFjY3BfbW9kZSB8fCAhY2NwX21vZGUubWF0Y2goL14oY29weV9ub2RlfG1vdmVfbm9kZSkkLykgfHwgIWNjcF9ub2RlKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdFx0aWYodGhpc1tjY3BfbW9kZV0oY2NwX25vZGUsIG9iaiwgcG9zKSkge1xuXHRcdFx0XHQvKipcblx0XHRcdFx0ICogdHJpZ2dlcmVkIHdoZW4gcGFzdGUgaXMgaW52b2tlZFxuXHRcdFx0XHQgKiBAZXZlbnRcblx0XHRcdFx0ICogQG5hbWUgcGFzdGUuanN0cmVlXG5cdFx0XHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBwYXJlbnQgdGhlIElEIG9mIHRoZSByZWNlaXZpbmcgbm9kZVxuXHRcdFx0XHQgKiBAcGFyYW0ge0FycmF5fSBub2RlIHRoZSBub2RlcyBpbiB0aGUgYnVmZmVyXG5cdFx0XHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBtb2RlIHRoZSBwZXJmb3JtZWQgb3BlcmF0aW9uIC0gXCJjb3B5X25vZGVcIiBvciBcIm1vdmVfbm9kZVwiXG5cdFx0XHRcdCAqL1xuXHRcdFx0XHR0aGlzLnRyaWdnZXIoJ3Bhc3RlJywgeyBcInBhcmVudFwiIDogb2JqLmlkLCBcIm5vZGVcIiA6IGNjcF9ub2RlLCBcIm1vZGVcIiA6IGNjcF9tb2RlIH0pO1xuXHRcdFx0fVxuXHRcdFx0Y2NwX25vZGUgPSBmYWxzZTtcblx0XHRcdGNjcF9tb2RlID0gZmFsc2U7XG5cdFx0XHRjY3BfaW5zdCA9IGZhbHNlO1xuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogcHV0IGEgbm9kZSBpbiBlZGl0IG1vZGUgKGlucHV0IGZpZWxkIHRvIHJlbmFtZSB0aGUgbm9kZSlcblx0XHQgKiBAbmFtZSBlZGl0KG9iaiBbLCBkZWZhdWx0X3RleHRdKVxuXHRcdCAqIEBwYXJhbSAge21peGVkfSBvYmpcblx0XHQgKiBAcGFyYW0gIHtTdHJpbmd9IGRlZmF1bHRfdGV4dCB0aGUgdGV4dCB0byBwb3B1bGF0ZSB0aGUgaW5wdXQgd2l0aCAoaWYgb21pdHRlZCB0aGUgbm9kZSB0ZXh0IHZhbHVlIGlzIHVzZWQpXG5cdFx0ICovXG5cdFx0ZWRpdCA6IGZ1bmN0aW9uIChvYmosIGRlZmF1bHRfdGV4dCkge1xuXHRcdFx0b2JqID0gdGhpcy5nZXRfbm9kZShvYmopO1xuXHRcdFx0aWYoIW9iaikgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRcdGlmKHRoaXMuc2V0dGluZ3MuY29yZS5jaGVja19jYWxsYmFjayA9PT0gZmFsc2UpIHtcblx0XHRcdFx0dGhpcy5fZGF0YS5jb3JlLmxhc3RfZXJyb3IgPSB7ICdlcnJvcicgOiAnY2hlY2snLCAncGx1Z2luJyA6ICdjb3JlJywgJ2lkJyA6ICdjb3JlXzA3JywgJ3JlYXNvbicgOiAnQ291bGQgbm90IGVkaXQgbm9kZSBiZWNhdXNlIG9mIGNoZWNrX2NhbGxiYWNrJyB9O1xuXHRcdFx0XHR0aGlzLnNldHRpbmdzLmNvcmUuZXJyb3IuY2FsbCh0aGlzLCB0aGlzLl9kYXRhLmNvcmUubGFzdF9lcnJvcik7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdGRlZmF1bHRfdGV4dCA9IHR5cGVvZiBkZWZhdWx0X3RleHQgPT09ICdzdHJpbmcnID8gZGVmYXVsdF90ZXh0IDogb2JqLnRleHQ7XG5cdFx0XHR0aGlzLnNldF90ZXh0KG9iaiwgXCJcIik7XG5cdFx0XHRvYmogPSB0aGlzLl9vcGVuX3RvKG9iaik7XG5cblx0XHRcdHZhciBydGwgPSB0aGlzLl9kYXRhLmNvcmUucnRsLFxuXHRcdFx0XHR3ICA9IHRoaXMuZWxlbWVudC53aWR0aCgpLFxuXHRcdFx0XHRhICA9IG9iai5jaGlsZHJlbignLmpzdHJlZS1hbmNob3InKSxcblx0XHRcdFx0cyAgPSAkKCc8c3Bhbj4nKSxcblx0XHRcdFx0LyohXG5cdFx0XHRcdG9pID0gb2JqLmNoaWxkcmVuKFwiaTp2aXNpYmxlXCIpLFxuXHRcdFx0XHRhaSA9IGEuY2hpbGRyZW4oXCJpOnZpc2libGVcIiksXG5cdFx0XHRcdHcxID0gb2kud2lkdGgoKSAqIG9pLmxlbmd0aCxcblx0XHRcdFx0dzIgPSBhaS53aWR0aCgpICogYWkubGVuZ3RoLFxuXHRcdFx0XHQqL1xuXHRcdFx0XHR0ICA9IGRlZmF1bHRfdGV4dCxcblx0XHRcdFx0aDEgPSAkKFwiPFwiK1wiZGl2IC8+XCIsIHsgY3NzIDogeyBcInBvc2l0aW9uXCIgOiBcImFic29sdXRlXCIsIFwidG9wXCIgOiBcIi0yMDBweFwiLCBcImxlZnRcIiA6IChydGwgPyBcIjBweFwiIDogXCItMTAwMHB4XCIpLCBcInZpc2liaWxpdHlcIiA6IFwiaGlkZGVuXCIgfSB9KS5hcHBlbmRUbyhcImJvZHlcIiksXG5cdFx0XHRcdGgyID0gJChcIjxcIitcImlucHV0IC8+XCIsIHtcblx0XHRcdFx0XHRcdFwidmFsdWVcIiA6IHQsXG5cdFx0XHRcdFx0XHRcImNsYXNzXCIgOiBcImpzdHJlZS1yZW5hbWUtaW5wdXRcIixcblx0XHRcdFx0XHRcdC8vIFwic2l6ZVwiIDogdC5sZW5ndGgsXG5cdFx0XHRcdFx0XHRcImNzc1wiIDoge1xuXHRcdFx0XHRcdFx0XHRcInBhZGRpbmdcIiA6IFwiMFwiLFxuXHRcdFx0XHRcdFx0XHRcImJvcmRlclwiIDogXCIxcHggc29saWQgc2lsdmVyXCIsXG5cdFx0XHRcdFx0XHRcdFwiYm94LXNpemluZ1wiIDogXCJib3JkZXItYm94XCIsXG5cdFx0XHRcdFx0XHRcdFwiZGlzcGxheVwiIDogXCJpbmxpbmUtYmxvY2tcIixcblx0XHRcdFx0XHRcdFx0XCJoZWlnaHRcIiA6ICh0aGlzLl9kYXRhLmNvcmUubGlfaGVpZ2h0KSArIFwicHhcIixcblx0XHRcdFx0XHRcdFx0XCJsaW5lSGVpZ2h0XCIgOiAodGhpcy5fZGF0YS5jb3JlLmxpX2hlaWdodCkgKyBcInB4XCIsXG5cdFx0XHRcdFx0XHRcdFwid2lkdGhcIiA6IFwiMTUwcHhcIiAvLyB3aWxsIGJlIHNldCBhIGJpdCBmdXJ0aGVyIGRvd25cblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcImJsdXJcIiA6ICQucHJveHkoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0XHR2YXIgaSA9IHMuY2hpbGRyZW4oXCIuanN0cmVlLXJlbmFtZS1pbnB1dFwiKSxcblx0XHRcdFx0XHRcdFx0XHR2ID0gaS52YWwoKTtcblx0XHRcdFx0XHRcdFx0aWYodiA9PT0gXCJcIikgeyB2ID0gdDsgfVxuXHRcdFx0XHRcdFx0XHRoMS5yZW1vdmUoKTtcblx0XHRcdFx0XHRcdFx0cy5yZXBsYWNlV2l0aChhKTtcblx0XHRcdFx0XHRcdFx0cy5yZW1vdmUoKTtcblx0XHRcdFx0XHRcdFx0dGhpcy5zZXRfdGV4dChvYmosIHQpO1xuXHRcdFx0XHRcdFx0XHRpZih0aGlzLnJlbmFtZV9ub2RlKG9iaiwgJCgnPGRpdj48L2Rpdj4nKS50ZXh0KHYpW3RoaXMuc2V0dGluZ3MuY29yZS5mb3JjZV90ZXh0ID8gJ3RleHQnIDogJ2h0bWwnXSgpKSA9PT0gZmFsc2UpIHtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLnNldF90ZXh0KG9iaiwgdCk7IC8vIG1vdmUgdGhpcyB1cD8gYW5kIGZpeCAjNDgzXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0sIHRoaXMpLFxuXHRcdFx0XHRcdFx0XCJrZXlkb3duXCIgOiBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHRcdFx0XHRcdFx0dmFyIGtleSA9IGV2ZW50LndoaWNoO1xuXHRcdFx0XHRcdFx0XHRpZihrZXkgPT09IDI3KSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy52YWx1ZSA9IHQ7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0aWYoa2V5ID09PSAyNyB8fCBrZXkgPT09IDEzIHx8IGtleSA9PT0gMzcgfHwga2V5ID09PSAzOCB8fCBrZXkgPT09IDM5IHx8IGtleSA9PT0gNDAgfHwga2V5ID09PSAzMikge1xuXHRcdFx0XHRcdFx0XHRcdGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGlmKGtleSA9PT0gMjcgfHwga2V5ID09PSAxMykge1xuXHRcdFx0XHRcdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5ibHVyKCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcImNsaWNrXCIgOiBmdW5jdGlvbiAoZSkgeyBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpOyB9LFxuXHRcdFx0XHRcdFx0XCJtb3VzZWRvd25cIiA6IGZ1bmN0aW9uIChlKSB7IGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7IH0sXG5cdFx0XHRcdFx0XHRcImtleXVwXCIgOiBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHRcdFx0XHRcdFx0aDIud2lkdGgoTWF0aC5taW4oaDEudGV4dChcInBXXCIgKyB0aGlzLnZhbHVlKS53aWR0aCgpLHcpKTtcblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcImtleXByZXNzXCIgOiBmdW5jdGlvbihldmVudCkge1xuXHRcdFx0XHRcdFx0XHRpZihldmVudC53aGljaCA9PT0gMTMpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSksXG5cdFx0XHRcdGZuID0ge1xuXHRcdFx0XHRcdFx0Zm9udEZhbWlseVx0XHQ6IGEuY3NzKCdmb250RmFtaWx5JylcdFx0fHwgJycsXG5cdFx0XHRcdFx0XHRmb250U2l6ZVx0XHQ6IGEuY3NzKCdmb250U2l6ZScpXHRcdFx0fHwgJycsXG5cdFx0XHRcdFx0XHRmb250V2VpZ2h0XHRcdDogYS5jc3MoJ2ZvbnRXZWlnaHQnKVx0XHR8fCAnJyxcblx0XHRcdFx0XHRcdGZvbnRTdHlsZVx0XHQ6IGEuY3NzKCdmb250U3R5bGUnKVx0XHR8fCAnJyxcblx0XHRcdFx0XHRcdGZvbnRTdHJldGNoXHRcdDogYS5jc3MoJ2ZvbnRTdHJldGNoJylcdFx0fHwgJycsXG5cdFx0XHRcdFx0XHRmb250VmFyaWFudFx0XHQ6IGEuY3NzKCdmb250VmFyaWFudCcpXHRcdHx8ICcnLFxuXHRcdFx0XHRcdFx0bGV0dGVyU3BhY2luZ1x0OiBhLmNzcygnbGV0dGVyU3BhY2luZycpXHR8fCAnJyxcblx0XHRcdFx0XHRcdHdvcmRTcGFjaW5nXHRcdDogYS5jc3MoJ3dvcmRTcGFjaW5nJylcdFx0fHwgJydcblx0XHRcdFx0fTtcblx0XHRcdHMuYXR0cignY2xhc3MnLCBhLmF0dHIoJ2NsYXNzJykpLmFwcGVuZChhLmNvbnRlbnRzKCkuY2xvbmUoKSkuYXBwZW5kKGgyKTtcblx0XHRcdGEucmVwbGFjZVdpdGgocyk7XG5cdFx0XHRoMS5jc3MoZm4pO1xuXHRcdFx0aDIuY3NzKGZuKS53aWR0aChNYXRoLm1pbihoMS50ZXh0KFwicFdcIiArIGgyWzBdLnZhbHVlKS53aWR0aCgpLHcpKVswXS5zZWxlY3QoKTtcblx0XHR9LFxuXG5cblx0XHQvKipcblx0XHQgKiBjaGFuZ2VzIHRoZSB0aGVtZVxuXHRcdCAqIEBuYW1lIHNldF90aGVtZSh0aGVtZV9uYW1lIFssIHRoZW1lX3VybF0pXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IHRoZW1lX25hbWUgdGhlIG5hbWUgb2YgdGhlIG5ldyB0aGVtZSB0byBhcHBseVxuXHRcdCAqIEBwYXJhbSB7bWl4ZWR9IHRoZW1lX3VybCAgdGhlIGxvY2F0aW9uIG9mIHRoZSBDU1MgZmlsZSBmb3IgdGhpcyB0aGVtZS4gT21pdCBvciBzZXQgdG8gYGZhbHNlYCBpZiB5b3UgbWFudWFsbHkgaW5jbHVkZWQgdGhlIGZpbGUuIFNldCB0byBgdHJ1ZWAgdG8gYXV0b2xvYWQgZnJvbSB0aGUgYGNvcmUudGhlbWVzLmRpcmAgZGlyZWN0b3J5LlxuXHRcdCAqIEB0cmlnZ2VyIHNldF90aGVtZS5qc3RyZWVcblx0XHQgKi9cblx0XHRzZXRfdGhlbWUgOiBmdW5jdGlvbiAodGhlbWVfbmFtZSwgdGhlbWVfdXJsKSB7XG5cdFx0XHRpZighdGhlbWVfbmFtZSkgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRcdGlmKHRoZW1lX3VybCA9PT0gdHJ1ZSkge1xuXHRcdFx0XHR2YXIgZGlyID0gdGhpcy5zZXR0aW5ncy5jb3JlLnRoZW1lcy5kaXI7XG5cdFx0XHRcdGlmKCFkaXIpIHsgZGlyID0gJC5qc3RyZWUucGF0aCArICcvdGhlbWVzJzsgfVxuXHRcdFx0XHR0aGVtZV91cmwgPSBkaXIgKyAnLycgKyB0aGVtZV9uYW1lICsgJy9zdHlsZS5jc3MnO1xuXHRcdFx0fVxuXHRcdFx0aWYodGhlbWVfdXJsICYmICQuaW5BcnJheSh0aGVtZV91cmwsIHRoZW1lc19sb2FkZWQpID09PSAtMSkge1xuXHRcdFx0XHQkKCdoZWFkJykuYXBwZW5kKCc8JysnbGluayByZWw9XCJzdHlsZXNoZWV0XCIgaHJlZj1cIicgKyB0aGVtZV91cmwgKyAnXCIgdHlwZT1cInRleHQvY3NzXCIgLz4nKTtcblx0XHRcdFx0dGhlbWVzX2xvYWRlZC5wdXNoKHRoZW1lX3VybCk7XG5cdFx0XHR9XG5cdFx0XHRpZih0aGlzLl9kYXRhLmNvcmUudGhlbWVzLm5hbWUpIHtcblx0XHRcdFx0dGhpcy5lbGVtZW50LnJlbW92ZUNsYXNzKCdqc3RyZWUtJyArIHRoaXMuX2RhdGEuY29yZS50aGVtZXMubmFtZSk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9kYXRhLmNvcmUudGhlbWVzLm5hbWUgPSB0aGVtZV9uYW1lO1xuXHRcdFx0dGhpcy5lbGVtZW50LmFkZENsYXNzKCdqc3RyZWUtJyArIHRoZW1lX25hbWUpO1xuXHRcdFx0dGhpcy5lbGVtZW50W3RoaXMuc2V0dGluZ3MuY29yZS50aGVtZXMucmVzcG9uc2l2ZSA/ICdhZGRDbGFzcycgOiAncmVtb3ZlQ2xhc3MnIF0oJ2pzdHJlZS0nICsgdGhlbWVfbmFtZSArICctcmVzcG9uc2l2ZScpO1xuXHRcdFx0LyoqXG5cdFx0XHQgKiB0cmlnZ2VyZWQgd2hlbiBhIHRoZW1lIGlzIHNldFxuXHRcdFx0ICogQGV2ZW50XG5cdFx0XHQgKiBAbmFtZSBzZXRfdGhlbWUuanN0cmVlXG5cdFx0XHQgKiBAcGFyYW0ge1N0cmluZ30gdGhlbWUgdGhlIG5ldyB0aGVtZVxuXHRcdFx0ICovXG5cdFx0XHR0aGlzLnRyaWdnZXIoJ3NldF90aGVtZScsIHsgJ3RoZW1lJyA6IHRoZW1lX25hbWUgfSk7XG5cdFx0fSxcblx0XHQvKipcblx0XHQgKiBnZXRzIHRoZSBuYW1lIG9mIHRoZSBjdXJyZW50bHkgYXBwbGllZCB0aGVtZSBuYW1lXG5cdFx0ICogQG5hbWUgZ2V0X3RoZW1lKClcblx0XHQgKiBAcmV0dXJuIHtTdHJpbmd9XG5cdFx0ICovXG5cdFx0Z2V0X3RoZW1lIDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZGF0YS5jb3JlLnRoZW1lcy5uYW1lOyB9LFxuXHRcdC8qKlxuXHRcdCAqIGNoYW5nZXMgdGhlIHRoZW1lIHZhcmlhbnQgKGlmIHRoZSB0aGVtZSBoYXMgdmFyaWFudHMpXG5cdFx0ICogQG5hbWUgc2V0X3RoZW1lX3ZhcmlhbnQodmFyaWFudF9uYW1lKVxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfEJvb2xlYW59IHZhcmlhbnRfbmFtZSB0aGUgdmFyaWFudCB0byBhcHBseSAoaWYgYGZhbHNlYCBpcyB1c2VkIHRoZSBjdXJyZW50IHZhcmlhbnQgaXMgcmVtb3ZlZClcblx0XHQgKi9cblx0XHRzZXRfdGhlbWVfdmFyaWFudCA6IGZ1bmN0aW9uICh2YXJpYW50X25hbWUpIHtcblx0XHRcdGlmKHRoaXMuX2RhdGEuY29yZS50aGVtZXMudmFyaWFudCkge1xuXHRcdFx0XHR0aGlzLmVsZW1lbnQucmVtb3ZlQ2xhc3MoJ2pzdHJlZS0nICsgdGhpcy5fZGF0YS5jb3JlLnRoZW1lcy5uYW1lICsgJy0nICsgdGhpcy5fZGF0YS5jb3JlLnRoZW1lcy52YXJpYW50KTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX2RhdGEuY29yZS50aGVtZXMudmFyaWFudCA9IHZhcmlhbnRfbmFtZTtcblx0XHRcdGlmKHZhcmlhbnRfbmFtZSkge1xuXHRcdFx0XHR0aGlzLmVsZW1lbnQuYWRkQ2xhc3MoJ2pzdHJlZS0nICsgdGhpcy5fZGF0YS5jb3JlLnRoZW1lcy5uYW1lICsgJy0nICsgdGhpcy5fZGF0YS5jb3JlLnRoZW1lcy52YXJpYW50KTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIGdldHMgdGhlIG5hbWUgb2YgdGhlIGN1cnJlbnRseSBhcHBsaWVkIHRoZW1lIHZhcmlhbnRcblx0XHQgKiBAbmFtZSBnZXRfdGhlbWUoKVxuXHRcdCAqIEByZXR1cm4ge1N0cmluZ31cblx0XHQgKi9cblx0XHRnZXRfdGhlbWVfdmFyaWFudCA6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2RhdGEuY29yZS50aGVtZXMudmFyaWFudDsgfSxcblx0XHQvKipcblx0XHQgKiBzaG93cyBhIHN0cmlwZWQgYmFja2dyb3VuZCBvbiB0aGUgY29udGFpbmVyIChpZiB0aGUgdGhlbWUgc3VwcG9ydHMgaXQpXG5cdFx0ICogQG5hbWUgc2hvd19zdHJpcGVzKClcblx0XHQgKi9cblx0XHRzaG93X3N0cmlwZXMgOiBmdW5jdGlvbiAoKSB7IHRoaXMuX2RhdGEuY29yZS50aGVtZXMuc3RyaXBlcyA9IHRydWU7IHRoaXMuZ2V0X2NvbnRhaW5lcl91bCgpLmFkZENsYXNzKFwianN0cmVlLXN0cmlwZWRcIik7IH0sXG5cdFx0LyoqXG5cdFx0ICogaGlkZXMgdGhlIHN0cmlwZWQgYmFja2dyb3VuZCBvbiB0aGUgY29udGFpbmVyXG5cdFx0ICogQG5hbWUgaGlkZV9zdHJpcGVzKClcblx0XHQgKi9cblx0XHRoaWRlX3N0cmlwZXMgOiBmdW5jdGlvbiAoKSB7IHRoaXMuX2RhdGEuY29yZS50aGVtZXMuc3RyaXBlcyA9IGZhbHNlOyB0aGlzLmdldF9jb250YWluZXJfdWwoKS5yZW1vdmVDbGFzcyhcImpzdHJlZS1zdHJpcGVkXCIpOyB9LFxuXHRcdC8qKlxuXHRcdCAqIHRvZ2dsZXMgdGhlIHN0cmlwZWQgYmFja2dyb3VuZCBvbiB0aGUgY29udGFpbmVyXG5cdFx0ICogQG5hbWUgdG9nZ2xlX3N0cmlwZXMoKVxuXHRcdCAqL1xuXHRcdHRvZ2dsZV9zdHJpcGVzIDogZnVuY3Rpb24gKCkgeyBpZih0aGlzLl9kYXRhLmNvcmUudGhlbWVzLnN0cmlwZXMpIHsgdGhpcy5oaWRlX3N0cmlwZXMoKTsgfSBlbHNlIHsgdGhpcy5zaG93X3N0cmlwZXMoKTsgfSB9LFxuXHRcdC8qKlxuXHRcdCAqIHNob3dzIHRoZSBjb25uZWN0aW5nIGRvdHMgKGlmIHRoZSB0aGVtZSBzdXBwb3J0cyBpdClcblx0XHQgKiBAbmFtZSBzaG93X2RvdHMoKVxuXHRcdCAqL1xuXHRcdHNob3dfZG90cyA6IGZ1bmN0aW9uICgpIHsgdGhpcy5fZGF0YS5jb3JlLnRoZW1lcy5kb3RzID0gdHJ1ZTsgdGhpcy5nZXRfY29udGFpbmVyX3VsKCkucmVtb3ZlQ2xhc3MoXCJqc3RyZWUtbm8tZG90c1wiKTsgfSxcblx0XHQvKipcblx0XHQgKiBoaWRlcyB0aGUgY29ubmVjdGluZyBkb3RzXG5cdFx0ICogQG5hbWUgaGlkZV9kb3RzKClcblx0XHQgKi9cblx0XHRoaWRlX2RvdHMgOiBmdW5jdGlvbiAoKSB7IHRoaXMuX2RhdGEuY29yZS50aGVtZXMuZG90cyA9IGZhbHNlOyB0aGlzLmdldF9jb250YWluZXJfdWwoKS5hZGRDbGFzcyhcImpzdHJlZS1uby1kb3RzXCIpOyB9LFxuXHRcdC8qKlxuXHRcdCAqIHRvZ2dsZXMgdGhlIGNvbm5lY3RpbmcgZG90c1xuXHRcdCAqIEBuYW1lIHRvZ2dsZV9kb3RzKClcblx0XHQgKi9cblx0XHR0b2dnbGVfZG90cyA6IGZ1bmN0aW9uICgpIHsgaWYodGhpcy5fZGF0YS5jb3JlLnRoZW1lcy5kb3RzKSB7IHRoaXMuaGlkZV9kb3RzKCk7IH0gZWxzZSB7IHRoaXMuc2hvd19kb3RzKCk7IH0gfSxcblx0XHQvKipcblx0XHQgKiBzaG93IHRoZSBub2RlIGljb25zXG5cdFx0ICogQG5hbWUgc2hvd19pY29ucygpXG5cdFx0ICovXG5cdFx0c2hvd19pY29ucyA6IGZ1bmN0aW9uICgpIHsgdGhpcy5fZGF0YS5jb3JlLnRoZW1lcy5pY29ucyA9IHRydWU7IHRoaXMuZ2V0X2NvbnRhaW5lcl91bCgpLnJlbW92ZUNsYXNzKFwianN0cmVlLW5vLWljb25zXCIpOyB9LFxuXHRcdC8qKlxuXHRcdCAqIGhpZGUgdGhlIG5vZGUgaWNvbnNcblx0XHQgKiBAbmFtZSBoaWRlX2ljb25zKClcblx0XHQgKi9cblx0XHRoaWRlX2ljb25zIDogZnVuY3Rpb24gKCkgeyB0aGlzLl9kYXRhLmNvcmUudGhlbWVzLmljb25zID0gZmFsc2U7IHRoaXMuZ2V0X2NvbnRhaW5lcl91bCgpLmFkZENsYXNzKFwianN0cmVlLW5vLWljb25zXCIpOyB9LFxuXHRcdC8qKlxuXHRcdCAqIHRvZ2dsZSB0aGUgbm9kZSBpY29uc1xuXHRcdCAqIEBuYW1lIHRvZ2dsZV9pY29ucygpXG5cdFx0ICovXG5cdFx0dG9nZ2xlX2ljb25zIDogZnVuY3Rpb24gKCkgeyBpZih0aGlzLl9kYXRhLmNvcmUudGhlbWVzLmljb25zKSB7IHRoaXMuaGlkZV9pY29ucygpOyB9IGVsc2UgeyB0aGlzLnNob3dfaWNvbnMoKTsgfSB9LFxuXHRcdC8qKlxuXHRcdCAqIHNldCB0aGUgbm9kZSBpY29uIGZvciBhIG5vZGVcblx0XHQgKiBAbmFtZSBzZXRfaWNvbihvYmosIGljb24pXG5cdFx0ICogQHBhcmFtIHttaXhlZH0gb2JqXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IGljb24gdGhlIG5ldyBpY29uIC0gY2FuIGJlIGEgcGF0aCB0byBhbiBpY29uIG9yIGEgY2xhc3NOYW1lLCBpZiB1c2luZyBhbiBpbWFnZSB0aGF0IGlzIGluIHRoZSBjdXJyZW50IGRpcmVjdG9yeSB1c2UgYSBgLi9gIHByZWZpeCwgb3RoZXJ3aXNlIGl0IHdpbGwgYmUgZGV0ZWN0ZWQgYXMgYSBjbGFzc1xuXHRcdCAqL1xuXHRcdHNldF9pY29uIDogZnVuY3Rpb24gKG9iaiwgaWNvbikge1xuXHRcdFx0dmFyIHQxLCB0MiwgZG9tLCBvbGQ7XG5cdFx0XHRpZigkLmlzQXJyYXkob2JqKSkge1xuXHRcdFx0XHRvYmogPSBvYmouc2xpY2UoKTtcblx0XHRcdFx0Zm9yKHQxID0gMCwgdDIgPSBvYmoubGVuZ3RoOyB0MSA8IHQyOyB0MSsrKSB7XG5cdFx0XHRcdFx0dGhpcy5zZXRfaWNvbihvYmpbdDFdLCBpY29uKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdG9iaiA9IHRoaXMuZ2V0X25vZGUob2JqKTtcblx0XHRcdGlmKCFvYmogfHwgb2JqLmlkID09PSAnIycpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0XHRvbGQgPSBvYmouaWNvbjtcblx0XHRcdG9iai5pY29uID0gaWNvbjtcblx0XHRcdGRvbSA9IHRoaXMuZ2V0X25vZGUob2JqLCB0cnVlKS5jaGlsZHJlbihcIi5qc3RyZWUtYW5jaG9yXCIpLmNoaWxkcmVuKFwiLmpzdHJlZS10aGVtZWljb25cIik7XG5cdFx0XHRpZihpY29uID09PSBmYWxzZSkge1xuXHRcdFx0XHR0aGlzLmhpZGVfaWNvbihvYmopO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZihpY29uID09PSB0cnVlKSB7XG5cdFx0XHRcdGRvbS5yZW1vdmVDbGFzcygnanN0cmVlLXRoZW1laWNvbi1jdXN0b20gJyArIG9sZCkuY3NzKFwiYmFja2dyb3VuZFwiLFwiXCIpLnJlbW92ZUF0dHIoXCJyZWxcIik7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmKGljb24uaW5kZXhPZihcIi9cIikgPT09IC0xICYmIGljb24uaW5kZXhPZihcIi5cIikgPT09IC0xKSB7XG5cdFx0XHRcdGRvbS5yZW1vdmVDbGFzcyhvbGQpLmNzcyhcImJhY2tncm91bmRcIixcIlwiKTtcblx0XHRcdFx0ZG9tLmFkZENsYXNzKGljb24gKyAnIGpzdHJlZS10aGVtZWljb24tY3VzdG9tJykuYXR0cihcInJlbFwiLGljb24pO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGRvbS5yZW1vdmVDbGFzcyhvbGQpLmNzcyhcImJhY2tncm91bmRcIixcIlwiKTtcblx0XHRcdFx0ZG9tLmFkZENsYXNzKCdqc3RyZWUtdGhlbWVpY29uLWN1c3RvbScpLmNzcyhcImJhY2tncm91bmRcIiwgXCJ1cmwoJ1wiICsgaWNvbiArIFwiJykgY2VudGVyIGNlbnRlciBuby1yZXBlYXRcIikuYXR0cihcInJlbFwiLGljb24pO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSxcblx0XHQvKipcblx0XHQgKiBnZXQgdGhlIG5vZGUgaWNvbiBmb3IgYSBub2RlXG5cdFx0ICogQG5hbWUgZ2V0X2ljb24ob2JqKVxuXHRcdCAqIEBwYXJhbSB7bWl4ZWR9IG9ialxuXHRcdCAqIEByZXR1cm4ge1N0cmluZ31cblx0XHQgKi9cblx0XHRnZXRfaWNvbiA6IGZ1bmN0aW9uIChvYmopIHtcblx0XHRcdG9iaiA9IHRoaXMuZ2V0X25vZGUob2JqKTtcblx0XHRcdHJldHVybiAoIW9iaiB8fCBvYmouaWQgPT09ICcjJykgPyBmYWxzZSA6IG9iai5pY29uO1xuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogaGlkZSB0aGUgaWNvbiBvbiBhbiBpbmRpdmlkdWFsIG5vZGVcblx0XHQgKiBAbmFtZSBoaWRlX2ljb24ob2JqKVxuXHRcdCAqIEBwYXJhbSB7bWl4ZWR9IG9ialxuXHRcdCAqL1xuXHRcdGhpZGVfaWNvbiA6IGZ1bmN0aW9uIChvYmopIHtcblx0XHRcdHZhciB0MSwgdDI7XG5cdFx0XHRpZigkLmlzQXJyYXkob2JqKSkge1xuXHRcdFx0XHRvYmogPSBvYmouc2xpY2UoKTtcblx0XHRcdFx0Zm9yKHQxID0gMCwgdDIgPSBvYmoubGVuZ3RoOyB0MSA8IHQyOyB0MSsrKSB7XG5cdFx0XHRcdFx0dGhpcy5oaWRlX2ljb24ob2JqW3QxXSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0XHRvYmogPSB0aGlzLmdldF9ub2RlKG9iaik7XG5cdFx0XHRpZighb2JqIHx8IG9iaiA9PT0gJyMnKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdFx0b2JqLmljb24gPSBmYWxzZTtcblx0XHRcdHRoaXMuZ2V0X25vZGUob2JqLCB0cnVlKS5jaGlsZHJlbihcIi5qc3RyZWUtYW5jaG9yXCIpLmNoaWxkcmVuKFwiLmpzdHJlZS10aGVtZWljb25cIikuYWRkQ2xhc3MoJ2pzdHJlZS10aGVtZWljb24taGlkZGVuJyk7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIHNob3cgdGhlIGljb24gb24gYW4gaW5kaXZpZHVhbCBub2RlXG5cdFx0ICogQG5hbWUgc2hvd19pY29uKG9iailcblx0XHQgKiBAcGFyYW0ge21peGVkfSBvYmpcblx0XHQgKi9cblx0XHRzaG93X2ljb24gOiBmdW5jdGlvbiAob2JqKSB7XG5cdFx0XHR2YXIgdDEsIHQyLCBkb207XG5cdFx0XHRpZigkLmlzQXJyYXkob2JqKSkge1xuXHRcdFx0XHRvYmogPSBvYmouc2xpY2UoKTtcblx0XHRcdFx0Zm9yKHQxID0gMCwgdDIgPSBvYmoubGVuZ3RoOyB0MSA8IHQyOyB0MSsrKSB7XG5cdFx0XHRcdFx0dGhpcy5zaG93X2ljb24ob2JqW3QxXSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0XHRvYmogPSB0aGlzLmdldF9ub2RlKG9iaik7XG5cdFx0XHRpZighb2JqIHx8IG9iaiA9PT0gJyMnKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdFx0ZG9tID0gdGhpcy5nZXRfbm9kZShvYmosIHRydWUpO1xuXHRcdFx0b2JqLmljb24gPSBkb20ubGVuZ3RoID8gZG9tLmNoaWxkcmVuKFwiLmpzdHJlZS1hbmNob3JcIikuY2hpbGRyZW4oXCIuanN0cmVlLXRoZW1laWNvblwiKS5hdHRyKCdyZWwnKSA6IHRydWU7XG5cdFx0XHRpZighb2JqLmljb24pIHsgb2JqLmljb24gPSB0cnVlOyB9XG5cdFx0XHRkb20uY2hpbGRyZW4oXCIuanN0cmVlLWFuY2hvclwiKS5jaGlsZHJlbihcIi5qc3RyZWUtdGhlbWVpY29uXCIpLnJlbW92ZUNsYXNzKCdqc3RyZWUtdGhlbWVpY29uLWhpZGRlbicpO1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHR9O1xuXG5cdC8vIGhlbHBlcnNcblx0JC52YWthdGEgPSB7fTtcblx0Ly8gY29sbGVjdCBhdHRyaWJ1dGVzXG5cdCQudmFrYXRhLmF0dHJpYnV0ZXMgPSBmdW5jdGlvbihub2RlLCB3aXRoX3ZhbHVlcykge1xuXHRcdG5vZGUgPSAkKG5vZGUpWzBdO1xuXHRcdHZhciBhdHRyID0gd2l0aF92YWx1ZXMgPyB7fSA6IFtdO1xuXHRcdGlmKG5vZGUgJiYgbm9kZS5hdHRyaWJ1dGVzKSB7XG5cdFx0XHQkLmVhY2gobm9kZS5hdHRyaWJ1dGVzLCBmdW5jdGlvbiAoaSwgdikge1xuXHRcdFx0XHRpZigkLmluQXJyYXkodi5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpLFsnc3R5bGUnLCdjb250ZW50ZWRpdGFibGUnLCdoYXNmb2N1cycsJ3RhYmluZGV4J10pICE9PSAtMSkgeyByZXR1cm47IH1cblx0XHRcdFx0aWYodi5ub2RlVmFsdWUgIT09IG51bGwgJiYgJC50cmltKHYubm9kZVZhbHVlKSAhPT0gJycpIHtcblx0XHRcdFx0XHRpZih3aXRoX3ZhbHVlcykgeyBhdHRyW3Yubm9kZU5hbWVdID0gdi5ub2RlVmFsdWU7IH1cblx0XHRcdFx0XHRlbHNlIHsgYXR0ci5wdXNoKHYubm9kZU5hbWUpOyB9XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblx0XHRyZXR1cm4gYXR0cjtcblx0fTtcblx0JC52YWthdGEuYXJyYXlfdW5pcXVlID0gZnVuY3Rpb24oYXJyYXkpIHtcblx0XHR2YXIgYSA9IFtdLCBpLCBqLCBsO1xuXHRcdGZvcihpID0gMCwgbCA9IGFycmF5Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0Zm9yKGogPSAwOyBqIDw9IGk7IGorKykge1xuXHRcdFx0XHRpZihhcnJheVtpXSA9PT0gYXJyYXlbal0pIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYoaiA9PT0gaSkgeyBhLnB1c2goYXJyYXlbaV0pOyB9XG5cdFx0fVxuXHRcdHJldHVybiBhO1xuXHR9O1xuXHQvLyByZW1vdmUgaXRlbSBmcm9tIGFycmF5XG5cdCQudmFrYXRhLmFycmF5X3JlbW92ZSA9IGZ1bmN0aW9uKGFycmF5LCBmcm9tLCB0bykge1xuXHRcdHZhciByZXN0ID0gYXJyYXkuc2xpY2UoKHRvIHx8IGZyb20pICsgMSB8fCBhcnJheS5sZW5ndGgpO1xuXHRcdGFycmF5Lmxlbmd0aCA9IGZyb20gPCAwID8gYXJyYXkubGVuZ3RoICsgZnJvbSA6IGZyb207XG5cdFx0YXJyYXkucHVzaC5hcHBseShhcnJheSwgcmVzdCk7XG5cdFx0cmV0dXJuIGFycmF5O1xuXHR9O1xuXHQvLyByZW1vdmUgaXRlbSBmcm9tIGFycmF5XG5cdCQudmFrYXRhLmFycmF5X3JlbW92ZV9pdGVtID0gZnVuY3Rpb24oYXJyYXksIGl0ZW0pIHtcblx0XHR2YXIgdG1wID0gJC5pbkFycmF5KGl0ZW0sIGFycmF5KTtcblx0XHRyZXR1cm4gdG1wICE9PSAtMSA/ICQudmFrYXRhLmFycmF5X3JlbW92ZShhcnJheSwgdG1wKSA6IGFycmF5O1xuXHR9O1xuXG4vKipcbiAqICMjIyBDaGVja2JveCBwbHVnaW5cbiAqXG4gKiBUaGlzIHBsdWdpbiByZW5kZXJzIGNoZWNrYm94IGljb25zIGluIGZyb250IG9mIGVhY2ggbm9kZSwgbWFraW5nIG11bHRpcGxlIHNlbGVjdGlvbiBtdWNoIGVhc2llci4gXG4gKiBJdCBhbHNvIHN1cHBvcnRzIHRyaS1zdGF0ZSBiZWhhdmlvciwgbWVhbmluZyB0aGF0IGlmIGEgbm9kZSBoYXMgYSBmZXcgb2YgaXRzIGNoaWxkcmVuIGNoZWNrZWQgaXQgd2lsbCBiZSByZW5kZXJlZCBhcyB1bmRldGVybWluZWQsIGFuZCBzdGF0ZSB3aWxsIGJlIHByb3BhZ2F0ZWQgdXAuXG4gKi9cblxuXHR2YXIgX2kgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdJJyk7XG5cdF9pLmNsYXNzTmFtZSA9ICdqc3RyZWUtaWNvbiBqc3RyZWUtY2hlY2tib3gnO1xuXHQvKipcblx0ICogc3RvcmVzIGFsbCBkZWZhdWx0cyBmb3IgdGhlIGNoZWNrYm94IHBsdWdpblxuXHQgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5jaGVja2JveFxuXHQgKiBAcGx1Z2luIGNoZWNrYm94XG5cdCAqL1xuXHQkLmpzdHJlZS5kZWZhdWx0cy5jaGVja2JveCA9IHtcblx0XHQvKipcblx0XHQgKiBhIGJvb2xlYW4gaW5kaWNhdGluZyBpZiBjaGVja2JveGVzIHNob3VsZCBiZSB2aXNpYmxlIChjYW4gYmUgY2hhbmdlZCBhdCBhIGxhdGVyIHRpbWUgdXNpbmcgYHNob3dfY2hlY2tib3hlcygpYCBhbmQgYGhpZGVfY2hlY2tib3hlc2ApLiBEZWZhdWx0cyB0byBgdHJ1ZWAuXG5cdFx0ICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuY2hlY2tib3gudmlzaWJsZVxuXHRcdCAqIEBwbHVnaW4gY2hlY2tib3hcblx0XHQgKi9cblx0XHR2aXNpYmxlXHRcdFx0XHQ6IHRydWUsXG5cdFx0LyoqXG5cdFx0ICogYSBib29sZWFuIGluZGljYXRpbmcgaWYgY2hlY2tib3hlcyBzaG91bGQgY2FzY2FkZSBkb3duIGFuZCBoYXZlIGFuIHVuZGV0ZXJtaW5lZCBzdGF0ZS4gRGVmYXVsdHMgdG8gYHRydWVgLlxuXHRcdCAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLmNoZWNrYm94LnRocmVlX3N0YXRlXG5cdFx0ICogQHBsdWdpbiBjaGVja2JveFxuXHRcdCAqL1xuXHRcdHRocmVlX3N0YXRlXHRcdFx0OiB0cnVlLFxuXHRcdC8qKlxuXHRcdCAqIGEgYm9vbGVhbiBpbmRpY2F0aW5nIGlmIGNsaWNraW5nIGFueXdoZXJlIG9uIHRoZSBub2RlIHNob3VsZCBhY3QgYXMgY2xpY2tpbmcgb24gdGhlIGNoZWNrYm94LiBEZWZhdWx0cyB0byBgdHJ1ZWAuXG5cdFx0ICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuY2hlY2tib3gud2hvbGVfbm9kZVxuXHRcdCAqIEBwbHVnaW4gY2hlY2tib3hcblx0XHQgKi9cblx0XHR3aG9sZV9ub2RlXHRcdFx0OiB0cnVlLFxuXHRcdC8qKlxuXHRcdCAqIGEgYm9vbGVhbiBpbmRpY2F0aW5nIGlmIHRoZSBzZWxlY3RlZCBzdHlsZSBvZiBhIG5vZGUgc2hvdWxkIGJlIGtlcHQsIG9yIHJlbW92ZWQuIERlZmF1bHRzIHRvIGB0cnVlYC5cblx0XHQgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5jaGVja2JveC5rZWVwX3NlbGVjdGVkX3N0eWxlXG5cdFx0ICogQHBsdWdpbiBjaGVja2JveFxuXHRcdCAqL1xuXHRcdGtlZXBfc2VsZWN0ZWRfc3R5bGVcdDogdHJ1ZSxcblx0XHQvKipcblx0XHQgKiBUaGlzIHNldHRpbmcgY29udHJvbHMgaG93IGNhc2NhZGluZyBhbmQgdW5kZXRlcm1pbmVkIG5vZGVzIGFyZSBhcHBsaWVkLiBcblx0XHQgKiBJZiAndXAnIGlzIGluIHRoZSBzdHJpbmcgLSBjYXNjYWRpbmcgdXAgaXMgZW5hYmxlZCwgaWYgJ2Rvd24nIGlzIGluIHRoZSBzdHJpbmcgLSBjYXNjYWRpbmcgZG93biBpcyBlbmFibGVkLCBpZiAndW5kZXRlcm1pbmVkJyBpcyBpbiB0aGUgc3RyaW5nIC0gdW5kZXRlcm1pbmVkIG5vZGVzIHdpbGwgYmUgdXNlZC4gXG5cdFx0ICogSWYgYHRocmVlX3N0YXRlYCBpcyBzZXQgdG8gYHRydWVgIHRoaXMgc2V0dGluZyBpcyBhdXRvbWF0aWNhbGx5IHNldCB0byAndXArZG93bit1bmRldGVybWluZWQnLiBEZWZhdWx0cyB0byAnJy5cblx0XHQgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5jaGVja2JveC5jYXNjYWRlXG5cdFx0ICogQHBsdWdpbiBjaGVja2JveFxuXHRcdCAqL1xuXHRcdGNhc2NhZGVcdFx0XHRcdDogJycsXG5cdFx0LyoqXG5cdFx0ICogVGhpcyBzZXR0aW5nIGNvbnRyb2xzIGlmIGNoZWNrYm94IGFyZSBib3VuZCB0byB0aGUgZ2VuZXJhbCB0cmVlIHNlbGVjdGlvbiBvciB0byBhbiBpbnRlcm5hbCBhcnJheSBtYWludGFpbmVkIGJ5IHRoZSBjaGVja2JveCBwbHVnaW4uIERlZmF1bHRzIHRvIGB0cnVlYCwgb25seSBzZXQgdG8gYGZhbHNlYCBpZiB5b3Uga25vdyBleGFjdGx5IHdoYXQgeW91IGFyZSBkb2luZy4gXG5cdFx0ICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuY2hlY2tib3gudGllX3NlbGVjdGlvblxuXHRcdCAqIEBwbHVnaW4gY2hlY2tib3hcblx0XHQgKi9cblx0XHR0aWVfc2VsZWN0aW9uXHRcdDogdHJ1ZVxuXHR9O1xuXHQkLmpzdHJlZS5wbHVnaW5zLmNoZWNrYm94ID0gZnVuY3Rpb24gKG9wdGlvbnMsIHBhcmVudCkge1xuXHRcdHRoaXMuYmluZCA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHBhcmVudC5iaW5kLmNhbGwodGhpcyk7XG5cdFx0XHR0aGlzLl9kYXRhLmNoZWNrYm94LnV0byA9IGZhbHNlO1xuXHRcdFx0dGhpcy5fZGF0YS5jaGVja2JveC5zZWxlY3RlZCA9IFtdO1xuXHRcdFx0aWYodGhpcy5zZXR0aW5ncy5jaGVja2JveC50aHJlZV9zdGF0ZSkge1xuXHRcdFx0XHR0aGlzLnNldHRpbmdzLmNoZWNrYm94LmNhc2NhZGUgPSAndXArZG93bit1bmRldGVybWluZWQnO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5lbGVtZW50XG5cdFx0XHRcdC5vbihcImluaXQuanN0cmVlXCIsICQucHJveHkoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0dGhpcy5fZGF0YS5jaGVja2JveC52aXNpYmxlID0gdGhpcy5zZXR0aW5ncy5jaGVja2JveC52aXNpYmxlO1xuXHRcdFx0XHRcdFx0aWYoIXRoaXMuc2V0dGluZ3MuY2hlY2tib3gua2VlcF9zZWxlY3RlZF9zdHlsZSkge1xuXHRcdFx0XHRcdFx0XHR0aGlzLmVsZW1lbnQuYWRkQ2xhc3MoJ2pzdHJlZS1jaGVja2JveC1uby1jbGlja2VkJyk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZih0aGlzLnNldHRpbmdzLmNoZWNrYm94LnRpZV9zZWxlY3Rpb24pIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5lbGVtZW50LmFkZENsYXNzKCdqc3RyZWUtY2hlY2tib3gtc2VsZWN0aW9uJyk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSwgdGhpcykpXG5cdFx0XHRcdC5vbihcImxvYWRpbmcuanN0cmVlXCIsICQucHJveHkoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0dGhpc1sgdGhpcy5fZGF0YS5jaGVja2JveC52aXNpYmxlID8gJ3Nob3dfY2hlY2tib3hlcycgOiAnaGlkZV9jaGVja2JveGVzJyBdKCk7XG5cdFx0XHRcdFx0fSwgdGhpcykpO1xuXHRcdFx0aWYodGhpcy5zZXR0aW5ncy5jaGVja2JveC5jYXNjYWRlLmluZGV4T2YoJ3VuZGV0ZXJtaW5lZCcpICE9PSAtMSkge1xuXHRcdFx0XHR0aGlzLmVsZW1lbnRcblx0XHRcdFx0XHQub24oJ2NoYW5nZWQuanN0cmVlIHVuY2hlY2tfbm9kZS5qc3RyZWUgY2hlY2tfbm9kZS5qc3RyZWUgdW5jaGVja19hbGwuanN0cmVlIGNoZWNrX2FsbC5qc3RyZWUgbW92ZV9ub2RlLmpzdHJlZSBjb3B5X25vZGUuanN0cmVlIHJlZHJhdy5qc3RyZWUgb3Blbl9ub2RlLmpzdHJlZScsICQucHJveHkoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0XHQvLyBvbmx5IGlmIHVuZGV0ZXJtaW5lZCBpcyBpbiBzZXR0aW5nXG5cdFx0XHRcdFx0XHRcdGlmKHRoaXMuX2RhdGEuY2hlY2tib3gudXRvKSB7IGNsZWFyVGltZW91dCh0aGlzLl9kYXRhLmNoZWNrYm94LnV0byk7IH1cblx0XHRcdFx0XHRcdFx0dGhpcy5fZGF0YS5jaGVja2JveC51dG8gPSBzZXRUaW1lb3V0KCQucHJveHkodGhpcy5fdW5kZXRlcm1pbmVkLCB0aGlzKSwgNTApO1xuXHRcdFx0XHRcdFx0fSwgdGhpcykpO1xuXHRcdFx0fVxuXHRcdFx0aWYoIXRoaXMuc2V0dGluZ3MuY2hlY2tib3gudGllX3NlbGVjdGlvbikge1xuXHRcdFx0XHR0aGlzLmVsZW1lbnRcblx0XHRcdFx0XHQub24oJ21vZGVsLmpzdHJlZScsICQucHJveHkoZnVuY3Rpb24gKGUsIGRhdGEpIHtcblx0XHRcdFx0XHRcdHZhciBtID0gdGhpcy5fbW9kZWwuZGF0YSxcblx0XHRcdFx0XHRcdFx0cCA9IG1bZGF0YS5wYXJlbnRdLFxuXHRcdFx0XHRcdFx0XHRkcGMgPSBkYXRhLm5vZGVzLFxuXHRcdFx0XHRcdFx0XHRpLCBqO1xuXHRcdFx0XHRcdFx0Zm9yKGkgPSAwLCBqID0gZHBjLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuXHRcdFx0XHRcdFx0XHRtW2RwY1tpXV0uc3RhdGUuY2hlY2tlZCA9IChtW2RwY1tpXV0ub3JpZ2luYWwgJiYgbVtkcGNbaV1dLm9yaWdpbmFsLnN0YXRlICYmIG1bZHBjW2ldXS5vcmlnaW5hbC5zdGF0ZS5jaGVja2VkKTtcblx0XHRcdFx0XHRcdFx0aWYobVtkcGNbaV1dLnN0YXRlLmNoZWNrZWQpIHtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLl9kYXRhLmNoZWNrYm94LnNlbGVjdGVkLnB1c2goZHBjW2ldKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sIHRoaXMpKTtcblx0XHRcdH1cblx0XHRcdGlmKHRoaXMuc2V0dGluZ3MuY2hlY2tib3guY2FzY2FkZS5pbmRleE9mKCd1cCcpICE9PSAtMSB8fCB0aGlzLnNldHRpbmdzLmNoZWNrYm94LmNhc2NhZGUuaW5kZXhPZignZG93bicpICE9PSAtMSkge1xuXHRcdFx0XHR0aGlzLmVsZW1lbnRcblx0XHRcdFx0XHQub24oJ21vZGVsLmpzdHJlZScsICQucHJveHkoZnVuY3Rpb24gKGUsIGRhdGEpIHtcblx0XHRcdFx0XHRcdFx0dmFyIG0gPSB0aGlzLl9tb2RlbC5kYXRhLFxuXHRcdFx0XHRcdFx0XHRcdHAgPSBtW2RhdGEucGFyZW50XSxcblx0XHRcdFx0XHRcdFx0XHRkcGMgPSBkYXRhLm5vZGVzLFxuXHRcdFx0XHRcdFx0XHRcdGNoZCA9IFtdLFxuXHRcdFx0XHRcdFx0XHRcdGMsIGksIGosIGssIGwsIHRtcCwgcyA9IHRoaXMuc2V0dGluZ3MuY2hlY2tib3guY2FzY2FkZSwgdCA9IHRoaXMuc2V0dGluZ3MuY2hlY2tib3gudGllX3NlbGVjdGlvbjtcblxuXHRcdFx0XHRcdFx0XHRpZihzLmluZGV4T2YoJ2Rvd24nKSAhPT0gLTEpIHtcblx0XHRcdFx0XHRcdFx0XHQvLyBhcHBseSBkb3duXG5cdFx0XHRcdFx0XHRcdFx0aWYocC5zdGF0ZVsgdCA/ICdzZWxlY3RlZCcgOiAnY2hlY2tlZCcgXSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Zm9yKGkgPSAwLCBqID0gZHBjLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRtW2RwY1tpXV0uc3RhdGVbIHQgPyAnc2VsZWN0ZWQnIDogJ2NoZWNrZWQnIF0gPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0dGhpcy5fZGF0YVsgdCA/ICdjb3JlJyA6ICdjaGVja2JveCcgXS5zZWxlY3RlZCA9IHRoaXMuX2RhdGFbIHQgPyAnY29yZScgOiAnY2hlY2tib3gnIF0uc2VsZWN0ZWQuY29uY2F0KGRwYyk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0Zm9yKGkgPSAwLCBqID0gZHBjLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZihtW2RwY1tpXV0uc3RhdGVbIHQgPyAnc2VsZWN0ZWQnIDogJ2NoZWNrZWQnIF0pIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRmb3IoayA9IDAsIGwgPSBtW2RwY1tpXV0uY2hpbGRyZW5fZC5sZW5ndGg7IGsgPCBsOyBrKyspIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdG1bbVtkcGNbaV1dLmNoaWxkcmVuX2Rba11dLnN0YXRlWyB0ID8gJ3NlbGVjdGVkJyA6ICdjaGVja2VkJyBdID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dGhpcy5fZGF0YVsgdCA/ICdjb3JlJyA6ICdjaGVja2JveCcgXS5zZWxlY3RlZCA9IHRoaXMuX2RhdGFbIHQgPyAnY29yZScgOiAnY2hlY2tib3gnIF0uc2VsZWN0ZWQuY29uY2F0KG1bZHBjW2ldXS5jaGlsZHJlbl9kKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdGlmKHMuaW5kZXhPZigndXAnKSAhPT0gLTEpIHtcblx0XHRcdFx0XHRcdFx0XHQvLyBhcHBseSB1cFxuXHRcdFx0XHRcdFx0XHRcdGZvcihpID0gMCwgaiA9IHAuY2hpbGRyZW5fZC5sZW5ndGg7IGkgPCBqOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0XHRcdGlmKCFtW3AuY2hpbGRyZW5fZFtpXV0uY2hpbGRyZW4ubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGNoZC5wdXNoKG1bcC5jaGlsZHJlbl9kW2ldXS5wYXJlbnQpO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRjaGQgPSAkLnZha2F0YS5hcnJheV91bmlxdWUoY2hkKTtcblx0XHRcdFx0XHRcdFx0XHRmb3IoayA9IDAsIGwgPSBjaGQubGVuZ3RoOyBrIDwgbDsgaysrKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRwID0gbVtjaGRba11dO1xuXHRcdFx0XHRcdFx0XHRcdFx0d2hpbGUocCAmJiBwLmlkICE9PSAnIycpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0YyA9IDA7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGZvcihpID0gMCwgaiA9IHAuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0YyArPSBtW3AuY2hpbGRyZW5baV1dLnN0YXRlWyB0ID8gJ3NlbGVjdGVkJyA6ICdjaGVja2VkJyBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmKGMgPT09IGopIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRwLnN0YXRlWyB0ID8gJ3NlbGVjdGVkJyA6ICdjaGVja2VkJyBdID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0aGlzLl9kYXRhWyB0ID8gJ2NvcmUnIDogJ2NoZWNrYm94JyBdLnNlbGVjdGVkLnB1c2gocC5pZCk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dG1wID0gdGhpcy5nZXRfbm9kZShwLCB0cnVlKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZih0bXAgJiYgdG1wLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dG1wLmNoaWxkcmVuKCcuanN0cmVlLWFuY2hvcicpLmFkZENsYXNzKCB0ID8gJ2pzdHJlZS1jbGlja2VkJyA6ICdqc3RyZWUtY2hlY2tlZCcpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRwID0gdGhpcy5nZXRfbm9kZShwLnBhcmVudCk7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0dGhpcy5fZGF0YVsgdCA/ICdjb3JlJyA6ICdjaGVja2JveCcgXS5zZWxlY3RlZCA9ICQudmFrYXRhLmFycmF5X3VuaXF1ZSh0aGlzLl9kYXRhWyB0ID8gJ2NvcmUnIDogJ2NoZWNrYm94JyBdLnNlbGVjdGVkKTtcblx0XHRcdFx0XHRcdH0sIHRoaXMpKVxuXHRcdFx0XHRcdC5vbih0aGlzLnNldHRpbmdzLmNoZWNrYm94LnRpZV9zZWxlY3Rpb24gPyAnc2VsZWN0X25vZGUuanN0cmVlJyA6ICdjaGVja19ub2RlLmpzdHJlZScsICQucHJveHkoZnVuY3Rpb24gKGUsIGRhdGEpIHtcblx0XHRcdFx0XHRcdFx0dmFyIG9iaiA9IGRhdGEubm9kZSxcblx0XHRcdFx0XHRcdFx0XHRtID0gdGhpcy5fbW9kZWwuZGF0YSxcblx0XHRcdFx0XHRcdFx0XHRwYXIgPSB0aGlzLmdldF9ub2RlKG9iai5wYXJlbnQpLFxuXHRcdFx0XHRcdFx0XHRcdGRvbSA9IHRoaXMuZ2V0X25vZGUob2JqLCB0cnVlKSxcblx0XHRcdFx0XHRcdFx0XHRpLCBqLCBjLCB0bXAsIHMgPSB0aGlzLnNldHRpbmdzLmNoZWNrYm94LmNhc2NhZGUsIHQgPSB0aGlzLnNldHRpbmdzLmNoZWNrYm94LnRpZV9zZWxlY3Rpb247XG5cblx0XHRcdFx0XHRcdFx0Ly8gYXBwbHkgZG93blxuXHRcdFx0XHRcdFx0XHRpZihzLmluZGV4T2YoJ2Rvd24nKSAhPT0gLTEpIHtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLl9kYXRhWyB0ID8gJ2NvcmUnIDogJ2NoZWNrYm94JyBdLnNlbGVjdGVkID0gJC52YWthdGEuYXJyYXlfdW5pcXVlKHRoaXMuX2RhdGFbIHQgPyAnY29yZScgOiAnY2hlY2tib3gnIF0uc2VsZWN0ZWQuY29uY2F0KG9iai5jaGlsZHJlbl9kKSk7XG5cdFx0XHRcdFx0XHRcdFx0Zm9yKGkgPSAwLCBqID0gb2JqLmNoaWxkcmVuX2QubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR0bXAgPSBtW29iai5jaGlsZHJlbl9kW2ldXTtcblx0XHRcdFx0XHRcdFx0XHRcdHRtcC5zdGF0ZVsgdCA/ICdzZWxlY3RlZCcgOiAnY2hlY2tlZCcgXSA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZih0bXAgJiYgdG1wLm9yaWdpbmFsICYmIHRtcC5vcmlnaW5hbC5zdGF0ZSAmJiB0bXAub3JpZ2luYWwuc3RhdGUudW5kZXRlcm1pbmVkKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRtcC5vcmlnaW5hbC5zdGF0ZS51bmRldGVybWluZWQgPSBmYWxzZTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHQvLyBhcHBseSB1cFxuXHRcdFx0XHRcdFx0XHRpZihzLmluZGV4T2YoJ3VwJykgIT09IC0xKSB7XG5cdFx0XHRcdFx0XHRcdFx0d2hpbGUocGFyICYmIHBhci5pZCAhPT0gJyMnKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjID0gMDtcblx0XHRcdFx0XHRcdFx0XHRcdGZvcihpID0gMCwgaiA9IHBhci5jaGlsZHJlbi5sZW5ndGg7IGkgPCBqOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0YyArPSBtW3Bhci5jaGlsZHJlbltpXV0uc3RhdGVbIHQgPyAnc2VsZWN0ZWQnIDogJ2NoZWNrZWQnIF07XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRpZihjID09PSBqKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHBhci5zdGF0ZVsgdCA/ICdzZWxlY3RlZCcgOiAnY2hlY2tlZCcgXSA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRoaXMuX2RhdGFbIHQgPyAnY29yZScgOiAnY2hlY2tib3gnIF0uc2VsZWN0ZWQucHVzaChwYXIuaWQpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0bXAgPSB0aGlzLmdldF9ub2RlKHBhciwgdHJ1ZSk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmKHRtcCAmJiB0bXAubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dG1wLmNoaWxkcmVuKCcuanN0cmVlLWFuY2hvcicpLmFkZENsYXNzKHQgPyAnanN0cmVlLWNsaWNrZWQnIDogJ2pzdHJlZS1jaGVja2VkJyk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdHBhciA9IHRoaXMuZ2V0X25vZGUocGFyLnBhcmVudCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0Ly8gYXBwbHkgZG93biAocHJvY2VzcyAuY2hpbGRyZW4gc2VwYXJhdGVseT8pXG5cdFx0XHRcdFx0XHRcdGlmKHMuaW5kZXhPZignZG93bicpICE9PSAtMSAmJiBkb20ubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRcdFx0ZG9tLmZpbmQoJy5qc3RyZWUtYW5jaG9yJykuYWRkQ2xhc3ModCA/ICdqc3RyZWUtY2xpY2tlZCcgOiAnanN0cmVlLWNoZWNrZWQnKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSwgdGhpcykpXG5cdFx0XHRcdFx0Lm9uKHRoaXMuc2V0dGluZ3MuY2hlY2tib3gudGllX3NlbGVjdGlvbiA/ICdkZXNlbGVjdF9hbGwuanN0cmVlJyA6ICd1bmNoZWNrX2FsbC5qc3RyZWUnLCAkLnByb3h5KGZ1bmN0aW9uIChlLCBkYXRhKSB7XG5cdFx0XHRcdFx0XHRcdHZhciBvYmogPSB0aGlzLmdldF9ub2RlKCcjJyksXG5cdFx0XHRcdFx0XHRcdFx0bSA9IHRoaXMuX21vZGVsLmRhdGEsXG5cdFx0XHRcdFx0XHRcdFx0aSwgaiwgdG1wO1xuXHRcdFx0XHRcdFx0XHRmb3IoaSA9IDAsIGogPSBvYmouY2hpbGRyZW5fZC5sZW5ndGg7IGkgPCBqOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0XHR0bXAgPSBtW29iai5jaGlsZHJlbl9kW2ldXTtcblx0XHRcdFx0XHRcdFx0XHRpZih0bXAgJiYgdG1wLm9yaWdpbmFsICYmIHRtcC5vcmlnaW5hbC5zdGF0ZSAmJiB0bXAub3JpZ2luYWwuc3RhdGUudW5kZXRlcm1pbmVkKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR0bXAub3JpZ2luYWwuc3RhdGUudW5kZXRlcm1pbmVkID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9LCB0aGlzKSlcblx0XHRcdFx0XHQub24odGhpcy5zZXR0aW5ncy5jaGVja2JveC50aWVfc2VsZWN0aW9uID8gJ2Rlc2VsZWN0X25vZGUuanN0cmVlJyA6ICd1bmNoZWNrX25vZGUuanN0cmVlJywgJC5wcm94eShmdW5jdGlvbiAoZSwgZGF0YSkge1xuXHRcdFx0XHRcdFx0XHR2YXIgb2JqID0gZGF0YS5ub2RlLFxuXHRcdFx0XHRcdFx0XHRcdGRvbSA9IHRoaXMuZ2V0X25vZGUob2JqLCB0cnVlKSxcblx0XHRcdFx0XHRcdFx0XHRpLCBqLCB0bXAsIHMgPSB0aGlzLnNldHRpbmdzLmNoZWNrYm94LmNhc2NhZGUsIHQgPSB0aGlzLnNldHRpbmdzLmNoZWNrYm94LnRpZV9zZWxlY3Rpb247XG5cdFx0XHRcdFx0XHRcdGlmKG9iaiAmJiBvYmoub3JpZ2luYWwgJiYgb2JqLm9yaWdpbmFsLnN0YXRlICYmIG9iai5vcmlnaW5hbC5zdGF0ZS51bmRldGVybWluZWQpIHtcblx0XHRcdFx0XHRcdFx0XHRvYmoub3JpZ2luYWwuc3RhdGUudW5kZXRlcm1pbmVkID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHQvLyBhcHBseSBkb3duXG5cdFx0XHRcdFx0XHRcdGlmKHMuaW5kZXhPZignZG93bicpICE9PSAtMSkge1xuXHRcdFx0XHRcdFx0XHRcdGZvcihpID0gMCwgaiA9IG9iai5jaGlsZHJlbl9kLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuXHRcdFx0XHRcdFx0XHRcdFx0dG1wID0gdGhpcy5fbW9kZWwuZGF0YVtvYmouY2hpbGRyZW5fZFtpXV07XG5cdFx0XHRcdFx0XHRcdFx0XHR0bXAuc3RhdGVbIHQgPyAnc2VsZWN0ZWQnIDogJ2NoZWNrZWQnIF0gPSBmYWxzZTtcblx0XHRcdFx0XHRcdFx0XHRcdGlmKHRtcCAmJiB0bXAub3JpZ2luYWwgJiYgdG1wLm9yaWdpbmFsLnN0YXRlICYmIHRtcC5vcmlnaW5hbC5zdGF0ZS51bmRldGVybWluZWQpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dG1wLm9yaWdpbmFsLnN0YXRlLnVuZGV0ZXJtaW5lZCA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdC8vIGFwcGx5IHVwXG5cdFx0XHRcdFx0XHRcdGlmKHMuaW5kZXhPZigndXAnKSAhPT0gLTEpIHtcblx0XHRcdFx0XHRcdFx0XHRmb3IoaSA9IDAsIGogPSBvYmoucGFyZW50cy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0XHRcdHRtcCA9IHRoaXMuX21vZGVsLmRhdGFbb2JqLnBhcmVudHNbaV1dO1xuXHRcdFx0XHRcdFx0XHRcdFx0dG1wLnN0YXRlWyB0ID8gJ3NlbGVjdGVkJyA6ICdjaGVja2VkJyBdID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZih0bXAgJiYgdG1wLm9yaWdpbmFsICYmIHRtcC5vcmlnaW5hbC5zdGF0ZSAmJiB0bXAub3JpZ2luYWwuc3RhdGUudW5kZXRlcm1pbmVkKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRtcC5vcmlnaW5hbC5zdGF0ZS51bmRldGVybWluZWQgPSBmYWxzZTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdHRtcCA9IHRoaXMuZ2V0X25vZGUob2JqLnBhcmVudHNbaV0sIHRydWUpO1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYodG1wICYmIHRtcC5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dG1wLmNoaWxkcmVuKCcuanN0cmVlLWFuY2hvcicpLnJlbW92ZUNsYXNzKHQgPyAnanN0cmVlLWNsaWNrZWQnIDogJ2pzdHJlZS1jaGVja2VkJyk7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHRtcCA9IFtdO1xuXHRcdFx0XHRcdFx0XHRmb3IoaSA9IDAsIGogPSB0aGlzLl9kYXRhWyB0ID8gJ2NvcmUnIDogJ2NoZWNrYm94JyBdLnNlbGVjdGVkLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuXHRcdFx0XHRcdFx0XHRcdC8vIGFwcGx5IGRvd24gKyBhcHBseSB1cFxuXHRcdFx0XHRcdFx0XHRcdGlmKFxuXHRcdFx0XHRcdFx0XHRcdFx0KHMuaW5kZXhPZignZG93bicpID09PSAtMSB8fCAkLmluQXJyYXkodGhpcy5fZGF0YVsgdCA/ICdjb3JlJyA6ICdjaGVja2JveCcgXS5zZWxlY3RlZFtpXSwgb2JqLmNoaWxkcmVuX2QpID09PSAtMSkgJiZcblx0XHRcdFx0XHRcdFx0XHRcdChzLmluZGV4T2YoJ3VwJykgPT09IC0xIHx8ICQuaW5BcnJheSh0aGlzLl9kYXRhWyB0ID8gJ2NvcmUnIDogJ2NoZWNrYm94JyBdLnNlbGVjdGVkW2ldLCBvYmoucGFyZW50cykgPT09IC0xKVxuXHRcdFx0XHRcdFx0XHRcdCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0dG1wLnB1c2godGhpcy5fZGF0YVsgdCA/ICdjb3JlJyA6ICdjaGVja2JveCcgXS5zZWxlY3RlZFtpXSk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHRoaXMuX2RhdGFbIHQgPyAnY29yZScgOiAnY2hlY2tib3gnIF0uc2VsZWN0ZWQgPSAkLnZha2F0YS5hcnJheV91bmlxdWUodG1wKTtcblxuXHRcdFx0XHRcdFx0XHQvLyBhcHBseSBkb3duIChwcm9jZXNzIC5jaGlsZHJlbiBzZXBhcmF0ZWx5Pylcblx0XHRcdFx0XHRcdFx0aWYocy5pbmRleE9mKCdkb3duJykgIT09IC0xICYmIGRvbS5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdFx0XHRkb20uZmluZCgnLmpzdHJlZS1hbmNob3InKS5yZW1vdmVDbGFzcyh0ID8gJ2pzdHJlZS1jbGlja2VkJyA6ICdqc3RyZWUtY2hlY2tlZCcpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9LCB0aGlzKSk7XG5cdFx0XHR9XG5cdFx0XHRpZih0aGlzLnNldHRpbmdzLmNoZWNrYm94LmNhc2NhZGUuaW5kZXhPZigndXAnKSAhPT0gLTEpIHtcblx0XHRcdFx0dGhpcy5lbGVtZW50XG5cdFx0XHRcdFx0Lm9uKCdkZWxldGVfbm9kZS5qc3RyZWUnLCAkLnByb3h5KGZ1bmN0aW9uIChlLCBkYXRhKSB7XG5cdFx0XHRcdFx0XHRcdC8vIGFwcGx5IHVwICh3aG9sZSBoYW5kbGVyKVxuXHRcdFx0XHRcdFx0XHR2YXIgcCA9IHRoaXMuZ2V0X25vZGUoZGF0YS5wYXJlbnQpLFxuXHRcdFx0XHRcdFx0XHRcdG0gPSB0aGlzLl9tb2RlbC5kYXRhLFxuXHRcdFx0XHRcdFx0XHRcdGksIGosIGMsIHRtcCwgdCA9IHRoaXMuc2V0dGluZ3MuY2hlY2tib3gudGllX3NlbGVjdGlvbjtcblx0XHRcdFx0XHRcdFx0d2hpbGUocCAmJiBwLmlkICE9PSAnIycpIHtcblx0XHRcdFx0XHRcdFx0XHRjID0gMDtcblx0XHRcdFx0XHRcdFx0XHRmb3IoaSA9IDAsIGogPSBwLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuXHRcdFx0XHRcdFx0XHRcdFx0YyArPSBtW3AuY2hpbGRyZW5baV1dLnN0YXRlWyB0ID8gJ3NlbGVjdGVkJyA6ICdjaGVja2VkJyBdO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRpZihjID09PSBqKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRwLnN0YXRlWyB0ID8gJ3NlbGVjdGVkJyA6ICdjaGVja2VkJyBdID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0XHRcdHRoaXMuX2RhdGFbIHQgPyAnY29yZScgOiAnY2hlY2tib3gnIF0uc2VsZWN0ZWQucHVzaChwLmlkKTtcblx0XHRcdFx0XHRcdFx0XHRcdHRtcCA9IHRoaXMuZ2V0X25vZGUocCwgdHJ1ZSk7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZih0bXAgJiYgdG1wLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0bXAuY2hpbGRyZW4oJy5qc3RyZWUtYW5jaG9yJykuYWRkQ2xhc3ModCA/ICdqc3RyZWUtY2xpY2tlZCcgOiAnanN0cmVlLWNoZWNrZWQnKTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0cCA9IHRoaXMuZ2V0X25vZGUocC5wYXJlbnQpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9LCB0aGlzKSlcblx0XHRcdFx0XHQub24oJ21vdmVfbm9kZS5qc3RyZWUnLCAkLnByb3h5KGZ1bmN0aW9uIChlLCBkYXRhKSB7XG5cdFx0XHRcdFx0XHRcdC8vIGFwcGx5IHVwICh3aG9sZSBoYW5kbGVyKVxuXHRcdFx0XHRcdFx0XHR2YXIgaXNfbXVsdGkgPSBkYXRhLmlzX211bHRpLFxuXHRcdFx0XHRcdFx0XHRcdG9sZF9wYXIgPSBkYXRhLm9sZF9wYXJlbnQsXG5cdFx0XHRcdFx0XHRcdFx0bmV3X3BhciA9IHRoaXMuZ2V0X25vZGUoZGF0YS5wYXJlbnQpLFxuXHRcdFx0XHRcdFx0XHRcdG0gPSB0aGlzLl9tb2RlbC5kYXRhLFxuXHRcdFx0XHRcdFx0XHRcdHAsIGMsIGksIGosIHRtcCwgdCA9IHRoaXMuc2V0dGluZ3MuY2hlY2tib3gudGllX3NlbGVjdGlvbjtcblx0XHRcdFx0XHRcdFx0aWYoIWlzX211bHRpKSB7XG5cdFx0XHRcdFx0XHRcdFx0cCA9IHRoaXMuZ2V0X25vZGUob2xkX3Bhcik7XG5cdFx0XHRcdFx0XHRcdFx0d2hpbGUocCAmJiBwLmlkICE9PSAnIycpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGMgPSAwO1xuXHRcdFx0XHRcdFx0XHRcdFx0Zm9yKGkgPSAwLCBqID0gcC5jaGlsZHJlbi5sZW5ndGg7IGkgPCBqOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0YyArPSBtW3AuY2hpbGRyZW5baV1dLnN0YXRlWyB0ID8gJ3NlbGVjdGVkJyA6ICdjaGVja2VkJyBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0aWYoYyA9PT0gaikge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRwLnN0YXRlWyB0ID8gJ3NlbGVjdGVkJyA6ICdjaGVja2VkJyBdID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dGhpcy5fZGF0YVsgdCA/ICdjb3JlJyA6ICdjaGVja2JveCcgXS5zZWxlY3RlZC5wdXNoKHAuaWQpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0bXAgPSB0aGlzLmdldF9ub2RlKHAsIHRydWUpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZih0bXAgJiYgdG1wLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRtcC5jaGlsZHJlbignLmpzdHJlZS1hbmNob3InKS5hZGRDbGFzcyh0ID8gJ2pzdHJlZS1jbGlja2VkJyA6ICdqc3RyZWUtY2hlY2tlZCcpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRwID0gdGhpcy5nZXRfbm9kZShwLnBhcmVudCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHAgPSBuZXdfcGFyO1xuXHRcdFx0XHRcdFx0XHR3aGlsZShwICYmIHAuaWQgIT09ICcjJykge1xuXHRcdFx0XHRcdFx0XHRcdGMgPSAwO1xuXHRcdFx0XHRcdFx0XHRcdGZvcihpID0gMCwgaiA9IHAuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjICs9IG1bcC5jaGlsZHJlbltpXV0uc3RhdGVbIHQgPyAnc2VsZWN0ZWQnIDogJ2NoZWNrZWQnIF07XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdGlmKGMgPT09IGopIHtcblx0XHRcdFx0XHRcdFx0XHRcdGlmKCFwLnN0YXRlWyB0ID8gJ3NlbGVjdGVkJyA6ICdjaGVja2VkJyBdKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHAuc3RhdGVbIHQgPyAnc2VsZWN0ZWQnIDogJ2NoZWNrZWQnIF0gPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0aGlzLl9kYXRhWyB0ID8gJ2NvcmUnIDogJ2NoZWNrYm94JyBdLnNlbGVjdGVkLnB1c2gocC5pZCk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRtcCA9IHRoaXMuZ2V0X25vZGUocCwgdHJ1ZSk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmKHRtcCAmJiB0bXAubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dG1wLmNoaWxkcmVuKCcuanN0cmVlLWFuY2hvcicpLmFkZENsYXNzKHQgPyAnanN0cmVlLWNsaWNrZWQnIDogJ2pzdHJlZS1jaGVja2VkJyk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZihwLnN0YXRlWyB0ID8gJ3NlbGVjdGVkJyA6ICdjaGVja2VkJyBdKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHAuc3RhdGVbIHQgPyAnc2VsZWN0ZWQnIDogJ2NoZWNrZWQnIF0gPSBmYWxzZTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dGhpcy5fZGF0YVsgdCA/ICdjb3JlJyA6ICdjaGVja2JveCcgXS5zZWxlY3RlZCA9ICQudmFrYXRhLmFycmF5X3JlbW92ZV9pdGVtKHRoaXMuX2RhdGFbIHQgPyAnY29yZScgOiAnY2hlY2tib3gnIF0uc2VsZWN0ZWQsIHAuaWQpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0bXAgPSB0aGlzLmdldF9ub2RlKHAsIHRydWUpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZih0bXAgJiYgdG1wLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRtcC5jaGlsZHJlbignLmpzdHJlZS1hbmNob3InKS5yZW1vdmVDbGFzcyh0ID8gJ2pzdHJlZS1jbGlja2VkJyA6ICdqc3RyZWUtY2hlY2tlZCcpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdHAgPSB0aGlzLmdldF9ub2RlKHAucGFyZW50KTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSwgdGhpcykpO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0LyoqXG5cdFx0ICogc2V0IHRoZSB1bmRldGVybWluZWQgc3RhdGUgd2hlcmUgYW5kIGlmIG5lY2Vzc2FyeS4gVXNlZCBpbnRlcm5hbGx5LlxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICogQG5hbWUgX3VuZGV0ZXJtaW5lZCgpXG5cdFx0ICogQHBsdWdpbiBjaGVja2JveFxuXHRcdCAqL1xuXHRcdHRoaXMuX3VuZGV0ZXJtaW5lZCA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBpLCBqLCBtID0gdGhpcy5fbW9kZWwuZGF0YSwgdCA9IHRoaXMuc2V0dGluZ3MuY2hlY2tib3gudGllX3NlbGVjdGlvbiwgcyA9IHRoaXMuX2RhdGFbIHQgPyAnY29yZScgOiAnY2hlY2tib3gnIF0uc2VsZWN0ZWQsIHAgPSBbXSwgdHQgPSB0aGlzO1xuXHRcdFx0Zm9yKGkgPSAwLCBqID0gcy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcblx0XHRcdFx0aWYobVtzW2ldXSAmJiBtW3NbaV1dLnBhcmVudHMpIHtcblx0XHRcdFx0XHRwID0gcC5jb25jYXQobVtzW2ldXS5wYXJlbnRzKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Ly8gYXR0ZW1wdCBmb3Igc2VydmVyIHNpZGUgdW5kZXRlcm1pbmVkIHN0YXRlXG5cdFx0XHR0aGlzLmVsZW1lbnQuZmluZCgnLmpzdHJlZS1jbG9zZWQnKS5ub3QoJzpoYXMoLmpzdHJlZS1jaGlsZHJlbiknKVxuXHRcdFx0XHQuZWFjaChmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0dmFyIHRtcCA9IHR0LmdldF9ub2RlKHRoaXMpLCB0bXAyO1xuXHRcdFx0XHRcdGlmKCF0bXAuc3RhdGUubG9hZGVkKSB7XG5cdFx0XHRcdFx0XHRpZih0bXAub3JpZ2luYWwgJiYgdG1wLm9yaWdpbmFsLnN0YXRlICYmIHRtcC5vcmlnaW5hbC5zdGF0ZS51bmRldGVybWluZWQgJiYgdG1wLm9yaWdpbmFsLnN0YXRlLnVuZGV0ZXJtaW5lZCA9PT0gdHJ1ZSkge1xuXHRcdFx0XHRcdFx0XHRwLnB1c2godG1wLmlkKTtcblx0XHRcdFx0XHRcdFx0cCA9IHAuY29uY2F0KHRtcC5wYXJlbnRzKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRmb3IoaSA9IDAsIGogPSB0bXAuY2hpbGRyZW5fZC5sZW5ndGg7IGkgPCBqOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0dG1wMiA9IG1bdG1wLmNoaWxkcmVuX2RbaV1dO1xuXHRcdFx0XHRcdFx0XHRpZighdG1wMi5zdGF0ZS5sb2FkZWQgJiYgdG1wMi5vcmlnaW5hbCAmJiB0bXAyLm9yaWdpbmFsLnN0YXRlICYmIHRtcDIub3JpZ2luYWwuc3RhdGUudW5kZXRlcm1pbmVkICYmIHRtcDIub3JpZ2luYWwuc3RhdGUudW5kZXRlcm1pbmVkID09PSB0cnVlKSB7XG5cdFx0XHRcdFx0XHRcdFx0cC5wdXNoKHRtcDIuaWQpO1xuXHRcdFx0XHRcdFx0XHRcdHAgPSBwLmNvbmNhdCh0bXAyLnBhcmVudHMpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdHAgPSAkLnZha2F0YS5hcnJheV91bmlxdWUocCk7XG5cdFx0XHRwID0gJC52YWthdGEuYXJyYXlfcmVtb3ZlX2l0ZW0ocCwnIycpO1xuXG5cdFx0XHR0aGlzLmVsZW1lbnQuZmluZCgnLmpzdHJlZS11bmRldGVybWluZWQnKS5yZW1vdmVDbGFzcygnanN0cmVlLXVuZGV0ZXJtaW5lZCcpO1xuXHRcdFx0Zm9yKGkgPSAwLCBqID0gcC5sZW5ndGg7IGkgPCBqOyBpKyspIHtcblx0XHRcdFx0aWYoIW1bcFtpXV0uc3RhdGVbIHQgPyAnc2VsZWN0ZWQnIDogJ2NoZWNrZWQnIF0pIHtcblx0XHRcdFx0XHRzID0gdGhpcy5nZXRfbm9kZShwW2ldLCB0cnVlKTtcblx0XHRcdFx0XHRpZihzICYmIHMubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRzLmNoaWxkcmVuKCcuanN0cmVlLWFuY2hvcicpLmNoaWxkcmVuKCcuanN0cmVlLWNoZWNrYm94JykuYWRkQ2xhc3MoJ2pzdHJlZS11bmRldGVybWluZWQnKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHRcdHRoaXMucmVkcmF3X25vZGUgPSBmdW5jdGlvbihvYmosIGRlZXAsIGlzX2NhbGxiYWNrKSB7XG5cdFx0XHRvYmogPSBwYXJlbnQucmVkcmF3X25vZGUuY2FsbCh0aGlzLCBvYmosIGRlZXAsIGlzX2NhbGxiYWNrKTtcblx0XHRcdGlmKG9iaikge1xuXHRcdFx0XHR2YXIgaSwgaiwgdG1wID0gbnVsbDtcblx0XHRcdFx0Zm9yKGkgPSAwLCBqID0gb2JqLmNoaWxkTm9kZXMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG5cdFx0XHRcdFx0aWYob2JqLmNoaWxkTm9kZXNbaV0gJiYgb2JqLmNoaWxkTm9kZXNbaV0uY2xhc3NOYW1lICYmIG9iai5jaGlsZE5vZGVzW2ldLmNsYXNzTmFtZS5pbmRleE9mKFwianN0cmVlLWFuY2hvclwiKSAhPT0gLTEpIHtcblx0XHRcdFx0XHRcdHRtcCA9IG9iai5jaGlsZE5vZGVzW2ldO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKHRtcCkge1xuXHRcdFx0XHRcdGlmKCF0aGlzLnNldHRpbmdzLmNoZWNrYm94LnRpZV9zZWxlY3Rpb24gJiYgdGhpcy5fbW9kZWwuZGF0YVtvYmouaWRdLnN0YXRlLmNoZWNrZWQpIHsgdG1wLmNsYXNzTmFtZSArPSAnIGpzdHJlZS1jaGVja2VkJzsgfVxuXHRcdFx0XHRcdHRtcC5pbnNlcnRCZWZvcmUoX2kuY2xvbmVOb2RlKGZhbHNlKSwgdG1wLmNoaWxkTm9kZXNbMF0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZighaXNfY2FsbGJhY2sgJiYgdGhpcy5zZXR0aW5ncy5jaGVja2JveC5jYXNjYWRlLmluZGV4T2YoJ3VuZGV0ZXJtaW5lZCcpICE9PSAtMSkge1xuXHRcdFx0XHRpZih0aGlzLl9kYXRhLmNoZWNrYm94LnV0bykgeyBjbGVhclRpbWVvdXQodGhpcy5fZGF0YS5jaGVja2JveC51dG8pOyB9XG5cdFx0XHRcdHRoaXMuX2RhdGEuY2hlY2tib3gudXRvID0gc2V0VGltZW91dCgkLnByb3h5KHRoaXMuX3VuZGV0ZXJtaW5lZCwgdGhpcyksIDUwKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBvYmo7XG5cdFx0fTtcblx0XHQvKipcblx0XHQgKiBzaG93IHRoZSBub2RlIGNoZWNrYm94IGljb25zXG5cdFx0ICogQG5hbWUgc2hvd19jaGVja2JveGVzKClcblx0XHQgKiBAcGx1Z2luIGNoZWNrYm94XG5cdFx0ICovXG5cdFx0dGhpcy5zaG93X2NoZWNrYm94ZXMgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX2RhdGEuY29yZS50aGVtZXMuY2hlY2tib3hlcyA9IHRydWU7IHRoaXMuZ2V0X2NvbnRhaW5lcl91bCgpLnJlbW92ZUNsYXNzKFwianN0cmVlLW5vLWNoZWNrYm94ZXNcIik7IH07XG5cdFx0LyoqXG5cdFx0ICogaGlkZSB0aGUgbm9kZSBjaGVja2JveCBpY29uc1xuXHRcdCAqIEBuYW1lIGhpZGVfY2hlY2tib3hlcygpXG5cdFx0ICogQHBsdWdpbiBjaGVja2JveFxuXHRcdCAqL1xuXHRcdHRoaXMuaGlkZV9jaGVja2JveGVzID0gZnVuY3Rpb24gKCkgeyB0aGlzLl9kYXRhLmNvcmUudGhlbWVzLmNoZWNrYm94ZXMgPSBmYWxzZTsgdGhpcy5nZXRfY29udGFpbmVyX3VsKCkuYWRkQ2xhc3MoXCJqc3RyZWUtbm8tY2hlY2tib3hlc1wiKTsgfTtcblx0XHQvKipcblx0XHQgKiB0b2dnbGUgdGhlIG5vZGUgaWNvbnNcblx0XHQgKiBAbmFtZSB0b2dnbGVfY2hlY2tib3hlcygpXG5cdFx0ICogQHBsdWdpbiBjaGVja2JveFxuXHRcdCAqL1xuXHRcdHRoaXMudG9nZ2xlX2NoZWNrYm94ZXMgPSBmdW5jdGlvbiAoKSB7IGlmKHRoaXMuX2RhdGEuY29yZS50aGVtZXMuY2hlY2tib3hlcykgeyB0aGlzLmhpZGVfY2hlY2tib3hlcygpOyB9IGVsc2UgeyB0aGlzLnNob3dfY2hlY2tib3hlcygpOyB9IH07XG5cdFx0LyoqXG5cdFx0ICogY2hlY2tzIGlmIGEgbm9kZSBpcyBpbiBhbiB1bmRldGVybWluZWQgc3RhdGVcblx0XHQgKiBAbmFtZSBpc191bmRldGVybWluZWQob2JqKVxuXHRcdCAqIEBwYXJhbSAge21peGVkfSBvYmpcblx0XHQgKiBAcmV0dXJuIHtCb29sZWFufVxuXHRcdCAqL1xuXHRcdHRoaXMuaXNfdW5kZXRlcm1pbmVkID0gZnVuY3Rpb24gKG9iaikge1xuXHRcdFx0b2JqID0gdGhpcy5nZXRfbm9kZShvYmopO1xuXHRcdFx0dmFyIHMgPSB0aGlzLnNldHRpbmdzLmNoZWNrYm94LmNhc2NhZGUsIGksIGosIHQgPSB0aGlzLnNldHRpbmdzLmNoZWNrYm94LnRpZV9zZWxlY3Rpb24sIGQgPSB0aGlzLl9kYXRhWyB0ID8gJ2NvcmUnIDogJ2NoZWNrYm94JyBdLnNlbGVjdGVkLCBtID0gdGhpcy5fbW9kZWwuZGF0YTtcblx0XHRcdGlmKCFvYmogfHwgb2JqLnN0YXRlWyB0ID8gJ3NlbGVjdGVkJyA6ICdjaGVja2VkJyBdID09PSB0cnVlIHx8IHMuaW5kZXhPZigndW5kZXRlcm1pbmVkJykgPT09IC0xIHx8IChzLmluZGV4T2YoJ2Rvd24nKSA9PT0gLTEgJiYgcy5pbmRleE9mKCd1cCcpID09PSAtMSkpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0aWYoIW9iai5zdGF0ZS5sb2FkZWQgJiYgb2JqLm9yaWdpbmFsLnN0YXRlLnVuZGV0ZXJtaW5lZCA9PT0gdHJ1ZSkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdGZvcihpID0gMCwgaiA9IG9iai5jaGlsZHJlbl9kLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuXHRcdFx0XHRpZigkLmluQXJyYXkob2JqLmNoaWxkcmVuX2RbaV0sIGQpICE9PSAtMSB8fCAoIW1bb2JqLmNoaWxkcmVuX2RbaV1dLnN0YXRlLmxvYWRlZCAmJiBtW29iai5jaGlsZHJlbl9kW2ldXS5vcmlnaW5hbC5zdGF0ZS51bmRldGVybWluZWQpKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9O1xuXG5cdFx0dGhpcy5hY3RpdmF0ZV9ub2RlID0gZnVuY3Rpb24gKG9iaiwgZSkge1xuXHRcdFx0aWYodGhpcy5zZXR0aW5ncy5jaGVja2JveC50aWVfc2VsZWN0aW9uICYmICh0aGlzLnNldHRpbmdzLmNoZWNrYm94Lndob2xlX25vZGUgfHwgJChlLnRhcmdldCkuaGFzQ2xhc3MoJ2pzdHJlZS1jaGVja2JveCcpKSkge1xuXHRcdFx0XHRlLmN0cmxLZXkgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0aWYodGhpcy5zZXR0aW5ncy5jaGVja2JveC50aWVfc2VsZWN0aW9uIHx8ICghdGhpcy5zZXR0aW5ncy5jaGVja2JveC53aG9sZV9ub2RlICYmICEkKGUudGFyZ2V0KS5oYXNDbGFzcygnanN0cmVlLWNoZWNrYm94JykpKSB7XG5cdFx0XHRcdHJldHVybiBwYXJlbnQuYWN0aXZhdGVfbm9kZS5jYWxsKHRoaXMsIG9iaiwgZSk7XG5cdFx0XHR9XG5cdFx0XHRpZih0aGlzLmlzX2NoZWNrZWQob2JqKSkge1xuXHRcdFx0XHR0aGlzLnVuY2hlY2tfbm9kZShvYmosIGUpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdHRoaXMuY2hlY2tfbm9kZShvYmosIGUpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy50cmlnZ2VyKCdhY3RpdmF0ZV9ub2RlJywgeyAnbm9kZScgOiB0aGlzLmdldF9ub2RlKG9iaikgfSk7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIGNoZWNrIGEgbm9kZSAob25seSBpZiB0aWVfc2VsZWN0aW9uIGluIGNoZWNrYm94IHNldHRpbmdzIGlzIGZhbHNlLCBvdGhlcndpc2Ugc2VsZWN0X25vZGUgd2lsbCBiZSBjYWxsZWQgaW50ZXJuYWxseSlcblx0XHQgKiBAbmFtZSBjaGVja19ub2RlKG9iailcblx0XHQgKiBAcGFyYW0ge21peGVkfSBvYmogYW4gYXJyYXkgY2FuIGJlIHVzZWQgdG8gY2hlY2sgbXVsdGlwbGUgbm9kZXNcblx0XHQgKiBAdHJpZ2dlciBjaGVja19ub2RlLmpzdHJlZVxuXHRcdCAqIEBwbHVnaW4gY2hlY2tib3hcblx0XHQgKi9cblx0XHR0aGlzLmNoZWNrX25vZGUgPSBmdW5jdGlvbiAob2JqLCBlKSB7XG5cdFx0XHRpZih0aGlzLnNldHRpbmdzLmNoZWNrYm94LnRpZV9zZWxlY3Rpb24pIHsgcmV0dXJuIHRoaXMuc2VsZWN0X25vZGUob2JqLCBmYWxzZSwgdHJ1ZSwgZSk7IH1cblx0XHRcdHZhciBkb20sIHQxLCB0MiwgdGg7XG5cdFx0XHRpZigkLmlzQXJyYXkob2JqKSkge1xuXHRcdFx0XHRvYmogPSBvYmouc2xpY2UoKTtcblx0XHRcdFx0Zm9yKHQxID0gMCwgdDIgPSBvYmoubGVuZ3RoOyB0MSA8IHQyOyB0MSsrKSB7XG5cdFx0XHRcdFx0dGhpcy5jaGVja19ub2RlKG9ialt0MV0sIGUpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0b2JqID0gdGhpcy5nZXRfbm9kZShvYmopO1xuXHRcdFx0aWYoIW9iaiB8fCBvYmouaWQgPT09ICcjJykge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHRkb20gPSB0aGlzLmdldF9ub2RlKG9iaiwgdHJ1ZSk7XG5cdFx0XHRpZighb2JqLnN0YXRlLmNoZWNrZWQpIHtcblx0XHRcdFx0b2JqLnN0YXRlLmNoZWNrZWQgPSB0cnVlO1xuXHRcdFx0XHR0aGlzLl9kYXRhLmNoZWNrYm94LnNlbGVjdGVkLnB1c2gob2JqLmlkKTtcblx0XHRcdFx0aWYoZG9tICYmIGRvbS5sZW5ndGgpIHtcblx0XHRcdFx0XHRkb20uY2hpbGRyZW4oJy5qc3RyZWUtYW5jaG9yJykuYWRkQ2xhc3MoJ2pzdHJlZS1jaGVja2VkJyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0LyoqXG5cdFx0XHRcdCAqIHRyaWdnZXJlZCB3aGVuIGFuIG5vZGUgaXMgY2hlY2tlZCAob25seSBpZiB0aWVfc2VsZWN0aW9uIGluIGNoZWNrYm94IHNldHRpbmdzIGlzIGZhbHNlKVxuXHRcdFx0XHQgKiBAZXZlbnRcblx0XHRcdFx0ICogQG5hbWUgY2hlY2tfbm9kZS5qc3RyZWVcblx0XHRcdFx0ICogQHBhcmFtIHtPYmplY3R9IG5vZGVcblx0XHRcdFx0ICogQHBhcmFtIHtBcnJheX0gc2VsZWN0ZWQgdGhlIGN1cnJlbnQgc2VsZWN0aW9uXG5cdFx0XHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCB0aGUgZXZlbnQgKGlmIGFueSkgdGhhdCB0cmlnZ2VyZWQgdGhpcyBjaGVja19ub2RlXG5cdFx0XHRcdCAqIEBwbHVnaW4gY2hlY2tib3hcblx0XHRcdFx0ICovXG5cdFx0XHRcdHRoaXMudHJpZ2dlcignY2hlY2tfbm9kZScsIHsgJ25vZGUnIDogb2JqLCAnc2VsZWN0ZWQnIDogdGhpcy5fZGF0YS5jaGVja2JveC5zZWxlY3RlZCwgJ2V2ZW50JyA6IGUgfSk7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHQvKipcblx0XHQgKiB1bmNoZWNrIGEgbm9kZSAob25seSBpZiB0aWVfc2VsZWN0aW9uIGluIGNoZWNrYm94IHNldHRpbmdzIGlzIGZhbHNlLCBvdGhlcndpc2UgZGVzZWxlY3Rfbm9kZSB3aWxsIGJlIGNhbGxlZCBpbnRlcm5hbGx5KVxuXHRcdCAqIEBuYW1lIGRlc2VsZWN0X25vZGUob2JqKVxuXHRcdCAqIEBwYXJhbSB7bWl4ZWR9IG9iaiBhbiBhcnJheSBjYW4gYmUgdXNlZCB0byBkZXNlbGVjdCBtdWx0aXBsZSBub2Rlc1xuXHRcdCAqIEB0cmlnZ2VyIHVuY2hlY2tfbm9kZS5qc3RyZWVcblx0XHQgKiBAcGx1Z2luIGNoZWNrYm94XG5cdFx0ICovXG5cdFx0dGhpcy51bmNoZWNrX25vZGUgPSBmdW5jdGlvbiAob2JqLCBlKSB7XG5cdFx0XHRpZih0aGlzLnNldHRpbmdzLmNoZWNrYm94LnRpZV9zZWxlY3Rpb24pIHsgcmV0dXJuIHRoaXMuZGVzZWxlY3Rfbm9kZShvYmosIGZhbHNlLCBlKTsgfVxuXHRcdFx0dmFyIHQxLCB0MiwgZG9tO1xuXHRcdFx0aWYoJC5pc0FycmF5KG9iaikpIHtcblx0XHRcdFx0b2JqID0gb2JqLnNsaWNlKCk7XG5cdFx0XHRcdGZvcih0MSA9IDAsIHQyID0gb2JqLmxlbmd0aDsgdDEgPCB0MjsgdDErKykge1xuXHRcdFx0XHRcdHRoaXMudW5jaGVja19ub2RlKG9ialt0MV0sIGUpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0b2JqID0gdGhpcy5nZXRfbm9kZShvYmopO1xuXHRcdFx0aWYoIW9iaiB8fCBvYmouaWQgPT09ICcjJykge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHRkb20gPSB0aGlzLmdldF9ub2RlKG9iaiwgdHJ1ZSk7XG5cdFx0XHRpZihvYmouc3RhdGUuY2hlY2tlZCkge1xuXHRcdFx0XHRvYmouc3RhdGUuY2hlY2tlZCA9IGZhbHNlO1xuXHRcdFx0XHR0aGlzLl9kYXRhLmNoZWNrYm94LnNlbGVjdGVkID0gJC52YWthdGEuYXJyYXlfcmVtb3ZlX2l0ZW0odGhpcy5fZGF0YS5jaGVja2JveC5zZWxlY3RlZCwgb2JqLmlkKTtcblx0XHRcdFx0aWYoZG9tLmxlbmd0aCkge1xuXHRcdFx0XHRcdGRvbS5jaGlsZHJlbignLmpzdHJlZS1hbmNob3InKS5yZW1vdmVDbGFzcygnanN0cmVlLWNoZWNrZWQnKTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvKipcblx0XHRcdFx0ICogdHJpZ2dlcmVkIHdoZW4gYW4gbm9kZSBpcyB1bmNoZWNrZWQgKG9ubHkgaWYgdGllX3NlbGVjdGlvbiBpbiBjaGVja2JveCBzZXR0aW5ncyBpcyBmYWxzZSlcblx0XHRcdFx0ICogQGV2ZW50XG5cdFx0XHRcdCAqIEBuYW1lIHVuY2hlY2tfbm9kZS5qc3RyZWVcblx0XHRcdFx0ICogQHBhcmFtIHtPYmplY3R9IG5vZGVcblx0XHRcdFx0ICogQHBhcmFtIHtBcnJheX0gc2VsZWN0ZWQgdGhlIGN1cnJlbnQgc2VsZWN0aW9uXG5cdFx0XHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCB0aGUgZXZlbnQgKGlmIGFueSkgdGhhdCB0cmlnZ2VyZWQgdGhpcyB1bmNoZWNrX25vZGVcblx0XHRcdFx0ICogQHBsdWdpbiBjaGVja2JveFxuXHRcdFx0XHQgKi9cblx0XHRcdFx0dGhpcy50cmlnZ2VyKCd1bmNoZWNrX25vZGUnLCB7ICdub2RlJyA6IG9iaiwgJ3NlbGVjdGVkJyA6IHRoaXMuX2RhdGEuY2hlY2tib3guc2VsZWN0ZWQsICdldmVudCcgOiBlIH0pO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0LyoqXG5cdFx0ICogY2hlY2tzIGFsbCBub2RlcyBpbiB0aGUgdHJlZSAob25seSBpZiB0aWVfc2VsZWN0aW9uIGluIGNoZWNrYm94IHNldHRpbmdzIGlzIGZhbHNlLCBvdGhlcndpc2Ugc2VsZWN0X2FsbCB3aWxsIGJlIGNhbGxlZCBpbnRlcm5hbGx5KVxuXHRcdCAqIEBuYW1lIGNoZWNrX2FsbCgpXG5cdFx0ICogQHRyaWdnZXIgY2hlY2tfYWxsLmpzdHJlZSwgY2hhbmdlZC5qc3RyZWVcblx0XHQgKiBAcGx1Z2luIGNoZWNrYm94XG5cdFx0ICovXG5cdFx0dGhpcy5jaGVja19hbGwgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRpZih0aGlzLnNldHRpbmdzLmNoZWNrYm94LnRpZV9zZWxlY3Rpb24pIHsgcmV0dXJuIHRoaXMuc2VsZWN0X2FsbCgpOyB9XG5cdFx0XHR2YXIgdG1wID0gdGhpcy5fZGF0YS5jaGVja2JveC5zZWxlY3RlZC5jb25jYXQoW10pLCBpLCBqO1xuXHRcdFx0dGhpcy5fZGF0YS5jaGVja2JveC5zZWxlY3RlZCA9IHRoaXMuX21vZGVsLmRhdGFbJyMnXS5jaGlsZHJlbl9kLmNvbmNhdCgpO1xuXHRcdFx0Zm9yKGkgPSAwLCBqID0gdGhpcy5fZGF0YS5jaGVja2JveC5zZWxlY3RlZC5sZW5ndGg7IGkgPCBqOyBpKyspIHtcblx0XHRcdFx0aWYodGhpcy5fbW9kZWwuZGF0YVt0aGlzLl9kYXRhLmNoZWNrYm94LnNlbGVjdGVkW2ldXSkge1xuXHRcdFx0XHRcdHRoaXMuX21vZGVsLmRhdGFbdGhpcy5fZGF0YS5jaGVja2JveC5zZWxlY3RlZFtpXV0uc3RhdGUuY2hlY2tlZCA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHRoaXMucmVkcmF3KHRydWUpO1xuXHRcdFx0LyoqXG5cdFx0XHQgKiB0cmlnZ2VyZWQgd2hlbiBhbGwgbm9kZXMgYXJlIGNoZWNrZWQgKG9ubHkgaWYgdGllX3NlbGVjdGlvbiBpbiBjaGVja2JveCBzZXR0aW5ncyBpcyBmYWxzZSlcblx0XHRcdCAqIEBldmVudFxuXHRcdFx0ICogQG5hbWUgY2hlY2tfYWxsLmpzdHJlZVxuXHRcdFx0ICogQHBhcmFtIHtBcnJheX0gc2VsZWN0ZWQgdGhlIGN1cnJlbnQgc2VsZWN0aW9uXG5cdFx0XHQgKiBAcGx1Z2luIGNoZWNrYm94XG5cdFx0XHQgKi9cblx0XHRcdHRoaXMudHJpZ2dlcignY2hlY2tfYWxsJywgeyAnc2VsZWN0ZWQnIDogdGhpcy5fZGF0YS5jaGVja2JveC5zZWxlY3RlZCB9KTtcblx0XHR9O1xuXHRcdC8qKlxuXHRcdCAqIHVuY2hlY2sgYWxsIGNoZWNrZWQgbm9kZXMgKG9ubHkgaWYgdGllX3NlbGVjdGlvbiBpbiBjaGVja2JveCBzZXR0aW5ncyBpcyBmYWxzZSwgb3RoZXJ3aXNlIGRlc2VsZWN0X2FsbCB3aWxsIGJlIGNhbGxlZCBpbnRlcm5hbGx5KVxuXHRcdCAqIEBuYW1lIHVuY2hlY2tfYWxsKClcblx0XHQgKiBAdHJpZ2dlciB1bmNoZWNrX2FsbC5qc3RyZWVcblx0XHQgKiBAcGx1Z2luIGNoZWNrYm94XG5cdFx0ICovXG5cdFx0dGhpcy51bmNoZWNrX2FsbCA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdGlmKHRoaXMuc2V0dGluZ3MuY2hlY2tib3gudGllX3NlbGVjdGlvbikgeyByZXR1cm4gdGhpcy5kZXNlbGVjdF9hbGwoKTsgfVxuXHRcdFx0dmFyIHRtcCA9IHRoaXMuX2RhdGEuY2hlY2tib3guc2VsZWN0ZWQuY29uY2F0KFtdKSwgaSwgajtcblx0XHRcdGZvcihpID0gMCwgaiA9IHRoaXMuX2RhdGEuY2hlY2tib3guc2VsZWN0ZWQubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG5cdFx0XHRcdGlmKHRoaXMuX21vZGVsLmRhdGFbdGhpcy5fZGF0YS5jaGVja2JveC5zZWxlY3RlZFtpXV0pIHtcblx0XHRcdFx0XHR0aGlzLl9tb2RlbC5kYXRhW3RoaXMuX2RhdGEuY2hlY2tib3guc2VsZWN0ZWRbaV1dLnN0YXRlLmNoZWNrZWQgPSBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dGhpcy5fZGF0YS5jaGVja2JveC5zZWxlY3RlZCA9IFtdO1xuXHRcdFx0dGhpcy5lbGVtZW50LmZpbmQoJy5qc3RyZWUtY2hlY2tlZCcpLnJlbW92ZUNsYXNzKCdqc3RyZWUtY2hlY2tlZCcpO1xuXHRcdFx0LyoqXG5cdFx0XHQgKiB0cmlnZ2VyZWQgd2hlbiBhbGwgbm9kZXMgYXJlIHVuY2hlY2tlZCAob25seSBpZiB0aWVfc2VsZWN0aW9uIGluIGNoZWNrYm94IHNldHRpbmdzIGlzIGZhbHNlKVxuXHRcdFx0ICogQGV2ZW50XG5cdFx0XHQgKiBAbmFtZSB1bmNoZWNrX2FsbC5qc3RyZWVcblx0XHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBub2RlIHRoZSBwcmV2aW91cyBzZWxlY3Rpb25cblx0XHRcdCAqIEBwYXJhbSB7QXJyYXl9IHNlbGVjdGVkIHRoZSBjdXJyZW50IHNlbGVjdGlvblxuXHRcdFx0ICogQHBsdWdpbiBjaGVja2JveFxuXHRcdFx0ICovXG5cdFx0XHR0aGlzLnRyaWdnZXIoJ3VuY2hlY2tfYWxsJywgeyAnc2VsZWN0ZWQnIDogdGhpcy5fZGF0YS5jaGVja2JveC5zZWxlY3RlZCwgJ25vZGUnIDogdG1wIH0pO1xuXHRcdH07XG5cdFx0LyoqXG5cdFx0ICogY2hlY2tzIGlmIGEgbm9kZSBpcyBjaGVja2VkIChpZiB0aWVfc2VsZWN0aW9uIGlzIG9uIGluIHRoZSBzZXR0aW5ncyB0aGlzIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIHRoZSBzYW1lIGFzIGlzX3NlbGVjdGVkKVxuXHRcdCAqIEBuYW1lIGlzX2NoZWNrZWQob2JqKVxuXHRcdCAqIEBwYXJhbSAge21peGVkfSAgb2JqXG5cdFx0ICogQHJldHVybiB7Qm9vbGVhbn1cblx0XHQgKiBAcGx1Z2luIGNoZWNrYm94XG5cdFx0ICovXG5cdFx0dGhpcy5pc19jaGVja2VkID0gZnVuY3Rpb24gKG9iaikge1xuXHRcdFx0aWYodGhpcy5zZXR0aW5ncy5jaGVja2JveC50aWVfc2VsZWN0aW9uKSB7IHJldHVybiB0aGlzLmlzX3NlbGVjdGVkKG9iaik7IH1cblx0XHRcdG9iaiA9IHRoaXMuZ2V0X25vZGUob2JqKTtcblx0XHRcdGlmKCFvYmogfHwgb2JqLmlkID09PSAnIycpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0XHRyZXR1cm4gb2JqLnN0YXRlLmNoZWNrZWQ7XG5cdFx0fTtcblx0XHQvKipcblx0XHQgKiBnZXQgYW4gYXJyYXkgb2YgYWxsIGNoZWNrZWQgbm9kZXMgKGlmIHRpZV9zZWxlY3Rpb24gaXMgb24gaW4gdGhlIHNldHRpbmdzIHRoaXMgZnVuY3Rpb24gd2lsbCByZXR1cm4gdGhlIHNhbWUgYXMgZ2V0X3NlbGVjdGVkKVxuXHRcdCAqIEBuYW1lIGdldF9jaGVja2VkKFtmdWxsXSlcblx0XHQgKiBAcGFyYW0gIHttaXhlZH0gIGZ1bGwgaWYgc2V0IHRvIGB0cnVlYCB0aGUgcmV0dXJuZWQgYXJyYXkgd2lsbCBjb25zaXN0IG9mIHRoZSBmdWxsIG5vZGUgb2JqZWN0cywgb3RoZXJ3aXNlIC0gb25seSBJRHMgd2lsbCBiZSByZXR1cm5lZFxuXHRcdCAqIEByZXR1cm4ge0FycmF5fVxuXHRcdCAqIEBwbHVnaW4gY2hlY2tib3hcblx0XHQgKi9cblx0XHR0aGlzLmdldF9jaGVja2VkID0gZnVuY3Rpb24gKGZ1bGwpIHtcblx0XHRcdGlmKHRoaXMuc2V0dGluZ3MuY2hlY2tib3gudGllX3NlbGVjdGlvbikgeyByZXR1cm4gdGhpcy5nZXRfc2VsZWN0ZWQoZnVsbCk7IH1cblx0XHRcdHJldHVybiBmdWxsID8gJC5tYXAodGhpcy5fZGF0YS5jaGVja2JveC5zZWxlY3RlZCwgJC5wcm94eShmdW5jdGlvbiAoaSkgeyByZXR1cm4gdGhpcy5nZXRfbm9kZShpKTsgfSwgdGhpcykpIDogdGhpcy5fZGF0YS5jaGVja2JveC5zZWxlY3RlZDtcblx0XHR9O1xuXHRcdC8qKlxuXHRcdCAqIGdldCBhbiBhcnJheSBvZiBhbGwgdG9wIGxldmVsIGNoZWNrZWQgbm9kZXMgKGlnbm9yaW5nIGNoaWxkcmVuIG9mIGNoZWNrZWQgbm9kZXMpIChpZiB0aWVfc2VsZWN0aW9uIGlzIG9uIGluIHRoZSBzZXR0aW5ncyB0aGlzIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIHRoZSBzYW1lIGFzIGdldF90b3Bfc2VsZWN0ZWQpXG5cdFx0ICogQG5hbWUgZ2V0X3RvcF9jaGVja2VkKFtmdWxsXSlcblx0XHQgKiBAcGFyYW0gIHttaXhlZH0gIGZ1bGwgaWYgc2V0IHRvIGB0cnVlYCB0aGUgcmV0dXJuZWQgYXJyYXkgd2lsbCBjb25zaXN0IG9mIHRoZSBmdWxsIG5vZGUgb2JqZWN0cywgb3RoZXJ3aXNlIC0gb25seSBJRHMgd2lsbCBiZSByZXR1cm5lZFxuXHRcdCAqIEByZXR1cm4ge0FycmF5fVxuXHRcdCAqIEBwbHVnaW4gY2hlY2tib3hcblx0XHQgKi9cblx0XHR0aGlzLmdldF90b3BfY2hlY2tlZCA9IGZ1bmN0aW9uIChmdWxsKSB7XG5cdFx0XHRpZih0aGlzLnNldHRpbmdzLmNoZWNrYm94LnRpZV9zZWxlY3Rpb24pIHsgcmV0dXJuIHRoaXMuZ2V0X3RvcF9zZWxlY3RlZChmdWxsKTsgfVxuXHRcdFx0dmFyIHRtcCA9IHRoaXMuZ2V0X2NoZWNrZWQodHJ1ZSksXG5cdFx0XHRcdG9iaiA9IHt9LCBpLCBqLCBrLCBsO1xuXHRcdFx0Zm9yKGkgPSAwLCBqID0gdG1wLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuXHRcdFx0XHRvYmpbdG1wW2ldLmlkXSA9IHRtcFtpXTtcblx0XHRcdH1cblx0XHRcdGZvcihpID0gMCwgaiA9IHRtcC5sZW5ndGg7IGkgPCBqOyBpKyspIHtcblx0XHRcdFx0Zm9yKGsgPSAwLCBsID0gdG1wW2ldLmNoaWxkcmVuX2QubGVuZ3RoOyBrIDwgbDsgaysrKSB7XG5cdFx0XHRcdFx0aWYob2JqW3RtcFtpXS5jaGlsZHJlbl9kW2tdXSkge1xuXHRcdFx0XHRcdFx0ZGVsZXRlIG9ialt0bXBbaV0uY2hpbGRyZW5fZFtrXV07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR0bXAgPSBbXTtcblx0XHRcdGZvcihpIGluIG9iaikge1xuXHRcdFx0XHRpZihvYmouaGFzT3duUHJvcGVydHkoaSkpIHtcblx0XHRcdFx0XHR0bXAucHVzaChpKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZ1bGwgPyAkLm1hcCh0bXAsICQucHJveHkoZnVuY3Rpb24gKGkpIHsgcmV0dXJuIHRoaXMuZ2V0X25vZGUoaSk7IH0sIHRoaXMpKSA6IHRtcDtcblx0XHR9O1xuXHRcdC8qKlxuXHRcdCAqIGdldCBhbiBhcnJheSBvZiBhbGwgYm90dG9tIGxldmVsIGNoZWNrZWQgbm9kZXMgKGlnbm9yaW5nIHNlbGVjdGVkIHBhcmVudHMpIChpZiB0aWVfc2VsZWN0aW9uIGlzIG9uIGluIHRoZSBzZXR0aW5ncyB0aGlzIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIHRoZSBzYW1lIGFzIGdldF9ib3R0b21fc2VsZWN0ZWQpXG5cdFx0ICogQG5hbWUgZ2V0X2JvdHRvbV9jaGVja2VkKFtmdWxsXSlcblx0XHQgKiBAcGFyYW0gIHttaXhlZH0gIGZ1bGwgaWYgc2V0IHRvIGB0cnVlYCB0aGUgcmV0dXJuZWQgYXJyYXkgd2lsbCBjb25zaXN0IG9mIHRoZSBmdWxsIG5vZGUgb2JqZWN0cywgb3RoZXJ3aXNlIC0gb25seSBJRHMgd2lsbCBiZSByZXR1cm5lZFxuXHRcdCAqIEByZXR1cm4ge0FycmF5fVxuXHRcdCAqIEBwbHVnaW4gY2hlY2tib3hcblx0XHQgKi9cblx0XHR0aGlzLmdldF9ib3R0b21fY2hlY2tlZCA9IGZ1bmN0aW9uIChmdWxsKSB7XG5cdFx0XHRpZih0aGlzLnNldHRpbmdzLmNoZWNrYm94LnRpZV9zZWxlY3Rpb24pIHsgcmV0dXJuIHRoaXMuZ2V0X2JvdHRvbV9zZWxlY3RlZChmdWxsKTsgfVxuXHRcdFx0dmFyIHRtcCA9IHRoaXMuZ2V0X2NoZWNrZWQodHJ1ZSksXG5cdFx0XHRcdG9iaiA9IFtdLCBpLCBqO1xuXHRcdFx0Zm9yKGkgPSAwLCBqID0gdG1wLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuXHRcdFx0XHRpZighdG1wW2ldLmNoaWxkcmVuLmxlbmd0aCkge1xuXHRcdFx0XHRcdG9iai5wdXNoKHRtcFtpXS5pZCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBmdWxsID8gJC5tYXAob2JqLCAkLnByb3h5KGZ1bmN0aW9uIChpKSB7IHJldHVybiB0aGlzLmdldF9ub2RlKGkpOyB9LCB0aGlzKSkgOiBvYmo7XG5cdFx0fTtcblx0fTtcblxuXHQvLyBpbmNsdWRlIHRoZSBjaGVja2JveCBwbHVnaW4gYnkgZGVmYXVsdFxuXHQvLyAkLmpzdHJlZS5kZWZhdWx0cy5wbHVnaW5zLnB1c2goXCJjaGVja2JveFwiKTtcblxuLyoqXG4gKiAjIyMgQ29udGV4dG1lbnUgcGx1Z2luXG4gKlxuICogU2hvd3MgYSBjb250ZXh0IG1lbnUgd2hlbiBhIG5vZGUgaXMgcmlnaHQtY2xpY2tlZC5cbiAqL1xuLy8gVE9ETzogbW92ZSBsb2dpYyBvdXRzaWRlIG9mIGZ1bmN0aW9uICsgY2hlY2sgbXVsdGlwbGUgbW92ZVxuXG5cdC8qKlxuXHQgKiBzdG9yZXMgYWxsIGRlZmF1bHRzIGZvciB0aGUgY29udGV4dG1lbnUgcGx1Z2luXG5cdCAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLmNvbnRleHRtZW51XG5cdCAqIEBwbHVnaW4gY29udGV4dG1lbnVcblx0ICovXG5cdCQuanN0cmVlLmRlZmF1bHRzLmNvbnRleHRtZW51ID0ge1xuXHRcdC8qKlxuXHRcdCAqIGEgYm9vbGVhbiBpbmRpY2F0aW5nIGlmIHRoZSBub2RlIHNob3VsZCBiZSBzZWxlY3RlZCB3aGVuIHRoZSBjb250ZXh0IG1lbnUgaXMgaW52b2tlZCBvbiBpdC4gRGVmYXVsdHMgdG8gYHRydWVgLlxuXHRcdCAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLmNvbnRleHRtZW51LnNlbGVjdF9ub2RlXG5cdFx0ICogQHBsdWdpbiBjb250ZXh0bWVudVxuXHRcdCAqL1xuXHRcdHNlbGVjdF9ub2RlIDogdHJ1ZSxcblx0XHQvKipcblx0XHQgKiBhIGJvb2xlYW4gaW5kaWNhdGluZyBpZiB0aGUgbWVudSBzaG91bGQgYmUgc2hvd24gYWxpZ25lZCB3aXRoIHRoZSBub2RlLiBEZWZhdWx0cyB0byBgdHJ1ZWAsIG90aGVyd2lzZSB0aGUgbW91c2UgY29vcmRpbmF0ZXMgYXJlIHVzZWQuXG5cdFx0ICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuY29udGV4dG1lbnUuc2hvd19hdF9ub2RlXG5cdFx0ICogQHBsdWdpbiBjb250ZXh0bWVudVxuXHRcdCAqL1xuXHRcdHNob3dfYXRfbm9kZSA6IHRydWUsXG5cdFx0LyoqXG5cdFx0ICogYW4gb2JqZWN0IG9mIGFjdGlvbnMsIG9yIGEgZnVuY3Rpb24gdGhhdCBhY2NlcHRzIGEgbm9kZSBhbmQgYSBjYWxsYmFjayBmdW5jdGlvbiBhbmQgY2FsbHMgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHdpdGggYW4gb2JqZWN0IG9mIGFjdGlvbnMgYXZhaWxhYmxlIGZvciB0aGF0IG5vZGUgKHlvdSBjYW4gYWxzbyByZXR1cm4gdGhlIGl0ZW1zIHRvbykuXG5cdFx0ICogXG5cdFx0ICogRWFjaCBhY3Rpb24gY29uc2lzdHMgb2YgYSBrZXkgKGEgdW5pcXVlIG5hbWUpIGFuZCBhIHZhbHVlIHdoaWNoIGlzIGFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllcyAob25seSBsYWJlbCBhbmQgYWN0aW9uIGFyZSByZXF1aXJlZCk6XG5cdFx0ICogXG5cdFx0ICogKiBgc2VwYXJhdG9yX2JlZm9yZWAgLSBhIGJvb2xlYW4gaW5kaWNhdGluZyBpZiB0aGVyZSBzaG91bGQgYmUgYSBzZXBhcmF0b3IgYmVmb3JlIHRoaXMgaXRlbVxuXHRcdCAqICogYHNlcGFyYXRvcl9hZnRlcmAgLSBhIGJvb2xlYW4gaW5kaWNhdGluZyBpZiB0aGVyZSBzaG91bGQgYmUgYSBzZXBhcmF0b3IgYWZ0ZXIgdGhpcyBpdGVtXG5cdFx0ICogKiBgX2Rpc2FibGVkYCAtIGEgYm9vbGVhbiBpbmRpY2F0aW5nIGlmIHRoaXMgYWN0aW9uIHNob3VsZCBiZSBkaXNhYmxlZFxuXHRcdCAqICogYGxhYmVsYCAtIGEgc3RyaW5nIC0gdGhlIG5hbWUgb2YgdGhlIGFjdGlvbiAoY291bGQgYmUgYSBmdW5jdGlvbiByZXR1cm5pbmcgYSBzdHJpbmcpXG5cdFx0ICogKiBgYWN0aW9uYCAtIGEgZnVuY3Rpb24gdG8gYmUgZXhlY3V0ZWQgaWYgdGhpcyBpdGVtIGlzIGNob3NlblxuXHRcdCAqICogYGljb25gIC0gYSBzdHJpbmcsIGNhbiBiZSBhIHBhdGggdG8gYW4gaWNvbiBvciBhIGNsYXNzTmFtZSwgaWYgdXNpbmcgYW4gaW1hZ2UgdGhhdCBpcyBpbiB0aGUgY3VycmVudCBkaXJlY3RvcnkgdXNlIGEgYC4vYCBwcmVmaXgsIG90aGVyd2lzZSBpdCB3aWxsIGJlIGRldGVjdGVkIGFzIGEgY2xhc3Ncblx0XHQgKiAqIGBzaG9ydGN1dGAgLSBrZXlDb2RlIHdoaWNoIHdpbGwgdHJpZ2dlciB0aGUgYWN0aW9uIGlmIHRoZSBtZW51IGlzIG9wZW4gKGZvciBleGFtcGxlIGAxMTNgIGZvciByZW5hbWUsIHdoaWNoIGVxdWFscyBGMilcblx0XHQgKiAqIGBzaG9ydGN1dF9sYWJlbGAgLSBzaG9ydGN1dCBsYWJlbCAobGlrZSBmb3IgZXhhbXBsZSBgRjJgIGZvciByZW5hbWUpXG5cdFx0ICogXG5cdFx0ICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuY29udGV4dG1lbnUuaXRlbXNcblx0XHQgKiBAcGx1Z2luIGNvbnRleHRtZW51XG5cdFx0ICovXG5cdFx0aXRlbXMgOiBmdW5jdGlvbiAobywgY2IpIHsgLy8gQ291bGQgYmUgYW4gb2JqZWN0IGRpcmVjdGx5XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcImNyZWF0ZVwiIDoge1xuXHRcdFx0XHRcdFwic2VwYXJhdG9yX2JlZm9yZVwiXHQ6IGZhbHNlLFxuXHRcdFx0XHRcdFwic2VwYXJhdG9yX2FmdGVyXCJcdDogdHJ1ZSxcblx0XHRcdFx0XHRcIl9kaXNhYmxlZFwiXHRcdFx0OiBmYWxzZSwgLy8odGhpcy5jaGVjayhcImNyZWF0ZV9ub2RlXCIsIGRhdGEucmVmZXJlbmNlLCB7fSwgXCJsYXN0XCIpKSxcblx0XHRcdFx0XHRcImxhYmVsXCJcdFx0XHRcdDogXCJDcmVhdGVcIixcblx0XHRcdFx0XHRcImFjdGlvblwiXHRcdFx0OiBmdW5jdGlvbiAoZGF0YSkge1xuXHRcdFx0XHRcdFx0dmFyIGluc3QgPSAkLmpzdHJlZS5yZWZlcmVuY2UoZGF0YS5yZWZlcmVuY2UpLFxuXHRcdFx0XHRcdFx0XHRvYmogPSBpbnN0LmdldF9ub2RlKGRhdGEucmVmZXJlbmNlKTtcblx0XHRcdFx0XHRcdGluc3QuY3JlYXRlX25vZGUob2JqLCB7fSwgXCJsYXN0XCIsIGZ1bmN0aW9uIChuZXdfbm9kZSkge1xuXHRcdFx0XHRcdFx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgaW5zdC5lZGl0KG5ld19ub2RlKTsgfSwwKTtcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblx0XHRcdFx0XCJyZW5hbWVcIiA6IHtcblx0XHRcdFx0XHRcInNlcGFyYXRvcl9iZWZvcmVcIlx0OiBmYWxzZSxcblx0XHRcdFx0XHRcInNlcGFyYXRvcl9hZnRlclwiXHQ6IGZhbHNlLFxuXHRcdFx0XHRcdFwiX2Rpc2FibGVkXCJcdFx0XHQ6IGZhbHNlLCAvLyh0aGlzLmNoZWNrKFwicmVuYW1lX25vZGVcIiwgZGF0YS5yZWZlcmVuY2UsIHRoaXMuZ2V0X3BhcmVudChkYXRhLnJlZmVyZW5jZSksIFwiXCIpKSxcblx0XHRcdFx0XHRcImxhYmVsXCJcdFx0XHRcdDogXCJSZW5hbWVcIixcblx0XHRcdFx0XHQvKlxuXHRcdFx0XHRcdFwic2hvcnRjdXRcIlx0XHRcdDogMTEzLFxuXHRcdFx0XHRcdFwic2hvcnRjdXRfbGFiZWxcIlx0OiAnRjInLFxuXHRcdFx0XHRcdFwiaWNvblwiXHRcdFx0XHQ6IFwiZ2x5cGhpY29uIGdseXBoaWNvbi1sZWFmXCIsXG5cdFx0XHRcdFx0Ki9cblx0XHRcdFx0XHRcImFjdGlvblwiXHRcdFx0OiBmdW5jdGlvbiAoZGF0YSkge1xuXHRcdFx0XHRcdFx0dmFyIGluc3QgPSAkLmpzdHJlZS5yZWZlcmVuY2UoZGF0YS5yZWZlcmVuY2UpLFxuXHRcdFx0XHRcdFx0XHRvYmogPSBpbnN0LmdldF9ub2RlKGRhdGEucmVmZXJlbmNlKTtcblx0XHRcdFx0XHRcdGluc3QuZWRpdChvYmopO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblx0XHRcdFx0XCJyZW1vdmVcIiA6IHtcblx0XHRcdFx0XHRcInNlcGFyYXRvcl9iZWZvcmVcIlx0OiBmYWxzZSxcblx0XHRcdFx0XHRcImljb25cIlx0XHRcdFx0OiBmYWxzZSxcblx0XHRcdFx0XHRcInNlcGFyYXRvcl9hZnRlclwiXHQ6IGZhbHNlLFxuXHRcdFx0XHRcdFwiX2Rpc2FibGVkXCJcdFx0XHQ6IGZhbHNlLCAvLyh0aGlzLmNoZWNrKFwiZGVsZXRlX25vZGVcIiwgZGF0YS5yZWZlcmVuY2UsIHRoaXMuZ2V0X3BhcmVudChkYXRhLnJlZmVyZW5jZSksIFwiXCIpKSxcblx0XHRcdFx0XHRcImxhYmVsXCJcdFx0XHRcdDogXCJEZWxldGVcIixcblx0XHRcdFx0XHRcImFjdGlvblwiXHRcdFx0OiBmdW5jdGlvbiAoZGF0YSkge1xuXHRcdFx0XHRcdFx0dmFyIGluc3QgPSAkLmpzdHJlZS5yZWZlcmVuY2UoZGF0YS5yZWZlcmVuY2UpLFxuXHRcdFx0XHRcdFx0XHRvYmogPSBpbnN0LmdldF9ub2RlKGRhdGEucmVmZXJlbmNlKTtcblx0XHRcdFx0XHRcdGlmKGluc3QuaXNfc2VsZWN0ZWQob2JqKSkge1xuXHRcdFx0XHRcdFx0XHRpbnN0LmRlbGV0ZV9ub2RlKGluc3QuZ2V0X3NlbGVjdGVkKCkpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGluc3QuZGVsZXRlX25vZGUob2JqKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sXG5cdFx0XHRcdFwiY2NwXCIgOiB7XG5cdFx0XHRcdFx0XCJzZXBhcmF0b3JfYmVmb3JlXCJcdDogdHJ1ZSxcblx0XHRcdFx0XHRcImljb25cIlx0XHRcdFx0OiBmYWxzZSxcblx0XHRcdFx0XHRcInNlcGFyYXRvcl9hZnRlclwiXHQ6IGZhbHNlLFxuXHRcdFx0XHRcdFwibGFiZWxcIlx0XHRcdFx0OiBcIkVkaXRcIixcblx0XHRcdFx0XHRcImFjdGlvblwiXHRcdFx0OiBmYWxzZSxcblx0XHRcdFx0XHRcInN1Ym1lbnVcIiA6IHtcblx0XHRcdFx0XHRcdFwiY3V0XCIgOiB7XG5cdFx0XHRcdFx0XHRcdFwic2VwYXJhdG9yX2JlZm9yZVwiXHQ6IGZhbHNlLFxuXHRcdFx0XHRcdFx0XHRcInNlcGFyYXRvcl9hZnRlclwiXHQ6IGZhbHNlLFxuXHRcdFx0XHRcdFx0XHRcImxhYmVsXCJcdFx0XHRcdDogXCJDdXRcIixcblx0XHRcdFx0XHRcdFx0XCJhY3Rpb25cIlx0XHRcdDogZnVuY3Rpb24gKGRhdGEpIHtcblx0XHRcdFx0XHRcdFx0XHR2YXIgaW5zdCA9ICQuanN0cmVlLnJlZmVyZW5jZShkYXRhLnJlZmVyZW5jZSksXG5cdFx0XHRcdFx0XHRcdFx0XHRvYmogPSBpbnN0LmdldF9ub2RlKGRhdGEucmVmZXJlbmNlKTtcblx0XHRcdFx0XHRcdFx0XHRpZihpbnN0LmlzX3NlbGVjdGVkKG9iaikpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGluc3QuY3V0KGluc3QuZ2V0X3NlbGVjdGVkKCkpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdGluc3QuY3V0KG9iaik7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XCJjb3B5XCIgOiB7XG5cdFx0XHRcdFx0XHRcdFwic2VwYXJhdG9yX2JlZm9yZVwiXHQ6IGZhbHNlLFxuXHRcdFx0XHRcdFx0XHRcImljb25cIlx0XHRcdFx0OiBmYWxzZSxcblx0XHRcdFx0XHRcdFx0XCJzZXBhcmF0b3JfYWZ0ZXJcIlx0OiBmYWxzZSxcblx0XHRcdFx0XHRcdFx0XCJsYWJlbFwiXHRcdFx0XHQ6IFwiQ29weVwiLFxuXHRcdFx0XHRcdFx0XHRcImFjdGlvblwiXHRcdFx0OiBmdW5jdGlvbiAoZGF0YSkge1xuXHRcdFx0XHRcdFx0XHRcdHZhciBpbnN0ID0gJC5qc3RyZWUucmVmZXJlbmNlKGRhdGEucmVmZXJlbmNlKSxcblx0XHRcdFx0XHRcdFx0XHRcdG9iaiA9IGluc3QuZ2V0X25vZGUoZGF0YS5yZWZlcmVuY2UpO1xuXHRcdFx0XHRcdFx0XHRcdGlmKGluc3QuaXNfc2VsZWN0ZWQob2JqKSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0aW5zdC5jb3B5KGluc3QuZ2V0X3NlbGVjdGVkKCkpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdGluc3QuY29weShvYmopO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFwicGFzdGVcIiA6IHtcblx0XHRcdFx0XHRcdFx0XCJzZXBhcmF0b3JfYmVmb3JlXCJcdDogZmFsc2UsXG5cdFx0XHRcdFx0XHRcdFwiaWNvblwiXHRcdFx0XHQ6IGZhbHNlLFxuXHRcdFx0XHRcdFx0XHRcIl9kaXNhYmxlZFwiXHRcdFx0OiBmdW5jdGlvbiAoZGF0YSkge1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiAhJC5qc3RyZWUucmVmZXJlbmNlKGRhdGEucmVmZXJlbmNlKS5jYW5fcGFzdGUoKTtcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XCJzZXBhcmF0b3JfYWZ0ZXJcIlx0OiBmYWxzZSxcblx0XHRcdFx0XHRcdFx0XCJsYWJlbFwiXHRcdFx0XHQ6IFwiUGFzdGVcIixcblx0XHRcdFx0XHRcdFx0XCJhY3Rpb25cIlx0XHRcdDogZnVuY3Rpb24gKGRhdGEpIHtcblx0XHRcdFx0XHRcdFx0XHR2YXIgaW5zdCA9ICQuanN0cmVlLnJlZmVyZW5jZShkYXRhLnJlZmVyZW5jZSksXG5cdFx0XHRcdFx0XHRcdFx0XHRvYmogPSBpbnN0LmdldF9ub2RlKGRhdGEucmVmZXJlbmNlKTtcblx0XHRcdFx0XHRcdFx0XHRpbnN0LnBhc3RlKG9iaik7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fVxuXHR9O1xuXG5cdCQuanN0cmVlLnBsdWdpbnMuY29udGV4dG1lbnUgPSBmdW5jdGlvbiAob3B0aW9ucywgcGFyZW50KSB7XG5cdFx0dGhpcy5iaW5kID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0cGFyZW50LmJpbmQuY2FsbCh0aGlzKTtcblxuXHRcdFx0dmFyIGxhc3RfdHMgPSAwO1xuXHRcdFx0dGhpcy5lbGVtZW50XG5cdFx0XHRcdC5vbihcImNvbnRleHRtZW51LmpzdHJlZVwiLCBcIi5qc3RyZWUtYW5jaG9yXCIsICQucHJveHkoZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHRcdGxhc3RfdHMgPSBlLmN0cmxLZXkgPyBlLnRpbWVTdGFtcCA6IDA7XG5cdFx0XHRcdFx0XHRpZighdGhpcy5pc19sb2FkaW5nKGUuY3VycmVudFRhcmdldCkpIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5zaG93X2NvbnRleHRtZW51KGUuY3VycmVudFRhcmdldCwgZS5wYWdlWCwgZS5wYWdlWSwgZSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSwgdGhpcykpXG5cdFx0XHRcdC5vbihcImNsaWNrLmpzdHJlZVwiLCBcIi5qc3RyZWUtYW5jaG9yXCIsICQucHJveHkoZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0XHRcdGlmKHRoaXMuX2RhdGEuY29udGV4dG1lbnUudmlzaWJsZSAmJiAoIWxhc3RfdHMgfHwgZS50aW1lU3RhbXAgLSBsYXN0X3RzID4gMjUwKSkgeyAvLyB3b3JrIGFyb3VuZCBzYWZhcmkgJiBtYWNPUyBjdHJsK2NsaWNrXG5cdFx0XHRcdFx0XHRcdCQudmFrYXRhLmNvbnRleHQuaGlkZSgpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sIHRoaXMpKTtcblx0XHRcdC8qXG5cdFx0XHRpZighKCdvbmNvbnRleHRtZW51JyBpbiBkb2N1bWVudC5ib2R5KSAmJiAoJ29udG91Y2hzdGFydCcgaW4gZG9jdW1lbnQuYm9keSkpIHtcblx0XHRcdFx0dmFyIGVsID0gbnVsbCwgdG0gPSBudWxsO1xuXHRcdFx0XHR0aGlzLmVsZW1lbnRcblx0XHRcdFx0XHQub24oXCJ0b3VjaHN0YXJ0XCIsIFwiLmpzdHJlZS1hbmNob3JcIiwgZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0XHRcdGVsID0gZS5jdXJyZW50VGFyZ2V0O1xuXHRcdFx0XHRcdFx0dG0gPSArbmV3IERhdGUoKTtcblx0XHRcdFx0XHRcdCQoZG9jdW1lbnQpLm9uZShcInRvdWNoZW5kXCIsIGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRcdFx0XHRcdGUudGFyZ2V0ID0gZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludChlLm9yaWdpbmFsRXZlbnQudGFyZ2V0VG91Y2hlc1swXS5wYWdlWCAtIHdpbmRvdy5wYWdlWE9mZnNldCwgZS5vcmlnaW5hbEV2ZW50LnRhcmdldFRvdWNoZXNbMF0ucGFnZVkgLSB3aW5kb3cucGFnZVlPZmZzZXQpO1xuXHRcdFx0XHRcdFx0XHRlLmN1cnJlbnRUYXJnZXQgPSBlLnRhcmdldDtcblx0XHRcdFx0XHRcdFx0dG0gPSAoKCsobmV3IERhdGUoKSkpIC0gdG0pO1xuXHRcdFx0XHRcdFx0XHRpZihlLnRhcmdldCA9PT0gZWwgJiYgdG0gPiA2MDAgJiYgdG0gPCAxMDAwKSB7XG5cdFx0XHRcdFx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdFx0XHRcdCQoZWwpLnRyaWdnZXIoJ2NvbnRleHRtZW51JywgZSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0ZWwgPSBudWxsO1xuXHRcdFx0XHRcdFx0XHR0bSA9IG51bGw7XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHRcdCovXG5cdFx0XHQkKGRvY3VtZW50KS5vbihcImNvbnRleHRfaGlkZS52YWthdGFcIiwgJC5wcm94eShmdW5jdGlvbiAoKSB7IHRoaXMuX2RhdGEuY29udGV4dG1lbnUudmlzaWJsZSA9IGZhbHNlOyB9LCB0aGlzKSk7XG5cdFx0fTtcblx0XHR0aGlzLnRlYXJkb3duID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0aWYodGhpcy5fZGF0YS5jb250ZXh0bWVudS52aXNpYmxlKSB7XG5cdFx0XHRcdCQudmFrYXRhLmNvbnRleHQuaGlkZSgpO1xuXHRcdFx0fVxuXHRcdFx0cGFyZW50LnRlYXJkb3duLmNhbGwodGhpcyk7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIHByZXBhcmUgYW5kIHNob3cgdGhlIGNvbnRleHQgbWVudSBmb3IgYSBub2RlXG5cdFx0ICogQG5hbWUgc2hvd19jb250ZXh0bWVudShvYmogWywgeCwgeV0pXG5cdFx0ICogQHBhcmFtIHttaXhlZH0gb2JqIHRoZSBub2RlXG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IHggdGhlIHgtY29vcmRpbmF0ZSByZWxhdGl2ZSB0byB0aGUgZG9jdW1lbnQgdG8gc2hvdyB0aGUgbWVudSBhdFxuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSB5IHRoZSB5LWNvb3JkaW5hdGUgcmVsYXRpdmUgdG8gdGhlIGRvY3VtZW50IHRvIHNob3cgdGhlIG1lbnUgYXRcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gZSB0aGUgZXZlbnQgaWYgYXZhaWxhYmxlIHRoYXQgdHJpZ2dlcmVkIHRoZSBjb250ZXh0bWVudVxuXHRcdCAqIEBwbHVnaW4gY29udGV4dG1lbnVcblx0XHQgKiBAdHJpZ2dlciBzaG93X2NvbnRleHRtZW51LmpzdHJlZVxuXHRcdCAqL1xuXHRcdHRoaXMuc2hvd19jb250ZXh0bWVudSA9IGZ1bmN0aW9uIChvYmosIHgsIHksIGUpIHtcblx0XHRcdG9iaiA9IHRoaXMuZ2V0X25vZGUob2JqKTtcblx0XHRcdGlmKCFvYmogfHwgb2JqLmlkID09PSAnIycpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0XHR2YXIgcyA9IHRoaXMuc2V0dGluZ3MuY29udGV4dG1lbnUsXG5cdFx0XHRcdGQgPSB0aGlzLmdldF9ub2RlKG9iaiwgdHJ1ZSksXG5cdFx0XHRcdGEgPSBkLmNoaWxkcmVuKFwiLmpzdHJlZS1hbmNob3JcIiksXG5cdFx0XHRcdG8gPSBmYWxzZSxcblx0XHRcdFx0aSA9IGZhbHNlO1xuXHRcdFx0aWYocy5zaG93X2F0X25vZGUgfHwgeCA9PT0gdW5kZWZpbmVkIHx8IHkgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRvID0gYS5vZmZzZXQoKTtcblx0XHRcdFx0eCA9IG8ubGVmdDtcblx0XHRcdFx0eSA9IG8udG9wICsgdGhpcy5fZGF0YS5jb3JlLmxpX2hlaWdodDtcblx0XHRcdH1cblx0XHRcdGlmKHRoaXMuc2V0dGluZ3MuY29udGV4dG1lbnUuc2VsZWN0X25vZGUgJiYgIXRoaXMuaXNfc2VsZWN0ZWQob2JqKSkge1xuXHRcdFx0XHR0aGlzLmFjdGl2YXRlX25vZGUob2JqLCBlKTtcblx0XHRcdH1cblxuXHRcdFx0aSA9IHMuaXRlbXM7XG5cdFx0XHRpZigkLmlzRnVuY3Rpb24oaSkpIHtcblx0XHRcdFx0aSA9IGkuY2FsbCh0aGlzLCBvYmosICQucHJveHkoZnVuY3Rpb24gKGkpIHtcblx0XHRcdFx0XHR0aGlzLl9zaG93X2NvbnRleHRtZW51KG9iaiwgeCwgeSwgaSk7XG5cdFx0XHRcdH0sIHRoaXMpKTtcblx0XHRcdH1cblx0XHRcdGlmKCQuaXNQbGFpbk9iamVjdChpKSkge1xuXHRcdFx0XHR0aGlzLl9zaG93X2NvbnRleHRtZW51KG9iaiwgeCwgeSwgaSk7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHQvKipcblx0XHQgKiBzaG93IHRoZSBwcmVwYXJlZCBjb250ZXh0IG1lbnUgZm9yIGEgbm9kZVxuXHRcdCAqIEBuYW1lIF9zaG93X2NvbnRleHRtZW51KG9iaiwgeCwgeSwgaSlcblx0XHQgKiBAcGFyYW0ge21peGVkfSBvYmogdGhlIG5vZGVcblx0XHQgKiBAcGFyYW0ge051bWJlcn0geCB0aGUgeC1jb29yZGluYXRlIHJlbGF0aXZlIHRvIHRoZSBkb2N1bWVudCB0byBzaG93IHRoZSBtZW51IGF0XG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IHkgdGhlIHktY29vcmRpbmF0ZSByZWxhdGl2ZSB0byB0aGUgZG9jdW1lbnQgdG8gc2hvdyB0aGUgbWVudSBhdFxuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSBpIHRoZSBvYmplY3Qgb2YgaXRlbXMgdG8gc2hvd1xuXHRcdCAqIEBwbHVnaW4gY29udGV4dG1lbnVcblx0XHQgKiBAdHJpZ2dlciBzaG93X2NvbnRleHRtZW51LmpzdHJlZVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dGhpcy5fc2hvd19jb250ZXh0bWVudSA9IGZ1bmN0aW9uIChvYmosIHgsIHksIGkpIHtcblx0XHRcdHZhciBkID0gdGhpcy5nZXRfbm9kZShvYmosIHRydWUpLFxuXHRcdFx0XHRhID0gZC5jaGlsZHJlbihcIi5qc3RyZWUtYW5jaG9yXCIpO1xuXHRcdFx0JChkb2N1bWVudCkub25lKFwiY29udGV4dF9zaG93LnZha2F0YVwiLCAkLnByb3h5KGZ1bmN0aW9uIChlLCBkYXRhKSB7XG5cdFx0XHRcdHZhciBjbHMgPSAnanN0cmVlLWNvbnRleHRtZW51IGpzdHJlZS0nICsgdGhpcy5nZXRfdGhlbWUoKSArICctY29udGV4dG1lbnUnO1xuXHRcdFx0XHQkKGRhdGEuZWxlbWVudCkuYWRkQ2xhc3MoY2xzKTtcblx0XHRcdH0sIHRoaXMpKTtcblx0XHRcdHRoaXMuX2RhdGEuY29udGV4dG1lbnUudmlzaWJsZSA9IHRydWU7XG5cdFx0XHQkLnZha2F0YS5jb250ZXh0LnNob3coYSwgeyAneCcgOiB4LCAneScgOiB5IH0sIGkpO1xuXHRcdFx0LyoqXG5cdFx0XHQgKiB0cmlnZ2VyZWQgd2hlbiB0aGUgY29udGV4dG1lbnUgaXMgc2hvd24gZm9yIGEgbm9kZVxuXHRcdFx0ICogQGV2ZW50XG5cdFx0XHQgKiBAbmFtZSBzaG93X2NvbnRleHRtZW51LmpzdHJlZVxuXHRcdFx0ICogQHBhcmFtIHtPYmplY3R9IG5vZGUgdGhlIG5vZGVcblx0XHRcdCAqIEBwYXJhbSB7TnVtYmVyfSB4IHRoZSB4LWNvb3JkaW5hdGUgb2YgdGhlIG1lbnUgcmVsYXRpdmUgdG8gdGhlIGRvY3VtZW50XG5cdFx0XHQgKiBAcGFyYW0ge051bWJlcn0geSB0aGUgeS1jb29yZGluYXRlIG9mIHRoZSBtZW51IHJlbGF0aXZlIHRvIHRoZSBkb2N1bWVudFxuXHRcdFx0ICogQHBsdWdpbiBjb250ZXh0bWVudVxuXHRcdFx0ICovXG5cdFx0XHR0aGlzLnRyaWdnZXIoJ3Nob3dfY29udGV4dG1lbnUnLCB7IFwibm9kZVwiIDogb2JqLCBcInhcIiA6IHgsIFwieVwiIDogeSB9KTtcblx0XHR9O1xuXHR9O1xuXG5cdC8vIGNvbnRleHRtZW51IGhlbHBlclxuXHQoZnVuY3Rpb24gKCQpIHtcblx0XHR2YXIgcmlnaHRfdG9fbGVmdCA9IGZhbHNlLFxuXHRcdFx0dmFrYXRhX2NvbnRleHQgPSB7XG5cdFx0XHRcdGVsZW1lbnRcdFx0OiBmYWxzZSxcblx0XHRcdFx0cmVmZXJlbmNlXHQ6IGZhbHNlLFxuXHRcdFx0XHRwb3NpdGlvbl94XHQ6IDAsXG5cdFx0XHRcdHBvc2l0aW9uX3lcdDogMCxcblx0XHRcdFx0aXRlbXNcdFx0OiBbXSxcblx0XHRcdFx0aHRtbFx0XHQ6IFwiXCIsXG5cdFx0XHRcdGlzX3Zpc2libGVcdDogZmFsc2Vcblx0XHRcdH07XG5cblx0XHQkLnZha2F0YS5jb250ZXh0ID0ge1xuXHRcdFx0c2V0dGluZ3MgOiB7XG5cdFx0XHRcdGhpZGVfb25tb3VzZWxlYXZlXHQ6IDAsXG5cdFx0XHRcdGljb25zXHRcdFx0XHQ6IHRydWVcblx0XHRcdH0sXG5cdFx0XHRfdHJpZ2dlciA6IGZ1bmN0aW9uIChldmVudF9uYW1lKSB7XG5cdFx0XHRcdCQoZG9jdW1lbnQpLnRyaWdnZXJIYW5kbGVyKFwiY29udGV4dF9cIiArIGV2ZW50X25hbWUgKyBcIi52YWthdGFcIiwge1xuXHRcdFx0XHRcdFwicmVmZXJlbmNlXCJcdDogdmFrYXRhX2NvbnRleHQucmVmZXJlbmNlLFxuXHRcdFx0XHRcdFwiZWxlbWVudFwiXHQ6IHZha2F0YV9jb250ZXh0LmVsZW1lbnQsXG5cdFx0XHRcdFx0XCJwb3NpdGlvblwiXHQ6IHtcblx0XHRcdFx0XHRcdFwieFwiIDogdmFrYXRhX2NvbnRleHQucG9zaXRpb25feCxcblx0XHRcdFx0XHRcdFwieVwiIDogdmFrYXRhX2NvbnRleHQucG9zaXRpb25feVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHR9LFxuXHRcdFx0X2V4ZWN1dGUgOiBmdW5jdGlvbiAoaSkge1xuXHRcdFx0XHRpID0gdmFrYXRhX2NvbnRleHQuaXRlbXNbaV07XG5cdFx0XHRcdHJldHVybiBpICYmICghaS5fZGlzYWJsZWQgfHwgKCQuaXNGdW5jdGlvbihpLl9kaXNhYmxlZCkgJiYgIWkuX2Rpc2FibGVkKHsgXCJpdGVtXCIgOiBpLCBcInJlZmVyZW5jZVwiIDogdmFrYXRhX2NvbnRleHQucmVmZXJlbmNlLCBcImVsZW1lbnRcIiA6IHZha2F0YV9jb250ZXh0LmVsZW1lbnQgfSkpKSAmJiBpLmFjdGlvbiA/IGkuYWN0aW9uLmNhbGwobnVsbCwge1xuXHRcdFx0XHRcdFx0XHRcIml0ZW1cIlx0XHQ6IGksXG5cdFx0XHRcdFx0XHRcdFwicmVmZXJlbmNlXCJcdDogdmFrYXRhX2NvbnRleHQucmVmZXJlbmNlLFxuXHRcdFx0XHRcdFx0XHRcImVsZW1lbnRcIlx0OiB2YWthdGFfY29udGV4dC5lbGVtZW50LFxuXHRcdFx0XHRcdFx0XHRcInBvc2l0aW9uXCJcdDoge1xuXHRcdFx0XHRcdFx0XHRcdFwieFwiIDogdmFrYXRhX2NvbnRleHQucG9zaXRpb25feCxcblx0XHRcdFx0XHRcdFx0XHRcInlcIiA6IHZha2F0YV9jb250ZXh0LnBvc2l0aW9uX3lcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSkgOiBmYWxzZTtcblx0XHRcdH0sXG5cdFx0XHRfcGFyc2UgOiBmdW5jdGlvbiAobywgaXNfY2FsbGJhY2spIHtcblx0XHRcdFx0aWYoIW8pIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0XHRcdGlmKCFpc19jYWxsYmFjaykge1xuXHRcdFx0XHRcdHZha2F0YV9jb250ZXh0Lmh0bWxcdFx0PSBcIlwiO1xuXHRcdFx0XHRcdHZha2F0YV9jb250ZXh0Lml0ZW1zXHQ9IFtdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHZhciBzdHIgPSBcIlwiLFxuXHRcdFx0XHRcdHNlcCA9IGZhbHNlLFxuXHRcdFx0XHRcdHRtcDtcblxuXHRcdFx0XHRpZihpc19jYWxsYmFjaykgeyBzdHIgKz0gXCI8XCIrXCJ1bD5cIjsgfVxuXHRcdFx0XHQkLmVhY2gobywgZnVuY3Rpb24gKGksIHZhbCkge1xuXHRcdFx0XHRcdGlmKCF2YWwpIHsgcmV0dXJuIHRydWU7IH1cblx0XHRcdFx0XHR2YWthdGFfY29udGV4dC5pdGVtcy5wdXNoKHZhbCk7XG5cdFx0XHRcdFx0aWYoIXNlcCAmJiB2YWwuc2VwYXJhdG9yX2JlZm9yZSkge1xuXHRcdFx0XHRcdFx0c3RyICs9IFwiPFwiK1wibGkgY2xhc3M9J3Zha2F0YS1jb250ZXh0LXNlcGFyYXRvcic+PFwiK1wiYSBocmVmPScjJyBcIiArICgkLnZha2F0YS5jb250ZXh0LnNldHRpbmdzLmljb25zID8gJycgOiAnc3R5bGU9XCJtYXJnaW4tbGVmdDowcHg7XCInKSArIFwiPiYjMTYwOzxcIitcIi9hPjxcIitcIi9saT5cIjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0c2VwID0gZmFsc2U7XG5cdFx0XHRcdFx0c3RyICs9IFwiPFwiK1wibGkgY2xhc3M9J1wiICsgKHZhbC5fY2xhc3MgfHwgXCJcIikgKyAodmFsLl9kaXNhYmxlZCA9PT0gdHJ1ZSB8fCAoJC5pc0Z1bmN0aW9uKHZhbC5fZGlzYWJsZWQpICYmIHZhbC5fZGlzYWJsZWQoeyBcIml0ZW1cIiA6IHZhbCwgXCJyZWZlcmVuY2VcIiA6IHZha2F0YV9jb250ZXh0LnJlZmVyZW5jZSwgXCJlbGVtZW50XCIgOiB2YWthdGFfY29udGV4dC5lbGVtZW50IH0pKSA/IFwiIHZha2F0YS1jb250ZXh0bWVudS1kaXNhYmxlZCBcIiA6IFwiXCIpICsgXCInIFwiKyh2YWwuc2hvcnRjdXQ/XCIgZGF0YS1zaG9ydGN1dD0nXCIrdmFsLnNob3J0Y3V0K1wiJyBcIjonJykrXCI+XCI7XG5cdFx0XHRcdFx0c3RyICs9IFwiPFwiK1wiYSBocmVmPScjJyByZWw9J1wiICsgKHZha2F0YV9jb250ZXh0Lml0ZW1zLmxlbmd0aCAtIDEpICsgXCInPlwiO1xuXHRcdFx0XHRcdGlmKCQudmFrYXRhLmNvbnRleHQuc2V0dGluZ3MuaWNvbnMpIHtcblx0XHRcdFx0XHRcdHN0ciArPSBcIjxcIitcImkgXCI7XG5cdFx0XHRcdFx0XHRpZih2YWwuaWNvbikge1xuXHRcdFx0XHRcdFx0XHRpZih2YWwuaWNvbi5pbmRleE9mKFwiL1wiKSAhPT0gLTEgfHwgdmFsLmljb24uaW5kZXhPZihcIi5cIikgIT09IC0xKSB7IHN0ciArPSBcIiBzdHlsZT0nYmFja2dyb3VuZDp1cmwoXFxcIlwiICsgdmFsLmljb24gKyBcIlxcXCIpIGNlbnRlciBjZW50ZXIgbm8tcmVwZWF0JyBcIjsgfVxuXHRcdFx0XHRcdFx0XHRlbHNlIHsgc3RyICs9IFwiIGNsYXNzPSdcIiArIHZhbC5pY29uICsgXCInIFwiOyB9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRzdHIgKz0gXCI+PFwiK1wiL2k+PFwiK1wic3BhbiBjbGFzcz0ndmFrYXRhLWNvbnRleHRtZW51LXNlcCc+JiMxNjA7PFwiK1wiL3NwYW4+XCI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHN0ciArPSAoJC5pc0Z1bmN0aW9uKHZhbC5sYWJlbCkgPyB2YWwubGFiZWwoeyBcIml0ZW1cIiA6IGksIFwicmVmZXJlbmNlXCIgOiB2YWthdGFfY29udGV4dC5yZWZlcmVuY2UsIFwiZWxlbWVudFwiIDogdmFrYXRhX2NvbnRleHQuZWxlbWVudCB9KSA6IHZhbC5sYWJlbCkgKyAodmFsLnNob3J0Y3V0PycgPHNwYW4gY2xhc3M9XCJ2YWthdGEtY29udGV4dG1lbnUtc2hvcnRjdXQgdmFrYXRhLWNvbnRleHRtZW51LXNob3J0Y3V0LScrdmFsLnNob3J0Y3V0KydcIj4nKyAodmFsLnNob3J0Y3V0X2xhYmVsIHx8ICcnKSArJzwvc3Bhbj4nOicnKSArIFwiPFwiK1wiL2E+XCI7XG5cdFx0XHRcdFx0aWYodmFsLnN1Ym1lbnUpIHtcblx0XHRcdFx0XHRcdHRtcCA9ICQudmFrYXRhLmNvbnRleHQuX3BhcnNlKHZhbC5zdWJtZW51LCB0cnVlKTtcblx0XHRcdFx0XHRcdGlmKHRtcCkgeyBzdHIgKz0gdG1wOyB9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHN0ciArPSBcIjxcIitcIi9saT5cIjtcblx0XHRcdFx0XHRpZih2YWwuc2VwYXJhdG9yX2FmdGVyKSB7XG5cdFx0XHRcdFx0XHRzdHIgKz0gXCI8XCIrXCJsaSBjbGFzcz0ndmFrYXRhLWNvbnRleHQtc2VwYXJhdG9yJz48XCIrXCJhIGhyZWY9JyMnIFwiICsgKCQudmFrYXRhLmNvbnRleHQuc2V0dGluZ3MuaWNvbnMgPyAnJyA6ICdzdHlsZT1cIm1hcmdpbi1sZWZ0OjBweDtcIicpICsgXCI+JiMxNjA7PFwiK1wiL2E+PFwiK1wiL2xpPlwiO1xuXHRcdFx0XHRcdFx0c2VwID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRzdHIgID0gc3RyLnJlcGxhY2UoLzxsaSBjbGFzc1xcPSd2YWthdGEtY29udGV4dC1zZXBhcmF0b3InXFw+PFxcL2xpXFw+JC8sXCJcIik7XG5cdFx0XHRcdGlmKGlzX2NhbGxiYWNrKSB7IHN0ciArPSBcIjwvdWw+XCI7IH1cblx0XHRcdFx0LyoqXG5cdFx0XHRcdCAqIHRyaWdnZXJlZCBvbiB0aGUgZG9jdW1lbnQgd2hlbiB0aGUgY29udGV4dG1lbnUgaXMgcGFyc2VkIChIVE1MIGlzIGJ1aWx0KVxuXHRcdFx0XHQgKiBAZXZlbnRcblx0XHRcdFx0ICogQHBsdWdpbiBjb250ZXh0bWVudVxuXHRcdFx0XHQgKiBAbmFtZSBjb250ZXh0X3BhcnNlLnZha2F0YVxuXHRcdFx0XHQgKiBAcGFyYW0ge2pRdWVyeX0gcmVmZXJlbmNlIHRoZSBlbGVtZW50IHRoYXQgd2FzIHJpZ2h0IGNsaWNrZWRcblx0XHRcdFx0ICogQHBhcmFtIHtqUXVlcnl9IGVsZW1lbnQgdGhlIERPTSBlbGVtZW50IG9mIHRoZSBtZW51IGl0c2VsZlxuXHRcdFx0XHQgKiBAcGFyYW0ge09iamVjdH0gcG9zaXRpb24gdGhlIHggJiB5IGNvb3JkaW5hdGVzIG9mIHRoZSBtZW51XG5cdFx0XHRcdCAqL1xuXHRcdFx0XHRpZighaXNfY2FsbGJhY2spIHsgdmFrYXRhX2NvbnRleHQuaHRtbCA9IHN0cjsgJC52YWthdGEuY29udGV4dC5fdHJpZ2dlcihcInBhcnNlXCIpOyB9XG5cdFx0XHRcdHJldHVybiBzdHIubGVuZ3RoID4gMTAgPyBzdHIgOiBmYWxzZTtcblx0XHRcdH0sXG5cdFx0XHRfc2hvd19zdWJtZW51IDogZnVuY3Rpb24gKG8pIHtcblx0XHRcdFx0byA9ICQobyk7XG5cdFx0XHRcdGlmKCFvLmxlbmd0aCB8fCAhby5jaGlsZHJlbihcInVsXCIpLmxlbmd0aCkgeyByZXR1cm47IH1cblx0XHRcdFx0dmFyIGUgPSBvLmNoaWxkcmVuKFwidWxcIiksXG5cdFx0XHRcdFx0eCA9IG8ub2Zmc2V0KCkubGVmdCArIG8ub3V0ZXJXaWR0aCgpLFxuXHRcdFx0XHRcdHkgPSBvLm9mZnNldCgpLnRvcCxcblx0XHRcdFx0XHR3ID0gZS53aWR0aCgpLFxuXHRcdFx0XHRcdGggPSBlLmhlaWdodCgpLFxuXHRcdFx0XHRcdGR3ID0gJCh3aW5kb3cpLndpZHRoKCkgKyAkKHdpbmRvdykuc2Nyb2xsTGVmdCgpLFxuXHRcdFx0XHRcdGRoID0gJCh3aW5kb3cpLmhlaWdodCgpICsgJCh3aW5kb3cpLnNjcm9sbFRvcCgpO1xuXHRcdFx0XHQvLyDQvNC+0LbQtSDQtNCwINGB0LUg0YHQv9C10YHRgtC4INC1INC10LTQvdCwINC/0YDQvtCy0LXRgNC60LAgLSDQtNCw0LvQuCDQvdGP0LzQsCDQvdGP0LrQvtC5INC+0YIg0LrQu9Cw0YHQvtCy0LXRgtC1INCy0LXRh9C1INC90LDQs9C+0YDQtVxuXHRcdFx0XHRpZihyaWdodF90b19sZWZ0KSB7XG5cdFx0XHRcdFx0b1t4IC0gKHcgKyAxMCArIG8ub3V0ZXJXaWR0aCgpKSA8IDAgPyBcImFkZENsYXNzXCIgOiBcInJlbW92ZUNsYXNzXCJdKFwidmFrYXRhLWNvbnRleHQtbGVmdFwiKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRvW3ggKyB3ICsgMTAgPiBkdyA/IFwiYWRkQ2xhc3NcIiA6IFwicmVtb3ZlQ2xhc3NcIl0oXCJ2YWthdGEtY29udGV4dC1yaWdodFwiKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZih5ICsgaCArIDEwID4gZGgpIHtcblx0XHRcdFx0XHRlLmNzcyhcImJvdHRvbVwiLFwiLTFweFwiKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlLnNob3coKTtcblx0XHRcdH0sXG5cdFx0XHRzaG93IDogZnVuY3Rpb24gKHJlZmVyZW5jZSwgcG9zaXRpb24sIGRhdGEpIHtcblx0XHRcdFx0dmFyIG8sIGUsIHgsIHksIHcsIGgsIGR3LCBkaCwgY29uZCA9IHRydWU7XG5cdFx0XHRcdGlmKHZha2F0YV9jb250ZXh0LmVsZW1lbnQgJiYgdmFrYXRhX2NvbnRleHQuZWxlbWVudC5sZW5ndGgpIHtcblx0XHRcdFx0XHR2YWthdGFfY29udGV4dC5lbGVtZW50LndpZHRoKCcnKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRzd2l0Y2goY29uZCkge1xuXHRcdFx0XHRcdGNhc2UgKCFwb3NpdGlvbiAmJiAhcmVmZXJlbmNlKTpcblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHRjYXNlICghIXBvc2l0aW9uICYmICEhcmVmZXJlbmNlKTpcblx0XHRcdFx0XHRcdHZha2F0YV9jb250ZXh0LnJlZmVyZW5jZVx0PSByZWZlcmVuY2U7XG5cdFx0XHRcdFx0XHR2YWthdGFfY29udGV4dC5wb3NpdGlvbl94XHQ9IHBvc2l0aW9uLng7XG5cdFx0XHRcdFx0XHR2YWthdGFfY29udGV4dC5wb3NpdGlvbl95XHQ9IHBvc2l0aW9uLnk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlICghcG9zaXRpb24gJiYgISFyZWZlcmVuY2UpOlxuXHRcdFx0XHRcdFx0dmFrYXRhX2NvbnRleHQucmVmZXJlbmNlXHQ9IHJlZmVyZW5jZTtcblx0XHRcdFx0XHRcdG8gPSByZWZlcmVuY2Uub2Zmc2V0KCk7XG5cdFx0XHRcdFx0XHR2YWthdGFfY29udGV4dC5wb3NpdGlvbl94XHQ9IG8ubGVmdCArIHJlZmVyZW5jZS5vdXRlckhlaWdodCgpO1xuXHRcdFx0XHRcdFx0dmFrYXRhX2NvbnRleHQucG9zaXRpb25feVx0PSBvLnRvcDtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgKCEhcG9zaXRpb24gJiYgIXJlZmVyZW5jZSk6XG5cdFx0XHRcdFx0XHR2YWthdGFfY29udGV4dC5wb3NpdGlvbl94XHQ9IHBvc2l0aW9uLng7XG5cdFx0XHRcdFx0XHR2YWthdGFfY29udGV4dC5wb3NpdGlvbl95XHQ9IHBvc2l0aW9uLnk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0XHRpZighIXJlZmVyZW5jZSAmJiAhZGF0YSAmJiAkKHJlZmVyZW5jZSkuZGF0YSgndmFrYXRhX2NvbnRleHRtZW51JykpIHtcblx0XHRcdFx0XHRkYXRhID0gJChyZWZlcmVuY2UpLmRhdGEoJ3Zha2F0YV9jb250ZXh0bWVudScpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKCQudmFrYXRhLmNvbnRleHQuX3BhcnNlKGRhdGEpKSB7XG5cdFx0XHRcdFx0dmFrYXRhX2NvbnRleHQuZWxlbWVudC5odG1sKHZha2F0YV9jb250ZXh0Lmh0bWwpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKHZha2F0YV9jb250ZXh0Lml0ZW1zLmxlbmd0aCkge1xuXHRcdFx0XHRcdGUgPSB2YWthdGFfY29udGV4dC5lbGVtZW50O1xuXHRcdFx0XHRcdHggPSB2YWthdGFfY29udGV4dC5wb3NpdGlvbl94O1xuXHRcdFx0XHRcdHkgPSB2YWthdGFfY29udGV4dC5wb3NpdGlvbl95O1xuXHRcdFx0XHRcdHcgPSBlLndpZHRoKCk7XG5cdFx0XHRcdFx0aCA9IGUuaGVpZ2h0KCk7XG5cdFx0XHRcdFx0ZHcgPSAkKHdpbmRvdykud2lkdGgoKSArICQod2luZG93KS5zY3JvbGxMZWZ0KCk7XG5cdFx0XHRcdFx0ZGggPSAkKHdpbmRvdykuaGVpZ2h0KCkgKyAkKHdpbmRvdykuc2Nyb2xsVG9wKCk7XG5cdFx0XHRcdFx0aWYocmlnaHRfdG9fbGVmdCkge1xuXHRcdFx0XHRcdFx0eCAtPSBlLm91dGVyV2lkdGgoKTtcblx0XHRcdFx0XHRcdGlmKHggPCAkKHdpbmRvdykuc2Nyb2xsTGVmdCgpICsgMjApIHtcblx0XHRcdFx0XHRcdFx0eCA9ICQod2luZG93KS5zY3JvbGxMZWZ0KCkgKyAyMDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYoeCArIHcgKyAyMCA+IGR3KSB7XG5cdFx0XHRcdFx0XHR4ID0gZHcgLSAodyArIDIwKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYoeSArIGggKyAyMCA+IGRoKSB7XG5cdFx0XHRcdFx0XHR5ID0gZGggLSAoaCArIDIwKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR2YWthdGFfY29udGV4dC5lbGVtZW50XG5cdFx0XHRcdFx0XHQuY3NzKHsgXCJsZWZ0XCIgOiB4LCBcInRvcFwiIDogeSB9KVxuXHRcdFx0XHRcdFx0LnNob3coKVxuXHRcdFx0XHRcdFx0LmZpbmQoJ2E6ZXEoMCknKS5mb2N1cygpLnBhcmVudCgpLmFkZENsYXNzKFwidmFrYXRhLWNvbnRleHQtaG92ZXJcIik7XG5cdFx0XHRcdFx0dmFrYXRhX2NvbnRleHQuaXNfdmlzaWJsZSA9IHRydWU7XG5cdFx0XHRcdFx0LyoqXG5cdFx0XHRcdFx0ICogdHJpZ2dlcmVkIG9uIHRoZSBkb2N1bWVudCB3aGVuIHRoZSBjb250ZXh0bWVudSBpcyBzaG93blxuXHRcdFx0XHRcdCAqIEBldmVudFxuXHRcdFx0XHRcdCAqIEBwbHVnaW4gY29udGV4dG1lbnVcblx0XHRcdFx0XHQgKiBAbmFtZSBjb250ZXh0X3Nob3cudmFrYXRhXG5cdFx0XHRcdFx0ICogQHBhcmFtIHtqUXVlcnl9IHJlZmVyZW5jZSB0aGUgZWxlbWVudCB0aGF0IHdhcyByaWdodCBjbGlja2VkXG5cdFx0XHRcdFx0ICogQHBhcmFtIHtqUXVlcnl9IGVsZW1lbnQgdGhlIERPTSBlbGVtZW50IG9mIHRoZSBtZW51IGl0c2VsZlxuXHRcdFx0XHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBwb3NpdGlvbiB0aGUgeCAmIHkgY29vcmRpbmF0ZXMgb2YgdGhlIG1lbnVcblx0XHRcdFx0XHQgKi9cblx0XHRcdFx0XHQkLnZha2F0YS5jb250ZXh0Ll90cmlnZ2VyKFwic2hvd1wiKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGhpZGUgOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdGlmKHZha2F0YV9jb250ZXh0LmlzX3Zpc2libGUpIHtcblx0XHRcdFx0XHR2YWthdGFfY29udGV4dC5lbGVtZW50LmhpZGUoKS5maW5kKFwidWxcIikuaGlkZSgpLmVuZCgpLmZpbmQoJzpmb2N1cycpLmJsdXIoKTtcblx0XHRcdFx0XHR2YWthdGFfY29udGV4dC5pc192aXNpYmxlID0gZmFsc2U7XG5cdFx0XHRcdFx0LyoqXG5cdFx0XHRcdFx0ICogdHJpZ2dlcmVkIG9uIHRoZSBkb2N1bWVudCB3aGVuIHRoZSBjb250ZXh0bWVudSBpcyBoaWRkZW5cblx0XHRcdFx0XHQgKiBAZXZlbnRcblx0XHRcdFx0XHQgKiBAcGx1Z2luIGNvbnRleHRtZW51XG5cdFx0XHRcdFx0ICogQG5hbWUgY29udGV4dF9oaWRlLnZha2F0YVxuXHRcdFx0XHRcdCAqIEBwYXJhbSB7alF1ZXJ5fSByZWZlcmVuY2UgdGhlIGVsZW1lbnQgdGhhdCB3YXMgcmlnaHQgY2xpY2tlZFxuXHRcdFx0XHRcdCAqIEBwYXJhbSB7alF1ZXJ5fSBlbGVtZW50IHRoZSBET00gZWxlbWVudCBvZiB0aGUgbWVudSBpdHNlbGZcblx0XHRcdFx0XHQgKiBAcGFyYW0ge09iamVjdH0gcG9zaXRpb24gdGhlIHggJiB5IGNvb3JkaW5hdGVzIG9mIHRoZSBtZW51XG5cdFx0XHRcdFx0ICovXG5cdFx0XHRcdFx0JC52YWthdGEuY29udGV4dC5fdHJpZ2dlcihcImhpZGVcIik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHRcdCQoZnVuY3Rpb24gKCkge1xuXHRcdFx0cmlnaHRfdG9fbGVmdCA9ICQoXCJib2R5XCIpLmNzcyhcImRpcmVjdGlvblwiKSA9PT0gXCJydGxcIjtcblx0XHRcdHZhciB0byA9IGZhbHNlO1xuXG5cdFx0XHR2YWthdGFfY29udGV4dC5lbGVtZW50ID0gJChcIjx1bCBjbGFzcz0ndmFrYXRhLWNvbnRleHQnPjwvdWw+XCIpO1xuXHRcdFx0dmFrYXRhX2NvbnRleHQuZWxlbWVudFxuXHRcdFx0XHQub24oXCJtb3VzZWVudGVyXCIsIFwibGlcIiwgZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0XHRlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuXG5cdFx0XHRcdFx0aWYoJC5jb250YWlucyh0aGlzLCBlLnJlbGF0ZWRUYXJnZXQpKSB7XG5cdFx0XHRcdFx0XHQvLyDQv9GA0LXQvNCw0YXQvdCw0YLQviDQt9Cw0YDQsNC00LggZGVsZWdhdGUgbW91c2VsZWF2ZSDQv9C+LdC00L7Qu9GDXG5cdFx0XHRcdFx0XHQvLyAkKHRoaXMpLmZpbmQoXCIudmFrYXRhLWNvbnRleHQtaG92ZXJcIikucmVtb3ZlQ2xhc3MoXCJ2YWthdGEtY29udGV4dC1ob3ZlclwiKTtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZih0bykgeyBjbGVhclRpbWVvdXQodG8pOyB9XG5cdFx0XHRcdFx0dmFrYXRhX2NvbnRleHQuZWxlbWVudC5maW5kKFwiLnZha2F0YS1jb250ZXh0LWhvdmVyXCIpLnJlbW92ZUNsYXNzKFwidmFrYXRhLWNvbnRleHQtaG92ZXJcIikuZW5kKCk7XG5cblx0XHRcdFx0XHQkKHRoaXMpXG5cdFx0XHRcdFx0XHQuc2libGluZ3MoKS5maW5kKFwidWxcIikuaGlkZSgpLmVuZCgpLmVuZCgpXG5cdFx0XHRcdFx0XHQucGFyZW50c1VudGlsKFwiLnZha2F0YS1jb250ZXh0XCIsIFwibGlcIikuYWRkQmFjaygpLmFkZENsYXNzKFwidmFrYXRhLWNvbnRleHQtaG92ZXJcIik7XG5cdFx0XHRcdFx0JC52YWthdGEuY29udGV4dC5fc2hvd19zdWJtZW51KHRoaXMpO1xuXHRcdFx0XHR9KVxuXHRcdFx0XHQvLyDRgtC10YHRgtC+0LLQviAtINC00LDQu9C4INC90LUg0L3QsNGC0L7QstCw0YDQstCwP1xuXHRcdFx0XHQub24oXCJtb3VzZWxlYXZlXCIsIFwibGlcIiwgZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0XHRpZigkLmNvbnRhaW5zKHRoaXMsIGUucmVsYXRlZFRhcmdldCkpIHsgcmV0dXJuOyB9XG5cdFx0XHRcdFx0JCh0aGlzKS5maW5kKFwiLnZha2F0YS1jb250ZXh0LWhvdmVyXCIpLmFkZEJhY2soKS5yZW1vdmVDbGFzcyhcInZha2F0YS1jb250ZXh0LWhvdmVyXCIpO1xuXHRcdFx0XHR9KVxuXHRcdFx0XHQub24oXCJtb3VzZWxlYXZlXCIsIGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRcdFx0JCh0aGlzKS5maW5kKFwiLnZha2F0YS1jb250ZXh0LWhvdmVyXCIpLnJlbW92ZUNsYXNzKFwidmFrYXRhLWNvbnRleHQtaG92ZXJcIik7XG5cdFx0XHRcdFx0aWYoJC52YWthdGEuY29udGV4dC5zZXR0aW5ncy5oaWRlX29ubW91c2VsZWF2ZSkge1xuXHRcdFx0XHRcdFx0dG8gPSBzZXRUaW1lb3V0KFxuXHRcdFx0XHRcdFx0XHQoZnVuY3Rpb24gKHQpIHtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24gKCkgeyAkLnZha2F0YS5jb250ZXh0LmhpZGUoKTsgfTtcblx0XHRcdFx0XHRcdFx0fSh0aGlzKSksICQudmFrYXRhLmNvbnRleHQuc2V0dGluZ3MuaGlkZV9vbm1vdXNlbGVhdmUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSlcblx0XHRcdFx0Lm9uKFwiY2xpY2tcIiwgXCJhXCIsIGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHQvL30pXG5cdFx0XHRcdC8vLm9uKFwibW91c2V1cFwiLCBcImFcIiwgZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0XHRpZighJCh0aGlzKS5ibHVyKCkucGFyZW50KCkuaGFzQ2xhc3MoXCJ2YWthdGEtY29udGV4dC1kaXNhYmxlZFwiKSAmJiAkLnZha2F0YS5jb250ZXh0Ll9leGVjdXRlKCQodGhpcykuYXR0cihcInJlbFwiKSkgIT09IGZhbHNlKSB7XG5cdFx0XHRcdFx0XHQkLnZha2F0YS5jb250ZXh0LmhpZGUoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pXG5cdFx0XHRcdC5vbigna2V5ZG93bicsICdhJywgZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0XHRcdHZhciBvID0gbnVsbDtcblx0XHRcdFx0XHRcdHN3aXRjaChlLndoaWNoKSB7XG5cdFx0XHRcdFx0XHRcdGNhc2UgMTM6XG5cdFx0XHRcdFx0XHRcdGNhc2UgMzI6XG5cdFx0XHRcdFx0XHRcdFx0ZS50eXBlID0gXCJtb3VzZXVwXCI7XG5cdFx0XHRcdFx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdFx0XHRcdCQoZS5jdXJyZW50VGFyZ2V0KS50cmlnZ2VyKGUpO1xuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRjYXNlIDM3OlxuXHRcdFx0XHRcdFx0XHRcdGlmKHZha2F0YV9jb250ZXh0LmlzX3Zpc2libGUpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHZha2F0YV9jb250ZXh0LmVsZW1lbnQuZmluZChcIi52YWthdGEtY29udGV4dC1ob3ZlclwiKS5sYXN0KCkucGFyZW50cyhcImxpOmVxKDApXCIpLmZpbmQoXCJ1bFwiKS5oaWRlKCkuZmluZChcIi52YWthdGEtY29udGV4dC1ob3ZlclwiKS5yZW1vdmVDbGFzcyhcInZha2F0YS1jb250ZXh0LWhvdmVyXCIpLmVuZCgpLmVuZCgpLmNoaWxkcmVuKCdhJykuZm9jdXMoKTtcblx0XHRcdFx0XHRcdFx0XHRcdGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG5cdFx0XHRcdFx0XHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRjYXNlIDM4OlxuXHRcdFx0XHRcdFx0XHRcdGlmKHZha2F0YV9jb250ZXh0LmlzX3Zpc2libGUpIHtcblx0XHRcdFx0XHRcdFx0XHRcdG8gPSB2YWthdGFfY29udGV4dC5lbGVtZW50LmZpbmQoXCJ1bDp2aXNpYmxlXCIpLmFkZEJhY2soKS5sYXN0KCkuY2hpbGRyZW4oXCIudmFrYXRhLWNvbnRleHQtaG92ZXJcIikucmVtb3ZlQ2xhc3MoXCJ2YWthdGEtY29udGV4dC1ob3ZlclwiKS5wcmV2QWxsKFwibGk6bm90KC52YWthdGEtY29udGV4dC1zZXBhcmF0b3IpXCIpLmZpcnN0KCk7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZighby5sZW5ndGgpIHsgbyA9IHZha2F0YV9jb250ZXh0LmVsZW1lbnQuZmluZChcInVsOnZpc2libGVcIikuYWRkQmFjaygpLmxhc3QoKS5jaGlsZHJlbihcImxpOm5vdCgudmFrYXRhLWNvbnRleHQtc2VwYXJhdG9yKVwiKS5sYXN0KCk7IH1cblx0XHRcdFx0XHRcdFx0XHRcdG8uYWRkQ2xhc3MoXCJ2YWthdGEtY29udGV4dC1ob3ZlclwiKS5jaGlsZHJlbignYScpLmZvY3VzKCk7XG5cdFx0XHRcdFx0XHRcdFx0XHRlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHRcdFx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0Y2FzZSAzOTpcblx0XHRcdFx0XHRcdFx0XHRpZih2YWthdGFfY29udGV4dC5pc192aXNpYmxlKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR2YWthdGFfY29udGV4dC5lbGVtZW50LmZpbmQoXCIudmFrYXRhLWNvbnRleHQtaG92ZXJcIikubGFzdCgpLmNoaWxkcmVuKFwidWxcIikuc2hvdygpLmNoaWxkcmVuKFwibGk6bm90KC52YWthdGEtY29udGV4dC1zZXBhcmF0b3IpXCIpLnJlbW92ZUNsYXNzKFwidmFrYXRhLWNvbnRleHQtaG92ZXJcIikuZmlyc3QoKS5hZGRDbGFzcyhcInZha2F0YS1jb250ZXh0LWhvdmVyXCIpLmNoaWxkcmVuKCdhJykuZm9jdXMoKTtcblx0XHRcdFx0XHRcdFx0XHRcdGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG5cdFx0XHRcdFx0XHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRjYXNlIDQwOlxuXHRcdFx0XHRcdFx0XHRcdGlmKHZha2F0YV9jb250ZXh0LmlzX3Zpc2libGUpIHtcblx0XHRcdFx0XHRcdFx0XHRcdG8gPSB2YWthdGFfY29udGV4dC5lbGVtZW50LmZpbmQoXCJ1bDp2aXNpYmxlXCIpLmFkZEJhY2soKS5sYXN0KCkuY2hpbGRyZW4oXCIudmFrYXRhLWNvbnRleHQtaG92ZXJcIikucmVtb3ZlQ2xhc3MoXCJ2YWthdGEtY29udGV4dC1ob3ZlclwiKS5uZXh0QWxsKFwibGk6bm90KC52YWthdGEtY29udGV4dC1zZXBhcmF0b3IpXCIpLmZpcnN0KCk7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZighby5sZW5ndGgpIHsgbyA9IHZha2F0YV9jb250ZXh0LmVsZW1lbnQuZmluZChcInVsOnZpc2libGVcIikuYWRkQmFjaygpLmxhc3QoKS5jaGlsZHJlbihcImxpOm5vdCgudmFrYXRhLWNvbnRleHQtc2VwYXJhdG9yKVwiKS5maXJzdCgpOyB9XG5cdFx0XHRcdFx0XHRcdFx0XHRvLmFkZENsYXNzKFwidmFrYXRhLWNvbnRleHQtaG92ZXJcIikuY2hpbGRyZW4oJ2EnKS5mb2N1cygpO1xuXHRcdFx0XHRcdFx0XHRcdFx0ZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcblx0XHRcdFx0XHRcdFx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdGNhc2UgMjc6XG5cdFx0XHRcdFx0XHRcdFx0JC52YWthdGEuY29udGV4dC5oaWRlKCk7XG5cdFx0XHRcdFx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0XHRcdC8vY29uc29sZS5sb2coZS53aGljaCk7XG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSlcblx0XHRcdFx0Lm9uKCdrZXlkb3duJywgZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0dmFyIGEgPSB2YWthdGFfY29udGV4dC5lbGVtZW50LmZpbmQoJy52YWthdGEtY29udGV4dG1lbnUtc2hvcnRjdXQtJyArIGUud2hpY2gpLnBhcmVudCgpO1xuXHRcdFx0XHRcdGlmKGEucGFyZW50KCkubm90KCcudmFrYXRhLWNvbnRleHQtZGlzYWJsZWQnKSkge1xuXHRcdFx0XHRcdFx0YS5tb3VzZXVwKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KVxuXHRcdFx0XHQuYXBwZW5kVG8oXCJib2R5XCIpO1xuXG5cdFx0XHQkKGRvY3VtZW50KVxuXHRcdFx0XHQub24oXCJtb3VzZWRvd25cIiwgZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0XHRpZih2YWthdGFfY29udGV4dC5pc192aXNpYmxlICYmICEkLmNvbnRhaW5zKHZha2F0YV9jb250ZXh0LmVsZW1lbnRbMF0sIGUudGFyZ2V0KSkgeyAkLnZha2F0YS5jb250ZXh0LmhpZGUoKTsgfVxuXHRcdFx0XHR9KVxuXHRcdFx0XHQub24oXCJjb250ZXh0X3Nob3cudmFrYXRhXCIsIGZ1bmN0aW9uIChlLCBkYXRhKSB7XG5cdFx0XHRcdFx0dmFrYXRhX2NvbnRleHQuZWxlbWVudC5maW5kKFwibGk6aGFzKHVsKVwiKS5jaGlsZHJlbihcImFcIikuYWRkQ2xhc3MoXCJ2YWthdGEtY29udGV4dC1wYXJlbnRcIik7XG5cdFx0XHRcdFx0aWYocmlnaHRfdG9fbGVmdCkge1xuXHRcdFx0XHRcdFx0dmFrYXRhX2NvbnRleHQuZWxlbWVudC5hZGRDbGFzcyhcInZha2F0YS1jb250ZXh0LXJ0bFwiKS5jc3MoXCJkaXJlY3Rpb25cIiwgXCJydGxcIik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vIGFsc28gYXBwbHkgYSBSVEwgY2xhc3M/XG5cdFx0XHRcdFx0dmFrYXRhX2NvbnRleHQuZWxlbWVudC5maW5kKFwidWxcIikuaGlkZSgpLmVuZCgpO1xuXHRcdFx0XHR9KTtcblx0XHR9KTtcblx0fSgkKSk7XG5cdC8vICQuanN0cmVlLmRlZmF1bHRzLnBsdWdpbnMucHVzaChcImNvbnRleHRtZW51XCIpO1xuXG4vKipcbiAqICMjIyBEcmFnJ24nZHJvcCBwbHVnaW5cbiAqXG4gKiBFbmFibGVzIGRyYWdnaW5nIGFuZCBkcm9wcGluZyBvZiBub2RlcyBpbiB0aGUgdHJlZSwgcmVzdWx0aW5nIGluIGEgbW92ZSBvciBjb3B5IG9wZXJhdGlvbnMuXG4gKi9cblxuXHQvKipcblx0ICogc3RvcmVzIGFsbCBkZWZhdWx0cyBmb3IgdGhlIGRyYWcnbidkcm9wIHBsdWdpblxuXHQgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5kbmRcblx0ICogQHBsdWdpbiBkbmRcblx0ICovXG5cdCQuanN0cmVlLmRlZmF1bHRzLmRuZCA9IHtcblx0XHQvKipcblx0XHQgKiBhIGJvb2xlYW4gaW5kaWNhdGluZyBpZiBhIGNvcHkgc2hvdWxkIGJlIHBvc3NpYmxlIHdoaWxlIGRyYWdnaW5nIChieSBwcmVzc2ludCB0aGUgbWV0YSBrZXkgb3IgQ3RybCkuIERlZmF1bHRzIHRvIGB0cnVlYC5cblx0XHQgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5kbmQuY29weVxuXHRcdCAqIEBwbHVnaW4gZG5kXG5cdFx0ICovXG5cdFx0Y29weSA6IHRydWUsXG5cdFx0LyoqXG5cdFx0ICogYSBudW1iZXIgaW5kaWNhdGluZyBob3cgbG9uZyBhIG5vZGUgc2hvdWxkIHJlbWFpbiBob3ZlcmVkIHdoaWxlIGRyYWdnaW5nIHRvIGJlIG9wZW5lZC4gRGVmYXVsdHMgdG8gYDUwMGAuXG5cdFx0ICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuZG5kLm9wZW5fdGltZW91dFxuXHRcdCAqIEBwbHVnaW4gZG5kXG5cdFx0ICovXG5cdFx0b3Blbl90aW1lb3V0IDogNTAwLFxuXHRcdC8qKlxuXHRcdCAqIGEgZnVuY3Rpb24gaW52b2tlZCBlYWNoIHRpbWUgYSBub2RlIGlzIGFib3V0IHRvIGJlIGRyYWdnZWQsIGludm9rZWQgaW4gdGhlIHRyZWUncyBzY29wZSBhbmQgcmVjZWl2ZXMgdGhlIG5vZGVzIGFib3V0IHRvIGJlIGRyYWdnZWQgYXMgYW4gYXJndW1lbnQgKGFycmF5KSAtIHJldHVybiBgZmFsc2VgIHRvIHByZXZlbnQgZHJhZ2dpbmdcblx0XHQgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5kbmQuaXNfZHJhZ2dhYmxlXG5cdFx0ICogQHBsdWdpbiBkbmRcblx0XHQgKi9cblx0XHRpc19kcmFnZ2FibGUgOiB0cnVlLFxuXHRcdC8qKlxuXHRcdCAqIGEgYm9vbGVhbiBpbmRpY2F0aW5nIGlmIGNoZWNrcyBzaG91bGQgY29uc3RhbnRseSBiZSBtYWRlIHdoaWxlIHRoZSB1c2VyIGlzIGRyYWdnaW5nIHRoZSBub2RlIChhcyBvcHBvc2VkIHRvIGNoZWNraW5nIG9ubHkgb24gZHJvcCksIGRlZmF1bHQgaXMgYHRydWVgXG5cdFx0ICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuZG5kLmNoZWNrX3doaWxlX2RyYWdnaW5nXG5cdFx0ICogQHBsdWdpbiBkbmRcblx0XHQgKi9cblx0XHRjaGVja193aGlsZV9kcmFnZ2luZyA6IHRydWUsXG5cdFx0LyoqXG5cdFx0ICogYSBib29sZWFuIGluZGljYXRpbmcgaWYgbm9kZXMgZnJvbSB0aGlzIHRyZWUgc2hvdWxkIG9ubHkgYmUgY29waWVkIHdpdGggZG5kIChhcyBvcHBvc2VkIHRvIG1vdmVkKSwgZGVmYXVsdCBpcyBgZmFsc2VgXG5cdFx0ICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuZG5kLmFsd2F5c19jb3B5XG5cdFx0ICogQHBsdWdpbiBkbmRcblx0XHQgKi9cblx0XHRhbHdheXNfY29weSA6IGZhbHNlLFxuXHRcdC8qKlxuXHRcdCAqIHdoZW4gZHJvcHBpbmcgYSBub2RlIFwiaW5zaWRlXCIsIHRoaXMgc2V0dGluZyBpbmRpY2F0ZXMgdGhlIHBvc2l0aW9uIHRoZSBub2RlIHNob3VsZCBnbyB0byAtIGl0IGNhbiBiZSBhbiBpbnRlZ2VyIG9yIGEgc3RyaW5nOiBcImZpcnN0XCIgKHNhbWUgYXMgMCkgb3IgXCJsYXN0XCIsIGRlZmF1bHQgaXMgYDBgXG5cdFx0ICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuZG5kLmluc2lkZV9wb3Ncblx0XHQgKiBAcGx1Z2luIGRuZFxuXHRcdCAqL1xuXHRcdGluc2lkZV9wb3MgOiAwXG5cdH07XG5cdC8vIFRPRE86IG5vdyBjaGVjayB3b3JrcyBieSBjaGVja2luZyBmb3IgZWFjaCBub2RlIGluZGl2aWR1YWxseSwgaG93IGFib3V0IG1heF9jaGlsZHJlbiwgdW5pcXVlLCBldGM/XG5cdC8vIFRPRE86IGRyb3Agc29tZXdoZXJlIGVsc2UgLSBtYXliZSBkZW1vIG9ubHk/XG5cdCQuanN0cmVlLnBsdWdpbnMuZG5kID0gZnVuY3Rpb24gKG9wdGlvbnMsIHBhcmVudCkge1xuXHRcdHRoaXMuYmluZCA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHBhcmVudC5iaW5kLmNhbGwodGhpcyk7XG5cblx0XHRcdHRoaXMuZWxlbWVudFxuXHRcdFx0XHQub24oJ21vdXNlZG93bi5qc3RyZWUgdG91Y2hzdGFydC5qc3RyZWUnLCAnLmpzdHJlZS1hbmNob3InLCAkLnByb3h5KGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRcdFx0dmFyIG9iaiA9IHRoaXMuZ2V0X25vZGUoZS50YXJnZXQpLFxuXHRcdFx0XHRcdFx0bWx0ID0gdGhpcy5pc19zZWxlY3RlZChvYmopID8gdGhpcy5nZXRfc2VsZWN0ZWQoKS5sZW5ndGggOiAxO1xuXHRcdFx0XHRcdGlmKG9iaiAmJiBvYmouaWQgJiYgb2JqLmlkICE9PSBcIiNcIiAmJiAoZS53aGljaCA9PT0gMSB8fCBlLnR5cGUgPT09IFwidG91Y2hzdGFydFwiKSAmJlxuXHRcdFx0XHRcdFx0KHRoaXMuc2V0dGluZ3MuZG5kLmlzX2RyYWdnYWJsZSA9PT0gdHJ1ZSB8fCAoJC5pc0Z1bmN0aW9uKHRoaXMuc2V0dGluZ3MuZG5kLmlzX2RyYWdnYWJsZSkgJiYgdGhpcy5zZXR0aW5ncy5kbmQuaXNfZHJhZ2dhYmxlLmNhbGwodGhpcywgKG1sdCA+IDEgPyB0aGlzLmdldF9zZWxlY3RlZCh0cnVlKSA6IFtvYmpdKSkpKVxuXHRcdFx0XHRcdCkge1xuXHRcdFx0XHRcdFx0dGhpcy5lbGVtZW50LnRyaWdnZXIoJ21vdXNlZG93bi5qc3RyZWUnKTtcblx0XHRcdFx0XHRcdHJldHVybiAkLnZha2F0YS5kbmQuc3RhcnQoZSwgeyAnanN0cmVlJyA6IHRydWUsICdvcmlnaW4nIDogdGhpcywgJ29iaicgOiB0aGlzLmdldF9ub2RlKG9iaix0cnVlKSwgJ25vZGVzJyA6IG1sdCA+IDEgPyB0aGlzLmdldF9zZWxlY3RlZCgpIDogW29iai5pZF0gfSwgJzxkaXYgaWQ9XCJqc3RyZWUtZG5kXCIgY2xhc3M9XCJqc3RyZWUtJyArIHRoaXMuZ2V0X3RoZW1lKCkgKyAoIHRoaXMuc2V0dGluZ3MuY29yZS50aGVtZXMucmVzcG9uc2l2ZSA/ICcganN0cmVlLWRuZC1yZXNwb25zaXZlJyA6ICcnICkgKyAnXCI+PGkgY2xhc3M9XCJqc3RyZWUtaWNvbiBqc3RyZWUtZXJcIj48L2k+JyArIChtbHQgPiAxID8gbWx0ICsgJyAnICsgdGhpcy5nZXRfc3RyaW5nKCdub2RlcycpIDogdGhpcy5nZXRfdGV4dChlLmN1cnJlbnRUYXJnZXQsIHRydWUpKSArICc8aW5zIGNsYXNzPVwianN0cmVlLWNvcHlcIiBzdHlsZT1cImRpc3BsYXk6bm9uZTtcIj4rPC9pbnM+PC9kaXY+Jyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LCB0aGlzKSk7XG5cdFx0fTtcblx0fTtcblxuXHQkKGZ1bmN0aW9uKCkge1xuXHRcdC8vIGJpbmQgb25seSBvbmNlIGZvciBhbGwgaW5zdGFuY2VzXG5cdFx0dmFyIGxhc3RtdiA9IGZhbHNlLFxuXHRcdFx0bGFzdGVyID0gZmFsc2UsXG5cdFx0XHRvcGVudG8gPSBmYWxzZSxcblx0XHRcdG1hcmtlciA9ICQoJzxkaXYgaWQ9XCJqc3RyZWUtbWFya2VyXCI+JiMxNjA7PC9kaXY+JykuaGlkZSgpLmFwcGVuZFRvKCdib2R5Jyk7XG5cblx0XHQkKGRvY3VtZW50KVxuXHRcdFx0LmJpbmQoJ2RuZF9zdGFydC52YWthdGEnLCBmdW5jdGlvbiAoZSwgZGF0YSkge1xuXHRcdFx0XHRsYXN0bXYgPSBmYWxzZTtcblx0XHRcdH0pXG5cdFx0XHQuYmluZCgnZG5kX21vdmUudmFrYXRhJywgZnVuY3Rpb24gKGUsIGRhdGEpIHtcblx0XHRcdFx0aWYob3BlbnRvKSB7IGNsZWFyVGltZW91dChvcGVudG8pOyB9XG5cdFx0XHRcdGlmKCFkYXRhIHx8ICFkYXRhLmRhdGEgfHwgIWRhdGEuZGF0YS5qc3RyZWUpIHsgcmV0dXJuOyB9XG5cblx0XHRcdFx0Ly8gaWYgd2UgYXJlIGhvdmVyaW5nIHRoZSBtYXJrZXIgaW1hZ2UgZG8gbm90aGluZyAoY2FuIGhhcHBlbiBvbiBcImluc2lkZVwiIGRyYWdzKVxuXHRcdFx0XHRpZihkYXRhLmV2ZW50LnRhcmdldC5pZCAmJiBkYXRhLmV2ZW50LnRhcmdldC5pZCA9PT0gJ2pzdHJlZS1tYXJrZXInKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIGlucyA9ICQuanN0cmVlLnJlZmVyZW5jZShkYXRhLmV2ZW50LnRhcmdldCksXG5cdFx0XHRcdFx0cmVmID0gZmFsc2UsXG5cdFx0XHRcdFx0b2ZmID0gZmFsc2UsXG5cdFx0XHRcdFx0cmVsID0gZmFsc2UsXG5cdFx0XHRcdFx0bCwgdCwgaCwgcCwgaSwgbywgb2ssIHQxLCB0Miwgb3AsIHBzLCBwciwgaXAsIHRtO1xuXHRcdFx0XHQvLyBpZiB3ZSBhcmUgb3ZlciBhbiBpbnN0YW5jZVxuXHRcdFx0XHRpZihpbnMgJiYgaW5zLl9kYXRhICYmIGlucy5fZGF0YS5kbmQpIHtcblx0XHRcdFx0XHRtYXJrZXIuYXR0cignY2xhc3MnLCAnanN0cmVlLScgKyBpbnMuZ2V0X3RoZW1lKCkgKyAoIGlucy5zZXR0aW5ncy5jb3JlLnRoZW1lcy5yZXNwb25zaXZlID8gJyBqc3RyZWUtZG5kLXJlc3BvbnNpdmUnIDogJycgKSk7XG5cdFx0XHRcdFx0ZGF0YS5oZWxwZXJcblx0XHRcdFx0XHRcdC5jaGlsZHJlbigpLmF0dHIoJ2NsYXNzJywgJ2pzdHJlZS0nICsgaW5zLmdldF90aGVtZSgpICsgKCBpbnMuc2V0dGluZ3MuY29yZS50aGVtZXMucmVzcG9uc2l2ZSA/ICcganN0cmVlLWRuZC1yZXNwb25zaXZlJyA6ICcnICkpXG5cdFx0XHRcdFx0XHQuZmluZCgnLmpzdHJlZS1jb3B5OmVxKDApJylbIGRhdGEuZGF0YS5vcmlnaW4gJiYgKGRhdGEuZGF0YS5vcmlnaW4uc2V0dGluZ3MuZG5kLmFsd2F5c19jb3B5IHx8IChkYXRhLmRhdGEub3JpZ2luLnNldHRpbmdzLmRuZC5jb3B5ICYmIChkYXRhLmV2ZW50Lm1ldGFLZXkgfHwgZGF0YS5ldmVudC5jdHJsS2V5KSkpID8gJ3Nob3cnIDogJ2hpZGUnIF0oKTtcblxuXG5cdFx0XHRcdFx0Ly8gaWYgYXJlIGhvdmVyaW5nIHRoZSBjb250YWluZXIgaXRzZWxmIGFkZCBhIG5ldyByb290IG5vZGVcblx0XHRcdFx0XHRpZiggKGRhdGEuZXZlbnQudGFyZ2V0ID09PSBpbnMuZWxlbWVudFswXSB8fCBkYXRhLmV2ZW50LnRhcmdldCA9PT0gaW5zLmdldF9jb250YWluZXJfdWwoKVswXSkgJiYgaW5zLmdldF9jb250YWluZXJfdWwoKS5jaGlsZHJlbigpLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0XHRcdFx0b2sgPSB0cnVlO1xuXHRcdFx0XHRcdFx0Zm9yKHQxID0gMCwgdDIgPSBkYXRhLmRhdGEubm9kZXMubGVuZ3RoOyB0MSA8IHQyOyB0MSsrKSB7XG5cdFx0XHRcdFx0XHRcdG9rID0gb2sgJiYgaW5zLmNoZWNrKCAoZGF0YS5kYXRhLm9yaWdpbiAmJiAoZGF0YS5kYXRhLm9yaWdpbi5zZXR0aW5ncy5kbmQuYWx3YXlzX2NvcHkgfHwgKGRhdGEuZGF0YS5vcmlnaW4uc2V0dGluZ3MuZG5kLmNvcHkgJiYgKGRhdGEuZXZlbnQubWV0YUtleSB8fCBkYXRhLmV2ZW50LmN0cmxLZXkpKSApID8gXCJjb3B5X25vZGVcIiA6IFwibW92ZV9ub2RlXCIpLCAoZGF0YS5kYXRhLm9yaWdpbiAmJiBkYXRhLmRhdGEub3JpZ2luICE9PSBpbnMgPyBkYXRhLmRhdGEub3JpZ2luLmdldF9ub2RlKGRhdGEuZGF0YS5ub2Rlc1t0MV0pIDogZGF0YS5kYXRhLm5vZGVzW3QxXSksICcjJywgJ2xhc3QnLCB7ICdkbmQnIDogdHJ1ZSwgJ3JlZicgOiBpbnMuZ2V0X25vZGUoJyMnKSwgJ3BvcycgOiAnaScsICdpc19tdWx0aScgOiAoZGF0YS5kYXRhLm9yaWdpbiAmJiBkYXRhLmRhdGEub3JpZ2luICE9PSBpbnMpLCAnaXNfZm9yZWlnbicgOiAoIWRhdGEuZGF0YS5vcmlnaW4pIH0pO1xuXHRcdFx0XHRcdFx0XHRpZighb2spIHsgYnJlYWs7IH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmKG9rKSB7XG5cdFx0XHRcdFx0XHRcdGxhc3RtdiA9IHsgJ2lucycgOiBpbnMsICdwYXInIDogJyMnLCAncG9zJyA6ICdsYXN0JyB9O1xuXHRcdFx0XHRcdFx0XHRtYXJrZXIuaGlkZSgpO1xuXHRcdFx0XHRcdFx0XHRkYXRhLmhlbHBlci5maW5kKCcuanN0cmVlLWljb246ZXEoMCknKS5yZW1vdmVDbGFzcygnanN0cmVlLWVyJykuYWRkQ2xhc3MoJ2pzdHJlZS1vaycpO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0Ly8gaWYgd2UgYXJlIGhvdmVyaW5nIGEgdHJlZSBub2RlXG5cdFx0XHRcdFx0XHRyZWYgPSAkKGRhdGEuZXZlbnQudGFyZ2V0KS5jbG9zZXN0KCcuanN0cmVlLWFuY2hvcicpO1xuXHRcdFx0XHRcdFx0aWYocmVmICYmIHJlZi5sZW5ndGggJiYgcmVmLnBhcmVudCgpLmlzKCcuanN0cmVlLWNsb3NlZCwgLmpzdHJlZS1vcGVuLCAuanN0cmVlLWxlYWYnKSkge1xuXHRcdFx0XHRcdFx0XHRvZmYgPSByZWYub2Zmc2V0KCk7XG5cdFx0XHRcdFx0XHRcdHJlbCA9IGRhdGEuZXZlbnQucGFnZVkgLSBvZmYudG9wO1xuXHRcdFx0XHRcdFx0XHRoID0gcmVmLmhlaWdodCgpO1xuXHRcdFx0XHRcdFx0XHRpZihyZWwgPCBoIC8gMykge1xuXHRcdFx0XHRcdFx0XHRcdG8gPSBbJ2InLCAnaScsICdhJ107XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0ZWxzZSBpZihyZWwgPiBoIC0gaCAvIDMpIHtcblx0XHRcdFx0XHRcdFx0XHRvID0gWydhJywgJ2knLCAnYiddO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdG8gPSByZWwgPiBoIC8gMiA/IFsnaScsICdhJywgJ2InXSA6IFsnaScsICdiJywgJ2EnXTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHQkLmVhY2gobywgZnVuY3Rpb24gKGosIHYpIHtcblx0XHRcdFx0XHRcdFx0XHRzd2l0Y2godikge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y2FzZSAnYic6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGwgPSBvZmYubGVmdCAtIDY7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHQgPSBvZmYudG9wO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRwID0gaW5zLmdldF9wYXJlbnQocmVmKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0aSA9IHJlZi5wYXJlbnQoKS5pbmRleCgpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0XHRcdGNhc2UgJ2knOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpcCA9IGlucy5zZXR0aW5ncy5kbmQuaW5zaWRlX3Bvcztcblx0XHRcdFx0XHRcdFx0XHRcdFx0dG0gPSBpbnMuZ2V0X25vZGUocmVmLnBhcmVudCgpKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0bCA9IG9mZi5sZWZ0IC0gMjtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dCA9IG9mZi50b3AgKyBoIC8gMiArIDE7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHAgPSB0bS5pZDtcblx0XHRcdFx0XHRcdFx0XHRcdFx0aSA9IGlwID09PSAnZmlyc3QnID8gMCA6IChpcCA9PT0gJ2xhc3QnID8gdG0uY2hpbGRyZW4ubGVuZ3RoIDogTWF0aC5taW4oaXAsIHRtLmNoaWxkcmVuLmxlbmd0aCkpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0XHRcdGNhc2UgJ2EnOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRsID0gb2ZmLmxlZnQgLSA2O1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0ID0gb2ZmLnRvcCArIGg7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHAgPSBpbnMuZ2V0X3BhcmVudChyZWYpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRpID0gcmVmLnBhcmVudCgpLmluZGV4KCkgKyAxO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0LyohXG5cdFx0XHRcdFx0XHRcdFx0Ly8gVE9ETzogbW92aW5nIGluc2lkZSwgYnV0IHRoZSBub2RlIGlzIG5vdCB5ZXQgbG9hZGVkP1xuXHRcdFx0XHRcdFx0XHRcdC8vIHRoZSBjaGVjayB3aWxsIHdvcmsgYW55d2F5LCBhcyB3aGVuIG1vdmluZyB0aGUgbm9kZSB3aWxsIGJlIGxvYWRlZCBmaXJzdCBhbmQgY2hlY2tlZCBhZ2FpblxuXHRcdFx0XHRcdFx0XHRcdGlmKHYgPT09ICdpJyAmJiAhaW5zLmlzX2xvYWRlZChwKSkgeyB9XG5cdFx0XHRcdFx0XHRcdFx0Ki9cblx0XHRcdFx0XHRcdFx0XHRvayA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdFx0Zm9yKHQxID0gMCwgdDIgPSBkYXRhLmRhdGEubm9kZXMubGVuZ3RoOyB0MSA8IHQyOyB0MSsrKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRvcCA9IGRhdGEuZGF0YS5vcmlnaW4gJiYgKGRhdGEuZGF0YS5vcmlnaW4uc2V0dGluZ3MuZG5kLmFsd2F5c19jb3B5IHx8IChkYXRhLmRhdGEub3JpZ2luLnNldHRpbmdzLmRuZC5jb3B5ICYmIChkYXRhLmV2ZW50Lm1ldGFLZXkgfHwgZGF0YS5ldmVudC5jdHJsS2V5KSkpID8gXCJjb3B5X25vZGVcIiA6IFwibW92ZV9ub2RlXCI7XG5cdFx0XHRcdFx0XHRcdFx0XHRwcyA9IGk7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZihvcCA9PT0gXCJtb3ZlX25vZGVcIiAmJiB2ID09PSAnYScgJiYgKGRhdGEuZGF0YS5vcmlnaW4gJiYgZGF0YS5kYXRhLm9yaWdpbiA9PT0gaW5zKSAmJiBwID09PSBpbnMuZ2V0X3BhcmVudChkYXRhLmRhdGEubm9kZXNbdDFdKSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRwciA9IGlucy5nZXRfbm9kZShwKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYocHMgPiAkLmluQXJyYXkoZGF0YS5kYXRhLm5vZGVzW3QxXSwgcHIuY2hpbGRyZW4pKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0cHMgLT0gMTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0b2sgPSBvayAmJiAoIChpbnMgJiYgaW5zLnNldHRpbmdzICYmIGlucy5zZXR0aW5ncy5kbmQgJiYgaW5zLnNldHRpbmdzLmRuZC5jaGVja193aGlsZV9kcmFnZ2luZyA9PT0gZmFsc2UpIHx8IGlucy5jaGVjayhvcCwgKGRhdGEuZGF0YS5vcmlnaW4gJiYgZGF0YS5kYXRhLm9yaWdpbiAhPT0gaW5zID8gZGF0YS5kYXRhLm9yaWdpbi5nZXRfbm9kZShkYXRhLmRhdGEubm9kZXNbdDFdKSA6IGRhdGEuZGF0YS5ub2Rlc1t0MV0pLCBwLCBwcywgeyAnZG5kJyA6IHRydWUsICdyZWYnIDogaW5zLmdldF9ub2RlKHJlZi5wYXJlbnQoKSksICdwb3MnIDogdiwgJ2lzX211bHRpJyA6IChkYXRhLmRhdGEub3JpZ2luICYmIGRhdGEuZGF0YS5vcmlnaW4gIT09IGlucyksICdpc19mb3JlaWduJyA6ICghZGF0YS5kYXRhLm9yaWdpbikgfSkgKTtcblx0XHRcdFx0XHRcdFx0XHRcdGlmKCFvaykge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZihpbnMgJiYgaW5zLmxhc3RfZXJyb3IpIHsgbGFzdGVyID0gaW5zLmxhc3RfZXJyb3IoKTsgfVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0aWYob2spIHtcblx0XHRcdFx0XHRcdFx0XHRcdGlmKHYgPT09ICdpJyAmJiByZWYucGFyZW50KCkuaXMoJy5qc3RyZWUtY2xvc2VkJykgJiYgaW5zLnNldHRpbmdzLmRuZC5vcGVuX3RpbWVvdXQpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0b3BlbnRvID0gc2V0VGltZW91dCgoZnVuY3Rpb24gKHgsIHopIHsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgeC5vcGVuX25vZGUoeik7IH07IH0oaW5zLCByZWYpKSwgaW5zLnNldHRpbmdzLmRuZC5vcGVuX3RpbWVvdXQpO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0bGFzdG12ID0geyAnaW5zJyA6IGlucywgJ3BhcicgOiBwLCAncG9zJyA6IHYgPT09ICdpJyAmJiBpcCA9PT0gJ2xhc3QnICYmIGkgPT09IDAgJiYgIWlucy5pc19sb2FkZWQodG0pID8gJ2xhc3QnIDogaSB9O1xuXHRcdFx0XHRcdFx0XHRcdFx0bWFya2VyLmNzcyh7ICdsZWZ0JyA6IGwgKyAncHgnLCAndG9wJyA6IHQgKyAncHgnIH0pLnNob3coKTtcblx0XHRcdFx0XHRcdFx0XHRcdGRhdGEuaGVscGVyLmZpbmQoJy5qc3RyZWUtaWNvbjplcSgwKScpLnJlbW92ZUNsYXNzKCdqc3RyZWUtZXInKS5hZGRDbGFzcygnanN0cmVlLW9rJyk7XG5cdFx0XHRcdFx0XHRcdFx0XHRsYXN0ZXIgPSB7fTtcblx0XHRcdFx0XHRcdFx0XHRcdG8gPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRcdGlmKG8gPT09IHRydWUpIHsgcmV0dXJuOyB9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGxhc3RtdiA9IGZhbHNlO1xuXHRcdFx0XHRkYXRhLmhlbHBlci5maW5kKCcuanN0cmVlLWljb24nKS5yZW1vdmVDbGFzcygnanN0cmVlLW9rJykuYWRkQ2xhc3MoJ2pzdHJlZS1lcicpO1xuXHRcdFx0XHRtYXJrZXIuaGlkZSgpO1xuXHRcdFx0fSlcblx0XHRcdC5iaW5kKCdkbmRfc2Nyb2xsLnZha2F0YScsIGZ1bmN0aW9uIChlLCBkYXRhKSB7XG5cdFx0XHRcdGlmKCFkYXRhIHx8ICFkYXRhLmRhdGEgfHwgIWRhdGEuZGF0YS5qc3RyZWUpIHsgcmV0dXJuOyB9XG5cdFx0XHRcdG1hcmtlci5oaWRlKCk7XG5cdFx0XHRcdGxhc3RtdiA9IGZhbHNlO1xuXHRcdFx0XHRkYXRhLmhlbHBlci5maW5kKCcuanN0cmVlLWljb246ZXEoMCknKS5yZW1vdmVDbGFzcygnanN0cmVlLW9rJykuYWRkQ2xhc3MoJ2pzdHJlZS1lcicpO1xuXHRcdFx0fSlcblx0XHRcdC5iaW5kKCdkbmRfc3RvcC52YWthdGEnLCBmdW5jdGlvbiAoZSwgZGF0YSkge1xuXHRcdFx0XHRpZihvcGVudG8pIHsgY2xlYXJUaW1lb3V0KG9wZW50byk7IH1cblx0XHRcdFx0aWYoIWRhdGEgfHwgIWRhdGEuZGF0YSB8fCAhZGF0YS5kYXRhLmpzdHJlZSkgeyByZXR1cm47IH1cblx0XHRcdFx0bWFya2VyLmhpZGUoKTtcblx0XHRcdFx0dmFyIGksIGosIG5vZGVzID0gW107XG5cdFx0XHRcdGlmKGxhc3Rtdikge1xuXHRcdFx0XHRcdGZvcihpID0gMCwgaiA9IGRhdGEuZGF0YS5ub2Rlcy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcblx0XHRcdFx0XHRcdG5vZGVzW2ldID0gZGF0YS5kYXRhLm9yaWdpbiA/IGRhdGEuZGF0YS5vcmlnaW4uZ2V0X25vZGUoZGF0YS5kYXRhLm5vZGVzW2ldKSA6IGRhdGEuZGF0YS5ub2Rlc1tpXTtcblx0XHRcdFx0XHRcdGlmKGRhdGEuZGF0YS5vcmlnaW4pIHtcblx0XHRcdFx0XHRcdFx0bm9kZXNbaV0uaW5zdGFuY2UgPSBkYXRhLmRhdGEub3JpZ2luO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRsYXN0bXYuaW5zWyBkYXRhLmRhdGEub3JpZ2luICYmIChkYXRhLmRhdGEub3JpZ2luLnNldHRpbmdzLmRuZC5hbHdheXNfY29weSB8fCAoZGF0YS5kYXRhLm9yaWdpbi5zZXR0aW5ncy5kbmQuY29weSAmJiAoZGF0YS5ldmVudC5tZXRhS2V5IHx8IGRhdGEuZXZlbnQuY3RybEtleSkpKSA/ICdjb3B5X25vZGUnIDogJ21vdmVfbm9kZScgXShub2RlcywgbGFzdG12LnBhciwgbGFzdG12LnBvcyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0aSA9ICQoZGF0YS5ldmVudC50YXJnZXQpLmNsb3Nlc3QoJy5qc3RyZWUnKTtcblx0XHRcdFx0XHRpZihpLmxlbmd0aCAmJiBsYXN0ZXIgJiYgbGFzdGVyLmVycm9yICYmIGxhc3Rlci5lcnJvciA9PT0gJ2NoZWNrJykge1xuXHRcdFx0XHRcdFx0aSA9IGkuanN0cmVlKHRydWUpO1xuXHRcdFx0XHRcdFx0aWYoaSkge1xuXHRcdFx0XHRcdFx0XHRpLnNldHRpbmdzLmNvcmUuZXJyb3IuY2FsbCh0aGlzLCBsYXN0ZXIpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSlcblx0XHRcdC5iaW5kKCdrZXl1cCBrZXlkb3duJywgZnVuY3Rpb24gKGUsIGRhdGEpIHtcblx0XHRcdFx0ZGF0YSA9ICQudmFrYXRhLmRuZC5fZ2V0KCk7XG5cdFx0XHRcdGlmKGRhdGEgJiYgZGF0YS5kYXRhICYmIGRhdGEuZGF0YS5qc3RyZWUpIHtcblx0XHRcdFx0XHRkYXRhLmhlbHBlci5maW5kKCcuanN0cmVlLWNvcHk6ZXEoMCknKVsgZGF0YS5kYXRhLm9yaWdpbiAmJiAoZGF0YS5kYXRhLm9yaWdpbi5zZXR0aW5ncy5kbmQuYWx3YXlzX2NvcHkgfHwgKGRhdGEuZGF0YS5vcmlnaW4uc2V0dGluZ3MuZG5kLmNvcHkgJiYgKGUubWV0YUtleSB8fCBlLmN0cmxLZXkpKSkgPyAnc2hvdycgOiAnaGlkZScgXSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0fSk7XG5cblx0Ly8gaGVscGVyc1xuXHQoZnVuY3Rpb24gKCQpIHtcblx0XHQvLyBwcml2YXRlIHZhcmlhYmxlXG5cdFx0dmFyIHZha2F0YV9kbmQgPSB7XG5cdFx0XHRlbGVtZW50XHQ6IGZhbHNlLFxuXHRcdFx0dGFyZ2V0XHQ6IGZhbHNlLFxuXHRcdFx0aXNfZG93blx0OiBmYWxzZSxcblx0XHRcdGlzX2RyYWdcdDogZmFsc2UsXG5cdFx0XHRoZWxwZXJcdDogZmFsc2UsXG5cdFx0XHRoZWxwZXJfdzogMCxcblx0XHRcdGRhdGFcdDogZmFsc2UsXG5cdFx0XHRpbml0X3hcdDogMCxcblx0XHRcdGluaXRfeVx0OiAwLFxuXHRcdFx0c2Nyb2xsX2w6IDAsXG5cdFx0XHRzY3JvbGxfdDogMCxcblx0XHRcdHNjcm9sbF9lOiBmYWxzZSxcblx0XHRcdHNjcm9sbF9pOiBmYWxzZSxcblx0XHRcdGlzX3RvdWNoOiBmYWxzZVxuXHRcdH07XG5cdFx0JC52YWthdGEuZG5kID0ge1xuXHRcdFx0c2V0dGluZ3MgOiB7XG5cdFx0XHRcdHNjcm9sbF9zcGVlZFx0XHQ6IDEwLFxuXHRcdFx0XHRzY3JvbGxfcHJveGltaXR5XHQ6IDIwLFxuXHRcdFx0XHRoZWxwZXJfbGVmdFx0XHRcdDogNSxcblx0XHRcdFx0aGVscGVyX3RvcFx0XHRcdDogMTAsXG5cdFx0XHRcdHRocmVzaG9sZFx0XHRcdDogNSxcblx0XHRcdFx0dGhyZXNob2xkX3RvdWNoXHRcdDogNTBcblx0XHRcdH0sXG5cdFx0XHRfdHJpZ2dlciA6IGZ1bmN0aW9uIChldmVudF9uYW1lLCBlKSB7XG5cdFx0XHRcdHZhciBkYXRhID0gJC52YWthdGEuZG5kLl9nZXQoKTtcblx0XHRcdFx0ZGF0YS5ldmVudCA9IGU7XG5cdFx0XHRcdCQoZG9jdW1lbnQpLnRyaWdnZXJIYW5kbGVyKFwiZG5kX1wiICsgZXZlbnRfbmFtZSArIFwiLnZha2F0YVwiLCBkYXRhKTtcblx0XHRcdH0sXG5cdFx0XHRfZ2V0IDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFwiZGF0YVwiXHRcdDogdmFrYXRhX2RuZC5kYXRhLFxuXHRcdFx0XHRcdFwiZWxlbWVudFwiXHQ6IHZha2F0YV9kbmQuZWxlbWVudCxcblx0XHRcdFx0XHRcImhlbHBlclwiXHQ6IHZha2F0YV9kbmQuaGVscGVyXG5cdFx0XHRcdH07XG5cdFx0XHR9LFxuXHRcdFx0X2NsZWFuIDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRpZih2YWthdGFfZG5kLmhlbHBlcikgeyB2YWthdGFfZG5kLmhlbHBlci5yZW1vdmUoKTsgfVxuXHRcdFx0XHRpZih2YWthdGFfZG5kLnNjcm9sbF9pKSB7IGNsZWFySW50ZXJ2YWwodmFrYXRhX2RuZC5zY3JvbGxfaSk7IHZha2F0YV9kbmQuc2Nyb2xsX2kgPSBmYWxzZTsgfVxuXHRcdFx0XHR2YWthdGFfZG5kID0ge1xuXHRcdFx0XHRcdGVsZW1lbnRcdDogZmFsc2UsXG5cdFx0XHRcdFx0dGFyZ2V0XHQ6IGZhbHNlLFxuXHRcdFx0XHRcdGlzX2Rvd25cdDogZmFsc2UsXG5cdFx0XHRcdFx0aXNfZHJhZ1x0OiBmYWxzZSxcblx0XHRcdFx0XHRoZWxwZXJcdDogZmFsc2UsXG5cdFx0XHRcdFx0aGVscGVyX3c6IDAsXG5cdFx0XHRcdFx0ZGF0YVx0OiBmYWxzZSxcblx0XHRcdFx0XHRpbml0X3hcdDogMCxcblx0XHRcdFx0XHRpbml0X3lcdDogMCxcblx0XHRcdFx0XHRzY3JvbGxfbDogMCxcblx0XHRcdFx0XHRzY3JvbGxfdDogMCxcblx0XHRcdFx0XHRzY3JvbGxfZTogZmFsc2UsXG5cdFx0XHRcdFx0c2Nyb2xsX2k6IGZhbHNlLFxuXHRcdFx0XHRcdGlzX3RvdWNoOiBmYWxzZVxuXHRcdFx0XHR9O1xuXHRcdFx0XHQkKGRvY3VtZW50KS5vZmYoXCJtb3VzZW1vdmUgdG91Y2htb3ZlXCIsICQudmFrYXRhLmRuZC5kcmFnKTtcblx0XHRcdFx0JChkb2N1bWVudCkub2ZmKFwibW91c2V1cCB0b3VjaGVuZFwiLCAkLnZha2F0YS5kbmQuc3RvcCk7XG5cdFx0XHR9LFxuXHRcdFx0X3Njcm9sbCA6IGZ1bmN0aW9uIChpbml0X29ubHkpIHtcblx0XHRcdFx0aWYoIXZha2F0YV9kbmQuc2Nyb2xsX2UgfHwgKCF2YWthdGFfZG5kLnNjcm9sbF9sICYmICF2YWthdGFfZG5kLnNjcm9sbF90KSkge1xuXHRcdFx0XHRcdGlmKHZha2F0YV9kbmQuc2Nyb2xsX2kpIHsgY2xlYXJJbnRlcnZhbCh2YWthdGFfZG5kLnNjcm9sbF9pKTsgdmFrYXRhX2RuZC5zY3JvbGxfaSA9IGZhbHNlOyB9XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKCF2YWthdGFfZG5kLnNjcm9sbF9pKSB7XG5cdFx0XHRcdFx0dmFrYXRhX2RuZC5zY3JvbGxfaSA9IHNldEludGVydmFsKCQudmFrYXRhLmRuZC5fc2Nyb2xsLCAxMDApO1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZihpbml0X29ubHkgPT09IHRydWUpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0XHRcdFx0dmFyIGkgPSB2YWthdGFfZG5kLnNjcm9sbF9lLnNjcm9sbFRvcCgpLFxuXHRcdFx0XHRcdGogPSB2YWthdGFfZG5kLnNjcm9sbF9lLnNjcm9sbExlZnQoKTtcblx0XHRcdFx0dmFrYXRhX2RuZC5zY3JvbGxfZS5zY3JvbGxUb3AoaSArIHZha2F0YV9kbmQuc2Nyb2xsX3QgKiAkLnZha2F0YS5kbmQuc2V0dGluZ3Muc2Nyb2xsX3NwZWVkKTtcblx0XHRcdFx0dmFrYXRhX2RuZC5zY3JvbGxfZS5zY3JvbGxMZWZ0KGogKyB2YWthdGFfZG5kLnNjcm9sbF9sICogJC52YWthdGEuZG5kLnNldHRpbmdzLnNjcm9sbF9zcGVlZCk7XG5cdFx0XHRcdGlmKGkgIT09IHZha2F0YV9kbmQuc2Nyb2xsX2Uuc2Nyb2xsVG9wKCkgfHwgaiAhPT0gdmFrYXRhX2RuZC5zY3JvbGxfZS5zY3JvbGxMZWZ0KCkpIHtcblx0XHRcdFx0XHQvKipcblx0XHRcdFx0XHQgKiB0cmlnZ2VyZWQgb24gdGhlIGRvY3VtZW50IHdoZW4gYSBkcmFnIGNhdXNlcyBhbiBlbGVtZW50IHRvIHNjcm9sbFxuXHRcdFx0XHRcdCAqIEBldmVudFxuXHRcdFx0XHRcdCAqIEBwbHVnaW4gZG5kXG5cdFx0XHRcdFx0ICogQG5hbWUgZG5kX3Njcm9sbC52YWthdGFcblx0XHRcdFx0XHQgKiBAcGFyYW0ge01peGVkfSBkYXRhIGFueSBkYXRhIHN1cHBsaWVkIHdpdGggdGhlIGNhbGwgdG8gJC52YWthdGEuZG5kLnN0YXJ0XG5cdFx0XHRcdFx0ICogQHBhcmFtIHtET019IGVsZW1lbnQgdGhlIERPTSBlbGVtZW50IGJlaW5nIGRyYWdnZWRcblx0XHRcdFx0XHQgKiBAcGFyYW0ge2pRdWVyeX0gaGVscGVyIHRoZSBoZWxwZXIgc2hvd24gbmV4dCB0byB0aGUgbW91c2Vcblx0XHRcdFx0XHQgKiBAcGFyYW0ge2pRdWVyeX0gZXZlbnQgdGhlIGVsZW1lbnQgdGhhdCBpcyBzY3JvbGxpbmdcblx0XHRcdFx0XHQgKi9cblx0XHRcdFx0XHQkLnZha2F0YS5kbmQuX3RyaWdnZXIoXCJzY3JvbGxcIiwgdmFrYXRhX2RuZC5zY3JvbGxfZSk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRzdGFydCA6IGZ1bmN0aW9uIChlLCBkYXRhLCBodG1sKSB7XG5cdFx0XHRcdGlmKGUudHlwZSA9PT0gXCJ0b3VjaHN0YXJ0XCIgJiYgZS5vcmlnaW5hbEV2ZW50ICYmIGUub3JpZ2luYWxFdmVudC5jaGFuZ2VkVG91Y2hlcyAmJiBlLm9yaWdpbmFsRXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0pIHtcblx0XHRcdFx0XHRlLnBhZ2VYID0gZS5vcmlnaW5hbEV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdLnBhZ2VYO1xuXHRcdFx0XHRcdGUucGFnZVkgPSBlLm9yaWdpbmFsRXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0ucGFnZVk7XG5cdFx0XHRcdFx0ZS50YXJnZXQgPSBkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KGUub3JpZ2luYWxFdmVudC5jaGFuZ2VkVG91Y2hlc1swXS5wYWdlWCAtIHdpbmRvdy5wYWdlWE9mZnNldCwgZS5vcmlnaW5hbEV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdLnBhZ2VZIC0gd2luZG93LnBhZ2VZT2Zmc2V0KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZih2YWthdGFfZG5kLmlzX2RyYWcpIHsgJC52YWthdGEuZG5kLnN0b3Aoe30pOyB9XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0ZS5jdXJyZW50VGFyZ2V0LnVuc2VsZWN0YWJsZSA9IFwib25cIjtcblx0XHRcdFx0XHRlLmN1cnJlbnRUYXJnZXQub25zZWxlY3RzdGFydCA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gZmFsc2U7IH07XG5cdFx0XHRcdFx0aWYoZS5jdXJyZW50VGFyZ2V0LnN0eWxlKSB7IGUuY3VycmVudFRhcmdldC5zdHlsZS5Nb3pVc2VyU2VsZWN0ID0gXCJub25lXCI7IH1cblx0XHRcdFx0fSBjYXRjaChpZ25vcmUpIHsgfVxuXHRcdFx0XHR2YWthdGFfZG5kLmluaXRfeFx0PSBlLnBhZ2VYO1xuXHRcdFx0XHR2YWthdGFfZG5kLmluaXRfeVx0PSBlLnBhZ2VZO1xuXHRcdFx0XHR2YWthdGFfZG5kLmRhdGFcdFx0PSBkYXRhO1xuXHRcdFx0XHR2YWthdGFfZG5kLmlzX2Rvd25cdD0gdHJ1ZTtcblx0XHRcdFx0dmFrYXRhX2RuZC5lbGVtZW50XHQ9IGUuY3VycmVudFRhcmdldDtcblx0XHRcdFx0dmFrYXRhX2RuZC50YXJnZXRcdD0gZS50YXJnZXQ7XG5cdFx0XHRcdHZha2F0YV9kbmQuaXNfdG91Y2hcdD0gZS50eXBlID09PSBcInRvdWNoc3RhcnRcIjtcblx0XHRcdFx0aWYoaHRtbCAhPT0gZmFsc2UpIHtcblx0XHRcdFx0XHR2YWthdGFfZG5kLmhlbHBlciA9ICQoXCI8ZGl2IGlkPSd2YWthdGEtZG5kJz48L2Rpdj5cIikuaHRtbChodG1sKS5jc3Moe1xuXHRcdFx0XHRcdFx0XCJkaXNwbGF5XCJcdFx0OiBcImJsb2NrXCIsXG5cdFx0XHRcdFx0XHRcIm1hcmdpblwiXHRcdDogXCIwXCIsXG5cdFx0XHRcdFx0XHRcInBhZGRpbmdcIlx0XHQ6IFwiMFwiLFxuXHRcdFx0XHRcdFx0XCJwb3NpdGlvblwiXHRcdDogXCJhYnNvbHV0ZVwiLFxuXHRcdFx0XHRcdFx0XCJ0b3BcIlx0XHRcdDogXCItMjAwMHB4XCIsXG5cdFx0XHRcdFx0XHRcImxpbmVIZWlnaHRcIlx0OiBcIjE2cHhcIixcblx0XHRcdFx0XHRcdFwiekluZGV4XCJcdFx0OiBcIjEwMDAwXCJcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0XHQkKGRvY3VtZW50KS5iaW5kKFwibW91c2Vtb3ZlIHRvdWNobW92ZVwiLCAkLnZha2F0YS5kbmQuZHJhZyk7XG5cdFx0XHRcdCQoZG9jdW1lbnQpLmJpbmQoXCJtb3VzZXVwIHRvdWNoZW5kXCIsICQudmFrYXRhLmRuZC5zdG9wKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fSxcblx0XHRcdGRyYWcgOiBmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHRpZihlLnR5cGUgPT09IFwidG91Y2htb3ZlXCIgJiYgZS5vcmlnaW5hbEV2ZW50ICYmIGUub3JpZ2luYWxFdmVudC5jaGFuZ2VkVG91Y2hlcyAmJiBlLm9yaWdpbmFsRXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0pIHtcblx0XHRcdFx0XHRlLnBhZ2VYID0gZS5vcmlnaW5hbEV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdLnBhZ2VYO1xuXHRcdFx0XHRcdGUucGFnZVkgPSBlLm9yaWdpbmFsRXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0ucGFnZVk7XG5cdFx0XHRcdFx0ZS50YXJnZXQgPSBkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KGUub3JpZ2luYWxFdmVudC5jaGFuZ2VkVG91Y2hlc1swXS5wYWdlWCAtIHdpbmRvdy5wYWdlWE9mZnNldCwgZS5vcmlnaW5hbEV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdLnBhZ2VZIC0gd2luZG93LnBhZ2VZT2Zmc2V0KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZighdmFrYXRhX2RuZC5pc19kb3duKSB7IHJldHVybjsgfVxuXHRcdFx0XHRpZighdmFrYXRhX2RuZC5pc19kcmFnKSB7XG5cdFx0XHRcdFx0aWYoXG5cdFx0XHRcdFx0XHRNYXRoLmFicyhlLnBhZ2VYIC0gdmFrYXRhX2RuZC5pbml0X3gpID4gKHZha2F0YV9kbmQuaXNfdG91Y2ggPyAkLnZha2F0YS5kbmQuc2V0dGluZ3MudGhyZXNob2xkX3RvdWNoIDogJC52YWthdGEuZG5kLnNldHRpbmdzLnRocmVzaG9sZCkgfHxcblx0XHRcdFx0XHRcdE1hdGguYWJzKGUucGFnZVkgLSB2YWthdGFfZG5kLmluaXRfeSkgPiAodmFrYXRhX2RuZC5pc190b3VjaCA/ICQudmFrYXRhLmRuZC5zZXR0aW5ncy50aHJlc2hvbGRfdG91Y2ggOiAkLnZha2F0YS5kbmQuc2V0dGluZ3MudGhyZXNob2xkKVxuXHRcdFx0XHRcdCkge1xuXHRcdFx0XHRcdFx0aWYodmFrYXRhX2RuZC5oZWxwZXIpIHtcblx0XHRcdFx0XHRcdFx0dmFrYXRhX2RuZC5oZWxwZXIuYXBwZW5kVG8oXCJib2R5XCIpO1xuXHRcdFx0XHRcdFx0XHR2YWthdGFfZG5kLmhlbHBlcl93ID0gdmFrYXRhX2RuZC5oZWxwZXIub3V0ZXJXaWR0aCgpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0dmFrYXRhX2RuZC5pc19kcmFnID0gdHJ1ZTtcblx0XHRcdFx0XHRcdC8qKlxuXHRcdFx0XHRcdFx0ICogdHJpZ2dlcmVkIG9uIHRoZSBkb2N1bWVudCB3aGVuIGEgZHJhZyBzdGFydHNcblx0XHRcdFx0XHRcdCAqIEBldmVudFxuXHRcdFx0XHRcdFx0ICogQHBsdWdpbiBkbmRcblx0XHRcdFx0XHRcdCAqIEBuYW1lIGRuZF9zdGFydC52YWthdGFcblx0XHRcdFx0XHRcdCAqIEBwYXJhbSB7TWl4ZWR9IGRhdGEgYW55IGRhdGEgc3VwcGxpZWQgd2l0aCB0aGUgY2FsbCB0byAkLnZha2F0YS5kbmQuc3RhcnRcblx0XHRcdFx0XHRcdCAqIEBwYXJhbSB7RE9NfSBlbGVtZW50IHRoZSBET00gZWxlbWVudCBiZWluZyBkcmFnZ2VkXG5cdFx0XHRcdFx0XHQgKiBAcGFyYW0ge2pRdWVyeX0gaGVscGVyIHRoZSBoZWxwZXIgc2hvd24gbmV4dCB0byB0aGUgbW91c2Vcblx0XHRcdFx0XHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCB0aGUgZXZlbnQgdGhhdCBjYXVzZWQgdGhlIHN0YXJ0IChwcm9iYWJseSBtb3VzZW1vdmUpXG5cdFx0XHRcdFx0XHQgKi9cblx0XHRcdFx0XHRcdCQudmFrYXRhLmRuZC5fdHJpZ2dlcihcInN0YXJ0XCIsIGUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIHsgcmV0dXJuOyB9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgZCAgPSBmYWxzZSwgdyAgPSBmYWxzZSxcblx0XHRcdFx0XHRkaCA9IGZhbHNlLCB3aCA9IGZhbHNlLFxuXHRcdFx0XHRcdGR3ID0gZmFsc2UsIHd3ID0gZmFsc2UsXG5cdFx0XHRcdFx0ZHQgPSBmYWxzZSwgZGwgPSBmYWxzZSxcblx0XHRcdFx0XHRodCA9IGZhbHNlLCBobCA9IGZhbHNlO1xuXG5cdFx0XHRcdHZha2F0YV9kbmQuc2Nyb2xsX3QgPSAwO1xuXHRcdFx0XHR2YWthdGFfZG5kLnNjcm9sbF9sID0gMDtcblx0XHRcdFx0dmFrYXRhX2RuZC5zY3JvbGxfZSA9IGZhbHNlO1xuXHRcdFx0XHQkKCQoZS50YXJnZXQpLnBhcmVudHNVbnRpbChcImJvZHlcIikuYWRkQmFjaygpLmdldCgpLnJldmVyc2UoKSlcblx0XHRcdFx0XHQuZmlsdGVyKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRcdHJldHVyblx0KC9eYXV0b3xzY3JvbGwkLykudGVzdCgkKHRoaXMpLmNzcyhcIm92ZXJmbG93XCIpKSAmJlxuXHRcdFx0XHRcdFx0XHRcdCh0aGlzLnNjcm9sbEhlaWdodCA+IHRoaXMub2Zmc2V0SGVpZ2h0IHx8IHRoaXMuc2Nyb2xsV2lkdGggPiB0aGlzLm9mZnNldFdpZHRoKTtcblx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdC5lYWNoKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRcdHZhciB0ID0gJCh0aGlzKSwgbyA9IHQub2Zmc2V0KCk7XG5cdFx0XHRcdFx0XHRpZih0aGlzLnNjcm9sbEhlaWdodCA+IHRoaXMub2Zmc2V0SGVpZ2h0KSB7XG5cdFx0XHRcdFx0XHRcdGlmKG8udG9wICsgdC5oZWlnaHQoKSAtIGUucGFnZVkgPCAkLnZha2F0YS5kbmQuc2V0dGluZ3Muc2Nyb2xsX3Byb3hpbWl0eSlcdHsgdmFrYXRhX2RuZC5zY3JvbGxfdCA9IDE7IH1cblx0XHRcdFx0XHRcdFx0aWYoZS5wYWdlWSAtIG8udG9wIDwgJC52YWthdGEuZG5kLnNldHRpbmdzLnNjcm9sbF9wcm94aW1pdHkpXHRcdFx0XHR7IHZha2F0YV9kbmQuc2Nyb2xsX3QgPSAtMTsgfVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYodGhpcy5zY3JvbGxXaWR0aCA+IHRoaXMub2Zmc2V0V2lkdGgpIHtcblx0XHRcdFx0XHRcdFx0aWYoby5sZWZ0ICsgdC53aWR0aCgpIC0gZS5wYWdlWCA8ICQudmFrYXRhLmRuZC5zZXR0aW5ncy5zY3JvbGxfcHJveGltaXR5KVx0eyB2YWthdGFfZG5kLnNjcm9sbF9sID0gMTsgfVxuXHRcdFx0XHRcdFx0XHRpZihlLnBhZ2VYIC0gby5sZWZ0IDwgJC52YWthdGEuZG5kLnNldHRpbmdzLnNjcm9sbF9wcm94aW1pdHkpXHRcdFx0XHR7IHZha2F0YV9kbmQuc2Nyb2xsX2wgPSAtMTsgfVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYodmFrYXRhX2RuZC5zY3JvbGxfdCB8fCB2YWthdGFfZG5kLnNjcm9sbF9sKSB7XG5cdFx0XHRcdFx0XHRcdHZha2F0YV9kbmQuc2Nyb2xsX2UgPSAkKHRoaXMpO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0aWYoIXZha2F0YV9kbmQuc2Nyb2xsX2UpIHtcblx0XHRcdFx0XHRkICA9ICQoZG9jdW1lbnQpOyB3ID0gJCh3aW5kb3cpO1xuXHRcdFx0XHRcdGRoID0gZC5oZWlnaHQoKTsgd2ggPSB3LmhlaWdodCgpO1xuXHRcdFx0XHRcdGR3ID0gZC53aWR0aCgpOyB3dyA9IHcud2lkdGgoKTtcblx0XHRcdFx0XHRkdCA9IGQuc2Nyb2xsVG9wKCk7IGRsID0gZC5zY3JvbGxMZWZ0KCk7XG5cdFx0XHRcdFx0aWYoZGggPiB3aCAmJiBlLnBhZ2VZIC0gZHQgPCAkLnZha2F0YS5kbmQuc2V0dGluZ3Muc2Nyb2xsX3Byb3hpbWl0eSlcdFx0eyB2YWthdGFfZG5kLnNjcm9sbF90ID0gLTE7ICB9XG5cdFx0XHRcdFx0aWYoZGggPiB3aCAmJiB3aCAtIChlLnBhZ2VZIC0gZHQpIDwgJC52YWthdGEuZG5kLnNldHRpbmdzLnNjcm9sbF9wcm94aW1pdHkpXHR7IHZha2F0YV9kbmQuc2Nyb2xsX3QgPSAxOyB9XG5cdFx0XHRcdFx0aWYoZHcgPiB3dyAmJiBlLnBhZ2VYIC0gZGwgPCAkLnZha2F0YS5kbmQuc2V0dGluZ3Muc2Nyb2xsX3Byb3hpbWl0eSlcdFx0eyB2YWthdGFfZG5kLnNjcm9sbF9sID0gLTE7IH1cblx0XHRcdFx0XHRpZihkdyA+IHd3ICYmIHd3IC0gKGUucGFnZVggLSBkbCkgPCAkLnZha2F0YS5kbmQuc2V0dGluZ3Muc2Nyb2xsX3Byb3hpbWl0eSlcdHsgdmFrYXRhX2RuZC5zY3JvbGxfbCA9IDE7IH1cblx0XHRcdFx0XHRpZih2YWthdGFfZG5kLnNjcm9sbF90IHx8IHZha2F0YV9kbmQuc2Nyb2xsX2wpIHtcblx0XHRcdFx0XHRcdHZha2F0YV9kbmQuc2Nyb2xsX2UgPSBkO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZih2YWthdGFfZG5kLnNjcm9sbF9lKSB7ICQudmFrYXRhLmRuZC5fc2Nyb2xsKHRydWUpOyB9XG5cblx0XHRcdFx0aWYodmFrYXRhX2RuZC5oZWxwZXIpIHtcblx0XHRcdFx0XHRodCA9IHBhcnNlSW50KGUucGFnZVkgKyAkLnZha2F0YS5kbmQuc2V0dGluZ3MuaGVscGVyX3RvcCwgMTApO1xuXHRcdFx0XHRcdGhsID0gcGFyc2VJbnQoZS5wYWdlWCArICQudmFrYXRhLmRuZC5zZXR0aW5ncy5oZWxwZXJfbGVmdCwgMTApO1xuXHRcdFx0XHRcdGlmKGRoICYmIGh0ICsgMjUgPiBkaCkgeyBodCA9IGRoIC0gNTA7IH1cblx0XHRcdFx0XHRpZihkdyAmJiBobCArIHZha2F0YV9kbmQuaGVscGVyX3cgPiBkdykgeyBobCA9IGR3IC0gKHZha2F0YV9kbmQuaGVscGVyX3cgKyAyKTsgfVxuXHRcdFx0XHRcdHZha2F0YV9kbmQuaGVscGVyLmNzcyh7XG5cdFx0XHRcdFx0XHRsZWZ0XHQ6IGhsICsgXCJweFwiLFxuXHRcdFx0XHRcdFx0dG9wXHRcdDogaHQgKyBcInB4XCJcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvKipcblx0XHRcdFx0ICogdHJpZ2dlcmVkIG9uIHRoZSBkb2N1bWVudCB3aGVuIGEgZHJhZyBpcyBpbiBwcm9ncmVzc1xuXHRcdFx0XHQgKiBAZXZlbnRcblx0XHRcdFx0ICogQHBsdWdpbiBkbmRcblx0XHRcdFx0ICogQG5hbWUgZG5kX21vdmUudmFrYXRhXG5cdFx0XHRcdCAqIEBwYXJhbSB7TWl4ZWR9IGRhdGEgYW55IGRhdGEgc3VwcGxpZWQgd2l0aCB0aGUgY2FsbCB0byAkLnZha2F0YS5kbmQuc3RhcnRcblx0XHRcdFx0ICogQHBhcmFtIHtET019IGVsZW1lbnQgdGhlIERPTSBlbGVtZW50IGJlaW5nIGRyYWdnZWRcblx0XHRcdFx0ICogQHBhcmFtIHtqUXVlcnl9IGhlbHBlciB0aGUgaGVscGVyIHNob3duIG5leHQgdG8gdGhlIG1vdXNlXG5cdFx0XHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCB0aGUgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyB0byB0cmlnZ2VyIChtb3N0IGxpa2VseSBtb3VzZW1vdmUpXG5cdFx0XHRcdCAqL1xuXHRcdFx0XHQkLnZha2F0YS5kbmQuX3RyaWdnZXIoXCJtb3ZlXCIsIGUpO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9LFxuXHRcdFx0c3RvcCA6IGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRcdGlmKGUudHlwZSA9PT0gXCJ0b3VjaGVuZFwiICYmIGUub3JpZ2luYWxFdmVudCAmJiBlLm9yaWdpbmFsRXZlbnQuY2hhbmdlZFRvdWNoZXMgJiYgZS5vcmlnaW5hbEV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdKSB7XG5cdFx0XHRcdFx0ZS5wYWdlWCA9IGUub3JpZ2luYWxFdmVudC5jaGFuZ2VkVG91Y2hlc1swXS5wYWdlWDtcblx0XHRcdFx0XHRlLnBhZ2VZID0gZS5vcmlnaW5hbEV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdLnBhZ2VZO1xuXHRcdFx0XHRcdGUudGFyZ2V0ID0gZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludChlLm9yaWdpbmFsRXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0ucGFnZVggLSB3aW5kb3cucGFnZVhPZmZzZXQsIGUub3JpZ2luYWxFdmVudC5jaGFuZ2VkVG91Y2hlc1swXS5wYWdlWSAtIHdpbmRvdy5wYWdlWU9mZnNldCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYodmFrYXRhX2RuZC5pc19kcmFnKSB7XG5cdFx0XHRcdFx0LyoqXG5cdFx0XHRcdFx0ICogdHJpZ2dlcmVkIG9uIHRoZSBkb2N1bWVudCB3aGVuIGEgZHJhZyBzdG9wcyAodGhlIGRyYWdnZWQgZWxlbWVudCBpcyBkcm9wcGVkKVxuXHRcdFx0XHRcdCAqIEBldmVudFxuXHRcdFx0XHRcdCAqIEBwbHVnaW4gZG5kXG5cdFx0XHRcdFx0ICogQG5hbWUgZG5kX3N0b3AudmFrYXRhXG5cdFx0XHRcdFx0ICogQHBhcmFtIHtNaXhlZH0gZGF0YSBhbnkgZGF0YSBzdXBwbGllZCB3aXRoIHRoZSBjYWxsIHRvICQudmFrYXRhLmRuZC5zdGFydFxuXHRcdFx0XHRcdCAqIEBwYXJhbSB7RE9NfSBlbGVtZW50IHRoZSBET00gZWxlbWVudCBiZWluZyBkcmFnZ2VkXG5cdFx0XHRcdFx0ICogQHBhcmFtIHtqUXVlcnl9IGhlbHBlciB0aGUgaGVscGVyIHNob3duIG5leHQgdG8gdGhlIG1vdXNlXG5cdFx0XHRcdFx0ICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IHRoZSBldmVudCB0aGF0IGNhdXNlZCB0aGUgc3RvcFxuXHRcdFx0XHRcdCAqL1xuXHRcdFx0XHRcdCQudmFrYXRhLmRuZC5fdHJpZ2dlcihcInN0b3BcIiwgZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0aWYoZS50eXBlID09PSBcInRvdWNoZW5kXCIgJiYgZS50YXJnZXQgPT09IHZha2F0YV9kbmQudGFyZ2V0KSB7XG5cdFx0XHRcdFx0XHR2YXIgdG8gPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgJChlLnRhcmdldCkuY2xpY2soKTsgfSwgMTAwKTtcblx0XHRcdFx0XHRcdCQoZS50YXJnZXQpLm9uZSgnY2xpY2snLCBmdW5jdGlvbigpIHsgaWYodG8pIHsgY2xlYXJUaW1lb3V0KHRvKTsgfSB9KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0JC52YWthdGEuZG5kLl9jbGVhbigpO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fTtcblx0fSgkKSk7XG5cblx0Ly8gaW5jbHVkZSB0aGUgZG5kIHBsdWdpbiBieSBkZWZhdWx0XG5cdC8vICQuanN0cmVlLmRlZmF1bHRzLnBsdWdpbnMucHVzaChcImRuZFwiKTtcblxuXG4vKipcbiAqICMjIyBTZWFyY2ggcGx1Z2luXG4gKlxuICogQWRkcyBzZWFyY2ggZnVuY3Rpb25hbGl0eSB0byBqc1RyZWUuXG4gKi9cblxuXHQvKipcblx0ICogc3RvcmVzIGFsbCBkZWZhdWx0cyBmb3IgdGhlIHNlYXJjaCBwbHVnaW5cblx0ICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuc2VhcmNoXG5cdCAqIEBwbHVnaW4gc2VhcmNoXG5cdCAqL1xuXHQkLmpzdHJlZS5kZWZhdWx0cy5zZWFyY2ggPSB7XG5cdFx0LyoqXG5cdFx0ICogYSBqUXVlcnktbGlrZSBBSkFYIGNvbmZpZywgd2hpY2gganN0cmVlIHVzZXMgaWYgYSBzZXJ2ZXIgc2hvdWxkIGJlIHF1ZXJpZWQgZm9yIHJlc3VsdHMuIFxuXHRcdCAqIFxuXHRcdCAqIEEgYHN0cmAgKHdoaWNoIGlzIHRoZSBzZWFyY2ggc3RyaW5nKSBwYXJhbWV0ZXIgd2lsbCBiZSBhZGRlZCB3aXRoIHRoZSByZXF1ZXN0LiBUaGUgZXhwZWN0ZWQgcmVzdWx0IGlzIGEgSlNPTiBhcnJheSB3aXRoIG5vZGVzIHRoYXQgbmVlZCB0byBiZSBvcGVuZWQgc28gdGhhdCBtYXRjaGluZyBub2RlcyB3aWxsIGJlIHJldmVhbGVkLlxuXHRcdCAqIExlYXZlIHRoaXMgc2V0dGluZyBhcyBgZmFsc2VgIHRvIG5vdCBxdWVyeSB0aGUgc2VydmVyLiBZb3UgY2FuIGFsc28gc2V0IHRoaXMgdG8gYSBmdW5jdGlvbiwgd2hpY2ggd2lsbCBiZSBpbnZva2VkIGluIHRoZSBpbnN0YW5jZSdzIHNjb3BlIGFuZCByZWNlaXZlIDIgcGFyYW1ldGVycyAtIHRoZSBzZWFyY2ggc3RyaW5nIGFuZCB0aGUgY2FsbGJhY2sgdG8gY2FsbCB3aXRoIHRoZSBhcnJheSBvZiBub2RlcyB0byBsb2FkLlxuXHRcdCAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLnNlYXJjaC5hamF4XG5cdFx0ICogQHBsdWdpbiBzZWFyY2hcblx0XHQgKi9cblx0XHRhamF4IDogZmFsc2UsXG5cdFx0LyoqXG5cdFx0ICogSW5kaWNhdGVzIGlmIHRoZSBzZWFyY2ggc2hvdWxkIGJlIGZ1enp5IG9yIG5vdCAoc2hvdWxkIGBjaG5kM2AgbWF0Y2ggYGNoaWxkIG5vZGUgM2ApLiBEZWZhdWx0IGlzIGBmYWxzZWAuXG5cdFx0ICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuc2VhcmNoLmZ1enp5XG5cdFx0ICogQHBsdWdpbiBzZWFyY2hcblx0XHQgKi9cblx0XHRmdXp6eSA6IGZhbHNlLFxuXHRcdC8qKlxuXHRcdCAqIEluZGljYXRlcyBpZiB0aGUgc2VhcmNoIHNob3VsZCBiZSBjYXNlIHNlbnNpdGl2ZS4gRGVmYXVsdCBpcyBgZmFsc2VgLlxuXHRcdCAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLnNlYXJjaC5jYXNlX3NlbnNpdGl2ZVxuXHRcdCAqIEBwbHVnaW4gc2VhcmNoXG5cdFx0ICovXG5cdFx0Y2FzZV9zZW5zaXRpdmUgOiBmYWxzZSxcblx0XHQvKipcblx0XHQgKiBJbmRpY2F0ZXMgaWYgdGhlIHRyZWUgc2hvdWxkIGJlIGZpbHRlcmVkIHRvIHNob3cgb25seSBtYXRjaGluZyBub2RlcyAoa2VlcCBpbiBtaW5kIHRoaXMgY2FuIGJlIGEgaGVhdnkgb24gbGFyZ2UgdHJlZXMgaW4gb2xkIGJyb3dzZXJzKS4gRGVmYXVsdCBpcyBgZmFsc2VgLlxuXHRcdCAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLnNlYXJjaC5zaG93X29ubHlfbWF0Y2hlc1xuXHRcdCAqIEBwbHVnaW4gc2VhcmNoXG5cdFx0ICovXG5cdFx0c2hvd19vbmx5X21hdGNoZXMgOiBmYWxzZSxcblx0XHQvKipcblx0XHQgKiBJbmRpY2F0ZXMgaWYgYWxsIG5vZGVzIG9wZW5lZCB0byByZXZlYWwgdGhlIHNlYXJjaCByZXN1bHQsIHNob3VsZCBiZSBjbG9zZWQgd2hlbiB0aGUgc2VhcmNoIGlzIGNsZWFyZWQgb3IgYSBuZXcgc2VhcmNoIGlzIHBlcmZvcm1lZC4gRGVmYXVsdCBpcyBgdHJ1ZWAuXG5cdFx0ICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuc2VhcmNoLmNsb3NlX29wZW5lZF9vbmNsZWFyXG5cdFx0ICogQHBsdWdpbiBzZWFyY2hcblx0XHQgKi9cblx0XHRjbG9zZV9vcGVuZWRfb25jbGVhciA6IHRydWUsXG5cdFx0LyoqXG5cdFx0ICogSW5kaWNhdGVzIGlmIG9ubHkgbGVhZiBub2RlcyBzaG91bGQgYmUgaW5jbHVkZWQgaW4gc2VhcmNoIHJlc3VsdHMuIERlZmF1bHQgaXMgYGZhbHNlYC5cblx0XHQgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5zZWFyY2guc2VhcmNoX2xlYXZlc19vbmx5XG5cdFx0ICogQHBsdWdpbiBzZWFyY2hcblx0XHQgKi9cblx0XHRzZWFyY2hfbGVhdmVzX29ubHkgOiBmYWxzZSxcblx0XHQvKipcblx0XHQgKiBJZiBzZXQgdG8gYSBmdW5jdGlvbiBpdCB3aWwgYmUgY2FsbGVkIGluIHRoZSBpbnN0YW5jZSdzIHNjb3BlIHdpdGggdHdvIGFyZ3VtZW50cyAtIHNlYXJjaCBzdHJpbmcgYW5kIG5vZGUgKHdoZXJlIG5vZGUgd2lsbCBiZSBldmVyeSBub2RlIGluIHRoZSBzdHJ1Y3R1cmUsIHNvIHVzZSB3aXRoIGNhdXRpb24pLlxuXHRcdCAqIElmIHRoZSBmdW5jdGlvbiByZXR1cm5zIGEgdHJ1dGh5IHZhbHVlIHRoZSBub2RlIHdpbGwgYmUgY29uc2lkZXJlZCBhIG1hdGNoIChpdCBtaWdodCBub3QgYmUgZGlzcGxheWVkIGlmIHNlYXJjaF9vbmx5X2xlYXZlcyBpcyBzZXQgdG8gdHJ1ZSBhbmQgdGhlIG5vZGUgaXMgbm90IGEgbGVhZikuIERlZmF1bHQgaXMgYGZhbHNlYC5cblx0XHQgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5zZWFyY2guc2VhcmNoX2NhbGxiYWNrXG5cdFx0ICogQHBsdWdpbiBzZWFyY2hcblx0XHQgKi9cblx0XHRzZWFyY2hfY2FsbGJhY2sgOiBmYWxzZVxuXHR9O1xuXG5cdCQuanN0cmVlLnBsdWdpbnMuc2VhcmNoID0gZnVuY3Rpb24gKG9wdGlvbnMsIHBhcmVudCkge1xuXHRcdHRoaXMuYmluZCA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHBhcmVudC5iaW5kLmNhbGwodGhpcyk7XG5cblx0XHRcdHRoaXMuX2RhdGEuc2VhcmNoLnN0ciA9IFwiXCI7XG5cdFx0XHR0aGlzLl9kYXRhLnNlYXJjaC5kb20gPSAkKCk7XG5cdFx0XHR0aGlzLl9kYXRhLnNlYXJjaC5yZXMgPSBbXTtcblx0XHRcdHRoaXMuX2RhdGEuc2VhcmNoLm9wbiA9IFtdO1xuXG5cdFx0XHR0aGlzLmVsZW1lbnQub24oJ2JlZm9yZV9vcGVuLmpzdHJlZScsICQucHJveHkoZnVuY3Rpb24gKGUsIGRhdGEpIHtcblx0XHRcdFx0dmFyIGksIGosIGYsIHIgPSB0aGlzLl9kYXRhLnNlYXJjaC5yZXMsIHMgPSBbXSwgbyA9ICQoKTtcblx0XHRcdFx0aWYociAmJiByLmxlbmd0aCkge1xuXHRcdFx0XHRcdHRoaXMuX2RhdGEuc2VhcmNoLmRvbSA9ICQodGhpcy5lbGVtZW50WzBdLnF1ZXJ5U2VsZWN0b3JBbGwoJyMnICsgJC5tYXAociwgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIFwiMDEyMzQ1Njc4OVwiLmluZGV4T2YodlswXSkgIT09IC0xID8gJ1xcXFwzJyArIHZbMF0gKyAnICcgKyB2LnN1YnN0cigxKS5yZXBsYWNlKCQuanN0cmVlLmlkcmVnZXgsJ1xcXFwkJicpIDogdi5yZXBsYWNlKCQuanN0cmVlLmlkcmVnZXgsJ1xcXFwkJicpOyB9KS5qb2luKCcsICMnKSkpO1xuXHRcdFx0XHRcdHRoaXMuX2RhdGEuc2VhcmNoLmRvbS5jaGlsZHJlbihcIi5qc3RyZWUtYW5jaG9yXCIpLmFkZENsYXNzKCdqc3RyZWUtc2VhcmNoJyk7XG5cdFx0XHRcdFx0aWYodGhpcy5zZXR0aW5ncy5zZWFyY2guc2hvd19vbmx5X21hdGNoZXMgJiYgdGhpcy5fZGF0YS5zZWFyY2gucmVzLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0Zm9yKGkgPSAwLCBqID0gci5sZW5ndGg7IGkgPCBqOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0cyA9IHMuY29uY2F0KHRoaXMuZ2V0X25vZGUocltpXSkucGFyZW50cyk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRzID0gJC52YWthdGEuYXJyYXlfcmVtb3ZlX2l0ZW0oJC52YWthdGEuYXJyYXlfdW5pcXVlKHMpLCcjJyk7XG5cdFx0XHRcdFx0XHRvID0gcy5sZW5ndGggPyAkKHRoaXMuZWxlbWVudFswXS5xdWVyeVNlbGVjdG9yQWxsKCcjJyArICQubWFwKHMsIGZ1bmN0aW9uICh2KSB7IHJldHVybiBcIjAxMjM0NTY3ODlcIi5pbmRleE9mKHZbMF0pICE9PSAtMSA/ICdcXFxcMycgKyB2WzBdICsgJyAnICsgdi5zdWJzdHIoMSkucmVwbGFjZSgkLmpzdHJlZS5pZHJlZ2V4LCdcXFxcJCYnKSA6IHYucmVwbGFjZSgkLmpzdHJlZS5pZHJlZ2V4LCdcXFxcJCYnKTsgfSkuam9pbignLCAjJykpKSA6ICQoKTtcblxuXHRcdFx0XHRcdFx0dGhpcy5lbGVtZW50LmZpbmQoXCIuanN0cmVlLW5vZGVcIikuaGlkZSgpLmZpbHRlcignLmpzdHJlZS1sYXN0JykuZmlsdGVyKGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5uZXh0U2libGluZzsgfSkucmVtb3ZlQ2xhc3MoJ2pzdHJlZS1sYXN0Jyk7XG5cdFx0XHRcdFx0XHRvID0gby5hZGQodGhpcy5fZGF0YS5zZWFyY2guZG9tKTtcblx0XHRcdFx0XHRcdG8ucGFyZW50c1VudGlsKFwiLmpzdHJlZVwiKS5hZGRCYWNrKCkuc2hvdygpXG5cdFx0XHRcdFx0XHRcdC5maWx0ZXIoXCIuanN0cmVlLWNoaWxkcmVuXCIpLmVhY2goZnVuY3Rpb24gKCkgeyAkKHRoaXMpLmNoaWxkcmVuKFwiLmpzdHJlZS1ub2RlOnZpc2libGVcIikuZXEoLTEpLmFkZENsYXNzKFwianN0cmVlLWxhc3RcIik7IH0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSwgdGhpcykpO1xuXHRcdFx0aWYodGhpcy5zZXR0aW5ncy5zZWFyY2guc2hvd19vbmx5X21hdGNoZXMpIHtcblx0XHRcdFx0dGhpcy5lbGVtZW50XG5cdFx0XHRcdFx0Lm9uKFwic2VhcmNoLmpzdHJlZVwiLCBmdW5jdGlvbiAoZSwgZGF0YSkge1xuXHRcdFx0XHRcdFx0aWYoZGF0YS5ub2Rlcy5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdFx0JCh0aGlzKS5maW5kKFwiLmpzdHJlZS1ub2RlXCIpLmhpZGUoKS5maWx0ZXIoJy5qc3RyZWUtbGFzdCcpLmZpbHRlcihmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMubmV4dFNpYmxpbmc7IH0pLnJlbW92ZUNsYXNzKCdqc3RyZWUtbGFzdCcpO1xuXHRcdFx0XHRcdFx0XHRkYXRhLm5vZGVzLnBhcmVudHNVbnRpbChcIi5qc3RyZWVcIikuYWRkQmFjaygpLnNob3coKVxuXHRcdFx0XHRcdFx0XHRcdC5maWx0ZXIoXCIuanN0cmVlLWNoaWxkcmVuXCIpLmVhY2goZnVuY3Rpb24gKCkgeyAkKHRoaXMpLmNoaWxkcmVuKFwiLmpzdHJlZS1ub2RlOnZpc2libGVcIikuZXEoLTEpLmFkZENsYXNzKFwianN0cmVlLWxhc3RcIik7IH0pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0Lm9uKFwiY2xlYXJfc2VhcmNoLmpzdHJlZVwiLCBmdW5jdGlvbiAoZSwgZGF0YSkge1xuXHRcdFx0XHRcdFx0aWYoZGF0YS5ub2Rlcy5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdFx0JCh0aGlzKS5maW5kKFwiLmpzdHJlZS1ub2RlXCIpLmNzcyhcImRpc3BsYXlcIixcIlwiKS5maWx0ZXIoJy5qc3RyZWUtbGFzdCcpLmZpbHRlcihmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMubmV4dFNpYmxpbmc7IH0pLnJlbW92ZUNsYXNzKCdqc3RyZWUtbGFzdCcpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0LyoqXG5cdFx0ICogdXNlZCB0byBzZWFyY2ggdGhlIHRyZWUgbm9kZXMgZm9yIGEgZ2l2ZW4gc3RyaW5nXG5cdFx0ICogQG5hbWUgc2VhcmNoKHN0ciBbLCBza2lwX2FzeW5jXSlcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gc3RyIHRoZSBzZWFyY2ggc3RyaW5nXG5cdFx0ICogQHBhcmFtIHtCb29sZWFufSBza2lwX2FzeW5jIGlmIHNldCB0byB0cnVlIHNlcnZlciB3aWxsIG5vdCBiZSBxdWVyaWVkIGV2ZW4gaWYgY29uZmlndXJlZFxuXHRcdCAqIEBwbHVnaW4gc2VhcmNoXG5cdFx0ICogQHRyaWdnZXIgc2VhcmNoLmpzdHJlZVxuXHRcdCAqL1xuXHRcdHRoaXMuc2VhcmNoID0gZnVuY3Rpb24gKHN0ciwgc2tpcF9hc3luYykge1xuXHRcdFx0aWYoc3RyID09PSBmYWxzZSB8fCAkLnRyaW0oc3RyLnRvU3RyaW5nKCkpID09PSBcIlwiKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmNsZWFyX3NlYXJjaCgpO1xuXHRcdFx0fVxuXHRcdFx0c3RyID0gc3RyLnRvU3RyaW5nKCk7XG5cdFx0XHR2YXIgcyA9IHRoaXMuc2V0dGluZ3Muc2VhcmNoLFxuXHRcdFx0XHRhID0gcy5hamF4ID8gcy5hamF4IDogZmFsc2UsXG5cdFx0XHRcdGYgPSBudWxsLFxuXHRcdFx0XHRyID0gW10sXG5cdFx0XHRcdHAgPSBbXSwgaSwgajtcblx0XHRcdGlmKHRoaXMuX2RhdGEuc2VhcmNoLnJlcy5sZW5ndGgpIHtcblx0XHRcdFx0dGhpcy5jbGVhcl9zZWFyY2goKTtcblx0XHRcdH1cblx0XHRcdGlmKCFza2lwX2FzeW5jICYmIGEgIT09IGZhbHNlKSB7XG5cdFx0XHRcdGlmKCQuaXNGdW5jdGlvbihhKSkge1xuXHRcdFx0XHRcdHJldHVybiBhLmNhbGwodGhpcywgc3RyLCAkLnByb3h5KGZ1bmN0aW9uIChkKSB7XG5cdFx0XHRcdFx0XHRcdGlmKGQgJiYgZC5kKSB7IGQgPSBkLmQ7IH1cblx0XHRcdFx0XHRcdFx0dGhpcy5fbG9hZF9ub2RlcyghJC5pc0FycmF5KGQpID8gW10gOiAkLnZha2F0YS5hcnJheV91bmlxdWUoZCksIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLnNlYXJjaChzdHIsIHRydWUpO1xuXHRcdFx0XHRcdFx0XHR9LCB0cnVlKTtcblx0XHRcdFx0XHRcdH0sIHRoaXMpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRhID0gJC5leHRlbmQoe30sIGEpO1xuXHRcdFx0XHRcdGlmKCFhLmRhdGEpIHsgYS5kYXRhID0ge307IH1cblx0XHRcdFx0XHRhLmRhdGEuc3RyID0gc3RyO1xuXHRcdFx0XHRcdHJldHVybiAkLmFqYXgoYSlcblx0XHRcdFx0XHRcdC5mYWlsKCQucHJveHkoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0XHR0aGlzLl9kYXRhLmNvcmUubGFzdF9lcnJvciA9IHsgJ2Vycm9yJyA6ICdhamF4JywgJ3BsdWdpbicgOiAnc2VhcmNoJywgJ2lkJyA6ICdzZWFyY2hfMDEnLCAncmVhc29uJyA6ICdDb3VsZCBub3QgbG9hZCBzZWFyY2ggcGFyZW50cycsICdkYXRhJyA6IEpTT04uc3RyaW5naWZ5KGEpIH07XG5cdFx0XHRcdFx0XHRcdHRoaXMuc2V0dGluZ3MuY29yZS5lcnJvci5jYWxsKHRoaXMsIHRoaXMuX2RhdGEuY29yZS5sYXN0X2Vycm9yKTtcblx0XHRcdFx0XHRcdH0sIHRoaXMpKVxuXHRcdFx0XHRcdFx0LmRvbmUoJC5wcm94eShmdW5jdGlvbiAoZCkge1xuXHRcdFx0XHRcdFx0XHRpZihkICYmIGQuZCkgeyBkID0gZC5kOyB9XG5cdFx0XHRcdFx0XHRcdHRoaXMuX2xvYWRfbm9kZXMoISQuaXNBcnJheShkKSA/IFtdIDogJC52YWthdGEuYXJyYXlfdW5pcXVlKGQpLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5zZWFyY2goc3RyLCB0cnVlKTtcblx0XHRcdFx0XHRcdFx0fSwgdHJ1ZSk7XG5cdFx0XHRcdFx0XHR9LCB0aGlzKSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHRoaXMuX2RhdGEuc2VhcmNoLnN0ciA9IHN0cjtcblx0XHRcdHRoaXMuX2RhdGEuc2VhcmNoLmRvbSA9ICQoKTtcblx0XHRcdHRoaXMuX2RhdGEuc2VhcmNoLnJlcyA9IFtdO1xuXHRcdFx0dGhpcy5fZGF0YS5zZWFyY2gub3BuID0gW107XG5cblx0XHRcdGYgPSBuZXcgJC52YWthdGEuc2VhcmNoKHN0ciwgdHJ1ZSwgeyBjYXNlU2Vuc2l0aXZlIDogcy5jYXNlX3NlbnNpdGl2ZSwgZnV6enkgOiBzLmZ1enp5IH0pO1xuXG5cdFx0XHQkLmVhY2godGhpcy5fbW9kZWwuZGF0YSwgZnVuY3Rpb24gKGksIHYpIHtcblx0XHRcdFx0aWYodi50ZXh0ICYmICggKHMuc2VhcmNoX2NhbGxiYWNrICYmIHMuc2VhcmNoX2NhbGxiYWNrLmNhbGwodGhpcywgc3RyLCB2KSkgfHwgKCFzLnNlYXJjaF9jYWxsYmFjayAmJiBmLnNlYXJjaCh2LnRleHQpLmlzTWF0Y2gpICkgJiYgKCFzLnNlYXJjaF9sZWF2ZXNfb25seSB8fCAodi5zdGF0ZS5sb2FkZWQgJiYgdi5jaGlsZHJlbi5sZW5ndGggPT09IDApKSApIHtcblx0XHRcdFx0XHRyLnB1c2goaSk7XG5cdFx0XHRcdFx0cCA9IHAuY29uY2F0KHYucGFyZW50cyk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdFx0aWYoci5sZW5ndGgpIHtcblx0XHRcdFx0cCA9ICQudmFrYXRhLmFycmF5X3VuaXF1ZShwKTtcblx0XHRcdFx0dGhpcy5fc2VhcmNoX29wZW4ocCk7XG5cdFx0XHRcdHRoaXMuX2RhdGEuc2VhcmNoLmRvbSA9ICQodGhpcy5lbGVtZW50WzBdLnF1ZXJ5U2VsZWN0b3JBbGwoJyMnICsgJC5tYXAociwgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIFwiMDEyMzQ1Njc4OVwiLmluZGV4T2YodlswXSkgIT09IC0xID8gJ1xcXFwzJyArIHZbMF0gKyAnICcgKyB2LnN1YnN0cigxKS5yZXBsYWNlKCQuanN0cmVlLmlkcmVnZXgsJ1xcXFwkJicpIDogdi5yZXBsYWNlKCQuanN0cmVlLmlkcmVnZXgsJ1xcXFwkJicpOyB9KS5qb2luKCcsICMnKSkpO1xuXHRcdFx0XHR0aGlzLl9kYXRhLnNlYXJjaC5yZXMgPSByO1xuXHRcdFx0XHR0aGlzLl9kYXRhLnNlYXJjaC5kb20uY2hpbGRyZW4oXCIuanN0cmVlLWFuY2hvclwiKS5hZGRDbGFzcygnanN0cmVlLXNlYXJjaCcpO1xuXHRcdFx0fVxuXHRcdFx0LyoqXG5cdFx0XHQgKiB0cmlnZ2VyZWQgYWZ0ZXIgc2VhcmNoIGlzIGNvbXBsZXRlXG5cdFx0XHQgKiBAZXZlbnRcblx0XHRcdCAqIEBuYW1lIHNlYXJjaC5qc3RyZWVcblx0XHRcdCAqIEBwYXJhbSB7alF1ZXJ5fSBub2RlcyBhIGpRdWVyeSBjb2xsZWN0aW9uIG9mIG1hdGNoaW5nIG5vZGVzXG5cdFx0XHQgKiBAcGFyYW0ge1N0cmluZ30gc3RyIHRoZSBzZWFyY2ggc3RyaW5nXG5cdFx0XHQgKiBAcGFyYW0ge0FycmF5fSByZXMgYSBjb2xsZWN0aW9uIG9mIG9iamVjdHMgcmVwcmVzZWluZyB0aGUgbWF0Y2hpbmcgbm9kZXNcblx0XHRcdCAqIEBwbHVnaW4gc2VhcmNoXG5cdFx0XHQgKi9cblx0XHRcdHRoaXMudHJpZ2dlcignc2VhcmNoJywgeyBub2RlcyA6IHRoaXMuX2RhdGEuc2VhcmNoLmRvbSwgc3RyIDogc3RyLCByZXMgOiB0aGlzLl9kYXRhLnNlYXJjaC5yZXMgfSk7XG5cdFx0fTtcblx0XHQvKipcblx0XHQgKiB1c2VkIHRvIGNsZWFyIHRoZSBsYXN0IHNlYXJjaCAocmVtb3ZlcyBjbGFzc2VzIGFuZCBzaG93cyBhbGwgbm9kZXMgaWYgZmlsdGVyaW5nIGlzIG9uKVxuXHRcdCAqIEBuYW1lIGNsZWFyX3NlYXJjaCgpXG5cdFx0ICogQHBsdWdpbiBzZWFyY2hcblx0XHQgKiBAdHJpZ2dlciBjbGVhcl9zZWFyY2guanN0cmVlXG5cdFx0ICovXG5cdFx0dGhpcy5jbGVhcl9zZWFyY2ggPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHR0aGlzLl9kYXRhLnNlYXJjaC5kb20uY2hpbGRyZW4oXCIuanN0cmVlLWFuY2hvclwiKS5yZW1vdmVDbGFzcyhcImpzdHJlZS1zZWFyY2hcIik7XG5cdFx0XHRpZih0aGlzLnNldHRpbmdzLnNlYXJjaC5jbG9zZV9vcGVuZWRfb25jbGVhcikge1xuXHRcdFx0XHR0aGlzLmNsb3NlX25vZGUodGhpcy5fZGF0YS5zZWFyY2gub3BuLCAwKTtcblx0XHRcdH1cblx0XHRcdC8qKlxuXHRcdFx0ICogdHJpZ2dlcmVkIGFmdGVyIHNlYXJjaCBpcyBjb21wbGV0ZVxuXHRcdFx0ICogQGV2ZW50XG5cdFx0XHQgKiBAbmFtZSBjbGVhcl9zZWFyY2guanN0cmVlXG5cdFx0XHQgKiBAcGFyYW0ge2pRdWVyeX0gbm9kZXMgYSBqUXVlcnkgY29sbGVjdGlvbiBvZiBtYXRjaGluZyBub2RlcyAodGhlIHJlc3VsdCBmcm9tIHRoZSBsYXN0IHNlYXJjaClcblx0XHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgdGhlIHNlYXJjaCBzdHJpbmcgKHRoZSBsYXN0IHNlYXJjaCBzdHJpbmcpXG5cdFx0XHQgKiBAcGFyYW0ge0FycmF5fSByZXMgYSBjb2xsZWN0aW9uIG9mIG9iamVjdHMgcmVwcmVzZWluZyB0aGUgbWF0Y2hpbmcgbm9kZXMgKHRoZSByZXN1bHQgZnJvbSB0aGUgbGFzdCBzZWFyY2gpXG5cdFx0XHQgKiBAcGx1Z2luIHNlYXJjaFxuXHRcdFx0ICovXG5cdFx0XHR0aGlzLnRyaWdnZXIoJ2NsZWFyX3NlYXJjaCcsIHsgJ25vZGVzJyA6IHRoaXMuX2RhdGEuc2VhcmNoLmRvbSwgc3RyIDogdGhpcy5fZGF0YS5zZWFyY2guc3RyLCByZXMgOiB0aGlzLl9kYXRhLnNlYXJjaC5yZXMgfSk7XG5cdFx0XHR0aGlzLl9kYXRhLnNlYXJjaC5zdHIgPSBcIlwiO1xuXHRcdFx0dGhpcy5fZGF0YS5zZWFyY2gucmVzID0gW107XG5cdFx0XHR0aGlzLl9kYXRhLnNlYXJjaC5vcG4gPSBbXTtcblx0XHRcdHRoaXMuX2RhdGEuc2VhcmNoLmRvbSA9ICQoKTtcblx0XHR9O1xuXHRcdC8qKlxuXHRcdCAqIG9wZW5zIG5vZGVzIHRoYXQgbmVlZCB0byBiZSBvcGVuZWQgdG8gcmV2ZWFsIHRoZSBzZWFyY2ggcmVzdWx0cy4gVXNlZCBvbmx5IGludGVybmFsbHkuXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKiBAbmFtZSBfc2VhcmNoX29wZW4oZClcblx0XHQgKiBAcGFyYW0ge0FycmF5fSBkIGFuIGFycmF5IG9mIG5vZGUgSURzXG5cdFx0ICogQHBsdWdpbiBzZWFyY2hcblx0XHQgKi9cblx0XHR0aGlzLl9zZWFyY2hfb3BlbiA9IGZ1bmN0aW9uIChkKSB7XG5cdFx0XHR2YXIgdCA9IHRoaXM7XG5cdFx0XHQkLmVhY2goZC5jb25jYXQoW10pLCBmdW5jdGlvbiAoaSwgdikge1xuXHRcdFx0XHRpZih2ID09PSBcIiNcIikgeyByZXR1cm4gdHJ1ZTsgfVxuXHRcdFx0XHR0cnkgeyB2ID0gJCgnIycgKyB2LnJlcGxhY2UoJC5qc3RyZWUuaWRyZWdleCwnXFxcXCQmJyksIHQuZWxlbWVudCk7IH0gY2F0Y2goaWdub3JlKSB7IH1cblx0XHRcdFx0aWYodiAmJiB2Lmxlbmd0aCkge1xuXHRcdFx0XHRcdGlmKHQuaXNfY2xvc2VkKHYpKSB7XG5cdFx0XHRcdFx0XHR0Ll9kYXRhLnNlYXJjaC5vcG4ucHVzaCh2WzBdLmlkKTtcblx0XHRcdFx0XHRcdHQub3Blbl9ub2RlKHYsIGZ1bmN0aW9uICgpIHsgdC5fc2VhcmNoX29wZW4oZCk7IH0sIDApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fTtcblx0fTtcblxuXHQvLyBoZWxwZXJzXG5cdChmdW5jdGlvbiAoJCkge1xuXHRcdC8vIGZyb20gaHR0cDovL2tpcm8ubWUvcHJvamVjdHMvZnVzZS5odG1sXG5cdFx0JC52YWthdGEuc2VhcmNoID0gZnVuY3Rpb24ocGF0dGVybiwgdHh0LCBvcHRpb25zKSB7XG5cdFx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblx0XHRcdGlmKG9wdGlvbnMuZnV6enkgIT09IGZhbHNlKSB7XG5cdFx0XHRcdG9wdGlvbnMuZnV6enkgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0cGF0dGVybiA9IG9wdGlvbnMuY2FzZVNlbnNpdGl2ZSA/IHBhdHRlcm4gOiBwYXR0ZXJuLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHR2YXIgTUFUQ0hfTE9DQVRJT05cdD0gb3B0aW9ucy5sb2NhdGlvbiB8fCAwLFxuXHRcdFx0XHRNQVRDSF9ESVNUQU5DRVx0PSBvcHRpb25zLmRpc3RhbmNlIHx8IDEwMCxcblx0XHRcdFx0TUFUQ0hfVEhSRVNIT0xEXHQ9IG9wdGlvbnMudGhyZXNob2xkIHx8IDAuNixcblx0XHRcdFx0cGF0dGVybkxlbiA9IHBhdHRlcm4ubGVuZ3RoLFxuXHRcdFx0XHRtYXRjaG1hc2ssIHBhdHRlcm5fYWxwaGFiZXQsIG1hdGNoX2JpdGFwU2NvcmUsIHNlYXJjaDtcblx0XHRcdGlmKHBhdHRlcm5MZW4gPiAzMikge1xuXHRcdFx0XHRvcHRpb25zLmZ1enp5ID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHRpZihvcHRpb25zLmZ1enp5KSB7XG5cdFx0XHRcdG1hdGNobWFzayA9IDEgPDwgKHBhdHRlcm5MZW4gLSAxKTtcblx0XHRcdFx0cGF0dGVybl9hbHBoYWJldCA9IChmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0dmFyIG1hc2sgPSB7fSxcblx0XHRcdFx0XHRcdGkgPSAwO1xuXHRcdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBwYXR0ZXJuTGVuOyBpKyspIHtcblx0XHRcdFx0XHRcdG1hc2tbcGF0dGVybi5jaGFyQXQoaSldID0gMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IHBhdHRlcm5MZW47IGkrKykge1xuXHRcdFx0XHRcdFx0bWFza1twYXR0ZXJuLmNoYXJBdChpKV0gfD0gMSA8PCAocGF0dGVybkxlbiAtIGkgLSAxKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIG1hc2s7XG5cdFx0XHRcdH0oKSk7XG5cdFx0XHRcdG1hdGNoX2JpdGFwU2NvcmUgPSBmdW5jdGlvbiAoZSwgeCkge1xuXHRcdFx0XHRcdHZhciBhY2N1cmFjeSA9IGUgLyBwYXR0ZXJuTGVuLFxuXHRcdFx0XHRcdFx0cHJveGltaXR5ID0gTWF0aC5hYnMoTUFUQ0hfTE9DQVRJT04gLSB4KTtcblx0XHRcdFx0XHRpZighTUFUQ0hfRElTVEFOQ0UpIHtcblx0XHRcdFx0XHRcdHJldHVybiBwcm94aW1pdHkgPyAxLjAgOiBhY2N1cmFjeTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIGFjY3VyYWN5ICsgKHByb3hpbWl0eSAvIE1BVENIX0RJU1RBTkNFKTtcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHRcdHNlYXJjaCA9IGZ1bmN0aW9uICh0ZXh0KSB7XG5cdFx0XHRcdHRleHQgPSBvcHRpb25zLmNhc2VTZW5zaXRpdmUgPyB0ZXh0IDogdGV4dC50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHRpZihwYXR0ZXJuID09PSB0ZXh0IHx8IHRleHQuaW5kZXhPZihwYXR0ZXJuKSAhPT0gLTEpIHtcblx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0aXNNYXRjaDogdHJ1ZSxcblx0XHRcdFx0XHRcdHNjb3JlOiAwXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZighb3B0aW9ucy5mdXp6eSkge1xuXHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHRpc01hdGNoOiBmYWxzZSxcblx0XHRcdFx0XHRcdHNjb3JlOiAxXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fVxuXHRcdFx0XHR2YXIgaSwgaixcblx0XHRcdFx0XHR0ZXh0TGVuID0gdGV4dC5sZW5ndGgsXG5cdFx0XHRcdFx0c2NvcmVUaHJlc2hvbGQgPSBNQVRDSF9USFJFU0hPTEQsXG5cdFx0XHRcdFx0YmVzdExvYyA9IHRleHQuaW5kZXhPZihwYXR0ZXJuLCBNQVRDSF9MT0NBVElPTiksXG5cdFx0XHRcdFx0YmluTWluLCBiaW5NaWQsXG5cdFx0XHRcdFx0YmluTWF4ID0gcGF0dGVybkxlbiArIHRleHRMZW4sXG5cdFx0XHRcdFx0bGFzdFJkLCBzdGFydCwgZmluaXNoLCByZCwgY2hhck1hdGNoLFxuXHRcdFx0XHRcdHNjb3JlID0gMSxcblx0XHRcdFx0XHRsb2NhdGlvbnMgPSBbXTtcblx0XHRcdFx0aWYgKGJlc3RMb2MgIT09IC0xKSB7XG5cdFx0XHRcdFx0c2NvcmVUaHJlc2hvbGQgPSBNYXRoLm1pbihtYXRjaF9iaXRhcFNjb3JlKDAsIGJlc3RMb2MpLCBzY29yZVRocmVzaG9sZCk7XG5cdFx0XHRcdFx0YmVzdExvYyA9IHRleHQubGFzdEluZGV4T2YocGF0dGVybiwgTUFUQ0hfTE9DQVRJT04gKyBwYXR0ZXJuTGVuKTtcblx0XHRcdFx0XHRpZiAoYmVzdExvYyAhPT0gLTEpIHtcblx0XHRcdFx0XHRcdHNjb3JlVGhyZXNob2xkID0gTWF0aC5taW4obWF0Y2hfYml0YXBTY29yZSgwLCBiZXN0TG9jKSwgc2NvcmVUaHJlc2hvbGQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRiZXN0TG9jID0gLTE7XG5cdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBwYXR0ZXJuTGVuOyBpKyspIHtcblx0XHRcdFx0XHRiaW5NaW4gPSAwO1xuXHRcdFx0XHRcdGJpbk1pZCA9IGJpbk1heDtcblx0XHRcdFx0XHR3aGlsZSAoYmluTWluIDwgYmluTWlkKSB7XG5cdFx0XHRcdFx0XHRpZiAobWF0Y2hfYml0YXBTY29yZShpLCBNQVRDSF9MT0NBVElPTiArIGJpbk1pZCkgPD0gc2NvcmVUaHJlc2hvbGQpIHtcblx0XHRcdFx0XHRcdFx0YmluTWluID0gYmluTWlkO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0YmluTWF4ID0gYmluTWlkO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0YmluTWlkID0gTWF0aC5mbG9vcigoYmluTWF4IC0gYmluTWluKSAvIDIgKyBiaW5NaW4pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRiaW5NYXggPSBiaW5NaWQ7XG5cdFx0XHRcdFx0c3RhcnQgPSBNYXRoLm1heCgxLCBNQVRDSF9MT0NBVElPTiAtIGJpbk1pZCArIDEpO1xuXHRcdFx0XHRcdGZpbmlzaCA9IE1hdGgubWluKE1BVENIX0xPQ0FUSU9OICsgYmluTWlkLCB0ZXh0TGVuKSArIHBhdHRlcm5MZW47XG5cdFx0XHRcdFx0cmQgPSBuZXcgQXJyYXkoZmluaXNoICsgMik7XG5cdFx0XHRcdFx0cmRbZmluaXNoICsgMV0gPSAoMSA8PCBpKSAtIDE7XG5cdFx0XHRcdFx0Zm9yIChqID0gZmluaXNoOyBqID49IHN0YXJ0OyBqLS0pIHtcblx0XHRcdFx0XHRcdGNoYXJNYXRjaCA9IHBhdHRlcm5fYWxwaGFiZXRbdGV4dC5jaGFyQXQoaiAtIDEpXTtcblx0XHRcdFx0XHRcdGlmIChpID09PSAwKSB7XG5cdFx0XHRcdFx0XHRcdHJkW2pdID0gKChyZFtqICsgMV0gPDwgMSkgfCAxKSAmIGNoYXJNYXRjaDtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHJkW2pdID0gKChyZFtqICsgMV0gPDwgMSkgfCAxKSAmIGNoYXJNYXRjaCB8ICgoKGxhc3RSZFtqICsgMV0gfCBsYXN0UmRbal0pIDw8IDEpIHwgMSkgfCBsYXN0UmRbaiArIDFdO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKHJkW2pdICYgbWF0Y2htYXNrKSB7XG5cdFx0XHRcdFx0XHRcdHNjb3JlID0gbWF0Y2hfYml0YXBTY29yZShpLCBqIC0gMSk7XG5cdFx0XHRcdFx0XHRcdGlmIChzY29yZSA8PSBzY29yZVRocmVzaG9sZCkge1xuXHRcdFx0XHRcdFx0XHRcdHNjb3JlVGhyZXNob2xkID0gc2NvcmU7XG5cdFx0XHRcdFx0XHRcdFx0YmVzdExvYyA9IGogLSAxO1xuXHRcdFx0XHRcdFx0XHRcdGxvY2F0aW9ucy5wdXNoKGJlc3RMb2MpO1xuXHRcdFx0XHRcdFx0XHRcdGlmIChiZXN0TG9jID4gTUFUQ0hfTE9DQVRJT04pIHtcblx0XHRcdFx0XHRcdFx0XHRcdHN0YXJ0ID0gTWF0aC5tYXgoMSwgMiAqIE1BVENIX0xPQ0FUSU9OIC0gYmVzdExvYyk7XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAobWF0Y2hfYml0YXBTY29yZShpICsgMSwgTUFUQ0hfTE9DQVRJT04pID4gc2NvcmVUaHJlc2hvbGQpIHtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRsYXN0UmQgPSByZDtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdGlzTWF0Y2g6IGJlc3RMb2MgPj0gMCxcblx0XHRcdFx0XHRzY29yZTogc2NvcmVcblx0XHRcdFx0fTtcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gdHh0ID09PSB0cnVlID8geyAnc2VhcmNoJyA6IHNlYXJjaCB9IDogc2VhcmNoKHR4dCk7XG5cdFx0fTtcblx0fSgkKSk7XG5cblx0Ly8gaW5jbHVkZSB0aGUgc2VhcmNoIHBsdWdpbiBieSBkZWZhdWx0XG5cdC8vICQuanN0cmVlLmRlZmF1bHRzLnBsdWdpbnMucHVzaChcInNlYXJjaFwiKTtcblxuLyoqXG4gKiAjIyMgU29ydCBwbHVnaW5cbiAqXG4gKiBBdXRtYXRpY2FsbHkgc29ydHMgYWxsIHNpYmxpbmdzIGluIHRoZSB0cmVlIGFjY29yZGluZyB0byBhIHNvcnRpbmcgZnVuY3Rpb24uXG4gKi9cblxuXHQvKipcblx0ICogdGhlIHNldHRpbmdzIGZ1bmN0aW9uIHVzZWQgdG8gc29ydCB0aGUgbm9kZXMuXG5cdCAqIEl0IGlzIGV4ZWN1dGVkIGluIHRoZSB0cmVlJ3MgY29udGV4dCwgYWNjZXB0cyB0d28gbm9kZXMgYXMgYXJndW1lbnRzIGFuZCBzaG91bGQgcmV0dXJuIGAxYCBvciBgLTFgLlxuXHQgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5zb3J0XG5cdCAqIEBwbHVnaW4gc29ydFxuXHQgKi9cblx0JC5qc3RyZWUuZGVmYXVsdHMuc29ydCA9IGZ1bmN0aW9uIChhLCBiKSB7XG5cdFx0Ly9yZXR1cm4gdGhpcy5nZXRfdHlwZShhKSA9PT0gdGhpcy5nZXRfdHlwZShiKSA/ICh0aGlzLmdldF90ZXh0KGEpID4gdGhpcy5nZXRfdGV4dChiKSA/IDEgOiAtMSkgOiB0aGlzLmdldF90eXBlKGEpID49IHRoaXMuZ2V0X3R5cGUoYik7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0X3RleHQoYSkgPiB0aGlzLmdldF90ZXh0KGIpID8gMSA6IC0xO1xuXHR9O1xuXHQkLmpzdHJlZS5wbHVnaW5zLnNvcnQgPSBmdW5jdGlvbiAob3B0aW9ucywgcGFyZW50KSB7XG5cdFx0dGhpcy5iaW5kID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0cGFyZW50LmJpbmQuY2FsbCh0aGlzKTtcblx0XHRcdHRoaXMuZWxlbWVudFxuXHRcdFx0XHQub24oXCJtb2RlbC5qc3RyZWVcIiwgJC5wcm94eShmdW5jdGlvbiAoZSwgZGF0YSkge1xuXHRcdFx0XHRcdFx0dGhpcy5zb3J0KGRhdGEucGFyZW50LCB0cnVlKTtcblx0XHRcdFx0XHR9LCB0aGlzKSlcblx0XHRcdFx0Lm9uKFwicmVuYW1lX25vZGUuanN0cmVlIGNyZWF0ZV9ub2RlLmpzdHJlZVwiLCAkLnByb3h5KGZ1bmN0aW9uIChlLCBkYXRhKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnNvcnQoZGF0YS5wYXJlbnQgfHwgZGF0YS5ub2RlLnBhcmVudCwgZmFsc2UpO1xuXHRcdFx0XHRcdFx0dGhpcy5yZWRyYXdfbm9kZShkYXRhLnBhcmVudCB8fCBkYXRhLm5vZGUucGFyZW50LCB0cnVlKTtcblx0XHRcdFx0XHR9LCB0aGlzKSlcblx0XHRcdFx0Lm9uKFwibW92ZV9ub2RlLmpzdHJlZSBjb3B5X25vZGUuanN0cmVlXCIsICQucHJveHkoZnVuY3Rpb24gKGUsIGRhdGEpIHtcblx0XHRcdFx0XHRcdHRoaXMuc29ydChkYXRhLnBhcmVudCwgZmFsc2UpO1xuXHRcdFx0XHRcdFx0dGhpcy5yZWRyYXdfbm9kZShkYXRhLnBhcmVudCwgdHJ1ZSk7XG5cdFx0XHRcdFx0fSwgdGhpcykpO1xuXHRcdH07XG5cdFx0LyoqXG5cdFx0ICogdXNlZCB0byBzb3J0IGEgbm9kZSdzIGNoaWxkcmVuXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKiBAbmFtZSBzb3J0KG9iaiBbLCBkZWVwXSlcblx0XHQgKiBAcGFyYW0gIHttaXhlZH0gb2JqIHRoZSBub2RlXG5cdFx0ICogQHBhcmFtIHtCb29sZWFufSBkZWVwIGlmIHNldCB0byBgdHJ1ZWAgbm9kZXMgYXJlIHNvcnRlZCByZWN1cnNpdmVseS5cblx0XHQgKiBAcGx1Z2luIHNvcnRcblx0XHQgKiBAdHJpZ2dlciBzZWFyY2guanN0cmVlXG5cdFx0ICovXG5cdFx0dGhpcy5zb3J0ID0gZnVuY3Rpb24gKG9iaiwgZGVlcCkge1xuXHRcdFx0dmFyIGksIGo7XG5cdFx0XHRvYmogPSB0aGlzLmdldF9ub2RlKG9iaik7XG5cdFx0XHRpZihvYmogJiYgb2JqLmNoaWxkcmVuICYmIG9iai5jaGlsZHJlbi5sZW5ndGgpIHtcblx0XHRcdFx0b2JqLmNoaWxkcmVuLnNvcnQoJC5wcm94eSh0aGlzLnNldHRpbmdzLnNvcnQsIHRoaXMpKTtcblx0XHRcdFx0aWYoZGVlcCkge1xuXHRcdFx0XHRcdGZvcihpID0gMCwgaiA9IG9iai5jaGlsZHJlbl9kLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuXHRcdFx0XHRcdFx0dGhpcy5zb3J0KG9iai5jaGlsZHJlbl9kW2ldLCBmYWxzZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fTtcblxuXHQvLyBpbmNsdWRlIHRoZSBzb3J0IHBsdWdpbiBieSBkZWZhdWx0XG5cdC8vICQuanN0cmVlLmRlZmF1bHRzLnBsdWdpbnMucHVzaChcInNvcnRcIik7XG5cbi8qKlxuICogIyMjIFN0YXRlIHBsdWdpblxuICpcbiAqIFNhdmVzIHRoZSBzdGF0ZSBvZiB0aGUgdHJlZSAoc2VsZWN0ZWQgbm9kZXMsIG9wZW5lZCBub2Rlcykgb24gdGhlIHVzZXIncyBjb21wdXRlciB1c2luZyBhdmFpbGFibGUgb3B0aW9ucyAobG9jYWxTdG9yYWdlLCBjb29raWVzLCBldGMpXG4gKi9cblxuXHR2YXIgdG8gPSBmYWxzZTtcblx0LyoqXG5cdCAqIHN0b3JlcyBhbGwgZGVmYXVsdHMgZm9yIHRoZSBzdGF0ZSBwbHVnaW5cblx0ICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuc3RhdGVcblx0ICogQHBsdWdpbiBzdGF0ZVxuXHQgKi9cblx0JC5qc3RyZWUuZGVmYXVsdHMuc3RhdGUgPSB7XG5cdFx0LyoqXG5cdFx0ICogQSBzdHJpbmcgZm9yIHRoZSBrZXkgdG8gdXNlIHdoZW4gc2F2aW5nIHRoZSBjdXJyZW50IHRyZWUgKGNoYW5nZSBpZiB1c2luZyBtdWx0aXBsZSB0cmVlcyBpbiB5b3VyIHByb2plY3QpLiBEZWZhdWx0cyB0byBganN0cmVlYC5cblx0XHQgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5zdGF0ZS5rZXlcblx0XHQgKiBAcGx1Z2luIHN0YXRlXG5cdFx0ICovXG5cdFx0a2V5XHRcdDogJ2pzdHJlZScsXG5cdFx0LyoqXG5cdFx0ICogQSBzcGFjZSBzZXBhcmF0ZWQgbGlzdCBvZiBldmVudHMgdGhhdCB0cmlnZ2VyIGEgc3RhdGUgc2F2ZS4gRGVmYXVsdHMgdG8gYGNoYW5nZWQuanN0cmVlIG9wZW5fbm9kZS5qc3RyZWUgY2xvc2Vfbm9kZS5qc3RyZWVgLlxuXHRcdCAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLnN0YXRlLmV2ZW50c1xuXHRcdCAqIEBwbHVnaW4gc3RhdGVcblx0XHQgKi9cblx0XHRldmVudHNcdDogJ2NoYW5nZWQuanN0cmVlIG9wZW5fbm9kZS5qc3RyZWUgY2xvc2Vfbm9kZS5qc3RyZWUnLFxuXHRcdC8qKlxuXHRcdCAqIFRpbWUgaW4gbWlsbGlzZWNvbmRzIGFmdGVyIHdoaWNoIHRoZSBzdGF0ZSB3aWxsIGV4cGlyZS4gRGVmYXVsdHMgdG8gJ2ZhbHNlJyBtZWFuaW5nIC0gbm8gZXhwaXJlLlxuXHRcdCAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLnN0YXRlLnR0bFxuXHRcdCAqIEBwbHVnaW4gc3RhdGVcblx0XHQgKi9cblx0XHR0dGxcdFx0OiBmYWxzZSxcblx0XHQvKipcblx0XHQgKiBBIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBleGVjdXRlZCBwcmlvciB0byByZXN0b3Jpbmcgc3RhdGUgd2l0aCBvbmUgYXJndW1lbnQgLSB0aGUgc3RhdGUgb2JqZWN0LiBDYW4gYmUgdXNlZCB0byBjbGVhciB1bndhbnRlZCBwYXJ0cyBvZiB0aGUgc3RhdGUuXG5cdFx0ICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuc3RhdGUuZmlsdGVyXG5cdFx0ICogQHBsdWdpbiBzdGF0ZVxuXHRcdCAqL1xuXHRcdGZpbHRlclx0OiBmYWxzZVxuXHR9O1xuXHQkLmpzdHJlZS5wbHVnaW5zLnN0YXRlID0gZnVuY3Rpb24gKG9wdGlvbnMsIHBhcmVudCkge1xuXHRcdHRoaXMuYmluZCA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHBhcmVudC5iaW5kLmNhbGwodGhpcyk7XG5cdFx0XHR2YXIgYmluZCA9ICQucHJveHkoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHR0aGlzLmVsZW1lbnQub24odGhpcy5zZXR0aW5ncy5zdGF0ZS5ldmVudHMsICQucHJveHkoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdGlmKHRvKSB7IGNsZWFyVGltZW91dCh0byk7IH1cblx0XHRcdFx0XHR0byA9IHNldFRpbWVvdXQoJC5wcm94eShmdW5jdGlvbiAoKSB7IHRoaXMuc2F2ZV9zdGF0ZSgpOyB9LCB0aGlzKSwgMTAwKTtcblx0XHRcdFx0fSwgdGhpcykpO1xuXHRcdFx0fSwgdGhpcyk7XG5cdFx0XHR0aGlzLmVsZW1lbnRcblx0XHRcdFx0Lm9uKFwicmVhZHkuanN0cmVlXCIsICQucHJveHkoZnVuY3Rpb24gKGUsIGRhdGEpIHtcblx0XHRcdFx0XHRcdHRoaXMuZWxlbWVudC5vbmUoXCJyZXN0b3JlX3N0YXRlLmpzdHJlZVwiLCBiaW5kKTtcblx0XHRcdFx0XHRcdGlmKCF0aGlzLnJlc3RvcmVfc3RhdGUoKSkgeyBiaW5kKCk7IH1cblx0XHRcdFx0XHR9LCB0aGlzKSk7XG5cdFx0fTtcblx0XHQvKipcblx0XHQgKiBzYXZlIHRoZSBzdGF0ZVxuXHRcdCAqIEBuYW1lIHNhdmVfc3RhdGUoKVxuXHRcdCAqIEBwbHVnaW4gc3RhdGVcblx0XHQgKi9cblx0XHR0aGlzLnNhdmVfc3RhdGUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgc3QgPSB7ICdzdGF0ZScgOiB0aGlzLmdldF9zdGF0ZSgpLCAndHRsJyA6IHRoaXMuc2V0dGluZ3Muc3RhdGUudHRsLCAnc2VjJyA6ICsobmV3IERhdGUoKSkgfTtcblx0XHRcdCQudmFrYXRhLnN0b3JhZ2Uuc2V0KHRoaXMuc2V0dGluZ3Muc3RhdGUua2V5LCBKU09OLnN0cmluZ2lmeShzdCkpO1xuXHRcdH07XG5cdFx0LyoqXG5cdFx0ICogcmVzdG9yZSB0aGUgc3RhdGUgZnJvbSB0aGUgdXNlcidzIGNvbXB1dGVyXG5cdFx0ICogQG5hbWUgcmVzdG9yZV9zdGF0ZSgpXG5cdFx0ICogQHBsdWdpbiBzdGF0ZVxuXHRcdCAqL1xuXHRcdHRoaXMucmVzdG9yZV9zdGF0ZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBrID0gJC52YWthdGEuc3RvcmFnZS5nZXQodGhpcy5zZXR0aW5ncy5zdGF0ZS5rZXkpO1xuXHRcdFx0aWYoISFrKSB7IHRyeSB7IGsgPSBKU09OLnBhcnNlKGspOyB9IGNhdGNoKGV4KSB7IHJldHVybiBmYWxzZTsgfSB9XG5cdFx0XHRpZighIWsgJiYgay50dGwgJiYgay5zZWMgJiYgKyhuZXcgRGF0ZSgpKSAtIGsuc2VjID4gay50dGwpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0XHRpZighIWsgJiYgay5zdGF0ZSkgeyBrID0gay5zdGF0ZTsgfVxuXHRcdFx0aWYoISFrICYmICQuaXNGdW5jdGlvbih0aGlzLnNldHRpbmdzLnN0YXRlLmZpbHRlcikpIHsgayA9IHRoaXMuc2V0dGluZ3Muc3RhdGUuZmlsdGVyLmNhbGwodGhpcywgayk7IH1cblx0XHRcdGlmKCEhaykge1xuXHRcdFx0XHR0aGlzLmVsZW1lbnQub25lKFwic2V0X3N0YXRlLmpzdHJlZVwiLCBmdW5jdGlvbiAoZSwgZGF0YSkgeyBkYXRhLmluc3RhbmNlLnRyaWdnZXIoJ3Jlc3RvcmVfc3RhdGUnLCB7ICdzdGF0ZScgOiAkLmV4dGVuZCh0cnVlLCB7fSwgaykgfSk7IH0pO1xuXHRcdFx0XHR0aGlzLnNldF9zdGF0ZShrKTtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fTtcblx0XHQvKipcblx0XHQgKiBjbGVhciB0aGUgc3RhdGUgb24gdGhlIHVzZXIncyBjb21wdXRlclxuXHRcdCAqIEBuYW1lIGNsZWFyX3N0YXRlKClcblx0XHQgKiBAcGx1Z2luIHN0YXRlXG5cdFx0ICovXG5cdFx0dGhpcy5jbGVhcl9zdGF0ZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiAkLnZha2F0YS5zdG9yYWdlLmRlbCh0aGlzLnNldHRpbmdzLnN0YXRlLmtleSk7XG5cdFx0fTtcblx0fTtcblxuXHQoZnVuY3Rpb24gKCQsIHVuZGVmaW5lZCkge1xuXHRcdCQudmFrYXRhLnN0b3JhZ2UgPSB7XG5cdFx0XHQvLyBzaW1wbHkgc3BlY2lmeWluZyB0aGUgZnVuY3Rpb25zIGluIEZGIHRocm93cyBhbiBlcnJvclxuXHRcdFx0c2V0IDogZnVuY3Rpb24gKGtleSwgdmFsKSB7IHJldHVybiB3aW5kb3cubG9jYWxTdG9yYWdlLnNldEl0ZW0oa2V5LCB2YWwpOyB9LFxuXHRcdFx0Z2V0IDogZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gd2luZG93LmxvY2FsU3RvcmFnZS5nZXRJdGVtKGtleSk7IH0sXG5cdFx0XHRkZWwgOiBmdW5jdGlvbiAoa2V5KSB7IHJldHVybiB3aW5kb3cubG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oa2V5KTsgfVxuXHRcdH07XG5cdH0oJCkpO1xuXG5cdC8vIGluY2x1ZGUgdGhlIHN0YXRlIHBsdWdpbiBieSBkZWZhdWx0XG5cdC8vICQuanN0cmVlLmRlZmF1bHRzLnBsdWdpbnMucHVzaChcInN0YXRlXCIpO1xuXG4vKipcbiAqICMjIyBUeXBlcyBwbHVnaW5cbiAqXG4gKiBNYWtlcyBpdCBwb3NzaWJsZSB0byBhZGQgcHJlZGVmaW5lZCB0eXBlcyBmb3IgZ3JvdXBzIG9mIG5vZGVzLCB3aGljaCBtYWtlIGl0IHBvc3NpYmxlIHRvIGVhc2lseSBjb250cm9sIG5lc3RpbmcgcnVsZXMgYW5kIGljb24gZm9yIGVhY2ggZ3JvdXAuXG4gKi9cblxuXHQvKipcblx0ICogQW4gb2JqZWN0IHN0b3JpbmcgYWxsIHR5cGVzIGFzIGtleSB2YWx1ZSBwYWlycywgd2hlcmUgdGhlIGtleSBpcyB0aGUgdHlwZSBuYW1lIGFuZCB0aGUgdmFsdWUgaXMgYW4gb2JqZWN0IHRoYXQgY291bGQgY29udGFpbiBmb2xsb3dpbmcga2V5cyAoYWxsIG9wdGlvbmFsKS5cblx0ICogXG5cdCAqICogYG1heF9jaGlsZHJlbmAgdGhlIG1heGltdW0gbnVtYmVyIG9mIGltbWVkaWF0ZSBjaGlsZHJlbiB0aGlzIG5vZGUgdHlwZSBjYW4gaGF2ZS4gRG8gbm90IHNwZWNpZnkgb3Igc2V0IHRvIGAtMWAgZm9yIHVubGltaXRlZC5cblx0ICogKiBgbWF4X2RlcHRoYCB0aGUgbWF4aW11bSBudW1iZXIgb2YgbmVzdGluZyB0aGlzIG5vZGUgdHlwZSBjYW4gaGF2ZS4gQSB2YWx1ZSBvZiBgMWAgd291bGQgbWVhbiB0aGF0IHRoZSBub2RlIGNhbiBoYXZlIGNoaWxkcmVuLCBidXQgbm8gZ3JhbmRjaGlsZHJlbi4gRG8gbm90IHNwZWNpZnkgb3Igc2V0IHRvIGAtMWAgZm9yIHVubGltaXRlZC5cblx0ICogKiBgdmFsaWRfY2hpbGRyZW5gIGFuIGFycmF5IG9mIG5vZGUgdHlwZSBzdHJpbmdzLCB0aGF0IG5vZGVzIG9mIHRoaXMgdHlwZSBjYW4gaGF2ZSBhcyBjaGlsZHJlbi4gRG8gbm90IHNwZWNpZnkgb3Igc2V0IHRvIGAtMWAgZm9yIG5vIGxpbWl0cy5cblx0ICogKiBgaWNvbmAgYSBzdHJpbmcgLSBjYW4gYmUgYSBwYXRoIHRvIGFuIGljb24gb3IgYSBjbGFzc05hbWUsIGlmIHVzaW5nIGFuIGltYWdlIHRoYXQgaXMgaW4gdGhlIGN1cnJlbnQgZGlyZWN0b3J5IHVzZSBhIGAuL2AgcHJlZml4LCBvdGhlcndpc2UgaXQgd2lsbCBiZSBkZXRlY3RlZCBhcyBhIGNsYXNzLiBPbWl0IHRvIHVzZSB0aGUgZGVmYXVsdCBpY29uIGZyb20geW91ciB0aGVtZS5cblx0ICpcblx0ICogVGhlcmUgYXJlIHR3byBwcmVkZWZpbmVkIHR5cGVzOlxuXHQgKiBcblx0ICogKiBgI2AgcmVwcmVzZW50cyB0aGUgcm9vdCBvZiB0aGUgdHJlZSwgZm9yIGV4YW1wbGUgYG1heF9jaGlsZHJlbmAgd291bGQgY29udHJvbCB0aGUgbWF4aW11bSBudW1iZXIgb2Ygcm9vdCBub2Rlcy5cblx0ICogKiBgZGVmYXVsdGAgcmVwcmVzZW50cyB0aGUgZGVmYXVsdCBub2RlIC0gYW55IHNldHRpbmdzIGhlcmUgd2lsbCBiZSBhcHBsaWVkIHRvIGFsbCBub2RlcyB0aGF0IGRvIG5vdCBoYXZlIGEgdHlwZSBzcGVjaWZpZWQuXG5cdCAqIFxuXHQgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy50eXBlc1xuXHQgKiBAcGx1Z2luIHR5cGVzXG5cdCAqL1xuXHQkLmpzdHJlZS5kZWZhdWx0cy50eXBlcyA9IHtcblx0XHQnIycgOiB7fSxcblx0XHQnZGVmYXVsdCcgOiB7fVxuXHR9O1xuXG5cdCQuanN0cmVlLnBsdWdpbnMudHlwZXMgPSBmdW5jdGlvbiAob3B0aW9ucywgcGFyZW50KSB7XG5cdFx0dGhpcy5pbml0ID0gZnVuY3Rpb24gKGVsLCBvcHRpb25zKSB7XG5cdFx0XHR2YXIgaSwgajtcblx0XHRcdGlmKG9wdGlvbnMgJiYgb3B0aW9ucy50eXBlcyAmJiBvcHRpb25zLnR5cGVzWydkZWZhdWx0J10pIHtcblx0XHRcdFx0Zm9yKGkgaW4gb3B0aW9ucy50eXBlcykge1xuXHRcdFx0XHRcdGlmKGkgIT09IFwiZGVmYXVsdFwiICYmIGkgIT09IFwiI1wiICYmIG9wdGlvbnMudHlwZXMuaGFzT3duUHJvcGVydHkoaSkpIHtcblx0XHRcdFx0XHRcdGZvcihqIGluIG9wdGlvbnMudHlwZXNbJ2RlZmF1bHQnXSkge1xuXHRcdFx0XHRcdFx0XHRpZihvcHRpb25zLnR5cGVzWydkZWZhdWx0J10uaGFzT3duUHJvcGVydHkoaikgJiYgb3B0aW9ucy50eXBlc1tpXVtqXSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHRcdFx0b3B0aW9ucy50eXBlc1tpXVtqXSA9IG9wdGlvbnMudHlwZXNbJ2RlZmF1bHQnXVtqXTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cGFyZW50LmluaXQuY2FsbCh0aGlzLCBlbCwgb3B0aW9ucyk7XG5cdFx0XHR0aGlzLl9tb2RlbC5kYXRhWycjJ10udHlwZSA9ICcjJztcblx0XHR9O1xuXHRcdHRoaXMucmVmcmVzaCA9IGZ1bmN0aW9uIChza2lwX2xvYWRpbmcsIGZvcmdldF9zdGF0ZSkge1xuXHRcdFx0cGFyZW50LnJlZnJlc2guY2FsbCh0aGlzLCBza2lwX2xvYWRpbmcsIGZvcmdldF9zdGF0ZSk7XG5cdFx0XHR0aGlzLl9tb2RlbC5kYXRhWycjJ10udHlwZSA9ICcjJztcblx0XHR9O1xuXHRcdHRoaXMuYmluZCA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHRoaXMuZWxlbWVudFxuXHRcdFx0XHQub24oJ21vZGVsLmpzdHJlZScsICQucHJveHkoZnVuY3Rpb24gKGUsIGRhdGEpIHtcblx0XHRcdFx0XHRcdHZhciBtID0gdGhpcy5fbW9kZWwuZGF0YSxcblx0XHRcdFx0XHRcdFx0ZHBjID0gZGF0YS5ub2Rlcyxcblx0XHRcdFx0XHRcdFx0dCA9IHRoaXMuc2V0dGluZ3MudHlwZXMsXG5cdFx0XHRcdFx0XHRcdGksIGosIGMgPSAnZGVmYXVsdCc7XG5cdFx0XHRcdFx0XHRmb3IoaSA9IDAsIGogPSBkcGMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdGMgPSAnZGVmYXVsdCc7XG5cdFx0XHRcdFx0XHRcdGlmKG1bZHBjW2ldXS5vcmlnaW5hbCAmJiBtW2RwY1tpXV0ub3JpZ2luYWwudHlwZSAmJiB0W21bZHBjW2ldXS5vcmlnaW5hbC50eXBlXSkge1xuXHRcdFx0XHRcdFx0XHRcdGMgPSBtW2RwY1tpXV0ub3JpZ2luYWwudHlwZTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRpZihtW2RwY1tpXV0uZGF0YSAmJiBtW2RwY1tpXV0uZGF0YS5qc3RyZWUgJiYgbVtkcGNbaV1dLmRhdGEuanN0cmVlLnR5cGUgJiYgdFttW2RwY1tpXV0uZGF0YS5qc3RyZWUudHlwZV0pIHtcblx0XHRcdFx0XHRcdFx0XHRjID0gbVtkcGNbaV1dLmRhdGEuanN0cmVlLnR5cGU7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0bVtkcGNbaV1dLnR5cGUgPSBjO1xuXHRcdFx0XHRcdFx0XHRpZihtW2RwY1tpXV0uaWNvbiA9PT0gdHJ1ZSAmJiB0W2NdLmljb24gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdFx0XHRcdG1bZHBjW2ldXS5pY29uID0gdFtjXS5pY29uO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRtWycjJ10udHlwZSA9ICcjJztcblx0XHRcdFx0XHR9LCB0aGlzKSk7XG5cdFx0XHRwYXJlbnQuYmluZC5jYWxsKHRoaXMpO1xuXHRcdH07XG5cdFx0dGhpcy5nZXRfanNvbiA9IGZ1bmN0aW9uIChvYmosIG9wdGlvbnMsIGZsYXQpIHtcblx0XHRcdHZhciBpLCBqLFxuXHRcdFx0XHRtID0gdGhpcy5fbW9kZWwuZGF0YSxcblx0XHRcdFx0b3B0ID0gb3B0aW9ucyA/ICQuZXh0ZW5kKHRydWUsIHt9LCBvcHRpb25zLCB7bm9faWQ6ZmFsc2V9KSA6IHt9LFxuXHRcdFx0XHR0bXAgPSBwYXJlbnQuZ2V0X2pzb24uY2FsbCh0aGlzLCBvYmosIG9wdCwgZmxhdCk7XG5cdFx0XHRpZih0bXAgPT09IGZhbHNlKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdFx0aWYoJC5pc0FycmF5KHRtcCkpIHtcblx0XHRcdFx0Zm9yKGkgPSAwLCBqID0gdG1wLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuXHRcdFx0XHRcdHRtcFtpXS50eXBlID0gdG1wW2ldLmlkICYmIG1bdG1wW2ldLmlkXSAmJiBtW3RtcFtpXS5pZF0udHlwZSA/IG1bdG1wW2ldLmlkXS50eXBlIDogXCJkZWZhdWx0XCI7XG5cdFx0XHRcdFx0aWYob3B0aW9ucyAmJiBvcHRpb25zLm5vX2lkKSB7XG5cdFx0XHRcdFx0XHRkZWxldGUgdG1wW2ldLmlkO1xuXHRcdFx0XHRcdFx0aWYodG1wW2ldLmxpX2F0dHIgJiYgdG1wW2ldLmxpX2F0dHIuaWQpIHtcblx0XHRcdFx0XHRcdFx0ZGVsZXRlIHRtcFtpXS5saV9hdHRyLmlkO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdHRtcC50eXBlID0gdG1wLmlkICYmIG1bdG1wLmlkXSAmJiBtW3RtcC5pZF0udHlwZSA/IG1bdG1wLmlkXS50eXBlIDogXCJkZWZhdWx0XCI7XG5cdFx0XHRcdGlmKG9wdGlvbnMgJiYgb3B0aW9ucy5ub19pZCkge1xuXHRcdFx0XHRcdHRtcCA9IHRoaXMuX2RlbGV0ZV9pZHModG1wKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRtcDtcblx0XHR9O1xuXHRcdHRoaXMuX2RlbGV0ZV9pZHMgPSBmdW5jdGlvbiAodG1wKSB7XG5cdFx0XHRpZigkLmlzQXJyYXkodG1wKSkge1xuXHRcdFx0XHRmb3IodmFyIGkgPSAwLCBqID0gdG1wLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuXHRcdFx0XHRcdHRtcFtpXSA9IHRoaXMuX2RlbGV0ZV9pZHModG1wW2ldKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdG1wO1xuXHRcdFx0fVxuXHRcdFx0ZGVsZXRlIHRtcC5pZDtcblx0XHRcdGlmKHRtcC5saV9hdHRyICYmIHRtcC5saV9hdHRyLmlkKSB7XG5cdFx0XHRcdGRlbGV0ZSB0bXAubGlfYXR0ci5pZDtcblx0XHRcdH1cblx0XHRcdGlmKHRtcC5jaGlsZHJlbiAmJiAkLmlzQXJyYXkodG1wLmNoaWxkcmVuKSkge1xuXHRcdFx0XHR0bXAuY2hpbGRyZW4gPSB0aGlzLl9kZWxldGVfaWRzKHRtcC5jaGlsZHJlbik7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdG1wO1xuXHRcdH07XG5cdFx0dGhpcy5jaGVjayA9IGZ1bmN0aW9uIChjaGssIG9iaiwgcGFyLCBwb3MsIG1vcmUpIHtcblx0XHRcdGlmKHBhcmVudC5jaGVjay5jYWxsKHRoaXMsIGNoaywgb2JqLCBwYXIsIHBvcywgbW9yZSkgPT09IGZhbHNlKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdFx0b2JqID0gb2JqICYmIG9iai5pZCA/IG9iaiA6IHRoaXMuZ2V0X25vZGUob2JqKTtcblx0XHRcdHBhciA9IHBhciAmJiBwYXIuaWQgPyBwYXIgOiB0aGlzLmdldF9ub2RlKHBhcik7XG5cdFx0XHR2YXIgbSA9IG9iaiAmJiBvYmouaWQgPyAkLmpzdHJlZS5yZWZlcmVuY2Uob2JqLmlkKSA6IG51bGwsIHRtcCwgZCwgaSwgajtcblx0XHRcdG0gPSBtICYmIG0uX21vZGVsICYmIG0uX21vZGVsLmRhdGEgPyBtLl9tb2RlbC5kYXRhIDogbnVsbDtcblx0XHRcdHN3aXRjaChjaGspIHtcblx0XHRcdFx0Y2FzZSBcImNyZWF0ZV9ub2RlXCI6XG5cdFx0XHRcdGNhc2UgXCJtb3ZlX25vZGVcIjpcblx0XHRcdFx0Y2FzZSBcImNvcHlfbm9kZVwiOlxuXHRcdFx0XHRcdGlmKGNoayAhPT0gJ21vdmVfbm9kZScgfHwgJC5pbkFycmF5KG9iai5pZCwgcGFyLmNoaWxkcmVuKSA9PT0gLTEpIHtcblx0XHRcdFx0XHRcdHRtcCA9IHRoaXMuZ2V0X3J1bGVzKHBhcik7XG5cdFx0XHRcdFx0XHRpZih0bXAubWF4X2NoaWxkcmVuICE9PSB1bmRlZmluZWQgJiYgdG1wLm1heF9jaGlsZHJlbiAhPT0gLTEgJiYgdG1wLm1heF9jaGlsZHJlbiA9PT0gcGFyLmNoaWxkcmVuLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0XHR0aGlzLl9kYXRhLmNvcmUubGFzdF9lcnJvciA9IHsgJ2Vycm9yJyA6ICdjaGVjaycsICdwbHVnaW4nIDogJ3R5cGVzJywgJ2lkJyA6ICd0eXBlc18wMScsICdyZWFzb24nIDogJ21heF9jaGlsZHJlbiBwcmV2ZW50cyBmdW5jdGlvbjogJyArIGNoaywgJ2RhdGEnIDogSlNPTi5zdHJpbmdpZnkoeyAnY2hrJyA6IGNoaywgJ3BvcycgOiBwb3MsICdvYmonIDogb2JqICYmIG9iai5pZCA/IG9iai5pZCA6IGZhbHNlLCAncGFyJyA6IHBhciAmJiBwYXIuaWQgPyBwYXIuaWQgOiBmYWxzZSB9KSB9O1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZih0bXAudmFsaWRfY2hpbGRyZW4gIT09IHVuZGVmaW5lZCAmJiB0bXAudmFsaWRfY2hpbGRyZW4gIT09IC0xICYmICQuaW5BcnJheShvYmoudHlwZSwgdG1wLnZhbGlkX2NoaWxkcmVuKSA9PT0gLTEpIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5fZGF0YS5jb3JlLmxhc3RfZXJyb3IgPSB7ICdlcnJvcicgOiAnY2hlY2snLCAncGx1Z2luJyA6ICd0eXBlcycsICdpZCcgOiAndHlwZXNfMDInLCAncmVhc29uJyA6ICd2YWxpZF9jaGlsZHJlbiBwcmV2ZW50cyBmdW5jdGlvbjogJyArIGNoaywgJ2RhdGEnIDogSlNPTi5zdHJpbmdpZnkoeyAnY2hrJyA6IGNoaywgJ3BvcycgOiBwb3MsICdvYmonIDogb2JqICYmIG9iai5pZCA/IG9iai5pZCA6IGZhbHNlLCAncGFyJyA6IHBhciAmJiBwYXIuaWQgPyBwYXIuaWQgOiBmYWxzZSB9KSB9O1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZihtICYmIG9iai5jaGlsZHJlbl9kICYmIG9iai5wYXJlbnRzKSB7XG5cdFx0XHRcdFx0XHRcdGQgPSAwO1xuXHRcdFx0XHRcdFx0XHRmb3IoaSA9IDAsIGogPSBvYmouY2hpbGRyZW5fZC5sZW5ndGg7IGkgPCBqOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0XHRkID0gTWF0aC5tYXgoZCwgbVtvYmouY2hpbGRyZW5fZFtpXV0ucGFyZW50cy5sZW5ndGgpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGQgPSBkIC0gb2JqLnBhcmVudHMubGVuZ3RoICsgMTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmKGQgPD0gMCB8fCBkID09PSB1bmRlZmluZWQpIHsgZCA9IDE7IH1cblx0XHRcdFx0XHRcdGRvIHtcblx0XHRcdFx0XHRcdFx0aWYodG1wLm1heF9kZXB0aCAhPT0gdW5kZWZpbmVkICYmIHRtcC5tYXhfZGVwdGggIT09IC0xICYmIHRtcC5tYXhfZGVwdGggPCBkKSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5fZGF0YS5jb3JlLmxhc3RfZXJyb3IgPSB7ICdlcnJvcicgOiAnY2hlY2snLCAncGx1Z2luJyA6ICd0eXBlcycsICdpZCcgOiAndHlwZXNfMDMnLCAncmVhc29uJyA6ICdtYXhfZGVwdGggcHJldmVudHMgZnVuY3Rpb246ICcgKyBjaGssICdkYXRhJyA6IEpTT04uc3RyaW5naWZ5KHsgJ2NoaycgOiBjaGssICdwb3MnIDogcG9zLCAnb2JqJyA6IG9iaiAmJiBvYmouaWQgPyBvYmouaWQgOiBmYWxzZSwgJ3BhcicgOiBwYXIgJiYgcGFyLmlkID8gcGFyLmlkIDogZmFsc2UgfSkgfTtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0cGFyID0gdGhpcy5nZXRfbm9kZShwYXIucGFyZW50KTtcblx0XHRcdFx0XHRcdFx0dG1wID0gdGhpcy5nZXRfcnVsZXMocGFyKTtcblx0XHRcdFx0XHRcdFx0ZCsrO1xuXHRcdFx0XHRcdFx0fSB3aGlsZShwYXIpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH07XG5cdFx0LyoqXG5cdFx0ICogdXNlZCB0byByZXRyaWV2ZSB0aGUgdHlwZSBzZXR0aW5ncyBvYmplY3QgZm9yIGEgbm9kZVxuXHRcdCAqIEBuYW1lIGdldF9ydWxlcyhvYmopXG5cdFx0ICogQHBhcmFtIHttaXhlZH0gb2JqIHRoZSBub2RlIHRvIGZpbmQgdGhlIHJ1bGVzIGZvclxuXHRcdCAqIEByZXR1cm4ge09iamVjdH1cblx0XHQgKiBAcGx1Z2luIHR5cGVzXG5cdFx0ICovXG5cdFx0dGhpcy5nZXRfcnVsZXMgPSBmdW5jdGlvbiAob2JqKSB7XG5cdFx0XHRvYmogPSB0aGlzLmdldF9ub2RlKG9iaik7XG5cdFx0XHRpZighb2JqKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdFx0dmFyIHRtcCA9IHRoaXMuZ2V0X3R5cGUob2JqLCB0cnVlKTtcblx0XHRcdGlmKHRtcC5tYXhfZGVwdGggPT09IHVuZGVmaW5lZCkgeyB0bXAubWF4X2RlcHRoID0gLTE7IH1cblx0XHRcdGlmKHRtcC5tYXhfY2hpbGRyZW4gPT09IHVuZGVmaW5lZCkgeyB0bXAubWF4X2NoaWxkcmVuID0gLTE7IH1cblx0XHRcdGlmKHRtcC52YWxpZF9jaGlsZHJlbiA9PT0gdW5kZWZpbmVkKSB7IHRtcC52YWxpZF9jaGlsZHJlbiA9IC0xOyB9XG5cdFx0XHRyZXR1cm4gdG1wO1xuXHRcdH07XG5cdFx0LyoqXG5cdFx0ICogdXNlZCB0byByZXRyaWV2ZSB0aGUgdHlwZSBzdHJpbmcgb3Igc2V0dGluZ3Mgb2JqZWN0IGZvciBhIG5vZGVcblx0XHQgKiBAbmFtZSBnZXRfdHlwZShvYmogWywgcnVsZXNdKVxuXHRcdCAqIEBwYXJhbSB7bWl4ZWR9IG9iaiB0aGUgbm9kZSB0byBmaW5kIHRoZSBydWxlcyBmb3Jcblx0XHQgKiBAcGFyYW0ge0Jvb2xlYW59IHJ1bGVzIGlmIHNldCB0byBgdHJ1ZWAgaW5zdGVhZCBvZiBhIHN0cmluZyB0aGUgc2V0dGluZ3Mgb2JqZWN0IHdpbGwgYmUgcmV0dXJuZWRcblx0XHQgKiBAcmV0dXJuIHtTdHJpbmd8T2JqZWN0fVxuXHRcdCAqIEBwbHVnaW4gdHlwZXNcblx0XHQgKi9cblx0XHR0aGlzLmdldF90eXBlID0gZnVuY3Rpb24gKG9iaiwgcnVsZXMpIHtcblx0XHRcdG9iaiA9IHRoaXMuZ2V0X25vZGUob2JqKTtcblx0XHRcdHJldHVybiAoIW9iaikgPyBmYWxzZSA6ICggcnVsZXMgPyAkLmV4dGVuZCh7ICd0eXBlJyA6IG9iai50eXBlIH0sIHRoaXMuc2V0dGluZ3MudHlwZXNbb2JqLnR5cGVdKSA6IG9iai50eXBlKTtcblx0XHR9O1xuXHRcdC8qKlxuXHRcdCAqIHVzZWQgdG8gY2hhbmdlIGEgbm9kZSdzIHR5cGVcblx0XHQgKiBAbmFtZSBzZXRfdHlwZShvYmosIHR5cGUpXG5cdFx0ICogQHBhcmFtIHttaXhlZH0gb2JqIHRoZSBub2RlIHRvIGNoYW5nZVxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIHRoZSBuZXcgdHlwZVxuXHRcdCAqIEBwbHVnaW4gdHlwZXNcblx0XHQgKi9cblx0XHR0aGlzLnNldF90eXBlID0gZnVuY3Rpb24gKG9iaiwgdHlwZSkge1xuXHRcdFx0dmFyIHQsIHQxLCB0Miwgb2xkX3R5cGUsIG9sZF9pY29uO1xuXHRcdFx0aWYoJC5pc0FycmF5KG9iaikpIHtcblx0XHRcdFx0b2JqID0gb2JqLnNsaWNlKCk7XG5cdFx0XHRcdGZvcih0MSA9IDAsIHQyID0gb2JqLmxlbmd0aDsgdDEgPCB0MjsgdDErKykge1xuXHRcdFx0XHRcdHRoaXMuc2V0X3R5cGUob2JqW3QxXSwgdHlwZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0XHR0ID0gdGhpcy5zZXR0aW5ncy50eXBlcztcblx0XHRcdG9iaiA9IHRoaXMuZ2V0X25vZGUob2JqKTtcblx0XHRcdGlmKCF0W3R5cGVdIHx8ICFvYmopIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0XHRvbGRfdHlwZSA9IG9iai50eXBlO1xuXHRcdFx0b2xkX2ljb24gPSB0aGlzLmdldF9pY29uKG9iaik7XG5cdFx0XHRvYmoudHlwZSA9IHR5cGU7XG5cdFx0XHRpZihvbGRfaWNvbiA9PT0gdHJ1ZSB8fCAodFtvbGRfdHlwZV0gJiYgdFtvbGRfdHlwZV0uaWNvbiAmJiBvbGRfaWNvbiA9PT0gdFtvbGRfdHlwZV0uaWNvbikpIHtcblx0XHRcdFx0dGhpcy5zZXRfaWNvbihvYmosIHRbdHlwZV0uaWNvbiAhPT0gdW5kZWZpbmVkID8gdFt0eXBlXS5pY29uIDogdHJ1ZSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9O1xuXHR9O1xuXHQvLyBpbmNsdWRlIHRoZSB0eXBlcyBwbHVnaW4gYnkgZGVmYXVsdFxuXHQvLyAkLmpzdHJlZS5kZWZhdWx0cy5wbHVnaW5zLnB1c2goXCJ0eXBlc1wiKTtcblxuLyoqXG4gKiAjIyMgVW5pcXVlIHBsdWdpblxuICpcbiAqIEVuZm9yY2VzIHRoYXQgbm8gbm9kZXMgd2l0aCB0aGUgc2FtZSBuYW1lIGNhbiBjb2V4aXN0IGFzIHNpYmxpbmdzLlxuICovXG5cblx0LyoqXG5cdCAqIHN0b3JlcyBhbGwgZGVmYXVsdHMgZm9yIHRoZSB1bmlxdWUgcGx1Z2luXG5cdCAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLnVuaXF1ZVxuXHQgKiBAcGx1Z2luIHVuaXF1ZVxuXHQgKi9cblx0JC5qc3RyZWUuZGVmYXVsdHMudW5pcXVlID0ge1xuXHRcdC8qKlxuXHRcdCAqIEluZGljYXRlcyBpZiB0aGUgY29tcGFyaXNvbiBzaG91bGQgYmUgY2FzZSBzZW5zaXRpdmUuIERlZmF1bHQgaXMgYGZhbHNlYC5cblx0XHQgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy51bmlxdWUuY2FzZV9zZW5zaXRpdmVcblx0XHQgKiBAcGx1Z2luIHVuaXF1ZVxuXHRcdCAqL1xuXHRcdGNhc2Vfc2Vuc2l0aXZlIDogZmFsc2UsXG5cdFx0LyoqXG5cdFx0ICogQSBjYWxsYmFjayBleGVjdXRlZCBpbiB0aGUgaW5zdGFuY2UncyBzY29wZSB3aGVuIGEgbmV3IG5vZGUgaXMgY3JlYXRlZCBhbmQgdGhlIG5hbWUgaXMgYWxyZWFkeSB0YWtlbiwgdGhlIHR3byBhcmd1bWVudHMgYXJlIHRoZSBjb25mbGljdGluZyBuYW1lIGFuZCB0aGUgY291bnRlci4gVGhlIGRlZmF1bHQgd2lsbCBwcm9kdWNlIHJlc3VsdHMgbGlrZSBgTmV3IG5vZGUgKDIpYC5cblx0XHQgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy51bmlxdWUuZHVwbGljYXRlXG5cdFx0ICogQHBsdWdpbiB1bmlxdWVcblx0XHQgKi9cblx0XHRkdXBsaWNhdGUgOiBmdW5jdGlvbiAobmFtZSwgY291bnRlcikge1xuXHRcdFx0cmV0dXJuIG5hbWUgKyAnICgnICsgY291bnRlciArICcpJztcblx0XHR9XG5cdH07XG5cblx0JC5qc3RyZWUucGx1Z2lucy51bmlxdWUgPSBmdW5jdGlvbiAob3B0aW9ucywgcGFyZW50KSB7XG5cdFx0dGhpcy5jaGVjayA9IGZ1bmN0aW9uIChjaGssIG9iaiwgcGFyLCBwb3MsIG1vcmUpIHtcblx0XHRcdGlmKHBhcmVudC5jaGVjay5jYWxsKHRoaXMsIGNoaywgb2JqLCBwYXIsIHBvcywgbW9yZSkgPT09IGZhbHNlKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdFx0b2JqID0gb2JqICYmIG9iai5pZCA/IG9iaiA6IHRoaXMuZ2V0X25vZGUob2JqKTtcblx0XHRcdHBhciA9IHBhciAmJiBwYXIuaWQgPyBwYXIgOiB0aGlzLmdldF9ub2RlKHBhcik7XG5cdFx0XHRpZighcGFyIHx8ICFwYXIuY2hpbGRyZW4pIHsgcmV0dXJuIHRydWU7IH1cblx0XHRcdHZhciBuID0gY2hrID09PSBcInJlbmFtZV9ub2RlXCIgPyBwb3MgOiBvYmoudGV4dCxcblx0XHRcdFx0YyA9IFtdLFxuXHRcdFx0XHRzID0gdGhpcy5zZXR0aW5ncy51bmlxdWUuY2FzZV9zZW5zaXRpdmUsXG5cdFx0XHRcdG0gPSB0aGlzLl9tb2RlbC5kYXRhLCBpLCBqO1xuXHRcdFx0Zm9yKGkgPSAwLCBqID0gcGFyLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuXHRcdFx0XHRjLnB1c2gocyA/IG1bcGFyLmNoaWxkcmVuW2ldXS50ZXh0IDogbVtwYXIuY2hpbGRyZW5baV1dLnRleHQudG9Mb3dlckNhc2UoKSk7XG5cdFx0XHR9XG5cdFx0XHRpZighcykgeyBuID0gbi50b0xvd2VyQ2FzZSgpOyB9XG5cdFx0XHRzd2l0Y2goY2hrKSB7XG5cdFx0XHRcdGNhc2UgXCJkZWxldGVfbm9kZVwiOlxuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRjYXNlIFwicmVuYW1lX25vZGVcIjpcblx0XHRcdFx0XHRpID0gKCQuaW5BcnJheShuLCBjKSA9PT0gLTEgfHwgKG9iai50ZXh0ICYmIG9iai50ZXh0WyBzID8gJ3RvU3RyaW5nJyA6ICd0b0xvd2VyQ2FzZSddKCkgPT09IG4pKTtcblx0XHRcdFx0XHRpZighaSkge1xuXHRcdFx0XHRcdFx0dGhpcy5fZGF0YS5jb3JlLmxhc3RfZXJyb3IgPSB7ICdlcnJvcicgOiAnY2hlY2snLCAncGx1Z2luJyA6ICd1bmlxdWUnLCAnaWQnIDogJ3VuaXF1ZV8wMScsICdyZWFzb24nIDogJ0NoaWxkIHdpdGggbmFtZSAnICsgbiArICcgYWxyZWFkeSBleGlzdHMuIFByZXZlbnRpbmc6ICcgKyBjaGssICdkYXRhJyA6IEpTT04uc3RyaW5naWZ5KHsgJ2NoaycgOiBjaGssICdwb3MnIDogcG9zLCAnb2JqJyA6IG9iaiAmJiBvYmouaWQgPyBvYmouaWQgOiBmYWxzZSwgJ3BhcicgOiBwYXIgJiYgcGFyLmlkID8gcGFyLmlkIDogZmFsc2UgfSkgfTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIGk7XG5cdFx0XHRcdGNhc2UgXCJjcmVhdGVfbm9kZVwiOlxuXHRcdFx0XHRcdGkgPSAoJC5pbkFycmF5KG4sIGMpID09PSAtMSk7XG5cdFx0XHRcdFx0aWYoIWkpIHtcblx0XHRcdFx0XHRcdHRoaXMuX2RhdGEuY29yZS5sYXN0X2Vycm9yID0geyAnZXJyb3InIDogJ2NoZWNrJywgJ3BsdWdpbicgOiAndW5pcXVlJywgJ2lkJyA6ICd1bmlxdWVfMDQnLCAncmVhc29uJyA6ICdDaGlsZCB3aXRoIG5hbWUgJyArIG4gKyAnIGFscmVhZHkgZXhpc3RzLiBQcmV2ZW50aW5nOiAnICsgY2hrLCAnZGF0YScgOiBKU09OLnN0cmluZ2lmeSh7ICdjaGsnIDogY2hrLCAncG9zJyA6IHBvcywgJ29iaicgOiBvYmogJiYgb2JqLmlkID8gb2JqLmlkIDogZmFsc2UsICdwYXInIDogcGFyICYmIHBhci5pZCA/IHBhci5pZCA6IGZhbHNlIH0pIH07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBpO1xuXHRcdFx0XHRjYXNlIFwiY29weV9ub2RlXCI6XG5cdFx0XHRcdFx0aSA9ICgkLmluQXJyYXkobiwgYykgPT09IC0xKTtcblx0XHRcdFx0XHRpZighaSkge1xuXHRcdFx0XHRcdFx0dGhpcy5fZGF0YS5jb3JlLmxhc3RfZXJyb3IgPSB7ICdlcnJvcicgOiAnY2hlY2snLCAncGx1Z2luJyA6ICd1bmlxdWUnLCAnaWQnIDogJ3VuaXF1ZV8wMicsICdyZWFzb24nIDogJ0NoaWxkIHdpdGggbmFtZSAnICsgbiArICcgYWxyZWFkeSBleGlzdHMuIFByZXZlbnRpbmc6ICcgKyBjaGssICdkYXRhJyA6IEpTT04uc3RyaW5naWZ5KHsgJ2NoaycgOiBjaGssICdwb3MnIDogcG9zLCAnb2JqJyA6IG9iaiAmJiBvYmouaWQgPyBvYmouaWQgOiBmYWxzZSwgJ3BhcicgOiBwYXIgJiYgcGFyLmlkID8gcGFyLmlkIDogZmFsc2UgfSkgfTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIGk7XG5cdFx0XHRcdGNhc2UgXCJtb3ZlX25vZGVcIjpcblx0XHRcdFx0XHRpID0gKG9iai5wYXJlbnQgPT09IHBhci5pZCB8fCAkLmluQXJyYXkobiwgYykgPT09IC0xKTtcblx0XHRcdFx0XHRpZighaSkge1xuXHRcdFx0XHRcdFx0dGhpcy5fZGF0YS5jb3JlLmxhc3RfZXJyb3IgPSB7ICdlcnJvcicgOiAnY2hlY2snLCAncGx1Z2luJyA6ICd1bmlxdWUnLCAnaWQnIDogJ3VuaXF1ZV8wMycsICdyZWFzb24nIDogJ0NoaWxkIHdpdGggbmFtZSAnICsgbiArICcgYWxyZWFkeSBleGlzdHMuIFByZXZlbnRpbmc6ICcgKyBjaGssICdkYXRhJyA6IEpTT04uc3RyaW5naWZ5KHsgJ2NoaycgOiBjaGssICdwb3MnIDogcG9zLCAnb2JqJyA6IG9iaiAmJiBvYmouaWQgPyBvYmouaWQgOiBmYWxzZSwgJ3BhcicgOiBwYXIgJiYgcGFyLmlkID8gcGFyLmlkIDogZmFsc2UgfSkgfTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIGk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9O1xuXHRcdHRoaXMuY3JlYXRlX25vZGUgPSBmdW5jdGlvbiAocGFyLCBub2RlLCBwb3MsIGNhbGxiYWNrLCBpc19sb2FkZWQpIHtcblx0XHRcdGlmKCFub2RlIHx8IG5vZGUudGV4dCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdGlmKHBhciA9PT0gbnVsbCkge1xuXHRcdFx0XHRcdHBhciA9IFwiI1wiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHBhciA9IHRoaXMuZ2V0X25vZGUocGFyKTtcblx0XHRcdFx0aWYoIXBhcikge1xuXHRcdFx0XHRcdHJldHVybiBwYXJlbnQuY3JlYXRlX25vZGUuY2FsbCh0aGlzLCBwYXIsIG5vZGUsIHBvcywgY2FsbGJhY2ssIGlzX2xvYWRlZCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cG9zID0gcG9zID09PSB1bmRlZmluZWQgPyBcImxhc3RcIiA6IHBvcztcblx0XHRcdFx0aWYoIXBvcy50b1N0cmluZygpLm1hdGNoKC9eKGJlZm9yZXxhZnRlcikkLykgJiYgIWlzX2xvYWRlZCAmJiAhdGhpcy5pc19sb2FkZWQocGFyKSkge1xuXHRcdFx0XHRcdHJldHVybiBwYXJlbnQuY3JlYXRlX25vZGUuY2FsbCh0aGlzLCBwYXIsIG5vZGUsIHBvcywgY2FsbGJhY2ssIGlzX2xvYWRlZCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYoIW5vZGUpIHsgbm9kZSA9IHt9OyB9XG5cdFx0XHRcdHZhciB0bXAsIG4sIGRwYywgaSwgaiwgbSA9IHRoaXMuX21vZGVsLmRhdGEsIHMgPSB0aGlzLnNldHRpbmdzLnVuaXF1ZS5jYXNlX3NlbnNpdGl2ZSwgY2IgPSB0aGlzLnNldHRpbmdzLnVuaXF1ZS5kdXBsaWNhdGU7XG5cdFx0XHRcdG4gPSB0bXAgPSB0aGlzLmdldF9zdHJpbmcoJ05ldyBub2RlJyk7XG5cdFx0XHRcdGRwYyA9IFtdO1xuXHRcdFx0XHRmb3IoaSA9IDAsIGogPSBwYXIuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG5cdFx0XHRcdFx0ZHBjLnB1c2gocyA/IG1bcGFyLmNoaWxkcmVuW2ldXS50ZXh0IDogbVtwYXIuY2hpbGRyZW5baV1dLnRleHQudG9Mb3dlckNhc2UoKSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aSA9IDE7XG5cdFx0XHRcdHdoaWxlKCQuaW5BcnJheShzID8gbiA6IG4udG9Mb3dlckNhc2UoKSwgZHBjKSAhPT0gLTEpIHtcblx0XHRcdFx0XHRuID0gY2IuY2FsbCh0aGlzLCB0bXAsICgrK2kpKS50b1N0cmluZygpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG5vZGUudGV4dCA9IG47XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcGFyZW50LmNyZWF0ZV9ub2RlLmNhbGwodGhpcywgcGFyLCBub2RlLCBwb3MsIGNhbGxiYWNrLCBpc19sb2FkZWQpO1xuXHRcdH07XG5cdH07XG5cblx0Ly8gaW5jbHVkZSB0aGUgdW5pcXVlIHBsdWdpbiBieSBkZWZhdWx0XG5cdC8vICQuanN0cmVlLmRlZmF1bHRzLnBsdWdpbnMucHVzaChcInVuaXF1ZVwiKTtcblxuXG4vKipcbiAqICMjIyBXaG9sZXJvdyBwbHVnaW5cbiAqXG4gKiBNYWtlcyBlYWNoIG5vZGUgYXBwZWFyIGJsb2NrIGxldmVsLiBNYWtpbmcgc2VsZWN0aW9uIGVhc2llci4gTWF5IGNhdXNlIHNsb3cgZG93biBmb3IgbGFyZ2UgdHJlZXMgaW4gb2xkIGJyb3dzZXJzLlxuICovXG5cblx0dmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0RJVicpO1xuXHRkaXYuc2V0QXR0cmlidXRlKCd1bnNlbGVjdGFibGUnLCdvbicpO1xuXHRkaXYuY2xhc3NOYW1lID0gJ2pzdHJlZS13aG9sZXJvdyc7XG5cdGRpdi5pbm5lckhUTUwgPSAnJiMxNjA7Jztcblx0JC5qc3RyZWUucGx1Z2lucy53aG9sZXJvdyA9IGZ1bmN0aW9uIChvcHRpb25zLCBwYXJlbnQpIHtcblx0XHR0aGlzLmJpbmQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRwYXJlbnQuYmluZC5jYWxsKHRoaXMpO1xuXG5cdFx0XHR0aGlzLmVsZW1lbnRcblx0XHRcdFx0Lm9uKCdyZWFkeS5qc3RyZWUgc2V0X3N0YXRlLmpzdHJlZScsICQucHJveHkoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0dGhpcy5oaWRlX2RvdHMoKTtcblx0XHRcdFx0XHR9LCB0aGlzKSlcblx0XHRcdFx0Lm9uKFwiaW5pdC5qc3RyZWUgbG9hZGluZy5qc3RyZWUgcmVhZHkuanN0cmVlXCIsICQucHJveHkoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0Ly9kaXYuc3R5bGUuaGVpZ2h0ID0gdGhpcy5fZGF0YS5jb3JlLmxpX2hlaWdodCArICdweCc7XG5cdFx0XHRcdFx0XHR0aGlzLmdldF9jb250YWluZXJfdWwoKS5hZGRDbGFzcygnanN0cmVlLXdob2xlcm93LXVsJyk7XG5cdFx0XHRcdFx0fSwgdGhpcykpXG5cdFx0XHRcdC5vbihcImRlc2VsZWN0X2FsbC5qc3RyZWVcIiwgJC5wcm94eShmdW5jdGlvbiAoZSwgZGF0YSkge1xuXHRcdFx0XHRcdFx0dGhpcy5lbGVtZW50LmZpbmQoJy5qc3RyZWUtd2hvbGVyb3ctY2xpY2tlZCcpLnJlbW92ZUNsYXNzKCdqc3RyZWUtd2hvbGVyb3ctY2xpY2tlZCcpO1xuXHRcdFx0XHRcdH0sIHRoaXMpKVxuXHRcdFx0XHQub24oXCJjaGFuZ2VkLmpzdHJlZVwiLCAkLnByb3h5KGZ1bmN0aW9uIChlLCBkYXRhKSB7XG5cdFx0XHRcdFx0XHR0aGlzLmVsZW1lbnQuZmluZCgnLmpzdHJlZS13aG9sZXJvdy1jbGlja2VkJykucmVtb3ZlQ2xhc3MoJ2pzdHJlZS13aG9sZXJvdy1jbGlja2VkJyk7XG5cdFx0XHRcdFx0XHR2YXIgdG1wID0gZmFsc2UsIGksIGo7XG5cdFx0XHRcdFx0XHRmb3IoaSA9IDAsIGogPSBkYXRhLnNlbGVjdGVkLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuXHRcdFx0XHRcdFx0XHR0bXAgPSB0aGlzLmdldF9ub2RlKGRhdGEuc2VsZWN0ZWRbaV0sIHRydWUpO1xuXHRcdFx0XHRcdFx0XHRpZih0bXAgJiYgdG1wLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0XHRcdHRtcC5jaGlsZHJlbignLmpzdHJlZS13aG9sZXJvdycpLmFkZENsYXNzKCdqc3RyZWUtd2hvbGVyb3ctY2xpY2tlZCcpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSwgdGhpcykpXG5cdFx0XHRcdC5vbihcIm9wZW5fbm9kZS5qc3RyZWVcIiwgJC5wcm94eShmdW5jdGlvbiAoZSwgZGF0YSkge1xuXHRcdFx0XHRcdFx0dGhpcy5nZXRfbm9kZShkYXRhLm5vZGUsIHRydWUpLmZpbmQoJy5qc3RyZWUtY2xpY2tlZCcpLnBhcmVudCgpLmNoaWxkcmVuKCcuanN0cmVlLXdob2xlcm93JykuYWRkQ2xhc3MoJ2pzdHJlZS13aG9sZXJvdy1jbGlja2VkJyk7XG5cdFx0XHRcdFx0fSwgdGhpcykpXG5cdFx0XHRcdC5vbihcImhvdmVyX25vZGUuanN0cmVlIGRlaG92ZXJfbm9kZS5qc3RyZWVcIiwgJC5wcm94eShmdW5jdGlvbiAoZSwgZGF0YSkge1xuXHRcdFx0XHRcdFx0dGhpcy5nZXRfbm9kZShkYXRhLm5vZGUsIHRydWUpLmNoaWxkcmVuKCcuanN0cmVlLXdob2xlcm93JylbZS50eXBlID09PSBcImhvdmVyX25vZGVcIj9cImFkZENsYXNzXCI6XCJyZW1vdmVDbGFzc1wiXSgnanN0cmVlLXdob2xlcm93LWhvdmVyZWQnKTtcblx0XHRcdFx0XHR9LCB0aGlzKSlcblx0XHRcdFx0Lm9uKFwiY29udGV4dG1lbnUuanN0cmVlXCIsIFwiLmpzdHJlZS13aG9sZXJvd1wiLCAkLnByb3h5KGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0XHR2YXIgdG1wID0gJC5FdmVudCgnY29udGV4dG1lbnUnLCB7IG1ldGFLZXkgOiBlLm1ldGFLZXksIGN0cmxLZXkgOiBlLmN0cmxLZXksIGFsdEtleSA6IGUuYWx0S2V5LCBzaGlmdEtleSA6IGUuc2hpZnRLZXksIHBhZ2VYIDogZS5wYWdlWCwgcGFnZVkgOiBlLnBhZ2VZIH0pO1xuXHRcdFx0XHRcdFx0JChlLmN1cnJlbnRUYXJnZXQpLmNsb3Nlc3QoXCIuanN0cmVlLW5vZGVcIikuY2hpbGRyZW4oXCIuanN0cmVlLWFuY2hvcjplcSgwKVwiKS50cmlnZ2VyKHRtcCk7XG5cdFx0XHRcdFx0fSwgdGhpcykpXG5cdFx0XHRcdC5vbihcImNsaWNrLmpzdHJlZVwiLCBcIi5qc3RyZWUtd2hvbGVyb3dcIiwgZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0XHRcdGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG5cdFx0XHRcdFx0XHR2YXIgdG1wID0gJC5FdmVudCgnY2xpY2snLCB7IG1ldGFLZXkgOiBlLm1ldGFLZXksIGN0cmxLZXkgOiBlLmN0cmxLZXksIGFsdEtleSA6IGUuYWx0S2V5LCBzaGlmdEtleSA6IGUuc2hpZnRLZXkgfSk7XG5cdFx0XHRcdFx0XHQkKGUuY3VycmVudFRhcmdldCkuY2xvc2VzdChcIi5qc3RyZWUtbm9kZVwiKS5jaGlsZHJlbihcIi5qc3RyZWUtYW5jaG9yOmVxKDApXCIpLnRyaWdnZXIodG1wKS5mb2N1cygpO1xuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdC5vbihcImNsaWNrLmpzdHJlZVwiLCBcIi5qc3RyZWUtbGVhZiA+IC5qc3RyZWUtb2NsXCIsICQucHJveHkoZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0XHRcdGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG5cdFx0XHRcdFx0XHR2YXIgdG1wID0gJC5FdmVudCgnY2xpY2snLCB7IG1ldGFLZXkgOiBlLm1ldGFLZXksIGN0cmxLZXkgOiBlLmN0cmxLZXksIGFsdEtleSA6IGUuYWx0S2V5LCBzaGlmdEtleSA6IGUuc2hpZnRLZXkgfSk7XG5cdFx0XHRcdFx0XHQkKGUuY3VycmVudFRhcmdldCkuY2xvc2VzdChcIi5qc3RyZWUtbm9kZVwiKS5jaGlsZHJlbihcIi5qc3RyZWUtYW5jaG9yOmVxKDApXCIpLnRyaWdnZXIodG1wKS5mb2N1cygpO1xuXHRcdFx0XHRcdH0sIHRoaXMpKVxuXHRcdFx0XHQub24oXCJtb3VzZW92ZXIuanN0cmVlXCIsIFwiLmpzdHJlZS13aG9sZXJvdywgLmpzdHJlZS1pY29uXCIsICQucHJveHkoZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0XHRcdGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG5cdFx0XHRcdFx0XHR0aGlzLmhvdmVyX25vZGUoZS5jdXJyZW50VGFyZ2V0KTtcblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHR9LCB0aGlzKSlcblx0XHRcdFx0Lm9uKFwibW91c2VsZWF2ZS5qc3RyZWVcIiwgXCIuanN0cmVlLW5vZGVcIiwgJC5wcm94eShmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHRcdFx0dGhpcy5kZWhvdmVyX25vZGUoZS5jdXJyZW50VGFyZ2V0KTtcblx0XHRcdFx0XHR9LCB0aGlzKSk7XG5cdFx0fTtcblx0XHR0aGlzLnRlYXJkb3duID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0aWYodGhpcy5zZXR0aW5ncy53aG9sZXJvdykge1xuXHRcdFx0XHR0aGlzLmVsZW1lbnQuZmluZChcIi5qc3RyZWUtd2hvbGVyb3dcIikucmVtb3ZlKCk7XG5cdFx0XHR9XG5cdFx0XHRwYXJlbnQudGVhcmRvd24uY2FsbCh0aGlzKTtcblx0XHR9O1xuXHRcdHRoaXMucmVkcmF3X25vZGUgPSBmdW5jdGlvbihvYmosIGRlZXAsIGNhbGxiYWNrKSB7XG5cdFx0XHRvYmogPSBwYXJlbnQucmVkcmF3X25vZGUuY2FsbCh0aGlzLCBvYmosIGRlZXAsIGNhbGxiYWNrKTtcblx0XHRcdGlmKG9iaikge1xuXHRcdFx0XHR2YXIgdG1wID0gZGl2LmNsb25lTm9kZSh0cnVlKTtcblx0XHRcdFx0Ly90bXAuc3R5bGUuaGVpZ2h0ID0gdGhpcy5fZGF0YS5jb3JlLmxpX2hlaWdodCArICdweCc7XG5cdFx0XHRcdGlmKCQuaW5BcnJheShvYmouaWQsIHRoaXMuX2RhdGEuY29yZS5zZWxlY3RlZCkgIT09IC0xKSB7IHRtcC5jbGFzc05hbWUgKz0gJyBqc3RyZWUtd2hvbGVyb3ctY2xpY2tlZCc7IH1cblx0XHRcdFx0b2JqLmluc2VydEJlZm9yZSh0bXAsIG9iai5jaGlsZE5vZGVzWzBdKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBvYmo7XG5cdFx0fTtcblx0fTtcblx0Ly8gaW5jbHVkZSB0aGUgd2hvbGVyb3cgcGx1Z2luIGJ5IGRlZmF1bHRcblx0Ly8gJC5qc3RyZWUuZGVmYXVsdHMucGx1Z2lucy5wdXNoKFwid2hvbGVyb3dcIik7XG5cbn0pKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ2FsYXh5L3NjcmlwdHMvbGlicy9qcXVlcnkvanN0cmVlLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjhcbi8vIG1vZHVsZSBjaHVua3MgPSAxIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///128\n");

/***/ }),

/***/ 13:
/*!*****************************************************!*\
  !*** ./galaxy/scripts/mvc/library/library-model.js ***!
  \*****************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(Backbone) {\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _libraryUtil = __webpack_require__(/*! mvc/library/library-util */ 297);\n\nvar _libraryUtil2 = _interopRequireDefault(_libraryUtil);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// ============================================================================\n// LIBRARY RELATED MODELS\n\nvar Library = Backbone.Model.extend({\n    urlRoot: Galaxy.root + \"api/libraries/\",\n\n    /** based on show_deleted would this lib show in the list of lib's?\n     *  @param {Boolean} show_deleted are we including deleted libraries?\n     */\n    isVisible: function isVisible(show_deleted) {\n        var isVisible = true;\n        if (!show_deleted && this.get(\"deleted\")) {\n            isVisible = false;\n        }\n        return isVisible;\n    }\n});\n\nvar Libraries = Backbone.Collection.extend({\n    urlRoot: Galaxy.root + \"api/libraries\",\n\n    model: Library,\n\n    initialize: function initialize(options) {\n        options = options || {};\n    },\n\n    search: function search(search_term) {\n        /**\n         * Search the collection and return only the models that have\n         * the search term in their names.\n         * [the term to search]\n         * @type {string}\n         */\n        if (search_term == \"\") return this;\n        var lowercase_term = search_term.toLowerCase();\n        return this.filter(function (data) {\n            var lowercase_name = data.get(\"name\").toLowerCase();\n            return lowercase_name.indexOf(lowercase_term) !== -1;\n        });\n    },\n\n    /** Get every 'shown' library in this collection based on deleted filter\n     *  @param {Boolean} show_deleted are we including deleted libraries?\n     *  @returns array of library models\n     */\n    getVisible: function getVisible(show_deleted, filters) {\n        filters = filters || [];\n        var filteredLibraries = new Libraries(this.filter(function (item) {\n            return item.isVisible(show_deleted);\n        }));\n\n        return filteredLibraries;\n    },\n\n    sortLibraries: function sortLibraries(sort_key, sort_order) {\n        this.comparator = _libraryUtil2.default.generateLibraryComparator(sort_key, sort_order);\n        this.sort();\n    }\n});\n\n// ============================================================================\n// FOLDER RELATED MODELS\n\nvar LibraryItem = Backbone.Model.extend({});\n\nvar Ldda = LibraryItem.extend({\n    urlRoot: Galaxy.root + \"api/libraries/datasets/\"\n});\n\nvar FolderAsModel = LibraryItem.extend({\n    urlRoot: Galaxy.root + \"api/folders/\"\n});\n\nvar Folder = Backbone.Collection.extend({\n    model: LibraryItem,\n\n    sortFolder: function sortFolder(sort_key, sort_order) {\n        this.comparator = _libraryUtil2.default.generateFolderComparator(sort_key, sort_order);\n        this.sort();\n    }\n});\n\nvar FolderContainer = Backbone.Model.extend({\n    defaults: {\n        folder: new Folder(),\n        urlRoot: Galaxy.root + \"api/folders/\",\n        id: \"unknown\"\n    },\n    parse: function parse(obj) {\n        // empty the collection\n        this.get(\"folder\").reset();\n        // response is not a simple array, it contains metadata\n        // this will update the inner collection\n        for (var i = 0; i < obj.folder_contents.length; i++) {\n            if (obj.folder_contents[i].type === \"folder\") {\n                var folder_item = new FolderAsModel(obj.folder_contents[i]);\n                this.get(\"folder\").add(folder_item);\n            } else if (obj.folder_contents[i].type === \"file\") {\n                var file_item = new Ldda(obj.folder_contents[i]);\n                this.get(\"folder\").add(file_item);\n            } else {\n                Galaxy.emit.error(\"Unknown folder item type encountered while parsing response.\");\n            }\n        }\n        return obj;\n    }\n});\n\n// ============================================================================\n// HISTORY RELATED MODELS\n// TODO UNITE\n\nvar HistoryItem = Backbone.Model.extend({\n    urlRoot: Galaxy.root + \"api/histories/\"\n});\n\nvar HistoryContents = Backbone.Collection.extend({\n    urlRoot: Galaxy.root + \"api/histories/\",\n    initialize: function initialize(options) {\n        this.id = options.id;\n    },\n    url: function url() {\n        return this.urlRoot + this.id + \"/contents\";\n    },\n    model: HistoryItem\n});\n\nvar GalaxyHistory = Backbone.Model.extend({\n    urlRoot: Galaxy.root + \"api/histories/\"\n});\n\nvar GalaxyHistories = Backbone.Collection.extend({\n    url: Galaxy.root + \"api/histories\",\n    model: GalaxyHistory\n});\n\n// ============================================================================\n// JSTREE MODEL\n/** Represents folder structure parsable by the jstree component.\n *\n */\n\nvar Jstree = Backbone.Model.extend({\n    urlRoot: Galaxy.root + \"api/remote_files\"\n});\n\nexports.default = {\n    Library: Library,\n    Libraries: Libraries,\n    Item: Ldda,\n    Ldda: Ldda,\n    FolderAsModel: FolderAsModel,\n    Folder: Folder,\n    FolderContainer: FolderContainer,\n    HistoryItem: HistoryItem,\n    HistoryContents: HistoryContents,\n    GalaxyHistory: GalaxyHistory,\n    GalaxyHistories: GalaxyHistories,\n    Jstree: Jstree\n};\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! libs/backbone */ 2)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZ2FsYXh5L3NjcmlwdHMvbXZjL2xpYnJhcnkvbGlicmFyeS1tb2RlbC5qcz82MDBhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBtb2RfdXRpbCBmcm9tIFwibXZjL2xpYnJhcnkvbGlicmFyeS11dGlsXCI7XG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBMSUJSQVJZIFJFTEFURUQgTU9ERUxTXG5cbnZhciBMaWJyYXJ5ID0gQmFja2JvbmUuTW9kZWwuZXh0ZW5kKHtcbiAgICB1cmxSb290OiBgJHtHYWxheHkucm9vdH1hcGkvbGlicmFyaWVzL2AsXG5cbiAgICAvKiogYmFzZWQgb24gc2hvd19kZWxldGVkIHdvdWxkIHRoaXMgbGliIHNob3cgaW4gdGhlIGxpc3Qgb2YgbGliJ3M/XG4gICAgICogIEBwYXJhbSB7Qm9vbGVhbn0gc2hvd19kZWxldGVkIGFyZSB3ZSBpbmNsdWRpbmcgZGVsZXRlZCBsaWJyYXJpZXM/XG4gICAgICovXG4gICAgaXNWaXNpYmxlOiBmdW5jdGlvbihzaG93X2RlbGV0ZWQpIHtcbiAgICAgICAgdmFyIGlzVmlzaWJsZSA9IHRydWU7XG4gICAgICAgIGlmICghc2hvd19kZWxldGVkICYmIHRoaXMuZ2V0KFwiZGVsZXRlZFwiKSkge1xuICAgICAgICAgICAgaXNWaXNpYmxlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzVmlzaWJsZTtcbiAgICB9XG59KTtcblxudmFyIExpYnJhcmllcyA9IEJhY2tib25lLkNvbGxlY3Rpb24uZXh0ZW5kKHtcbiAgICB1cmxSb290OiBgJHtHYWxheHkucm9vdH1hcGkvbGlicmFyaWVzYCxcblxuICAgIG1vZGVsOiBMaWJyYXJ5LFxuXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB9LFxuXG4gICAgc2VhcmNoOiBmdW5jdGlvbihzZWFyY2hfdGVybSkge1xuICAgICAgICAvKipcbiAgICAgICAgICogU2VhcmNoIHRoZSBjb2xsZWN0aW9uIGFuZCByZXR1cm4gb25seSB0aGUgbW9kZWxzIHRoYXQgaGF2ZVxuICAgICAgICAgKiB0aGUgc2VhcmNoIHRlcm0gaW4gdGhlaXIgbmFtZXMuXG4gICAgICAgICAqIFt0aGUgdGVybSB0byBzZWFyY2hdXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICBpZiAoc2VhcmNoX3Rlcm0gPT0gXCJcIikgcmV0dXJuIHRoaXM7XG4gICAgICAgIHZhciBsb3dlcmNhc2VfdGVybSA9IHNlYXJjaF90ZXJtLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbHRlcihkYXRhID0+IHtcbiAgICAgICAgICAgIHZhciBsb3dlcmNhc2VfbmFtZSA9IGRhdGEuZ2V0KFwibmFtZVwiKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgcmV0dXJuIGxvd2VyY2FzZV9uYW1lLmluZGV4T2YobG93ZXJjYXNlX3Rlcm0pICE9PSAtMTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKiBHZXQgZXZlcnkgJ3Nob3duJyBsaWJyYXJ5IGluIHRoaXMgY29sbGVjdGlvbiBiYXNlZCBvbiBkZWxldGVkIGZpbHRlclxuICAgICAqICBAcGFyYW0ge0Jvb2xlYW59IHNob3dfZGVsZXRlZCBhcmUgd2UgaW5jbHVkaW5nIGRlbGV0ZWQgbGlicmFyaWVzP1xuICAgICAqICBAcmV0dXJucyBhcnJheSBvZiBsaWJyYXJ5IG1vZGVsc1xuICAgICAqL1xuICAgIGdldFZpc2libGU6IGZ1bmN0aW9uKHNob3dfZGVsZXRlZCwgZmlsdGVycykge1xuICAgICAgICBmaWx0ZXJzID0gZmlsdGVycyB8fCBbXTtcbiAgICAgICAgdmFyIGZpbHRlcmVkTGlicmFyaWVzID0gbmV3IExpYnJhcmllcyh0aGlzLmZpbHRlcihpdGVtID0+IGl0ZW0uaXNWaXNpYmxlKHNob3dfZGVsZXRlZCkpKTtcblxuICAgICAgICByZXR1cm4gZmlsdGVyZWRMaWJyYXJpZXM7XG4gICAgfSxcblxuICAgIHNvcnRMaWJyYXJpZXM6IGZ1bmN0aW9uKHNvcnRfa2V5LCBzb3J0X29yZGVyKSB7XG4gICAgICAgIHRoaXMuY29tcGFyYXRvciA9IG1vZF91dGlsLmdlbmVyYXRlTGlicmFyeUNvbXBhcmF0b3Ioc29ydF9rZXksIHNvcnRfb3JkZXIpO1xuICAgICAgICB0aGlzLnNvcnQoKTtcbiAgICB9XG59KTtcblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gRk9MREVSIFJFTEFURUQgTU9ERUxTXG5cbnZhciBMaWJyYXJ5SXRlbSA9IEJhY2tib25lLk1vZGVsLmV4dGVuZCh7fSk7XG5cbnZhciBMZGRhID0gTGlicmFyeUl0ZW0uZXh0ZW5kKHtcbiAgICB1cmxSb290OiBgJHtHYWxheHkucm9vdH1hcGkvbGlicmFyaWVzL2RhdGFzZXRzL2Bcbn0pO1xuXG52YXIgRm9sZGVyQXNNb2RlbCA9IExpYnJhcnlJdGVtLmV4dGVuZCh7XG4gICAgdXJsUm9vdDogYCR7R2FsYXh5LnJvb3R9YXBpL2ZvbGRlcnMvYFxufSk7XG5cbnZhciBGb2xkZXIgPSBCYWNrYm9uZS5Db2xsZWN0aW9uLmV4dGVuZCh7XG4gICAgbW9kZWw6IExpYnJhcnlJdGVtLFxuXG4gICAgc29ydEZvbGRlcjogZnVuY3Rpb24oc29ydF9rZXksIHNvcnRfb3JkZXIpIHtcbiAgICAgICAgdGhpcy5jb21wYXJhdG9yID0gbW9kX3V0aWwuZ2VuZXJhdGVGb2xkZXJDb21wYXJhdG9yKHNvcnRfa2V5LCBzb3J0X29yZGVyKTtcbiAgICAgICAgdGhpcy5zb3J0KCk7XG4gICAgfVxufSk7XG5cbnZhciBGb2xkZXJDb250YWluZXIgPSBCYWNrYm9uZS5Nb2RlbC5leHRlbmQoe1xuICAgIGRlZmF1bHRzOiB7XG4gICAgICAgIGZvbGRlcjogbmV3IEZvbGRlcigpLFxuICAgICAgICB1cmxSb290OiBgJHtHYWxheHkucm9vdH1hcGkvZm9sZGVycy9gLFxuICAgICAgICBpZDogXCJ1bmtub3duXCJcbiAgICB9LFxuICAgIHBhcnNlOiBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgLy8gZW1wdHkgdGhlIGNvbGxlY3Rpb25cbiAgICAgICAgdGhpcy5nZXQoXCJmb2xkZXJcIikucmVzZXQoKTtcbiAgICAgICAgLy8gcmVzcG9uc2UgaXMgbm90IGEgc2ltcGxlIGFycmF5LCBpdCBjb250YWlucyBtZXRhZGF0YVxuICAgICAgICAvLyB0aGlzIHdpbGwgdXBkYXRlIHRoZSBpbm5lciBjb2xsZWN0aW9uXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqLmZvbGRlcl9jb250ZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKG9iai5mb2xkZXJfY29udGVudHNbaV0udHlwZSA9PT0gXCJmb2xkZXJcIikge1xuICAgICAgICAgICAgICAgIHZhciBmb2xkZXJfaXRlbSA9IG5ldyBGb2xkZXJBc01vZGVsKG9iai5mb2xkZXJfY29udGVudHNbaV0pO1xuICAgICAgICAgICAgICAgIHRoaXMuZ2V0KFwiZm9sZGVyXCIpLmFkZChmb2xkZXJfaXRlbSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG9iai5mb2xkZXJfY29udGVudHNbaV0udHlwZSA9PT0gXCJmaWxlXCIpIHtcbiAgICAgICAgICAgICAgICB2YXIgZmlsZV9pdGVtID0gbmV3IExkZGEob2JqLmZvbGRlcl9jb250ZW50c1tpXSk7XG4gICAgICAgICAgICAgICAgdGhpcy5nZXQoXCJmb2xkZXJcIikuYWRkKGZpbGVfaXRlbSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIEdhbGF4eS5lbWl0LmVycm9yKFwiVW5rbm93biBmb2xkZXIgaXRlbSB0eXBlIGVuY291bnRlcmVkIHdoaWxlIHBhcnNpbmcgcmVzcG9uc2UuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxufSk7XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIEhJU1RPUlkgUkVMQVRFRCBNT0RFTFNcbi8vIFRPRE8gVU5JVEVcblxudmFyIEhpc3RvcnlJdGVtID0gQmFja2JvbmUuTW9kZWwuZXh0ZW5kKHtcbiAgICB1cmxSb290OiBgJHtHYWxheHkucm9vdH1hcGkvaGlzdG9yaWVzL2Bcbn0pO1xuXG52YXIgSGlzdG9yeUNvbnRlbnRzID0gQmFja2JvbmUuQ29sbGVjdGlvbi5leHRlbmQoe1xuICAgIHVybFJvb3Q6IGAke0dhbGF4eS5yb290fWFwaS9oaXN0b3JpZXMvYCxcbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuaWQgPSBvcHRpb25zLmlkO1xuICAgIH0sXG4gICAgdXJsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMudXJsUm9vdCArIHRoaXMuaWR9L2NvbnRlbnRzYDtcbiAgICB9LFxuICAgIG1vZGVsOiBIaXN0b3J5SXRlbVxufSk7XG5cbnZhciBHYWxheHlIaXN0b3J5ID0gQmFja2JvbmUuTW9kZWwuZXh0ZW5kKHtcbiAgICB1cmxSb290OiBgJHtHYWxheHkucm9vdH1hcGkvaGlzdG9yaWVzL2Bcbn0pO1xuXG52YXIgR2FsYXh5SGlzdG9yaWVzID0gQmFja2JvbmUuQ29sbGVjdGlvbi5leHRlbmQoe1xuICAgIHVybDogYCR7R2FsYXh5LnJvb3R9YXBpL2hpc3Rvcmllc2AsXG4gICAgbW9kZWw6IEdhbGF4eUhpc3Rvcnlcbn0pO1xuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBKU1RSRUUgTU9ERUxcbi8qKiBSZXByZXNlbnRzIGZvbGRlciBzdHJ1Y3R1cmUgcGFyc2FibGUgYnkgdGhlIGpzdHJlZSBjb21wb25lbnQuXG4gKlxuICovXG5cbnZhciBKc3RyZWUgPSBCYWNrYm9uZS5Nb2RlbC5leHRlbmQoe1xuICAgIHVybFJvb3Q6IGAke0dhbGF4eS5yb290fWFwaS9yZW1vdGVfZmlsZXNgXG59KTtcblxuZXhwb3J0IGRlZmF1bHQge1xuICAgIExpYnJhcnk6IExpYnJhcnksXG4gICAgTGlicmFyaWVzOiBMaWJyYXJpZXMsXG4gICAgSXRlbTogTGRkYSxcbiAgICBMZGRhOiBMZGRhLFxuICAgIEZvbGRlckFzTW9kZWw6IEZvbGRlckFzTW9kZWwsXG4gICAgRm9sZGVyOiBGb2xkZXIsXG4gICAgRm9sZGVyQ29udGFpbmVyOiBGb2xkZXJDb250YWluZXIsXG4gICAgSGlzdG9yeUl0ZW06IEhpc3RvcnlJdGVtLFxuICAgIEhpc3RvcnlDb250ZW50czogSGlzdG9yeUNvbnRlbnRzLFxuICAgIEdhbGF4eUhpc3Rvcnk6IEdhbGF4eUhpc3RvcnksXG4gICAgR2FsYXh5SGlzdG9yaWVzOiBHYWxheHlIaXN0b3JpZXMsXG4gICAgSnN0cmVlOiBKc3RyZWVcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gZ2FsYXh5L3NjcmlwdHMvbXZjL2xpYnJhcnkvbGlicmFyeS1tb2RlbC5qcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFaQTtBQUNBO0FBY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUF0Q0E7QUFDQTtBQXdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFDQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXZCQTtBQUNBO0FBeUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFSQTtBQUNBO0FBVUE7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFGQTtBQUNBO0FBSUE7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVpBO0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///13\n");

/***/ }),

/***/ 17:
/*!*******************************************************!*\
  !*** ./galaxy/scripts/mvc/toolshed/toolshed-model.js ***!
  \*******************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(Backbone, _) {\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nvar ToolShedModel = Backbone.Model.extend({\n    defaults: {\n        url: \"https://toolshed.g2.bx.psu.edu/\",\n        name: \"Galaxy Main Tool Shed\"\n    },\n    urlRoot: Galaxy.root + \"api/tool_shed\"\n});\n\nvar ToolShedsCollection = Backbone.Collection.extend({\n    url: Galaxy.root + \"api/tool_shed\",\n    model: ToolShedModel\n});\n\nvar ToolShedCategoriesModel = Backbone.Model.extend({\n    defaults: [{}],\n    urlRoot: Galaxy.root + \"api/tool_shed/contents\"\n});\n\nvar ToolShedCategoriesCollection = Backbone.Collection.extend({\n    url: Galaxy.root + \"api/tool_shed/contents\",\n    model: ToolShedCategoriesModel\n});\n\nvar ToolShedCategoryModel = Backbone.Model.extend({\n    defaults: [{}],\n    urlRoot: Galaxy.root + \"api/tool_shed/category\"\n});\n\nvar ToolShedCategoryCollection = Backbone.Collection.extend({\n    url: Galaxy.root + \"api/tool_shed/category\",\n    model: ToolShedCategoryModel\n});\n\nvar ToolShedRepositoryModel = Backbone.Model.extend({\n    defaults: [{}],\n    urlRoot: Galaxy.root + \"api/tool_shed/repository\"\n});\n\nvar ToolShedRepositoryCollection = Backbone.Collection.extend({\n    url: Galaxy.root + \"api/tool_shed/repository\",\n    model: ToolShedRepositoryModel\n});\n\nvar RepoQueueModel = Backbone.Model.extend({\n    url: \"#\"\n});\n\nvar RepoQueueCollection = Backbone.Collection.extend({\n    url: \"#\",\n    model: RepoQueueModel,\n    fetch: function fetch() {\n        var collection = this;\n        var repositories = Array();\n        var repositories_enc = JSON.parse(localStorage.repositories);\n        var queue_keys = Object.keys(repositories_enc);\n        _.each(queue_keys, function (key) {\n            var repo = repositories_enc[key];\n            repo.queue_key = key;\n            repositories.push(repo);\n        });\n        collection.reset(repositories);\n        return Backbone.Collection.prototype.fetch.call(this);\n    }\n});\n\nvar RepoStatusModel = Backbone.Model.extend({\n    defaults: [{}],\n    urlRoot: Galaxy.root + \"api/tool_shed/status\"\n});\n\nvar RepoStatusCollection = Backbone.Collection.extend({\n    url: Galaxy.root + \"api/tool_shed/status\",\n    model: RepoStatusModel\n});\n\nvar WorkflowToolsModel = Backbone.Model.extend({\n    defaults: [{}],\n    urlRoot: Galaxy.root + \"api/workflows?missing_tools=True\"\n});\n\nvar WorkflowToolsCollection = Backbone.Collection.extend({\n    url: Galaxy.root + \"api/workflows?missing_tools=True\",\n    model: WorkflowToolsModel\n});\n\nexports.default = {\n    ShedModel: ToolShedModel,\n    ShedsCollection: ToolShedsCollection,\n    Category: ToolShedCategoriesModel,\n    Categories: ToolShedCategoriesCollection,\n    CategoryModel: ToolShedCategoryModel,\n    CategoryCollection: ToolShedCategoryCollection,\n    RepositoryModel: ToolShedRepositoryModel,\n    RepositoryCollection: ToolShedRepositoryCollection,\n    RepoQueue: RepoQueueCollection,\n    RepoStatus: RepoStatusCollection,\n    WorkflowTools: WorkflowToolsCollection\n};\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! libs/backbone */ 2), __webpack_require__(/*! underscore */ 1)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTcuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZ2FsYXh5L3NjcmlwdHMvbXZjL3Rvb2xzaGVkL3Rvb2xzaGVkLW1vZGVsLmpzP2I1MzIiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIFRvb2xTaGVkTW9kZWwgPSBCYWNrYm9uZS5Nb2RlbC5leHRlbmQoe1xuICAgIGRlZmF1bHRzOiB7XG4gICAgICAgIHVybDogXCJodHRwczovL3Rvb2xzaGVkLmcyLmJ4LnBzdS5lZHUvXCIsXG4gICAgICAgIG5hbWU6IFwiR2FsYXh5IE1haW4gVG9vbCBTaGVkXCJcbiAgICB9LFxuICAgIHVybFJvb3Q6IGAke0dhbGF4eS5yb290fWFwaS90b29sX3NoZWRgXG59KTtcblxudmFyIFRvb2xTaGVkc0NvbGxlY3Rpb24gPSBCYWNrYm9uZS5Db2xsZWN0aW9uLmV4dGVuZCh7XG4gICAgdXJsOiBgJHtHYWxheHkucm9vdH1hcGkvdG9vbF9zaGVkYCxcbiAgICBtb2RlbDogVG9vbFNoZWRNb2RlbFxufSk7XG5cbnZhciBUb29sU2hlZENhdGVnb3JpZXNNb2RlbCA9IEJhY2tib25lLk1vZGVsLmV4dGVuZCh7XG4gICAgZGVmYXVsdHM6IFt7fV0sXG4gICAgdXJsUm9vdDogYCR7R2FsYXh5LnJvb3R9YXBpL3Rvb2xfc2hlZC9jb250ZW50c2Bcbn0pO1xuXG52YXIgVG9vbFNoZWRDYXRlZ29yaWVzQ29sbGVjdGlvbiA9IEJhY2tib25lLkNvbGxlY3Rpb24uZXh0ZW5kKHtcbiAgICB1cmw6IGAke0dhbGF4eS5yb290fWFwaS90b29sX3NoZWQvY29udGVudHNgLFxuICAgIG1vZGVsOiBUb29sU2hlZENhdGVnb3JpZXNNb2RlbFxufSk7XG5cbnZhciBUb29sU2hlZENhdGVnb3J5TW9kZWwgPSBCYWNrYm9uZS5Nb2RlbC5leHRlbmQoe1xuICAgIGRlZmF1bHRzOiBbe31dLFxuICAgIHVybFJvb3Q6IGAke0dhbGF4eS5yb290fWFwaS90b29sX3NoZWQvY2F0ZWdvcnlgXG59KTtcblxudmFyIFRvb2xTaGVkQ2F0ZWdvcnlDb2xsZWN0aW9uID0gQmFja2JvbmUuQ29sbGVjdGlvbi5leHRlbmQoe1xuICAgIHVybDogYCR7R2FsYXh5LnJvb3R9YXBpL3Rvb2xfc2hlZC9jYXRlZ29yeWAsXG4gICAgbW9kZWw6IFRvb2xTaGVkQ2F0ZWdvcnlNb2RlbFxufSk7XG5cbnZhciBUb29sU2hlZFJlcG9zaXRvcnlNb2RlbCA9IEJhY2tib25lLk1vZGVsLmV4dGVuZCh7XG4gICAgZGVmYXVsdHM6IFt7fV0sXG4gICAgdXJsUm9vdDogYCR7R2FsYXh5LnJvb3R9YXBpL3Rvb2xfc2hlZC9yZXBvc2l0b3J5YFxufSk7XG5cbnZhciBUb29sU2hlZFJlcG9zaXRvcnlDb2xsZWN0aW9uID0gQmFja2JvbmUuQ29sbGVjdGlvbi5leHRlbmQoe1xuICAgIHVybDogYCR7R2FsYXh5LnJvb3R9YXBpL3Rvb2xfc2hlZC9yZXBvc2l0b3J5YCxcbiAgICBtb2RlbDogVG9vbFNoZWRSZXBvc2l0b3J5TW9kZWxcbn0pO1xuXG52YXIgUmVwb1F1ZXVlTW9kZWwgPSBCYWNrYm9uZS5Nb2RlbC5leHRlbmQoe1xuICAgIHVybDogXCIjXCJcbn0pO1xuXG52YXIgUmVwb1F1ZXVlQ29sbGVjdGlvbiA9IEJhY2tib25lLkNvbGxlY3Rpb24uZXh0ZW5kKHtcbiAgICB1cmw6IFwiI1wiLFxuICAgIG1vZGVsOiBSZXBvUXVldWVNb2RlbCxcbiAgICBmZXRjaDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjb2xsZWN0aW9uID0gdGhpcztcbiAgICAgICAgdmFyIHJlcG9zaXRvcmllcyA9IEFycmF5KCk7XG4gICAgICAgIHZhciByZXBvc2l0b3JpZXNfZW5jID0gSlNPTi5wYXJzZShsb2NhbFN0b3JhZ2UucmVwb3NpdG9yaWVzKTtcbiAgICAgICAgdmFyIHF1ZXVlX2tleXMgPSBPYmplY3Qua2V5cyhyZXBvc2l0b3JpZXNfZW5jKTtcbiAgICAgICAgXy5lYWNoKHF1ZXVlX2tleXMsIGtleSA9PiB7XG4gICAgICAgICAgICB2YXIgcmVwbyA9IHJlcG9zaXRvcmllc19lbmNba2V5XTtcbiAgICAgICAgICAgIHJlcG8ucXVldWVfa2V5ID0ga2V5O1xuICAgICAgICAgICAgcmVwb3NpdG9yaWVzLnB1c2gocmVwbyk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb2xsZWN0aW9uLnJlc2V0KHJlcG9zaXRvcmllcyk7XG4gICAgICAgIHJldHVybiBCYWNrYm9uZS5Db2xsZWN0aW9uLnByb3RvdHlwZS5mZXRjaC5jYWxsKHRoaXMpO1xuICAgIH1cbn0pO1xuXG52YXIgUmVwb1N0YXR1c01vZGVsID0gQmFja2JvbmUuTW9kZWwuZXh0ZW5kKHtcbiAgICBkZWZhdWx0czogW3t9XSxcbiAgICB1cmxSb290OiBgJHtHYWxheHkucm9vdH1hcGkvdG9vbF9zaGVkL3N0YXR1c2Bcbn0pO1xuXG52YXIgUmVwb1N0YXR1c0NvbGxlY3Rpb24gPSBCYWNrYm9uZS5Db2xsZWN0aW9uLmV4dGVuZCh7XG4gICAgdXJsOiBgJHtHYWxheHkucm9vdH1hcGkvdG9vbF9zaGVkL3N0YXR1c2AsXG4gICAgbW9kZWw6IFJlcG9TdGF0dXNNb2RlbFxufSk7XG5cbnZhciBXb3JrZmxvd1Rvb2xzTW9kZWwgPSBCYWNrYm9uZS5Nb2RlbC5leHRlbmQoe1xuICAgIGRlZmF1bHRzOiBbe31dLFxuICAgIHVybFJvb3Q6IGAke0dhbGF4eS5yb290fWFwaS93b3JrZmxvd3M/bWlzc2luZ190b29scz1UcnVlYFxufSk7XG5cbnZhciBXb3JrZmxvd1Rvb2xzQ29sbGVjdGlvbiA9IEJhY2tib25lLkNvbGxlY3Rpb24uZXh0ZW5kKHtcbiAgICB1cmw6IGAke0dhbGF4eS5yb290fWFwaS93b3JrZmxvd3M/bWlzc2luZ190b29scz1UcnVlYCxcbiAgICBtb2RlbDogV29ya2Zsb3dUb29sc01vZGVsXG59KTtcblxuZXhwb3J0IGRlZmF1bHQge1xuICAgIFNoZWRNb2RlbDogVG9vbFNoZWRNb2RlbCxcbiAgICBTaGVkc0NvbGxlY3Rpb246IFRvb2xTaGVkc0NvbGxlY3Rpb24sXG4gICAgQ2F0ZWdvcnk6IFRvb2xTaGVkQ2F0ZWdvcmllc01vZGVsLFxuICAgIENhdGVnb3JpZXM6IFRvb2xTaGVkQ2F0ZWdvcmllc0NvbGxlY3Rpb24sXG4gICAgQ2F0ZWdvcnlNb2RlbDogVG9vbFNoZWRDYXRlZ29yeU1vZGVsLFxuICAgIENhdGVnb3J5Q29sbGVjdGlvbjogVG9vbFNoZWRDYXRlZ29yeUNvbGxlY3Rpb24sXG4gICAgUmVwb3NpdG9yeU1vZGVsOiBUb29sU2hlZFJlcG9zaXRvcnlNb2RlbCxcbiAgICBSZXBvc2l0b3J5Q29sbGVjdGlvbjogVG9vbFNoZWRSZXBvc2l0b3J5Q29sbGVjdGlvbixcbiAgICBSZXBvUXVldWU6IFJlcG9RdWV1ZUNvbGxlY3Rpb24sXG4gICAgUmVwb1N0YXR1czogUmVwb1N0YXR1c0NvbGxlY3Rpb24sXG4gICAgV29ya2Zsb3dUb29sczogV29ya2Zsb3dUb29sc0NvbGxlY3Rpb25cbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gZ2FsYXh5L3NjcmlwdHMvbXZjL3Rvb2xzaGVkL3Rvb2xzaGVkLW1vZGVsLmpzIl0sIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUxBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFGQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBRkE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUZBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFGQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBRkE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUZBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFGQTtBQUNBO0FBSUE7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWZBO0FBQ0E7QUFpQkE7QUFDQTtBQUNBO0FBRkE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUZBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFGQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBRkE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVhBO0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///17\n");

/***/ }),

/***/ 18:
/*!*********************************************!*\
  !*** ./galaxy/scripts/mvc/toolshed/util.js ***!
  \*********************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function($) {\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nvar searchShed = function searchShed(request, response) {\n    var that = this;\n    var shed_url = this.shed_url;\n    var base_url = Galaxy.root + \"api/tool_shed/search\";\n    $.get(base_url, { term: request.term, tool_shed_url: shed_url }, function (data) {\n        var result_list = that.shedParser(data);\n        response(result_list);\n    });\n};\n\nvar shedParser = function shedParser(jsondata) {\n    var results = [];\n    var hits = jsondata.hits;\n    $.each(hits, function (hit) {\n        var record = hits[hit];\n        var label = record.repository.name + \" by \" + record.repository.repo_owner_username + \": \" + record.repository.description;\n        var result = { value: record.repository.id, label: label };\n        results.push(result);\n    });\n    return results;\n};\n\nvar addToQueue = function addToQueue(metadata) {\n    if (metadata.tool_shed_url.substr(-1) == \"/\") {\n        metadata.tool_shed_url = metadata.tool_shed_url.substr(0, metadata.tool_shed_url.length - 1);\n    }\n    var key = metadata.tool_shed_url + \"|\" + metadata.repository_id + \"|\" + metadata.changeset_revision;\n    var queued_repos = new Object();\n    if (localStorage.repositories) {\n        queued_repos = JSON.parse(localStorage.repositories);\n    }\n    queued_repos[key] = metadata;\n    localStorage.repositories = JSON.stringify(queued_repos);\n};\n\nvar queueLength = function queueLength() {\n    if (localStorage.hasOwnProperty(\"repositories\")) {\n        var repo_queue = JSON.parse(localStorage.repositories);\n        var queue_length = Object.keys(repo_queue).length;\n        return queue_length;\n    } else {\n        return 0;\n    }\n};\n\nexports.default = {\n    searchShed: searchShed,\n    shedParser: shedParser,\n    addToQueue: addToQueue,\n    queueLength: queueLength\n};\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! jquery */ 0)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTguanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZ2FsYXh5L3NjcmlwdHMvbXZjL3Rvb2xzaGVkL3V0aWwuanM/OWU5NiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgc2VhcmNoU2hlZCA9IGZ1bmN0aW9uKHJlcXVlc3QsIHJlc3BvbnNlKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIHZhciBzaGVkX3VybCA9IHRoaXMuc2hlZF91cmw7XG4gICAgdmFyIGJhc2VfdXJsID0gYCR7R2FsYXh5LnJvb3R9YXBpL3Rvb2xfc2hlZC9zZWFyY2hgO1xuICAgICQuZ2V0KGJhc2VfdXJsLCB7IHRlcm06IHJlcXVlc3QudGVybSwgdG9vbF9zaGVkX3VybDogc2hlZF91cmwgfSwgZGF0YSA9PiB7XG4gICAgICAgIHZhciByZXN1bHRfbGlzdCA9IHRoYXQuc2hlZFBhcnNlcihkYXRhKTtcbiAgICAgICAgcmVzcG9uc2UocmVzdWx0X2xpc3QpO1xuICAgIH0pO1xufTtcblxudmFyIHNoZWRQYXJzZXIgPSBqc29uZGF0YSA9PiB7XG4gICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICB2YXIgaGl0cyA9IGpzb25kYXRhLmhpdHM7XG4gICAgJC5lYWNoKGhpdHMsIGhpdCA9PiB7XG4gICAgICAgIHZhciByZWNvcmQgPSBoaXRzW2hpdF07XG4gICAgICAgIHZhciBsYWJlbCA9IGAke3JlY29yZC5yZXBvc2l0b3J5Lm5hbWV9IGJ5ICR7cmVjb3JkLnJlcG9zaXRvcnkucmVwb19vd25lcl91c2VybmFtZX06ICR7XG4gICAgICAgICAgICByZWNvcmQucmVwb3NpdG9yeS5kZXNjcmlwdGlvblxuICAgICAgICB9YDtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHsgdmFsdWU6IHJlY29yZC5yZXBvc2l0b3J5LmlkLCBsYWJlbDogbGFiZWwgfTtcbiAgICAgICAgcmVzdWx0cy5wdXNoKHJlc3VsdCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdHM7XG59O1xuXG52YXIgYWRkVG9RdWV1ZSA9IG1ldGFkYXRhID0+IHtcbiAgICBpZiAobWV0YWRhdGEudG9vbF9zaGVkX3VybC5zdWJzdHIoLTEpID09IFwiL1wiKSB7XG4gICAgICAgIG1ldGFkYXRhLnRvb2xfc2hlZF91cmwgPSBtZXRhZGF0YS50b29sX3NoZWRfdXJsLnN1YnN0cigwLCBtZXRhZGF0YS50b29sX3NoZWRfdXJsLmxlbmd0aCAtIDEpO1xuICAgIH1cbiAgICB2YXIga2V5ID0gYCR7bWV0YWRhdGEudG9vbF9zaGVkX3VybH18JHttZXRhZGF0YS5yZXBvc2l0b3J5X2lkfXwke21ldGFkYXRhLmNoYW5nZXNldF9yZXZpc2lvbn1gO1xuICAgIHZhciBxdWV1ZWRfcmVwb3MgPSBuZXcgT2JqZWN0KCk7XG4gICAgaWYgKGxvY2FsU3RvcmFnZS5yZXBvc2l0b3JpZXMpIHtcbiAgICAgICAgcXVldWVkX3JlcG9zID0gSlNPTi5wYXJzZShsb2NhbFN0b3JhZ2UucmVwb3NpdG9yaWVzKTtcbiAgICB9XG4gICAgcXVldWVkX3JlcG9zW2tleV0gPSBtZXRhZGF0YTtcbiAgICBsb2NhbFN0b3JhZ2UucmVwb3NpdG9yaWVzID0gSlNPTi5zdHJpbmdpZnkocXVldWVkX3JlcG9zKTtcbn07XG5cbnZhciBxdWV1ZUxlbmd0aCA9ICgpID0+IHtcbiAgICBpZiAobG9jYWxTdG9yYWdlLmhhc093blByb3BlcnR5KFwicmVwb3NpdG9yaWVzXCIpKSB7XG4gICAgICAgIHZhciByZXBvX3F1ZXVlID0gSlNPTi5wYXJzZShsb2NhbFN0b3JhZ2UucmVwb3NpdG9yaWVzKTtcbiAgICAgICAgdmFyIHF1ZXVlX2xlbmd0aCA9IE9iamVjdC5rZXlzKHJlcG9fcXVldWUpLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHF1ZXVlX2xlbmd0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gICAgc2VhcmNoU2hlZDogc2VhcmNoU2hlZCxcbiAgICBzaGVkUGFyc2VyOiBzaGVkUGFyc2VyLFxuICAgIGFkZFRvUXVldWU6IGFkZFRvUXVldWUsXG4gICAgcXVldWVMZW5ndGg6IHF1ZXVlTGVuZ3RoXG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGdhbGF4eS9zY3JpcHRzL212Yy90b29sc2hlZC91dGlsLmpzIl0sIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///18\n");

/***/ }),

/***/ 284:
/*!*****************************************!*\
  !*** ./galaxy/scripts/apps/extended.js ***!
  \*****************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function($) {\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.bundleEntries = undefined;\nexports.mastheadEntry = mastheadEntry;\nexports.adminToolshedEntry = adminToolshedEntry;\nexports.tracksterEntry = tracksterEntry;\nexports.circsterEntry = circsterEntry;\nexports.workflowEntry = workflowEntry;\n\nvar _workflowView = __webpack_require__(/*! mvc/workflow/workflow-view */ 285);\n\nvar _workflowView2 = _interopRequireDefault(_workflowView);\n\nvar _trackster = __webpack_require__(/*! viz/trackster */ 84);\n\nvar _trackster2 = _interopRequireDefault(_trackster);\n\nvar _circster = __webpack_require__(/*! viz/circster */ 294);\n\nvar _circster2 = _interopRequireDefault(_circster);\n\nvar _galaxy = __webpack_require__(/*! galaxy.library */ 296);\n\nvar _galaxy2 = _interopRequireDefault(_galaxy);\n\nvar _admin = __webpack_require__(/*! admin.toolshed */ 306);\n\nvar _admin2 = _interopRequireDefault(_admin);\n\nvar _masthead = __webpack_require__(/*! layout/masthead */ 33);\n\nvar _masthead2 = _interopRequireDefault(_masthead);\n\nvar _userModel = __webpack_require__(/*! mvc/user/user-model */ 24);\n\nvar _userModel2 = _interopRequireDefault(_userModel);\n\nvar _uiModal = __webpack_require__(/*! mvc/ui/ui-modal */ 8);\n\nvar _uiModal2 = _interopRequireDefault(_uiModal);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction mastheadEntry(options) {\n    if (!Galaxy.user) {\n        Galaxy.user = new _userModel2.default.User(options.user_json);\n    }\n    if (!Galaxy.masthead) {\n        Galaxy.masthead = new _masthead2.default.View(options);\n        Galaxy.modal = new _uiModal2.default.View();\n        $(\"#masthead\").replaceWith(Galaxy.masthead.render().$el);\n    }\n}\n\nfunction adminToolshedEntry(options) {\n    new _admin2.default.GalaxyApp(options);\n}\n\nfunction tracksterEntry(options) {\n    new _trackster2.default.GalaxyApp(options);\n}\n\nfunction circsterEntry(options) {\n    new _circster2.default.GalaxyApp(options);\n}\n\nfunction workflowEntry(options) {\n    new _workflowView2.default(options);\n}\n\nfunction libraryEntry(options) {\n    new _galaxy2.default.GalaxyApp(options);\n}\n\nvar bundleEntries = exports.bundleEntries = {\n    library: libraryEntry,\n    masthead: mastheadEntry,\n    workflow: workflowEntry,\n    trackster: tracksterEntry,\n    circster: circsterEntry,\n    adminToolshed: adminToolshedEntry\n};\n\nwindow.bundleEntries = bundleEntries;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! jquery */ 0)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjg0LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL2dhbGF4eS9zY3JpcHRzL2FwcHMvZXh0ZW5kZWQuanM/Yjg5MSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgV29ya2Zsb3dWaWV3IGZyb20gXCJtdmMvd29ya2Zsb3cvd29ya2Zsb3ctdmlld1wiO1xuaW1wb3J0IFRyYWNrc3RlciBmcm9tIFwidml6L3RyYWNrc3RlclwiO1xuaW1wb3J0IENpcmNzdGVyIGZyb20gXCJ2aXovY2lyY3N0ZXJcIjtcbmltcG9ydCBHYWxheHlMaWJyYXJ5IGZyb20gXCJnYWxheHkubGlicmFyeVwiO1xuaW1wb3J0IEFkbWluVG9vbHNoZWQgZnJvbSBcImFkbWluLnRvb2xzaGVkXCI7XG5pbXBvcnQgTWFzdGhlYWQgZnJvbSBcImxheW91dC9tYXN0aGVhZFwiO1xuaW1wb3J0IHVzZXIgZnJvbSBcIm12Yy91c2VyL3VzZXItbW9kZWxcIjtcbmltcG9ydCBNb2RhbCBmcm9tIFwibXZjL3VpL3VpLW1vZGFsXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBtYXN0aGVhZEVudHJ5KG9wdGlvbnMpIHtcbiAgICBpZiAoIUdhbGF4eS51c2VyKSB7XG4gICAgICAgIEdhbGF4eS51c2VyID0gbmV3IHVzZXIuVXNlcihvcHRpb25zLnVzZXJfanNvbik7XG4gICAgfVxuICAgIGlmICghR2FsYXh5Lm1hc3RoZWFkKSB7XG4gICAgICAgIEdhbGF4eS5tYXN0aGVhZCA9IG5ldyBNYXN0aGVhZC5WaWV3KG9wdGlvbnMpO1xuICAgICAgICBHYWxheHkubW9kYWwgPSBuZXcgTW9kYWwuVmlldygpO1xuICAgICAgICAkKFwiI21hc3RoZWFkXCIpLnJlcGxhY2VXaXRoKEdhbGF4eS5tYXN0aGVhZC5yZW5kZXIoKS4kZWwpO1xuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFkbWluVG9vbHNoZWRFbnRyeShvcHRpb25zKSB7XG4gICAgbmV3IEFkbWluVG9vbHNoZWQuR2FsYXh5QXBwKG9wdGlvbnMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdHJhY2tzdGVyRW50cnkob3B0aW9ucykge1xuICAgIG5ldyBUcmFja3N0ZXIuR2FsYXh5QXBwKG9wdGlvbnMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2lyY3N0ZXJFbnRyeShvcHRpb25zKSB7XG4gICAgbmV3IENpcmNzdGVyLkdhbGF4eUFwcChvcHRpb25zKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHdvcmtmbG93RW50cnkob3B0aW9ucykge1xuICAgIG5ldyBXb3JrZmxvd1ZpZXcob3B0aW9ucyk7XG59XG5cbmZ1bmN0aW9uIGxpYnJhcnlFbnRyeShvcHRpb25zKSB7XG4gICAgbmV3IEdhbGF4eUxpYnJhcnkuR2FsYXh5QXBwKG9wdGlvbnMpO1xufVxuXG5leHBvcnQgY29uc3QgYnVuZGxlRW50cmllcyA9IHtcbiAgICBsaWJyYXJ5OiBsaWJyYXJ5RW50cnksXG4gICAgbWFzdGhlYWQ6IG1hc3RoZWFkRW50cnksXG4gICAgd29ya2Zsb3c6IHdvcmtmbG93RW50cnksXG4gICAgdHJhY2tzdGVyOiB0cmFja3N0ZXJFbnRyeSxcbiAgICBjaXJjc3RlcjogY2lyY3N0ZXJFbnRyeSxcbiAgICBhZG1pblRvb2xzaGVkOiBhZG1pblRvb2xzaGVkRW50cnlcbn07XG5cbndpbmRvdy5idW5kbGVFbnRyaWVzID0gYnVuZGxlRW50cmllcztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBnYWxheHkvc2NyaXB0cy9hcHBzL2V4dGVuZGVkLmpzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFTQTtBQVdBO0FBSUE7QUFJQTtBQUlBO0FBQ0E7QUFqQ0E7QUFDQTs7O0FBQUE7QUFDQTs7O0FBQUE7QUFDQTs7O0FBQUE7QUFDQTs7O0FBQUE7QUFDQTs7O0FBQUE7QUFDQTs7O0FBQUE7QUFDQTs7O0FBQUE7QUFDQTs7Ozs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFDQTtBQVFBO0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///284\n");

/***/ }),

/***/ 285:
/*!******************************************************!*\
  !*** ./galaxy/scripts/mvc/workflow/workflow-view.js ***!
  \******************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function($, Backbone, _) {\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _localization = __webpack_require__(/*! utils/localization */ 3);\n\nvar _localization2 = _interopRequireDefault(_localization);\n\nvar _utils = __webpack_require__(/*! utils/utils */ 4);\n\nvar _utils2 = _interopRequireDefault(_utils);\n\nvar _workflowManager = __webpack_require__(/*! mvc/workflow/workflow-manager */ 286);\n\nvar _workflowManager2 = _interopRequireDefault(_workflowManager);\n\nvar _workflowCanvas = __webpack_require__(/*! mvc/workflow/workflow-canvas */ 287);\n\nvar _workflowCanvas2 = _interopRequireDefault(_workflowCanvas);\n\nvar _workflowNode = __webpack_require__(/*! mvc/workflow/workflow-node */ 288);\n\nvar _workflowNode2 = _interopRequireDefault(_workflowNode);\n\nvar _workflowIcons = __webpack_require__(/*! mvc/workflow/workflow-icons */ 61);\n\nvar _workflowIcons2 = _interopRequireDefault(_workflowIcons);\n\nvar _workflowForms = __webpack_require__(/*! mvc/workflow/workflow-forms */ 293);\n\nvar _workflowForms2 = _interopRequireDefault(_workflowForms);\n\nvar _uiMisc = __webpack_require__(/*! mvc/ui/ui-misc */ 6);\n\nvar _uiMisc2 = _interopRequireDefault(_uiMisc);\n\nvar _asyncSaveText = __webpack_require__(/*! utils/async-save-text */ 79);\n\nvar _asyncSaveText2 = _interopRequireDefault(_asyncSaveText);\n\nvar _toastr = __webpack_require__(/*! libs/toastr */ 7);\n\nvar Toastr = _interopRequireWildcard(_toastr);\n\n__webpack_require__(/*! ui/editable-text */ 20);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// TODO; tie into Galaxy state?\nwindow.workflow_globals = window.workflow_globals || {};\n\n// Reset tool search to start state.\nfunction reset_tool_search(initValue) {\n    // Function may be called in top frame or in tool_menu_frame;\n    // in either case, get the tool menu frame.\n    var tool_menu_frame = $(\"#galaxy_tools\").contents();\n    if (tool_menu_frame.length === 0) {\n        tool_menu_frame = $(document);\n        // Remove classes that indicate searching is active.\n        $(this).removeClass(\"search_active\");\n        tool_menu_frame.find(\".toolTitle\").removeClass(\"search_match\");\n\n        // Reset visibility of tools and labels.\n        tool_menu_frame.find(\".toolSectionBody\").hide();\n        tool_menu_frame.find(\".toolTitle\").show();\n        tool_menu_frame.find(\".toolPanelLabel\").show();\n        tool_menu_frame.find(\".toolSectionWrapper\").each(function () {\n            if ($(this).attr(\"id\") !== \"recently_used_wrapper\") {\n                // Default action.\n                $(this).show();\n            } else if ($(this).hasClass(\"user_pref_visible\")) {\n                $(this).show();\n            }\n        });\n        tool_menu_frame.find(\"#search-no-results\").hide();\n\n        // Reset search input.\n        tool_menu_frame.find(\"#search-spinner\").hide();\n        if (initValue) {\n            var search_input = tool_menu_frame.find(\"#tool-search-query\");\n            search_input.val(\"search tools\");\n        }\n    }\n}\n\nfunction add_node_icon($to_el, nodeType) {\n    var iconStyle = _workflowIcons2.default[nodeType];\n    if (iconStyle) {\n        var $icon = $('<i class=\"icon fa\">&nbsp;</i>').addClass(iconStyle);\n        $to_el.before($icon);\n    }\n}\n\n// create form view\nexports.default = Backbone.View.extend({\n    initialize: function initialize(options) {\n        var self = window.workflow_globals.app = this;\n        this.options = options;\n        this.urls = options && options.urls || {};\n        var close_editor = function close_editor() {\n            self.workflow.check_changes_in_active_form();\n            if (workflow && self.workflow.has_changes) {\n                var do_close = function do_close() {\n                    window.onbeforeunload = undefined;\n                    window.document.location = self.urls.workflow_index;\n                };\n                window.show_modal(\"Close workflow editor\", \"There are unsaved changes to your workflow which will be lost.\", {\n                    Cancel: hide_modal,\n                    \"Save Changes\": function SaveChanges() {\n                        save_current_workflow(null, do_close);\n                    }\n                }, {\n                    \"Don't Save\": do_close\n                });\n            } else {\n                window.document.location = self.urls.workflow_index;\n            }\n        };\n        var save_current_workflow = function save_current_workflow(eventObj, success_callback) {\n            show_message(\"Saving workflow\", \"progress\");\n            self.workflow.check_changes_in_active_form();\n            if (!self.workflow.has_changes) {\n                hide_modal();\n                if (success_callback) {\n                    success_callback();\n                }\n                return;\n            }\n            self.workflow.rectify_workflow_outputs();\n            _utils2.default.request({\n                url: Galaxy.root + \"api/workflows/\" + self.options.id,\n                type: \"PUT\",\n                data: { workflow: self.workflow.to_simple() },\n                success: function success(data) {\n                    var body = $(\"<div/>\").text(data.message);\n                    if (data.errors) {\n                        body.addClass(\"warningmark\");\n                        var errlist = $(\"<ul/>\");\n                        $.each(data.errors, function (i, v) {\n                            $(\"<li/>\").text(v).appendTo(errlist);\n                        });\n                        body.append(errlist);\n                    } else {\n                        body.addClass(\"donemark\");\n                    }\n                    self.workflow.name = data.name;\n                    self.workflow.has_changes = false;\n                    self.workflow.stored = true;\n                    self.showWorkflowParameters();\n                    if (data.errors) {\n                        window.show_modal(\"Saving workflow\", body, {\n                            Ok: hide_modal\n                        });\n                    } else {\n                        success_callback && success_callback();\n                        hide_modal();\n                    }\n                },\n                error: function error(response) {\n                    window.show_modal(\"Saving workflow failed.\", response.err_msg, { Ok: hide_modal });\n                }\n            });\n        };\n\n        // Init searching.\n        $(\"#tool-search-query\").click(function () {\n            $(this).focus();\n            $(this).select();\n        }).keyup(function () {\n            // Remove italics.\n            $(this).css(\"font-style\", \"normal\");\n            // Don't update if same value as last time\n            if (this.value.length < 3) {\n                reset_tool_search(false);\n            } else if (this.value != this.lastValue) {\n                // Add class to denote that searching is active.\n                $(this).addClass(\"search_active\");\n                // input.addClass(config.loadingClass);\n                // Add '*' to facilitate partial matching.\n                var q = this.value;\n                // Stop previous ajax-request\n                if (this.timer) {\n                    clearTimeout(this.timer);\n                }\n                // Start a new ajax-request in X ms\n                $(\"#search-spinner\").show();\n                this.timer = setTimeout(function () {\n                    $.get(self.urls.tool_search, { q: q }, function (data) {\n                        // input.removeClass(config.loadingClass);\n                        // Show live-search if results and search-term aren't empty\n                        $(\"#search-no-results\").hide();\n                        // Hide all tool sections.\n                        $(\".toolSectionWrapper\").hide();\n                        // This hides all tools but not workflows link (which is in a .toolTitle div).\n                        $(\".toolSectionWrapper\").find(\".toolTitle\").hide();\n                        if (data.length != 0) {\n                            // Map tool ids to element ids and join them.\n                            var s = $.map(data, function (n, i) {\n                                return \"link-\" + n;\n                            });\n                            // First pass to show matching tools and their parents.\n                            $(s).each(function (index, id) {\n                                // Add class to denote match.\n                                $(\"[id='\" + id + \"']\").parent().addClass(\"search_match\");\n                                $(\"[id='\" + id + \"']\").parent().show().parent().parent().show().parent().show();\n                            });\n                            // Hide labels that have no visible children.\n                            $(\".toolPanelLabel\").each(function () {\n                                var this_label = $(this);\n                                var next = this_label.next();\n                                var no_visible_tools = true;\n                                // Look through tools following label and, if none are visible, hide label.\n                                while (next.length !== 0 && next.hasClass(\"toolTitle\")) {\n                                    if (next.is(\":visible\")) {\n                                        no_visible_tools = false;\n                                        break;\n                                    } else {\n                                        next = next.next();\n                                    }\n                                }\n                                if (no_visible_tools) {\n                                    this_label.hide();\n                                }\n                            });\n                        } else {\n                            $(\"#search-no-results\").show();\n                        }\n                        $(\"#search-spinner\").hide();\n                    }, \"json\");\n                }, 400);\n            }\n            this.lastValue = this.value;\n        });\n\n        // Canvas overview management\n        this.canvas_manager = window.workflow_globals.canvas_manager = new _workflowCanvas2.default(this, $(\"#canvas-viewport\"), $(\"#overview\"));\n\n        // Initialize workflow state\n        this.reset();\n\n        // get available datatypes for post job action options\n        this.datatypes = JSON.parse($.ajax({\n            url: Galaxy.root + \"api/datatypes\",\n            async: false\n        }).responseText);\n\n        // get datatype mapping options\n        this.datatypes_mapping = JSON.parse($.ajax({\n            url: Galaxy.root + \"api/datatypes/mapping\",\n            async: false\n        }).responseText);\n\n        // set mapping sub lists\n        this.ext_to_type = this.datatypes_mapping.ext_to_class_name;\n        this.type_to_type = this.datatypes_mapping.class_to_classes;\n\n        // Load workflow definition\n        this._workflowLoadAjax(self.options.id, {\n            success: function success(data) {\n                self.reset();\n                self.workflow.from_simple(data, true);\n                self.workflow.has_changes = false;\n                self.workflow.fit_canvas_to_nodes();\n                self.scroll_to_nodes();\n                self.canvas_manager.draw_overview();\n                // Determine if any parameters were 'upgraded' and provide message\n                var upgrade_message = \"\";\n                _.each(data.steps, function (step, step_id) {\n                    var details = \"\";\n                    if (step.errors) {\n                        details += \"<li>\" + step.errors + \"</li>\";\n                    }\n                    _.each(data.upgrade_messages[step_id], function (m) {\n                        details += \"<li>\" + m + \"</li>\";\n                    });\n                    if (details) {\n                        upgrade_message += \"<li>Step \" + (parseInt(step_id, 10) + 1) + \": \" + self.workflow.nodes[step_id].name + \"<ul>\" + details + \"</ul></li>\";\n                    }\n                });\n                if (upgrade_message) {\n                    window.show_modal(\"Issues loading this workflow\", \"Please review the following issues, possibly resulting from tool upgrades or changes.<p><ul>\" + upgrade_message + \"</ul></p>\", { Continue: hide_modal });\n                } else {\n                    hide_modal();\n                }\n                self.showWorkflowParameters();\n            },\n            beforeSubmit: function beforeSubmit(data) {\n                show_message(\"Loading workflow\", \"progress\");\n            }\n        });\n\n        window.make_popupmenu && make_popupmenu($(\"#workflow-options-button\"), {\n            Save: save_current_workflow,\n            \"Save As\": workflow_save_as,\n            Run: function Run() {\n                window.location = Galaxy.root + \"workflows/run?id=\" + self.options.id;\n            },\n            \"Edit Attributes\": function EditAttributes() {\n                self.workflow.clear_active_node();\n            },\n            \"Auto Re-layout\": layout_editor,\n            Close: close_editor\n        });\n\n        /******************************************** Issue 3000*/\n        function workflow_save_as() {\n            var body = $('<form><label style=\"display:inline-block; width: 100%;\">Save as name: </label><input type=\"text\" id=\"workflow_rename\" style=\"width: 80%;\" autofocus/>' + '<br><label style=\"display:inline-block; width: 100%;\">Annotation: </label><input type=\"text\" id=\"wf_annotation\" style=\"width: 80%;\" /></form>');\n            window.show_modal(\"Save As a New Workflow\", body, {\n                OK: function OK() {\n                    var rename_name = $(\"#workflow_rename\").val().length > 0 ? $(\"#workflow_rename\").val() : \"SavedAs_\" + self.workflow.name;\n                    var rename_annotation = $(\"#wf_annotation\").val().length > 0 ? $(\"#wf_annotation\").val() : \"\";\n                    $.ajax({\n                        url: self.urls.workflow_save_as,\n                        type: \"POST\",\n                        data: {\n                            workflow_name: rename_name,\n                            workflow_annotation: rename_annotation,\n                            workflow_data: function workflow_data() {\n                                return JSON.stringify(self.workflow.to_simple());\n                            }\n                        }\n                    }).done(function (id) {\n                        window.onbeforeunload = undefined;\n                        window.location = Galaxy.root + \"workflow/editor?id=\" + id;\n                        hide_modal();\n                    }).fail(function () {\n                        hide_modal();\n                        alert(\"Saving this workflow failed. Please contact this site's administrator.\");\n                    });\n                },\n                Cancel: hide_modal\n            });\n        }\n\n        function edit_workflow_outputs() {\n            self.workflow.clear_active_node();\n            $(\".right-content\").hide();\n            var new_content = \"\";\n            for (var node_key in self.workflow.nodes) {\n                var node = self.workflow.nodes[node_key];\n                if ([\"tool\", \"subworkflow\"].indexOf(node.type) >= 0) {\n                    new_content += \"<div class='toolForm' style='margin-bottom:5px;'><div class='toolFormTitle'>Step \" + node.id + \" - \" + node.name + \"</div>\";\n                    for (var ot_key in node.output_terminals) {\n                        var output = node.output_terminals[ot_key];\n                        if (node.isWorkflowOutput(output.name)) {\n                            new_content += \"<p>\" + output.name + \"<input type='checkbox' name='\" + node.id + \"|\" + output.name + \"' checked /></p>\";\n                        } else {\n                            new_content += \"<p>\" + output.name + \"<input type='checkbox' name='\" + node.id + \"|\" + output.name + \"' /></p>\";\n                        }\n                    }\n                    new_content += \"</div>\";\n                }\n            }\n            $(\"#output-fill-area\").html(new_content);\n            $(\"#output-fill-area input\").bind(\"click\", function () {\n                var node_id = this.name.split(\"|\")[0];\n                var workflowNode = this.workflow.nodes[node_id];\n                var output_name = this.name.split(\"|\")[1];\n                if (this.checked) {\n                    workflowNode.addWorkflowOutput(output_name);\n                } else {\n                    workflowNode.removeWorkflowOutput(output_name);\n                }\n                self.workflow.has_changes = true;\n            });\n            $(\"#workflow-output-area\").show();\n        }\n\n        function layout_editor() {\n            self.workflow.layout();\n            self.workflow.fit_canvas_to_nodes();\n            self.scroll_to_nodes();\n            self.canvas_manager.draw_overview();\n        }\n\n        // On load, set the size to the pref stored in local storage if it exists\n        var overview_size = $.jStorage.get(\"overview-size\");\n        if (overview_size !== undefined) {\n            $(\"#overview-border\").css({\n                width: overview_size,\n                height: overview_size\n            });\n        }\n\n        // Show viewport on load unless pref says it's off\n        if ($.jStorage.get(\"overview-off\")) {\n            hide_overview();\n        } else {\n            show_overview();\n        }\n\n        // Stores the size of the overview into local storage when it's resized\n        $(\"#overview-border\").bind(\"dragend\", function (e, d) {\n            var op = $(this).offsetParent();\n            var opo = op.offset();\n            var new_size = Math.max(op.width() - (d.offsetX - opo.left), op.height() - (d.offsetY - opo.top));\n            $.jStorage.set(\"overview-size\", new_size + \"px\");\n        });\n\n        function show_overview() {\n            $.jStorage.set(\"overview-off\", false);\n            $(\"#overview-border\").css(\"right\", \"0px\");\n            $(\"#close-viewport\").css(\"background-position\", \"0px 0px\");\n        }\n\n        function hide_overview() {\n            $.jStorage.set(\"overview-off\", true);\n            $(\"#overview-border\").css(\"right\", \"20000px\");\n            $(\"#close-viewport\").css(\"background-position\", \"12px 0px\");\n        }\n\n        // Lets the overview be toggled visible and invisible, adjusting the arrows accordingly\n        $(\"#close-viewport\").click(function () {\n            if ($(\"#overview-border\").css(\"right\") === \"0px\") {\n                hide_overview();\n            } else {\n                show_overview();\n            }\n        });\n\n        // Unload handler\n        window.onbeforeunload = function () {\n            if (workflow && self.workflow.has_changes) {\n                return \"There are unsaved changes to your workflow which will be lost.\";\n            }\n        };\n\n        this.options.workflows.length > 0 && $(\"#left\").find(\".toolMenu\").append(this._buildToolPanelWorkflows());\n\n        // Tool menu\n        $(\"div.toolSectionBody\").hide();\n        $(\"div.toolSectionTitle > span\").wrap(\"<a href='#'></a>\");\n        var last_expanded = null;\n        $(\"div.toolSectionTitle\").each(function () {\n            var body = $(this).next(\"div.toolSectionBody\");\n            $(this).click(function () {\n                if (body.is(\":hidden\")) {\n                    if (last_expanded) last_expanded.slideUp(\"fast\");\n                    last_expanded = body;\n                    body.slideDown(\"fast\");\n                } else {\n                    body.slideUp(\"fast\");\n                    last_expanded = null;\n                }\n            });\n        });\n\n        // Rename async.\n        (0, _asyncSaveText2.default)(\"workflow-name\", \"workflow-name\", self.urls.rename_async, \"new_name\");\n\n        // Tag async. Simply have the workflow edit element generate a click on the tag element to activate tagging.\n        $(\"#workflow-tag\").click(function () {\n            $(\".tag-area\").click();\n            return false;\n        });\n        // Annotate async.\n        (0, _asyncSaveText2.default)(\"workflow-annotation\", \"workflow-annotation\", self.urls.annotate_async, \"new_annotation\", 25, true, 4);\n    },\n\n    _buildToolPanelWorkflows: function _buildToolPanelWorkflows() {\n        var self = this;\n        var $section = $('<div class=\"toolSectionWrapper\">' + '<div class=\"toolSectionTitle\">' + '<a href=\"#\"><span>Workflows</span></a>' + \"</div>\" + '<div class=\"toolSectionBody\">' + '<div class=\"toolSectionBg\"/>' + \"</div>\" + \"</div>\");\n        _.each(this.options.workflows, function (workflow) {\n            if (workflow.id !== self.options.id) {\n                var copy = new _uiMisc2.default.ButtonIcon({\n                    icon: \"fa fa-copy\",\n                    cls: \"ui-button-icon-plain\",\n                    tooltip: (0, _localization2.default)(\"Copy and insert individual steps\"),\n                    onclick: function onclick() {\n                        if (workflow.step_count < 2) {\n                            self.copy_into_workflow(workflow.id, workflow.name);\n                        } else {\n                            // don't ruin the workflow by adding 50 steps unprompted.\n                            Galaxy.modal.show({\n                                title: (0, _localization2.default)(\"Warning\"),\n                                body: \"This will copy \" + workflow.step_count + \" new steps into your workflow.\",\n                                buttons: {\n                                    Cancel: function Cancel() {\n                                        Galaxy.modal.hide();\n                                    },\n                                    Copy: function Copy() {\n                                        Galaxy.modal.hide();\n                                        self.copy_into_workflow(workflow.id, workflow.name);\n                                    }\n                                }\n                            });\n                        }\n                    }\n                });\n                var $add = $(\"<a/>\").attr(\"href\", \"#\").html(workflow.name).on(\"click\", function () {\n                    self.add_node_for_subworkflow(workflow.latest_id, workflow.name);\n                });\n                $section.find(\".toolSectionBg\").append($(\"<div/>\").addClass(\"toolTitle\").append($add).append(copy.$el));\n            }\n        });\n        return $section;\n    },\n\n    copy_into_workflow: function copy_into_workflow(workflowId) {\n        // Load workflow definition\n        var self = this;\n        this._workflowLoadAjax(workflowId, {\n            success: function success(data) {\n                self.workflow.from_simple(data, false);\n                // Determine if any parameters were 'upgraded' and provide message\n                var upgrade_message = \"\";\n                $.each(data.upgrade_messages, function (k, v) {\n                    upgrade_message += \"<li>Step \" + (parseInt(k, 10) + 1) + \": \" + self.workflow.nodes[k].name + \"<ul>\";\n                    $.each(v, function (i, vv) {\n                        upgrade_message += \"<li>\" + vv + \"</li>\";\n                    });\n                    upgrade_message += \"</ul></li>\";\n                });\n                if (upgrade_message) {\n                    window.show_modal(\"Subworkflow embedded with changes\", \"Problems were encountered loading this workflow (possibly a result of tool upgrades). Please review the following parameters and then save.<ul>\" + upgrade_message + \"</ul>\", { Continue: hide_modal });\n                } else {\n                    hide_modal();\n                }\n            },\n            beforeSubmit: function beforeSubmit(data) {\n                show_message(\"Importing workflow\", \"progress\");\n            }\n        });\n    },\n\n    // Global state for the whole workflow\n    reset: function reset() {\n        this.workflow && this.workflow.remove_all();\n        this.workflow = window.workflow_globals.workflow = new _workflowManager2.default(this, $(\"#canvas-container\"));\n    },\n\n    scroll_to_nodes: function scroll_to_nodes() {\n        var cv = $(\"#canvas-viewport\");\n        var cc = $(\"#canvas-container\");\n        var top;\n        var left;\n        if (cc.width() < cv.width()) {\n            left = (cv.width() - cc.width()) / 2;\n        } else {\n            left = 0;\n        }\n        if (cc.height() < cv.height()) {\n            top = (cv.height() - cc.height()) / 2;\n        } else {\n            top = 0;\n        }\n        cc.css({ left: left, top: top });\n    },\n\n    _workflowLoadAjax: function _workflowLoadAjax(workflowId, options) {\n        $.ajax(_utils2.default.merge(options, {\n            url: this.urls.load_workflow,\n            data: { id: workflowId, _: \"true\" },\n            dataType: \"json\",\n            cache: false\n        }));\n    },\n\n    _moduleInitAjax: function _moduleInitAjax(node, request_data) {\n        var self = this;\n        _utils2.default.request({\n            type: \"POST\",\n            url: Galaxy.root + \"api/workflows/build_module\",\n            data: request_data,\n            success: function success(data) {\n                node.init_field_data(data);\n                node.update_field_data(data);\n                self.workflow.activate_node(node);\n            }\n        });\n    },\n\n    // Add a new step to the workflow by tool id\n    add_node_for_tool: function add_node_for_tool(id, title) {\n        var node = this.workflow.create_node(\"tool\", title, id);\n        this._moduleInitAjax(node, {\n            type: \"tool\",\n            tool_id: id,\n            _: \"true\"\n        });\n    },\n\n    // Add a new step to the workflow by tool id\n    add_node_for_subworkflow: function add_node_for_subworkflow(id, title) {\n        var node = this.workflow.create_node(\"subworkflow\", title, id);\n        this._moduleInitAjax(node, {\n            type: \"subworkflow\",\n            content_id: id,\n            _: \"true\"\n        });\n    },\n\n    add_node_for_module: function add_node_for_module(type, title) {\n        var node = this.workflow.create_node(type, title);\n        this._moduleInitAjax(node, { type: type, _: \"true\" });\n    },\n\n    display_file_list: function display_file_list(node) {\n        var addlist = \"<select id='node_data_list' name='node_data_list'>\";\n        for (var out_terminal in node.output_terminals) {\n            addlist += \"<option value='\" + out_terminal + \"'>\" + out_terminal + \"</option>\";\n        }\n        addlist += \"</select>\";\n        return addlist;\n    },\n\n    showWorkflowParameters: function showWorkflowParameters() {\n        var parameter_re = /\\$\\{.+?\\}/g;\n        var workflow_parameters = [];\n        var wf_parm_container = $(\"#workflow-parameters-container\");\n        var wf_parm_box = $(\"#workflow-parameters-box\");\n        var new_parameter_content = \"\";\n        var matches = [];\n        $.each(this.workflow.nodes, function (k, node) {\n            if (node.config_form && node.config_form.inputs) {\n                _utils2.default.deepeach(node.config_form.inputs, function (d) {\n                    if (typeof d.value == \"string\") {\n                        var form_matches = d.value.match(parameter_re);\n                        if (form_matches) {\n                            matches = matches.concat(form_matches);\n                        }\n                    }\n                });\n            }\n            if (node.post_job_actions) {\n                $.each(node.post_job_actions, function (k, pja) {\n                    if (pja.action_arguments) {\n                        $.each(pja.action_arguments, function (k, action_argument) {\n                            var arg_matches = action_argument.match(parameter_re);\n                            if (arg_matches) {\n                                matches = matches.concat(arg_matches);\n                            }\n                        });\n                    }\n                });\n            }\n            if (matches) {\n                $.each(matches, function (k, element) {\n                    if ($.inArray(element, workflow_parameters) === -1) {\n                        workflow_parameters.push(element);\n                    }\n                });\n            }\n        });\n        if (workflow_parameters && workflow_parameters.length !== 0) {\n            $.each(workflow_parameters, function (k, element) {\n                new_parameter_content += \"<div>\" + element.substring(2, element.length - 1) + \"</div>\";\n            });\n            wf_parm_container.html(new_parameter_content);\n            wf_parm_box.show();\n        } else {\n            wf_parm_container.html(new_parameter_content);\n            wf_parm_box.hide();\n        }\n    },\n\n    showAttributes: function showAttributes() {\n        $(\".right-content\").hide();\n        $(\"#edit-attributes\").show();\n    },\n\n    showForm: function showForm(content, node) {\n        var self = this;\n        var cls = \"right-content\";\n        var id = cls + \"-\" + node.id;\n        var $container = $(\"#\" + cls);\n        if (content && $container.find(\"#\" + id).length == 0) {\n            var $el = $(\"<div id=\\\"\" + id + \"\\\" class=\\\"\" + cls + \"\\\"/>\");\n            content.node = node;\n            content.workflow = this.workflow;\n            content.datatypes = this.datatypes;\n            content.icon = _workflowIcons2.default[node.type];\n            content.cls = \"ui-portlet-narrow\";\n            if (node) {\n                var form_type = node.type == \"tool\" ? \"Tool\" : \"Default\";\n                $el.append(new _workflowForms2.default[form_type](content).form.$el);\n                $container.append($el);\n            } else {\n                Galaxy.emit.debug(\"workflow-view::initialize()\", \"Node not found in workflow.\");\n            }\n        }\n        $(\".\" + cls).hide();\n        $container.find(\"#\" + id).show();\n        $container.show();\n        $container.scrollTop();\n    },\n\n    isSubType: function isSubType(child, parent) {\n        child = this.ext_to_type[child];\n        parent = this.ext_to_type[parent];\n        return this.type_to_type[child] && parent in this.type_to_type[child];\n    },\n\n    prebuildNode: function prebuildNode(type, title_text, content_id) {\n        var self = this;\n        var $f = $(\"<div class='toolForm toolFormInCanvas'/>\");\n        var $title = $(\"<div class='toolFormTitle unselectable'><span class='nodeTitle'>\" + title_text + \"</div></div>\");\n        add_node_icon($title.find(\".nodeTitle\"), type);\n        $f.append($title);\n        $f.css(\"left\", $(window).scrollLeft() + 20);\n        $f.css(\"top\", $(window).scrollTop() + 20);\n        $f.append($(\"<div class='toolFormBody'></div>\"));\n        var node = new _workflowNode2.default(this, { element: $f });\n        node.type = type;\n        node.content_id = content_id;\n        var tmp = \"<div><img height='16' align='middle' src='\" + Galaxy.root + \"static/images/loading_small_white_bg.gif'/> loading tool info...</div>\";\n        $f.find(\".toolFormBody\").append(tmp);\n        // Fix width to computed width\n        // Now add floats\n        var buttons = $(\"<div class='buttons' style='float: right;'></div>\");\n        if (type !== \"subworkflow\") {\n            buttons.append($(\"<div/>\").addClass(\"fa-icon-button fa fa-files-o\").click(function (e) {\n                node.clone();\n            }));\n        }\n        buttons.append($(\"<div/>\").addClass(\"fa-icon-button fa fa-times\").click(function (e) {\n            node.destroy();\n        }));\n        // Place inside container\n        $f.appendTo(\"#canvas-container\");\n        // Position in container\n        var o = $(\"#canvas-container\").position();\n        var p = $(\"#canvas-container\").parent();\n        var width = $f.width();\n        var height = $f.height();\n        $f.css({\n            left: -o.left + p.width() / 2 - width / 2,\n            top: -o.top + p.height() / 2 - height / 2\n        });\n        buttons.prependTo($f.find(\".toolFormTitle\"));\n        width += buttons.width() + 10;\n        $f.css(\"width\", width);\n        $f.bind(\"dragstart\", function () {\n            self.workflow.activate_node(node);\n        }).bind(\"dragend\", function () {\n            self.workflow.node_changed(this);\n            self.workflow.fit_canvas_to_nodes();\n            self.canvas_manager.draw_overview();\n        }).bind(\"dragclickonly\", function () {\n            self.workflow.activate_node(node);\n        }).bind(\"drag\", function (e, d) {\n            // Move\n            var po = $(this).offsetParent().offset();\n\n            var x = d.offsetX - po.left;\n            var y = d.offsetY - po.top;\n            $(this).css({ left: x, top: y });\n            // Redraw\n            $(this).find(\".terminal\").each(function () {\n                this.terminal.redraw();\n            });\n        });\n        return node;\n    }\n});\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! jquery */ 0), __webpack_require__(/*! libs/backbone */ 2), __webpack_require__(/*! underscore */ 1)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjg1LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL2dhbGF4eS9zY3JpcHRzL212Yy93b3JrZmxvdy93b3JrZmxvdy12aWV3LmpzP2FlNDQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IF9sIGZyb20gXCJ1dGlscy9sb2NhbGl6YXRpb25cIjtcbmltcG9ydCBVdGlscyBmcm9tIFwidXRpbHMvdXRpbHNcIjtcbmltcG9ydCBXb3JrZmxvdyBmcm9tIFwibXZjL3dvcmtmbG93L3dvcmtmbG93LW1hbmFnZXJcIjtcbmltcG9ydCBXb3JrZmxvd0NhbnZhcyBmcm9tIFwibXZjL3dvcmtmbG93L3dvcmtmbG93LWNhbnZhc1wiO1xuaW1wb3J0IE5vZGUgZnJvbSBcIm12Yy93b3JrZmxvdy93b3JrZmxvdy1ub2RlXCI7XG5pbXBvcnQgV29ya2Zsb3dJY29ucyBmcm9tIFwibXZjL3dvcmtmbG93L3dvcmtmbG93LWljb25zXCI7XG5pbXBvcnQgRm9ybVdyYXBwZXJzIGZyb20gXCJtdmMvd29ya2Zsb3cvd29ya2Zsb3ctZm9ybXNcIjtcbmltcG9ydCBVaSBmcm9tIFwibXZjL3VpL3VpLW1pc2NcIjtcbmltcG9ydCBhc3luY19zYXZlX3RleHQgZnJvbSBcInV0aWxzL2FzeW5jLXNhdmUtdGV4dFwiO1xuaW1wb3J0ICogYXMgVG9hc3RyIGZyb20gXCJsaWJzL3RvYXN0clwiO1xuaW1wb3J0IFwidWkvZWRpdGFibGUtdGV4dFwiO1xuXG4vLyBUT0RPOyB0aWUgaW50byBHYWxheHkgc3RhdGU/XG53aW5kb3cud29ya2Zsb3dfZ2xvYmFscyA9IHdpbmRvdy53b3JrZmxvd19nbG9iYWxzIHx8IHt9O1xuXG4vLyBSZXNldCB0b29sIHNlYXJjaCB0byBzdGFydCBzdGF0ZS5cbmZ1bmN0aW9uIHJlc2V0X3Rvb2xfc2VhcmNoKGluaXRWYWx1ZSkge1xuICAgIC8vIEZ1bmN0aW9uIG1heSBiZSBjYWxsZWQgaW4gdG9wIGZyYW1lIG9yIGluIHRvb2xfbWVudV9mcmFtZTtcbiAgICAvLyBpbiBlaXRoZXIgY2FzZSwgZ2V0IHRoZSB0b29sIG1lbnUgZnJhbWUuXG4gICAgdmFyIHRvb2xfbWVudV9mcmFtZSA9ICQoXCIjZ2FsYXh5X3Rvb2xzXCIpLmNvbnRlbnRzKCk7XG4gICAgaWYgKHRvb2xfbWVudV9mcmFtZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdG9vbF9tZW51X2ZyYW1lID0gJChkb2N1bWVudCk7XG4gICAgICAgIC8vIFJlbW92ZSBjbGFzc2VzIHRoYXQgaW5kaWNhdGUgc2VhcmNoaW5nIGlzIGFjdGl2ZS5cbiAgICAgICAgJCh0aGlzKS5yZW1vdmVDbGFzcyhcInNlYXJjaF9hY3RpdmVcIik7XG4gICAgICAgIHRvb2xfbWVudV9mcmFtZS5maW5kKFwiLnRvb2xUaXRsZVwiKS5yZW1vdmVDbGFzcyhcInNlYXJjaF9tYXRjaFwiKTtcblxuICAgICAgICAvLyBSZXNldCB2aXNpYmlsaXR5IG9mIHRvb2xzIGFuZCBsYWJlbHMuXG4gICAgICAgIHRvb2xfbWVudV9mcmFtZS5maW5kKFwiLnRvb2xTZWN0aW9uQm9keVwiKS5oaWRlKCk7XG4gICAgICAgIHRvb2xfbWVudV9mcmFtZS5maW5kKFwiLnRvb2xUaXRsZVwiKS5zaG93KCk7XG4gICAgICAgIHRvb2xfbWVudV9mcmFtZS5maW5kKFwiLnRvb2xQYW5lbExhYmVsXCIpLnNob3coKTtcbiAgICAgICAgdG9vbF9tZW51X2ZyYW1lLmZpbmQoXCIudG9vbFNlY3Rpb25XcmFwcGVyXCIpLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoJCh0aGlzKS5hdHRyKFwiaWRcIikgIT09IFwicmVjZW50bHlfdXNlZF93cmFwcGVyXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBEZWZhdWx0IGFjdGlvbi5cbiAgICAgICAgICAgICAgICAkKHRoaXMpLnNob3coKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoJCh0aGlzKS5oYXNDbGFzcyhcInVzZXJfcHJlZl92aXNpYmxlXCIpKSB7XG4gICAgICAgICAgICAgICAgJCh0aGlzKS5zaG93KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0b29sX21lbnVfZnJhbWUuZmluZChcIiNzZWFyY2gtbm8tcmVzdWx0c1wiKS5oaWRlKCk7XG5cbiAgICAgICAgLy8gUmVzZXQgc2VhcmNoIGlucHV0LlxuICAgICAgICB0b29sX21lbnVfZnJhbWUuZmluZChcIiNzZWFyY2gtc3Bpbm5lclwiKS5oaWRlKCk7XG4gICAgICAgIGlmIChpbml0VmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBzZWFyY2hfaW5wdXQgPSB0b29sX21lbnVfZnJhbWUuZmluZChcIiN0b29sLXNlYXJjaC1xdWVyeVwiKTtcbiAgICAgICAgICAgIHNlYXJjaF9pbnB1dC52YWwoXCJzZWFyY2ggdG9vbHNcIik7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIGFkZF9ub2RlX2ljb24oJHRvX2VsLCBub2RlVHlwZSkge1xuICAgIHZhciBpY29uU3R5bGUgPSBXb3JrZmxvd0ljb25zW25vZGVUeXBlXTtcbiAgICBpZiAoaWNvblN0eWxlKSB7XG4gICAgICAgIHZhciAkaWNvbiA9ICQoJzxpIGNsYXNzPVwiaWNvbiBmYVwiPiZuYnNwOzwvaT4nKS5hZGRDbGFzcyhpY29uU3R5bGUpO1xuICAgICAgICAkdG9fZWwuYmVmb3JlKCRpY29uKTtcbiAgICB9XG59XG5cbi8vIGNyZWF0ZSBmb3JtIHZpZXdcbmV4cG9ydCBkZWZhdWx0IEJhY2tib25lLlZpZXcuZXh0ZW5kKHtcbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHZhciBzZWxmID0gKHdpbmRvdy53b3JrZmxvd19nbG9iYWxzLmFwcCA9IHRoaXMpO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLnVybHMgPSAob3B0aW9ucyAmJiBvcHRpb25zLnVybHMpIHx8IHt9O1xuICAgICAgICB2YXIgY2xvc2VfZWRpdG9yID0gKCkgPT4ge1xuICAgICAgICAgICAgc2VsZi53b3JrZmxvdy5jaGVja19jaGFuZ2VzX2luX2FjdGl2ZV9mb3JtKCk7XG4gICAgICAgICAgICBpZiAod29ya2Zsb3cgJiYgc2VsZi53b3JrZmxvdy5oYXNfY2hhbmdlcykge1xuICAgICAgICAgICAgICAgIHZhciBkb19jbG9zZSA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93Lm9uYmVmb3JldW5sb2FkID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB3aW5kb3cuZG9jdW1lbnQubG9jYXRpb24gPSBzZWxmLnVybHMud29ya2Zsb3dfaW5kZXg7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB3aW5kb3cuc2hvd19tb2RhbChcbiAgICAgICAgICAgICAgICAgICAgXCJDbG9zZSB3b3JrZmxvdyBlZGl0b3JcIixcbiAgICAgICAgICAgICAgICAgICAgXCJUaGVyZSBhcmUgdW5zYXZlZCBjaGFuZ2VzIHRvIHlvdXIgd29ya2Zsb3cgd2hpY2ggd2lsbCBiZSBsb3N0LlwiLFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBDYW5jZWw6IGhpZGVfbW9kYWwsXG4gICAgICAgICAgICAgICAgICAgICAgICBcIlNhdmUgQ2hhbmdlc1wiOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzYXZlX2N1cnJlbnRfd29ya2Zsb3cobnVsbCwgZG9fY2xvc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBcIkRvbid0IFNhdmVcIjogZG9fY2xvc2VcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5kb2N1bWVudC5sb2NhdGlvbiA9IHNlbGYudXJscy53b3JrZmxvd19pbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHNhdmVfY3VycmVudF93b3JrZmxvdyA9IChldmVudE9iaiwgc3VjY2Vzc19jYWxsYmFjaykgPT4ge1xuICAgICAgICAgICAgc2hvd19tZXNzYWdlKFwiU2F2aW5nIHdvcmtmbG93XCIsIFwicHJvZ3Jlc3NcIik7XG4gICAgICAgICAgICBzZWxmLndvcmtmbG93LmNoZWNrX2NoYW5nZXNfaW5fYWN0aXZlX2Zvcm0oKTtcbiAgICAgICAgICAgIGlmICghc2VsZi53b3JrZmxvdy5oYXNfY2hhbmdlcykge1xuICAgICAgICAgICAgICAgIGhpZGVfbW9kYWwoKTtcbiAgICAgICAgICAgICAgICBpZiAoc3VjY2Vzc19jYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzX2NhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGYud29ya2Zsb3cucmVjdGlmeV93b3JrZmxvd19vdXRwdXRzKCk7XG4gICAgICAgICAgICBVdGlscy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICB1cmw6IGAke0dhbGF4eS5yb290fWFwaS93b3JrZmxvd3MvJHtzZWxmLm9wdGlvbnMuaWR9YCxcbiAgICAgICAgICAgICAgICB0eXBlOiBcIlBVVFwiLFxuICAgICAgICAgICAgICAgIGRhdGE6IHsgd29ya2Zsb3c6IHNlbGYud29ya2Zsb3cudG9fc2ltcGxlKCkgfSxcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBib2R5ID0gJChcIjxkaXYvPlwiKS50ZXh0KGRhdGEubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLmVycm9ycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYm9keS5hZGRDbGFzcyhcIndhcm5pbmdtYXJrXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVycmxpc3QgPSAkKFwiPHVsLz5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAkLmVhY2goZGF0YS5lcnJvcnMsIChpLCB2KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJChcIjxsaS8+XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50ZXh0KHYpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hcHBlbmRUbyhlcnJsaXN0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYm9keS5hcHBlbmQoZXJybGlzdCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5LmFkZENsYXNzKFwiZG9uZW1hcmtcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc2VsZi53b3JrZmxvdy5uYW1lID0gZGF0YS5uYW1lO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLndvcmtmbG93Lmhhc19jaGFuZ2VzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYud29ya2Zsb3cuc3RvcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5zaG93V29ya2Zsb3dQYXJhbWV0ZXJzKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLmVycm9ycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LnNob3dfbW9kYWwoXCJTYXZpbmcgd29ya2Zsb3dcIiwgYm9keSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9rOiBoaWRlX21vZGFsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3NfY2FsbGJhY2sgJiYgc3VjY2Vzc19jYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaGlkZV9tb2RhbCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBlcnJvcjogZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93LnNob3dfbW9kYWwoXCJTYXZpbmcgd29ya2Zsb3cgZmFpbGVkLlwiLCByZXNwb25zZS5lcnJfbXNnLCB7IE9rOiBoaWRlX21vZGFsIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEluaXQgc2VhcmNoaW5nLlxuICAgICAgICAkKFwiI3Rvb2wtc2VhcmNoLXF1ZXJ5XCIpXG4gICAgICAgICAgICAuY2xpY2soZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgJCh0aGlzKS5mb2N1cygpO1xuICAgICAgICAgICAgICAgICQodGhpcykuc2VsZWN0KCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmtleXVwKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBpdGFsaWNzLlxuICAgICAgICAgICAgICAgICQodGhpcykuY3NzKFwiZm9udC1zdHlsZVwiLCBcIm5vcm1hbFwiKTtcbiAgICAgICAgICAgICAgICAvLyBEb24ndCB1cGRhdGUgaWYgc2FtZSB2YWx1ZSBhcyBsYXN0IHRpbWVcbiAgICAgICAgICAgICAgICBpZiAodGhpcy52YWx1ZS5sZW5ndGggPCAzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc2V0X3Rvb2xfc2VhcmNoKGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMudmFsdWUgIT0gdGhpcy5sYXN0VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQWRkIGNsYXNzIHRvIGRlbm90ZSB0aGF0IHNlYXJjaGluZyBpcyBhY3RpdmUuXG4gICAgICAgICAgICAgICAgICAgICQodGhpcykuYWRkQ2xhc3MoXCJzZWFyY2hfYWN0aXZlXCIpO1xuICAgICAgICAgICAgICAgICAgICAvLyBpbnB1dC5hZGRDbGFzcyhjb25maWcubG9hZGluZ0NsYXNzKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQWRkICcqJyB0byBmYWNpbGl0YXRlIHBhcnRpYWwgbWF0Y2hpbmcuXG4gICAgICAgICAgICAgICAgICAgIHZhciBxID0gdGhpcy52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgLy8gU3RvcCBwcmV2aW91cyBhamF4LXJlcXVlc3RcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudGltZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBTdGFydCBhIG5ldyBhamF4LXJlcXVlc3QgaW4gWCBtc1xuICAgICAgICAgICAgICAgICAgICAkKFwiI3NlYXJjaC1zcGlubmVyXCIpLnNob3coKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50aW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgJC5nZXQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi51cmxzLnRvb2xfc2VhcmNoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgcTogcSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbnB1dC5yZW1vdmVDbGFzcyhjb25maWcubG9hZGluZ0NsYXNzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2hvdyBsaXZlLXNlYXJjaCBpZiByZXN1bHRzIGFuZCBzZWFyY2gtdGVybSBhcmVuJ3QgZW1wdHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJChcIiNzZWFyY2gtbm8tcmVzdWx0c1wiKS5oaWRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEhpZGUgYWxsIHRvb2wgc2VjdGlvbnMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICQoXCIudG9vbFNlY3Rpb25XcmFwcGVyXCIpLmhpZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBoaWRlcyBhbGwgdG9vbHMgYnV0IG5vdCB3b3JrZmxvd3MgbGluayAod2hpY2ggaXMgaW4gYSAudG9vbFRpdGxlIGRpdikuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICQoXCIudG9vbFNlY3Rpb25XcmFwcGVyXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZmluZChcIi50b29sVGl0bGVcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5oaWRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLmxlbmd0aCAhPSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNYXAgdG9vbCBpZHMgdG8gZWxlbWVudCBpZHMgYW5kIGpvaW4gdGhlbS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzID0gJC5tYXAoZGF0YSwgKG4sIGkpID0+IGBsaW5rLSR7bn1gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZpcnN0IHBhc3MgdG8gc2hvdyBtYXRjaGluZyB0b29scyBhbmQgdGhlaXIgcGFyZW50cy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICQocykuZWFjaCgoaW5kZXgsIGlkKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWRkIGNsYXNzIHRvIGRlbm90ZSBtYXRjaC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKGBbaWQ9JyR7aWR9J11gKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucGFyZW50KClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKFwic2VhcmNoX21hdGNoXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICQoYFtpZD0nJHtpZH0nXWApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5wYXJlbnQoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc2hvdygpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5wYXJlbnQoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucGFyZW50KClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnNob3coKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucGFyZW50KClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnNob3coKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSGlkZSBsYWJlbHMgdGhhdCBoYXZlIG5vIHZpc2libGUgY2hpbGRyZW4uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKFwiLnRvb2xQYW5lbExhYmVsXCIpLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRoaXNfbGFiZWwgPSAkKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXh0ID0gdGhpc19sYWJlbC5uZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5vX3Zpc2libGVfdG9vbHMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIExvb2sgdGhyb3VnaCB0b29scyBmb2xsb3dpbmcgbGFiZWwgYW5kLCBpZiBub25lIGFyZSB2aXNpYmxlLCBoaWRlIGxhYmVsLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChuZXh0Lmxlbmd0aCAhPT0gMCAmJiBuZXh0Lmhhc0NsYXNzKFwidG9vbFRpdGxlXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXh0LmlzKFwiOnZpc2libGVcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vX3Zpc2libGVfdG9vbHMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCA9IG5leHQubmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub192aXNpYmxlX3Rvb2xzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNfbGFiZWwuaGlkZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJChcIiNzZWFyY2gtbm8tcmVzdWx0c1wiKS5zaG93KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJChcIiNzZWFyY2gtc3Bpbm5lclwiKS5oaWRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImpzb25cIlxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgNDAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5sYXN0VmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gQ2FudmFzIG92ZXJ2aWV3IG1hbmFnZW1lbnRcbiAgICAgICAgdGhpcy5jYW52YXNfbWFuYWdlciA9IHdpbmRvdy53b3JrZmxvd19nbG9iYWxzLmNhbnZhc19tYW5hZ2VyID0gbmV3IFdvcmtmbG93Q2FudmFzKFxuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICQoXCIjY2FudmFzLXZpZXdwb3J0XCIpLFxuICAgICAgICAgICAgJChcIiNvdmVydmlld1wiKVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIEluaXRpYWxpemUgd29ya2Zsb3cgc3RhdGVcbiAgICAgICAgdGhpcy5yZXNldCgpO1xuXG4gICAgICAgIC8vIGdldCBhdmFpbGFibGUgZGF0YXR5cGVzIGZvciBwb3N0IGpvYiBhY3Rpb24gb3B0aW9uc1xuICAgICAgICB0aGlzLmRhdGF0eXBlcyA9IEpTT04ucGFyc2UoXG4gICAgICAgICAgICAkLmFqYXgoe1xuICAgICAgICAgICAgICAgIHVybDogYCR7R2FsYXh5LnJvb3R9YXBpL2RhdGF0eXBlc2AsXG4gICAgICAgICAgICAgICAgYXN5bmM6IGZhbHNlXG4gICAgICAgICAgICB9KS5yZXNwb25zZVRleHRcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBnZXQgZGF0YXR5cGUgbWFwcGluZyBvcHRpb25zXG4gICAgICAgIHRoaXMuZGF0YXR5cGVzX21hcHBpbmcgPSBKU09OLnBhcnNlKFxuICAgICAgICAgICAgJC5hamF4KHtcbiAgICAgICAgICAgICAgICB1cmw6IGAke0dhbGF4eS5yb290fWFwaS9kYXRhdHlwZXMvbWFwcGluZ2AsXG4gICAgICAgICAgICAgICAgYXN5bmM6IGZhbHNlXG4gICAgICAgICAgICB9KS5yZXNwb25zZVRleHRcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBzZXQgbWFwcGluZyBzdWIgbGlzdHNcbiAgICAgICAgdGhpcy5leHRfdG9fdHlwZSA9IHRoaXMuZGF0YXR5cGVzX21hcHBpbmcuZXh0X3RvX2NsYXNzX25hbWU7XG4gICAgICAgIHRoaXMudHlwZV90b190eXBlID0gdGhpcy5kYXRhdHlwZXNfbWFwcGluZy5jbGFzc190b19jbGFzc2VzO1xuXG4gICAgICAgIC8vIExvYWQgd29ya2Zsb3cgZGVmaW5pdGlvblxuICAgICAgICB0aGlzLl93b3JrZmxvd0xvYWRBamF4KHNlbGYub3B0aW9ucy5pZCwge1xuICAgICAgICAgICAgc3VjY2VzczogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgICAgIHNlbGYucmVzZXQoKTtcbiAgICAgICAgICAgICAgICBzZWxmLndvcmtmbG93LmZyb21fc2ltcGxlKGRhdGEsIHRydWUpO1xuICAgICAgICAgICAgICAgIHNlbGYud29ya2Zsb3cuaGFzX2NoYW5nZXMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBzZWxmLndvcmtmbG93LmZpdF9jYW52YXNfdG9fbm9kZXMoKTtcbiAgICAgICAgICAgICAgICBzZWxmLnNjcm9sbF90b19ub2RlcygpO1xuICAgICAgICAgICAgICAgIHNlbGYuY2FudmFzX21hbmFnZXIuZHJhd19vdmVydmlldygpO1xuICAgICAgICAgICAgICAgIC8vIERldGVybWluZSBpZiBhbnkgcGFyYW1ldGVycyB3ZXJlICd1cGdyYWRlZCcgYW5kIHByb3ZpZGUgbWVzc2FnZVxuICAgICAgICAgICAgICAgIHZhciB1cGdyYWRlX21lc3NhZ2UgPSBcIlwiO1xuICAgICAgICAgICAgICAgIF8uZWFjaChkYXRhLnN0ZXBzLCAoc3RlcCwgc3RlcF9pZCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGV0YWlscyA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGVwLmVycm9ycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGV0YWlscyArPSBgPGxpPiR7c3RlcC5lcnJvcnN9PC9saT5gO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF8uZWFjaChkYXRhLnVwZ3JhZGVfbWVzc2FnZXNbc3RlcF9pZF0sIG0gPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGV0YWlscyArPSBgPGxpPiR7bX08L2xpPmA7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGV0YWlscykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXBncmFkZV9tZXNzYWdlICs9IGA8bGk+U3RlcCAke3BhcnNlSW50KHN0ZXBfaWQsIDEwKSArIDF9OiAke1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYud29ya2Zsb3cubm9kZXNbc3RlcF9pZF0ubmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgfTx1bD4ke2RldGFpbHN9PC91bD48L2xpPmA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAodXBncmFkZV9tZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5zaG93X21vZGFsKFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJJc3N1ZXMgbG9hZGluZyB0aGlzIHdvcmtmbG93XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBgUGxlYXNlIHJldmlldyB0aGUgZm9sbG93aW5nIGlzc3VlcywgcG9zc2libHkgcmVzdWx0aW5nIGZyb20gdG9vbCB1cGdyYWRlcyBvciBjaGFuZ2VzLjxwPjx1bD4ke1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwZ3JhZGVfbWVzc2FnZVxuICAgICAgICAgICAgICAgICAgICAgICAgfTwvdWw+PC9wPmAsXG4gICAgICAgICAgICAgICAgICAgICAgICB7IENvbnRpbnVlOiBoaWRlX21vZGFsIH1cbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBoaWRlX21vZGFsKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNlbGYuc2hvd1dvcmtmbG93UGFyYW1ldGVycygpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGJlZm9yZVN1Ym1pdDogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgICAgIHNob3dfbWVzc2FnZShcIkxvYWRpbmcgd29ya2Zsb3dcIiwgXCJwcm9ncmVzc1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgd2luZG93Lm1ha2VfcG9wdXBtZW51ICYmXG4gICAgICAgICAgICBtYWtlX3BvcHVwbWVudSgkKFwiI3dvcmtmbG93LW9wdGlvbnMtYnV0dG9uXCIpLCB7XG4gICAgICAgICAgICAgICAgU2F2ZTogc2F2ZV9jdXJyZW50X3dvcmtmbG93LFxuICAgICAgICAgICAgICAgIFwiU2F2ZSBBc1wiOiB3b3JrZmxvd19zYXZlX2FzLFxuICAgICAgICAgICAgICAgIFJ1bjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbiA9IGAke0dhbGF4eS5yb290fXdvcmtmbG93cy9ydW4/aWQ9JHtzZWxmLm9wdGlvbnMuaWR9YDtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwiRWRpdCBBdHRyaWJ1dGVzXCI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLndvcmtmbG93LmNsZWFyX2FjdGl2ZV9ub2RlKCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcIkF1dG8gUmUtbGF5b3V0XCI6IGxheW91dF9lZGl0b3IsXG4gICAgICAgICAgICAgICAgQ2xvc2U6IGNsb3NlX2VkaXRvclxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqIElzc3VlIDMwMDAqL1xuICAgICAgICBmdW5jdGlvbiB3b3JrZmxvd19zYXZlX2FzKCkge1xuICAgICAgICAgICAgdmFyIGJvZHkgPSAkKFxuICAgICAgICAgICAgICAgICc8Zm9ybT48bGFiZWwgc3R5bGU9XCJkaXNwbGF5OmlubGluZS1ibG9jazsgd2lkdGg6IDEwMCU7XCI+U2F2ZSBhcyBuYW1lOiA8L2xhYmVsPjxpbnB1dCB0eXBlPVwidGV4dFwiIGlkPVwid29ya2Zsb3dfcmVuYW1lXCIgc3R5bGU9XCJ3aWR0aDogODAlO1wiIGF1dG9mb2N1cy8+JyArXG4gICAgICAgICAgICAgICAgICAgICc8YnI+PGxhYmVsIHN0eWxlPVwiZGlzcGxheTppbmxpbmUtYmxvY2s7IHdpZHRoOiAxMDAlO1wiPkFubm90YXRpb246IDwvbGFiZWw+PGlucHV0IHR5cGU9XCJ0ZXh0XCIgaWQ9XCJ3Zl9hbm5vdGF0aW9uXCIgc3R5bGU9XCJ3aWR0aDogODAlO1wiIC8+PC9mb3JtPidcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB3aW5kb3cuc2hvd19tb2RhbChcIlNhdmUgQXMgYSBOZXcgV29ya2Zsb3dcIiwgYm9keSwge1xuICAgICAgICAgICAgICAgIE9LOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlbmFtZV9uYW1lID1cbiAgICAgICAgICAgICAgICAgICAgICAgICQoXCIjd29ya2Zsb3dfcmVuYW1lXCIpLnZhbCgpLmxlbmd0aCA+IDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/ICQoXCIjd29ya2Zsb3dfcmVuYW1lXCIpLnZhbCgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBgU2F2ZWRBc18ke3NlbGYud29ya2Zsb3cubmFtZX1gO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVuYW1lX2Fubm90YXRpb24gPSAkKFwiI3dmX2Fubm90YXRpb25cIikudmFsKCkubGVuZ3RoID4gMCA/ICQoXCIjd2ZfYW5ub3RhdGlvblwiKS52YWwoKSA6IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgICQuYWpheCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cmw6IHNlbGYudXJscy53b3JrZmxvd19zYXZlX2FzLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJQT1NUXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd29ya2Zsb3dfbmFtZTogcmVuYW1lX25hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd29ya2Zsb3dfYW5ub3RhdGlvbjogcmVuYW1lX2Fubm90YXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd29ya2Zsb3dfZGF0YTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShzZWxmLndvcmtmbG93LnRvX3NpbXBsZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAuZG9uZShpZCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93Lm9uYmVmb3JldW5sb2FkID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbiA9IGAke0dhbGF4eS5yb290fXdvcmtmbG93L2VkaXRvcj9pZD0ke2lkfWA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGlkZV9tb2RhbCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5mYWlsKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaWRlX21vZGFsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxlcnQoXCJTYXZpbmcgdGhpcyB3b3JrZmxvdyBmYWlsZWQuIFBsZWFzZSBjb250YWN0IHRoaXMgc2l0ZSdzIGFkbWluaXN0cmF0b3IuXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBDYW5jZWw6IGhpZGVfbW9kYWxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZWRpdF93b3JrZmxvd19vdXRwdXRzKCkge1xuICAgICAgICAgICAgc2VsZi53b3JrZmxvdy5jbGVhcl9hY3RpdmVfbm9kZSgpO1xuICAgICAgICAgICAgJChcIi5yaWdodC1jb250ZW50XCIpLmhpZGUoKTtcbiAgICAgICAgICAgIHZhciBuZXdfY29udGVudCA9IFwiXCI7XG4gICAgICAgICAgICBmb3IgKHZhciBub2RlX2tleSBpbiBzZWxmLndvcmtmbG93Lm5vZGVzKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5vZGUgPSBzZWxmLndvcmtmbG93Lm5vZGVzW25vZGVfa2V5XTtcbiAgICAgICAgICAgICAgICBpZiAoW1widG9vbFwiLCBcInN1YndvcmtmbG93XCJdLmluZGV4T2Yobm9kZS50eXBlKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld19jb250ZW50ICs9IGA8ZGl2IGNsYXNzPSd0b29sRm9ybScgc3R5bGU9J21hcmdpbi1ib3R0b206NXB4Oyc+PGRpdiBjbGFzcz0ndG9vbEZvcm1UaXRsZSc+U3RlcCAke1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5pZFxuICAgICAgICAgICAgICAgICAgICB9IC0gJHtub2RlLm5hbWV9PC9kaXY+YDtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgb3Rfa2V5IGluIG5vZGUub3V0cHV0X3Rlcm1pbmFscykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG91dHB1dCA9IG5vZGUub3V0cHV0X3Rlcm1pbmFsc1tvdF9rZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUuaXNXb3JrZmxvd091dHB1dChvdXRwdXQubmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdfY29udGVudCArPSBgPHA+JHtvdXRwdXQubmFtZX08aW5wdXQgdHlwZT0nY2hlY2tib3gnIG5hbWU9JyR7bm9kZS5pZH18JHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0Lm5hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9JyBjaGVja2VkIC8+PC9wPmA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld19jb250ZW50ICs9IGA8cD4ke291dHB1dC5uYW1lfTxpbnB1dCB0eXBlPSdjaGVja2JveCcgbmFtZT0nJHtub2RlLmlkfXwke1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQubmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0nIC8+PC9wPmA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbmV3X2NvbnRlbnQgKz0gXCI8L2Rpdj5cIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAkKFwiI291dHB1dC1maWxsLWFyZWFcIikuaHRtbChuZXdfY29udGVudCk7XG4gICAgICAgICAgICAkKFwiI291dHB1dC1maWxsLWFyZWEgaW5wdXRcIikuYmluZChcImNsaWNrXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBub2RlX2lkID0gdGhpcy5uYW1lLnNwbGl0KFwifFwiKVswXTtcbiAgICAgICAgICAgICAgICB2YXIgd29ya2Zsb3dOb2RlID0gdGhpcy53b3JrZmxvdy5ub2Rlc1tub2RlX2lkXTtcbiAgICAgICAgICAgICAgICB2YXIgb3V0cHV0X25hbWUgPSB0aGlzLm5hbWUuc3BsaXQoXCJ8XCIpWzFdO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNoZWNrZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgd29ya2Zsb3dOb2RlLmFkZFdvcmtmbG93T3V0cHV0KG91dHB1dF9uYW1lKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB3b3JrZmxvd05vZGUucmVtb3ZlV29ya2Zsb3dPdXRwdXQob3V0cHV0X25hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZWxmLndvcmtmbG93Lmhhc19jaGFuZ2VzID0gdHJ1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgJChcIiN3b3JrZmxvdy1vdXRwdXQtYXJlYVwiKS5zaG93KCk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBsYXlvdXRfZWRpdG9yKCkge1xuICAgICAgICAgICAgc2VsZi53b3JrZmxvdy5sYXlvdXQoKTtcbiAgICAgICAgICAgIHNlbGYud29ya2Zsb3cuZml0X2NhbnZhc190b19ub2RlcygpO1xuICAgICAgICAgICAgc2VsZi5zY3JvbGxfdG9fbm9kZXMoKTtcbiAgICAgICAgICAgIHNlbGYuY2FudmFzX21hbmFnZXIuZHJhd19vdmVydmlldygpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gT24gbG9hZCwgc2V0IHRoZSBzaXplIHRvIHRoZSBwcmVmIHN0b3JlZCBpbiBsb2NhbCBzdG9yYWdlIGlmIGl0IGV4aXN0c1xuICAgICAgICB2YXIgb3ZlcnZpZXdfc2l6ZSA9ICQualN0b3JhZ2UuZ2V0KFwib3ZlcnZpZXctc2l6ZVwiKTtcbiAgICAgICAgaWYgKG92ZXJ2aWV3X3NpemUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgJChcIiNvdmVydmlldy1ib3JkZXJcIikuY3NzKHtcbiAgICAgICAgICAgICAgICB3aWR0aDogb3ZlcnZpZXdfc2l6ZSxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IG92ZXJ2aWV3X3NpemVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2hvdyB2aWV3cG9ydCBvbiBsb2FkIHVubGVzcyBwcmVmIHNheXMgaXQncyBvZmZcbiAgICAgICAgaWYgKCQualN0b3JhZ2UuZ2V0KFwib3ZlcnZpZXctb2ZmXCIpKSB7XG4gICAgICAgICAgICBoaWRlX292ZXJ2aWV3KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzaG93X292ZXJ2aWV3KCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTdG9yZXMgdGhlIHNpemUgb2YgdGhlIG92ZXJ2aWV3IGludG8gbG9jYWwgc3RvcmFnZSB3aGVuIGl0J3MgcmVzaXplZFxuICAgICAgICAkKFwiI292ZXJ2aWV3LWJvcmRlclwiKS5iaW5kKFwiZHJhZ2VuZFwiLCBmdW5jdGlvbihlLCBkKSB7XG4gICAgICAgICAgICB2YXIgb3AgPSAkKHRoaXMpLm9mZnNldFBhcmVudCgpO1xuICAgICAgICAgICAgdmFyIG9wbyA9IG9wLm9mZnNldCgpO1xuICAgICAgICAgICAgdmFyIG5ld19zaXplID0gTWF0aC5tYXgob3Aud2lkdGgoKSAtIChkLm9mZnNldFggLSBvcG8ubGVmdCksIG9wLmhlaWdodCgpIC0gKGQub2Zmc2V0WSAtIG9wby50b3ApKTtcbiAgICAgICAgICAgICQualN0b3JhZ2Uuc2V0KFwib3ZlcnZpZXctc2l6ZVwiLCBgJHtuZXdfc2l6ZX1weGApO1xuICAgICAgICB9KTtcblxuICAgICAgICBmdW5jdGlvbiBzaG93X292ZXJ2aWV3KCkge1xuICAgICAgICAgICAgJC5qU3RvcmFnZS5zZXQoXCJvdmVydmlldy1vZmZcIiwgZmFsc2UpO1xuICAgICAgICAgICAgJChcIiNvdmVydmlldy1ib3JkZXJcIikuY3NzKFwicmlnaHRcIiwgXCIwcHhcIik7XG4gICAgICAgICAgICAkKFwiI2Nsb3NlLXZpZXdwb3J0XCIpLmNzcyhcImJhY2tncm91bmQtcG9zaXRpb25cIiwgXCIwcHggMHB4XCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gaGlkZV9vdmVydmlldygpIHtcbiAgICAgICAgICAgICQualN0b3JhZ2Uuc2V0KFwib3ZlcnZpZXctb2ZmXCIsIHRydWUpO1xuICAgICAgICAgICAgJChcIiNvdmVydmlldy1ib3JkZXJcIikuY3NzKFwicmlnaHRcIiwgXCIyMDAwMHB4XCIpO1xuICAgICAgICAgICAgJChcIiNjbG9zZS12aWV3cG9ydFwiKS5jc3MoXCJiYWNrZ3JvdW5kLXBvc2l0aW9uXCIsIFwiMTJweCAwcHhcIik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBMZXRzIHRoZSBvdmVydmlldyBiZSB0b2dnbGVkIHZpc2libGUgYW5kIGludmlzaWJsZSwgYWRqdXN0aW5nIHRoZSBhcnJvd3MgYWNjb3JkaW5nbHlcbiAgICAgICAgJChcIiNjbG9zZS12aWV3cG9ydFwiKS5jbGljaygoKSA9PiB7XG4gICAgICAgICAgICBpZiAoJChcIiNvdmVydmlldy1ib3JkZXJcIikuY3NzKFwicmlnaHRcIikgPT09IFwiMHB4XCIpIHtcbiAgICAgICAgICAgICAgICBoaWRlX292ZXJ2aWV3KCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNob3dfb3ZlcnZpZXcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gVW5sb2FkIGhhbmRsZXJcbiAgICAgICAgd2luZG93Lm9uYmVmb3JldW5sb2FkID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHdvcmtmbG93ICYmIHNlbGYud29ya2Zsb3cuaGFzX2NoYW5nZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJUaGVyZSBhcmUgdW5zYXZlZCBjaGFuZ2VzIHRvIHlvdXIgd29ya2Zsb3cgd2hpY2ggd2lsbCBiZSBsb3N0LlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMub3B0aW9ucy53b3JrZmxvd3MubGVuZ3RoID4gMCAmJlxuICAgICAgICAgICAgJChcIiNsZWZ0XCIpXG4gICAgICAgICAgICAgICAgLmZpbmQoXCIudG9vbE1lbnVcIilcbiAgICAgICAgICAgICAgICAuYXBwZW5kKHRoaXMuX2J1aWxkVG9vbFBhbmVsV29ya2Zsb3dzKCkpO1xuXG4gICAgICAgIC8vIFRvb2wgbWVudVxuICAgICAgICAkKFwiZGl2LnRvb2xTZWN0aW9uQm9keVwiKS5oaWRlKCk7XG4gICAgICAgICQoXCJkaXYudG9vbFNlY3Rpb25UaXRsZSA+IHNwYW5cIikud3JhcChcIjxhIGhyZWY9JyMnPjwvYT5cIik7XG4gICAgICAgIHZhciBsYXN0X2V4cGFuZGVkID0gbnVsbDtcbiAgICAgICAgJChcImRpdi50b29sU2VjdGlvblRpdGxlXCIpLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgYm9keSA9ICQodGhpcykubmV4dChcImRpdi50b29sU2VjdGlvbkJvZHlcIik7XG4gICAgICAgICAgICAkKHRoaXMpLmNsaWNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoYm9keS5pcyhcIjpoaWRkZW5cIikpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxhc3RfZXhwYW5kZWQpIGxhc3RfZXhwYW5kZWQuc2xpZGVVcChcImZhc3RcIik7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RfZXhwYW5kZWQgPSBib2R5O1xuICAgICAgICAgICAgICAgICAgICBib2R5LnNsaWRlRG93bihcImZhc3RcIik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYm9keS5zbGlkZVVwKFwiZmFzdFwiKTtcbiAgICAgICAgICAgICAgICAgICAgbGFzdF9leHBhbmRlZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFJlbmFtZSBhc3luYy5cbiAgICAgICAgYXN5bmNfc2F2ZV90ZXh0KFwid29ya2Zsb3ctbmFtZVwiLCBcIndvcmtmbG93LW5hbWVcIiwgc2VsZi51cmxzLnJlbmFtZV9hc3luYywgXCJuZXdfbmFtZVwiKTtcblxuICAgICAgICAvLyBUYWcgYXN5bmMuIFNpbXBseSBoYXZlIHRoZSB3b3JrZmxvdyBlZGl0IGVsZW1lbnQgZ2VuZXJhdGUgYSBjbGljayBvbiB0aGUgdGFnIGVsZW1lbnQgdG8gYWN0aXZhdGUgdGFnZ2luZy5cbiAgICAgICAgJChcIiN3b3JrZmxvdy10YWdcIikuY2xpY2soKCkgPT4ge1xuICAgICAgICAgICAgJChcIi50YWctYXJlYVwiKS5jbGljaygpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gQW5ub3RhdGUgYXN5bmMuXG4gICAgICAgIGFzeW5jX3NhdmVfdGV4dChcbiAgICAgICAgICAgIFwid29ya2Zsb3ctYW5ub3RhdGlvblwiLFxuICAgICAgICAgICAgXCJ3b3JrZmxvdy1hbm5vdGF0aW9uXCIsXG4gICAgICAgICAgICBzZWxmLnVybHMuYW5ub3RhdGVfYXN5bmMsXG4gICAgICAgICAgICBcIm5ld19hbm5vdGF0aW9uXCIsXG4gICAgICAgICAgICAyNSxcbiAgICAgICAgICAgIHRydWUsXG4gICAgICAgICAgICA0XG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIF9idWlsZFRvb2xQYW5lbFdvcmtmbG93czogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyICRzZWN0aW9uID0gJChcbiAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwidG9vbFNlY3Rpb25XcmFwcGVyXCI+JyArXG4gICAgICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJ0b29sU2VjdGlvblRpdGxlXCI+JyArXG4gICAgICAgICAgICAgICAgJzxhIGhyZWY9XCIjXCI+PHNwYW4+V29ya2Zsb3dzPC9zcGFuPjwvYT4nICtcbiAgICAgICAgICAgICAgICBcIjwvZGl2PlwiICtcbiAgICAgICAgICAgICAgICAnPGRpdiBjbGFzcz1cInRvb2xTZWN0aW9uQm9keVwiPicgK1xuICAgICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwidG9vbFNlY3Rpb25CZ1wiLz4nICtcbiAgICAgICAgICAgICAgICBcIjwvZGl2PlwiICtcbiAgICAgICAgICAgICAgICBcIjwvZGl2PlwiXG4gICAgICAgICk7XG4gICAgICAgIF8uZWFjaCh0aGlzLm9wdGlvbnMud29ya2Zsb3dzLCB3b3JrZmxvdyA9PiB7XG4gICAgICAgICAgICBpZiAod29ya2Zsb3cuaWQgIT09IHNlbGYub3B0aW9ucy5pZCkge1xuICAgICAgICAgICAgICAgIHZhciBjb3B5ID0gbmV3IFVpLkJ1dHRvbkljb24oe1xuICAgICAgICAgICAgICAgICAgICBpY29uOiBcImZhIGZhLWNvcHlcIixcbiAgICAgICAgICAgICAgICAgICAgY2xzOiBcInVpLWJ1dHRvbi1pY29uLXBsYWluXCIsXG4gICAgICAgICAgICAgICAgICAgIHRvb2x0aXA6IF9sKFwiQ29weSBhbmQgaW5zZXJ0IGluZGl2aWR1YWwgc3RlcHNcIiksXG4gICAgICAgICAgICAgICAgICAgIG9uY2xpY2s6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdvcmtmbG93LnN0ZXBfY291bnQgPCAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jb3B5X2ludG9fd29ya2Zsb3cod29ya2Zsb3cuaWQsIHdvcmtmbG93Lm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkb24ndCBydWluIHRoZSB3b3JrZmxvdyBieSBhZGRpbmcgNTAgc3RlcHMgdW5wcm9tcHRlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBHYWxheHkubW9kYWwuc2hvdyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBfbChcIldhcm5pbmdcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IGBUaGlzIHdpbGwgY29weSAke3dvcmtmbG93LnN0ZXBfY291bnR9IG5ldyBzdGVwcyBpbnRvIHlvdXIgd29ya2Zsb3cuYCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnV0dG9uczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ2FuY2VsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBHYWxheHkubW9kYWwuaGlkZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIENvcHk6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEdhbGF4eS5tb2RhbC5oaWRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jb3B5X2ludG9fd29ya2Zsb3cod29ya2Zsb3cuaWQsIHdvcmtmbG93Lm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB2YXIgJGFkZCA9ICQoXCI8YS8+XCIpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKFwiaHJlZlwiLCBcIiNcIilcbiAgICAgICAgICAgICAgICAgICAgLmh0bWwod29ya2Zsb3cubmFtZSlcbiAgICAgICAgICAgICAgICAgICAgLm9uKFwiY2xpY2tcIiwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5hZGRfbm9kZV9mb3Jfc3Vid29ya2Zsb3cod29ya2Zsb3cubGF0ZXN0X2lkLCB3b3JrZmxvdy5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgJHNlY3Rpb24uZmluZChcIi50b29sU2VjdGlvbkJnXCIpLmFwcGVuZChcbiAgICAgICAgICAgICAgICAgICAgJChcIjxkaXYvPlwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKFwidG9vbFRpdGxlXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKCRhZGQpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKGNvcHkuJGVsKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gJHNlY3Rpb247XG4gICAgfSxcblxuICAgIGNvcHlfaW50b193b3JrZmxvdzogZnVuY3Rpb24od29ya2Zsb3dJZCkge1xuICAgICAgICAvLyBMb2FkIHdvcmtmbG93IGRlZmluaXRpb25cbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB0aGlzLl93b3JrZmxvd0xvYWRBamF4KHdvcmtmbG93SWQsIHtcbiAgICAgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgICAgICBzZWxmLndvcmtmbG93LmZyb21fc2ltcGxlKGRhdGEsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAvLyBEZXRlcm1pbmUgaWYgYW55IHBhcmFtZXRlcnMgd2VyZSAndXBncmFkZWQnIGFuZCBwcm92aWRlIG1lc3NhZ2VcbiAgICAgICAgICAgICAgICB2YXIgdXBncmFkZV9tZXNzYWdlID0gXCJcIjtcbiAgICAgICAgICAgICAgICAkLmVhY2goZGF0YS51cGdyYWRlX21lc3NhZ2VzLCAoaywgdikgPT4ge1xuICAgICAgICAgICAgICAgICAgICB1cGdyYWRlX21lc3NhZ2UgKz0gYDxsaT5TdGVwICR7cGFyc2VJbnQoaywgMTApICsgMX06ICR7c2VsZi53b3JrZmxvdy5ub2Rlc1trXS5uYW1lfTx1bD5gO1xuICAgICAgICAgICAgICAgICAgICAkLmVhY2godiwgKGksIHZ2KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cGdyYWRlX21lc3NhZ2UgKz0gYDxsaT4ke3Z2fTwvbGk+YDtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHVwZ3JhZGVfbWVzc2FnZSArPSBcIjwvdWw+PC9saT5cIjtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAodXBncmFkZV9tZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5zaG93X21vZGFsKFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJTdWJ3b3JrZmxvdyBlbWJlZGRlZCB3aXRoIGNoYW5nZXNcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGBQcm9ibGVtcyB3ZXJlIGVuY291bnRlcmVkIGxvYWRpbmcgdGhpcyB3b3JrZmxvdyAocG9zc2libHkgYSByZXN1bHQgb2YgdG9vbCB1cGdyYWRlcykuIFBsZWFzZSByZXZpZXcgdGhlIGZvbGxvd2luZyBwYXJhbWV0ZXJzIGFuZCB0aGVuIHNhdmUuPHVsPiR7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBncmFkZV9tZXNzYWdlXG4gICAgICAgICAgICAgICAgICAgICAgICB9PC91bD5gLFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBDb250aW51ZTogaGlkZV9tb2RhbCB9XG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaGlkZV9tb2RhbCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBiZWZvcmVTdWJtaXQ6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgICAgICBzaG93X21lc3NhZ2UoXCJJbXBvcnRpbmcgd29ya2Zsb3dcIiwgXCJwcm9ncmVzc1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8vIEdsb2JhbCBzdGF0ZSBmb3IgdGhlIHdob2xlIHdvcmtmbG93XG4gICAgcmVzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLndvcmtmbG93ICYmIHRoaXMud29ya2Zsb3cucmVtb3ZlX2FsbCgpO1xuICAgICAgICB0aGlzLndvcmtmbG93ID0gd2luZG93LndvcmtmbG93X2dsb2JhbHMud29ya2Zsb3cgPSBuZXcgV29ya2Zsb3codGhpcywgJChcIiNjYW52YXMtY29udGFpbmVyXCIpKTtcbiAgICB9LFxuXG4gICAgc2Nyb2xsX3RvX25vZGVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGN2ID0gJChcIiNjYW52YXMtdmlld3BvcnRcIik7XG4gICAgICAgIHZhciBjYyA9ICQoXCIjY2FudmFzLWNvbnRhaW5lclwiKTtcbiAgICAgICAgdmFyIHRvcDtcbiAgICAgICAgdmFyIGxlZnQ7XG4gICAgICAgIGlmIChjYy53aWR0aCgpIDwgY3Yud2lkdGgoKSkge1xuICAgICAgICAgICAgbGVmdCA9IChjdi53aWR0aCgpIC0gY2Mud2lkdGgoKSkgLyAyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGVmdCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNjLmhlaWdodCgpIDwgY3YuaGVpZ2h0KCkpIHtcbiAgICAgICAgICAgIHRvcCA9IChjdi5oZWlnaHQoKSAtIGNjLmhlaWdodCgpKSAvIDI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0b3AgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGNjLmNzcyh7IGxlZnQ6IGxlZnQsIHRvcDogdG9wIH0pO1xuICAgIH0sXG5cbiAgICBfd29ya2Zsb3dMb2FkQWpheDogZnVuY3Rpb24od29ya2Zsb3dJZCwgb3B0aW9ucykge1xuICAgICAgICAkLmFqYXgoXG4gICAgICAgICAgICBVdGlscy5tZXJnZShvcHRpb25zLCB7XG4gICAgICAgICAgICAgICAgdXJsOiB0aGlzLnVybHMubG9hZF93b3JrZmxvdyxcbiAgICAgICAgICAgICAgICBkYXRhOiB7IGlkOiB3b3JrZmxvd0lkLCBfOiBcInRydWVcIiB9LFxuICAgICAgICAgICAgICAgIGRhdGFUeXBlOiBcImpzb25cIixcbiAgICAgICAgICAgICAgICBjYWNoZTogZmFsc2VcbiAgICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIF9tb2R1bGVJbml0QWpheDogZnVuY3Rpb24obm9kZSwgcmVxdWVzdF9kYXRhKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgVXRpbHMucmVxdWVzdCh7XG4gICAgICAgICAgICB0eXBlOiBcIlBPU1RcIixcbiAgICAgICAgICAgIHVybDogYCR7R2FsYXh5LnJvb3R9YXBpL3dvcmtmbG93cy9idWlsZF9tb2R1bGVgLFxuICAgICAgICAgICAgZGF0YTogcmVxdWVzdF9kYXRhLFxuICAgICAgICAgICAgc3VjY2VzczogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgICAgIG5vZGUuaW5pdF9maWVsZF9kYXRhKGRhdGEpO1xuICAgICAgICAgICAgICAgIG5vZGUudXBkYXRlX2ZpZWxkX2RhdGEoZGF0YSk7XG4gICAgICAgICAgICAgICAgc2VsZi53b3JrZmxvdy5hY3RpdmF0ZV9ub2RlKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLy8gQWRkIGEgbmV3IHN0ZXAgdG8gdGhlIHdvcmtmbG93IGJ5IHRvb2wgaWRcbiAgICBhZGRfbm9kZV9mb3JfdG9vbDogZnVuY3Rpb24oaWQsIHRpdGxlKSB7XG4gICAgICAgIHZhciBub2RlID0gdGhpcy53b3JrZmxvdy5jcmVhdGVfbm9kZShcInRvb2xcIiwgdGl0bGUsIGlkKTtcbiAgICAgICAgdGhpcy5fbW9kdWxlSW5pdEFqYXgobm9kZSwge1xuICAgICAgICAgICAgdHlwZTogXCJ0b29sXCIsXG4gICAgICAgICAgICB0b29sX2lkOiBpZCxcbiAgICAgICAgICAgIF86IFwidHJ1ZVwiXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvLyBBZGQgYSBuZXcgc3RlcCB0byB0aGUgd29ya2Zsb3cgYnkgdG9vbCBpZFxuICAgIGFkZF9ub2RlX2Zvcl9zdWJ3b3JrZmxvdzogZnVuY3Rpb24oaWQsIHRpdGxlKSB7XG4gICAgICAgIHZhciBub2RlID0gdGhpcy53b3JrZmxvdy5jcmVhdGVfbm9kZShcInN1YndvcmtmbG93XCIsIHRpdGxlLCBpZCk7XG4gICAgICAgIHRoaXMuX21vZHVsZUluaXRBamF4KG5vZGUsIHtcbiAgICAgICAgICAgIHR5cGU6IFwic3Vid29ya2Zsb3dcIixcbiAgICAgICAgICAgIGNvbnRlbnRfaWQ6IGlkLFxuICAgICAgICAgICAgXzogXCJ0cnVlXCJcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIGFkZF9ub2RlX2Zvcl9tb2R1bGU6IGZ1bmN0aW9uKHR5cGUsIHRpdGxlKSB7XG4gICAgICAgIHZhciBub2RlID0gdGhpcy53b3JrZmxvdy5jcmVhdGVfbm9kZSh0eXBlLCB0aXRsZSk7XG4gICAgICAgIHRoaXMuX21vZHVsZUluaXRBamF4KG5vZGUsIHsgdHlwZTogdHlwZSwgXzogXCJ0cnVlXCIgfSk7XG4gICAgfSxcblxuICAgIGRpc3BsYXlfZmlsZV9saXN0OiBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgIHZhciBhZGRsaXN0ID0gXCI8c2VsZWN0IGlkPSdub2RlX2RhdGFfbGlzdCcgbmFtZT0nbm9kZV9kYXRhX2xpc3QnPlwiO1xuICAgICAgICBmb3IgKHZhciBvdXRfdGVybWluYWwgaW4gbm9kZS5vdXRwdXRfdGVybWluYWxzKSB7XG4gICAgICAgICAgICBhZGRsaXN0ICs9IGA8b3B0aW9uIHZhbHVlPScke291dF90ZXJtaW5hbH0nPiR7b3V0X3Rlcm1pbmFsfTwvb3B0aW9uPmA7XG4gICAgICAgIH1cbiAgICAgICAgYWRkbGlzdCArPSBcIjwvc2VsZWN0PlwiO1xuICAgICAgICByZXR1cm4gYWRkbGlzdDtcbiAgICB9LFxuXG4gICAgc2hvd1dvcmtmbG93UGFyYW1ldGVyczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwYXJhbWV0ZXJfcmUgPSAvXFwkXFx7Lis/XFx9L2c7XG4gICAgICAgIHZhciB3b3JrZmxvd19wYXJhbWV0ZXJzID0gW107XG4gICAgICAgIHZhciB3Zl9wYXJtX2NvbnRhaW5lciA9ICQoXCIjd29ya2Zsb3ctcGFyYW1ldGVycy1jb250YWluZXJcIik7XG4gICAgICAgIHZhciB3Zl9wYXJtX2JveCA9ICQoXCIjd29ya2Zsb3ctcGFyYW1ldGVycy1ib3hcIik7XG4gICAgICAgIHZhciBuZXdfcGFyYW1ldGVyX2NvbnRlbnQgPSBcIlwiO1xuICAgICAgICB2YXIgbWF0Y2hlcyA9IFtdO1xuICAgICAgICAkLmVhY2godGhpcy53b3JrZmxvdy5ub2RlcywgKGssIG5vZGUpID0+IHtcbiAgICAgICAgICAgIGlmIChub2RlLmNvbmZpZ19mb3JtICYmIG5vZGUuY29uZmlnX2Zvcm0uaW5wdXRzKSB7XG4gICAgICAgICAgICAgICAgVXRpbHMuZGVlcGVhY2gobm9kZS5jb25maWdfZm9ybS5pbnB1dHMsIGQgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGQudmFsdWUgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZvcm1fbWF0Y2hlcyA9IGQudmFsdWUubWF0Y2gocGFyYW1ldGVyX3JlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmb3JtX21hdGNoZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVzID0gbWF0Y2hlcy5jb25jYXQoZm9ybV9tYXRjaGVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vZGUucG9zdF9qb2JfYWN0aW9ucykge1xuICAgICAgICAgICAgICAgICQuZWFjaChub2RlLnBvc3Rfam9iX2FjdGlvbnMsIChrLCBwamEpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBqYS5hY3Rpb25fYXJndW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkLmVhY2gocGphLmFjdGlvbl9hcmd1bWVudHMsIChrLCBhY3Rpb25fYXJndW1lbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXJnX21hdGNoZXMgPSBhY3Rpb25fYXJndW1lbnQubWF0Y2gocGFyYW1ldGVyX3JlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXJnX21hdGNoZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlcyA9IG1hdGNoZXMuY29uY2F0KGFyZ19tYXRjaGVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hdGNoZXMpIHtcbiAgICAgICAgICAgICAgICAkLmVhY2gobWF0Y2hlcywgKGssIGVsZW1lbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCQuaW5BcnJheShlbGVtZW50LCB3b3JrZmxvd19wYXJhbWV0ZXJzKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdvcmtmbG93X3BhcmFtZXRlcnMucHVzaChlbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHdvcmtmbG93X3BhcmFtZXRlcnMgJiYgd29ya2Zsb3dfcGFyYW1ldGVycy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgICQuZWFjaCh3b3JrZmxvd19wYXJhbWV0ZXJzLCAoaywgZWxlbWVudCkgPT4ge1xuICAgICAgICAgICAgICAgIG5ld19wYXJhbWV0ZXJfY29udGVudCArPSBgPGRpdj4ke2VsZW1lbnQuc3Vic3RyaW5nKDIsIGVsZW1lbnQubGVuZ3RoIC0gMSl9PC9kaXY+YDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgd2ZfcGFybV9jb250YWluZXIuaHRtbChuZXdfcGFyYW1ldGVyX2NvbnRlbnQpO1xuICAgICAgICAgICAgd2ZfcGFybV9ib3guc2hvdygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd2ZfcGFybV9jb250YWluZXIuaHRtbChuZXdfcGFyYW1ldGVyX2NvbnRlbnQpO1xuICAgICAgICAgICAgd2ZfcGFybV9ib3guaGlkZSgpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHNob3dBdHRyaWJ1dGVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgJChcIi5yaWdodC1jb250ZW50XCIpLmhpZGUoKTtcbiAgICAgICAgJChcIiNlZGl0LWF0dHJpYnV0ZXNcIikuc2hvdygpO1xuICAgIH0sXG5cbiAgICBzaG93Rm9ybTogZnVuY3Rpb24oY29udGVudCwgbm9kZSkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBjbHMgPSBcInJpZ2h0LWNvbnRlbnRcIjtcbiAgICAgICAgdmFyIGlkID0gYCR7Y2xzfS0ke25vZGUuaWR9YDtcbiAgICAgICAgdmFyICRjb250YWluZXIgPSAkKGAjJHtjbHN9YCk7XG4gICAgICAgIGlmIChjb250ZW50ICYmICRjb250YWluZXIuZmluZChgIyR7aWR9YCkubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgIHZhciAkZWwgPSAkKGA8ZGl2IGlkPVwiJHtpZH1cIiBjbGFzcz1cIiR7Y2xzfVwiLz5gKTtcbiAgICAgICAgICAgIGNvbnRlbnQubm9kZSA9IG5vZGU7XG4gICAgICAgICAgICBjb250ZW50LndvcmtmbG93ID0gdGhpcy53b3JrZmxvdztcbiAgICAgICAgICAgIGNvbnRlbnQuZGF0YXR5cGVzID0gdGhpcy5kYXRhdHlwZXM7XG4gICAgICAgICAgICBjb250ZW50Lmljb24gPSBXb3JrZmxvd0ljb25zW25vZGUudHlwZV07XG4gICAgICAgICAgICBjb250ZW50LmNscyA9IFwidWktcG9ydGxldC1uYXJyb3dcIjtcbiAgICAgICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZvcm1fdHlwZSA9IG5vZGUudHlwZSA9PSBcInRvb2xcIiA/IFwiVG9vbFwiIDogXCJEZWZhdWx0XCI7XG4gICAgICAgICAgICAgICAgJGVsLmFwcGVuZChuZXcgRm9ybVdyYXBwZXJzW2Zvcm1fdHlwZV0oY29udGVudCkuZm9ybS4kZWwpO1xuICAgICAgICAgICAgICAgICRjb250YWluZXIuYXBwZW5kKCRlbCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIEdhbGF4eS5lbWl0LmRlYnVnKFwid29ya2Zsb3ctdmlldzo6aW5pdGlhbGl6ZSgpXCIsIFwiTm9kZSBub3QgZm91bmQgaW4gd29ya2Zsb3cuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgICQoYC4ke2Nsc31gKS5oaWRlKCk7XG4gICAgICAgICRjb250YWluZXIuZmluZChgIyR7aWR9YCkuc2hvdygpO1xuICAgICAgICAkY29udGFpbmVyLnNob3coKTtcbiAgICAgICAgJGNvbnRhaW5lci5zY3JvbGxUb3AoKTtcbiAgICB9LFxuXG4gICAgaXNTdWJUeXBlOiBmdW5jdGlvbihjaGlsZCwgcGFyZW50KSB7XG4gICAgICAgIGNoaWxkID0gdGhpcy5leHRfdG9fdHlwZVtjaGlsZF07XG4gICAgICAgIHBhcmVudCA9IHRoaXMuZXh0X3RvX3R5cGVbcGFyZW50XTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZV90b190eXBlW2NoaWxkXSAmJiBwYXJlbnQgaW4gdGhpcy50eXBlX3RvX3R5cGVbY2hpbGRdO1xuICAgIH0sXG5cbiAgICBwcmVidWlsZE5vZGU6IGZ1bmN0aW9uKHR5cGUsIHRpdGxlX3RleHQsIGNvbnRlbnRfaWQpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgJGYgPSAkKFwiPGRpdiBjbGFzcz0ndG9vbEZvcm0gdG9vbEZvcm1JbkNhbnZhcycvPlwiKTtcbiAgICAgICAgdmFyICR0aXRsZSA9ICQoYDxkaXYgY2xhc3M9J3Rvb2xGb3JtVGl0bGUgdW5zZWxlY3RhYmxlJz48c3BhbiBjbGFzcz0nbm9kZVRpdGxlJz4ke3RpdGxlX3RleHR9PC9kaXY+PC9kaXY+YCk7XG4gICAgICAgIGFkZF9ub2RlX2ljb24oJHRpdGxlLmZpbmQoXCIubm9kZVRpdGxlXCIpLCB0eXBlKTtcbiAgICAgICAgJGYuYXBwZW5kKCR0aXRsZSk7XG4gICAgICAgICRmLmNzcyhcImxlZnRcIiwgJCh3aW5kb3cpLnNjcm9sbExlZnQoKSArIDIwKTtcbiAgICAgICAgJGYuY3NzKFwidG9wXCIsICQod2luZG93KS5zY3JvbGxUb3AoKSArIDIwKTtcbiAgICAgICAgJGYuYXBwZW5kKCQoXCI8ZGl2IGNsYXNzPSd0b29sRm9ybUJvZHknPjwvZGl2PlwiKSk7XG4gICAgICAgIHZhciBub2RlID0gbmV3IE5vZGUodGhpcywgeyBlbGVtZW50OiAkZiB9KTtcbiAgICAgICAgbm9kZS50eXBlID0gdHlwZTtcbiAgICAgICAgbm9kZS5jb250ZW50X2lkID0gY29udGVudF9pZDtcbiAgICAgICAgdmFyIHRtcCA9IGA8ZGl2PjxpbWcgaGVpZ2h0PScxNicgYWxpZ249J21pZGRsZScgc3JjPScke1xuICAgICAgICAgICAgR2FsYXh5LnJvb3RcbiAgICAgICAgfXN0YXRpYy9pbWFnZXMvbG9hZGluZ19zbWFsbF93aGl0ZV9iZy5naWYnLz4gbG9hZGluZyB0b29sIGluZm8uLi48L2Rpdj5gO1xuICAgICAgICAkZi5maW5kKFwiLnRvb2xGb3JtQm9keVwiKS5hcHBlbmQodG1wKTtcbiAgICAgICAgLy8gRml4IHdpZHRoIHRvIGNvbXB1dGVkIHdpZHRoXG4gICAgICAgIC8vIE5vdyBhZGQgZmxvYXRzXG4gICAgICAgIHZhciBidXR0b25zID0gJChcIjxkaXYgY2xhc3M9J2J1dHRvbnMnIHN0eWxlPSdmbG9hdDogcmlnaHQ7Jz48L2Rpdj5cIik7XG4gICAgICAgIGlmICh0eXBlICE9PSBcInN1YndvcmtmbG93XCIpIHtcbiAgICAgICAgICAgIGJ1dHRvbnMuYXBwZW5kKFxuICAgICAgICAgICAgICAgICQoXCI8ZGl2Lz5cIilcbiAgICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKFwiZmEtaWNvbi1idXR0b24gZmEgZmEtZmlsZXMtb1wiKVxuICAgICAgICAgICAgICAgICAgICAuY2xpY2soZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLmNsb25lKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGJ1dHRvbnMuYXBwZW5kKFxuICAgICAgICAgICAgJChcIjxkaXYvPlwiKVxuICAgICAgICAgICAgICAgIC5hZGRDbGFzcyhcImZhLWljb24tYnV0dG9uIGZhIGZhLXRpbWVzXCIpXG4gICAgICAgICAgICAgICAgLmNsaWNrKGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICBub2RlLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgICAvLyBQbGFjZSBpbnNpZGUgY29udGFpbmVyXG4gICAgICAgICRmLmFwcGVuZFRvKFwiI2NhbnZhcy1jb250YWluZXJcIik7XG4gICAgICAgIC8vIFBvc2l0aW9uIGluIGNvbnRhaW5lclxuICAgICAgICB2YXIgbyA9ICQoXCIjY2FudmFzLWNvbnRhaW5lclwiKS5wb3NpdGlvbigpO1xuICAgICAgICB2YXIgcCA9ICQoXCIjY2FudmFzLWNvbnRhaW5lclwiKS5wYXJlbnQoKTtcbiAgICAgICAgdmFyIHdpZHRoID0gJGYud2lkdGgoKTtcbiAgICAgICAgdmFyIGhlaWdodCA9ICRmLmhlaWdodCgpO1xuICAgICAgICAkZi5jc3Moe1xuICAgICAgICAgICAgbGVmdDogLW8ubGVmdCArIHAud2lkdGgoKSAvIDIgLSB3aWR0aCAvIDIsXG4gICAgICAgICAgICB0b3A6IC1vLnRvcCArIHAuaGVpZ2h0KCkgLyAyIC0gaGVpZ2h0IC8gMlxuICAgICAgICB9KTtcbiAgICAgICAgYnV0dG9ucy5wcmVwZW5kVG8oJGYuZmluZChcIi50b29sRm9ybVRpdGxlXCIpKTtcbiAgICAgICAgd2lkdGggKz0gYnV0dG9ucy53aWR0aCgpICsgMTA7XG4gICAgICAgICRmLmNzcyhcIndpZHRoXCIsIHdpZHRoKTtcbiAgICAgICAgJGZcbiAgICAgICAgICAgIC5iaW5kKFwiZHJhZ3N0YXJ0XCIsICgpID0+IHtcbiAgICAgICAgICAgICAgICBzZWxmLndvcmtmbG93LmFjdGl2YXRlX25vZGUobm9kZSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmJpbmQoXCJkcmFnZW5kXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHNlbGYud29ya2Zsb3cubm9kZV9jaGFuZ2VkKHRoaXMpO1xuICAgICAgICAgICAgICAgIHNlbGYud29ya2Zsb3cuZml0X2NhbnZhc190b19ub2RlcygpO1xuICAgICAgICAgICAgICAgIHNlbGYuY2FudmFzX21hbmFnZXIuZHJhd19vdmVydmlldygpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5iaW5kKFwiZHJhZ2NsaWNrb25seVwiLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgc2VsZi53b3JrZmxvdy5hY3RpdmF0ZV9ub2RlKG5vZGUpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5iaW5kKFwiZHJhZ1wiLCBmdW5jdGlvbihlLCBkKSB7XG4gICAgICAgICAgICAgICAgLy8gTW92ZVxuICAgICAgICAgICAgICAgIHZhciBwbyA9ICQodGhpcylcbiAgICAgICAgICAgICAgICAgICAgLm9mZnNldFBhcmVudCgpXG4gICAgICAgICAgICAgICAgICAgIC5vZmZzZXQoKTtcblxuICAgICAgICAgICAgICAgIHZhciB4ID0gZC5vZmZzZXRYIC0gcG8ubGVmdDtcbiAgICAgICAgICAgICAgICB2YXIgeSA9IGQub2Zmc2V0WSAtIHBvLnRvcDtcbiAgICAgICAgICAgICAgICAkKHRoaXMpLmNzcyh7IGxlZnQ6IHgsIHRvcDogeSB9KTtcbiAgICAgICAgICAgICAgICAvLyBSZWRyYXdcbiAgICAgICAgICAgICAgICAkKHRoaXMpXG4gICAgICAgICAgICAgICAgICAgIC5maW5kKFwiLnRlcm1pbmFsXCIpXG4gICAgICAgICAgICAgICAgICAgIC5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50ZXJtaW5hbC5yZWRyYXcoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gZ2FsYXh5L3NjcmlwdHMvbXZjL3dvcmtmbG93L3dvcmtmbG93LXZpZXcuanMiXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7OztBQUFBO0FBQ0E7OztBQUFBO0FBQ0E7OztBQUFBO0FBQ0E7OztBQUFBO0FBQ0E7OztBQUFBO0FBQ0E7OztBQUFBO0FBQ0E7OztBQUFBO0FBQ0E7OztBQUFBO0FBQ0E7OztBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFDQTs7Ozs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU9BO0FBREE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBakNBO0FBbUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRkE7QUFDQTtBQUtBO0FBQ0E7QUFFQTtBQUNBO0FBRkE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBdkNBO0FBQ0E7QUF5Q0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVZBO0FBQ0E7QUFZQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBSEE7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUE1QkE7QUE4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBSEE7QUFhQTtBQUNBO0FBdkJBO0FBeUJBO0FBSUE7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQTFCQTtBQTRCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVJBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBRUE7QUFDQTtBQUlBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUEvdkJBO0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///285\n");

/***/ }),

/***/ 286:
/*!*********************************************************!*\
  !*** ./galaxy/scripts/mvc/workflow/workflow-manager.js ***!
  \*********************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function($) {\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _workflowConnector = __webpack_require__(/*! mvc/workflow/workflow-connector */ 126);\n\nvar _workflowConnector2 = _interopRequireDefault(_workflowConnector);\n\nvar _toastr = __webpack_require__(/*! libs/toastr */ 7);\n\nvar Toastr = _interopRequireWildcard(_toastr);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction Workflow(app, canvas_container) {\n    this.app = app;\n    this.canvas_container = canvas_container;\n    this.id_counter = 0;\n    this.nodes = {};\n    this.name = null;\n    this.has_changes = false;\n    this.active_form_has_changes = false;\n    this.workflowOutputLabels = {};\n}\n$.extend(Workflow.prototype, {\n    canLabelOutputWith: function canLabelOutputWith(label) {\n        if (label) {\n            return !(label in this.workflowOutputLabels);\n        } else {\n            // empty labels are non-exclusive, so allow this one.\n            return true;\n        }\n    },\n    registerOutputLabel: function registerOutputLabel(label) {\n        if (label) {\n            this.workflowOutputLabels[label] = true;\n        }\n    },\n    unregisterOutputLabel: function unregisterOutputLabel(label) {\n        if (label) {\n            delete this.workflowOutputLabels[label];\n        }\n    },\n    updateOutputLabel: function updateOutputLabel(fromLabel, toLabel) {\n        if (fromLabel) {\n            this.unregisterOutputLabel(fromLabel);\n        }\n        if (!this.canLabelOutputWith(toLabel)) {\n            Toastr.warning(\"Workflow contains duplicate workflow output labels \" + toLabel + \". This must be fixed before it can be saved.\");\n        }\n        if (toLabel) {\n            this.registerOutputLabel(toLabel);\n        }\n    },\n    attemptUpdateOutputLabel: function attemptUpdateOutputLabel(node, outputName, label) {\n        if (this.canLabelOutputWith(label)) {\n            node.labelWorkflowOutput(outputName, label);\n            node.nodeView.redrawWorkflowOutputs();\n            return true;\n        } else {\n            return false;\n        }\n    },\n    create_node: function create_node(type, title_text, content_id) {\n        var node = this.app.prebuildNode(type, title_text, content_id);\n        this.add_node(node);\n        this.fit_canvas_to_nodes();\n        this.app.canvas_manager.draw_overview();\n        this.activate_node(node);\n        return node;\n    },\n    add_node: function add_node(node) {\n        node.id = this.id_counter;\n        node.element.attr(\"id\", \"wf-node-step-\" + node.id);\n        this.id_counter++;\n        this.nodes[node.id] = node;\n        this.has_changes = true;\n        node.workflow = this;\n    },\n    remove_node: function remove_node(node) {\n        if (this.active_node == node) {\n            this.clear_active_node();\n        }\n        delete this.nodes[node.id];\n        this.has_changes = true;\n    },\n    remove_all: function remove_all() {\n        var wf = this;\n        $.each(this.nodes, function (k, v) {\n            v.destroy();\n            wf.remove_node(v);\n        });\n    },\n    rectify_workflow_outputs: function rectify_workflow_outputs() {\n        // Find out if we're using workflow_outputs or not.\n        var using_workflow_outputs = false;\n        var has_existing_pjas = false;\n        $.each(this.nodes, function (k, node) {\n            if (node.workflow_outputs && node.workflow_outputs.length > 0) {\n                using_workflow_outputs = true;\n            }\n            $.each(node.post_job_actions, function (pja_id, pja) {\n                if (pja.action_type === \"HideDatasetAction\") {\n                    has_existing_pjas = true;\n                }\n            });\n        });\n        if (using_workflow_outputs !== false || has_existing_pjas !== false) {\n            // Using workflow outputs, or has existing pjas.  Remove all PJAs and recreate based on outputs.\n            var self = this;\n            $.each(this.nodes, function (k, node) {\n                if (node.type === \"tool\") {\n                    var node_changed = false;\n                    if (node.post_job_actions === null) {\n                        node.post_job_actions = {};\n                        node_changed = true;\n                    }\n                    var pjas_to_rem = [];\n                    $.each(node.post_job_actions, function (pja_id, pja) {\n                        if (pja.action_type == \"HideDatasetAction\") {\n                            pjas_to_rem.push(pja_id);\n                        }\n                    });\n                    if (pjas_to_rem.length > 0) {\n                        $.each(pjas_to_rem, function (i, pja_name) {\n                            node_changed = true;\n                            delete node.post_job_actions[pja_name];\n                        });\n                    }\n                    if (using_workflow_outputs) {\n                        $.each(node.output_terminals, function (ot_id, ot) {\n                            var create_pja = !node.isWorkflowOutput(ot.name);\n                            if (create_pja === true) {\n                                node_changed = true;\n                                var pja = {\n                                    action_type: \"HideDatasetAction\",\n                                    output_name: ot.name,\n                                    action_arguments: {}\n                                };\n                                node.post_job_actions[\"HideDatasetAction\" + ot.name] = null;\n                                node.post_job_actions[\"HideDatasetAction\" + ot.name] = pja;\n                            }\n                        });\n                    }\n                    // lastly, if this is the active node, and we made changes, reload the display at right.\n                    if (self.active_node == node && node_changed === true) {\n                        self.reload_active_node();\n                    }\n                }\n            });\n        }\n    },\n    to_simple: function to_simple() {\n        var nodes = {};\n        $.each(this.nodes, function (i, node) {\n            var input_connections = {};\n            $.each(node.input_terminals, function (k, t) {\n                input_connections[t.name] = null;\n                // There should only be 0 or 1 connectors, so this is\n                // really a sneaky if statement\n                var cons = [];\n                $.each(t.connectors, function (i, c) {\n                    if (c.handle1) {\n                        var con_dict = {\n                            id: c.handle1.node.id,\n                            output_name: c.handle1.name\n                        };\n                        var input_subworkflow_step_id = t.attributes.input.input_subworkflow_step_id;\n                        if (input_subworkflow_step_id !== undefined) {\n                            con_dict[\"input_subworkflow_step_id\"] = input_subworkflow_step_id;\n                        }\n                        cons[i] = con_dict;\n                        input_connections[t.name] = cons;\n                    }\n                });\n            });\n            var post_job_actions = {};\n            if (node.post_job_actions) {\n                $.each(node.post_job_actions, function (i, act) {\n                    var pja = {\n                        action_type: act.action_type,\n                        output_name: act.output_name,\n                        action_arguments: act.action_arguments\n                    };\n                    post_job_actions[act.action_type + act.output_name] = null;\n                    post_job_actions[act.action_type + act.output_name] = pja;\n                });\n            }\n            if (!node.workflow_outputs) {\n                node.workflow_outputs = [];\n                // Just in case.\n            }\n            var node_data = {\n                id: node.id,\n                type: node.type,\n                content_id: node.content_id,\n                tool_version: node.config_form.version,\n                tool_state: node.tool_state,\n                errors: node.errors,\n                input_connections: input_connections,\n                position: $(node.element).position(),\n                annotation: node.annotation,\n                post_job_actions: node.post_job_actions,\n                uuid: node.uuid,\n                label: node.label,\n                workflow_outputs: node.workflow_outputs\n            };\n            nodes[node.id] = node_data;\n        });\n        return { steps: nodes };\n    },\n    from_simple: function from_simple(data, initialImport_) {\n        var initialImport = initialImport_ === undefined ? true : initialImport_;\n        var wf = this;\n        var offset = 0;\n        if (initialImport) {\n            wf.name = data.name;\n        } else {\n            offset = Object.keys(wf.nodes).length;\n        }\n        var max_id = offset;\n        // First pass, nodes\n        var using_workflow_outputs = false;\n        $.each(data.steps, function (id, step) {\n            var node = wf.app.prebuildNode(step.type, step.name, step.content_id);\n            // If workflow being copied into another, wipe UUID and let\n            // Galaxy assign new ones.\n            if (!initialImport) {\n                step.uuid = null;\n                $.each(step.workflow_outputs, function (name, workflow_output) {\n                    workflow_output.uuid = null;\n                });\n            }\n            node.init_field_data(step);\n            if (step.position) {\n                node.element.css({\n                    top: step.position.top,\n                    left: step.position.left\n                });\n            }\n            node.id = parseInt(step.id) + offset;\n            wf.nodes[node.id] = node;\n            max_id = Math.max(max_id, parseInt(id) + offset);\n            // For older workflows, it's possible to have HideDataset PJAs, but not WorkflowOutputs.\n            // Check for either, and then add outputs in the next pass.\n            if (!using_workflow_outputs) {\n                if (node.workflow_outputs.length > 0) {\n                    using_workflow_outputs = true;\n                } else {\n                    $.each(node.post_job_actions || [], function (pja_id, pja) {\n                        if (pja.action_type === \"HideDatasetAction\") {\n                            using_workflow_outputs = true;\n                        }\n                    });\n                }\n            }\n        });\n        wf.id_counter = max_id + 1;\n        // Second pass, connections\n        $.each(data.steps, function (id, step) {\n            var node = wf.nodes[parseInt(id) + offset];\n            $.each(step.input_connections, function (k, v) {\n                if (v) {\n                    if (!$.isArray(v)) {\n                        v = [v];\n                    }\n                    $.each(v, function (l, x) {\n                        var other_node = wf.nodes[parseInt(x.id) + offset];\n                        var c = new _workflowConnector2.default();\n                        c.connect(other_node.output_terminals[x.output_name], node.input_terminals[k]);\n                        c.redraw();\n                    });\n                }\n            });\n            if (using_workflow_outputs) {\n                // Ensure that every output terminal has a WorkflowOutput or HideDatasetAction.\n                $.each(node.output_terminals, function (ot_id, ot) {\n                    if (node.post_job_actions[\"HideDatasetAction\" + ot.name] === undefined) {\n                        node.addWorkflowOutput(ot.name);\n                        var callout = $(node.element).find(\".callout.\" + ot.name);\n                        callout.find(\"img\").attr(\"src\", Galaxy.root + \"static/images/fugue/asterisk-small.png\");\n                        wf.has_changes = true;\n                    }\n                });\n            }\n        });\n    },\n    check_changes_in_active_form: function check_changes_in_active_form() {\n        // If active form has changed, save it\n        if (this.active_form_has_changes) {\n            this.has_changes = true;\n            // Submit form.\n            $(\"#right-content\").find(\"form\").submit();\n            this.active_form_has_changes = false;\n        }\n    },\n    reload_active_node: function reload_active_node() {\n        if (this.active_node) {\n            var node = this.active_node;\n            this.clear_active_node();\n            this.activate_node(node);\n        }\n    },\n    clear_active_node: function clear_active_node() {\n        if (this.active_node) {\n            this.active_node.make_inactive();\n            this.active_node = null;\n        }\n        document.activeElement.blur();\n        this.app.showAttributes();\n    },\n    activate_node: function activate_node(node) {\n        if (this.active_node != node) {\n            this.check_changes_in_active_form();\n            this.clear_active_node();\n            this.app.showForm(node.config_form, node);\n            node.make_active();\n            this.active_node = node;\n        }\n    },\n    node_changed: function node_changed(node, force) {\n        this.has_changes = true;\n        if (this.active_node == node && force) {\n            // Force changes to be saved even on new connection (previously dumped)\n            this.check_changes_in_active_form();\n            this.app.showForm(node.config_form, node);\n        }\n        this.app.showWorkflowParameters();\n    },\n    layout: function layout() {\n        this.check_changes_in_active_form();\n        this.has_changes = true;\n        // Prepare predecessor / successor tracking\n        var n_pred = {};\n        var successors = {};\n        // First pass to initialize arrays even for nodes with no connections\n        $.each(this.nodes, function (id, node) {\n            if (n_pred[id] === undefined) {\n                n_pred[id] = 0;\n            }\n            if (successors[id] === undefined) {\n                successors[id] = [];\n            }\n        });\n        // Second pass to count predecessors and successors\n        $.each(this.nodes, function (id, node) {\n            $.each(node.input_terminals, function (j, t) {\n                $.each(t.connectors, function (k, c) {\n                    // A connection exists from `other` to `node`\n                    var other = c.handle1.node;\n                    // node gains a predecessor\n                    n_pred[node.id] += 1;\n                    // other gains a successor\n                    successors[other.id].push(node.id);\n                });\n            });\n        });\n        // Assemble order, tracking levels\n        var node_ids_by_level = [];\n        while (true) {\n            // Everything without a predecessor\n            var level_parents = [];\n            for (var pred_k in n_pred) {\n                if (n_pred[pred_k] === 0) {\n                    level_parents.push(pred_k);\n                }\n            }\n            if (level_parents.length === 0) {\n                break;\n            }\n            node_ids_by_level.push(level_parents);\n            // Remove the parents from this level, and decrement the number\n            // of predecessors for each successor\n            for (var k in level_parents) {\n                var v = level_parents[k];\n                delete n_pred[v];\n                for (var sk in successors[v]) {\n                    n_pred[successors[v][sk]] -= 1;\n                }\n            }\n        }\n        if (n_pred.length) {\n            // ERROR: CYCLE! Currently we do nothing\n            return;\n        }\n        // Layout each level\n        var all_nodes = this.nodes;\n        var h_pad = 80;\n        var v_pad = 30;\n        var left = h_pad;\n        $.each(node_ids_by_level, function (i, ids) {\n            // We keep nodes in the same order in a level to give the user\n            // some control over ordering\n            ids.sort(function (a, b) {\n                return $(all_nodes[a].element).position().top - $(all_nodes[b].element).position().top;\n            });\n            // Position each node\n            var max_width = 0;\n            var top = v_pad;\n            $.each(ids, function (j, id) {\n                var node = all_nodes[id];\n                var element = $(node.element);\n                $(element).css({ top: top, left: left });\n                max_width = Math.max(max_width, $(element).width());\n                top += $(element).height() + v_pad;\n            });\n            left += max_width + h_pad;\n        });\n        // Need to redraw all connectors\n        $.each(all_nodes, function (_, node) {\n            node.redraw();\n        });\n    },\n    bounds_for_all_nodes: function bounds_for_all_nodes() {\n        var xmin = Infinity;\n        var xmax = -Infinity;\n        var ymin = Infinity;\n        var ymax = -Infinity;\n        var p;\n        $.each(this.nodes, function (id, node) {\n            var e = $(node.element);\n            p = e.position();\n            xmin = Math.min(xmin, p.left);\n            xmax = Math.max(xmax, p.left + e.width());\n            ymin = Math.min(ymin, p.top);\n            ymax = Math.max(ymax, p.top + e.width());\n        });\n        return { xmin: xmin, xmax: xmax, ymin: ymin, ymax: ymax };\n    },\n    fit_canvas_to_nodes: function fit_canvas_to_nodes() {\n        // Math utils\n        function round_up(x, n) {\n            return Math.ceil(x / n) * n;\n        }\n        function fix_delta(x, n) {\n            if (x < n || x > 3 * n) {\n                var new_pos = (Math.ceil(x % n / n) + 1) * n;\n                return -(x - new_pos);\n            }\n            return 0;\n        }\n        // Span of all elements\n        var bounds = this.bounds_for_all_nodes();\n        var position = this.canvas_container.position();\n        var parent = this.canvas_container.parent();\n        // Determine amount we need to expand on top/left\n        var xmin_delta = fix_delta(bounds.xmin, 100);\n        var ymin_delta = fix_delta(bounds.ymin, 100);\n        // May need to expand farther to fill viewport\n        xmin_delta = Math.max(xmin_delta, position.left);\n        ymin_delta = Math.max(ymin_delta, position.top);\n        var left = position.left - xmin_delta;\n        var top = position.top - ymin_delta;\n        // Same for width/height\n        var width = round_up(bounds.xmax + 100, 100) + xmin_delta;\n        var height = round_up(bounds.ymax + 100, 100) + ymin_delta;\n        width = Math.max(width, -left + parent.width());\n        height = Math.max(height, -top + parent.height());\n        // Grow the canvas container\n        this.canvas_container.css({\n            left: left,\n            top: top,\n            width: width,\n            height: height\n        });\n        // Move elements back if needed\n        this.canvas_container.children().each(function () {\n            var p = $(this).position();\n            $(this).css(\"left\", p.left + xmin_delta);\n            $(this).css(\"top\", p.top + ymin_delta);\n        });\n    }\n});\nexports.default = Workflow;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! jquery */ 0)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjg2LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL2dhbGF4eS9zY3JpcHRzL212Yy93b3JrZmxvdy93b3JrZmxvdy1tYW5hZ2VyLmpzPzdjNWUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IENvbm5lY3RvciBmcm9tIFwibXZjL3dvcmtmbG93L3dvcmtmbG93LWNvbm5lY3RvclwiO1xuaW1wb3J0ICogYXMgVG9hc3RyIGZyb20gXCJsaWJzL3RvYXN0clwiO1xuZnVuY3Rpb24gV29ya2Zsb3coYXBwLCBjYW52YXNfY29udGFpbmVyKSB7XG4gICAgdGhpcy5hcHAgPSBhcHA7XG4gICAgdGhpcy5jYW52YXNfY29udGFpbmVyID0gY2FudmFzX2NvbnRhaW5lcjtcbiAgICB0aGlzLmlkX2NvdW50ZXIgPSAwO1xuICAgIHRoaXMubm9kZXMgPSB7fTtcbiAgICB0aGlzLm5hbWUgPSBudWxsO1xuICAgIHRoaXMuaGFzX2NoYW5nZXMgPSBmYWxzZTtcbiAgICB0aGlzLmFjdGl2ZV9mb3JtX2hhc19jaGFuZ2VzID0gZmFsc2U7XG4gICAgdGhpcy53b3JrZmxvd091dHB1dExhYmVscyA9IHt9O1xufVxuJC5leHRlbmQoV29ya2Zsb3cucHJvdG90eXBlLCB7XG4gICAgY2FuTGFiZWxPdXRwdXRXaXRoOiBmdW5jdGlvbihsYWJlbCkge1xuICAgICAgICBpZiAobGFiZWwpIHtcbiAgICAgICAgICAgIHJldHVybiAhKGxhYmVsIGluIHRoaXMud29ya2Zsb3dPdXRwdXRMYWJlbHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gZW1wdHkgbGFiZWxzIGFyZSBub24tZXhjbHVzaXZlLCBzbyBhbGxvdyB0aGlzIG9uZS5cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfSxcbiAgICByZWdpc3Rlck91dHB1dExhYmVsOiBmdW5jdGlvbihsYWJlbCkge1xuICAgICAgICBpZiAobGFiZWwpIHtcbiAgICAgICAgICAgIHRoaXMud29ya2Zsb3dPdXRwdXRMYWJlbHNbbGFiZWxdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgdW5yZWdpc3Rlck91dHB1dExhYmVsOiBmdW5jdGlvbihsYWJlbCkge1xuICAgICAgICBpZiAobGFiZWwpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLndvcmtmbG93T3V0cHV0TGFiZWxzW2xhYmVsXTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgdXBkYXRlT3V0cHV0TGFiZWw6IGZ1bmN0aW9uKGZyb21MYWJlbCwgdG9MYWJlbCkge1xuICAgICAgICBpZiAoZnJvbUxhYmVsKSB7XG4gICAgICAgICAgICB0aGlzLnVucmVnaXN0ZXJPdXRwdXRMYWJlbChmcm9tTGFiZWwpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5jYW5MYWJlbE91dHB1dFdpdGgodG9MYWJlbCkpIHtcbiAgICAgICAgICAgIFRvYXN0ci53YXJuaW5nKFxuICAgICAgICAgICAgICAgIGBXb3JrZmxvdyBjb250YWlucyBkdXBsaWNhdGUgd29ya2Zsb3cgb3V0cHV0IGxhYmVscyAke1xuICAgICAgICAgICAgICAgICAgICB0b0xhYmVsXG4gICAgICAgICAgICAgICAgfS4gVGhpcyBtdXN0IGJlIGZpeGVkIGJlZm9yZSBpdCBjYW4gYmUgc2F2ZWQuYFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9MYWJlbCkge1xuICAgICAgICAgICAgdGhpcy5yZWdpc3Rlck91dHB1dExhYmVsKHRvTGFiZWwpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBhdHRlbXB0VXBkYXRlT3V0cHV0TGFiZWw6IGZ1bmN0aW9uKG5vZGUsIG91dHB1dE5hbWUsIGxhYmVsKSB7XG4gICAgICAgIGlmICh0aGlzLmNhbkxhYmVsT3V0cHV0V2l0aChsYWJlbCkpIHtcbiAgICAgICAgICAgIG5vZGUubGFiZWxXb3JrZmxvd091dHB1dChvdXRwdXROYW1lLCBsYWJlbCk7XG4gICAgICAgICAgICBub2RlLm5vZGVWaWV3LnJlZHJhd1dvcmtmbG93T3V0cHV0cygpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGNyZWF0ZV9ub2RlOiBmdW5jdGlvbih0eXBlLCB0aXRsZV90ZXh0LCBjb250ZW50X2lkKSB7XG4gICAgICAgIHZhciBub2RlID0gdGhpcy5hcHAucHJlYnVpbGROb2RlKHR5cGUsIHRpdGxlX3RleHQsIGNvbnRlbnRfaWQpO1xuICAgICAgICB0aGlzLmFkZF9ub2RlKG5vZGUpO1xuICAgICAgICB0aGlzLmZpdF9jYW52YXNfdG9fbm9kZXMoKTtcbiAgICAgICAgdGhpcy5hcHAuY2FudmFzX21hbmFnZXIuZHJhd19vdmVydmlldygpO1xuICAgICAgICB0aGlzLmFjdGl2YXRlX25vZGUobm9kZSk7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH0sXG4gICAgYWRkX25vZGU6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgbm9kZS5pZCA9IHRoaXMuaWRfY291bnRlcjtcbiAgICAgICAgbm9kZS5lbGVtZW50LmF0dHIoXCJpZFwiLCBgd2Ytbm9kZS1zdGVwLSR7bm9kZS5pZH1gKTtcbiAgICAgICAgdGhpcy5pZF9jb3VudGVyKys7XG4gICAgICAgIHRoaXMubm9kZXNbbm9kZS5pZF0gPSBub2RlO1xuICAgICAgICB0aGlzLmhhc19jaGFuZ2VzID0gdHJ1ZTtcbiAgICAgICAgbm9kZS53b3JrZmxvdyA9IHRoaXM7XG4gICAgfSxcbiAgICByZW1vdmVfbm9kZTogZnVuY3Rpb24obm9kZSkge1xuICAgICAgICBpZiAodGhpcy5hY3RpdmVfbm9kZSA9PSBub2RlKSB7XG4gICAgICAgICAgICB0aGlzLmNsZWFyX2FjdGl2ZV9ub2RlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZGVsZXRlIHRoaXMubm9kZXNbbm9kZS5pZF07XG4gICAgICAgIHRoaXMuaGFzX2NoYW5nZXMgPSB0cnVlO1xuICAgIH0sXG4gICAgcmVtb3ZlX2FsbDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB3ZiA9IHRoaXM7XG4gICAgICAgICQuZWFjaCh0aGlzLm5vZGVzLCAoaywgdikgPT4ge1xuICAgICAgICAgICAgdi5kZXN0cm95KCk7XG4gICAgICAgICAgICB3Zi5yZW1vdmVfbm9kZSh2KTtcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICByZWN0aWZ5X3dvcmtmbG93X291dHB1dHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBGaW5kIG91dCBpZiB3ZSdyZSB1c2luZyB3b3JrZmxvd19vdXRwdXRzIG9yIG5vdC5cbiAgICAgICAgdmFyIHVzaW5nX3dvcmtmbG93X291dHB1dHMgPSBmYWxzZTtcbiAgICAgICAgdmFyIGhhc19leGlzdGluZ19wamFzID0gZmFsc2U7XG4gICAgICAgICQuZWFjaCh0aGlzLm5vZGVzLCAoaywgbm9kZSkgPT4ge1xuICAgICAgICAgICAgaWYgKG5vZGUud29ya2Zsb3dfb3V0cHV0cyAmJiBub2RlLndvcmtmbG93X291dHB1dHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHVzaW5nX3dvcmtmbG93X291dHB1dHMgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgJC5lYWNoKG5vZGUucG9zdF9qb2JfYWN0aW9ucywgKHBqYV9pZCwgcGphKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHBqYS5hY3Rpb25fdHlwZSA9PT0gXCJIaWRlRGF0YXNldEFjdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhc19leGlzdGluZ19wamFzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh1c2luZ193b3JrZmxvd19vdXRwdXRzICE9PSBmYWxzZSB8fCBoYXNfZXhpc3RpbmdfcGphcyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIC8vIFVzaW5nIHdvcmtmbG93IG91dHB1dHMsIG9yIGhhcyBleGlzdGluZyBwamFzLiAgUmVtb3ZlIGFsbCBQSkFzIGFuZCByZWNyZWF0ZSBiYXNlZCBvbiBvdXRwdXRzLlxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgJC5lYWNoKHRoaXMubm9kZXMsIChrLCBub2RlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gXCJ0b29sXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGVfY2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5wb3N0X2pvYl9hY3Rpb25zID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLnBvc3Rfam9iX2FjdGlvbnMgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVfY2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIHBqYXNfdG9fcmVtID0gW107XG4gICAgICAgICAgICAgICAgICAgICQuZWFjaChub2RlLnBvc3Rfam9iX2FjdGlvbnMsIChwamFfaWQsIHBqYSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBqYS5hY3Rpb25fdHlwZSA9PSBcIkhpZGVEYXRhc2V0QWN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwamFzX3RvX3JlbS5wdXNoKHBqYV9pZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAocGphc190b19yZW0ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgJC5lYWNoKHBqYXNfdG9fcmVtLCAoaSwgcGphX25hbWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlX2NoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBub2RlLnBvc3Rfam9iX2FjdGlvbnNbcGphX25hbWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHVzaW5nX3dvcmtmbG93X291dHB1dHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICQuZWFjaChub2RlLm91dHB1dF90ZXJtaW5hbHMsIChvdF9pZCwgb3QpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3JlYXRlX3BqYSA9ICFub2RlLmlzV29ya2Zsb3dPdXRwdXQob3QubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNyZWF0ZV9wamEgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZV9jaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBqYSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbl90eXBlOiBcIkhpZGVEYXRhc2V0QWN0aW9uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRfbmFtZTogb3QubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbl9hcmd1bWVudHM6IHt9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUucG9zdF9qb2JfYWN0aW9uc1tgSGlkZURhdGFzZXRBY3Rpb24ke290Lm5hbWV9YF0gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLnBvc3Rfam9iX2FjdGlvbnNbYEhpZGVEYXRhc2V0QWN0aW9uJHtvdC5uYW1lfWBdID0gcGphO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIGxhc3RseSwgaWYgdGhpcyBpcyB0aGUgYWN0aXZlIG5vZGUsIGFuZCB3ZSBtYWRlIGNoYW5nZXMsIHJlbG9hZCB0aGUgZGlzcGxheSBhdCByaWdodC5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuYWN0aXZlX25vZGUgPT0gbm9kZSAmJiBub2RlX2NoYW5nZWQgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYucmVsb2FkX2FjdGl2ZV9ub2RlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgdG9fc2ltcGxlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG5vZGVzID0ge307XG4gICAgICAgICQuZWFjaCh0aGlzLm5vZGVzLCAoaSwgbm9kZSkgPT4ge1xuICAgICAgICAgICAgdmFyIGlucHV0X2Nvbm5lY3Rpb25zID0ge307XG4gICAgICAgICAgICAkLmVhY2gobm9kZS5pbnB1dF90ZXJtaW5hbHMsIChrLCB0KSA9PiB7XG4gICAgICAgICAgICAgICAgaW5wdXRfY29ubmVjdGlvbnNbdC5uYW1lXSA9IG51bGw7XG4gICAgICAgICAgICAgICAgLy8gVGhlcmUgc2hvdWxkIG9ubHkgYmUgMCBvciAxIGNvbm5lY3RvcnMsIHNvIHRoaXMgaXNcbiAgICAgICAgICAgICAgICAvLyByZWFsbHkgYSBzbmVha3kgaWYgc3RhdGVtZW50XG4gICAgICAgICAgICAgICAgdmFyIGNvbnMgPSBbXTtcbiAgICAgICAgICAgICAgICAkLmVhY2godC5jb25uZWN0b3JzLCAoaSwgYykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYy5oYW5kbGUxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29uX2RpY3QgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGMuaGFuZGxlMS5ub2RlLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dF9uYW1lOiBjLmhhbmRsZTEubmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbnB1dF9zdWJ3b3JrZmxvd19zdGVwX2lkID0gdC5hdHRyaWJ1dGVzLmlucHV0LmlucHV0X3N1YndvcmtmbG93X3N0ZXBfaWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXRfc3Vid29ya2Zsb3dfc3RlcF9pZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uX2RpY3RbXCJpbnB1dF9zdWJ3b3JrZmxvd19zdGVwX2lkXCJdID0gaW5wdXRfc3Vid29ya2Zsb3dfc3RlcF9pZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNbaV0gPSBjb25fZGljdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0X2Nvbm5lY3Rpb25zW3QubmFtZV0gPSBjb25zO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBwb3N0X2pvYl9hY3Rpb25zID0ge307XG4gICAgICAgICAgICBpZiAobm9kZS5wb3N0X2pvYl9hY3Rpb25zKSB7XG4gICAgICAgICAgICAgICAgJC5lYWNoKG5vZGUucG9zdF9qb2JfYWN0aW9ucywgKGksIGFjdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGphID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uX3R5cGU6IGFjdC5hY3Rpb25fdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dF9uYW1lOiBhY3Qub3V0cHV0X25hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb25fYXJndW1lbnRzOiBhY3QuYWN0aW9uX2FyZ3VtZW50c1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBwb3N0X2pvYl9hY3Rpb25zW2FjdC5hY3Rpb25fdHlwZSArIGFjdC5vdXRwdXRfbmFtZV0gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBwb3N0X2pvYl9hY3Rpb25zW2FjdC5hY3Rpb25fdHlwZSArIGFjdC5vdXRwdXRfbmFtZV0gPSBwamE7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW5vZGUud29ya2Zsb3dfb3V0cHV0cykge1xuICAgICAgICAgICAgICAgIG5vZGUud29ya2Zsb3dfb3V0cHV0cyA9IFtdO1xuICAgICAgICAgICAgICAgIC8vIEp1c3QgaW4gY2FzZS5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBub2RlX2RhdGEgPSB7XG4gICAgICAgICAgICAgICAgaWQ6IG5vZGUuaWQsXG4gICAgICAgICAgICAgICAgdHlwZTogbm9kZS50eXBlLFxuICAgICAgICAgICAgICAgIGNvbnRlbnRfaWQ6IG5vZGUuY29udGVudF9pZCxcbiAgICAgICAgICAgICAgICB0b29sX3ZlcnNpb246IG5vZGUuY29uZmlnX2Zvcm0udmVyc2lvbixcbiAgICAgICAgICAgICAgICB0b29sX3N0YXRlOiBub2RlLnRvb2xfc3RhdGUsXG4gICAgICAgICAgICAgICAgZXJyb3JzOiBub2RlLmVycm9ycyxcbiAgICAgICAgICAgICAgICBpbnB1dF9jb25uZWN0aW9uczogaW5wdXRfY29ubmVjdGlvbnMsXG4gICAgICAgICAgICAgICAgcG9zaXRpb246ICQobm9kZS5lbGVtZW50KS5wb3NpdGlvbigpLFxuICAgICAgICAgICAgICAgIGFubm90YXRpb246IG5vZGUuYW5ub3RhdGlvbixcbiAgICAgICAgICAgICAgICBwb3N0X2pvYl9hY3Rpb25zOiBub2RlLnBvc3Rfam9iX2FjdGlvbnMsXG4gICAgICAgICAgICAgICAgdXVpZDogbm9kZS51dWlkLFxuICAgICAgICAgICAgICAgIGxhYmVsOiBub2RlLmxhYmVsLFxuICAgICAgICAgICAgICAgIHdvcmtmbG93X291dHB1dHM6IG5vZGUud29ya2Zsb3dfb3V0cHV0c1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIG5vZGVzW25vZGUuaWRdID0gbm9kZV9kYXRhO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHsgc3RlcHM6IG5vZGVzIH07XG4gICAgfSxcbiAgICBmcm9tX3NpbXBsZTogZnVuY3Rpb24oZGF0YSwgaW5pdGlhbEltcG9ydF8pIHtcbiAgICAgICAgdmFyIGluaXRpYWxJbXBvcnQgPSBpbml0aWFsSW1wb3J0XyA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGluaXRpYWxJbXBvcnRfO1xuICAgICAgICB2YXIgd2YgPSB0aGlzO1xuICAgICAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICAgICAgaWYgKGluaXRpYWxJbXBvcnQpIHtcbiAgICAgICAgICAgIHdmLm5hbWUgPSBkYXRhLm5hbWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvZmZzZXQgPSBPYmplY3Qua2V5cyh3Zi5ub2RlcykubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtYXhfaWQgPSBvZmZzZXQ7XG4gICAgICAgIC8vIEZpcnN0IHBhc3MsIG5vZGVzXG4gICAgICAgIHZhciB1c2luZ193b3JrZmxvd19vdXRwdXRzID0gZmFsc2U7XG4gICAgICAgICQuZWFjaChkYXRhLnN0ZXBzLCAoaWQsIHN0ZXApID0+IHtcbiAgICAgICAgICAgIHZhciBub2RlID0gd2YuYXBwLnByZWJ1aWxkTm9kZShzdGVwLnR5cGUsIHN0ZXAubmFtZSwgc3RlcC5jb250ZW50X2lkKTtcbiAgICAgICAgICAgIC8vIElmIHdvcmtmbG93IGJlaW5nIGNvcGllZCBpbnRvIGFub3RoZXIsIHdpcGUgVVVJRCBhbmQgbGV0XG4gICAgICAgICAgICAvLyBHYWxheHkgYXNzaWduIG5ldyBvbmVzLlxuICAgICAgICAgICAgaWYgKCFpbml0aWFsSW1wb3J0KSB7XG4gICAgICAgICAgICAgICAgc3RlcC51dWlkID0gbnVsbDtcbiAgICAgICAgICAgICAgICAkLmVhY2goc3RlcC53b3JrZmxvd19vdXRwdXRzLCAobmFtZSwgd29ya2Zsb3dfb3V0cHV0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHdvcmtmbG93X291dHB1dC51dWlkID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGUuaW5pdF9maWVsZF9kYXRhKHN0ZXApO1xuICAgICAgICAgICAgaWYgKHN0ZXAucG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICBub2RlLmVsZW1lbnQuY3NzKHtcbiAgICAgICAgICAgICAgICAgICAgdG9wOiBzdGVwLnBvc2l0aW9uLnRvcCxcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogc3RlcC5wb3NpdGlvbi5sZWZ0XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2RlLmlkID0gcGFyc2VJbnQoc3RlcC5pZCkgKyBvZmZzZXQ7XG4gICAgICAgICAgICB3Zi5ub2Rlc1tub2RlLmlkXSA9IG5vZGU7XG4gICAgICAgICAgICBtYXhfaWQgPSBNYXRoLm1heChtYXhfaWQsIHBhcnNlSW50KGlkKSArIG9mZnNldCk7XG4gICAgICAgICAgICAvLyBGb3Igb2xkZXIgd29ya2Zsb3dzLCBpdCdzIHBvc3NpYmxlIHRvIGhhdmUgSGlkZURhdGFzZXQgUEpBcywgYnV0IG5vdCBXb3JrZmxvd091dHB1dHMuXG4gICAgICAgICAgICAvLyBDaGVjayBmb3IgZWl0aGVyLCBhbmQgdGhlbiBhZGQgb3V0cHV0cyBpbiB0aGUgbmV4dCBwYXNzLlxuICAgICAgICAgICAgaWYgKCF1c2luZ193b3JrZmxvd19vdXRwdXRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUud29ya2Zsb3dfb3V0cHV0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHVzaW5nX3dvcmtmbG93X291dHB1dHMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICQuZWFjaChub2RlLnBvc3Rfam9iX2FjdGlvbnMgfHwgW10sIChwamFfaWQsIHBqYSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBqYS5hY3Rpb25fdHlwZSA9PT0gXCJIaWRlRGF0YXNldEFjdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNpbmdfd29ya2Zsb3dfb3V0cHV0cyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHdmLmlkX2NvdW50ZXIgPSBtYXhfaWQgKyAxO1xuICAgICAgICAvLyBTZWNvbmQgcGFzcywgY29ubmVjdGlvbnNcbiAgICAgICAgJC5lYWNoKGRhdGEuc3RlcHMsIChpZCwgc3RlcCkgPT4ge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSB3Zi5ub2Rlc1twYXJzZUludChpZCkgKyBvZmZzZXRdO1xuICAgICAgICAgICAgJC5lYWNoKHN0ZXAuaW5wdXRfY29ubmVjdGlvbnMsIChrLCB2KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHYpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEkLmlzQXJyYXkodikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHYgPSBbdl07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgJC5lYWNoKHYsIChsLCB4KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3RoZXJfbm9kZSA9IHdmLm5vZGVzW3BhcnNlSW50KHguaWQpICsgb2Zmc2V0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjID0gbmV3IENvbm5lY3RvcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYy5jb25uZWN0KG90aGVyX25vZGUub3V0cHV0X3Rlcm1pbmFsc1t4Lm91dHB1dF9uYW1lXSwgbm9kZS5pbnB1dF90ZXJtaW5hbHNba10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYy5yZWRyYXcoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAodXNpbmdfd29ya2Zsb3dfb3V0cHV0cykge1xuICAgICAgICAgICAgICAgIC8vIEVuc3VyZSB0aGF0IGV2ZXJ5IG91dHB1dCB0ZXJtaW5hbCBoYXMgYSBXb3JrZmxvd091dHB1dCBvciBIaWRlRGF0YXNldEFjdGlvbi5cbiAgICAgICAgICAgICAgICAkLmVhY2gobm9kZS5vdXRwdXRfdGVybWluYWxzLCAob3RfaWQsIG90KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLnBvc3Rfam9iX2FjdGlvbnNbYEhpZGVEYXRhc2V0QWN0aW9uJHtvdC5uYW1lfWBdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuYWRkV29ya2Zsb3dPdXRwdXQob3QubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2FsbG91dCA9ICQobm9kZS5lbGVtZW50KS5maW5kKGAuY2FsbG91dC4ke290Lm5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsb3V0LmZpbmQoXCJpbWdcIikuYXR0cihcInNyY1wiLCBgJHtHYWxheHkucm9vdH1zdGF0aWMvaW1hZ2VzL2Z1Z3VlL2FzdGVyaXNrLXNtYWxsLnBuZ2ApO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2YuaGFzX2NoYW5nZXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgY2hlY2tfY2hhbmdlc19pbl9hY3RpdmVfZm9ybTogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIElmIGFjdGl2ZSBmb3JtIGhhcyBjaGFuZ2VkLCBzYXZlIGl0XG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZV9mb3JtX2hhc19jaGFuZ2VzKSB7XG4gICAgICAgICAgICB0aGlzLmhhc19jaGFuZ2VzID0gdHJ1ZTtcbiAgICAgICAgICAgIC8vIFN1Ym1pdCBmb3JtLlxuICAgICAgICAgICAgJChcIiNyaWdodC1jb250ZW50XCIpXG4gICAgICAgICAgICAgICAgLmZpbmQoXCJmb3JtXCIpXG4gICAgICAgICAgICAgICAgLnN1Ym1pdCgpO1xuICAgICAgICAgICAgdGhpcy5hY3RpdmVfZm9ybV9oYXNfY2hhbmdlcyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfSxcbiAgICByZWxvYWRfYWN0aXZlX25vZGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5hY3RpdmVfbm9kZSkge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmFjdGl2ZV9ub2RlO1xuICAgICAgICAgICAgdGhpcy5jbGVhcl9hY3RpdmVfbm9kZSgpO1xuICAgICAgICAgICAgdGhpcy5hY3RpdmF0ZV9ub2RlKG5vZGUpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBjbGVhcl9hY3RpdmVfbm9kZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZV9ub2RlKSB7XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZV9ub2RlLm1ha2VfaW5hY3RpdmUoKTtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlX25vZGUgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQuYmx1cigpO1xuICAgICAgICB0aGlzLmFwcC5zaG93QXR0cmlidXRlcygpO1xuICAgIH0sXG4gICAgYWN0aXZhdGVfbm9kZTogZnVuY3Rpb24obm9kZSkge1xuICAgICAgICBpZiAodGhpcy5hY3RpdmVfbm9kZSAhPSBub2RlKSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrX2NoYW5nZXNfaW5fYWN0aXZlX2Zvcm0oKTtcbiAgICAgICAgICAgIHRoaXMuY2xlYXJfYWN0aXZlX25vZGUoKTtcbiAgICAgICAgICAgIHRoaXMuYXBwLnNob3dGb3JtKG5vZGUuY29uZmlnX2Zvcm0sIG5vZGUpO1xuICAgICAgICAgICAgbm9kZS5tYWtlX2FjdGl2ZSgpO1xuICAgICAgICAgICAgdGhpcy5hY3RpdmVfbm9kZSA9IG5vZGU7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIG5vZGVfY2hhbmdlZDogZnVuY3Rpb24obm9kZSwgZm9yY2UpIHtcbiAgICAgICAgdGhpcy5oYXNfY2hhbmdlcyA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZV9ub2RlID09IG5vZGUgJiYgZm9yY2UpIHtcbiAgICAgICAgICAgIC8vIEZvcmNlIGNoYW5nZXMgdG8gYmUgc2F2ZWQgZXZlbiBvbiBuZXcgY29ubmVjdGlvbiAocHJldmlvdXNseSBkdW1wZWQpXG4gICAgICAgICAgICB0aGlzLmNoZWNrX2NoYW5nZXNfaW5fYWN0aXZlX2Zvcm0oKTtcbiAgICAgICAgICAgIHRoaXMuYXBwLnNob3dGb3JtKG5vZGUuY29uZmlnX2Zvcm0sIG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYXBwLnNob3dXb3JrZmxvd1BhcmFtZXRlcnMoKTtcbiAgICB9LFxuICAgIGxheW91dDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuY2hlY2tfY2hhbmdlc19pbl9hY3RpdmVfZm9ybSgpO1xuICAgICAgICB0aGlzLmhhc19jaGFuZ2VzID0gdHJ1ZTtcbiAgICAgICAgLy8gUHJlcGFyZSBwcmVkZWNlc3NvciAvIHN1Y2Nlc3NvciB0cmFja2luZ1xuICAgICAgICB2YXIgbl9wcmVkID0ge307XG4gICAgICAgIHZhciBzdWNjZXNzb3JzID0ge307XG4gICAgICAgIC8vIEZpcnN0IHBhc3MgdG8gaW5pdGlhbGl6ZSBhcnJheXMgZXZlbiBmb3Igbm9kZXMgd2l0aCBubyBjb25uZWN0aW9uc1xuICAgICAgICAkLmVhY2godGhpcy5ub2RlcywgKGlkLCBub2RlKSA9PiB7XG4gICAgICAgICAgICBpZiAobl9wcmVkW2lkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbl9wcmVkW2lkXSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3VjY2Vzc29yc1tpZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3NvcnNbaWRdID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBTZWNvbmQgcGFzcyB0byBjb3VudCBwcmVkZWNlc3NvcnMgYW5kIHN1Y2Nlc3NvcnNcbiAgICAgICAgJC5lYWNoKHRoaXMubm9kZXMsIChpZCwgbm9kZSkgPT4ge1xuICAgICAgICAgICAgJC5lYWNoKG5vZGUuaW5wdXRfdGVybWluYWxzLCAoaiwgdCkgPT4ge1xuICAgICAgICAgICAgICAgICQuZWFjaCh0LmNvbm5lY3RvcnMsIChrLCBjKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEEgY29ubmVjdGlvbiBleGlzdHMgZnJvbSBgb3RoZXJgIHRvIGBub2RlYFxuICAgICAgICAgICAgICAgICAgICB2YXIgb3RoZXIgPSBjLmhhbmRsZTEubm9kZTtcbiAgICAgICAgICAgICAgICAgICAgLy8gbm9kZSBnYWlucyBhIHByZWRlY2Vzc29yXG4gICAgICAgICAgICAgICAgICAgIG5fcHJlZFtub2RlLmlkXSArPSAxO1xuICAgICAgICAgICAgICAgICAgICAvLyBvdGhlciBnYWlucyBhIHN1Y2Nlc3NvclxuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzb3JzW290aGVyLmlkXS5wdXNoKG5vZGUuaWQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBBc3NlbWJsZSBvcmRlciwgdHJhY2tpbmcgbGV2ZWxzXG4gICAgICAgIHZhciBub2RlX2lkc19ieV9sZXZlbCA9IFtdO1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgLy8gRXZlcnl0aGluZyB3aXRob3V0IGEgcHJlZGVjZXNzb3JcbiAgICAgICAgICAgIHZhciBsZXZlbF9wYXJlbnRzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBwcmVkX2sgaW4gbl9wcmVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5fcHJlZFtwcmVkX2tdID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldmVsX3BhcmVudHMucHVzaChwcmVkX2spO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsZXZlbF9wYXJlbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZV9pZHNfYnlfbGV2ZWwucHVzaChsZXZlbF9wYXJlbnRzKTtcbiAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgcGFyZW50cyBmcm9tIHRoaXMgbGV2ZWwsIGFuZCBkZWNyZW1lbnQgdGhlIG51bWJlclxuICAgICAgICAgICAgLy8gb2YgcHJlZGVjZXNzb3JzIGZvciBlYWNoIHN1Y2Nlc3NvclxuICAgICAgICAgICAgZm9yICh2YXIgayBpbiBsZXZlbF9wYXJlbnRzKSB7XG4gICAgICAgICAgICAgICAgdmFyIHYgPSBsZXZlbF9wYXJlbnRzW2tdO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBuX3ByZWRbdl07XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgc2sgaW4gc3VjY2Vzc29yc1t2XSkge1xuICAgICAgICAgICAgICAgICAgICBuX3ByZWRbc3VjY2Vzc29yc1t2XVtza11dIC09IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChuX3ByZWQubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBFUlJPUjogQ1lDTEUhIEN1cnJlbnRseSB3ZSBkbyBub3RoaW5nXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gTGF5b3V0IGVhY2ggbGV2ZWxcbiAgICAgICAgdmFyIGFsbF9ub2RlcyA9IHRoaXMubm9kZXM7XG4gICAgICAgIHZhciBoX3BhZCA9IDgwO1xuICAgICAgICB2YXIgdl9wYWQgPSAzMDtcbiAgICAgICAgdmFyIGxlZnQgPSBoX3BhZDtcbiAgICAgICAgJC5lYWNoKG5vZGVfaWRzX2J5X2xldmVsLCAoaSwgaWRzKSA9PiB7XG4gICAgICAgICAgICAvLyBXZSBrZWVwIG5vZGVzIGluIHRoZSBzYW1lIG9yZGVyIGluIGEgbGV2ZWwgdG8gZ2l2ZSB0aGUgdXNlclxuICAgICAgICAgICAgLy8gc29tZSBjb250cm9sIG92ZXIgb3JkZXJpbmdcbiAgICAgICAgICAgIGlkcy5zb3J0KChhLCBiKSA9PiAkKGFsbF9ub2Rlc1thXS5lbGVtZW50KS5wb3NpdGlvbigpLnRvcCAtICQoYWxsX25vZGVzW2JdLmVsZW1lbnQpLnBvc2l0aW9uKCkudG9wKTtcbiAgICAgICAgICAgIC8vIFBvc2l0aW9uIGVhY2ggbm9kZVxuICAgICAgICAgICAgdmFyIG1heF93aWR0aCA9IDA7XG4gICAgICAgICAgICB2YXIgdG9wID0gdl9wYWQ7XG4gICAgICAgICAgICAkLmVhY2goaWRzLCAoaiwgaWQpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IGFsbF9ub2Rlc1tpZF07XG4gICAgICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSAkKG5vZGUuZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgJChlbGVtZW50KS5jc3MoeyB0b3A6IHRvcCwgbGVmdDogbGVmdCB9KTtcbiAgICAgICAgICAgICAgICBtYXhfd2lkdGggPSBNYXRoLm1heChtYXhfd2lkdGgsICQoZWxlbWVudCkud2lkdGgoKSk7XG4gICAgICAgICAgICAgICAgdG9wICs9ICQoZWxlbWVudCkuaGVpZ2h0KCkgKyB2X3BhZDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbGVmdCArPSBtYXhfd2lkdGggKyBoX3BhZDtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIE5lZWQgdG8gcmVkcmF3IGFsbCBjb25uZWN0b3JzXG4gICAgICAgICQuZWFjaChhbGxfbm9kZXMsIChfLCBub2RlKSA9PiB7XG4gICAgICAgICAgICBub2RlLnJlZHJhdygpO1xuICAgICAgICB9KTtcbiAgICB9LFxuICAgIGJvdW5kc19mb3JfYWxsX25vZGVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHhtaW4gPSBJbmZpbml0eTtcbiAgICAgICAgdmFyIHhtYXggPSAtSW5maW5pdHk7XG4gICAgICAgIHZhciB5bWluID0gSW5maW5pdHk7XG4gICAgICAgIHZhciB5bWF4ID0gLUluZmluaXR5O1xuICAgICAgICB2YXIgcDtcbiAgICAgICAgJC5lYWNoKHRoaXMubm9kZXMsIChpZCwgbm9kZSkgPT4ge1xuICAgICAgICAgICAgdmFyIGUgPSAkKG5vZGUuZWxlbWVudCk7XG4gICAgICAgICAgICBwID0gZS5wb3NpdGlvbigpO1xuICAgICAgICAgICAgeG1pbiA9IE1hdGgubWluKHhtaW4sIHAubGVmdCk7XG4gICAgICAgICAgICB4bWF4ID0gTWF0aC5tYXgoeG1heCwgcC5sZWZ0ICsgZS53aWR0aCgpKTtcbiAgICAgICAgICAgIHltaW4gPSBNYXRoLm1pbih5bWluLCBwLnRvcCk7XG4gICAgICAgICAgICB5bWF4ID0gTWF0aC5tYXgoeW1heCwgcC50b3AgKyBlLndpZHRoKCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHsgeG1pbjogeG1pbiwgeG1heDogeG1heCwgeW1pbjogeW1pbiwgeW1heDogeW1heCB9O1xuICAgIH0sXG4gICAgZml0X2NhbnZhc190b19ub2RlczogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIE1hdGggdXRpbHNcbiAgICAgICAgZnVuY3Rpb24gcm91bmRfdXAoeCwgbikge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguY2VpbCh4IC8gbikgKiBuO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGZpeF9kZWx0YSh4LCBuKSB7XG4gICAgICAgICAgICBpZiAoeCA8IG4gfHwgeCA+IDMgKiBuKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5ld19wb3MgPSAoTWF0aC5jZWlsKCh4ICUgbikgLyBuKSArIDEpICogbjtcbiAgICAgICAgICAgICAgICByZXR1cm4gLSh4IC0gbmV3X3Bvcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBTcGFuIG9mIGFsbCBlbGVtZW50c1xuICAgICAgICB2YXIgYm91bmRzID0gdGhpcy5ib3VuZHNfZm9yX2FsbF9ub2RlcygpO1xuICAgICAgICB2YXIgcG9zaXRpb24gPSB0aGlzLmNhbnZhc19jb250YWluZXIucG9zaXRpb24oKTtcbiAgICAgICAgdmFyIHBhcmVudCA9IHRoaXMuY2FudmFzX2NvbnRhaW5lci5wYXJlbnQoKTtcbiAgICAgICAgLy8gRGV0ZXJtaW5lIGFtb3VudCB3ZSBuZWVkIHRvIGV4cGFuZCBvbiB0b3AvbGVmdFxuICAgICAgICB2YXIgeG1pbl9kZWx0YSA9IGZpeF9kZWx0YShib3VuZHMueG1pbiwgMTAwKTtcbiAgICAgICAgdmFyIHltaW5fZGVsdGEgPSBmaXhfZGVsdGEoYm91bmRzLnltaW4sIDEwMCk7XG4gICAgICAgIC8vIE1heSBuZWVkIHRvIGV4cGFuZCBmYXJ0aGVyIHRvIGZpbGwgdmlld3BvcnRcbiAgICAgICAgeG1pbl9kZWx0YSA9IE1hdGgubWF4KHhtaW5fZGVsdGEsIHBvc2l0aW9uLmxlZnQpO1xuICAgICAgICB5bWluX2RlbHRhID0gTWF0aC5tYXgoeW1pbl9kZWx0YSwgcG9zaXRpb24udG9wKTtcbiAgICAgICAgdmFyIGxlZnQgPSBwb3NpdGlvbi5sZWZ0IC0geG1pbl9kZWx0YTtcbiAgICAgICAgdmFyIHRvcCA9IHBvc2l0aW9uLnRvcCAtIHltaW5fZGVsdGE7XG4gICAgICAgIC8vIFNhbWUgZm9yIHdpZHRoL2hlaWdodFxuICAgICAgICB2YXIgd2lkdGggPSByb3VuZF91cChib3VuZHMueG1heCArIDEwMCwgMTAwKSArIHhtaW5fZGVsdGE7XG4gICAgICAgIHZhciBoZWlnaHQgPSByb3VuZF91cChib3VuZHMueW1heCArIDEwMCwgMTAwKSArIHltaW5fZGVsdGE7XG4gICAgICAgIHdpZHRoID0gTWF0aC5tYXgod2lkdGgsIC1sZWZ0ICsgcGFyZW50LndpZHRoKCkpO1xuICAgICAgICBoZWlnaHQgPSBNYXRoLm1heChoZWlnaHQsIC10b3AgKyBwYXJlbnQuaGVpZ2h0KCkpO1xuICAgICAgICAvLyBHcm93IHRoZSBjYW52YXMgY29udGFpbmVyXG4gICAgICAgIHRoaXMuY2FudmFzX2NvbnRhaW5lci5jc3Moe1xuICAgICAgICAgICAgbGVmdDogbGVmdCxcbiAgICAgICAgICAgIHRvcDogdG9wLFxuICAgICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIE1vdmUgZWxlbWVudHMgYmFjayBpZiBuZWVkZWRcbiAgICAgICAgdGhpcy5jYW52YXNfY29udGFpbmVyLmNoaWxkcmVuKCkuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBwID0gJCh0aGlzKS5wb3NpdGlvbigpO1xuICAgICAgICAgICAgJCh0aGlzKS5jc3MoXCJsZWZ0XCIsIHAubGVmdCArIHhtaW5fZGVsdGEpO1xuICAgICAgICAgICAgJCh0aGlzKS5jc3MoXCJ0b3BcIiwgcC50b3AgKyB5bWluX2RlbHRhKTtcbiAgICAgICAgfSk7XG4gICAgfVxufSk7XG5leHBvcnQgZGVmYXVsdCBXb3JrZmxvdztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBnYWxheHkvc2NyaXB0cy9tdmMvd29ya2Zsb3cvd29ya2Zsb3ctbWFuYWdlci5qcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTs7O0FBQUE7QUFDQTtBQURBO0FBQ0E7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBYkE7QUFlQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQW5jQTtBQXFjQTtBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///286\n");

/***/ }),

/***/ 287:
/*!********************************************************!*\
  !*** ./galaxy/scripts/mvc/workflow/workflow-canvas.js ***!
  \********************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function($) {\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nfunction CanvasManager(app, canvas_viewport, overview) {\n    this.app = app;\n    this.cv = canvas_viewport;\n    this.cc = this.cv.find(\"#canvas-container\");\n    this.overview = overview;\n    this.oc = overview.find(\"#overview-canvas\");\n    this.ov = overview.find(\"#overview-viewport\");\n    // Make overview box draggable\n    this.init_drag();\n    // Initialize Copy & Paste events\n    this.init_copy_paste();\n}\n$.extend(CanvasManager.prototype, {\n    init_drag: function init_drag() {\n        var self = this;\n        var move = function move(x, y) {\n            x = Math.min(x, self.cv.width() / 2);\n            x = Math.max(x, -self.cc.width() + self.cv.width() / 2);\n            y = Math.min(y, self.cv.height() / 2);\n            y = Math.max(y, -self.cc.height() + self.cv.height() / 2);\n            self.cc.css({\n                left: x,\n                top: y\n            });\n            self.cv.css({\n                \"background-position-x\": x,\n                \"background-position-y\": y\n            });\n            self.update_viewport_overlay();\n        };\n        // Dragging within canvas background\n        this.cc.each(function () {\n            this.scroll_panel = new ScrollPanel(this);\n        });\n        var x_adjust;\n        var y_adjust;\n        this.cv.bind(\"click\", function () {\n            document.activeElement.blur();\n        }).bind(\"dragstart\", function () {\n            var o = $(this).offset();\n            var p = self.cc.position();\n            y_adjust = p.top - o.top;\n            x_adjust = p.left - o.left;\n        }).bind(\"drag\", function (e, d) {\n            move(d.offsetX + x_adjust, d.offsetY + y_adjust);\n        }).bind(\"dragend\", function () {\n            self.app.workflow.fit_canvas_to_nodes();\n            self.draw_overview();\n        });\n        this.overview.click(function (e) {\n            if (self.overview.hasClass(\"blockaclick\")) {\n                self.overview.removeClass(\"blockaclick\");\n            } else {\n                var in_w = self.cc.width();\n                var in_h = self.cc.height();\n                var o_w = self.oc.width();\n                var o_h = self.oc.height();\n\n                var new_x_offset = e.pageX - self.oc.offset().left - self.ov.width() / 2;\n\n                var new_y_offset = e.pageY - self.oc.offset().top - self.ov.height() / 2;\n\n                move(-(new_x_offset / o_w * in_w), -(new_y_offset / o_h * in_h));\n                self.app.workflow.fit_canvas_to_nodes();\n                self.draw_overview();\n            }\n        });\n        // Dragging for overview pane\n        this.ov.bind(\"drag\", function (e, d) {\n            var in_w = self.cc.width();\n            var in_h = self.cc.height();\n            var o_w = self.oc.width();\n            var o_h = self.oc.height();\n            var new_x_offset = d.offsetX - self.overview.offset().left;\n            var new_y_offset = d.offsetY - self.overview.offset().top;\n            move(-(new_x_offset / o_w * in_w), -(new_y_offset / o_h * in_h));\n        }).bind(\"dragend\", function () {\n            self.overview.addClass(\"blockaclick\");\n            self.app.workflow.fit_canvas_to_nodes();\n            self.draw_overview();\n        });\n        // Dragging for overview border (resize)\n        $(\"#overview-border\").bind(\"drag\", function (e, d) {\n            var op = $(this).offsetParent();\n            var opo = op.offset();\n            var new_size = Math.max(op.width() - (d.offsetX - opo.left), op.height() - (d.offsetY - opo.top));\n            $(this).css({\n                width: new_size,\n                height: new_size\n            });\n            self.draw_overview();\n        });\n\n        /*  Disable dragging for child element of the panel so that resizing can\n                only be done by dragging the borders */\n        $(\"#overview-border div\").bind(\"drag\", function () {});\n    },\n    init_copy_paste: function init_copy_paste() {\n        var _this = this;\n\n        document.addEventListener(\"copy\", function (e) {\n            // If it appears that the user is trying to copy/paste text, we\n            // pass that through.\n            if (window.getSelection().toString() === \"\") {\n                if (_this.app.workflow.active_node && _this.app.workflow.active_node.type !== \"subworkflow\") {\n                    e.clipboardData.setData(\"application/json\", JSON.stringify({\n                        nodeId: _this.app.workflow.active_node.id\n                    }));\n                }\n                e.preventDefault();\n            }\n        });\n\n        document.addEventListener(\"paste\", function (e) {\n            // If it appears that the user is trying to paste into a text box,\n            // pass that through and skip the workflow copy/paste logic.\n            if (document.activeElement && document.activeElement.type !== \"textarea\" && document.activeElement.type !== \"text\") {\n                var nodeId;\n                try {\n                    nodeId = JSON.parse(e.clipboardData.getData(\"application/json\")).nodeId;\n                } catch (error) {}\n                if (nodeId && _this.app.workflow.nodes.hasOwnProperty(nodeId)) {\n                    _this.app.workflow.nodes[nodeId].clone();\n                }\n                e.preventDefault();\n            }\n        });\n    },\n    update_viewport_overlay: function update_viewport_overlay() {\n        var cc = this.cc;\n        var cv = this.cv;\n        var oc = this.oc;\n        var ov = this.ov;\n        var in_w = cc.width();\n        var in_h = cc.height();\n        var o_w = oc.width();\n        var o_h = oc.height();\n        var cc_pos = cc.position();\n        ov.css({\n            left: -(cc_pos.left / in_w * o_w),\n            top: -(cc_pos.top / in_h * o_h),\n            // Subtract 2 to account for borders (maybe just change box sizing style instead?)\n            width: cv.width() / in_w * o_w - 2,\n            height: cv.height() / in_h * o_h - 2\n        });\n    },\n    draw_overview: function draw_overview() {\n        var canvas_el = $(\"#overview-canvas\");\n\n        var size = canvas_el.parent().parent().width();\n\n        var c = canvas_el.get(0).getContext(\"2d\");\n        var in_w = $(\"#canvas-container\").width();\n        var in_h = $(\"#canvas-container\").height();\n        var o_h;\n        var shift_h;\n        var o_w;\n        var shift_w;\n        // Fit canvas into overview area\n        var cv_w = this.cv.width();\n        var cv_h = this.cv.height();\n        if (in_w < cv_w && in_h < cv_h) {\n            // Canvas is smaller than viewport\n            o_w = in_w / cv_w * size;\n            shift_w = (size - o_w) / 2;\n            o_h = in_h / cv_h * size;\n            shift_h = (size - o_h) / 2;\n        } else if (in_w < in_h) {\n            // Taller than wide\n            shift_h = 0;\n            o_h = size;\n            o_w = Math.ceil(o_h * in_w / in_h);\n            shift_w = (size - o_w) / 2;\n        } else {\n            // Wider than tall\n            o_w = size;\n            shift_w = 0;\n            o_h = Math.ceil(o_w * in_h / in_w);\n            shift_h = (size - o_h) / 2;\n        }\n        canvas_el.parent().css({\n            left: shift_w,\n            top: shift_h,\n            width: o_w,\n            height: o_h\n        });\n        canvas_el.attr(\"width\", o_w);\n        canvas_el.attr(\"height\", o_h);\n        // Draw overview\n        $.each(this.app.workflow.nodes, function (id, node) {\n            c.fillStyle = \"#D2C099\";\n            c.strokeStyle = \"#D8B365\";\n            c.lineWidth = 1;\n            var node_element = $(node.element);\n            var position = node_element.position();\n            var x = position.left / in_w * o_w;\n            var y = position.top / in_h * o_h;\n            var w = node_element.width() / in_w * o_w;\n            var h = node_element.height() / in_h * o_h;\n            if (node.errors) {\n                c.fillStyle = \"#FFCCCC\";\n                c.strokeStyle = \"#AA6666\";\n            } else if (node.workflow_outputs !== undefined && node.workflow_outputs.length > 0) {\n                c.fillStyle = \"#E8A92D\";\n                c.strokeStyle = \"#E8A92D\";\n            }\n            c.fillRect(x, y, w, h);\n            c.strokeRect(x, y, w, h);\n        });\n        this.update_viewport_overlay();\n    }\n});\n\n// FIXME: merge scroll panel into CanvasManager, clean up hardcoded stuff.\nfunction ScrollPanel(panel) {\n    this.panel = panel;\n}\n$.extend(ScrollPanel.prototype, {\n    test: function test(e, onmove) {\n        var _this2 = this;\n\n        clearTimeout(this.timeout);\n        var x = e.pageX;\n        var y = e.pageY;\n\n        var // Panel size and position\n        panel = $(this.panel);\n\n        var panel_pos = panel.position();\n        var panel_w = panel.width();\n        var panel_h = panel.height();\n\n        var // Viewport size and offset\n        viewport = panel.parent();\n\n        var viewport_w = viewport.width();\n        var viewport_h = viewport.height();\n        var viewport_offset = viewport.offset();\n\n        var // Edges of viewport (in page coordinates)\n        min_x = viewport_offset.left;\n\n        var min_y = viewport_offset.top;\n        var max_x = min_x + viewport.width();\n        var max_y = min_y + viewport.height();\n\n        var // Legal panel range\n        p_min_x = -(panel_w - viewport_w / 2);\n\n        var p_min_y = -(panel_h - viewport_h / 2);\n        var p_max_x = viewport_w / 2;\n        var p_max_y = viewport_h / 2;\n\n        var // Did the panel move?\n        moved = false;\n\n        var // Constants\n        close_dist = 5;\n\n        var nudge = 23;\n        var t = 0;\n        if (x - close_dist < min_x) {\n            if (panel_pos.left < p_max_x) {\n                t = Math.min(nudge, p_max_x - panel_pos.left);\n                panel.css(\"left\", panel_pos.left + t);\n                moved = true;\n            }\n        } else if (x + close_dist > max_x) {\n            if (panel_pos.left > p_min_x) {\n                t = Math.min(nudge, panel_pos.left - p_min_x);\n                panel.css(\"left\", panel_pos.left - t);\n                moved = true;\n            }\n        } else if (y - close_dist < min_y) {\n            if (panel_pos.top < p_max_y) {\n                t = Math.min(nudge, p_max_y - panel_pos.top);\n                panel.css(\"top\", panel_pos.top + t);\n                moved = true;\n            }\n        } else if (y + close_dist > max_y) {\n            if (panel_pos.top > p_min_y) {\n                t = Math.min(nudge, panel_pos.top - p_min_x);\n                panel.css(\"top\", panel_pos.top - t + \"px\");\n                moved = true;\n            }\n        }\n        if (moved) {\n            // Keep moving even if mouse doesn't move\n            onmove();\n            this.timeout = setTimeout(function () {\n                _this2.test(e, onmove);\n            }, 50);\n        }\n    },\n    stop: function stop() {\n        clearTimeout(this.timeout);\n    }\n});\nexports.default = CanvasManager;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! jquery */ 0)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjg3LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL2dhbGF4eS9zY3JpcHRzL212Yy93b3JrZmxvdy93b3JrZmxvdy1jYW52YXMuanM/YWZmOSJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBDYW52YXNNYW5hZ2VyKGFwcCwgY2FudmFzX3ZpZXdwb3J0LCBvdmVydmlldykge1xuICAgIHRoaXMuYXBwID0gYXBwO1xuICAgIHRoaXMuY3YgPSBjYW52YXNfdmlld3BvcnQ7XG4gICAgdGhpcy5jYyA9IHRoaXMuY3YuZmluZChcIiNjYW52YXMtY29udGFpbmVyXCIpO1xuICAgIHRoaXMub3ZlcnZpZXcgPSBvdmVydmlldztcbiAgICB0aGlzLm9jID0gb3ZlcnZpZXcuZmluZChcIiNvdmVydmlldy1jYW52YXNcIik7XG4gICAgdGhpcy5vdiA9IG92ZXJ2aWV3LmZpbmQoXCIjb3ZlcnZpZXctdmlld3BvcnRcIik7XG4gICAgLy8gTWFrZSBvdmVydmlldyBib3ggZHJhZ2dhYmxlXG4gICAgdGhpcy5pbml0X2RyYWcoKTtcbiAgICAvLyBJbml0aWFsaXplIENvcHkgJiBQYXN0ZSBldmVudHNcbiAgICB0aGlzLmluaXRfY29weV9wYXN0ZSgpO1xufVxuJC5leHRlbmQoQ2FudmFzTWFuYWdlci5wcm90b3R5cGUsIHtcbiAgICBpbml0X2RyYWc6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBtb3ZlID0gKHgsIHkpID0+IHtcbiAgICAgICAgICAgIHggPSBNYXRoLm1pbih4LCBzZWxmLmN2LndpZHRoKCkgLyAyKTtcbiAgICAgICAgICAgIHggPSBNYXRoLm1heCh4LCAtc2VsZi5jYy53aWR0aCgpICsgc2VsZi5jdi53aWR0aCgpIC8gMik7XG4gICAgICAgICAgICB5ID0gTWF0aC5taW4oeSwgc2VsZi5jdi5oZWlnaHQoKSAvIDIpO1xuICAgICAgICAgICAgeSA9IE1hdGgubWF4KHksIC1zZWxmLmNjLmhlaWdodCgpICsgc2VsZi5jdi5oZWlnaHQoKSAvIDIpO1xuICAgICAgICAgICAgc2VsZi5jYy5jc3Moe1xuICAgICAgICAgICAgICAgIGxlZnQ6IHgsXG4gICAgICAgICAgICAgICAgdG9wOiB5XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNlbGYuY3YuY3NzKHtcbiAgICAgICAgICAgICAgICBcImJhY2tncm91bmQtcG9zaXRpb24teFwiOiB4LFxuICAgICAgICAgICAgICAgIFwiYmFja2dyb3VuZC1wb3NpdGlvbi15XCI6IHlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2VsZi51cGRhdGVfdmlld3BvcnRfb3ZlcmxheSgpO1xuICAgICAgICB9O1xuICAgICAgICAvLyBEcmFnZ2luZyB3aXRoaW4gY2FudmFzIGJhY2tncm91bmRcbiAgICAgICAgdGhpcy5jYy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxfcGFuZWwgPSBuZXcgU2Nyb2xsUGFuZWwodGhpcyk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgeF9hZGp1c3Q7XG4gICAgICAgIHZhciB5X2FkanVzdDtcbiAgICAgICAgdGhpcy5jdlxuICAgICAgICAgICAgLmJpbmQoXCJjbGlja1wiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5hY3RpdmVFbGVtZW50LmJsdXIoKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuYmluZChcImRyYWdzdGFydFwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgbyA9ICQodGhpcykub2Zmc2V0KCk7XG4gICAgICAgICAgICAgICAgdmFyIHAgPSBzZWxmLmNjLnBvc2l0aW9uKCk7XG4gICAgICAgICAgICAgICAgeV9hZGp1c3QgPSBwLnRvcCAtIG8udG9wO1xuICAgICAgICAgICAgICAgIHhfYWRqdXN0ID0gcC5sZWZ0IC0gby5sZWZ0O1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5iaW5kKFwiZHJhZ1wiLCAoZSwgZCkgPT4ge1xuICAgICAgICAgICAgICAgIG1vdmUoZC5vZmZzZXRYICsgeF9hZGp1c3QsIGQub2Zmc2V0WSArIHlfYWRqdXN0KTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuYmluZChcImRyYWdlbmRcIiwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHNlbGYuYXBwLndvcmtmbG93LmZpdF9jYW52YXNfdG9fbm9kZXMoKTtcbiAgICAgICAgICAgICAgICBzZWxmLmRyYXdfb3ZlcnZpZXcoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB0aGlzLm92ZXJ2aWV3LmNsaWNrKGUgPT4ge1xuICAgICAgICAgICAgaWYgKHNlbGYub3ZlcnZpZXcuaGFzQ2xhc3MoXCJibG9ja2FjbGlja1wiKSkge1xuICAgICAgICAgICAgICAgIHNlbGYub3ZlcnZpZXcucmVtb3ZlQ2xhc3MoXCJibG9ja2FjbGlja1wiKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGluX3cgPSBzZWxmLmNjLndpZHRoKCk7XG4gICAgICAgICAgICAgICAgdmFyIGluX2ggPSBzZWxmLmNjLmhlaWdodCgpO1xuICAgICAgICAgICAgICAgIHZhciBvX3cgPSBzZWxmLm9jLndpZHRoKCk7XG4gICAgICAgICAgICAgICAgdmFyIG9faCA9IHNlbGYub2MuaGVpZ2h0KCk7XG5cbiAgICAgICAgICAgICAgICB2YXIgbmV3X3hfb2Zmc2V0ID0gZS5wYWdlWCAtIHNlbGYub2Mub2Zmc2V0KCkubGVmdCAtIHNlbGYub3Yud2lkdGgoKSAvIDI7XG5cbiAgICAgICAgICAgICAgICB2YXIgbmV3X3lfb2Zmc2V0ID0gZS5wYWdlWSAtIHNlbGYub2Mub2Zmc2V0KCkudG9wIC0gc2VsZi5vdi5oZWlnaHQoKSAvIDI7XG5cbiAgICAgICAgICAgICAgICBtb3ZlKC0obmV3X3hfb2Zmc2V0IC8gb193ICogaW5fdyksIC0obmV3X3lfb2Zmc2V0IC8gb19oICogaW5faCkpO1xuICAgICAgICAgICAgICAgIHNlbGYuYXBwLndvcmtmbG93LmZpdF9jYW52YXNfdG9fbm9kZXMoKTtcbiAgICAgICAgICAgICAgICBzZWxmLmRyYXdfb3ZlcnZpZXcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIERyYWdnaW5nIGZvciBvdmVydmlldyBwYW5lXG4gICAgICAgIHRoaXMub3ZcbiAgICAgICAgICAgIC5iaW5kKFwiZHJhZ1wiLCAoZSwgZCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBpbl93ID0gc2VsZi5jYy53aWR0aCgpO1xuICAgICAgICAgICAgICAgIHZhciBpbl9oID0gc2VsZi5jYy5oZWlnaHQoKTtcbiAgICAgICAgICAgICAgICB2YXIgb193ID0gc2VsZi5vYy53aWR0aCgpO1xuICAgICAgICAgICAgICAgIHZhciBvX2ggPSBzZWxmLm9jLmhlaWdodCgpO1xuICAgICAgICAgICAgICAgIHZhciBuZXdfeF9vZmZzZXQgPSBkLm9mZnNldFggLSBzZWxmLm92ZXJ2aWV3Lm9mZnNldCgpLmxlZnQ7XG4gICAgICAgICAgICAgICAgdmFyIG5ld195X29mZnNldCA9IGQub2Zmc2V0WSAtIHNlbGYub3ZlcnZpZXcub2Zmc2V0KCkudG9wO1xuICAgICAgICAgICAgICAgIG1vdmUoLShuZXdfeF9vZmZzZXQgLyBvX3cgKiBpbl93KSwgLShuZXdfeV9vZmZzZXQgLyBvX2ggKiBpbl9oKSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmJpbmQoXCJkcmFnZW5kXCIsICgpID0+IHtcbiAgICAgICAgICAgICAgICBzZWxmLm92ZXJ2aWV3LmFkZENsYXNzKFwiYmxvY2thY2xpY2tcIik7XG4gICAgICAgICAgICAgICAgc2VsZi5hcHAud29ya2Zsb3cuZml0X2NhbnZhc190b19ub2RlcygpO1xuICAgICAgICAgICAgICAgIHNlbGYuZHJhd19vdmVydmlldygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIC8vIERyYWdnaW5nIGZvciBvdmVydmlldyBib3JkZXIgKHJlc2l6ZSlcbiAgICAgICAgJChcIiNvdmVydmlldy1ib3JkZXJcIikuYmluZChcImRyYWdcIiwgZnVuY3Rpb24oZSwgZCkge1xuICAgICAgICAgICAgdmFyIG9wID0gJCh0aGlzKS5vZmZzZXRQYXJlbnQoKTtcbiAgICAgICAgICAgIHZhciBvcG8gPSBvcC5vZmZzZXQoKTtcbiAgICAgICAgICAgIHZhciBuZXdfc2l6ZSA9IE1hdGgubWF4KG9wLndpZHRoKCkgLSAoZC5vZmZzZXRYIC0gb3BvLmxlZnQpLCBvcC5oZWlnaHQoKSAtIChkLm9mZnNldFkgLSBvcG8udG9wKSk7XG4gICAgICAgICAgICAkKHRoaXMpLmNzcyh7XG4gICAgICAgICAgICAgICAgd2lkdGg6IG5ld19zaXplLFxuICAgICAgICAgICAgICAgIGhlaWdodDogbmV3X3NpemVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2VsZi5kcmF3X292ZXJ2aWV3KCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8qICBEaXNhYmxlIGRyYWdnaW5nIGZvciBjaGlsZCBlbGVtZW50IG9mIHRoZSBwYW5lbCBzbyB0aGF0IHJlc2l6aW5nIGNhblxuICAgICAgICAgICAgICAgIG9ubHkgYmUgZG9uZSBieSBkcmFnZ2luZyB0aGUgYm9yZGVycyAqL1xuICAgICAgICAkKFwiI292ZXJ2aWV3LWJvcmRlciBkaXZcIikuYmluZChcImRyYWdcIiwgKCkgPT4ge30pO1xuICAgIH0sXG4gICAgaW5pdF9jb3B5X3Bhc3RlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNvcHlcIiwgZSA9PiB7XG4gICAgICAgICAgICAvLyBJZiBpdCBhcHBlYXJzIHRoYXQgdGhlIHVzZXIgaXMgdHJ5aW5nIHRvIGNvcHkvcGFzdGUgdGV4dCwgd2VcbiAgICAgICAgICAgIC8vIHBhc3MgdGhhdCB0aHJvdWdoLlxuICAgICAgICAgICAgaWYgKHdpbmRvdy5nZXRTZWxlY3Rpb24oKS50b1N0cmluZygpID09PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcC53b3JrZmxvdy5hY3RpdmVfbm9kZSAmJlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcC53b3JrZmxvdy5hY3RpdmVfbm9kZS50eXBlICE9PSBcInN1YndvcmtmbG93XCJcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgZS5jbGlwYm9hcmREYXRhLnNldERhdGEoXG4gICAgICAgICAgICAgICAgICAgICAgICBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlSWQ6IHRoaXMuYXBwLndvcmtmbG93LmFjdGl2ZV9ub2RlLmlkXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJwYXN0ZVwiLCBlID0+IHtcbiAgICAgICAgICAgIC8vIElmIGl0IGFwcGVhcnMgdGhhdCB0aGUgdXNlciBpcyB0cnlpbmcgdG8gcGFzdGUgaW50byBhIHRleHQgYm94LFxuICAgICAgICAgICAgLy8gcGFzcyB0aGF0IHRocm91Z2ggYW5kIHNraXAgdGhlIHdvcmtmbG93IGNvcHkvcGFzdGUgbG9naWMuXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAmJlxuICAgICAgICAgICAgICAgIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQudHlwZSAhPT0gXCJ0ZXh0YXJlYVwiICYmXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuYWN0aXZlRWxlbWVudC50eXBlICE9PSBcInRleHRcIlxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5vZGVJZDtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBub2RlSWQgPSBKU09OLnBhcnNlKGUuY2xpcGJvYXJkRGF0YS5nZXREYXRhKFwiYXBwbGljYXRpb24vanNvblwiKSkubm9kZUlkO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7fVxuICAgICAgICAgICAgICAgIGlmIChub2RlSWQgJiYgdGhpcy5hcHAud29ya2Zsb3cubm9kZXMuaGFzT3duUHJvcGVydHkobm9kZUlkKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcC53b3JrZmxvdy5ub2Rlc1tub2RlSWRdLmNsb25lKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICB1cGRhdGVfdmlld3BvcnRfb3ZlcmxheTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjYyA9IHRoaXMuY2M7XG4gICAgICAgIHZhciBjdiA9IHRoaXMuY3Y7XG4gICAgICAgIHZhciBvYyA9IHRoaXMub2M7XG4gICAgICAgIHZhciBvdiA9IHRoaXMub3Y7XG4gICAgICAgIHZhciBpbl93ID0gY2Mud2lkdGgoKTtcbiAgICAgICAgdmFyIGluX2ggPSBjYy5oZWlnaHQoKTtcbiAgICAgICAgdmFyIG9fdyA9IG9jLndpZHRoKCk7XG4gICAgICAgIHZhciBvX2ggPSBvYy5oZWlnaHQoKTtcbiAgICAgICAgdmFyIGNjX3BvcyA9IGNjLnBvc2l0aW9uKCk7XG4gICAgICAgIG92LmNzcyh7XG4gICAgICAgICAgICBsZWZ0OiAtKGNjX3Bvcy5sZWZ0IC8gaW5fdyAqIG9fdyksXG4gICAgICAgICAgICB0b3A6IC0oY2NfcG9zLnRvcCAvIGluX2ggKiBvX2gpLFxuICAgICAgICAgICAgLy8gU3VidHJhY3QgMiB0byBhY2NvdW50IGZvciBib3JkZXJzIChtYXliZSBqdXN0IGNoYW5nZSBib3ggc2l6aW5nIHN0eWxlIGluc3RlYWQ/KVxuICAgICAgICAgICAgd2lkdGg6IGN2LndpZHRoKCkgLyBpbl93ICogb193IC0gMixcbiAgICAgICAgICAgIGhlaWdodDogY3YuaGVpZ2h0KCkgLyBpbl9oICogb19oIC0gMlxuICAgICAgICB9KTtcbiAgICB9LFxuICAgIGRyYXdfb3ZlcnZpZXc6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY2FudmFzX2VsID0gJChcIiNvdmVydmlldy1jYW52YXNcIik7XG5cbiAgICAgICAgdmFyIHNpemUgPSBjYW52YXNfZWxcbiAgICAgICAgICAgIC5wYXJlbnQoKVxuICAgICAgICAgICAgLnBhcmVudCgpXG4gICAgICAgICAgICAud2lkdGgoKTtcblxuICAgICAgICB2YXIgYyA9IGNhbnZhc19lbC5nZXQoMCkuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgICB2YXIgaW5fdyA9ICQoXCIjY2FudmFzLWNvbnRhaW5lclwiKS53aWR0aCgpO1xuICAgICAgICB2YXIgaW5faCA9ICQoXCIjY2FudmFzLWNvbnRhaW5lclwiKS5oZWlnaHQoKTtcbiAgICAgICAgdmFyIG9faDtcbiAgICAgICAgdmFyIHNoaWZ0X2g7XG4gICAgICAgIHZhciBvX3c7XG4gICAgICAgIHZhciBzaGlmdF93O1xuICAgICAgICAvLyBGaXQgY2FudmFzIGludG8gb3ZlcnZpZXcgYXJlYVxuICAgICAgICB2YXIgY3ZfdyA9IHRoaXMuY3Yud2lkdGgoKTtcbiAgICAgICAgdmFyIGN2X2ggPSB0aGlzLmN2LmhlaWdodCgpO1xuICAgICAgICBpZiAoaW5fdyA8IGN2X3cgJiYgaW5faCA8IGN2X2gpIHtcbiAgICAgICAgICAgIC8vIENhbnZhcyBpcyBzbWFsbGVyIHRoYW4gdmlld3BvcnRcbiAgICAgICAgICAgIG9fdyA9IGluX3cgLyBjdl93ICogc2l6ZTtcbiAgICAgICAgICAgIHNoaWZ0X3cgPSAoc2l6ZSAtIG9fdykgLyAyO1xuICAgICAgICAgICAgb19oID0gaW5faCAvIGN2X2ggKiBzaXplO1xuICAgICAgICAgICAgc2hpZnRfaCA9IChzaXplIC0gb19oKSAvIDI7XG4gICAgICAgIH0gZWxzZSBpZiAoaW5fdyA8IGluX2gpIHtcbiAgICAgICAgICAgIC8vIFRhbGxlciB0aGFuIHdpZGVcbiAgICAgICAgICAgIHNoaWZ0X2ggPSAwO1xuICAgICAgICAgICAgb19oID0gc2l6ZTtcbiAgICAgICAgICAgIG9fdyA9IE1hdGguY2VpbChvX2ggKiBpbl93IC8gaW5faCk7XG4gICAgICAgICAgICBzaGlmdF93ID0gKHNpemUgLSBvX3cpIC8gMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFdpZGVyIHRoYW4gdGFsbFxuICAgICAgICAgICAgb193ID0gc2l6ZTtcbiAgICAgICAgICAgIHNoaWZ0X3cgPSAwO1xuICAgICAgICAgICAgb19oID0gTWF0aC5jZWlsKG9fdyAqIGluX2ggLyBpbl93KTtcbiAgICAgICAgICAgIHNoaWZ0X2ggPSAoc2l6ZSAtIG9faCkgLyAyO1xuICAgICAgICB9XG4gICAgICAgIGNhbnZhc19lbC5wYXJlbnQoKS5jc3Moe1xuICAgICAgICAgICAgbGVmdDogc2hpZnRfdyxcbiAgICAgICAgICAgIHRvcDogc2hpZnRfaCxcbiAgICAgICAgICAgIHdpZHRoOiBvX3csXG4gICAgICAgICAgICBoZWlnaHQ6IG9faFxuICAgICAgICB9KTtcbiAgICAgICAgY2FudmFzX2VsLmF0dHIoXCJ3aWR0aFwiLCBvX3cpO1xuICAgICAgICBjYW52YXNfZWwuYXR0cihcImhlaWdodFwiLCBvX2gpO1xuICAgICAgICAvLyBEcmF3IG92ZXJ2aWV3XG4gICAgICAgICQuZWFjaCh0aGlzLmFwcC53b3JrZmxvdy5ub2RlcywgKGlkLCBub2RlKSA9PiB7XG4gICAgICAgICAgICBjLmZpbGxTdHlsZSA9IFwiI0QyQzA5OVwiO1xuICAgICAgICAgICAgYy5zdHJva2VTdHlsZSA9IFwiI0Q4QjM2NVwiO1xuICAgICAgICAgICAgYy5saW5lV2lkdGggPSAxO1xuICAgICAgICAgICAgdmFyIG5vZGVfZWxlbWVudCA9ICQobm9kZS5lbGVtZW50KTtcbiAgICAgICAgICAgIHZhciBwb3NpdGlvbiA9IG5vZGVfZWxlbWVudC5wb3NpdGlvbigpO1xuICAgICAgICAgICAgdmFyIHggPSBwb3NpdGlvbi5sZWZ0IC8gaW5fdyAqIG9fdztcbiAgICAgICAgICAgIHZhciB5ID0gcG9zaXRpb24udG9wIC8gaW5faCAqIG9faDtcbiAgICAgICAgICAgIHZhciB3ID0gbm9kZV9lbGVtZW50LndpZHRoKCkgLyBpbl93ICogb193O1xuICAgICAgICAgICAgdmFyIGggPSBub2RlX2VsZW1lbnQuaGVpZ2h0KCkgLyBpbl9oICogb19oO1xuICAgICAgICAgICAgaWYgKG5vZGUuZXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgYy5maWxsU3R5bGUgPSBcIiNGRkNDQ0NcIjtcbiAgICAgICAgICAgICAgICBjLnN0cm9rZVN0eWxlID0gXCIjQUE2NjY2XCI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG5vZGUud29ya2Zsb3dfb3V0cHV0cyAhPT0gdW5kZWZpbmVkICYmIG5vZGUud29ya2Zsb3dfb3V0cHV0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgYy5maWxsU3R5bGUgPSBcIiNFOEE5MkRcIjtcbiAgICAgICAgICAgICAgICBjLnN0cm9rZVN0eWxlID0gXCIjRThBOTJEXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjLmZpbGxSZWN0KHgsIHksIHcsIGgpO1xuICAgICAgICAgICAgYy5zdHJva2VSZWN0KHgsIHksIHcsIGgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy51cGRhdGVfdmlld3BvcnRfb3ZlcmxheSgpO1xuICAgIH1cbn0pO1xuXG4vLyBGSVhNRTogbWVyZ2Ugc2Nyb2xsIHBhbmVsIGludG8gQ2FudmFzTWFuYWdlciwgY2xlYW4gdXAgaGFyZGNvZGVkIHN0dWZmLlxuZnVuY3Rpb24gU2Nyb2xsUGFuZWwocGFuZWwpIHtcbiAgICB0aGlzLnBhbmVsID0gcGFuZWw7XG59XG4kLmV4dGVuZChTY3JvbGxQYW5lbC5wcm90b3R5cGUsIHtcbiAgICB0ZXN0OiBmdW5jdGlvbihlLCBvbm1vdmUpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dCk7XG4gICAgICAgIHZhciB4ID0gZS5wYWdlWDtcbiAgICAgICAgdmFyIHkgPSBlLnBhZ2VZO1xuXG4gICAgICAgIHZhciAvLyBQYW5lbCBzaXplIGFuZCBwb3NpdGlvblxuICAgICAgICBwYW5lbCA9ICQodGhpcy5wYW5lbCk7XG5cbiAgICAgICAgdmFyIHBhbmVsX3BvcyA9IHBhbmVsLnBvc2l0aW9uKCk7XG4gICAgICAgIHZhciBwYW5lbF93ID0gcGFuZWwud2lkdGgoKTtcbiAgICAgICAgdmFyIHBhbmVsX2ggPSBwYW5lbC5oZWlnaHQoKTtcblxuICAgICAgICB2YXIgLy8gVmlld3BvcnQgc2l6ZSBhbmQgb2Zmc2V0XG4gICAgICAgIHZpZXdwb3J0ID0gcGFuZWwucGFyZW50KCk7XG5cbiAgICAgICAgdmFyIHZpZXdwb3J0X3cgPSB2aWV3cG9ydC53aWR0aCgpO1xuICAgICAgICB2YXIgdmlld3BvcnRfaCA9IHZpZXdwb3J0LmhlaWdodCgpO1xuICAgICAgICB2YXIgdmlld3BvcnRfb2Zmc2V0ID0gdmlld3BvcnQub2Zmc2V0KCk7XG5cbiAgICAgICAgdmFyIC8vIEVkZ2VzIG9mIHZpZXdwb3J0IChpbiBwYWdlIGNvb3JkaW5hdGVzKVxuICAgICAgICBtaW5feCA9IHZpZXdwb3J0X29mZnNldC5sZWZ0O1xuXG4gICAgICAgIHZhciBtaW5feSA9IHZpZXdwb3J0X29mZnNldC50b3A7XG4gICAgICAgIHZhciBtYXhfeCA9IG1pbl94ICsgdmlld3BvcnQud2lkdGgoKTtcbiAgICAgICAgdmFyIG1heF95ID0gbWluX3kgKyB2aWV3cG9ydC5oZWlnaHQoKTtcblxuICAgICAgICB2YXIgLy8gTGVnYWwgcGFuZWwgcmFuZ2VcbiAgICAgICAgcF9taW5feCA9IC0ocGFuZWxfdyAtIHZpZXdwb3J0X3cgLyAyKTtcblxuICAgICAgICB2YXIgcF9taW5feSA9IC0ocGFuZWxfaCAtIHZpZXdwb3J0X2ggLyAyKTtcbiAgICAgICAgdmFyIHBfbWF4X3ggPSB2aWV3cG9ydF93IC8gMjtcbiAgICAgICAgdmFyIHBfbWF4X3kgPSB2aWV3cG9ydF9oIC8gMjtcblxuICAgICAgICB2YXIgLy8gRGlkIHRoZSBwYW5lbCBtb3ZlP1xuICAgICAgICBtb3ZlZCA9IGZhbHNlO1xuXG4gICAgICAgIHZhciAvLyBDb25zdGFudHNcbiAgICAgICAgY2xvc2VfZGlzdCA9IDU7XG5cbiAgICAgICAgdmFyIG51ZGdlID0gMjM7XG4gICAgICAgIHZhciB0ID0gMDtcbiAgICAgICAgaWYgKHggLSBjbG9zZV9kaXN0IDwgbWluX3gpIHtcbiAgICAgICAgICAgIGlmIChwYW5lbF9wb3MubGVmdCA8IHBfbWF4X3gpIHtcbiAgICAgICAgICAgICAgICB0ID0gTWF0aC5taW4obnVkZ2UsIHBfbWF4X3ggLSBwYW5lbF9wb3MubGVmdCk7XG4gICAgICAgICAgICAgICAgcGFuZWwuY3NzKFwibGVmdFwiLCBwYW5lbF9wb3MubGVmdCArIHQpO1xuICAgICAgICAgICAgICAgIG1vdmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh4ICsgY2xvc2VfZGlzdCA+IG1heF94KSB7XG4gICAgICAgICAgICBpZiAocGFuZWxfcG9zLmxlZnQgPiBwX21pbl94KSB7XG4gICAgICAgICAgICAgICAgdCA9IE1hdGgubWluKG51ZGdlLCBwYW5lbF9wb3MubGVmdCAtIHBfbWluX3gpO1xuICAgICAgICAgICAgICAgIHBhbmVsLmNzcyhcImxlZnRcIiwgcGFuZWxfcG9zLmxlZnQgLSB0KTtcbiAgICAgICAgICAgICAgICBtb3ZlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoeSAtIGNsb3NlX2Rpc3QgPCBtaW5feSkge1xuICAgICAgICAgICAgaWYgKHBhbmVsX3Bvcy50b3AgPCBwX21heF95KSB7XG4gICAgICAgICAgICAgICAgdCA9IE1hdGgubWluKG51ZGdlLCBwX21heF95IC0gcGFuZWxfcG9zLnRvcCk7XG4gICAgICAgICAgICAgICAgcGFuZWwuY3NzKFwidG9wXCIsIHBhbmVsX3Bvcy50b3AgKyB0KTtcbiAgICAgICAgICAgICAgICBtb3ZlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoeSArIGNsb3NlX2Rpc3QgPiBtYXhfeSkge1xuICAgICAgICAgICAgaWYgKHBhbmVsX3Bvcy50b3AgPiBwX21pbl95KSB7XG4gICAgICAgICAgICAgICAgdCA9IE1hdGgubWluKG51ZGdlLCBwYW5lbF9wb3MudG9wIC0gcF9taW5feCk7XG4gICAgICAgICAgICAgICAgcGFuZWwuY3NzKFwidG9wXCIsIGAke3BhbmVsX3Bvcy50b3AgLSB0fXB4YCk7XG4gICAgICAgICAgICAgICAgbW92ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChtb3ZlZCkge1xuICAgICAgICAgICAgLy8gS2VlcCBtb3ZpbmcgZXZlbiBpZiBtb3VzZSBkb2Vzbid0IG1vdmVcbiAgICAgICAgICAgIG9ubW92ZSgpO1xuICAgICAgICAgICAgdGhpcy50aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy50ZXN0KGUsIG9ubW92ZSk7XG4gICAgICAgICAgICB9LCA1MCk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHN0b3A6IGZ1bmN0aW9uKCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0KTtcbiAgICB9XG59KTtcbmV4cG9ydCBkZWZhdWx0IENhbnZhc01hbmFnZXI7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gZ2FsYXh5L3NjcmlwdHMvbXZjL3dvcmtmbG93L3dvcmtmbG93LWNhbnZhcy5qcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBR0E7QUFEQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBdk5BO0FBQ0E7QUF5TkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBN0VBO0FBK0VBO0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///287\n");

/***/ }),

/***/ 288:
/*!******************************************************!*\
  !*** ./galaxy/scripts/mvc/workflow/workflow-node.js ***!
  \******************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(Backbone, _, $) {\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _utils = __webpack_require__(/*! utils/utils */ 4);\n\nvar _utils2 = _interopRequireDefault(_utils);\n\nvar _workflowViewNode = __webpack_require__(/*! mvc/workflow/workflow-view-node */ 289);\n\nvar _workflowViewNode2 = _interopRequireDefault(_workflowViewNode);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar Node = Backbone.Model.extend({\n    initialize: function initialize(app, attr) {\n        this.app = app;\n        this.element = attr.element;\n        this.input_terminals = {};\n        this.output_terminals = {};\n        this.errors = {};\n        this.workflow_outputs = [];\n    },\n    getWorkflowOutput: function getWorkflowOutput(outputName) {\n        return _.findWhere(this.workflow_outputs, {\n            output_name: outputName\n        });\n    },\n    isWorkflowOutput: function isWorkflowOutput(outputName) {\n        return this.getWorkflowOutput(outputName) !== undefined;\n    },\n    removeWorkflowOutput: function removeWorkflowOutput(outputName) {\n        while (this.isWorkflowOutput(outputName)) {\n            this.workflow_outputs.splice(this.getWorkflowOutput(outputName), 1);\n        }\n    },\n    addWorkflowOutput: function addWorkflowOutput(outputName, label) {\n        if (!this.isWorkflowOutput(outputName)) {\n            var output = { output_name: outputName };\n            if (label) {\n                output.label = label;\n            }\n            this.workflow_outputs.push(output);\n            return true;\n        }\n        return false;\n    },\n    labelWorkflowOutput: function labelWorkflowOutput(outputName, label) {\n        var changed = false;\n        var oldLabel = null;\n        if (this.isWorkflowOutput(outputName)) {\n            var workflowOutput = this.getWorkflowOutput(outputName);\n            oldLabel = workflowOutput.label;\n            workflowOutput.label = label;\n            changed = oldLabel != label;\n        } else {\n            changed = this.addWorkflowOutput(outputName, label);\n        }\n        if (changed) {\n            this.app.workflow.updateOutputLabel(oldLabel, label);\n            this.markChanged();\n            this.nodeView.redrawWorkflowOutputs();\n        }\n        return changed;\n    },\n    connectedOutputTerminals: function connectedOutputTerminals() {\n        return this._connectedTerminals(this.output_terminals);\n    },\n    _connectedTerminals: function _connectedTerminals(terminals) {\n        var connectedTerminals = [];\n        $.each(terminals, function (_, t) {\n            if (t.connectors.length > 0) {\n                connectedTerminals.push(t);\n            }\n        });\n        return connectedTerminals;\n    },\n    hasConnectedOutputTerminals: function hasConnectedOutputTerminals() {\n        // return this.connectedOutputTerminals().length > 0; <- optimized this\n        var outputTerminals = this.output_terminals;\n        for (var outputName in outputTerminals) {\n            if (outputTerminals[outputName].connectors.length > 0) {\n                return true;\n            }\n        }\n        return false;\n    },\n    connectedMappedInputTerminals: function connectedMappedInputTerminals() {\n        return this._connectedMappedTerminals(this.input_terminals);\n    },\n    hasConnectedMappedInputTerminals: function hasConnectedMappedInputTerminals() {\n        // return this.connectedMappedInputTerminals().length > 0; <- optimized this\n        var inputTerminals = this.input_terminals;\n        for (var inputName in inputTerminals) {\n            var inputTerminal = inputTerminals[inputName];\n            if (inputTerminal.connectors.length > 0 && inputTerminal.isMappedOver()) {\n                return true;\n            }\n        }\n        return false;\n    },\n    _connectedMappedTerminals: function _connectedMappedTerminals(terminals) {\n        var mapped_outputs = [];\n        $.each(terminals, function (_, t) {\n            var mapOver = t.mapOver();\n            if (mapOver.isCollection) {\n                if (t.connectors.length > 0) {\n                    mapped_outputs.push(t);\n                }\n            }\n        });\n        return mapped_outputs;\n    },\n    mappedInputTerminals: function mappedInputTerminals() {\n        return this._mappedTerminals(this.input_terminals);\n    },\n    _mappedTerminals: function _mappedTerminals(terminals) {\n        var mappedTerminals = [];\n        $.each(terminals, function (_, t) {\n            var mapOver = t.mapOver();\n            if (mapOver.isCollection) {\n                mappedTerminals.push(t);\n            }\n        });\n        return mappedTerminals;\n    },\n    hasMappedOverInputTerminals: function hasMappedOverInputTerminals() {\n        var found = false;\n        _.each(this.input_terminals, function (t) {\n            var mapOver = t.mapOver();\n            if (mapOver.isCollection) {\n                found = true;\n            }\n        });\n        return found;\n    },\n    redraw: function redraw() {\n        $.each(this.input_terminals, function (_, t) {\n            t.redraw();\n        });\n        $.each(this.output_terminals, function (_, t) {\n            t.redraw();\n        });\n    },\n    clone: function clone() {\n        var _this = this;\n\n        var copiedData = {\n            name: this.name,\n            label: this.label,\n            annotation: this.annotation,\n            post_job_actions: this.post_job_actions\n        };\n        var node = this.app.workflow.create_node(this.type, this.name, this.content_id);\n\n        _utils2.default.request({\n            type: \"POST\",\n            url: Galaxy.root + \"api/workflows/build_module\",\n            data: {\n                type: this.type,\n                tool_id: this.content_id,\n                inputs: this.tool_state\n            },\n            success: function success(data) {\n                var newData = Object.assign({}, data, copiedData);\n                node.init_field_data(newData);\n                node.update_field_data(newData);\n                _this.app.workflow.activate_node(node);\n            }\n        });\n    },\n    destroy: function destroy() {\n        $.each(this.input_terminals, function (k, t) {\n            t.destroy();\n        });\n        $.each(this.output_terminals, function (k, t) {\n            t.destroy();\n        });\n        this.app.workflow.remove_node(this);\n        $(this.element).remove();\n    },\n    make_active: function make_active() {\n        $(this.element).addClass(\"toolForm-active\");\n    },\n    make_inactive: function make_inactive() {\n        // Keep inactive nodes stacked from most to least recently active\n        // by moving element to the end of parent's node list\n        var element = this.element.get(0);\n        (function (p) {\n            p.removeChild(element);\n            p.appendChild(element);\n        })(element.parentNode);\n        // Remove active class\n        $(element).removeClass(\"toolForm-active\");\n    },\n    init_field_data: function init_field_data(data) {\n        if (data.type) {\n            this.type = data.type;\n        }\n        this.name = data.name;\n        this.config_form = data.config_form;\n        this.tool_version = this.config_form && this.config_form.version;\n        this.tool_state = data.tool_state;\n        this.errors = data.errors;\n        this.tooltip = data.tooltip ? data.tooltip : \"\";\n        this.annotation = data.annotation;\n        this.post_job_actions = data.post_job_actions ? data.post_job_actions : {};\n        this.label = data.label;\n        this.uuid = data.uuid;\n        this.workflow_outputs = data.workflow_outputs ? data.workflow_outputs : [];\n        var node = this;\n        var nodeView = new _workflowViewNode2.default({\n            el: this.element[0],\n            node: node\n        });\n        node.nodeView = nodeView;\n        $.each(data.data_inputs, function (i, input) {\n            nodeView.addDataInput(input);\n        });\n        if (data.data_inputs.length > 0 && data.data_outputs.length > 0) {\n            nodeView.addRule();\n        }\n        $.each(data.data_outputs, function (i, output) {\n            nodeView.addDataOutput(output);\n        });\n        nodeView.render();\n        this.app.workflow.node_changed(this, true);\n    },\n    update_field_data: function update_field_data(data) {\n        var node = this;\n        var nodeView = node.nodeView;\n        // remove unused output views and remove pre-existing output views from data.data_outputs,\n        // so that these are not added twice.\n        var unused_outputs = [];\n        // nodeView.outputViews contains pre-existing outputs,\n        // while data.data_output contains what should be displayed.\n        // Now we gather the unused outputs\n        $.each(nodeView.outputViews, function (i, output_view) {\n            var cur_name = output_view.output.name;\n            var data_names = data.data_outputs;\n            var cur_name_in_data_outputs = false;\n            _.each(data_names, function (data_name) {\n                if (data_name.name == cur_name) {\n                    cur_name_in_data_outputs = true;\n                }\n            });\n            if (cur_name_in_data_outputs === false) {\n                unused_outputs.push(cur_name);\n            }\n        });\n\n        // Remove the unused outputs\n        _.each(unused_outputs, function (unused_output) {\n            _.each(nodeView.outputViews[unused_output].terminalElement.terminal.connectors, function (x) {\n                if (x) {\n                    x.destroy(); // Removes the noodle connectors\n                }\n            });\n            nodeView.outputViews[unused_output].remove(); // removes the rendered output\n            delete nodeView.outputViews[unused_output]; // removes the reference to the output\n            delete node.output_terminals[unused_output]; // removes the output terminal\n        });\n        $.each(node.workflow_outputs, function (i, wf_output) {\n            if (wf_output && !node.output_terminals[wf_output.output_name]) {\n                node.workflow_outputs.splice(i, 1); // removes output from list of workflow outputs\n            }\n        });\n        $.each(data.data_outputs, function (i, output) {\n            if (!nodeView.outputViews[output.name]) {\n                nodeView.addDataOutput(output); // add data output if it does not yet exist\n            } else {\n                // the output already exists, but the output formats may have changed.\n                // Therefore we update the datatypes and destroy invalid connections.\n                node.output_terminals[output.name].datatypes = output.extensions;\n                node.output_terminals[output.name].destroyInvalidConnections();\n            }\n        });\n        this.tool_state = data.tool_state;\n        this.config_form = data.config_form;\n        this.tool_version = this.config_form && this.config_form.version;\n        this.errors = data.errors;\n        this.annotation = data.annotation;\n        this.label = data.label;\n        if (\"post_job_actions\" in data) {\n            // Won't be present in response for data inputs\n            var pja_in = data.post_job_actions;\n            this.post_job_actions = pja_in ? pja_in : {};\n        }\n        node.nodeView.renderToolErrors();\n        // Update input rows\n        var old_body = nodeView.$(\"div.inputs\");\n        var new_body = nodeView.newInputsDiv();\n        var newTerminalViews = {};\n        _.each(data.data_inputs, function (input) {\n            var terminalView = node.nodeView.addDataInput(input, new_body);\n            newTerminalViews[input.name] = terminalView;\n        });\n        // Cleanup any leftover terminals\n        _.each(_.difference(_.values(nodeView.terminalViews), _.values(newTerminalViews)), function (unusedView) {\n            unusedView.el.terminal.destroy();\n        });\n        nodeView.terminalViews = newTerminalViews;\n        node.nodeView.render();\n        // In general workflow editor assumes tool outputs don't change in # or\n        // type (not really valid right?) but adding special logic here for\n        // data collection input parameters that can have their collection\n        // change.\n        if (data.data_outputs.length == 1 && \"collection_type\" in data.data_outputs[0]) {\n            nodeView.updateDataOutput(data.data_outputs[0]);\n        }\n        old_body.replaceWith(new_body);\n        if (\"workflow_outputs\" in data) {\n            // Won't be present in response for data inputs\n            this.workflow_outputs = data.workflow_outputs ? data.workflow_outputs : [];\n        }\n        // If active, reactivate with new config_form\n        this.markChanged();\n        this.redraw();\n    },\n    error: function error(text) {\n        var b = $(this.element).find(\".toolFormBody\");\n        b.find(\"div\").remove();\n        var tmp = \"<div style='color: red; text-style: italic;'>\" + text + \"</div>\";\n        this.config_form = tmp;\n        b.html(tmp);\n        this.app.workflow.node_changed(this);\n    },\n    markChanged: function markChanged() {\n        this.app.workflow.node_changed(this);\n    }\n});\nexports.default = Node;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! libs/backbone */ 2), __webpack_require__(/*! underscore */ 1), __webpack_require__(/*! jquery */ 0)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjg4LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL2dhbGF4eS9zY3JpcHRzL212Yy93b3JrZmxvdy93b3JrZmxvdy1ub2RlLmpzPzIyZDMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFV0aWxzIGZyb20gXCJ1dGlscy91dGlsc1wiO1xuaW1wb3J0IE5vZGVWaWV3IGZyb20gXCJtdmMvd29ya2Zsb3cvd29ya2Zsb3ctdmlldy1ub2RlXCI7XG52YXIgTm9kZSA9IEJhY2tib25lLk1vZGVsLmV4dGVuZCh7XG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oYXBwLCBhdHRyKSB7XG4gICAgICAgIHRoaXMuYXBwID0gYXBwO1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBhdHRyLmVsZW1lbnQ7XG4gICAgICAgIHRoaXMuaW5wdXRfdGVybWluYWxzID0ge307XG4gICAgICAgIHRoaXMub3V0cHV0X3Rlcm1pbmFscyA9IHt9O1xuICAgICAgICB0aGlzLmVycm9ycyA9IHt9O1xuICAgICAgICB0aGlzLndvcmtmbG93X291dHB1dHMgPSBbXTtcbiAgICB9LFxuICAgIGdldFdvcmtmbG93T3V0cHV0OiBmdW5jdGlvbihvdXRwdXROYW1lKSB7XG4gICAgICAgIHJldHVybiBfLmZpbmRXaGVyZSh0aGlzLndvcmtmbG93X291dHB1dHMsIHtcbiAgICAgICAgICAgIG91dHB1dF9uYW1lOiBvdXRwdXROYW1lXG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgaXNXb3JrZmxvd091dHB1dDogZnVuY3Rpb24ob3V0cHV0TmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRXb3JrZmxvd091dHB1dChvdXRwdXROYW1lKSAhPT0gdW5kZWZpbmVkO1xuICAgIH0sXG4gICAgcmVtb3ZlV29ya2Zsb3dPdXRwdXQ6IGZ1bmN0aW9uKG91dHB1dE5hbWUpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMuaXNXb3JrZmxvd091dHB1dChvdXRwdXROYW1lKSkge1xuICAgICAgICAgICAgdGhpcy53b3JrZmxvd19vdXRwdXRzLnNwbGljZSh0aGlzLmdldFdvcmtmbG93T3V0cHV0KG91dHB1dE5hbWUpLCAxKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgYWRkV29ya2Zsb3dPdXRwdXQ6IGZ1bmN0aW9uKG91dHB1dE5hbWUsIGxhYmVsKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1dvcmtmbG93T3V0cHV0KG91dHB1dE5hbWUpKSB7XG4gICAgICAgICAgICB2YXIgb3V0cHV0ID0geyBvdXRwdXRfbmFtZTogb3V0cHV0TmFtZSB9O1xuICAgICAgICAgICAgaWYgKGxhYmVsKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0LmxhYmVsID0gbGFiZWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLndvcmtmbG93X291dHB1dHMucHVzaChvdXRwdXQpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgbGFiZWxXb3JrZmxvd091dHB1dDogZnVuY3Rpb24ob3V0cHV0TmFtZSwgbGFiZWwpIHtcbiAgICAgICAgdmFyIGNoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgdmFyIG9sZExhYmVsID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuaXNXb3JrZmxvd091dHB1dChvdXRwdXROYW1lKSkge1xuICAgICAgICAgICAgdmFyIHdvcmtmbG93T3V0cHV0ID0gdGhpcy5nZXRXb3JrZmxvd091dHB1dChvdXRwdXROYW1lKTtcbiAgICAgICAgICAgIG9sZExhYmVsID0gd29ya2Zsb3dPdXRwdXQubGFiZWw7XG4gICAgICAgICAgICB3b3JrZmxvd091dHB1dC5sYWJlbCA9IGxhYmVsO1xuICAgICAgICAgICAgY2hhbmdlZCA9IG9sZExhYmVsICE9IGxhYmVsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2hhbmdlZCA9IHRoaXMuYWRkV29ya2Zsb3dPdXRwdXQob3V0cHV0TmFtZSwgbGFiZWwpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICAgICAgICB0aGlzLmFwcC53b3JrZmxvdy51cGRhdGVPdXRwdXRMYWJlbChvbGRMYWJlbCwgbGFiZWwpO1xuICAgICAgICAgICAgdGhpcy5tYXJrQ2hhbmdlZCgpO1xuICAgICAgICAgICAgdGhpcy5ub2RlVmlldy5yZWRyYXdXb3JrZmxvd091dHB1dHMoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2hhbmdlZDtcbiAgICB9LFxuICAgIGNvbm5lY3RlZE91dHB1dFRlcm1pbmFsczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb25uZWN0ZWRUZXJtaW5hbHModGhpcy5vdXRwdXRfdGVybWluYWxzKTtcbiAgICB9LFxuICAgIF9jb25uZWN0ZWRUZXJtaW5hbHM6IGZ1bmN0aW9uKHRlcm1pbmFscykge1xuICAgICAgICB2YXIgY29ubmVjdGVkVGVybWluYWxzID0gW107XG4gICAgICAgICQuZWFjaCh0ZXJtaW5hbHMsIChfLCB0KSA9PiB7XG4gICAgICAgICAgICBpZiAodC5jb25uZWN0b3JzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25uZWN0ZWRUZXJtaW5hbHMucHVzaCh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjb25uZWN0ZWRUZXJtaW5hbHM7XG4gICAgfSxcbiAgICBoYXNDb25uZWN0ZWRPdXRwdXRUZXJtaW5hbHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyByZXR1cm4gdGhpcy5jb25uZWN0ZWRPdXRwdXRUZXJtaW5hbHMoKS5sZW5ndGggPiAwOyA8LSBvcHRpbWl6ZWQgdGhpc1xuICAgICAgICB2YXIgb3V0cHV0VGVybWluYWxzID0gdGhpcy5vdXRwdXRfdGVybWluYWxzO1xuICAgICAgICBmb3IgKHZhciBvdXRwdXROYW1lIGluIG91dHB1dFRlcm1pbmFscykge1xuICAgICAgICAgICAgaWYgKG91dHB1dFRlcm1pbmFsc1tvdXRwdXROYW1lXS5jb25uZWN0b3JzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcbiAgICBjb25uZWN0ZWRNYXBwZWRJbnB1dFRlcm1pbmFsczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb25uZWN0ZWRNYXBwZWRUZXJtaW5hbHModGhpcy5pbnB1dF90ZXJtaW5hbHMpO1xuICAgIH0sXG4gICAgaGFzQ29ubmVjdGVkTWFwcGVkSW5wdXRUZXJtaW5hbHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyByZXR1cm4gdGhpcy5jb25uZWN0ZWRNYXBwZWRJbnB1dFRlcm1pbmFscygpLmxlbmd0aCA+IDA7IDwtIG9wdGltaXplZCB0aGlzXG4gICAgICAgIHZhciBpbnB1dFRlcm1pbmFscyA9IHRoaXMuaW5wdXRfdGVybWluYWxzO1xuICAgICAgICBmb3IgKHZhciBpbnB1dE5hbWUgaW4gaW5wdXRUZXJtaW5hbHMpIHtcbiAgICAgICAgICAgIHZhciBpbnB1dFRlcm1pbmFsID0gaW5wdXRUZXJtaW5hbHNbaW5wdXROYW1lXTtcbiAgICAgICAgICAgIGlmIChpbnB1dFRlcm1pbmFsLmNvbm5lY3RvcnMubGVuZ3RoID4gMCAmJiBpbnB1dFRlcm1pbmFsLmlzTWFwcGVkT3ZlcigpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgX2Nvbm5lY3RlZE1hcHBlZFRlcm1pbmFsczogZnVuY3Rpb24odGVybWluYWxzKSB7XG4gICAgICAgIHZhciBtYXBwZWRfb3V0cHV0cyA9IFtdO1xuICAgICAgICAkLmVhY2godGVybWluYWxzLCAoXywgdCkgPT4ge1xuICAgICAgICAgICAgdmFyIG1hcE92ZXIgPSB0Lm1hcE92ZXIoKTtcbiAgICAgICAgICAgIGlmIChtYXBPdmVyLmlzQ29sbGVjdGlvbikge1xuICAgICAgICAgICAgICAgIGlmICh0LmNvbm5lY3RvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBtYXBwZWRfb3V0cHV0cy5wdXNoKHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBtYXBwZWRfb3V0cHV0cztcbiAgICB9LFxuICAgIG1hcHBlZElucHV0VGVybWluYWxzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcHBlZFRlcm1pbmFscyh0aGlzLmlucHV0X3Rlcm1pbmFscyk7XG4gICAgfSxcbiAgICBfbWFwcGVkVGVybWluYWxzOiBmdW5jdGlvbih0ZXJtaW5hbHMpIHtcbiAgICAgICAgdmFyIG1hcHBlZFRlcm1pbmFscyA9IFtdO1xuICAgICAgICAkLmVhY2godGVybWluYWxzLCAoXywgdCkgPT4ge1xuICAgICAgICAgICAgdmFyIG1hcE92ZXIgPSB0Lm1hcE92ZXIoKTtcbiAgICAgICAgICAgIGlmIChtYXBPdmVyLmlzQ29sbGVjdGlvbikge1xuICAgICAgICAgICAgICAgIG1hcHBlZFRlcm1pbmFscy5wdXNoKHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG1hcHBlZFRlcm1pbmFscztcbiAgICB9LFxuICAgIGhhc01hcHBlZE92ZXJJbnB1dFRlcm1pbmFsczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBmb3VuZCA9IGZhbHNlO1xuICAgICAgICBfLmVhY2godGhpcy5pbnB1dF90ZXJtaW5hbHMsIHQgPT4ge1xuICAgICAgICAgICAgdmFyIG1hcE92ZXIgPSB0Lm1hcE92ZXIoKTtcbiAgICAgICAgICAgIGlmIChtYXBPdmVyLmlzQ29sbGVjdGlvbikge1xuICAgICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmb3VuZDtcbiAgICB9LFxuICAgIHJlZHJhdzogZnVuY3Rpb24oKSB7XG4gICAgICAgICQuZWFjaCh0aGlzLmlucHV0X3Rlcm1pbmFscywgKF8sIHQpID0+IHtcbiAgICAgICAgICAgIHQucmVkcmF3KCk7XG4gICAgICAgIH0pO1xuICAgICAgICAkLmVhY2godGhpcy5vdXRwdXRfdGVybWluYWxzLCAoXywgdCkgPT4ge1xuICAgICAgICAgICAgdC5yZWRyYXcoKTtcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBjbG9uZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjb3BpZWREYXRhID0ge1xuICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICAgICAgbGFiZWw6IHRoaXMubGFiZWwsXG4gICAgICAgICAgICBhbm5vdGF0aW9uOiB0aGlzLmFubm90YXRpb24sXG4gICAgICAgICAgICBwb3N0X2pvYl9hY3Rpb25zOiB0aGlzLnBvc3Rfam9iX2FjdGlvbnNcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmFwcC53b3JrZmxvdy5jcmVhdGVfbm9kZSh0aGlzLnR5cGUsIHRoaXMubmFtZSwgdGhpcy5jb250ZW50X2lkKTtcblxuICAgICAgICBVdGlscy5yZXF1ZXN0KHtcbiAgICAgICAgICAgIHR5cGU6IFwiUE9TVFwiLFxuICAgICAgICAgICAgdXJsOiBgJHtHYWxheHkucm9vdH1hcGkvd29ya2Zsb3dzL2J1aWxkX21vZHVsZWAsXG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgICAgICAgICAgIHRvb2xfaWQ6IHRoaXMuY29udGVudF9pZCxcbiAgICAgICAgICAgICAgICBpbnB1dHM6IHRoaXMudG9vbF9zdGF0ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN1Y2Nlc3M6IGRhdGEgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBuZXdEYXRhID0gT2JqZWN0LmFzc2lnbih7fSwgZGF0YSwgY29waWVkRGF0YSk7XG4gICAgICAgICAgICAgICAgbm9kZS5pbml0X2ZpZWxkX2RhdGEobmV3RGF0YSk7XG4gICAgICAgICAgICAgICAgbm9kZS51cGRhdGVfZmllbGRfZGF0YShuZXdEYXRhKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFwcC53b3JrZmxvdy5hY3RpdmF0ZV9ub2RlKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9LFxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuICAgICAgICAkLmVhY2godGhpcy5pbnB1dF90ZXJtaW5hbHMsIChrLCB0KSA9PiB7XG4gICAgICAgICAgICB0LmRlc3Ryb3koKTtcbiAgICAgICAgfSk7XG4gICAgICAgICQuZWFjaCh0aGlzLm91dHB1dF90ZXJtaW5hbHMsIChrLCB0KSA9PiB7XG4gICAgICAgICAgICB0LmRlc3Ryb3koKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYXBwLndvcmtmbG93LnJlbW92ZV9ub2RlKHRoaXMpO1xuICAgICAgICAkKHRoaXMuZWxlbWVudCkucmVtb3ZlKCk7XG4gICAgfSxcbiAgICBtYWtlX2FjdGl2ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICQodGhpcy5lbGVtZW50KS5hZGRDbGFzcyhcInRvb2xGb3JtLWFjdGl2ZVwiKTtcbiAgICB9LFxuICAgIG1ha2VfaW5hY3RpdmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBLZWVwIGluYWN0aXZlIG5vZGVzIHN0YWNrZWQgZnJvbSBtb3N0IHRvIGxlYXN0IHJlY2VudGx5IGFjdGl2ZVxuICAgICAgICAvLyBieSBtb3ZpbmcgZWxlbWVudCB0byB0aGUgZW5kIG9mIHBhcmVudCdzIG5vZGUgbGlzdFxuICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMuZWxlbWVudC5nZXQoMCk7XG4gICAgICAgIChwID0+IHtcbiAgICAgICAgICAgIHAucmVtb3ZlQ2hpbGQoZWxlbWVudCk7XG4gICAgICAgICAgICBwLmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuICAgICAgICB9KShlbGVtZW50LnBhcmVudE5vZGUpO1xuICAgICAgICAvLyBSZW1vdmUgYWN0aXZlIGNsYXNzXG4gICAgICAgICQoZWxlbWVudCkucmVtb3ZlQ2xhc3MoXCJ0b29sRm9ybS1hY3RpdmVcIik7XG4gICAgfSxcbiAgICBpbml0X2ZpZWxkX2RhdGE6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgaWYgKGRhdGEudHlwZSkge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gZGF0YS50eXBlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubmFtZSA9IGRhdGEubmFtZTtcbiAgICAgICAgdGhpcy5jb25maWdfZm9ybSA9IGRhdGEuY29uZmlnX2Zvcm07XG4gICAgICAgIHRoaXMudG9vbF92ZXJzaW9uID0gdGhpcy5jb25maWdfZm9ybSAmJiB0aGlzLmNvbmZpZ19mb3JtLnZlcnNpb247XG4gICAgICAgIHRoaXMudG9vbF9zdGF0ZSA9IGRhdGEudG9vbF9zdGF0ZTtcbiAgICAgICAgdGhpcy5lcnJvcnMgPSBkYXRhLmVycm9ycztcbiAgICAgICAgdGhpcy50b29sdGlwID0gZGF0YS50b29sdGlwID8gZGF0YS50b29sdGlwIDogXCJcIjtcbiAgICAgICAgdGhpcy5hbm5vdGF0aW9uID0gZGF0YS5hbm5vdGF0aW9uO1xuICAgICAgICB0aGlzLnBvc3Rfam9iX2FjdGlvbnMgPSBkYXRhLnBvc3Rfam9iX2FjdGlvbnMgPyBkYXRhLnBvc3Rfam9iX2FjdGlvbnMgOiB7fTtcbiAgICAgICAgdGhpcy5sYWJlbCA9IGRhdGEubGFiZWw7XG4gICAgICAgIHRoaXMudXVpZCA9IGRhdGEudXVpZDtcbiAgICAgICAgdGhpcy53b3JrZmxvd19vdXRwdXRzID0gZGF0YS53b3JrZmxvd19vdXRwdXRzID8gZGF0YS53b3JrZmxvd19vdXRwdXRzIDogW107XG4gICAgICAgIHZhciBub2RlID0gdGhpcztcbiAgICAgICAgdmFyIG5vZGVWaWV3ID0gbmV3IE5vZGVWaWV3KHtcbiAgICAgICAgICAgIGVsOiB0aGlzLmVsZW1lbnRbMF0sXG4gICAgICAgICAgICBub2RlOiBub2RlXG4gICAgICAgIH0pO1xuICAgICAgICBub2RlLm5vZGVWaWV3ID0gbm9kZVZpZXc7XG4gICAgICAgICQuZWFjaChkYXRhLmRhdGFfaW5wdXRzLCAoaSwgaW5wdXQpID0+IHtcbiAgICAgICAgICAgIG5vZGVWaWV3LmFkZERhdGFJbnB1dChpbnB1dCk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoZGF0YS5kYXRhX2lucHV0cy5sZW5ndGggPiAwICYmIGRhdGEuZGF0YV9vdXRwdXRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIG5vZGVWaWV3LmFkZFJ1bGUoKTtcbiAgICAgICAgfVxuICAgICAgICAkLmVhY2goZGF0YS5kYXRhX291dHB1dHMsIChpLCBvdXRwdXQpID0+IHtcbiAgICAgICAgICAgIG5vZGVWaWV3LmFkZERhdGFPdXRwdXQob3V0cHV0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIG5vZGVWaWV3LnJlbmRlcigpO1xuICAgICAgICB0aGlzLmFwcC53b3JrZmxvdy5ub2RlX2NoYW5nZWQodGhpcywgdHJ1ZSk7XG4gICAgfSxcbiAgICB1cGRhdGVfZmllbGRfZGF0YTogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICB2YXIgbm9kZSA9IHRoaXM7XG4gICAgICAgIHZhciBub2RlVmlldyA9IG5vZGUubm9kZVZpZXc7XG4gICAgICAgIC8vIHJlbW92ZSB1bnVzZWQgb3V0cHV0IHZpZXdzIGFuZCByZW1vdmUgcHJlLWV4aXN0aW5nIG91dHB1dCB2aWV3cyBmcm9tIGRhdGEuZGF0YV9vdXRwdXRzLFxuICAgICAgICAvLyBzbyB0aGF0IHRoZXNlIGFyZSBub3QgYWRkZWQgdHdpY2UuXG4gICAgICAgIHZhciB1bnVzZWRfb3V0cHV0cyA9IFtdO1xuICAgICAgICAvLyBub2RlVmlldy5vdXRwdXRWaWV3cyBjb250YWlucyBwcmUtZXhpc3Rpbmcgb3V0cHV0cyxcbiAgICAgICAgLy8gd2hpbGUgZGF0YS5kYXRhX291dHB1dCBjb250YWlucyB3aGF0IHNob3VsZCBiZSBkaXNwbGF5ZWQuXG4gICAgICAgIC8vIE5vdyB3ZSBnYXRoZXIgdGhlIHVudXNlZCBvdXRwdXRzXG4gICAgICAgICQuZWFjaChub2RlVmlldy5vdXRwdXRWaWV3cywgKGksIG91dHB1dF92aWV3KSA9PiB7XG4gICAgICAgICAgICB2YXIgY3VyX25hbWUgPSBvdXRwdXRfdmlldy5vdXRwdXQubmFtZTtcbiAgICAgICAgICAgIHZhciBkYXRhX25hbWVzID0gZGF0YS5kYXRhX291dHB1dHM7XG4gICAgICAgICAgICB2YXIgY3VyX25hbWVfaW5fZGF0YV9vdXRwdXRzID0gZmFsc2U7XG4gICAgICAgICAgICBfLmVhY2goZGF0YV9uYW1lcywgZGF0YV9uYW1lID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZGF0YV9uYW1lLm5hbWUgPT0gY3VyX25hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VyX25hbWVfaW5fZGF0YV9vdXRwdXRzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChjdXJfbmFtZV9pbl9kYXRhX291dHB1dHMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgdW51c2VkX291dHB1dHMucHVzaChjdXJfbmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFJlbW92ZSB0aGUgdW51c2VkIG91dHB1dHNcbiAgICAgICAgXy5lYWNoKHVudXNlZF9vdXRwdXRzLCB1bnVzZWRfb3V0cHV0ID0+IHtcbiAgICAgICAgICAgIF8uZWFjaChub2RlVmlldy5vdXRwdXRWaWV3c1t1bnVzZWRfb3V0cHV0XS50ZXJtaW5hbEVsZW1lbnQudGVybWluYWwuY29ubmVjdG9ycywgeCA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHgpIHtcbiAgICAgICAgICAgICAgICAgICAgeC5kZXN0cm95KCk7IC8vIFJlbW92ZXMgdGhlIG5vb2RsZSBjb25uZWN0b3JzXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBub2RlVmlldy5vdXRwdXRWaWV3c1t1bnVzZWRfb3V0cHV0XS5yZW1vdmUoKTsgLy8gcmVtb3ZlcyB0aGUgcmVuZGVyZWQgb3V0cHV0XG4gICAgICAgICAgICBkZWxldGUgbm9kZVZpZXcub3V0cHV0Vmlld3NbdW51c2VkX291dHB1dF07IC8vIHJlbW92ZXMgdGhlIHJlZmVyZW5jZSB0byB0aGUgb3V0cHV0XG4gICAgICAgICAgICBkZWxldGUgbm9kZS5vdXRwdXRfdGVybWluYWxzW3VudXNlZF9vdXRwdXRdOyAvLyByZW1vdmVzIHRoZSBvdXRwdXQgdGVybWluYWxcbiAgICAgICAgfSk7XG4gICAgICAgICQuZWFjaChub2RlLndvcmtmbG93X291dHB1dHMsIChpLCB3Zl9vdXRwdXQpID0+IHtcbiAgICAgICAgICAgIGlmICh3Zl9vdXRwdXQgJiYgIW5vZGUub3V0cHV0X3Rlcm1pbmFsc1t3Zl9vdXRwdXQub3V0cHV0X25hbWVdKSB7XG4gICAgICAgICAgICAgICAgbm9kZS53b3JrZmxvd19vdXRwdXRzLnNwbGljZShpLCAxKTsgLy8gcmVtb3ZlcyBvdXRwdXQgZnJvbSBsaXN0IG9mIHdvcmtmbG93IG91dHB1dHNcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgICQuZWFjaChkYXRhLmRhdGFfb3V0cHV0cywgKGksIG91dHB1dCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFub2RlVmlldy5vdXRwdXRWaWV3c1tvdXRwdXQubmFtZV0pIHtcbiAgICAgICAgICAgICAgICBub2RlVmlldy5hZGREYXRhT3V0cHV0KG91dHB1dCk7IC8vIGFkZCBkYXRhIG91dHB1dCBpZiBpdCBkb2VzIG5vdCB5ZXQgZXhpc3RcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gdGhlIG91dHB1dCBhbHJlYWR5IGV4aXN0cywgYnV0IHRoZSBvdXRwdXQgZm9ybWF0cyBtYXkgaGF2ZSBjaGFuZ2VkLlxuICAgICAgICAgICAgICAgIC8vIFRoZXJlZm9yZSB3ZSB1cGRhdGUgdGhlIGRhdGF0eXBlcyBhbmQgZGVzdHJveSBpbnZhbGlkIGNvbm5lY3Rpb25zLlxuICAgICAgICAgICAgICAgIG5vZGUub3V0cHV0X3Rlcm1pbmFsc1tvdXRwdXQubmFtZV0uZGF0YXR5cGVzID0gb3V0cHV0LmV4dGVuc2lvbnM7XG4gICAgICAgICAgICAgICAgbm9kZS5vdXRwdXRfdGVybWluYWxzW291dHB1dC5uYW1lXS5kZXN0cm95SW52YWxpZENvbm5lY3Rpb25zKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnRvb2xfc3RhdGUgPSBkYXRhLnRvb2xfc3RhdGU7XG4gICAgICAgIHRoaXMuY29uZmlnX2Zvcm0gPSBkYXRhLmNvbmZpZ19mb3JtO1xuICAgICAgICB0aGlzLnRvb2xfdmVyc2lvbiA9IHRoaXMuY29uZmlnX2Zvcm0gJiYgdGhpcy5jb25maWdfZm9ybS52ZXJzaW9uO1xuICAgICAgICB0aGlzLmVycm9ycyA9IGRhdGEuZXJyb3JzO1xuICAgICAgICB0aGlzLmFubm90YXRpb24gPSBkYXRhLmFubm90YXRpb247XG4gICAgICAgIHRoaXMubGFiZWwgPSBkYXRhLmxhYmVsO1xuICAgICAgICBpZiAoXCJwb3N0X2pvYl9hY3Rpb25zXCIgaW4gZGF0YSkge1xuICAgICAgICAgICAgLy8gV29uJ3QgYmUgcHJlc2VudCBpbiByZXNwb25zZSBmb3IgZGF0YSBpbnB1dHNcbiAgICAgICAgICAgIHZhciBwamFfaW4gPSBkYXRhLnBvc3Rfam9iX2FjdGlvbnM7XG4gICAgICAgICAgICB0aGlzLnBvc3Rfam9iX2FjdGlvbnMgPSBwamFfaW4gPyBwamFfaW4gOiB7fTtcbiAgICAgICAgfVxuICAgICAgICBub2RlLm5vZGVWaWV3LnJlbmRlclRvb2xFcnJvcnMoKTtcbiAgICAgICAgLy8gVXBkYXRlIGlucHV0IHJvd3NcbiAgICAgICAgdmFyIG9sZF9ib2R5ID0gbm9kZVZpZXcuJChcImRpdi5pbnB1dHNcIik7XG4gICAgICAgIHZhciBuZXdfYm9keSA9IG5vZGVWaWV3Lm5ld0lucHV0c0RpdigpO1xuICAgICAgICB2YXIgbmV3VGVybWluYWxWaWV3cyA9IHt9O1xuICAgICAgICBfLmVhY2goZGF0YS5kYXRhX2lucHV0cywgaW5wdXQgPT4ge1xuICAgICAgICAgICAgdmFyIHRlcm1pbmFsVmlldyA9IG5vZGUubm9kZVZpZXcuYWRkRGF0YUlucHV0KGlucHV0LCBuZXdfYm9keSk7XG4gICAgICAgICAgICBuZXdUZXJtaW5hbFZpZXdzW2lucHV0Lm5hbWVdID0gdGVybWluYWxWaWV3O1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gQ2xlYW51cCBhbnkgbGVmdG92ZXIgdGVybWluYWxzXG4gICAgICAgIF8uZWFjaChfLmRpZmZlcmVuY2UoXy52YWx1ZXMobm9kZVZpZXcudGVybWluYWxWaWV3cyksIF8udmFsdWVzKG5ld1Rlcm1pbmFsVmlld3MpKSwgdW51c2VkVmlldyA9PiB7XG4gICAgICAgICAgICB1bnVzZWRWaWV3LmVsLnRlcm1pbmFsLmRlc3Ryb3koKTtcbiAgICAgICAgfSk7XG4gICAgICAgIG5vZGVWaWV3LnRlcm1pbmFsVmlld3MgPSBuZXdUZXJtaW5hbFZpZXdzO1xuICAgICAgICBub2RlLm5vZGVWaWV3LnJlbmRlcigpO1xuICAgICAgICAvLyBJbiBnZW5lcmFsIHdvcmtmbG93IGVkaXRvciBhc3N1bWVzIHRvb2wgb3V0cHV0cyBkb24ndCBjaGFuZ2UgaW4gIyBvclxuICAgICAgICAvLyB0eXBlIChub3QgcmVhbGx5IHZhbGlkIHJpZ2h0PykgYnV0IGFkZGluZyBzcGVjaWFsIGxvZ2ljIGhlcmUgZm9yXG4gICAgICAgIC8vIGRhdGEgY29sbGVjdGlvbiBpbnB1dCBwYXJhbWV0ZXJzIHRoYXQgY2FuIGhhdmUgdGhlaXIgY29sbGVjdGlvblxuICAgICAgICAvLyBjaGFuZ2UuXG4gICAgICAgIGlmIChkYXRhLmRhdGFfb3V0cHV0cy5sZW5ndGggPT0gMSAmJiBcImNvbGxlY3Rpb25fdHlwZVwiIGluIGRhdGEuZGF0YV9vdXRwdXRzWzBdKSB7XG4gICAgICAgICAgICBub2RlVmlldy51cGRhdGVEYXRhT3V0cHV0KGRhdGEuZGF0YV9vdXRwdXRzWzBdKTtcbiAgICAgICAgfVxuICAgICAgICBvbGRfYm9keS5yZXBsYWNlV2l0aChuZXdfYm9keSk7XG4gICAgICAgIGlmIChcIndvcmtmbG93X291dHB1dHNcIiBpbiBkYXRhKSB7XG4gICAgICAgICAgICAvLyBXb24ndCBiZSBwcmVzZW50IGluIHJlc3BvbnNlIGZvciBkYXRhIGlucHV0c1xuICAgICAgICAgICAgdGhpcy53b3JrZmxvd19vdXRwdXRzID0gZGF0YS53b3JrZmxvd19vdXRwdXRzID8gZGF0YS53b3JrZmxvd19vdXRwdXRzIDogW107XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgYWN0aXZlLCByZWFjdGl2YXRlIHdpdGggbmV3IGNvbmZpZ19mb3JtXG4gICAgICAgIHRoaXMubWFya0NoYW5nZWQoKTtcbiAgICAgICAgdGhpcy5yZWRyYXcoKTtcbiAgICB9LFxuICAgIGVycm9yOiBmdW5jdGlvbih0ZXh0KSB7XG4gICAgICAgIHZhciBiID0gJCh0aGlzLmVsZW1lbnQpLmZpbmQoXCIudG9vbEZvcm1Cb2R5XCIpO1xuICAgICAgICBiLmZpbmQoXCJkaXZcIikucmVtb3ZlKCk7XG4gICAgICAgIHZhciB0bXAgPSBgPGRpdiBzdHlsZT0nY29sb3I6IHJlZDsgdGV4dC1zdHlsZTogaXRhbGljOyc+JHt0ZXh0fTwvZGl2PmA7XG4gICAgICAgIHRoaXMuY29uZmlnX2Zvcm0gPSB0bXA7XG4gICAgICAgIGIuaHRtbCh0bXApO1xuICAgICAgICB0aGlzLmFwcC53b3JrZmxvdy5ub2RlX2NoYW5nZWQodGhpcyk7XG4gICAgfSxcbiAgICBtYXJrQ2hhbmdlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuYXBwLndvcmtmbG93Lm5vZGVfY2hhbmdlZCh0aGlzKTtcbiAgICB9XG59KTtcbmV4cG9ydCBkZWZhdWx0IE5vZGU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gZ2FsYXh5L3NjcmlwdHMvbXZjL3dvcmtmbG93L3dvcmtmbG93LW5vZGUuanMiXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7OztBQUFBO0FBQ0E7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWJBO0FBZUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUF6VEE7QUEyVEE7QSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///288\n");

/***/ }),

/***/ 289:
/*!***********************************************************!*\
  !*** ./galaxy/scripts/mvc/workflow/workflow-view-node.js ***!
  \***********************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(Backbone, $) {\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _underscore = __webpack_require__(/*! libs/underscore */ 1);\n\nvar _ = _interopRequireWildcard(_underscore);\n\nvar _workflowViewTerminals = __webpack_require__(/*! mvc/workflow/workflow-view-terminals */ 290);\n\nvar _workflowViewTerminals2 = _interopRequireDefault(_workflowViewTerminals);\n\nvar _workflowViewData = __webpack_require__(/*! mvc/workflow/workflow-view-data */ 292);\n\nvar _workflowViewData2 = _interopRequireDefault(_workflowViewData);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nexports.default = Backbone.View.extend({\n    initialize: function initialize(options) {\n        this.node = options.node;\n        this.output_width = Math.max(150, this.$el.width());\n        this.tool_body = this.$el.find(\".toolFormBody\");\n        this.tool_body.find(\"div\").remove();\n        this.newInputsDiv().appendTo(this.tool_body);\n        this.terminalViews = {};\n        this.outputViews = {};\n    },\n\n    render: function render() {\n        this.renderToolLabel();\n        this.renderToolErrors();\n        this.$el.css(\"width\", Math.min(250, Math.max(this.$el.width(), this.output_width)));\n    },\n\n    renderToolLabel: function renderToolLabel() {\n        this.$(\".nodeTitle\").text(this.node.label || this.node.name);\n    },\n\n    renderToolErrors: function renderToolErrors() {\n        this.node.errors ? this.$el.addClass(\"tool-node-error\") : this.$el.removeClass(\"tool-node-error\");\n    },\n\n    newInputsDiv: function newInputsDiv() {\n        return $(\"<div/>\").addClass(\"inputs\");\n    },\n\n    updateMaxWidth: function updateMaxWidth(newWidth) {\n        this.output_width = Math.max(this.output_width, newWidth);\n    },\n\n    addRule: function addRule() {\n        this.tool_body.append($(\"<div/>\").addClass(\"rule\"));\n    },\n\n    addDataInput: function addDataInput(input, body) {\n        var skipResize = true;\n        if (!body) {\n            body = this.$(\".inputs\");\n            // initial addition to node - resize input to help calculate node\n            // width.\n            skipResize = false;\n        }\n        var terminalView = this.terminalViews[input.name];\n        var terminalViewClass = input.input_type == \"dataset_collection\" ? _workflowViewTerminals2.default.InputCollectionTerminalView : _workflowViewTerminals2.default.InputTerminalView;\n        if (terminalView && !(terminalView instanceof terminalViewClass)) {\n            terminalView.el.terminal.destroy();\n            terminalView = null;\n        }\n        if (!terminalView) {\n            terminalView = new terminalViewClass({\n                node: this.node,\n                input: input\n            });\n        } else {\n            var terminal = terminalView.el.terminal;\n            terminal.update(input);\n            terminal.destroyInvalidConnections();\n        }\n        this.terminalViews[input.name] = terminalView;\n        var terminalElement = terminalView.el;\n        var inputView = new _workflowViewData2.default.DataInputView({\n            terminalElement: terminalElement,\n            input: input,\n            nodeView: this,\n            skipResize: skipResize\n        });\n        var ib = inputView.$el;\n        body.append(ib.prepend(terminalView.terminalElements()));\n        return terminalView;\n    },\n\n    addDataOutput: function addDataOutput(output) {\n        var terminalViewClass = output.collection ? _workflowViewTerminals2.default.OutputCollectionTerminalView : _workflowViewTerminals2.default.OutputTerminalView;\n        var terminalView = new terminalViewClass({\n            node: this.node,\n            output: output\n        });\n        var outputView = new _workflowViewData2.default.DataOutputView({\n            output: output,\n            terminalElement: terminalView.el,\n            nodeView: this\n        });\n        this.outputViews[output.name] = outputView;\n        this.tool_body.append(outputView.$el.append(terminalView.terminalElements()));\n    },\n\n    redrawWorkflowOutputs: function redrawWorkflowOutputs() {\n        _.each(this.outputViews, function (outputView) {\n            outputView.redrawWorkflowOutput();\n        });\n    },\n\n    updateDataOutput: function updateDataOutput(output) {\n        var outputTerminal = this.node.output_terminals[output.name];\n        outputTerminal.update(output);\n    }\n});\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! libs/backbone */ 2), __webpack_require__(/*! jquery */ 0)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjg5LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL2dhbGF4eS9zY3JpcHRzL212Yy93b3JrZmxvdy93b3JrZmxvdy12aWV3LW5vZGUuanM/MmYwNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBfIGZyb20gXCJsaWJzL3VuZGVyc2NvcmVcIjtcbmltcG9ydCBUZXJtaW5hbFZpZXdzIGZyb20gXCJtdmMvd29ya2Zsb3cvd29ya2Zsb3ctdmlldy10ZXJtaW5hbHNcIjtcbmltcG9ydCBEYXRhVmlld3MgZnJvbSBcIm12Yy93b3JrZmxvdy93b3JrZmxvdy12aWV3LWRhdGFcIjtcbmV4cG9ydCBkZWZhdWx0IEJhY2tib25lLlZpZXcuZXh0ZW5kKHtcbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHRoaXMubm9kZSA9IG9wdGlvbnMubm9kZTtcbiAgICAgICAgdGhpcy5vdXRwdXRfd2lkdGggPSBNYXRoLm1heCgxNTAsIHRoaXMuJGVsLndpZHRoKCkpO1xuICAgICAgICB0aGlzLnRvb2xfYm9keSA9IHRoaXMuJGVsLmZpbmQoXCIudG9vbEZvcm1Cb2R5XCIpO1xuICAgICAgICB0aGlzLnRvb2xfYm9keS5maW5kKFwiZGl2XCIpLnJlbW92ZSgpO1xuICAgICAgICB0aGlzLm5ld0lucHV0c0RpdigpLmFwcGVuZFRvKHRoaXMudG9vbF9ib2R5KTtcbiAgICAgICAgdGhpcy50ZXJtaW5hbFZpZXdzID0ge307XG4gICAgICAgIHRoaXMub3V0cHV0Vmlld3MgPSB7fTtcbiAgICB9LFxuXG4gICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJUb29sTGFiZWwoKTtcbiAgICAgICAgdGhpcy5yZW5kZXJUb29sRXJyb3JzKCk7XG4gICAgICAgIHRoaXMuJGVsLmNzcyhcIndpZHRoXCIsIE1hdGgubWluKDI1MCwgTWF0aC5tYXgodGhpcy4kZWwud2lkdGgoKSwgdGhpcy5vdXRwdXRfd2lkdGgpKSk7XG4gICAgfSxcblxuICAgIHJlbmRlclRvb2xMYWJlbDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuJChcIi5ub2RlVGl0bGVcIikudGV4dCh0aGlzLm5vZGUubGFiZWwgfHwgdGhpcy5ub2RlLm5hbWUpO1xuICAgIH0sXG5cbiAgICByZW5kZXJUb29sRXJyb3JzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5ub2RlLmVycm9ycyA/IHRoaXMuJGVsLmFkZENsYXNzKFwidG9vbC1ub2RlLWVycm9yXCIpIDogdGhpcy4kZWwucmVtb3ZlQ2xhc3MoXCJ0b29sLW5vZGUtZXJyb3JcIik7XG4gICAgfSxcblxuICAgIG5ld0lucHV0c0RpdjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAkKFwiPGRpdi8+XCIpLmFkZENsYXNzKFwiaW5wdXRzXCIpO1xuICAgIH0sXG5cbiAgICB1cGRhdGVNYXhXaWR0aDogZnVuY3Rpb24obmV3V2lkdGgpIHtcbiAgICAgICAgdGhpcy5vdXRwdXRfd2lkdGggPSBNYXRoLm1heCh0aGlzLm91dHB1dF93aWR0aCwgbmV3V2lkdGgpO1xuICAgIH0sXG5cbiAgICBhZGRSdWxlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy50b29sX2JvZHkuYXBwZW5kKCQoXCI8ZGl2Lz5cIikuYWRkQ2xhc3MoXCJydWxlXCIpKTtcbiAgICB9LFxuXG4gICAgYWRkRGF0YUlucHV0OiBmdW5jdGlvbihpbnB1dCwgYm9keSkge1xuICAgICAgICB2YXIgc2tpcFJlc2l6ZSA9IHRydWU7XG4gICAgICAgIGlmICghYm9keSkge1xuICAgICAgICAgICAgYm9keSA9IHRoaXMuJChcIi5pbnB1dHNcIik7XG4gICAgICAgICAgICAvLyBpbml0aWFsIGFkZGl0aW9uIHRvIG5vZGUgLSByZXNpemUgaW5wdXQgdG8gaGVscCBjYWxjdWxhdGUgbm9kZVxuICAgICAgICAgICAgLy8gd2lkdGguXG4gICAgICAgICAgICBza2lwUmVzaXplID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRlcm1pbmFsVmlldyA9IHRoaXMudGVybWluYWxWaWV3c1tpbnB1dC5uYW1lXTtcbiAgICAgICAgdmFyIHRlcm1pbmFsVmlld0NsYXNzID1cbiAgICAgICAgICAgIGlucHV0LmlucHV0X3R5cGUgPT0gXCJkYXRhc2V0X2NvbGxlY3Rpb25cIlxuICAgICAgICAgICAgICAgID8gVGVybWluYWxWaWV3cy5JbnB1dENvbGxlY3Rpb25UZXJtaW5hbFZpZXdcbiAgICAgICAgICAgICAgICA6IFRlcm1pbmFsVmlld3MuSW5wdXRUZXJtaW5hbFZpZXc7XG4gICAgICAgIGlmICh0ZXJtaW5hbFZpZXcgJiYgISh0ZXJtaW5hbFZpZXcgaW5zdGFuY2VvZiB0ZXJtaW5hbFZpZXdDbGFzcykpIHtcbiAgICAgICAgICAgIHRlcm1pbmFsVmlldy5lbC50ZXJtaW5hbC5kZXN0cm95KCk7XG4gICAgICAgICAgICB0ZXJtaW5hbFZpZXcgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGVybWluYWxWaWV3KSB7XG4gICAgICAgICAgICB0ZXJtaW5hbFZpZXcgPSBuZXcgdGVybWluYWxWaWV3Q2xhc3Moe1xuICAgICAgICAgICAgICAgIG5vZGU6IHRoaXMubm9kZSxcbiAgICAgICAgICAgICAgICBpbnB1dDogaW5wdXRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHRlcm1pbmFsID0gdGVybWluYWxWaWV3LmVsLnRlcm1pbmFsO1xuICAgICAgICAgICAgdGVybWluYWwudXBkYXRlKGlucHV0KTtcbiAgICAgICAgICAgIHRlcm1pbmFsLmRlc3Ryb3lJbnZhbGlkQ29ubmVjdGlvbnMoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRlcm1pbmFsVmlld3NbaW5wdXQubmFtZV0gPSB0ZXJtaW5hbFZpZXc7XG4gICAgICAgIHZhciB0ZXJtaW5hbEVsZW1lbnQgPSB0ZXJtaW5hbFZpZXcuZWw7XG4gICAgICAgIHZhciBpbnB1dFZpZXcgPSBuZXcgRGF0YVZpZXdzLkRhdGFJbnB1dFZpZXcoe1xuICAgICAgICAgICAgdGVybWluYWxFbGVtZW50OiB0ZXJtaW5hbEVsZW1lbnQsXG4gICAgICAgICAgICBpbnB1dDogaW5wdXQsXG4gICAgICAgICAgICBub2RlVmlldzogdGhpcyxcbiAgICAgICAgICAgIHNraXBSZXNpemU6IHNraXBSZXNpemVcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBpYiA9IGlucHV0Vmlldy4kZWw7XG4gICAgICAgIGJvZHkuYXBwZW5kKGliLnByZXBlbmQodGVybWluYWxWaWV3LnRlcm1pbmFsRWxlbWVudHMoKSkpO1xuICAgICAgICByZXR1cm4gdGVybWluYWxWaWV3O1xuICAgIH0sXG5cbiAgICBhZGREYXRhT3V0cHV0OiBmdW5jdGlvbihvdXRwdXQpIHtcbiAgICAgICAgdmFyIHRlcm1pbmFsVmlld0NsYXNzID0gb3V0cHV0LmNvbGxlY3Rpb25cbiAgICAgICAgICAgID8gVGVybWluYWxWaWV3cy5PdXRwdXRDb2xsZWN0aW9uVGVybWluYWxWaWV3XG4gICAgICAgICAgICA6IFRlcm1pbmFsVmlld3MuT3V0cHV0VGVybWluYWxWaWV3O1xuICAgICAgICB2YXIgdGVybWluYWxWaWV3ID0gbmV3IHRlcm1pbmFsVmlld0NsYXNzKHtcbiAgICAgICAgICAgIG5vZGU6IHRoaXMubm9kZSxcbiAgICAgICAgICAgIG91dHB1dDogb3V0cHV0XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgb3V0cHV0VmlldyA9IG5ldyBEYXRhVmlld3MuRGF0YU91dHB1dFZpZXcoe1xuICAgICAgICAgICAgb3V0cHV0OiBvdXRwdXQsXG4gICAgICAgICAgICB0ZXJtaW5hbEVsZW1lbnQ6IHRlcm1pbmFsVmlldy5lbCxcbiAgICAgICAgICAgIG5vZGVWaWV3OiB0aGlzXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm91dHB1dFZpZXdzW291dHB1dC5uYW1lXSA9IG91dHB1dFZpZXc7XG4gICAgICAgIHRoaXMudG9vbF9ib2R5LmFwcGVuZChvdXRwdXRWaWV3LiRlbC5hcHBlbmQodGVybWluYWxWaWV3LnRlcm1pbmFsRWxlbWVudHMoKSkpO1xuICAgIH0sXG5cbiAgICByZWRyYXdXb3JrZmxvd091dHB1dHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICBfLmVhY2godGhpcy5vdXRwdXRWaWV3cywgb3V0cHV0VmlldyA9PiB7XG4gICAgICAgICAgICBvdXRwdXRWaWV3LnJlZHJhd1dvcmtmbG93T3V0cHV0KCk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICB1cGRhdGVEYXRhT3V0cHV0OiBmdW5jdGlvbihvdXRwdXQpIHtcbiAgICAgICAgdmFyIG91dHB1dFRlcm1pbmFsID0gdGhpcy5ub2RlLm91dHB1dF90ZXJtaW5hbHNbb3V0cHV0Lm5hbWVdO1xuICAgICAgICBvdXRwdXRUZXJtaW5hbC51cGRhdGUob3V0cHV0KTtcbiAgICB9XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBnYWxheHkvc2NyaXB0cy9tdmMvd29ya2Zsb3cvd29ya2Zsb3ctdmlldy1ub2RlLmpzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQ0E7OztBQUFBO0FBQ0E7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUF2R0E7QSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///289\n");

/***/ }),

/***/ 290:
/*!****************************************************************!*\
  !*** ./galaxy/scripts/mvc/workflow/workflow-view-terminals.js ***!
  \****************************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(Backbone, _, $) {\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _workflowTerminals = __webpack_require__(/*! mvc/workflow/workflow-terminals */ 291);\n\nvar _workflowTerminals2 = _interopRequireDefault(_workflowTerminals);\n\nvar _workflowConnector = __webpack_require__(/*! mvc/workflow/workflow-connector */ 126);\n\nvar _workflowConnector2 = _interopRequireDefault(_workflowConnector);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// TODO; tie into Galaxy state?\nwindow.workflow_globals = window.workflow_globals || {};\n\nvar TerminalMappingView = Backbone.View.extend({\n    tagName: \"div\",\n    className: \"fa-icon-button fa fa-folder-o\",\n    initialize: function initialize(options) {\n        var mapText = \"Run tool in parallel over collection\";\n        this.$el.tooltip({ delay: 500, title: mapText });\n        this.model.bind(\"change\", _.bind(this.render, this));\n    },\n    render: function render() {\n        if (this.model.mapOver.isCollection) {\n            this.$el.show();\n        } else {\n            this.$el.hide();\n        }\n    }\n});\n\nvar InputTerminalMappingView = TerminalMappingView.extend({\n    events: {\n        click: \"onClick\",\n        mouseenter: \"onMouseEnter\",\n        mouseleave: \"onMouseLeave\"\n    },\n    onMouseEnter: function onMouseEnter(e) {\n        var model = this.model;\n        if (!model.terminal.connected() && model.mapOver.isCollection) {\n            this.$el.css(\"color\", \"red\");\n        }\n    },\n    onMouseLeave: function onMouseLeave(e) {\n        this.$el.css(\"color\", \"black\");\n    },\n    onClick: function onClick(e) {\n        var model = this.model;\n        if (!model.terminal.connected() && model.mapOver.isCollection) {\n            // TODO: Consider prompting...\n            model.terminal.resetMapping();\n        }\n    }\n});\n\nvar TerminalView = Backbone.View.extend({\n    setupMappingView: function setupMappingView(terminal) {\n        var terminalMapping = new this.terminalMappingClass({\n            terminal: terminal\n        });\n        var terminalMappingView = new this.terminalMappingViewClass({\n            model: terminalMapping\n        });\n        terminalMappingView.render();\n        terminal.terminalMappingView = terminalMappingView;\n        this.terminalMappingView = terminalMappingView;\n    },\n    terminalElements: function terminalElements() {\n        if (this.terminalMappingView) {\n            return [this.terminalMappingView.el, this.el];\n        } else {\n            return [this.el];\n        }\n    }\n});\n\nvar BaseInputTerminalView = TerminalView.extend({\n    className: \"terminal input-terminal\",\n    initialize: function initialize(options) {\n        var node = options.node;\n        var input = options.input;\n        var name = input.name;\n        var terminal = this.terminalForInput(input);\n        if (!terminal.multiple) {\n            this.setupMappingView(terminal);\n        }\n        this.el.terminal = terminal;\n        terminal.node = node;\n        terminal.name = name;\n        node.input_terminals[name] = terminal;\n    },\n    events: {\n        dropinit: \"onDropInit\",\n        dropstart: \"onDropStart\",\n        dropend: \"onDropEnd\",\n        drop: \"onDrop\",\n        hover: \"onHover\"\n    },\n    onDropInit: function onDropInit(e, d) {\n        var terminal = this.el.terminal;\n        // Accept a dragable if it is an output terminal and has a\n        // compatible type\n        return $(d.drag).hasClass(\"output-terminal\") && terminal.canAccept(d.drag.terminal);\n    },\n    onDropStart: function onDropStart(e, d) {\n        if (d.proxy.terminal) {\n            d.proxy.terminal.connectors[0].inner_color = \"#BBFFBB\";\n        }\n    },\n    onDropEnd: function onDropEnd(e, d) {\n        if (d.proxy.terminal) {\n            d.proxy.terminal.connectors[0].inner_color = \"#FFFFFF\";\n        }\n    },\n    onDrop: function onDrop(e, d) {\n        var terminal = this.el.terminal;\n        new _workflowConnector2.default(d.drag.terminal, terminal).redraw();\n    },\n    onHover: function onHover() {\n        var element = this.el;\n        var terminal = element.terminal;\n        // If connected, create a popup to allow disconnection\n        if (terminal.connectors.length > 0) {\n            // Create callout\n            var t = $(\"<div class='callout'></div>\").css({ display: \"none\" }).appendTo(\"body\").append($(\"<div class='button'></div>\").append($(\"<div/>\").addClass(\"fa-icon-button fa fa-times\").click(function () {\n                $.each(terminal.connectors, function (_, x) {\n                    if (x) {\n                        x.destroy();\n                    }\n                });\n                t.remove();\n            }))).bind(\"mouseleave\", function () {\n                $(this).remove();\n            });\n            // Position it and show\n            t.css({\n                top: $(element).offset().top - 2,\n                left: $(element).offset().left - t.width(),\n                \"padding-right\": $(element).width()\n            }).show();\n        }\n    }\n});\n\nvar InputTerminalView = BaseInputTerminalView.extend({\n    terminalMappingClass: _workflowTerminals2.default.TerminalMapping,\n    terminalMappingViewClass: InputTerminalMappingView,\n    terminalForInput: function terminalForInput(input) {\n        return new _workflowTerminals2.default.InputTerminal({\n            element: this.el,\n            input: input\n        });\n    }\n});\n\nvar InputCollectionTerminalView = BaseInputTerminalView.extend({\n    terminalMappingClass: _workflowTerminals2.default.TerminalMapping,\n    terminalMappingViewClass: InputTerminalMappingView,\n    terminalForInput: function terminalForInput(input) {\n        return new _workflowTerminals2.default.InputCollectionTerminal({\n            element: this.el,\n            input: input\n        });\n    }\n});\n\nvar BaseOutputTerminalView = TerminalView.extend({\n    className: \"terminal output-terminal\",\n    initialize: function initialize(options) {\n        var node = options.node;\n        var output = options.output;\n        var name = output.name;\n        var terminal = this.terminalForOutput(output);\n        this.setupMappingView(terminal);\n        this.el.terminal = terminal;\n        terminal.node = node;\n        terminal.name = name;\n        node.output_terminals[name] = terminal;\n    },\n    events: {\n        drag: \"onDrag\",\n        dragstart: \"onDragStart\",\n        dragend: \"onDragEnd\"\n    },\n    onDrag: function onDrag(e, d) {\n        var onmove = function onmove() {\n            var po = $(d.proxy).offsetParent().offset();\n\n            var x = d.offsetX - po.left;\n            var y = d.offsetY - po.top;\n            $(d.proxy).css({ left: x, top: y });\n            d.proxy.terminal.redraw();\n            // FIXME: global\n            window.workflow_globals.canvas_manager.update_viewport_overlay();\n        };\n        onmove();\n        $(\"#canvas-container\").get(0).scroll_panel.test(e, onmove);\n    },\n    onDragStart: function onDragStart(e, d) {\n        $(d.available).addClass(\"input-terminal-active\");\n        // Save PJAs in the case of change datatype actions.\n        window.workflow_globals.workflow.check_changes_in_active_form();\n        // Drag proxy div\n        var h = $('<div class=\"drag-terminal\" style=\"position: absolute;\"></div>').appendTo(\"#canvas-container\").get(0);\n        // Terminal and connection to display noodle while dragging\n        h.terminal = new _workflowTerminals2.default.OutputTerminal({ element: h });\n        var c = new _workflowConnector2.default();\n        c.dragging = true;\n        c.connect(this.el.terminal, h.terminal);\n        return h;\n    },\n    onDragEnd: function onDragEnd(e, d) {\n        var connector = d.proxy.terminal.connectors[0];\n        // check_changes_in_active_form may change the state and cause a\n        // the connection to have already been destroyed. There must be better\n        // ways to handle this but the following check fixes some serious GUI\n        // bugs for now.\n        if (connector) {\n            connector.destroy();\n        }\n        $(d.proxy).remove();\n        $(d.available).removeClass(\"input-terminal-active\");\n        $(\"#canvas-container\").get(0).scroll_panel.stop();\n    }\n});\n\nvar OutputTerminalView = BaseOutputTerminalView.extend({\n    terminalMappingClass: _workflowTerminals2.default.TerminalMapping,\n    terminalMappingViewClass: TerminalMappingView,\n    terminalForOutput: function terminalForOutput(output) {\n        var type = output.extensions;\n        var terminal = new _workflowTerminals2.default.OutputTerminal({\n            element: this.el,\n            datatypes: type\n        });\n        return terminal;\n    }\n});\n\nvar OutputCollectionTerminalView = BaseOutputTerminalView.extend({\n    terminalMappingClass: _workflowTerminals2.default.TerminalMapping,\n    terminalMappingViewClass: TerminalMappingView,\n    terminalForOutput: function terminalForOutput(output) {\n        var collection_type = output.collection_type;\n        var collection_type_source = output.collection_type_source;\n        var terminal = new _workflowTerminals2.default.OutputCollectionTerminal({\n            element: this.el,\n            collection_type: collection_type,\n            collection_type_source: collection_type_source,\n            datatypes: output.extensions\n        });\n        return terminal;\n    }\n});\n\nexports.default = {\n    InputTerminalView: InputTerminalView,\n    OutputTerminalView: OutputTerminalView,\n    InputCollectionTerminalView: InputCollectionTerminalView,\n    OutputCollectionTerminalView: OutputCollectionTerminalView\n};\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! libs/backbone */ 2), __webpack_require__(/*! underscore */ 1), __webpack_require__(/*! jquery */ 0)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjkwLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL2dhbGF4eS9zY3JpcHRzL212Yy93b3JrZmxvdy93b3JrZmxvdy12aWV3LXRlcm1pbmFscy5qcz80NGQzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBUZXJtaW5hbHMgZnJvbSBcIm12Yy93b3JrZmxvdy93b3JrZmxvdy10ZXJtaW5hbHNcIjtcbmltcG9ydCBDb25uZWN0b3IgZnJvbSBcIm12Yy93b3JrZmxvdy93b3JrZmxvdy1jb25uZWN0b3JcIjtcblxuLy8gVE9ETzsgdGllIGludG8gR2FsYXh5IHN0YXRlP1xud2luZG93LndvcmtmbG93X2dsb2JhbHMgPSB3aW5kb3cud29ya2Zsb3dfZ2xvYmFscyB8fCB7fTtcblxudmFyIFRlcm1pbmFsTWFwcGluZ1ZpZXcgPSBCYWNrYm9uZS5WaWV3LmV4dGVuZCh7XG4gICAgdGFnTmFtZTogXCJkaXZcIixcbiAgICBjbGFzc05hbWU6IFwiZmEtaWNvbi1idXR0b24gZmEgZmEtZm9sZGVyLW9cIixcbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHZhciBtYXBUZXh0ID0gXCJSdW4gdG9vbCBpbiBwYXJhbGxlbCBvdmVyIGNvbGxlY3Rpb25cIjtcbiAgICAgICAgdGhpcy4kZWwudG9vbHRpcCh7IGRlbGF5OiA1MDAsIHRpdGxlOiBtYXBUZXh0IH0pO1xuICAgICAgICB0aGlzLm1vZGVsLmJpbmQoXCJjaGFuZ2VcIiwgXy5iaW5kKHRoaXMucmVuZGVyLCB0aGlzKSk7XG4gICAgfSxcbiAgICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5tb2RlbC5tYXBPdmVyLmlzQ29sbGVjdGlvbikge1xuICAgICAgICAgICAgdGhpcy4kZWwuc2hvdygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy4kZWwuaGlkZSgpO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cbnZhciBJbnB1dFRlcm1pbmFsTWFwcGluZ1ZpZXcgPSBUZXJtaW5hbE1hcHBpbmdWaWV3LmV4dGVuZCh7XG4gICAgZXZlbnRzOiB7XG4gICAgICAgIGNsaWNrOiBcIm9uQ2xpY2tcIixcbiAgICAgICAgbW91c2VlbnRlcjogXCJvbk1vdXNlRW50ZXJcIixcbiAgICAgICAgbW91c2VsZWF2ZTogXCJvbk1vdXNlTGVhdmVcIlxuICAgIH0sXG4gICAgb25Nb3VzZUVudGVyOiBmdW5jdGlvbihlKSB7XG4gICAgICAgIHZhciBtb2RlbCA9IHRoaXMubW9kZWw7XG4gICAgICAgIGlmICghbW9kZWwudGVybWluYWwuY29ubmVjdGVkKCkgJiYgbW9kZWwubWFwT3Zlci5pc0NvbGxlY3Rpb24pIHtcbiAgICAgICAgICAgIHRoaXMuJGVsLmNzcyhcImNvbG9yXCIsIFwicmVkXCIpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBvbk1vdXNlTGVhdmU6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdGhpcy4kZWwuY3NzKFwiY29sb3JcIiwgXCJibGFja1wiKTtcbiAgICB9LFxuICAgIG9uQ2xpY2s6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdmFyIG1vZGVsID0gdGhpcy5tb2RlbDtcbiAgICAgICAgaWYgKCFtb2RlbC50ZXJtaW5hbC5jb25uZWN0ZWQoKSAmJiBtb2RlbC5tYXBPdmVyLmlzQ29sbGVjdGlvbikge1xuICAgICAgICAgICAgLy8gVE9ETzogQ29uc2lkZXIgcHJvbXB0aW5nLi4uXG4gICAgICAgICAgICBtb2RlbC50ZXJtaW5hbC5yZXNldE1hcHBpbmcoKTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG52YXIgVGVybWluYWxWaWV3ID0gQmFja2JvbmUuVmlldy5leHRlbmQoe1xuICAgIHNldHVwTWFwcGluZ1ZpZXc6IGZ1bmN0aW9uKHRlcm1pbmFsKSB7XG4gICAgICAgIHZhciB0ZXJtaW5hbE1hcHBpbmcgPSBuZXcgdGhpcy50ZXJtaW5hbE1hcHBpbmdDbGFzcyh7XG4gICAgICAgICAgICB0ZXJtaW5hbDogdGVybWluYWxcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciB0ZXJtaW5hbE1hcHBpbmdWaWV3ID0gbmV3IHRoaXMudGVybWluYWxNYXBwaW5nVmlld0NsYXNzKHtcbiAgICAgICAgICAgIG1vZGVsOiB0ZXJtaW5hbE1hcHBpbmdcbiAgICAgICAgfSk7XG4gICAgICAgIHRlcm1pbmFsTWFwcGluZ1ZpZXcucmVuZGVyKCk7XG4gICAgICAgIHRlcm1pbmFsLnRlcm1pbmFsTWFwcGluZ1ZpZXcgPSB0ZXJtaW5hbE1hcHBpbmdWaWV3O1xuICAgICAgICB0aGlzLnRlcm1pbmFsTWFwcGluZ1ZpZXcgPSB0ZXJtaW5hbE1hcHBpbmdWaWV3O1xuICAgIH0sXG4gICAgdGVybWluYWxFbGVtZW50czogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLnRlcm1pbmFsTWFwcGluZ1ZpZXcpIHtcbiAgICAgICAgICAgIHJldHVybiBbdGhpcy50ZXJtaW5hbE1hcHBpbmdWaWV3LmVsLCB0aGlzLmVsXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBbdGhpcy5lbF07XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxudmFyIEJhc2VJbnB1dFRlcm1pbmFsVmlldyA9IFRlcm1pbmFsVmlldy5leHRlbmQoe1xuICAgIGNsYXNzTmFtZTogXCJ0ZXJtaW5hbCBpbnB1dC10ZXJtaW5hbFwiLFxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBvcHRpb25zLm5vZGU7XG4gICAgICAgIHZhciBpbnB1dCA9IG9wdGlvbnMuaW5wdXQ7XG4gICAgICAgIHZhciBuYW1lID0gaW5wdXQubmFtZTtcbiAgICAgICAgdmFyIHRlcm1pbmFsID0gdGhpcy50ZXJtaW5hbEZvcklucHV0KGlucHV0KTtcbiAgICAgICAgaWYgKCF0ZXJtaW5hbC5tdWx0aXBsZSkge1xuICAgICAgICAgICAgdGhpcy5zZXR1cE1hcHBpbmdWaWV3KHRlcm1pbmFsKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVsLnRlcm1pbmFsID0gdGVybWluYWw7XG4gICAgICAgIHRlcm1pbmFsLm5vZGUgPSBub2RlO1xuICAgICAgICB0ZXJtaW5hbC5uYW1lID0gbmFtZTtcbiAgICAgICAgbm9kZS5pbnB1dF90ZXJtaW5hbHNbbmFtZV0gPSB0ZXJtaW5hbDtcbiAgICB9LFxuICAgIGV2ZW50czoge1xuICAgICAgICBkcm9waW5pdDogXCJvbkRyb3BJbml0XCIsXG4gICAgICAgIGRyb3BzdGFydDogXCJvbkRyb3BTdGFydFwiLFxuICAgICAgICBkcm9wZW5kOiBcIm9uRHJvcEVuZFwiLFxuICAgICAgICBkcm9wOiBcIm9uRHJvcFwiLFxuICAgICAgICBob3ZlcjogXCJvbkhvdmVyXCJcbiAgICB9LFxuICAgIG9uRHJvcEluaXQ6IGZ1bmN0aW9uKGUsIGQpIHtcbiAgICAgICAgdmFyIHRlcm1pbmFsID0gdGhpcy5lbC50ZXJtaW5hbDtcbiAgICAgICAgLy8gQWNjZXB0IGEgZHJhZ2FibGUgaWYgaXQgaXMgYW4gb3V0cHV0IHRlcm1pbmFsIGFuZCBoYXMgYVxuICAgICAgICAvLyBjb21wYXRpYmxlIHR5cGVcbiAgICAgICAgcmV0dXJuICQoZC5kcmFnKS5oYXNDbGFzcyhcIm91dHB1dC10ZXJtaW5hbFwiKSAmJiB0ZXJtaW5hbC5jYW5BY2NlcHQoZC5kcmFnLnRlcm1pbmFsKTtcbiAgICB9LFxuICAgIG9uRHJvcFN0YXJ0OiBmdW5jdGlvbihlLCBkKSB7XG4gICAgICAgIGlmIChkLnByb3h5LnRlcm1pbmFsKSB7XG4gICAgICAgICAgICBkLnByb3h5LnRlcm1pbmFsLmNvbm5lY3RvcnNbMF0uaW5uZXJfY29sb3IgPSBcIiNCQkZGQkJcIjtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgb25Ecm9wRW5kOiBmdW5jdGlvbihlLCBkKSB7XG4gICAgICAgIGlmIChkLnByb3h5LnRlcm1pbmFsKSB7XG4gICAgICAgICAgICBkLnByb3h5LnRlcm1pbmFsLmNvbm5lY3RvcnNbMF0uaW5uZXJfY29sb3IgPSBcIiNGRkZGRkZcIjtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgb25Ecm9wOiBmdW5jdGlvbihlLCBkKSB7XG4gICAgICAgIHZhciB0ZXJtaW5hbCA9IHRoaXMuZWwudGVybWluYWw7XG4gICAgICAgIG5ldyBDb25uZWN0b3IoZC5kcmFnLnRlcm1pbmFsLCB0ZXJtaW5hbCkucmVkcmF3KCk7XG4gICAgfSxcbiAgICBvbkhvdmVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLmVsO1xuICAgICAgICB2YXIgdGVybWluYWwgPSBlbGVtZW50LnRlcm1pbmFsO1xuICAgICAgICAvLyBJZiBjb25uZWN0ZWQsIGNyZWF0ZSBhIHBvcHVwIHRvIGFsbG93IGRpc2Nvbm5lY3Rpb25cbiAgICAgICAgaWYgKHRlcm1pbmFsLmNvbm5lY3RvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGNhbGxvdXRcbiAgICAgICAgICAgIHZhciB0ID0gJChcIjxkaXYgY2xhc3M9J2NhbGxvdXQnPjwvZGl2PlwiKVxuICAgICAgICAgICAgICAgIC5jc3MoeyBkaXNwbGF5OiBcIm5vbmVcIiB9KVxuICAgICAgICAgICAgICAgIC5hcHBlbmRUbyhcImJvZHlcIilcbiAgICAgICAgICAgICAgICAuYXBwZW5kKFxuICAgICAgICAgICAgICAgICAgICAkKFwiPGRpdiBjbGFzcz0nYnV0dG9uJz48L2Rpdj5cIikuYXBwZW5kKFxuICAgICAgICAgICAgICAgICAgICAgICAgJChcIjxkaXYvPlwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hZGRDbGFzcyhcImZhLWljb24tYnV0dG9uIGZhIGZhLXRpbWVzXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmNsaWNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJC5lYWNoKHRlcm1pbmFsLmNvbm5lY3RvcnMsIChfLCB4KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoeCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHguZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdC5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIC5iaW5kKFwibW91c2VsZWF2ZVwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgJCh0aGlzKS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIFBvc2l0aW9uIGl0IGFuZCBzaG93XG4gICAgICAgICAgICB0XG4gICAgICAgICAgICAgICAgLmNzcyh7XG4gICAgICAgICAgICAgICAgICAgIHRvcDogJChlbGVtZW50KS5vZmZzZXQoKS50b3AgLSAyLFxuICAgICAgICAgICAgICAgICAgICBsZWZ0OiAkKGVsZW1lbnQpLm9mZnNldCgpLmxlZnQgLSB0LndpZHRoKCksXG4gICAgICAgICAgICAgICAgICAgIFwicGFkZGluZy1yaWdodFwiOiAkKGVsZW1lbnQpLndpZHRoKClcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5zaG93KCk7XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxudmFyIElucHV0VGVybWluYWxWaWV3ID0gQmFzZUlucHV0VGVybWluYWxWaWV3LmV4dGVuZCh7XG4gICAgdGVybWluYWxNYXBwaW5nQ2xhc3M6IFRlcm1pbmFscy5UZXJtaW5hbE1hcHBpbmcsXG4gICAgdGVybWluYWxNYXBwaW5nVmlld0NsYXNzOiBJbnB1dFRlcm1pbmFsTWFwcGluZ1ZpZXcsXG4gICAgdGVybWluYWxGb3JJbnB1dDogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUZXJtaW5hbHMuSW5wdXRUZXJtaW5hbCh7XG4gICAgICAgICAgICBlbGVtZW50OiB0aGlzLmVsLFxuICAgICAgICAgICAgaW5wdXQ6IGlucHV0XG4gICAgICAgIH0pO1xuICAgIH1cbn0pO1xuXG52YXIgSW5wdXRDb2xsZWN0aW9uVGVybWluYWxWaWV3ID0gQmFzZUlucHV0VGVybWluYWxWaWV3LmV4dGVuZCh7XG4gICAgdGVybWluYWxNYXBwaW5nQ2xhc3M6IFRlcm1pbmFscy5UZXJtaW5hbE1hcHBpbmcsXG4gICAgdGVybWluYWxNYXBwaW5nVmlld0NsYXNzOiBJbnB1dFRlcm1pbmFsTWFwcGluZ1ZpZXcsXG4gICAgdGVybWluYWxGb3JJbnB1dDogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUZXJtaW5hbHMuSW5wdXRDb2xsZWN0aW9uVGVybWluYWwoe1xuICAgICAgICAgICAgZWxlbWVudDogdGhpcy5lbCxcbiAgICAgICAgICAgIGlucHV0OiBpbnB1dFxuICAgICAgICB9KTtcbiAgICB9XG59KTtcblxudmFyIEJhc2VPdXRwdXRUZXJtaW5hbFZpZXcgPSBUZXJtaW5hbFZpZXcuZXh0ZW5kKHtcbiAgICBjbGFzc05hbWU6IFwidGVybWluYWwgb3V0cHV0LXRlcm1pbmFsXCIsXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICB2YXIgbm9kZSA9IG9wdGlvbnMubm9kZTtcbiAgICAgICAgdmFyIG91dHB1dCA9IG9wdGlvbnMub3V0cHV0O1xuICAgICAgICB2YXIgbmFtZSA9IG91dHB1dC5uYW1lO1xuICAgICAgICB2YXIgdGVybWluYWwgPSB0aGlzLnRlcm1pbmFsRm9yT3V0cHV0KG91dHB1dCk7XG4gICAgICAgIHRoaXMuc2V0dXBNYXBwaW5nVmlldyh0ZXJtaW5hbCk7XG4gICAgICAgIHRoaXMuZWwudGVybWluYWwgPSB0ZXJtaW5hbDtcbiAgICAgICAgdGVybWluYWwubm9kZSA9IG5vZGU7XG4gICAgICAgIHRlcm1pbmFsLm5hbWUgPSBuYW1lO1xuICAgICAgICBub2RlLm91dHB1dF90ZXJtaW5hbHNbbmFtZV0gPSB0ZXJtaW5hbDtcbiAgICB9LFxuICAgIGV2ZW50czoge1xuICAgICAgICBkcmFnOiBcIm9uRHJhZ1wiLFxuICAgICAgICBkcmFnc3RhcnQ6IFwib25EcmFnU3RhcnRcIixcbiAgICAgICAgZHJhZ2VuZDogXCJvbkRyYWdFbmRcIlxuICAgIH0sXG4gICAgb25EcmFnOiBmdW5jdGlvbihlLCBkKSB7XG4gICAgICAgIHZhciBvbm1vdmUgPSAoKSA9PiB7XG4gICAgICAgICAgICB2YXIgcG8gPSAkKGQucHJveHkpXG4gICAgICAgICAgICAgICAgLm9mZnNldFBhcmVudCgpXG4gICAgICAgICAgICAgICAgLm9mZnNldCgpO1xuXG4gICAgICAgICAgICB2YXIgeCA9IGQub2Zmc2V0WCAtIHBvLmxlZnQ7XG4gICAgICAgICAgICB2YXIgeSA9IGQub2Zmc2V0WSAtIHBvLnRvcDtcbiAgICAgICAgICAgICQoZC5wcm94eSkuY3NzKHsgbGVmdDogeCwgdG9wOiB5IH0pO1xuICAgICAgICAgICAgZC5wcm94eS50ZXJtaW5hbC5yZWRyYXcoKTtcbiAgICAgICAgICAgIC8vIEZJWE1FOiBnbG9iYWxcbiAgICAgICAgICAgIHdpbmRvdy53b3JrZmxvd19nbG9iYWxzLmNhbnZhc19tYW5hZ2VyLnVwZGF0ZV92aWV3cG9ydF9vdmVybGF5KCk7XG4gICAgICAgIH07XG4gICAgICAgIG9ubW92ZSgpO1xuICAgICAgICAkKFwiI2NhbnZhcy1jb250YWluZXJcIilcbiAgICAgICAgICAgIC5nZXQoMClcbiAgICAgICAgICAgIC5zY3JvbGxfcGFuZWwudGVzdChlLCBvbm1vdmUpO1xuICAgIH0sXG4gICAgb25EcmFnU3RhcnQ6IGZ1bmN0aW9uKGUsIGQpIHtcbiAgICAgICAgJChkLmF2YWlsYWJsZSkuYWRkQ2xhc3MoXCJpbnB1dC10ZXJtaW5hbC1hY3RpdmVcIik7XG4gICAgICAgIC8vIFNhdmUgUEpBcyBpbiB0aGUgY2FzZSBvZiBjaGFuZ2UgZGF0YXR5cGUgYWN0aW9ucy5cbiAgICAgICAgd2luZG93LndvcmtmbG93X2dsb2JhbHMud29ya2Zsb3cuY2hlY2tfY2hhbmdlc19pbl9hY3RpdmVfZm9ybSgpO1xuICAgICAgICAvLyBEcmFnIHByb3h5IGRpdlxuICAgICAgICB2YXIgaCA9ICQoJzxkaXYgY2xhc3M9XCJkcmFnLXRlcm1pbmFsXCIgc3R5bGU9XCJwb3NpdGlvbjogYWJzb2x1dGU7XCI+PC9kaXY+JylcbiAgICAgICAgICAgIC5hcHBlbmRUbyhcIiNjYW52YXMtY29udGFpbmVyXCIpXG4gICAgICAgICAgICAuZ2V0KDApO1xuICAgICAgICAvLyBUZXJtaW5hbCBhbmQgY29ubmVjdGlvbiB0byBkaXNwbGF5IG5vb2RsZSB3aGlsZSBkcmFnZ2luZ1xuICAgICAgICBoLnRlcm1pbmFsID0gbmV3IFRlcm1pbmFscy5PdXRwdXRUZXJtaW5hbCh7IGVsZW1lbnQ6IGggfSk7XG4gICAgICAgIHZhciBjID0gbmV3IENvbm5lY3RvcigpO1xuICAgICAgICBjLmRyYWdnaW5nID0gdHJ1ZTtcbiAgICAgICAgYy5jb25uZWN0KHRoaXMuZWwudGVybWluYWwsIGgudGVybWluYWwpO1xuICAgICAgICByZXR1cm4gaDtcbiAgICB9LFxuICAgIG9uRHJhZ0VuZDogZnVuY3Rpb24oZSwgZCkge1xuICAgICAgICB2YXIgY29ubmVjdG9yID0gZC5wcm94eS50ZXJtaW5hbC5jb25uZWN0b3JzWzBdO1xuICAgICAgICAvLyBjaGVja19jaGFuZ2VzX2luX2FjdGl2ZV9mb3JtIG1heSBjaGFuZ2UgdGhlIHN0YXRlIGFuZCBjYXVzZSBhXG4gICAgICAgIC8vIHRoZSBjb25uZWN0aW9uIHRvIGhhdmUgYWxyZWFkeSBiZWVuIGRlc3Ryb3llZC4gVGhlcmUgbXVzdCBiZSBiZXR0ZXJcbiAgICAgICAgLy8gd2F5cyB0byBoYW5kbGUgdGhpcyBidXQgdGhlIGZvbGxvd2luZyBjaGVjayBmaXhlcyBzb21lIHNlcmlvdXMgR1VJXG4gICAgICAgIC8vIGJ1Z3MgZm9yIG5vdy5cbiAgICAgICAgaWYgKGNvbm5lY3Rvcikge1xuICAgICAgICAgICAgY29ubmVjdG9yLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgICAkKGQucHJveHkpLnJlbW92ZSgpO1xuICAgICAgICAkKGQuYXZhaWxhYmxlKS5yZW1vdmVDbGFzcyhcImlucHV0LXRlcm1pbmFsLWFjdGl2ZVwiKTtcbiAgICAgICAgJChcIiNjYW52YXMtY29udGFpbmVyXCIpXG4gICAgICAgICAgICAuZ2V0KDApXG4gICAgICAgICAgICAuc2Nyb2xsX3BhbmVsLnN0b3AoKTtcbiAgICB9XG59KTtcblxudmFyIE91dHB1dFRlcm1pbmFsVmlldyA9IEJhc2VPdXRwdXRUZXJtaW5hbFZpZXcuZXh0ZW5kKHtcbiAgICB0ZXJtaW5hbE1hcHBpbmdDbGFzczogVGVybWluYWxzLlRlcm1pbmFsTWFwcGluZyxcbiAgICB0ZXJtaW5hbE1hcHBpbmdWaWV3Q2xhc3M6IFRlcm1pbmFsTWFwcGluZ1ZpZXcsXG4gICAgdGVybWluYWxGb3JPdXRwdXQ6IGZ1bmN0aW9uKG91dHB1dCkge1xuICAgICAgICB2YXIgdHlwZSA9IG91dHB1dC5leHRlbnNpb25zO1xuICAgICAgICB2YXIgdGVybWluYWwgPSBuZXcgVGVybWluYWxzLk91dHB1dFRlcm1pbmFsKHtcbiAgICAgICAgICAgIGVsZW1lbnQ6IHRoaXMuZWwsXG4gICAgICAgICAgICBkYXRhdHlwZXM6IHR5cGVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0ZXJtaW5hbDtcbiAgICB9XG59KTtcblxudmFyIE91dHB1dENvbGxlY3Rpb25UZXJtaW5hbFZpZXcgPSBCYXNlT3V0cHV0VGVybWluYWxWaWV3LmV4dGVuZCh7XG4gICAgdGVybWluYWxNYXBwaW5nQ2xhc3M6IFRlcm1pbmFscy5UZXJtaW5hbE1hcHBpbmcsXG4gICAgdGVybWluYWxNYXBwaW5nVmlld0NsYXNzOiBUZXJtaW5hbE1hcHBpbmdWaWV3LFxuICAgIHRlcm1pbmFsRm9yT3V0cHV0OiBmdW5jdGlvbihvdXRwdXQpIHtcbiAgICAgICAgdmFyIGNvbGxlY3Rpb25fdHlwZSA9IG91dHB1dC5jb2xsZWN0aW9uX3R5cGU7XG4gICAgICAgIHZhciBjb2xsZWN0aW9uX3R5cGVfc291cmNlID0gb3V0cHV0LmNvbGxlY3Rpb25fdHlwZV9zb3VyY2U7XG4gICAgICAgIHZhciB0ZXJtaW5hbCA9IG5ldyBUZXJtaW5hbHMuT3V0cHV0Q29sbGVjdGlvblRlcm1pbmFsKHtcbiAgICAgICAgICAgIGVsZW1lbnQ6IHRoaXMuZWwsXG4gICAgICAgICAgICBjb2xsZWN0aW9uX3R5cGU6IGNvbGxlY3Rpb25fdHlwZSxcbiAgICAgICAgICAgIGNvbGxlY3Rpb25fdHlwZV9zb3VyY2U6IGNvbGxlY3Rpb25fdHlwZV9zb3VyY2UsXG4gICAgICAgICAgICBkYXRhdHlwZXM6IG91dHB1dC5leHRlbnNpb25zXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGVybWluYWw7XG4gICAgfVxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgICBJbnB1dFRlcm1pbmFsVmlldzogSW5wdXRUZXJtaW5hbFZpZXcsXG4gICAgT3V0cHV0VGVybWluYWxWaWV3OiBPdXRwdXRUZXJtaW5hbFZpZXcsXG4gICAgSW5wdXRDb2xsZWN0aW9uVGVybWluYWxWaWV3OiBJbnB1dENvbGxlY3Rpb25UZXJtaW5hbFZpZXcsXG4gICAgT3V0cHV0Q29sbGVjdGlvblRlcm1pbmFsVmlldzogT3V0cHV0Q29sbGVjdGlvblRlcm1pbmFsVmlld1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBnYWxheHkvc2NyaXB0cy9tdmMvd29ya2Zsb3cvd29ya2Zsb3ctdmlldy10ZXJtaW5hbHMuanMiXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7OztBQUFBO0FBQ0E7Ozs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBZEE7QUFDQTtBQWdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXJCQTtBQUNBO0FBdUJBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBbEJBO0FBQ0E7QUFvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBSEE7QUFNQTtBQUNBO0FBN0VBO0FBQ0E7QUErRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBUkE7QUFDQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQVJBO0FBQ0E7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQWpFQTtBQUNBO0FBbUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFWQTtBQUNBO0FBWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQWJBO0FBQ0E7QUFlQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///290\n");

/***/ }),

/***/ 291:
/*!***********************************************************!*\
  !*** ./galaxy/scripts/mvc/workflow/workflow-terminals.js ***!
  \***********************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function($, Backbone, _) {\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n// TODO; tie into Galaxy state?\nwindow.workflow_globals = window.workflow_globals || {};\nfunction CollectionTypeDescription(collectionType) {\n    this.collectionType = collectionType;\n    this.isCollection = true;\n    this.rank = collectionType.split(\":\").length;\n}\n\nvar NULL_COLLECTION_TYPE_DESCRIPTION = {\n    isCollection: false,\n    canMatch: function canMatch() {\n        return false;\n    },\n    canMapOver: function canMapOver() {\n        return false;\n    },\n    toString: function toString() {\n        return \"NullCollectionType[]\";\n    },\n    append: function append(otherCollectionType) {\n        return otherCollectionType;\n    },\n    equal: function equal(other) {\n        return other === this;\n    }\n};\n\nvar ANY_COLLECTION_TYPE_DESCRIPTION = {\n    isCollection: true,\n    canMatch: function canMatch(other) {\n        return NULL_COLLECTION_TYPE_DESCRIPTION !== other;\n    },\n    canMapOver: function canMapOver() {\n        return false;\n    },\n    toString: function toString() {\n        return \"AnyCollectionType[]\";\n    },\n    append: function append() {\n        throw \"Cannot append to ANY_COLLECTION_TYPE_DESCRIPTION\";\n    },\n    equal: function equal(other) {\n        return other === this;\n    }\n};\n\n$.extend(CollectionTypeDescription.prototype, {\n    append: function append(otherCollectionTypeDescription) {\n        if (otherCollectionTypeDescription === NULL_COLLECTION_TYPE_DESCRIPTION) {\n            return this;\n        }\n        if (otherCollectionTypeDescription === ANY_COLLECTION_TYPE_DESCRIPTION) {\n            return otherCollectionTypeDescription;\n        }\n        return new CollectionTypeDescription(this.collectionType + \":\" + otherCollectionTypeDescription.collectionType);\n    },\n    canMatch: function canMatch(otherCollectionTypeDescription) {\n        if (otherCollectionTypeDescription === NULL_COLLECTION_TYPE_DESCRIPTION) {\n            return false;\n        }\n        if (otherCollectionTypeDescription === ANY_COLLECTION_TYPE_DESCRIPTION) {\n            return true;\n        }\n        return otherCollectionTypeDescription.collectionType == this.collectionType;\n    },\n    canMapOver: function canMapOver(otherCollectionTypeDescription) {\n        if (otherCollectionTypeDescription === NULL_COLLECTION_TYPE_DESCRIPTION) {\n            return false;\n        }\n        if (otherCollectionTypeDescription === ANY_COLLECTION_TYPE_DESCRIPTION) {\n            return false;\n        }\n        if (this.rank <= otherCollectionTypeDescription.rank) {\n            // Cannot map over self...\n            return false;\n        }\n        var requiredSuffix = otherCollectionTypeDescription.collectionType;\n        return this._endsWith(this.collectionType, requiredSuffix);\n    },\n    effectiveMapOver: function effectiveMapOver(otherCollectionTypeDescription) {\n        var otherCollectionType = otherCollectionTypeDescription.collectionType;\n        var effectiveCollectionType = this.collectionType.substring(0, this.collectionType.length - otherCollectionType.length - 1);\n        return new CollectionTypeDescription(effectiveCollectionType);\n    },\n    equal: function equal(otherCollectionTypeDescription) {\n        return otherCollectionTypeDescription.collectionType == this.collectionType;\n    },\n    toString: function toString() {\n        return \"CollectionType[\" + this.collectionType + \"]\";\n    },\n    _endsWith: function _endsWith(str, suffix) {\n        return str.indexOf(suffix, str.length - suffix.length) !== -1;\n    }\n});\n\nvar TerminalMapping = Backbone.Model.extend({\n    initialize: function initialize(attr) {\n        this.mapOver = attr.mapOver || NULL_COLLECTION_TYPE_DESCRIPTION;\n        this.terminal = attr.terminal;\n        this.terminal.terminalMapping = this;\n    },\n    disableMapOver: function disableMapOver() {\n        this.setMapOver(NULL_COLLECTION_TYPE_DESCRIPTION);\n    },\n    setMapOver: function setMapOver(collectionTypeDescription) {\n        // TODO: Can I use \"attributes\" or something to auto trigger \"change\"\n        // event?\n        this.mapOver = collectionTypeDescription;\n        this.trigger(\"change\");\n    }\n});\n\nvar Terminal = Backbone.Model.extend({\n    initialize: function initialize(attr) {\n        this.element = attr.element;\n        this.connectors = [];\n    },\n    connect: function connect(connector) {\n        this.connectors.push(connector);\n        if (this.node) {\n            this.node.markChanged();\n        }\n    },\n    disconnect: function disconnect(connector) {\n        this.connectors.splice($.inArray(connector, this.connectors), 1);\n        if (this.node) {\n            this.node.markChanged();\n            this.resetMappingIfNeeded();\n        }\n    },\n    redraw: function redraw() {\n        $.each(this.connectors, function (_, c) {\n            c.redraw();\n        });\n    },\n    destroy: function destroy() {\n        $.each(this.connectors.slice(), function (_, c) {\n            c.destroy();\n        });\n    },\n    destroyInvalidConnections: function destroyInvalidConnections() {\n        _.each(this.connectors, function (connector) {\n            if (connector) {\n                connector.destroyIfInvalid();\n            }\n        });\n    },\n    setMapOver: function setMapOver(val) {\n        if (this.multiple) {\n            return; // Cannot set this to be multirun...\n        }\n\n        if (!this.mapOver().equal(val)) {\n            this.terminalMapping.setMapOver(val);\n            _.each(this.node.output_terminals, function (outputTerminal) {\n                outputTerminal.setMapOver(val);\n            });\n        }\n    },\n    mapOver: function mapOver() {\n        if (!this.terminalMapping) {\n            return NULL_COLLECTION_TYPE_DESCRIPTION;\n        } else {\n            return this.terminalMapping.mapOver;\n        }\n    },\n    isMappedOver: function isMappedOver() {\n        return this.terminalMapping && this.terminalMapping.mapOver.isCollection;\n    },\n    resetMapping: function resetMapping() {\n        this.terminalMapping.disableMapOver();\n    },\n\n    resetMappingIfNeeded: function resetMappingIfNeeded() {} // Subclasses should override this...\n});\n\nvar OutputTerminal = Terminal.extend({\n    initialize: function initialize(attr) {\n        Terminal.prototype.initialize.call(this, attr);\n        this.datatypes = attr.datatypes;\n    },\n\n    resetMappingIfNeeded: function resetMappingIfNeeded() {\n        // If inputs were only mapped over to preserve\n        // an output just disconnected reset these...\n        if (!this.node.hasConnectedOutputTerminals() && !this.node.hasConnectedMappedInputTerminals()) {\n            _.each(this.node.mappedInputTerminals(), function (mappedInput) {\n                mappedInput.resetMappingIfNeeded();\n            });\n        }\n\n        var noMappedInputs = !this.node.hasMappedOverInputTerminals();\n        if (noMappedInputs) {\n            this.resetMapping();\n        }\n    },\n\n    resetMapping: function resetMapping() {\n        this.terminalMapping.disableMapOver();\n        _.each(this.connectors, function (connector) {\n            var connectedInput = connector.handle2;\n            if (connectedInput) {\n                // Not exactly right because this is still connected.\n                // Either rewrite resetMappingIfNeeded or disconnect\n                // and reconnect if valid.\n                connectedInput.resetMappingIfNeeded();\n                connector.destroyIfInvalid();\n            }\n        });\n    }\n});\n\nvar BaseInputTerminal = Terminal.extend({\n    initialize: function initialize(attr) {\n        Terminal.prototype.initialize.call(this, attr);\n        this.update(attr.input); // subclasses should implement this...\n    },\n    canAccept: function canAccept(other) {\n        if (this._inputFilled()) {\n            return false;\n        } else {\n            return this.attachable(other);\n        }\n    },\n    resetMappingIfNeeded: function resetMappingIfNeeded() {\n        var mapOver = this.mapOver();\n        if (!mapOver.isCollection) {\n            return;\n        }\n        // No output terminals are counting on this being mapped\n        // over if connected inputs are still mapped over or if none\n        // of the outputs are connected...\n        var reset = this.node.hasConnectedMappedInputTerminals() || !this.node.hasConnectedOutputTerminals();\n        if (reset) {\n            this.resetMapping();\n        }\n    },\n    resetMapping: function resetMapping() {\n        this.terminalMapping.disableMapOver();\n        if (!this.node.hasMappedOverInputTerminals()) {\n            _.each(this.node.output_terminals, function (terminal) {\n                // This shouldn't be called if there are mapped over\n                // outputs.\n                terminal.resetMapping();\n            });\n        }\n    },\n    connected: function connected() {\n        return this.connectors.length !== 0;\n    },\n    _inputFilled: function _inputFilled() {\n        var inputFilled;\n        if (!this.connected()) {\n            inputFilled = false;\n        } else {\n            if (this.multiple) {\n                if (this._collectionAttached()) {\n                    // Can only attach one collection to multiple input\n                    // data parameter.\n                    inputFilled = true;\n                } else {\n                    inputFilled = false;\n                }\n            } else {\n                inputFilled = true;\n            }\n        }\n        return inputFilled;\n    },\n    _collectionAttached: function _collectionAttached() {\n        if (!this.connected()) {\n            return false;\n        } else {\n            var firstOutput = this.connectors[0].handle1;\n            if (!firstOutput) {\n                return false;\n            } else {\n                if (firstOutput.isCollection || firstOutput.isMappedOver() || firstOutput.datatypes.indexOf(\"input_collection\") > 0) {\n                    return true;\n                } else {\n                    return false;\n                }\n            }\n        }\n    },\n    _mappingConstraints: function _mappingConstraints() {\n        // If this is a connected terminal, return list of collection types\n        // other terminals connected to node are constraining mapping to.\n        if (!this.node) {\n            return []; // No node - completely unconstrained\n        }\n        var mapOver = this.mapOver();\n        if (mapOver.isCollection) {\n            return [mapOver];\n        }\n\n        var constraints = [];\n        if (!this.node.hasConnectedOutputTerminals()) {\n            _.each(this.node.connectedMappedInputTerminals(), function (inputTerminal) {\n                constraints.push(inputTerminal.mapOver());\n            });\n        } else {\n            // All outputs should have same mapOver status - least specific.\n            constraints.push(_.first(_.values(this.node.output_terminals)).mapOver());\n        }\n        return constraints;\n    },\n    _producesAcceptableDatatype: function _producesAcceptableDatatype(other) {\n        // other is a non-collection output...\n        for (var t in this.datatypes) {\n            var thisDatatype = this.datatypes[t];\n            if (thisDatatype == \"input\") {\n                return true;\n            }\n            var cat_outputs = [];\n            cat_outputs = cat_outputs.concat(other.datatypes);\n            if (other.node.post_job_actions) {\n                for (var pja_i in other.node.post_job_actions) {\n                    var pja = other.node.post_job_actions[pja_i];\n                    if (pja.action_type == \"ChangeDatatypeAction\" && (pja.output_name === \"\" || pja.output_name == other.name) && pja.action_arguments) {\n                        cat_outputs.push(pja.action_arguments.newtype);\n                    }\n                }\n            }\n            // FIXME: No idea what to do about case when datatype is 'input'\n            for (var other_datatype_i in cat_outputs) {\n                var other_datatype = cat_outputs[other_datatype_i];\n                if (other_datatype == \"input\" || other_datatype == \"_sniff_\" || other_datatype == \"input_collection\" || window.workflow_globals.app.isSubType(cat_outputs[other_datatype_i], thisDatatype)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    },\n    _otherCollectionType: function _otherCollectionType(other) {\n        var otherCollectionType = NULL_COLLECTION_TYPE_DESCRIPTION;\n        if (other.isCollection) {\n            otherCollectionType = other.collectionType;\n        }\n        var otherMapOver = other.mapOver();\n        if (otherMapOver.isCollection) {\n            otherCollectionType = otherMapOver.append(otherCollectionType);\n        }\n        return otherCollectionType;\n    }\n});\n\nvar InputTerminal = BaseInputTerminal.extend({\n    update: function update(input) {\n        this.datatypes = input.extensions;\n        this.multiple = input.multiple;\n        this.collection = false;\n    },\n    connect: function connect(connector) {\n        BaseInputTerminal.prototype.connect.call(this, connector);\n        var other_output = connector.handle1;\n        if (!other_output) {\n            return;\n        }\n        var otherCollectionType = this._otherCollectionType(other_output);\n        if (otherCollectionType.isCollection) {\n            this.setMapOver(otherCollectionType);\n        }\n    },\n    attachable: function attachable(other) {\n        var otherCollectionType = this._otherCollectionType(other);\n        var thisMapOver = this.mapOver();\n        if (otherCollectionType.isCollection) {\n            if (this.multiple) {\n                if (this.connected() && !this._collectionAttached()) {\n                    // if single inputs attached, cannot also attach a\n                    // collection (yet...)\n                    return false;\n                }\n                if (otherCollectionType.rank == 1) {\n                    return this._producesAcceptableDatatype(other);\n                } else {\n                    // TODO: Allow subcollection mapping over this as if it were\n                    // a list collection input.\n                    return false;\n                }\n            }\n            if (thisMapOver.isCollection && thisMapOver.canMatch(otherCollectionType)) {\n                return this._producesAcceptableDatatype(other);\n            } else {\n                //  Need to check if this would break constraints...\n                var mappingConstraints = this._mappingConstraints();\n                if (mappingConstraints.every(_.bind(otherCollectionType.canMatch, otherCollectionType))) {\n                    return this._producesAcceptableDatatype(other);\n                } else {\n                    return false;\n                }\n            }\n        } else if (thisMapOver.isCollection) {\n            // Attempting to match a non-collection output to an\n            // explicitly collection input.\n            return false;\n        }\n        return this._producesAcceptableDatatype(other);\n    }\n});\n\nvar InputCollectionTerminal = BaseInputTerminal.extend({\n    update: function update(input) {\n        this.multiple = false;\n        this.collection = true;\n        this.datatypes = input.extensions;\n        var collectionTypes = [];\n        if (input.collection_types) {\n            _.each(input.collection_types, function (collectionType) {\n                collectionTypes.push(new CollectionTypeDescription(collectionType));\n            });\n        } else {\n            collectionTypes.push(ANY_COLLECTION_TYPE_DESCRIPTION);\n        }\n        this.collectionTypes = collectionTypes;\n    },\n    connect: function connect(connector) {\n        BaseInputTerminal.prototype.connect.call(this, connector);\n        var other = connector.handle1;\n        if (!other) {\n            return;\n        }\n\n        var effectiveMapOver = this._effectiveMapOver(other);\n        this.setMapOver(effectiveMapOver);\n    },\n    _effectiveMapOver: function _effectiveMapOver(other) {\n        var collectionTypes = this.collectionTypes;\n        var otherCollectionType = this._otherCollectionType(other);\n        var canMatch = _.some(collectionTypes, function (collectionType) {\n            return collectionType.canMatch(otherCollectionType);\n        });\n\n        if (!canMatch) {\n            for (var collectionTypeIndex in collectionTypes) {\n                var collectionType = collectionTypes[collectionTypeIndex];\n                if (otherCollectionType.canMapOver(collectionType)) {\n                    var effectiveMapOver = otherCollectionType.effectiveMapOver(collectionType);\n                    if (effectiveMapOver != NULL_COLLECTION_TYPE_DESCRIPTION) {\n                        return effectiveMapOver;\n                    }\n                }\n            }\n        }\n        return NULL_COLLECTION_TYPE_DESCRIPTION;\n    },\n    _effectiveCollectionTypes: function _effectiveCollectionTypes() {\n        var thisMapOver = this.mapOver();\n        return _.map(this.collectionTypes, function (t) {\n            return thisMapOver.append(t);\n        });\n    },\n    attachable: function attachable(other) {\n        var otherCollectionType = this._otherCollectionType(other);\n        if (otherCollectionType.isCollection) {\n            var effectiveCollectionTypes = this._effectiveCollectionTypes();\n            var thisMapOver = this.mapOver();\n            var canMatch = _.some(effectiveCollectionTypes, function (effectiveCollectionType) {\n                return effectiveCollectionType.canMatch(otherCollectionType);\n            });\n            if (canMatch) {\n                // Only way a direct match...\n                return this._producesAcceptableDatatype(other);\n                // Otherwise we need to mapOver\n            } else if (thisMapOver.isCollection) {\n                // In this case, mapOver already set and we didn't match skipping...\n                return false;\n            } else if (_.some(this.collectionTypes, function (collectionType) {\n                return otherCollectionType.canMapOver(collectionType);\n            })) {\n                var effectiveMapOver = this._effectiveMapOver(other);\n                if (!effectiveMapOver.isCollection) {\n                    return false;\n                }\n                //  Need to check if this would break constraints...\n                var mappingConstraints = this._mappingConstraints();\n                if (mappingConstraints.every(effectiveMapOver.canMatch)) {\n                    return this._producesAcceptableDatatype(other);\n                }\n            }\n        }\n        return false;\n    }\n});\n\nvar OutputCollectionTerminal = Terminal.extend({\n    initialize: function initialize(attr) {\n        Terminal.prototype.initialize.call(this, attr);\n        this.datatypes = attr.datatypes;\n        if (attr.collection_type) {\n            this.collectionType = new CollectionTypeDescription(attr.collection_type);\n        } else {\n            var collectionTypeSource = attr.collection_type_source;\n            if (!collectionTypeSource) {\n                console.log(\"Warning: No collection type or collection type source defined.\");\n            }\n            this.collectionType = ANY_COLLECTION_TYPE_DESCRIPTION;\n        }\n        this.isCollection = true;\n    },\n    update: function update(output) {\n        var newCollectionType;\n        if (output.collection_type) {\n            newCollectionType = new CollectionTypeDescription(output.collection_type);\n        } else {\n            var collectionTypeSource = output.collection_type_source;\n            if (!collectionTypeSource) {\n                console.log(\"Warning: No collection type or collection type source defined.\");\n            }\n            newCollectionType = ANY_COLLECTION_TYPE_DESCRIPTION;\n        }\n\n        if (newCollectionType.collectionType != this.collectionType.collectionType) {\n            _.each(this.connectors, function (connector) {\n                // TODO: consider checking if connection valid before removing...\n                connector.destroy();\n            });\n        }\n        this.collectionType = newCollectionType;\n    }\n});\n\nexports.default = {\n    InputTerminal: InputTerminal,\n    OutputTerminal: OutputTerminal,\n    InputCollectionTerminal: InputCollectionTerminal,\n    OutputCollectionTerminal: OutputCollectionTerminal,\n    TerminalMapping: TerminalMapping,\n\n    // test export\n    CollectionTypeDescription: CollectionTypeDescription,\n    NULL_COLLECTION_TYPE_DESCRIPTION: NULL_COLLECTION_TYPE_DESCRIPTION,\n    ANY_COLLECTION_TYPE_DESCRIPTION: ANY_COLLECTION_TYPE_DESCRIPTION\n};\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! jquery */ 0), __webpack_require__(/*! libs/backbone */ 2), __webpack_require__(/*! underscore */ 1)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjkxLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL2dhbGF4eS9zY3JpcHRzL212Yy93b3JrZmxvdy93b3JrZmxvdy10ZXJtaW5hbHMuanM/MmI3MyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBUT0RPOyB0aWUgaW50byBHYWxheHkgc3RhdGU/XG53aW5kb3cud29ya2Zsb3dfZ2xvYmFscyA9IHdpbmRvdy53b3JrZmxvd19nbG9iYWxzIHx8IHt9O1xuZnVuY3Rpb24gQ29sbGVjdGlvblR5cGVEZXNjcmlwdGlvbihjb2xsZWN0aW9uVHlwZSkge1xuICAgIHRoaXMuY29sbGVjdGlvblR5cGUgPSBjb2xsZWN0aW9uVHlwZTtcbiAgICB0aGlzLmlzQ29sbGVjdGlvbiA9IHRydWU7XG4gICAgdGhpcy5yYW5rID0gY29sbGVjdGlvblR5cGUuc3BsaXQoXCI6XCIpLmxlbmd0aDtcbn1cblxudmFyIE5VTExfQ09MTEVDVElPTl9UWVBFX0RFU0NSSVBUSU9OID0ge1xuICAgIGlzQ29sbGVjdGlvbjogZmFsc2UsXG4gICAgY2FuTWF0Y2g6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcbiAgICBjYW5NYXBPdmVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gXCJOdWxsQ29sbGVjdGlvblR5cGVbXVwiO1xuICAgIH0sXG4gICAgYXBwZW5kOiBmdW5jdGlvbihvdGhlckNvbGxlY3Rpb25UeXBlKSB7XG4gICAgICAgIHJldHVybiBvdGhlckNvbGxlY3Rpb25UeXBlO1xuICAgIH0sXG4gICAgZXF1YWw6IGZ1bmN0aW9uKG90aGVyKSB7XG4gICAgICAgIHJldHVybiBvdGhlciA9PT0gdGhpcztcbiAgICB9XG59O1xuXG52YXIgQU5ZX0NPTExFQ1RJT05fVFlQRV9ERVNDUklQVElPTiA9IHtcbiAgICBpc0NvbGxlY3Rpb246IHRydWUsXG4gICAgY2FuTWF0Y2g6IGZ1bmN0aW9uKG90aGVyKSB7XG4gICAgICAgIHJldHVybiBOVUxMX0NPTExFQ1RJT05fVFlQRV9ERVNDUklQVElPTiAhPT0gb3RoZXI7XG4gICAgfSxcbiAgICBjYW5NYXBPdmVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gXCJBbnlDb2xsZWN0aW9uVHlwZVtdXCI7XG4gICAgfSxcbiAgICBhcHBlbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aHJvdyBcIkNhbm5vdCBhcHBlbmQgdG8gQU5ZX0NPTExFQ1RJT05fVFlQRV9ERVNDUklQVElPTlwiO1xuICAgIH0sXG4gICAgZXF1YWw6IGZ1bmN0aW9uKG90aGVyKSB7XG4gICAgICAgIHJldHVybiBvdGhlciA9PT0gdGhpcztcbiAgICB9XG59O1xuXG4kLmV4dGVuZChDb2xsZWN0aW9uVHlwZURlc2NyaXB0aW9uLnByb3RvdHlwZSwge1xuICAgIGFwcGVuZDogZnVuY3Rpb24ob3RoZXJDb2xsZWN0aW9uVHlwZURlc2NyaXB0aW9uKSB7XG4gICAgICAgIGlmIChvdGhlckNvbGxlY3Rpb25UeXBlRGVzY3JpcHRpb24gPT09IE5VTExfQ09MTEVDVElPTl9UWVBFX0RFU0NSSVBUSU9OKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBpZiAob3RoZXJDb2xsZWN0aW9uVHlwZURlc2NyaXB0aW9uID09PSBBTllfQ09MTEVDVElPTl9UWVBFX0RFU0NSSVBUSU9OKSB7XG4gICAgICAgICAgICByZXR1cm4gb3RoZXJDb2xsZWN0aW9uVHlwZURlc2NyaXB0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQ29sbGVjdGlvblR5cGVEZXNjcmlwdGlvbihgJHt0aGlzLmNvbGxlY3Rpb25UeXBlfToke290aGVyQ29sbGVjdGlvblR5cGVEZXNjcmlwdGlvbi5jb2xsZWN0aW9uVHlwZX1gKTtcbiAgICB9LFxuICAgIGNhbk1hdGNoOiBmdW5jdGlvbihvdGhlckNvbGxlY3Rpb25UeXBlRGVzY3JpcHRpb24pIHtcbiAgICAgICAgaWYgKG90aGVyQ29sbGVjdGlvblR5cGVEZXNjcmlwdGlvbiA9PT0gTlVMTF9DT0xMRUNUSU9OX1RZUEVfREVTQ1JJUFRJT04pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3RoZXJDb2xsZWN0aW9uVHlwZURlc2NyaXB0aW9uID09PSBBTllfQ09MTEVDVElPTl9UWVBFX0RFU0NSSVBUSU9OKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3RoZXJDb2xsZWN0aW9uVHlwZURlc2NyaXB0aW9uLmNvbGxlY3Rpb25UeXBlID09IHRoaXMuY29sbGVjdGlvblR5cGU7XG4gICAgfSxcbiAgICBjYW5NYXBPdmVyOiBmdW5jdGlvbihvdGhlckNvbGxlY3Rpb25UeXBlRGVzY3JpcHRpb24pIHtcbiAgICAgICAgaWYgKG90aGVyQ29sbGVjdGlvblR5cGVEZXNjcmlwdGlvbiA9PT0gTlVMTF9DT0xMRUNUSU9OX1RZUEVfREVTQ1JJUFRJT04pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3RoZXJDb2xsZWN0aW9uVHlwZURlc2NyaXB0aW9uID09PSBBTllfQ09MTEVDVElPTl9UWVBFX0RFU0NSSVBUSU9OKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucmFuayA8PSBvdGhlckNvbGxlY3Rpb25UeXBlRGVzY3JpcHRpb24ucmFuaykge1xuICAgICAgICAgICAgLy8gQ2Fubm90IG1hcCBvdmVyIHNlbGYuLi5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVxdWlyZWRTdWZmaXggPSBvdGhlckNvbGxlY3Rpb25UeXBlRGVzY3JpcHRpb24uY29sbGVjdGlvblR5cGU7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbmRzV2l0aCh0aGlzLmNvbGxlY3Rpb25UeXBlLCByZXF1aXJlZFN1ZmZpeCk7XG4gICAgfSxcbiAgICBlZmZlY3RpdmVNYXBPdmVyOiBmdW5jdGlvbihvdGhlckNvbGxlY3Rpb25UeXBlRGVzY3JpcHRpb24pIHtcbiAgICAgICAgdmFyIG90aGVyQ29sbGVjdGlvblR5cGUgPSBvdGhlckNvbGxlY3Rpb25UeXBlRGVzY3JpcHRpb24uY29sbGVjdGlvblR5cGU7XG4gICAgICAgIHZhciBlZmZlY3RpdmVDb2xsZWN0aW9uVHlwZSA9IHRoaXMuY29sbGVjdGlvblR5cGUuc3Vic3RyaW5nKFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIHRoaXMuY29sbGVjdGlvblR5cGUubGVuZ3RoIC0gb3RoZXJDb2xsZWN0aW9uVHlwZS5sZW5ndGggLSAxXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBuZXcgQ29sbGVjdGlvblR5cGVEZXNjcmlwdGlvbihlZmZlY3RpdmVDb2xsZWN0aW9uVHlwZSk7XG4gICAgfSxcbiAgICBlcXVhbDogZnVuY3Rpb24ob3RoZXJDb2xsZWN0aW9uVHlwZURlc2NyaXB0aW9uKSB7XG4gICAgICAgIHJldHVybiBvdGhlckNvbGxlY3Rpb25UeXBlRGVzY3JpcHRpb24uY29sbGVjdGlvblR5cGUgPT0gdGhpcy5jb2xsZWN0aW9uVHlwZTtcbiAgICB9LFxuICAgIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGBDb2xsZWN0aW9uVHlwZVske3RoaXMuY29sbGVjdGlvblR5cGV9XWA7XG4gICAgfSxcbiAgICBfZW5kc1dpdGg6IGZ1bmN0aW9uKHN0ciwgc3VmZml4KSB7XG4gICAgICAgIHJldHVybiBzdHIuaW5kZXhPZihzdWZmaXgsIHN0ci5sZW5ndGggLSBzdWZmaXgubGVuZ3RoKSAhPT0gLTE7XG4gICAgfVxufSk7XG5cbnZhciBUZXJtaW5hbE1hcHBpbmcgPSBCYWNrYm9uZS5Nb2RlbC5leHRlbmQoe1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKGF0dHIpIHtcbiAgICAgICAgdGhpcy5tYXBPdmVyID0gYXR0ci5tYXBPdmVyIHx8IE5VTExfQ09MTEVDVElPTl9UWVBFX0RFU0NSSVBUSU9OO1xuICAgICAgICB0aGlzLnRlcm1pbmFsID0gYXR0ci50ZXJtaW5hbDtcbiAgICAgICAgdGhpcy50ZXJtaW5hbC50ZXJtaW5hbE1hcHBpbmcgPSB0aGlzO1xuICAgIH0sXG4gICAgZGlzYWJsZU1hcE92ZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnNldE1hcE92ZXIoTlVMTF9DT0xMRUNUSU9OX1RZUEVfREVTQ1JJUFRJT04pO1xuICAgIH0sXG4gICAgc2V0TWFwT3ZlcjogZnVuY3Rpb24oY29sbGVjdGlvblR5cGVEZXNjcmlwdGlvbikge1xuICAgICAgICAvLyBUT0RPOiBDYW4gSSB1c2UgXCJhdHRyaWJ1dGVzXCIgb3Igc29tZXRoaW5nIHRvIGF1dG8gdHJpZ2dlciBcImNoYW5nZVwiXG4gICAgICAgIC8vIGV2ZW50P1xuICAgICAgICB0aGlzLm1hcE92ZXIgPSBjb2xsZWN0aW9uVHlwZURlc2NyaXB0aW9uO1xuICAgICAgICB0aGlzLnRyaWdnZXIoXCJjaGFuZ2VcIik7XG4gICAgfVxufSk7XG5cbnZhciBUZXJtaW5hbCA9IEJhY2tib25lLk1vZGVsLmV4dGVuZCh7XG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oYXR0cikge1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBhdHRyLmVsZW1lbnQ7XG4gICAgICAgIHRoaXMuY29ubmVjdG9ycyA9IFtdO1xuICAgIH0sXG4gICAgY29ubmVjdDogZnVuY3Rpb24oY29ubmVjdG9yKSB7XG4gICAgICAgIHRoaXMuY29ubmVjdG9ycy5wdXNoKGNvbm5lY3Rvcik7XG4gICAgICAgIGlmICh0aGlzLm5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMubm9kZS5tYXJrQ2hhbmdlZCgpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBkaXNjb25uZWN0OiBmdW5jdGlvbihjb25uZWN0b3IpIHtcbiAgICAgICAgdGhpcy5jb25uZWN0b3JzLnNwbGljZSgkLmluQXJyYXkoY29ubmVjdG9yLCB0aGlzLmNvbm5lY3RvcnMpLCAxKTtcbiAgICAgICAgaWYgKHRoaXMubm9kZSkge1xuICAgICAgICAgICAgdGhpcy5ub2RlLm1hcmtDaGFuZ2VkKCk7XG4gICAgICAgICAgICB0aGlzLnJlc2V0TWFwcGluZ0lmTmVlZGVkKCk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHJlZHJhdzogZnVuY3Rpb24oKSB7XG4gICAgICAgICQuZWFjaCh0aGlzLmNvbm5lY3RvcnMsIChfLCBjKSA9PiB7XG4gICAgICAgICAgICBjLnJlZHJhdygpO1xuICAgICAgICB9KTtcbiAgICB9LFxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuICAgICAgICAkLmVhY2godGhpcy5jb25uZWN0b3JzLnNsaWNlKCksIChfLCBjKSA9PiB7XG4gICAgICAgICAgICBjLmRlc3Ryb3koKTtcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBkZXN0cm95SW52YWxpZENvbm5lY3Rpb25zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgXy5lYWNoKHRoaXMuY29ubmVjdG9ycywgY29ubmVjdG9yID0+IHtcbiAgICAgICAgICAgIGlmIChjb25uZWN0b3IpIHtcbiAgICAgICAgICAgICAgICBjb25uZWN0b3IuZGVzdHJveUlmSW52YWxpZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9LFxuICAgIHNldE1hcE92ZXI6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICBpZiAodGhpcy5tdWx0aXBsZSkge1xuICAgICAgICAgICAgcmV0dXJuOyAvLyBDYW5ub3Qgc2V0IHRoaXMgdG8gYmUgbXVsdGlydW4uLi5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5tYXBPdmVyKCkuZXF1YWwodmFsKSkge1xuICAgICAgICAgICAgdGhpcy50ZXJtaW5hbE1hcHBpbmcuc2V0TWFwT3Zlcih2YWwpO1xuICAgICAgICAgICAgXy5lYWNoKHRoaXMubm9kZS5vdXRwdXRfdGVybWluYWxzLCBvdXRwdXRUZXJtaW5hbCA9PiB7XG4gICAgICAgICAgICAgICAgb3V0cHV0VGVybWluYWwuc2V0TWFwT3Zlcih2YWwpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIG1hcE92ZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMudGVybWluYWxNYXBwaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gTlVMTF9DT0xMRUNUSU9OX1RZUEVfREVTQ1JJUFRJT047XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50ZXJtaW5hbE1hcHBpbmcubWFwT3ZlcjtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgaXNNYXBwZWRPdmVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGVybWluYWxNYXBwaW5nICYmIHRoaXMudGVybWluYWxNYXBwaW5nLm1hcE92ZXIuaXNDb2xsZWN0aW9uO1xuICAgIH0sXG4gICAgcmVzZXRNYXBwaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy50ZXJtaW5hbE1hcHBpbmcuZGlzYWJsZU1hcE92ZXIoKTtcbiAgICB9LFxuXG4gICAgcmVzZXRNYXBwaW5nSWZOZWVkZWQ6IGZ1bmN0aW9uKCkge30gLy8gU3ViY2xhc3NlcyBzaG91bGQgb3ZlcnJpZGUgdGhpcy4uLlxufSk7XG5cbnZhciBPdXRwdXRUZXJtaW5hbCA9IFRlcm1pbmFsLmV4dGVuZCh7XG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oYXR0cikge1xuICAgICAgICBUZXJtaW5hbC5wcm90b3R5cGUuaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIGF0dHIpO1xuICAgICAgICB0aGlzLmRhdGF0eXBlcyA9IGF0dHIuZGF0YXR5cGVzO1xuICAgIH0sXG5cbiAgICByZXNldE1hcHBpbmdJZk5lZWRlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIElmIGlucHV0cyB3ZXJlIG9ubHkgbWFwcGVkIG92ZXIgdG8gcHJlc2VydmVcbiAgICAgICAgLy8gYW4gb3V0cHV0IGp1c3QgZGlzY29ubmVjdGVkIHJlc2V0IHRoZXNlLi4uXG4gICAgICAgIGlmICghdGhpcy5ub2RlLmhhc0Nvbm5lY3RlZE91dHB1dFRlcm1pbmFscygpICYmICF0aGlzLm5vZGUuaGFzQ29ubmVjdGVkTWFwcGVkSW5wdXRUZXJtaW5hbHMoKSkge1xuICAgICAgICAgICAgXy5lYWNoKHRoaXMubm9kZS5tYXBwZWRJbnB1dFRlcm1pbmFscygpLCBtYXBwZWRJbnB1dCA9PiB7XG4gICAgICAgICAgICAgICAgbWFwcGVkSW5wdXQucmVzZXRNYXBwaW5nSWZOZWVkZWQoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG5vTWFwcGVkSW5wdXRzID0gIXRoaXMubm9kZS5oYXNNYXBwZWRPdmVySW5wdXRUZXJtaW5hbHMoKTtcbiAgICAgICAgaWYgKG5vTWFwcGVkSW5wdXRzKSB7XG4gICAgICAgICAgICB0aGlzLnJlc2V0TWFwcGluZygpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHJlc2V0TWFwcGluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMudGVybWluYWxNYXBwaW5nLmRpc2FibGVNYXBPdmVyKCk7XG4gICAgICAgIF8uZWFjaCh0aGlzLmNvbm5lY3RvcnMsIGNvbm5lY3RvciA9PiB7XG4gICAgICAgICAgICB2YXIgY29ubmVjdGVkSW5wdXQgPSBjb25uZWN0b3IuaGFuZGxlMjtcbiAgICAgICAgICAgIGlmIChjb25uZWN0ZWRJbnB1dCkge1xuICAgICAgICAgICAgICAgIC8vIE5vdCBleGFjdGx5IHJpZ2h0IGJlY2F1c2UgdGhpcyBpcyBzdGlsbCBjb25uZWN0ZWQuXG4gICAgICAgICAgICAgICAgLy8gRWl0aGVyIHJld3JpdGUgcmVzZXRNYXBwaW5nSWZOZWVkZWQgb3IgZGlzY29ubmVjdFxuICAgICAgICAgICAgICAgIC8vIGFuZCByZWNvbm5lY3QgaWYgdmFsaWQuXG4gICAgICAgICAgICAgICAgY29ubmVjdGVkSW5wdXQucmVzZXRNYXBwaW5nSWZOZWVkZWQoKTtcbiAgICAgICAgICAgICAgICBjb25uZWN0b3IuZGVzdHJveUlmSW52YWxpZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59KTtcblxudmFyIEJhc2VJbnB1dFRlcm1pbmFsID0gVGVybWluYWwuZXh0ZW5kKHtcbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihhdHRyKSB7XG4gICAgICAgIFRlcm1pbmFsLnByb3RvdHlwZS5pbml0aWFsaXplLmNhbGwodGhpcywgYXR0cik7XG4gICAgICAgIHRoaXMudXBkYXRlKGF0dHIuaW5wdXQpOyAvLyBzdWJjbGFzc2VzIHNob3VsZCBpbXBsZW1lbnQgdGhpcy4uLlxuICAgIH0sXG4gICAgY2FuQWNjZXB0OiBmdW5jdGlvbihvdGhlcikge1xuICAgICAgICBpZiAodGhpcy5faW5wdXRGaWxsZWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXR0YWNoYWJsZShvdGhlcik7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHJlc2V0TWFwcGluZ0lmTmVlZGVkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG1hcE92ZXIgPSB0aGlzLm1hcE92ZXIoKTtcbiAgICAgICAgaWYgKCFtYXBPdmVyLmlzQ29sbGVjdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vIG91dHB1dCB0ZXJtaW5hbHMgYXJlIGNvdW50aW5nIG9uIHRoaXMgYmVpbmcgbWFwcGVkXG4gICAgICAgIC8vIG92ZXIgaWYgY29ubmVjdGVkIGlucHV0cyBhcmUgc3RpbGwgbWFwcGVkIG92ZXIgb3IgaWYgbm9uZVxuICAgICAgICAvLyBvZiB0aGUgb3V0cHV0cyBhcmUgY29ubmVjdGVkLi4uXG4gICAgICAgIHZhciByZXNldCA9IHRoaXMubm9kZS5oYXNDb25uZWN0ZWRNYXBwZWRJbnB1dFRlcm1pbmFscygpIHx8ICF0aGlzLm5vZGUuaGFzQ29ubmVjdGVkT3V0cHV0VGVybWluYWxzKCk7XG4gICAgICAgIGlmIChyZXNldCkge1xuICAgICAgICAgICAgdGhpcy5yZXNldE1hcHBpbmcoKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgcmVzZXRNYXBwaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy50ZXJtaW5hbE1hcHBpbmcuZGlzYWJsZU1hcE92ZXIoKTtcbiAgICAgICAgaWYgKCF0aGlzLm5vZGUuaGFzTWFwcGVkT3ZlcklucHV0VGVybWluYWxzKCkpIHtcbiAgICAgICAgICAgIF8uZWFjaCh0aGlzLm5vZGUub3V0cHV0X3Rlcm1pbmFscywgdGVybWluYWwgPT4ge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgc2hvdWxkbid0IGJlIGNhbGxlZCBpZiB0aGVyZSBhcmUgbWFwcGVkIG92ZXJcbiAgICAgICAgICAgICAgICAvLyBvdXRwdXRzLlxuICAgICAgICAgICAgICAgIHRlcm1pbmFsLnJlc2V0TWFwcGluZygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGNvbm5lY3RlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbm5lY3RvcnMubGVuZ3RoICE9PSAwO1xuICAgIH0sXG4gICAgX2lucHV0RmlsbGVkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGlucHV0RmlsbGVkO1xuICAgICAgICBpZiAoIXRoaXMuY29ubmVjdGVkKCkpIHtcbiAgICAgICAgICAgIGlucHV0RmlsbGVkID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5tdWx0aXBsZSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9jb2xsZWN0aW9uQXR0YWNoZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBDYW4gb25seSBhdHRhY2ggb25lIGNvbGxlY3Rpb24gdG8gbXVsdGlwbGUgaW5wdXRcbiAgICAgICAgICAgICAgICAgICAgLy8gZGF0YSBwYXJhbWV0ZXIuXG4gICAgICAgICAgICAgICAgICAgIGlucHV0RmlsbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpbnB1dEZpbGxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaW5wdXRGaWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbnB1dEZpbGxlZDtcbiAgICB9LFxuICAgIF9jb2xsZWN0aW9uQXR0YWNoZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuY29ubmVjdGVkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBmaXJzdE91dHB1dCA9IHRoaXMuY29ubmVjdG9yc1swXS5oYW5kbGUxO1xuICAgICAgICAgICAgaWYgKCFmaXJzdE91dHB1dCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICBmaXJzdE91dHB1dC5pc0NvbGxlY3Rpb24gfHxcbiAgICAgICAgICAgICAgICAgICAgZmlyc3RPdXRwdXQuaXNNYXBwZWRPdmVyKCkgfHxcbiAgICAgICAgICAgICAgICAgICAgZmlyc3RPdXRwdXQuZGF0YXR5cGVzLmluZGV4T2YoXCJpbnB1dF9jb2xsZWN0aW9uXCIpID4gMFxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICBfbWFwcGluZ0NvbnN0cmFpbnRzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gSWYgdGhpcyBpcyBhIGNvbm5lY3RlZCB0ZXJtaW5hbCwgcmV0dXJuIGxpc3Qgb2YgY29sbGVjdGlvbiB0eXBlc1xuICAgICAgICAvLyBvdGhlciB0ZXJtaW5hbHMgY29ubmVjdGVkIHRvIG5vZGUgYXJlIGNvbnN0cmFpbmluZyBtYXBwaW5nIHRvLlxuICAgICAgICBpZiAoIXRoaXMubm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIFtdOyAvLyBObyBub2RlIC0gY29tcGxldGVseSB1bmNvbnN0cmFpbmVkXG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1hcE92ZXIgPSB0aGlzLm1hcE92ZXIoKTtcbiAgICAgICAgaWYgKG1hcE92ZXIuaXNDb2xsZWN0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gW21hcE92ZXJdO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNvbnN0cmFpbnRzID0gW107XG4gICAgICAgIGlmICghdGhpcy5ub2RlLmhhc0Nvbm5lY3RlZE91dHB1dFRlcm1pbmFscygpKSB7XG4gICAgICAgICAgICBfLmVhY2godGhpcy5ub2RlLmNvbm5lY3RlZE1hcHBlZElucHV0VGVybWluYWxzKCksIGlucHV0VGVybWluYWwgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0cmFpbnRzLnB1c2goaW5wdXRUZXJtaW5hbC5tYXBPdmVyKCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBBbGwgb3V0cHV0cyBzaG91bGQgaGF2ZSBzYW1lIG1hcE92ZXIgc3RhdHVzIC0gbGVhc3Qgc3BlY2lmaWMuXG4gICAgICAgICAgICBjb25zdHJhaW50cy5wdXNoKF8uZmlyc3QoXy52YWx1ZXModGhpcy5ub2RlLm91dHB1dF90ZXJtaW5hbHMpKS5tYXBPdmVyKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb25zdHJhaW50cztcbiAgICB9LFxuICAgIF9wcm9kdWNlc0FjY2VwdGFibGVEYXRhdHlwZTogZnVuY3Rpb24ob3RoZXIpIHtcbiAgICAgICAgLy8gb3RoZXIgaXMgYSBub24tY29sbGVjdGlvbiBvdXRwdXQuLi5cbiAgICAgICAgZm9yICh2YXIgdCBpbiB0aGlzLmRhdGF0eXBlcykge1xuICAgICAgICAgICAgdmFyIHRoaXNEYXRhdHlwZSA9IHRoaXMuZGF0YXR5cGVzW3RdO1xuICAgICAgICAgICAgaWYgKHRoaXNEYXRhdHlwZSA9PSBcImlucHV0XCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjYXRfb3V0cHV0cyA9IFtdO1xuICAgICAgICAgICAgY2F0X291dHB1dHMgPSBjYXRfb3V0cHV0cy5jb25jYXQob3RoZXIuZGF0YXR5cGVzKTtcbiAgICAgICAgICAgIGlmIChvdGhlci5ub2RlLnBvc3Rfam9iX2FjdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBwamFfaSBpbiBvdGhlci5ub2RlLnBvc3Rfam9iX2FjdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBqYSA9IG90aGVyLm5vZGUucG9zdF9qb2JfYWN0aW9uc1twamFfaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgIHBqYS5hY3Rpb25fdHlwZSA9PSBcIkNoYW5nZURhdGF0eXBlQWN0aW9uXCIgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIChwamEub3V0cHV0X25hbWUgPT09IFwiXCIgfHwgcGphLm91dHB1dF9uYW1lID09IG90aGVyLm5hbWUpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBwamEuYWN0aW9uX2FyZ3VtZW50c1xuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdF9vdXRwdXRzLnB1c2gocGphLmFjdGlvbl9hcmd1bWVudHMubmV3dHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBGSVhNRTogTm8gaWRlYSB3aGF0IHRvIGRvIGFib3V0IGNhc2Ugd2hlbiBkYXRhdHlwZSBpcyAnaW5wdXQnXG4gICAgICAgICAgICBmb3IgKHZhciBvdGhlcl9kYXRhdHlwZV9pIGluIGNhdF9vdXRwdXRzKSB7XG4gICAgICAgICAgICAgICAgdmFyIG90aGVyX2RhdGF0eXBlID0gY2F0X291dHB1dHNbb3RoZXJfZGF0YXR5cGVfaV07XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICBvdGhlcl9kYXRhdHlwZSA9PSBcImlucHV0XCIgfHxcbiAgICAgICAgICAgICAgICAgICAgb3RoZXJfZGF0YXR5cGUgPT0gXCJfc25pZmZfXCIgfHxcbiAgICAgICAgICAgICAgICAgICAgb3RoZXJfZGF0YXR5cGUgPT0gXCJpbnB1dF9jb2xsZWN0aW9uXCIgfHxcbiAgICAgICAgICAgICAgICAgICAgd2luZG93LndvcmtmbG93X2dsb2JhbHMuYXBwLmlzU3ViVHlwZShjYXRfb3V0cHV0c1tvdGhlcl9kYXRhdHlwZV9pXSwgdGhpc0RhdGF0eXBlKVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgX290aGVyQ29sbGVjdGlvblR5cGU6IGZ1bmN0aW9uKG90aGVyKSB7XG4gICAgICAgIHZhciBvdGhlckNvbGxlY3Rpb25UeXBlID0gTlVMTF9DT0xMRUNUSU9OX1RZUEVfREVTQ1JJUFRJT047XG4gICAgICAgIGlmIChvdGhlci5pc0NvbGxlY3Rpb24pIHtcbiAgICAgICAgICAgIG90aGVyQ29sbGVjdGlvblR5cGUgPSBvdGhlci5jb2xsZWN0aW9uVHlwZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb3RoZXJNYXBPdmVyID0gb3RoZXIubWFwT3ZlcigpO1xuICAgICAgICBpZiAob3RoZXJNYXBPdmVyLmlzQ29sbGVjdGlvbikge1xuICAgICAgICAgICAgb3RoZXJDb2xsZWN0aW9uVHlwZSA9IG90aGVyTWFwT3Zlci5hcHBlbmQob3RoZXJDb2xsZWN0aW9uVHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG90aGVyQ29sbGVjdGlvblR5cGU7XG4gICAgfVxufSk7XG5cbnZhciBJbnB1dFRlcm1pbmFsID0gQmFzZUlucHV0VGVybWluYWwuZXh0ZW5kKHtcbiAgICB1cGRhdGU6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHRoaXMuZGF0YXR5cGVzID0gaW5wdXQuZXh0ZW5zaW9ucztcbiAgICAgICAgdGhpcy5tdWx0aXBsZSA9IGlucHV0Lm11bHRpcGxlO1xuICAgICAgICB0aGlzLmNvbGxlY3Rpb24gPSBmYWxzZTtcbiAgICB9LFxuICAgIGNvbm5lY3Q6IGZ1bmN0aW9uKGNvbm5lY3Rvcikge1xuICAgICAgICBCYXNlSW5wdXRUZXJtaW5hbC5wcm90b3R5cGUuY29ubmVjdC5jYWxsKHRoaXMsIGNvbm5lY3Rvcik7XG4gICAgICAgIHZhciBvdGhlcl9vdXRwdXQgPSBjb25uZWN0b3IuaGFuZGxlMTtcbiAgICAgICAgaWYgKCFvdGhlcl9vdXRwdXQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb3RoZXJDb2xsZWN0aW9uVHlwZSA9IHRoaXMuX290aGVyQ29sbGVjdGlvblR5cGUob3RoZXJfb3V0cHV0KTtcbiAgICAgICAgaWYgKG90aGVyQ29sbGVjdGlvblR5cGUuaXNDb2xsZWN0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnNldE1hcE92ZXIob3RoZXJDb2xsZWN0aW9uVHlwZSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGF0dGFjaGFibGU6IGZ1bmN0aW9uKG90aGVyKSB7XG4gICAgICAgIHZhciBvdGhlckNvbGxlY3Rpb25UeXBlID0gdGhpcy5fb3RoZXJDb2xsZWN0aW9uVHlwZShvdGhlcik7XG4gICAgICAgIHZhciB0aGlzTWFwT3ZlciA9IHRoaXMubWFwT3ZlcigpO1xuICAgICAgICBpZiAob3RoZXJDb2xsZWN0aW9uVHlwZS5pc0NvbGxlY3Rpb24pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm11bHRpcGxlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY29ubmVjdGVkKCkgJiYgIXRoaXMuX2NvbGxlY3Rpb25BdHRhY2hlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHNpbmdsZSBpbnB1dHMgYXR0YWNoZWQsIGNhbm5vdCBhbHNvIGF0dGFjaCBhXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbGxlY3Rpb24gKHlldC4uLilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAob3RoZXJDb2xsZWN0aW9uVHlwZS5yYW5rID09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Byb2R1Y2VzQWNjZXB0YWJsZURhdGF0eXBlKG90aGVyKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBBbGxvdyBzdWJjb2xsZWN0aW9uIG1hcHBpbmcgb3ZlciB0aGlzIGFzIGlmIGl0IHdlcmVcbiAgICAgICAgICAgICAgICAgICAgLy8gYSBsaXN0IGNvbGxlY3Rpb24gaW5wdXQuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpc01hcE92ZXIuaXNDb2xsZWN0aW9uICYmIHRoaXNNYXBPdmVyLmNhbk1hdGNoKG90aGVyQ29sbGVjdGlvblR5cGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Byb2R1Y2VzQWNjZXB0YWJsZURhdGF0eXBlKG90aGVyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gIE5lZWQgdG8gY2hlY2sgaWYgdGhpcyB3b3VsZCBicmVhayBjb25zdHJhaW50cy4uLlxuICAgICAgICAgICAgICAgIHZhciBtYXBwaW5nQ29uc3RyYWludHMgPSB0aGlzLl9tYXBwaW5nQ29uc3RyYWludHMoKTtcbiAgICAgICAgICAgICAgICBpZiAobWFwcGluZ0NvbnN0cmFpbnRzLmV2ZXJ5KF8uYmluZChvdGhlckNvbGxlY3Rpb25UeXBlLmNhbk1hdGNoLCBvdGhlckNvbGxlY3Rpb25UeXBlKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Byb2R1Y2VzQWNjZXB0YWJsZURhdGF0eXBlKG90aGVyKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXNNYXBPdmVyLmlzQ29sbGVjdGlvbikge1xuICAgICAgICAgICAgLy8gQXR0ZW1wdGluZyB0byBtYXRjaCBhIG5vbi1jb2xsZWN0aW9uIG91dHB1dCB0byBhblxuICAgICAgICAgICAgLy8gZXhwbGljaXRseSBjb2xsZWN0aW9uIGlucHV0LlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9wcm9kdWNlc0FjY2VwdGFibGVEYXRhdHlwZShvdGhlcik7XG4gICAgfVxufSk7XG5cbnZhciBJbnB1dENvbGxlY3Rpb25UZXJtaW5hbCA9IEJhc2VJbnB1dFRlcm1pbmFsLmV4dGVuZCh7XG4gICAgdXBkYXRlOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICB0aGlzLm11bHRpcGxlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY29sbGVjdGlvbiA9IHRydWU7XG4gICAgICAgIHRoaXMuZGF0YXR5cGVzID0gaW5wdXQuZXh0ZW5zaW9ucztcbiAgICAgICAgdmFyIGNvbGxlY3Rpb25UeXBlcyA9IFtdO1xuICAgICAgICBpZiAoaW5wdXQuY29sbGVjdGlvbl90eXBlcykge1xuICAgICAgICAgICAgXy5lYWNoKGlucHV0LmNvbGxlY3Rpb25fdHlwZXMsIGNvbGxlY3Rpb25UeXBlID0+IHtcbiAgICAgICAgICAgICAgICBjb2xsZWN0aW9uVHlwZXMucHVzaChuZXcgQ29sbGVjdGlvblR5cGVEZXNjcmlwdGlvbihjb2xsZWN0aW9uVHlwZSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb2xsZWN0aW9uVHlwZXMucHVzaChBTllfQ09MTEVDVElPTl9UWVBFX0RFU0NSSVBUSU9OKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbGxlY3Rpb25UeXBlcyA9IGNvbGxlY3Rpb25UeXBlcztcbiAgICB9LFxuICAgIGNvbm5lY3Q6IGZ1bmN0aW9uKGNvbm5lY3Rvcikge1xuICAgICAgICBCYXNlSW5wdXRUZXJtaW5hbC5wcm90b3R5cGUuY29ubmVjdC5jYWxsKHRoaXMsIGNvbm5lY3Rvcik7XG4gICAgICAgIHZhciBvdGhlciA9IGNvbm5lY3Rvci5oYW5kbGUxO1xuICAgICAgICBpZiAoIW90aGVyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZWZmZWN0aXZlTWFwT3ZlciA9IHRoaXMuX2VmZmVjdGl2ZU1hcE92ZXIob3RoZXIpO1xuICAgICAgICB0aGlzLnNldE1hcE92ZXIoZWZmZWN0aXZlTWFwT3Zlcik7XG4gICAgfSxcbiAgICBfZWZmZWN0aXZlTWFwT3ZlcjogZnVuY3Rpb24ob3RoZXIpIHtcbiAgICAgICAgdmFyIGNvbGxlY3Rpb25UeXBlcyA9IHRoaXMuY29sbGVjdGlvblR5cGVzO1xuICAgICAgICB2YXIgb3RoZXJDb2xsZWN0aW9uVHlwZSA9IHRoaXMuX290aGVyQ29sbGVjdGlvblR5cGUob3RoZXIpO1xuICAgICAgICB2YXIgY2FuTWF0Y2ggPSBfLnNvbWUoY29sbGVjdGlvblR5cGVzLCBjb2xsZWN0aW9uVHlwZSA9PiBjb2xsZWN0aW9uVHlwZS5jYW5NYXRjaChvdGhlckNvbGxlY3Rpb25UeXBlKSk7XG5cbiAgICAgICAgaWYgKCFjYW5NYXRjaCkge1xuICAgICAgICAgICAgZm9yICh2YXIgY29sbGVjdGlvblR5cGVJbmRleCBpbiBjb2xsZWN0aW9uVHlwZXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29sbGVjdGlvblR5cGUgPSBjb2xsZWN0aW9uVHlwZXNbY29sbGVjdGlvblR5cGVJbmRleF07XG4gICAgICAgICAgICAgICAgaWYgKG90aGVyQ29sbGVjdGlvblR5cGUuY2FuTWFwT3Zlcihjb2xsZWN0aW9uVHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVmZmVjdGl2ZU1hcE92ZXIgPSBvdGhlckNvbGxlY3Rpb25UeXBlLmVmZmVjdGl2ZU1hcE92ZXIoY29sbGVjdGlvblR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZWZmZWN0aXZlTWFwT3ZlciAhPSBOVUxMX0NPTExFQ1RJT05fVFlQRV9ERVNDUklQVElPTikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVmZmVjdGl2ZU1hcE92ZXI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE5VTExfQ09MTEVDVElPTl9UWVBFX0RFU0NSSVBUSU9OO1xuICAgIH0sXG4gICAgX2VmZmVjdGl2ZUNvbGxlY3Rpb25UeXBlczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB0aGlzTWFwT3ZlciA9IHRoaXMubWFwT3ZlcigpO1xuICAgICAgICByZXR1cm4gXy5tYXAodGhpcy5jb2xsZWN0aW9uVHlwZXMsIHQgPT4gdGhpc01hcE92ZXIuYXBwZW5kKHQpKTtcbiAgICB9LFxuICAgIGF0dGFjaGFibGU6IGZ1bmN0aW9uKG90aGVyKSB7XG4gICAgICAgIHZhciBvdGhlckNvbGxlY3Rpb25UeXBlID0gdGhpcy5fb3RoZXJDb2xsZWN0aW9uVHlwZShvdGhlcik7XG4gICAgICAgIGlmIChvdGhlckNvbGxlY3Rpb25UeXBlLmlzQ29sbGVjdGlvbikge1xuICAgICAgICAgICAgdmFyIGVmZmVjdGl2ZUNvbGxlY3Rpb25UeXBlcyA9IHRoaXMuX2VmZmVjdGl2ZUNvbGxlY3Rpb25UeXBlcygpO1xuICAgICAgICAgICAgdmFyIHRoaXNNYXBPdmVyID0gdGhpcy5tYXBPdmVyKCk7XG4gICAgICAgICAgICB2YXIgY2FuTWF0Y2ggPSBfLnNvbWUoZWZmZWN0aXZlQ29sbGVjdGlvblR5cGVzLCBlZmZlY3RpdmVDb2xsZWN0aW9uVHlwZSA9PlxuICAgICAgICAgICAgICAgIGVmZmVjdGl2ZUNvbGxlY3Rpb25UeXBlLmNhbk1hdGNoKG90aGVyQ29sbGVjdGlvblR5cGUpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKGNhbk1hdGNoKSB7XG4gICAgICAgICAgICAgICAgLy8gT25seSB3YXkgYSBkaXJlY3QgbWF0Y2guLi5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcHJvZHVjZXNBY2NlcHRhYmxlRGF0YXR5cGUob3RoZXIpO1xuICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSB3ZSBuZWVkIHRvIG1hcE92ZXJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpc01hcE92ZXIuaXNDb2xsZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgLy8gSW4gdGhpcyBjYXNlLCBtYXBPdmVyIGFscmVhZHkgc2V0IGFuZCB3ZSBkaWRuJ3QgbWF0Y2ggc2tpcHBpbmcuLi5cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKF8uc29tZSh0aGlzLmNvbGxlY3Rpb25UeXBlcywgY29sbGVjdGlvblR5cGUgPT4gb3RoZXJDb2xsZWN0aW9uVHlwZS5jYW5NYXBPdmVyKGNvbGxlY3Rpb25UeXBlKSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZWZmZWN0aXZlTWFwT3ZlciA9IHRoaXMuX2VmZmVjdGl2ZU1hcE92ZXIob3RoZXIpO1xuICAgICAgICAgICAgICAgIGlmICghZWZmZWN0aXZlTWFwT3Zlci5pc0NvbGxlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyAgTmVlZCB0byBjaGVjayBpZiB0aGlzIHdvdWxkIGJyZWFrIGNvbnN0cmFpbnRzLi4uXG4gICAgICAgICAgICAgICAgdmFyIG1hcHBpbmdDb25zdHJhaW50cyA9IHRoaXMuX21hcHBpbmdDb25zdHJhaW50cygpO1xuICAgICAgICAgICAgICAgIGlmIChtYXBwaW5nQ29uc3RyYWludHMuZXZlcnkoZWZmZWN0aXZlTWFwT3Zlci5jYW5NYXRjaCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Byb2R1Y2VzQWNjZXB0YWJsZURhdGF0eXBlKG90aGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn0pO1xuXG52YXIgT3V0cHV0Q29sbGVjdGlvblRlcm1pbmFsID0gVGVybWluYWwuZXh0ZW5kKHtcbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihhdHRyKSB7XG4gICAgICAgIFRlcm1pbmFsLnByb3RvdHlwZS5pbml0aWFsaXplLmNhbGwodGhpcywgYXR0cik7XG4gICAgICAgIHRoaXMuZGF0YXR5cGVzID0gYXR0ci5kYXRhdHlwZXM7XG4gICAgICAgIGlmIChhdHRyLmNvbGxlY3Rpb25fdHlwZSkge1xuICAgICAgICAgICAgdGhpcy5jb2xsZWN0aW9uVHlwZSA9IG5ldyBDb2xsZWN0aW9uVHlwZURlc2NyaXB0aW9uKGF0dHIuY29sbGVjdGlvbl90eXBlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBjb2xsZWN0aW9uVHlwZVNvdXJjZSA9IGF0dHIuY29sbGVjdGlvbl90eXBlX3NvdXJjZTtcbiAgICAgICAgICAgIGlmICghY29sbGVjdGlvblR5cGVTb3VyY2UpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIldhcm5pbmc6IE5vIGNvbGxlY3Rpb24gdHlwZSBvciBjb2xsZWN0aW9uIHR5cGUgc291cmNlIGRlZmluZWQuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jb2xsZWN0aW9uVHlwZSA9IEFOWV9DT0xMRUNUSU9OX1RZUEVfREVTQ1JJUFRJT047XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc0NvbGxlY3Rpb24gPSB0cnVlO1xuICAgIH0sXG4gICAgdXBkYXRlOiBmdW5jdGlvbihvdXRwdXQpIHtcbiAgICAgICAgdmFyIG5ld0NvbGxlY3Rpb25UeXBlO1xuICAgICAgICBpZiAob3V0cHV0LmNvbGxlY3Rpb25fdHlwZSkge1xuICAgICAgICAgICAgbmV3Q29sbGVjdGlvblR5cGUgPSBuZXcgQ29sbGVjdGlvblR5cGVEZXNjcmlwdGlvbihvdXRwdXQuY29sbGVjdGlvbl90eXBlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBjb2xsZWN0aW9uVHlwZVNvdXJjZSA9IG91dHB1dC5jb2xsZWN0aW9uX3R5cGVfc291cmNlO1xuICAgICAgICAgICAgaWYgKCFjb2xsZWN0aW9uVHlwZVNvdXJjZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiV2FybmluZzogTm8gY29sbGVjdGlvbiB0eXBlIG9yIGNvbGxlY3Rpb24gdHlwZSBzb3VyY2UgZGVmaW5lZC5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXdDb2xsZWN0aW9uVHlwZSA9IEFOWV9DT0xMRUNUSU9OX1RZUEVfREVTQ1JJUFRJT047XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobmV3Q29sbGVjdGlvblR5cGUuY29sbGVjdGlvblR5cGUgIT0gdGhpcy5jb2xsZWN0aW9uVHlwZS5jb2xsZWN0aW9uVHlwZSkge1xuICAgICAgICAgICAgXy5lYWNoKHRoaXMuY29ubmVjdG9ycywgY29ubmVjdG9yID0+IHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBjb25zaWRlciBjaGVja2luZyBpZiBjb25uZWN0aW9uIHZhbGlkIGJlZm9yZSByZW1vdmluZy4uLlxuICAgICAgICAgICAgICAgIGNvbm5lY3Rvci5kZXN0cm95KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbGxlY3Rpb25UeXBlID0gbmV3Q29sbGVjdGlvblR5cGU7XG4gICAgfVxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgICBJbnB1dFRlcm1pbmFsOiBJbnB1dFRlcm1pbmFsLFxuICAgIE91dHB1dFRlcm1pbmFsOiBPdXRwdXRUZXJtaW5hbCxcbiAgICBJbnB1dENvbGxlY3Rpb25UZXJtaW5hbDogSW5wdXRDb2xsZWN0aW9uVGVybWluYWwsXG4gICAgT3V0cHV0Q29sbGVjdGlvblRlcm1pbmFsOiBPdXRwdXRDb2xsZWN0aW9uVGVybWluYWwsXG4gICAgVGVybWluYWxNYXBwaW5nOiBUZXJtaW5hbE1hcHBpbmcsXG5cbiAgICAvLyB0ZXN0IGV4cG9ydFxuICAgIENvbGxlY3Rpb25UeXBlRGVzY3JpcHRpb246IENvbGxlY3Rpb25UeXBlRGVzY3JpcHRpb24sXG4gICAgTlVMTF9DT0xMRUNUSU9OX1RZUEVfREVTQ1JJUFRJT046IE5VTExfQ09MTEVDVElPTl9UWVBFX0RFU0NSSVBUSU9OLFxuICAgIEFOWV9DT0xMRUNUSU9OX1RZUEVfREVTQ1JJUFRJT046IEFOWV9DT0xMRUNUSU9OX1RZUEVfREVTQ1JJUFRJT05cbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gZ2FsYXh5L3NjcmlwdHMvbXZjL3dvcmtmbG93L3dvcmtmbG93LXRlcm1pbmFscy5qcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWhCQTtBQUNBO0FBa0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFoQkE7QUFDQTtBQWtCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBakRBO0FBQ0E7QUFtREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBZEE7QUFDQTtBQWdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBN0RBO0FBQ0E7QUErREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFqQ0E7QUFDQTtBQW1DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWpKQTtBQUNBO0FBbUpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFwREE7QUFDQTtBQXNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQTNFQTtBQUNBO0FBNkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFsQ0E7QUFDQTtBQW9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVkE7QSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///291\n");

/***/ }),

/***/ 292:
/*!***********************************************************!*\
  !*** ./galaxy/scripts/mvc/workflow/workflow-view-data.js ***!
  \***********************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(Backbone, $) {\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n// TODO; tie into Galaxy state?\nwindow.workflow_globals = window.workflow_globals || {};\n\nvar DataInputView = Backbone.View.extend({\n    className: \"form-row dataRow input-data-row\",\n\n    initialize: function initialize(options) {\n        this.input = options.input;\n        this.nodeView = options.nodeView;\n        this.terminalElement = options.terminalElement;\n\n        this.$el.attr(\"name\", this.input.name).html(this.input.label);\n\n        if (!options.skipResize) {\n            this.$el.css({\n                position: \"absolute\",\n                left: -1000,\n                top: -1000,\n                display: \"none\"\n            });\n            $(\"body\").append(this.el);\n            this.nodeView.updateMaxWidth(this.$el.outerWidth());\n            this.$el.css({\n                position: \"\",\n                left: \"\",\n                top: \"\",\n                display: \"\"\n            });\n            this.$el.remove();\n        }\n    }\n});\n\nvar DataOutputView = Backbone.View.extend({\n    className: \"form-row dataRow\",\n\n    initialize: function initialize(options) {\n        this.output = options.output;\n        this.terminalElement = options.terminalElement;\n        this.nodeView = options.nodeView;\n\n        var output = this.output;\n        var label = output.name;\n        var node = this.nodeView.node;\n\n        var isInput = output.extensions.indexOf(\"input\") >= 0 || output.extensions.indexOf(\"input_collection\") >= 0;\n        if (!isInput) {\n            label = label + \" (\" + output.extensions.join(\", \") + \")\";\n        }\n        this.$el.html(label);\n        this.calloutView = null;\n        if ([\"tool\", \"subworkflow\"].indexOf(node.type) >= 0) {\n            var calloutView = new OutputCalloutView({\n                label: label,\n                output: output,\n                node: node\n            });\n            this.calloutView = calloutView;\n            this.$el.append(calloutView.el);\n            this.$el.hover(function () {\n                calloutView.hoverImage();\n            }, function () {\n                calloutView.resetImage();\n            });\n        }\n        this.$el.css({\n            position: \"absolute\",\n            left: -1000,\n            top: -1000,\n            display: \"none\"\n        });\n        $(\"body\").append(this.el);\n        this.nodeView.updateMaxWidth(this.$el.outerWidth() + 17);\n        this.$el.css({\n            position: \"\",\n            left: \"\",\n            top: \"\",\n            display: \"\"\n        }).detach();\n    },\n    redrawWorkflowOutput: function redrawWorkflowOutput() {\n        if (this.calloutView) {\n            this.calloutView.resetImage();\n        }\n    }\n});\n\nvar OutputCalloutView = Backbone.View.extend({\n    tagName: \"div\",\n\n    initialize: function initialize(options) {\n        this.label = options.label;\n        this.node = options.node;\n        this.output = options.output;\n\n        var view = this;\n        var node = this.node;\n        this.$el.attr(\"class\", \"callout \" + this.label).css({ display: \"none\" }).append($(\"<div class='buttons'></div>\").append($(\"<img/>\").attr(\"src\", Galaxy.root + \"static/images/fugue/asterisk-small-outline.png\").click(function () {\n            var outputName = view.output.name;\n            if (node.isWorkflowOutput(outputName)) {\n                node.removeWorkflowOutput(outputName);\n                view.$(\"img\").attr(\"src\", Galaxy.root + \"static/images/fugue/asterisk-small-outline.png\");\n            } else {\n                node.addWorkflowOutput(outputName);\n                view.$(\"img\").attr(\"src\", Galaxy.root + \"static/images/fugue/asterisk-small.png\");\n            }\n            window.workflow_globals.workflow.has_changes = true;\n            window.workflow_globals.canvas_manager.draw_overview();\n        }))).tooltip({\n            delay: 500,\n            title: \"Mark dataset as a workflow output. All unmarked datasets will be hidden.\"\n        });\n\n        this.$el.css({\n            top: \"50%\",\n            margin: \"-8px 0px 0px 0px\",\n            right: 8\n        });\n        this.$el.show();\n        this.resetImage();\n    },\n\n    resetImage: function resetImage() {\n        if (!this.node.isWorkflowOutput(this.output.name)) {\n            this.$(\"img\").attr(\"src\", Galaxy.root + \"static/images/fugue/asterisk-small-outline.png\");\n        } else {\n            this.$(\"img\").attr(\"src\", Galaxy.root + \"static/images/fugue/asterisk-small.png\");\n        }\n    },\n\n    hoverImage: function hoverImage() {\n        this.$(\"img\").attr(\"src\", Galaxy.root + \"static/images/fugue/asterisk-small-yellow.png\");\n    }\n});\n\nexports.default = {\n    DataInputView: DataInputView,\n    DataOutputView: DataOutputView\n};\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! libs/backbone */ 2), __webpack_require__(/*! jquery */ 0)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjkyLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL2dhbGF4eS9zY3JpcHRzL212Yy93b3JrZmxvdy93b3JrZmxvdy12aWV3LWRhdGEuanM/MWM1NyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBUT0RPOyB0aWUgaW50byBHYWxheHkgc3RhdGU/XG53aW5kb3cud29ya2Zsb3dfZ2xvYmFscyA9IHdpbmRvdy53b3JrZmxvd19nbG9iYWxzIHx8IHt9O1xuXG52YXIgRGF0YUlucHV0VmlldyA9IEJhY2tib25lLlZpZXcuZXh0ZW5kKHtcbiAgICBjbGFzc05hbWU6IFwiZm9ybS1yb3cgZGF0YVJvdyBpbnB1dC1kYXRhLXJvd1wiLFxuXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICB0aGlzLmlucHV0ID0gb3B0aW9ucy5pbnB1dDtcbiAgICAgICAgdGhpcy5ub2RlVmlldyA9IG9wdGlvbnMubm9kZVZpZXc7XG4gICAgICAgIHRoaXMudGVybWluYWxFbGVtZW50ID0gb3B0aW9ucy50ZXJtaW5hbEVsZW1lbnQ7XG5cbiAgICAgICAgdGhpcy4kZWwuYXR0cihcIm5hbWVcIiwgdGhpcy5pbnB1dC5uYW1lKS5odG1sKHRoaXMuaW5wdXQubGFiZWwpO1xuXG4gICAgICAgIGlmICghb3B0aW9ucy5za2lwUmVzaXplKSB7XG4gICAgICAgICAgICB0aGlzLiRlbC5jc3Moe1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG4gICAgICAgICAgICAgICAgbGVmdDogLTEwMDAsXG4gICAgICAgICAgICAgICAgdG9wOiAtMTAwMCxcbiAgICAgICAgICAgICAgICBkaXNwbGF5OiBcIm5vbmVcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAkKFwiYm9keVwiKS5hcHBlbmQodGhpcy5lbCk7XG4gICAgICAgICAgICB0aGlzLm5vZGVWaWV3LnVwZGF0ZU1heFdpZHRoKHRoaXMuJGVsLm91dGVyV2lkdGgoKSk7XG4gICAgICAgICAgICB0aGlzLiRlbC5jc3Moe1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBcIlwiLFxuICAgICAgICAgICAgICAgIGxlZnQ6IFwiXCIsXG4gICAgICAgICAgICAgICAgdG9wOiBcIlwiLFxuICAgICAgICAgICAgICAgIGRpc3BsYXk6IFwiXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy4kZWwucmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxudmFyIERhdGFPdXRwdXRWaWV3ID0gQmFja2JvbmUuVmlldy5leHRlbmQoe1xuICAgIGNsYXNzTmFtZTogXCJmb3JtLXJvdyBkYXRhUm93XCIsXG5cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHRoaXMub3V0cHV0ID0gb3B0aW9ucy5vdXRwdXQ7XG4gICAgICAgIHRoaXMudGVybWluYWxFbGVtZW50ID0gb3B0aW9ucy50ZXJtaW5hbEVsZW1lbnQ7XG4gICAgICAgIHRoaXMubm9kZVZpZXcgPSBvcHRpb25zLm5vZGVWaWV3O1xuXG4gICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLm91dHB1dDtcbiAgICAgICAgdmFyIGxhYmVsID0gb3V0cHV0Lm5hbWU7XG4gICAgICAgIHZhciBub2RlID0gdGhpcy5ub2RlVmlldy5ub2RlO1xuXG4gICAgICAgIHZhciBpc0lucHV0ID0gb3V0cHV0LmV4dGVuc2lvbnMuaW5kZXhPZihcImlucHV0XCIpID49IDAgfHwgb3V0cHV0LmV4dGVuc2lvbnMuaW5kZXhPZihcImlucHV0X2NvbGxlY3Rpb25cIikgPj0gMDtcbiAgICAgICAgaWYgKCFpc0lucHV0KSB7XG4gICAgICAgICAgICBsYWJlbCA9IGAke2xhYmVsfSAoJHtvdXRwdXQuZXh0ZW5zaW9ucy5qb2luKFwiLCBcIil9KWA7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4kZWwuaHRtbChsYWJlbCk7XG4gICAgICAgIHRoaXMuY2FsbG91dFZpZXcgPSBudWxsO1xuICAgICAgICBpZiAoW1widG9vbFwiLCBcInN1YndvcmtmbG93XCJdLmluZGV4T2Yobm9kZS50eXBlKSA+PSAwKSB7XG4gICAgICAgICAgICB2YXIgY2FsbG91dFZpZXcgPSBuZXcgT3V0cHV0Q2FsbG91dFZpZXcoe1xuICAgICAgICAgICAgICAgIGxhYmVsOiBsYWJlbCxcbiAgICAgICAgICAgICAgICBvdXRwdXQ6IG91dHB1dCxcbiAgICAgICAgICAgICAgICBub2RlOiBub2RlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuY2FsbG91dFZpZXcgPSBjYWxsb3V0VmlldztcbiAgICAgICAgICAgIHRoaXMuJGVsLmFwcGVuZChjYWxsb3V0Vmlldy5lbCk7XG4gICAgICAgICAgICB0aGlzLiRlbC5ob3ZlcihcbiAgICAgICAgICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxvdXRWaWV3LmhvdmVySW1hZ2UoKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbG91dFZpZXcucmVzZXRJbWFnZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4kZWwuY3NzKHtcbiAgICAgICAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG4gICAgICAgICAgICBsZWZ0OiAtMTAwMCxcbiAgICAgICAgICAgIHRvcDogLTEwMDAsXG4gICAgICAgICAgICBkaXNwbGF5OiBcIm5vbmVcIlxuICAgICAgICB9KTtcbiAgICAgICAgJChcImJvZHlcIikuYXBwZW5kKHRoaXMuZWwpO1xuICAgICAgICB0aGlzLm5vZGVWaWV3LnVwZGF0ZU1heFdpZHRoKHRoaXMuJGVsLm91dGVyV2lkdGgoKSArIDE3KTtcbiAgICAgICAgdGhpcy4kZWxcbiAgICAgICAgICAgIC5jc3Moe1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBcIlwiLFxuICAgICAgICAgICAgICAgIGxlZnQ6IFwiXCIsXG4gICAgICAgICAgICAgICAgdG9wOiBcIlwiLFxuICAgICAgICAgICAgICAgIGRpc3BsYXk6IFwiXCJcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuZGV0YWNoKCk7XG4gICAgfSxcbiAgICByZWRyYXdXb3JrZmxvd091dHB1dDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmNhbGxvdXRWaWV3KSB7XG4gICAgICAgICAgICB0aGlzLmNhbGxvdXRWaWV3LnJlc2V0SW1hZ2UoKTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG52YXIgT3V0cHV0Q2FsbG91dFZpZXcgPSBCYWNrYm9uZS5WaWV3LmV4dGVuZCh7XG4gICAgdGFnTmFtZTogXCJkaXZcIixcblxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5sYWJlbCA9IG9wdGlvbnMubGFiZWw7XG4gICAgICAgIHRoaXMubm9kZSA9IG9wdGlvbnMubm9kZTtcbiAgICAgICAgdGhpcy5vdXRwdXQgPSBvcHRpb25zLm91dHB1dDtcblxuICAgICAgICB2YXIgdmlldyA9IHRoaXM7XG4gICAgICAgIHZhciBub2RlID0gdGhpcy5ub2RlO1xuICAgICAgICB0aGlzLiRlbFxuICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBgY2FsbG91dCAke3RoaXMubGFiZWx9YClcbiAgICAgICAgICAgIC5jc3MoeyBkaXNwbGF5OiBcIm5vbmVcIiB9KVxuICAgICAgICAgICAgLmFwcGVuZChcbiAgICAgICAgICAgICAgICAkKFwiPGRpdiBjbGFzcz0nYnV0dG9ucyc+PC9kaXY+XCIpLmFwcGVuZChcbiAgICAgICAgICAgICAgICAgICAgJChcIjxpbWcvPlwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJzcmNcIiwgYCR7R2FsYXh5LnJvb3R9c3RhdGljL2ltYWdlcy9mdWd1ZS9hc3Rlcmlzay1zbWFsbC1vdXRsaW5lLnBuZ2ApXG4gICAgICAgICAgICAgICAgICAgICAgICAuY2xpY2soKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvdXRwdXROYW1lID0gdmlldy5vdXRwdXQubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5pc1dvcmtmbG93T3V0cHV0KG91dHB1dE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUucmVtb3ZlV29ya2Zsb3dPdXRwdXQob3V0cHV0TmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpZXdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4kKFwiaW1nXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcInNyY1wiLCBgJHtHYWxheHkucm9vdH1zdGF0aWMvaW1hZ2VzL2Z1Z3VlL2FzdGVyaXNrLXNtYWxsLW91dGxpbmUucG5nYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5hZGRXb3JrZmxvd091dHB1dChvdXRwdXROYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlldy4kKFwiaW1nXCIpLmF0dHIoXCJzcmNcIiwgYCR7R2FsYXh5LnJvb3R9c3RhdGljL2ltYWdlcy9mdWd1ZS9hc3Rlcmlzay1zbWFsbC5wbmdgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LndvcmtmbG93X2dsb2JhbHMud29ya2Zsb3cuaGFzX2NoYW5nZXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy53b3JrZmxvd19nbG9iYWxzLmNhbnZhc19tYW5hZ2VyLmRyYXdfb3ZlcnZpZXcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgLnRvb2x0aXAoe1xuICAgICAgICAgICAgICAgIGRlbGF5OiA1MDAsXG4gICAgICAgICAgICAgICAgdGl0bGU6IFwiTWFyayBkYXRhc2V0IGFzIGEgd29ya2Zsb3cgb3V0cHV0LiBBbGwgdW5tYXJrZWQgZGF0YXNldHMgd2lsbCBiZSBoaWRkZW4uXCJcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuJGVsLmNzcyh7XG4gICAgICAgICAgICB0b3A6IFwiNTAlXCIsXG4gICAgICAgICAgICBtYXJnaW46IFwiLThweCAwcHggMHB4IDBweFwiLFxuICAgICAgICAgICAgcmlnaHQ6IDhcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuJGVsLnNob3coKTtcbiAgICAgICAgdGhpcy5yZXNldEltYWdlKCk7XG4gICAgfSxcblxuICAgIHJlc2V0SW1hZ2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMubm9kZS5pc1dvcmtmbG93T3V0cHV0KHRoaXMub3V0cHV0Lm5hbWUpKSB7XG4gICAgICAgICAgICB0aGlzLiQoXCJpbWdcIikuYXR0cihcInNyY1wiLCBgJHtHYWxheHkucm9vdH1zdGF0aWMvaW1hZ2VzL2Z1Z3VlL2FzdGVyaXNrLXNtYWxsLW91dGxpbmUucG5nYCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLiQoXCJpbWdcIikuYXR0cihcInNyY1wiLCBgJHtHYWxheHkucm9vdH1zdGF0aWMvaW1hZ2VzL2Z1Z3VlL2FzdGVyaXNrLXNtYWxsLnBuZ2ApO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGhvdmVySW1hZ2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLiQoXCJpbWdcIikuYXR0cihcInNyY1wiLCBgJHtHYWxheHkucm9vdH1zdGF0aWMvaW1hZ2VzL2Z1Z3VlL2FzdGVyaXNrLXNtYWxsLXllbGxvdy5wbmdgKTtcbiAgICB9XG59KTtcblxuZXhwb3J0IGRlZmF1bHQge1xuICAgIERhdGFJbnB1dFZpZXc6IERhdGFJbnB1dFZpZXcsXG4gICAgRGF0YU91dHB1dFZpZXc6IERhdGFPdXRwdXRWaWV3XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGdhbGF4eS9zY3JpcHRzL212Yy93b3JrZmxvdy93b3JrZmxvdy12aWV3LWRhdGEuanMiXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUEzQkE7QUFDQTtBQTZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXhEQTtBQUNBO0FBMERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUZBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBekRBO0FBQ0E7QUEyREE7QUFDQTtBQUNBO0FBRkE7QSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///292\n");

/***/ }),

/***/ 293:
/*!*******************************************************!*\
  !*** ./galaxy/scripts/mvc/workflow/workflow-forms.js ***!
  \*******************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(Backbone, $) {\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _localization = __webpack_require__(/*! utils/localization */ 3);\n\nvar _localization2 = _interopRequireDefault(_localization);\n\nvar _utils = __webpack_require__(/*! utils/utils */ 4);\n\nvar _utils2 = _interopRequireDefault(_utils);\n\nvar _formView = __webpack_require__(/*! mvc/form/form-view */ 11);\n\nvar _formView2 = _interopRequireDefault(_formView);\n\nvar _toolFormBase = __webpack_require__(/*! mvc/tool/tool-form-base */ 45);\n\nvar _toolFormBase2 = _interopRequireDefault(_toolFormBase);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/** Default form wrapper for non-tool modules in the workflow editor. */\nvar Default = Backbone.View.extend({\n    initialize: function initialize(options) {\n        var self = this;\n        var node = options.node;\n        this.form = new _formView2.default(_utils2.default.merge(options, {\n            onchange: function onchange() {\n                _utils2.default.request({\n                    type: \"POST\",\n                    url: Galaxy.root + \"api/workflows/build_module\",\n                    data: {\n                        id: node.id,\n                        type: node.type,\n                        content_id: node.content_id,\n                        inputs: self.form.data.create()\n                    },\n                    success: function success(data) {\n                        node.update_field_data(data);\n                    }\n                });\n            }\n        }));\n        _addLabelAnnotation(this.form);\n        this.form.render();\n    }\n});\n\n/** Tool form wrapper for the workflow editor. */\nvar Tool = Backbone.View.extend({\n    initialize: function initialize(options) {\n        var self = this;\n        var node = options.node;\n        this.form = new _toolFormBase2.default(_utils2.default.merge(options, {\n            text_enable: \"Set in Advance\",\n            text_disable: \"Set at Runtime\",\n            narrow: true,\n            initial_errors: true,\n            cls: \"ui-portlet-narrow\",\n            initialmodel: function initialmodel(process, form) {\n                self._customize(form);\n                process.resolve();\n            },\n            buildmodel: function buildmodel(process, form) {\n                form.model.get(\"postchange\")(process, form);\n            },\n            postchange: function postchange(process, form) {\n                var options = form.model.attributes;\n                var current_state = {\n                    tool_id: options.id,\n                    tool_version: options.version,\n                    type: \"tool\",\n                    inputs: $.extend(true, {}, form.data.create())\n                };\n                Galaxy.emit.debug(\"tool-form-workflow::postchange()\", \"Sending current state.\", current_state);\n                _utils2.default.request({\n                    type: \"POST\",\n                    url: Galaxy.root + \"api/workflows/build_module\",\n                    data: current_state,\n                    success: function success(data) {\n                        form.model.set(data.config_form);\n                        self._customize(form);\n                        form.update(data.config_form);\n                        form.errors(data.config_form);\n                        // This hasn't modified the workflow, just returned\n                        // module information for the tool to update the workflow\n                        // state stored on the client with. User needs to save\n                        // for this to take effect.\n                        node.update_field_data(data);\n                        Galaxy.emit.debug(\"tool-form-workflow::postchange()\", \"Received new model.\", data);\n                        process.resolve();\n                    },\n                    error: function error(response) {\n                        Galaxy.emit.debug(\"tool-form-workflow::postchange()\", \"Refresh request failed.\", response);\n                        process.reject();\n                    }\n                });\n            }\n        }));\n    },\n\n    _customize: function _customize(form) {\n        var options = form.model.attributes;\n        _utils2.default.deepeach(options.inputs, function (input) {\n            if (input.type) {\n                if ([\"data\", \"data_collection\"].indexOf(input.type) != -1) {\n                    input.type = \"hidden\";\n                    input.info = \"Data input '\" + input.name + \"' (\" + _utils2.default.textify(input.extensions) + \")\";\n                    input.value = { __class__: \"RuntimeValue\" };\n                } else if (!input.fixed) {\n                    input.collapsible_value = {\n                        __class__: \"RuntimeValue\"\n                    };\n                    input.is_workflow = input.options && input.options.length === 0 || [\"integer\", \"float\"].indexOf(input.type) != -1;\n                }\n            }\n        });\n        _utils2.default.deepeach(options.inputs, function (input) {\n            if (input.type === \"conditional\") {\n                input.test_param.collapsible_value = undefined;\n            }\n        });\n        _addSections(form);\n        _addLabelAnnotation(form);\n    }\n});\n\n/** Augments the module form definition by adding label and annotation fields */\nfunction _addLabelAnnotation(form) {\n    var options = form.model.attributes;\n    var workflow = options.workflow;\n    var node = options.node;\n    options.inputs.unshift({\n        type: \"text\",\n        name: \"__annotation\",\n        label: \"Annotation\",\n        fixed: true,\n        value: node.annotation,\n        area: true,\n        help: \"Add an annotation or notes to this step. Annotations are available when a workflow is viewed.\"\n    });\n    options.inputs.unshift({\n        type: \"text\",\n        name: \"__label\",\n        label: \"Label\",\n        value: node.label,\n        help: (0, _localization2.default)(\"Add a step label.\"),\n        fixed: true,\n        onchange: function onchange(new_label) {\n            var duplicate = false;\n            for (var i in workflow.nodes) {\n                var n = workflow.nodes[i];\n                if (n.label && n.label == new_label && n.id != node.id) {\n                    duplicate = true;\n                    break;\n                }\n            }\n            var input_id = form.data.match(\"__label\");\n            var input_element = form.element_list[input_id];\n            input_element.model.set(\"error_text\", duplicate && \"Duplicate label. Please fix this before saving the workflow.\");\n            form.trigger(\"change\");\n        }\n    });\n}\n\n/** Visit input nodes and enrich by name/value pairs from server data */\nfunction _visit(head, head_list, output_id, options) {\n    var post_job_actions = options.node.post_job_actions;\n    head_list = head_list || [];\n    head_list.push(head);\n    for (var i in head.inputs) {\n        var input = head.inputs[i];\n        var action = input.action;\n        if (action) {\n            input.name = \"pja__\" + output_id + \"__\" + input.action;\n            if (input.pja_arg) {\n                input.name += \"__\" + input.pja_arg;\n            }\n            if (input.payload) {\n                for (var p_id in input.payload) {\n                    input.payload[input.name + \"__\" + p_id] = input.payload[p_id];\n                    delete input.payload[p_id];\n                }\n            }\n            var d = post_job_actions[input.action + output_id];\n            if (d) {\n                for (var j in head_list) {\n                    head_list[j].expanded = true;\n                }\n                if (input.pja_arg) {\n                    input.value = d.action_arguments && d.action_arguments[input.pja_arg] || input.value;\n                } else {\n                    input.value = \"true\";\n                }\n            }\n        }\n        if (input.inputs) {\n            _visit(input, head_list.slice(0), output_id, options);\n        }\n    }\n}\n\n/** Builds sub section with step actions/annotation */\nfunction _makeSection(output_id, options) {\n    var extensions = [];\n    var input_terminal_names = [];\n    var datatypes = options.datatypes;\n    var node = options.node;\n    var workflow = options.workflow;\n\n    for (var key in datatypes) {\n        extensions.push({ 0: datatypes[key], 1: datatypes[key] });\n    }\n    for (key in node.input_terminals) {\n        input_terminal_names.push(node.input_terminals[key].name);\n    }\n    extensions.sort(function (a, b) {\n        return a.label > b.label ? 1 : a.label < b.label ? -1 : 0;\n    });\n    extensions.unshift({\n        0: \"Sequences\",\n        1: \"Sequences\"\n    });\n    extensions.unshift({\n        0: \"Roadmaps\",\n        1: \"Roadmaps\"\n    });\n    extensions.unshift({\n        0: \"Leave unchanged\",\n        1: \"__empty__\"\n    });\n    var output;\n    var input_config = {\n        title: \"Configure Output: '\" + output_id + \"'\",\n        type: \"section\",\n        flat: true,\n        inputs: [{\n            label: \"Label\",\n            type: \"text\",\n            value: (output = node.getWorkflowOutput(output_id)) && output.label || \"\",\n            help: \"This will provide a short name to describe the output - this must be unique across workflows.\",\n            onchange: function onchange(new_value) {\n                workflow.attemptUpdateOutputLabel(node, output_id, new_value);\n            }\n        }, {\n            action: \"RenameDatasetAction\",\n            pja_arg: \"newname\",\n            label: \"Rename dataset\",\n            type: \"text\",\n            value: \"\",\n            ignore: \"\",\n            help: \"This action will rename the output dataset. Click <a href=\\\"https://galaxyproject.org/learn/advanced-workflow/variables/\\\">here</a> for more information. Valid inputs are: <strong>\" + input_terminal_names.join(\", \") + \"</strong>.\"\n        }, {\n            action: \"ChangeDatatypeAction\",\n            pja_arg: \"newtype\",\n            label: \"Change datatype\",\n            type: \"select\",\n            ignore: \"__empty__\",\n            value: \"__empty__\",\n            options: extensions,\n            help: \"This action will change the datatype of the output to the indicated value.\"\n        }, {\n            action: \"TagDatasetAction\",\n            pja_arg: \"tags\",\n            label: \"Add Tags\",\n            type: \"text\",\n            value: \"\",\n            ignore: \"\",\n            help: \"This action will set tags for the dataset.\"\n        }, {\n            action: \"RemoveTagDatasetAction\",\n            pja_arg: \"tags\",\n            label: \"Remove Tags\",\n            type: \"text\",\n            value: \"\",\n            ignore: \"\",\n            help: \"This action will remove tags for the dataset.\"\n        }, {\n            title: (0, _localization2.default)(\"Assign columns\"),\n            type: \"section\",\n            flat: true,\n            inputs: [{\n                action: \"ColumnSetAction\",\n                pja_arg: \"chromCol\",\n                label: \"Chrom column\",\n                type: \"integer\",\n                value: \"\",\n                ignore: \"\"\n            }, {\n                action: \"ColumnSetAction\",\n                pja_arg: \"startCol\",\n                label: \"Start column\",\n                type: \"integer\",\n                value: \"\",\n                ignore: \"\"\n            }, {\n                action: \"ColumnSetAction\",\n                pja_arg: \"endCol\",\n                label: \"End column\",\n                type: \"integer\",\n                value: \"\",\n                ignore: \"\"\n            }, {\n                action: \"ColumnSetAction\",\n                pja_arg: \"strandCol\",\n                label: \"Strand column\",\n                type: \"integer\",\n                value: \"\",\n                ignore: \"\"\n            }, {\n                action: \"ColumnSetAction\",\n                pja_arg: \"nameCol\",\n                label: \"Name column\",\n                type: \"integer\",\n                value: \"\",\n                ignore: \"\"\n            }],\n            help: \"This action will set column assignments in the output dataset. Blank fields are ignored.\"\n        }]\n    };\n    _visit(input_config, [], output_id, options);\n    return input_config;\n}\n\n/** Builds all sub sections */\nfunction _addSections(form) {\n    var options = form.model.attributes;\n    var inputs = options.inputs;\n    var node = options.node;\n    var post_job_actions = node.post_job_actions;\n    var output_id = node.output_terminals && Object.keys(node.output_terminals)[0];\n\n    if (output_id) {\n        inputs.push({\n            name: \"pja__\" + output_id + \"__EmailAction\",\n            label: \"Email notification\",\n            type: \"boolean\",\n            value: String(Boolean(post_job_actions[\"EmailAction\" + output_id])),\n            ignore: \"false\",\n            help: (0, _localization2.default)(\"An email notification will be sent when the job has completed.\"),\n            payload: {\n                host: window.location.host\n            }\n        });\n        inputs.push({\n            name: \"pja__\" + output_id + \"__DeleteIntermediatesAction\",\n            label: \"Output cleanup\",\n            type: \"boolean\",\n            value: String(Boolean(post_job_actions[\"DeleteIntermediatesAction\" + output_id])),\n            ignore: \"false\",\n            help: \"Upon completion of this step, delete non-starred outputs from completed workflow steps if they are no longer required as inputs.\"\n        });\n        for (var i in node.output_terminals) {\n            inputs.push(_makeSection(i, options));\n        }\n    }\n}\n\nexports.default = {\n    Default: Default,\n    Tool: Tool\n};\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! libs/backbone */ 2), __webpack_require__(/*! jquery */ 0)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjkzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL2dhbGF4eS9zY3JpcHRzL212Yy93b3JrZmxvdy93b3JrZmxvdy1mb3Jtcy5qcz84M2M3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBfbCBmcm9tIFwidXRpbHMvbG9jYWxpemF0aW9uXCI7XG5pbXBvcnQgVXRpbHMgZnJvbSBcInV0aWxzL3V0aWxzXCI7XG5pbXBvcnQgRm9ybSBmcm9tIFwibXZjL2Zvcm0vZm9ybS12aWV3XCI7XG5pbXBvcnQgVG9vbEZvcm1CYXNlIGZyb20gXCJtdmMvdG9vbC90b29sLWZvcm0tYmFzZVwiO1xuLyoqIERlZmF1bHQgZm9ybSB3cmFwcGVyIGZvciBub24tdG9vbCBtb2R1bGVzIGluIHRoZSB3b3JrZmxvdyBlZGl0b3IuICovXG52YXIgRGVmYXVsdCA9IEJhY2tib25lLlZpZXcuZXh0ZW5kKHtcbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIG5vZGUgPSBvcHRpb25zLm5vZGU7XG4gICAgICAgIHRoaXMuZm9ybSA9IG5ldyBGb3JtKFxuICAgICAgICAgICAgVXRpbHMubWVyZ2Uob3B0aW9ucywge1xuICAgICAgICAgICAgICAgIG9uY2hhbmdlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgVXRpbHMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIlBPU1RcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybDogYCR7R2FsYXh5LnJvb3R9YXBpL3dvcmtmbG93cy9idWlsZF9tb2R1bGVgLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBub2RlLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IG5vZGUudHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50X2lkOiBub2RlLmNvbnRlbnRfaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRzOiBzZWxmLmZvcm0uZGF0YS5jcmVhdGUoKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLnVwZGF0ZV9maWVsZF9kYXRhKGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgICBfYWRkTGFiZWxBbm5vdGF0aW9uKHRoaXMuZm9ybSk7XG4gICAgICAgIHRoaXMuZm9ybS5yZW5kZXIoKTtcbiAgICB9XG59KTtcblxuLyoqIFRvb2wgZm9ybSB3cmFwcGVyIGZvciB0aGUgd29ya2Zsb3cgZWRpdG9yLiAqL1xudmFyIFRvb2wgPSBCYWNrYm9uZS5WaWV3LmV4dGVuZCh7XG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBub2RlID0gb3B0aW9ucy5ub2RlO1xuICAgICAgICB0aGlzLmZvcm0gPSBuZXcgVG9vbEZvcm1CYXNlKFxuICAgICAgICAgICAgVXRpbHMubWVyZ2Uob3B0aW9ucywge1xuICAgICAgICAgICAgICAgIHRleHRfZW5hYmxlOiBcIlNldCBpbiBBZHZhbmNlXCIsXG4gICAgICAgICAgICAgICAgdGV4dF9kaXNhYmxlOiBcIlNldCBhdCBSdW50aW1lXCIsXG4gICAgICAgICAgICAgICAgbmFycm93OiB0cnVlLFxuICAgICAgICAgICAgICAgIGluaXRpYWxfZXJyb3JzOiB0cnVlLFxuICAgICAgICAgICAgICAgIGNsczogXCJ1aS1wb3J0bGV0LW5hcnJvd1wiLFxuICAgICAgICAgICAgICAgIGluaXRpYWxtb2RlbDogZnVuY3Rpb24ocHJvY2VzcywgZm9ybSkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLl9jdXN0b21pemUoZm9ybSk7XG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3MucmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgYnVpbGRtb2RlbDogZnVuY3Rpb24ocHJvY2VzcywgZm9ybSkge1xuICAgICAgICAgICAgICAgICAgICBmb3JtLm1vZGVsLmdldChcInBvc3RjaGFuZ2VcIikocHJvY2VzcywgZm9ybSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBwb3N0Y2hhbmdlOiBmdW5jdGlvbihwcm9jZXNzLCBmb3JtKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvcHRpb25zID0gZm9ybS5tb2RlbC5hdHRyaWJ1dGVzO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY3VycmVudF9zdGF0ZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvb2xfaWQ6IG9wdGlvbnMuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0b29sX3ZlcnNpb246IG9wdGlvbnMudmVyc2lvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwidG9vbFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRzOiAkLmV4dGVuZCh0cnVlLCB7fSwgZm9ybS5kYXRhLmNyZWF0ZSgpKVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBHYWxheHkuZW1pdC5kZWJ1ZyhcInRvb2wtZm9ybS13b3JrZmxvdzo6cG9zdGNoYW5nZSgpXCIsIFwiU2VuZGluZyBjdXJyZW50IHN0YXRlLlwiLCBjdXJyZW50X3N0YXRlKTtcbiAgICAgICAgICAgICAgICAgICAgVXRpbHMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIlBPU1RcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybDogYCR7R2FsYXh5LnJvb3R9YXBpL3dvcmtmbG93cy9idWlsZF9tb2R1bGVgLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogY3VycmVudF9zdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JtLm1vZGVsLnNldChkYXRhLmNvbmZpZ19mb3JtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9jdXN0b21pemUoZm9ybSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9ybS51cGRhdGUoZGF0YS5jb25maWdfZm9ybSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9ybS5lcnJvcnMoZGF0YS5jb25maWdfZm9ybSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBoYXNuJ3QgbW9kaWZpZWQgdGhlIHdvcmtmbG93LCBqdXN0IHJldHVybmVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbW9kdWxlIGluZm9ybWF0aW9uIGZvciB0aGUgdG9vbCB0byB1cGRhdGUgdGhlIHdvcmtmbG93XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3RhdGUgc3RvcmVkIG9uIHRoZSBjbGllbnQgd2l0aC4gVXNlciBuZWVkcyB0byBzYXZlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZm9yIHRoaXMgdG8gdGFrZSBlZmZlY3QuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS51cGRhdGVfZmllbGRfZGF0YShkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBHYWxheHkuZW1pdC5kZWJ1ZyhcInRvb2wtZm9ybS13b3JrZmxvdzo6cG9zdGNoYW5nZSgpXCIsIFwiUmVjZWl2ZWQgbmV3IG1vZGVsLlwiLCBkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9jZXNzLnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBHYWxheHkuZW1pdC5kZWJ1ZyhcInRvb2wtZm9ybS13b3JrZmxvdzo6cG9zdGNoYW5nZSgpXCIsIFwiUmVmcmVzaCByZXF1ZXN0IGZhaWxlZC5cIiwgcmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2Nlc3MucmVqZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIF9jdXN0b21pemU6IGZ1bmN0aW9uKGZvcm0pIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBmb3JtLm1vZGVsLmF0dHJpYnV0ZXM7XG4gICAgICAgIFV0aWxzLmRlZXBlYWNoKG9wdGlvbnMuaW5wdXRzLCBpbnB1dCA9PiB7XG4gICAgICAgICAgICBpZiAoaW5wdXQudHlwZSkge1xuICAgICAgICAgICAgICAgIGlmIChbXCJkYXRhXCIsIFwiZGF0YV9jb2xsZWN0aW9uXCJdLmluZGV4T2YoaW5wdXQudHlwZSkgIT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQudHlwZSA9IFwiaGlkZGVuXCI7XG4gICAgICAgICAgICAgICAgICAgIGlucHV0LmluZm8gPSBgRGF0YSBpbnB1dCAnJHtpbnB1dC5uYW1lfScgKCR7VXRpbHMudGV4dGlmeShpbnB1dC5leHRlbnNpb25zKX0pYDtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQudmFsdWUgPSB7IF9fY2xhc3NfXzogXCJSdW50aW1lVmFsdWVcIiB9O1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIWlucHV0LmZpeGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlucHV0LmNvbGxhcHNpYmxlX3ZhbHVlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgX19jbGFzc19fOiBcIlJ1bnRpbWVWYWx1ZVwiXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGlucHV0LmlzX3dvcmtmbG93ID1cbiAgICAgICAgICAgICAgICAgICAgICAgIChpbnB1dC5vcHRpb25zICYmIGlucHV0Lm9wdGlvbnMubGVuZ3RoID09PSAwKSB8fCBbXCJpbnRlZ2VyXCIsIFwiZmxvYXRcIl0uaW5kZXhPZihpbnB1dC50eXBlKSAhPSAtMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBVdGlscy5kZWVwZWFjaChvcHRpb25zLmlucHV0cywgaW5wdXQgPT4ge1xuICAgICAgICAgICAgaWYgKGlucHV0LnR5cGUgPT09IFwiY29uZGl0aW9uYWxcIikge1xuICAgICAgICAgICAgICAgIGlucHV0LnRlc3RfcGFyYW0uY29sbGFwc2libGVfdmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBfYWRkU2VjdGlvbnMoZm9ybSk7XG4gICAgICAgIF9hZGRMYWJlbEFubm90YXRpb24oZm9ybSk7XG4gICAgfVxufSk7XG5cbi8qKiBBdWdtZW50cyB0aGUgbW9kdWxlIGZvcm0gZGVmaW5pdGlvbiBieSBhZGRpbmcgbGFiZWwgYW5kIGFubm90YXRpb24gZmllbGRzICovXG5mdW5jdGlvbiBfYWRkTGFiZWxBbm5vdGF0aW9uKGZvcm0pIHtcbiAgICB2YXIgb3B0aW9ucyA9IGZvcm0ubW9kZWwuYXR0cmlidXRlcztcbiAgICB2YXIgd29ya2Zsb3cgPSBvcHRpb25zLndvcmtmbG93O1xuICAgIHZhciBub2RlID0gb3B0aW9ucy5ub2RlO1xuICAgIG9wdGlvbnMuaW5wdXRzLnVuc2hpZnQoe1xuICAgICAgICB0eXBlOiBcInRleHRcIixcbiAgICAgICAgbmFtZTogXCJfX2Fubm90YXRpb25cIixcbiAgICAgICAgbGFiZWw6IFwiQW5ub3RhdGlvblwiLFxuICAgICAgICBmaXhlZDogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IG5vZGUuYW5ub3RhdGlvbixcbiAgICAgICAgYXJlYTogdHJ1ZSxcbiAgICAgICAgaGVscDogXCJBZGQgYW4gYW5ub3RhdGlvbiBvciBub3RlcyB0byB0aGlzIHN0ZXAuIEFubm90YXRpb25zIGFyZSBhdmFpbGFibGUgd2hlbiBhIHdvcmtmbG93IGlzIHZpZXdlZC5cIlxuICAgIH0pO1xuICAgIG9wdGlvbnMuaW5wdXRzLnVuc2hpZnQoe1xuICAgICAgICB0eXBlOiBcInRleHRcIixcbiAgICAgICAgbmFtZTogXCJfX2xhYmVsXCIsXG4gICAgICAgIGxhYmVsOiBcIkxhYmVsXCIsXG4gICAgICAgIHZhbHVlOiBub2RlLmxhYmVsLFxuICAgICAgICBoZWxwOiBfbChcIkFkZCBhIHN0ZXAgbGFiZWwuXCIpLFxuICAgICAgICBmaXhlZDogdHJ1ZSxcbiAgICAgICAgb25jaGFuZ2U6IGZ1bmN0aW9uKG5ld19sYWJlbCkge1xuICAgICAgICAgICAgdmFyIGR1cGxpY2F0ZSA9IGZhbHNlO1xuICAgICAgICAgICAgZm9yICh2YXIgaSBpbiB3b3JrZmxvdy5ub2Rlcykge1xuICAgICAgICAgICAgICAgIHZhciBuID0gd29ya2Zsb3cubm9kZXNbaV07XG4gICAgICAgICAgICAgICAgaWYgKG4ubGFiZWwgJiYgbi5sYWJlbCA9PSBuZXdfbGFiZWwgJiYgbi5pZCAhPSBub2RlLmlkKSB7XG4gICAgICAgICAgICAgICAgICAgIGR1cGxpY2F0ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBpbnB1dF9pZCA9IGZvcm0uZGF0YS5tYXRjaChcIl9fbGFiZWxcIik7XG4gICAgICAgICAgICB2YXIgaW5wdXRfZWxlbWVudCA9IGZvcm0uZWxlbWVudF9saXN0W2lucHV0X2lkXTtcbiAgICAgICAgICAgIGlucHV0X2VsZW1lbnQubW9kZWwuc2V0KFxuICAgICAgICAgICAgICAgIFwiZXJyb3JfdGV4dFwiLFxuICAgICAgICAgICAgICAgIGR1cGxpY2F0ZSAmJiBcIkR1cGxpY2F0ZSBsYWJlbC4gUGxlYXNlIGZpeCB0aGlzIGJlZm9yZSBzYXZpbmcgdGhlIHdvcmtmbG93LlwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgZm9ybS50cmlnZ2VyKFwiY2hhbmdlXCIpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5cbi8qKiBWaXNpdCBpbnB1dCBub2RlcyBhbmQgZW5yaWNoIGJ5IG5hbWUvdmFsdWUgcGFpcnMgZnJvbSBzZXJ2ZXIgZGF0YSAqL1xuZnVuY3Rpb24gX3Zpc2l0KGhlYWQsIGhlYWRfbGlzdCwgb3V0cHV0X2lkLCBvcHRpb25zKSB7XG4gICAgdmFyIHBvc3Rfam9iX2FjdGlvbnMgPSBvcHRpb25zLm5vZGUucG9zdF9qb2JfYWN0aW9ucztcbiAgICBoZWFkX2xpc3QgPSBoZWFkX2xpc3QgfHwgW107XG4gICAgaGVhZF9saXN0LnB1c2goaGVhZCk7XG4gICAgZm9yICh2YXIgaSBpbiBoZWFkLmlucHV0cykge1xuICAgICAgICB2YXIgaW5wdXQgPSBoZWFkLmlucHV0c1tpXTtcbiAgICAgICAgdmFyIGFjdGlvbiA9IGlucHV0LmFjdGlvbjtcbiAgICAgICAgaWYgKGFjdGlvbikge1xuICAgICAgICAgICAgaW5wdXQubmFtZSA9IGBwamFfXyR7b3V0cHV0X2lkfV9fJHtpbnB1dC5hY3Rpb259YDtcbiAgICAgICAgICAgIGlmIChpbnB1dC5wamFfYXJnKSB7XG4gICAgICAgICAgICAgICAgaW5wdXQubmFtZSArPSBgX18ke2lucHV0LnBqYV9hcmd9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpbnB1dC5wYXlsb2FkKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgcF9pZCBpbiBpbnB1dC5wYXlsb2FkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlucHV0LnBheWxvYWRbYCR7aW5wdXQubmFtZX1fXyR7cF9pZH1gXSA9IGlucHV0LnBheWxvYWRbcF9pZF07XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBpbnB1dC5wYXlsb2FkW3BfaWRdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBkID0gcG9zdF9qb2JfYWN0aW9uc1tpbnB1dC5hY3Rpb24gKyBvdXRwdXRfaWRdO1xuICAgICAgICAgICAgaWYgKGQpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqIGluIGhlYWRfbGlzdCkge1xuICAgICAgICAgICAgICAgICAgICBoZWFkX2xpc3Rbal0uZXhwYW5kZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQucGphX2FyZykge1xuICAgICAgICAgICAgICAgICAgICBpbnB1dC52YWx1ZSA9IChkLmFjdGlvbl9hcmd1bWVudHMgJiYgZC5hY3Rpb25fYXJndW1lbnRzW2lucHV0LnBqYV9hcmddKSB8fCBpbnB1dC52YWx1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpbnB1dC52YWx1ZSA9IFwidHJ1ZVwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5wdXQuaW5wdXRzKSB7XG4gICAgICAgICAgICBfdmlzaXQoaW5wdXQsIGhlYWRfbGlzdC5zbGljZSgwKSwgb3V0cHV0X2lkLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqIEJ1aWxkcyBzdWIgc2VjdGlvbiB3aXRoIHN0ZXAgYWN0aW9ucy9hbm5vdGF0aW9uICovXG5mdW5jdGlvbiBfbWFrZVNlY3Rpb24ob3V0cHV0X2lkLCBvcHRpb25zKSB7XG4gICAgdmFyIGV4dGVuc2lvbnMgPSBbXTtcbiAgICB2YXIgaW5wdXRfdGVybWluYWxfbmFtZXMgPSBbXTtcbiAgICB2YXIgZGF0YXR5cGVzID0gb3B0aW9ucy5kYXRhdHlwZXM7XG4gICAgdmFyIG5vZGUgPSBvcHRpb25zLm5vZGU7XG4gICAgdmFyIHdvcmtmbG93ID0gb3B0aW9ucy53b3JrZmxvdztcblxuICAgIGZvciAodmFyIGtleSBpbiBkYXRhdHlwZXMpIHtcbiAgICAgICAgZXh0ZW5zaW9ucy5wdXNoKHsgMDogZGF0YXR5cGVzW2tleV0sIDE6IGRhdGF0eXBlc1trZXldIH0pO1xuICAgIH1cbiAgICBmb3IgKGtleSBpbiBub2RlLmlucHV0X3Rlcm1pbmFscykge1xuICAgICAgICBpbnB1dF90ZXJtaW5hbF9uYW1lcy5wdXNoKG5vZGUuaW5wdXRfdGVybWluYWxzW2tleV0ubmFtZSk7XG4gICAgfVxuICAgIGV4dGVuc2lvbnMuc29ydCgoYSwgYikgPT4gKGEubGFiZWwgPiBiLmxhYmVsID8gMSA6IGEubGFiZWwgPCBiLmxhYmVsID8gLTEgOiAwKSk7XG4gICAgZXh0ZW5zaW9ucy51bnNoaWZ0KHtcbiAgICAgICAgMDogXCJTZXF1ZW5jZXNcIixcbiAgICAgICAgMTogXCJTZXF1ZW5jZXNcIlxuICAgIH0pO1xuICAgIGV4dGVuc2lvbnMudW5zaGlmdCh7XG4gICAgICAgIDA6IFwiUm9hZG1hcHNcIixcbiAgICAgICAgMTogXCJSb2FkbWFwc1wiXG4gICAgfSk7XG4gICAgZXh0ZW5zaW9ucy51bnNoaWZ0KHtcbiAgICAgICAgMDogXCJMZWF2ZSB1bmNoYW5nZWRcIixcbiAgICAgICAgMTogXCJfX2VtcHR5X19cIlxuICAgIH0pO1xuICAgIHZhciBvdXRwdXQ7XG4gICAgdmFyIGlucHV0X2NvbmZpZyA9IHtcbiAgICAgICAgdGl0bGU6IGBDb25maWd1cmUgT3V0cHV0OiAnJHtvdXRwdXRfaWR9J2AsXG4gICAgICAgIHR5cGU6IFwic2VjdGlvblwiLFxuICAgICAgICBmbGF0OiB0cnVlLFxuICAgICAgICBpbnB1dHM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBsYWJlbDogXCJMYWJlbFwiLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgICAgICAgICAgIHZhbHVlOiAoKG91dHB1dCA9IG5vZGUuZ2V0V29ya2Zsb3dPdXRwdXQob3V0cHV0X2lkKSkgJiYgb3V0cHV0LmxhYmVsKSB8fCBcIlwiLFxuICAgICAgICAgICAgICAgIGhlbHA6IFwiVGhpcyB3aWxsIHByb3ZpZGUgYSBzaG9ydCBuYW1lIHRvIGRlc2NyaWJlIHRoZSBvdXRwdXQgLSB0aGlzIG11c3QgYmUgdW5pcXVlIGFjcm9zcyB3b3JrZmxvd3MuXCIsXG4gICAgICAgICAgICAgICAgb25jaGFuZ2U6IGZ1bmN0aW9uKG5ld192YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB3b3JrZmxvdy5hdHRlbXB0VXBkYXRlT3V0cHV0TGFiZWwobm9kZSwgb3V0cHV0X2lkLCBuZXdfdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgYWN0aW9uOiBcIlJlbmFtZURhdGFzZXRBY3Rpb25cIixcbiAgICAgICAgICAgICAgICBwamFfYXJnOiBcIm5ld25hbWVcIixcbiAgICAgICAgICAgICAgICBsYWJlbDogXCJSZW5hbWUgZGF0YXNldFwiLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBcIlwiLFxuICAgICAgICAgICAgICAgIGlnbm9yZTogXCJcIixcbiAgICAgICAgICAgICAgICBoZWxwOiBgVGhpcyBhY3Rpb24gd2lsbCByZW5hbWUgdGhlIG91dHB1dCBkYXRhc2V0LiBDbGljayA8YSBocmVmPVwiaHR0cHM6Ly9nYWxheHlwcm9qZWN0Lm9yZy9sZWFybi9hZHZhbmNlZC13b3JrZmxvdy92YXJpYWJsZXMvXCI+aGVyZTwvYT4gZm9yIG1vcmUgaW5mb3JtYXRpb24uIFZhbGlkIGlucHV0cyBhcmU6IDxzdHJvbmc+JHtpbnB1dF90ZXJtaW5hbF9uYW1lcy5qb2luKFxuICAgICAgICAgICAgICAgICAgICBcIiwgXCJcbiAgICAgICAgICAgICAgICApfTwvc3Ryb25nPi5gXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGFjdGlvbjogXCJDaGFuZ2VEYXRhdHlwZUFjdGlvblwiLFxuICAgICAgICAgICAgICAgIHBqYV9hcmc6IFwibmV3dHlwZVwiLFxuICAgICAgICAgICAgICAgIGxhYmVsOiBcIkNoYW5nZSBkYXRhdHlwZVwiLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwic2VsZWN0XCIsXG4gICAgICAgICAgICAgICAgaWdub3JlOiBcIl9fZW1wdHlfX1wiLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBcIl9fZW1wdHlfX1wiLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGV4dGVuc2lvbnMsXG4gICAgICAgICAgICAgICAgaGVscDogXCJUaGlzIGFjdGlvbiB3aWxsIGNoYW5nZSB0aGUgZGF0YXR5cGUgb2YgdGhlIG91dHB1dCB0byB0aGUgaW5kaWNhdGVkIHZhbHVlLlwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGFjdGlvbjogXCJUYWdEYXRhc2V0QWN0aW9uXCIsXG4gICAgICAgICAgICAgICAgcGphX2FyZzogXCJ0YWdzXCIsXG4gICAgICAgICAgICAgICAgbGFiZWw6IFwiQWRkIFRhZ3NcIixcbiAgICAgICAgICAgICAgICB0eXBlOiBcInRleHRcIixcbiAgICAgICAgICAgICAgICB2YWx1ZTogXCJcIixcbiAgICAgICAgICAgICAgICBpZ25vcmU6IFwiXCIsXG4gICAgICAgICAgICAgICAgaGVscDogXCJUaGlzIGFjdGlvbiB3aWxsIHNldCB0YWdzIGZvciB0aGUgZGF0YXNldC5cIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBhY3Rpb246IFwiUmVtb3ZlVGFnRGF0YXNldEFjdGlvblwiLFxuICAgICAgICAgICAgICAgIHBqYV9hcmc6IFwidGFnc1wiLFxuICAgICAgICAgICAgICAgIGxhYmVsOiBcIlJlbW92ZSBUYWdzXCIsXG4gICAgICAgICAgICAgICAgdHlwZTogXCJ0ZXh0XCIsXG4gICAgICAgICAgICAgICAgdmFsdWU6IFwiXCIsXG4gICAgICAgICAgICAgICAgaWdub3JlOiBcIlwiLFxuICAgICAgICAgICAgICAgIGhlbHA6IFwiVGhpcyBhY3Rpb24gd2lsbCByZW1vdmUgdGFncyBmb3IgdGhlIGRhdGFzZXQuXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGl0bGU6IF9sKFwiQXNzaWduIGNvbHVtbnNcIiksXG4gICAgICAgICAgICAgICAgdHlwZTogXCJzZWN0aW9uXCIsXG4gICAgICAgICAgICAgICAgZmxhdDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBpbnB1dHM6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBcIkNvbHVtblNldEFjdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGphX2FyZzogXCJjaHJvbUNvbFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6IFwiQ2hyb20gY29sdW1uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImludGVnZXJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBcIlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgaWdub3JlOiBcIlwiXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogXCJDb2x1bW5TZXRBY3Rpb25cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHBqYV9hcmc6IFwic3RhcnRDb2xcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiBcIlN0YXJ0IGNvbHVtblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJpbnRlZ2VyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogXCJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGlnbm9yZTogXCJcIlxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFwiQ29sdW1uU2V0QWN0aW9uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBwamFfYXJnOiBcImVuZENvbFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6IFwiRW5kIGNvbHVtblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJpbnRlZ2VyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogXCJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGlnbm9yZTogXCJcIlxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFwiQ29sdW1uU2V0QWN0aW9uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBwamFfYXJnOiBcInN0cmFuZENvbFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6IFwiU3RyYW5kIGNvbHVtblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJpbnRlZ2VyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogXCJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGlnbm9yZTogXCJcIlxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFwiQ29sdW1uU2V0QWN0aW9uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBwamFfYXJnOiBcIm5hbWVDb2xcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiBcIk5hbWUgY29sdW1uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImludGVnZXJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBcIlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgaWdub3JlOiBcIlwiXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIGhlbHA6IFwiVGhpcyBhY3Rpb24gd2lsbCBzZXQgY29sdW1uIGFzc2lnbm1lbnRzIGluIHRoZSBvdXRwdXQgZGF0YXNldC4gQmxhbmsgZmllbGRzIGFyZSBpZ25vcmVkLlwiXG4gICAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICB9O1xuICAgIF92aXNpdChpbnB1dF9jb25maWcsIFtdLCBvdXRwdXRfaWQsIG9wdGlvbnMpO1xuICAgIHJldHVybiBpbnB1dF9jb25maWc7XG59XG5cbi8qKiBCdWlsZHMgYWxsIHN1YiBzZWN0aW9ucyAqL1xuZnVuY3Rpb24gX2FkZFNlY3Rpb25zKGZvcm0pIHtcbiAgICB2YXIgb3B0aW9ucyA9IGZvcm0ubW9kZWwuYXR0cmlidXRlcztcbiAgICB2YXIgaW5wdXRzID0gb3B0aW9ucy5pbnB1dHM7XG4gICAgdmFyIG5vZGUgPSBvcHRpb25zLm5vZGU7XG4gICAgdmFyIHBvc3Rfam9iX2FjdGlvbnMgPSBub2RlLnBvc3Rfam9iX2FjdGlvbnM7XG4gICAgdmFyIG91dHB1dF9pZCA9IG5vZGUub3V0cHV0X3Rlcm1pbmFscyAmJiBPYmplY3Qua2V5cyhub2RlLm91dHB1dF90ZXJtaW5hbHMpWzBdO1xuXG4gICAgaWYgKG91dHB1dF9pZCkge1xuICAgICAgICBpbnB1dHMucHVzaCh7XG4gICAgICAgICAgICBuYW1lOiBgcGphX18ke291dHB1dF9pZH1fX0VtYWlsQWN0aW9uYCxcbiAgICAgICAgICAgIGxhYmVsOiBcIkVtYWlsIG5vdGlmaWNhdGlvblwiLFxuICAgICAgICAgICAgdHlwZTogXCJib29sZWFuXCIsXG4gICAgICAgICAgICB2YWx1ZTogU3RyaW5nKEJvb2xlYW4ocG9zdF9qb2JfYWN0aW9uc1tgRW1haWxBY3Rpb24ke291dHB1dF9pZH1gXSkpLFxuICAgICAgICAgICAgaWdub3JlOiBcImZhbHNlXCIsXG4gICAgICAgICAgICBoZWxwOiBfbChcIkFuIGVtYWlsIG5vdGlmaWNhdGlvbiB3aWxsIGJlIHNlbnQgd2hlbiB0aGUgam9iIGhhcyBjb21wbGV0ZWQuXCIpLFxuICAgICAgICAgICAgcGF5bG9hZDoge1xuICAgICAgICAgICAgICAgIGhvc3Q6IHdpbmRvdy5sb2NhdGlvbi5ob3N0XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpbnB1dHMucHVzaCh7XG4gICAgICAgICAgICBuYW1lOiBgcGphX18ke291dHB1dF9pZH1fX0RlbGV0ZUludGVybWVkaWF0ZXNBY3Rpb25gLFxuICAgICAgICAgICAgbGFiZWw6IFwiT3V0cHV0IGNsZWFudXBcIixcbiAgICAgICAgICAgIHR5cGU6IFwiYm9vbGVhblwiLFxuICAgICAgICAgICAgdmFsdWU6IFN0cmluZyhCb29sZWFuKHBvc3Rfam9iX2FjdGlvbnNbYERlbGV0ZUludGVybWVkaWF0ZXNBY3Rpb24ke291dHB1dF9pZH1gXSkpLFxuICAgICAgICAgICAgaWdub3JlOiBcImZhbHNlXCIsXG4gICAgICAgICAgICBoZWxwOlxuICAgICAgICAgICAgICAgIFwiVXBvbiBjb21wbGV0aW9uIG9mIHRoaXMgc3RlcCwgZGVsZXRlIG5vbi1zdGFycmVkIG91dHB1dHMgZnJvbSBjb21wbGV0ZWQgd29ya2Zsb3cgc3RlcHMgaWYgdGhleSBhcmUgbm8gbG9uZ2VyIHJlcXVpcmVkIGFzIGlucHV0cy5cIlxuICAgICAgICB9KTtcbiAgICAgICAgZm9yICh2YXIgaSBpbiBub2RlLm91dHB1dF90ZXJtaW5hbHMpIHtcbiAgICAgICAgICAgIGlucHV0cy5wdXNoKF9tYWtlU2VjdGlvbihpLCBvcHRpb25zKSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgICBEZWZhdWx0OiBEZWZhdWx0LFxuICAgIFRvb2w6IFRvb2xcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gZ2FsYXh5L3NjcmlwdHMvbXZjL3dvcmtmbG93L3dvcmtmbG93LWZvcm1zLmpzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBOzs7QUFBQTtBQUNBOzs7QUFBQTtBQUNBOzs7QUFBQTtBQUNBOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBWEE7QUFhQTtBQWZBO0FBa0JBO0FBQ0E7QUFDQTtBQXpCQTtBQUNBO0FBMkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXBCQTtBQXNCQTtBQTVDQTtBQStDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBOUVBO0FBQ0E7QUFnRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQXZCQTtBQXlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUkE7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVNBO0FBOUNBO0FBckRBO0FBdUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFQQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///293\n");

/***/ }),

/***/ 294:
/*!****************************************!*\
  !*** ./galaxy/scripts/viz/circster.js ***!
  \****************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(Backbone, $) {\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _localization = __webpack_require__(/*! utils/localization */ 3);\n\nvar _localization2 = _interopRequireDefault(_localization);\n\nvar _underscore = __webpack_require__(/*! libs/underscore */ 1);\n\nvar _ = _interopRequireWildcard(_underscore);\n\nvar _d = __webpack_require__(/*! libs/d3 */ 295);\n\nvar d3 = _interopRequireWildcard(_d);\n\nvar _visualization = __webpack_require__(/*! viz/visualization */ 27);\n\nvar _visualization2 = _interopRequireDefault(_visualization);\n\nvar _utils = __webpack_require__(/*! utils/utils */ 4);\n\nvar _utils2 = _interopRequireDefault(_utils);\n\nvar _config = __webpack_require__(/*! utils/config */ 37);\n\nvar _config2 = _interopRequireDefault(_config);\n\nvar _iconButton = __webpack_require__(/*! mvc/ui/icon-button */ 41);\n\nvar _iconButton2 = _interopRequireDefault(_iconButton);\n\n__webpack_require__(/*! libs/farbtastic */ 40);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Utility class for working with SVG.\n */\n\nvar SVGUtils = Backbone.Model.extend({\n    /**\n     * Returns true if element is visible.\n     */\n    is_visible: function is_visible(svg_elt, svg) {\n        var eltBRect = svg_elt.getBoundingClientRect();\n        var svgBRect = $(\"svg\")[0].getBoundingClientRect();\n\n        if (\n        // To the left of screen?\n        eltBRect.right < 0 ||\n        // To the right of screen?\n        eltBRect.left > svgBRect.right ||\n        // Above screen?\n        eltBRect.bottom < 0 ||\n        // Below screen?\n        eltBRect.top > svgBRect.bottom) {\n            return false;\n        }\n        return true;\n    }\n});\n\n/**\n * Mixin for using ticks.\n */\nvar UsesTicks = {\n    drawTicks: function drawTicks(parent_elt, data, dataHandler, textTransform, horizontal) {\n        // Set up group elements for chroms and for each tick.\n        var ticks = parent_elt.append(\"g\").selectAll(\"g\").data(data).enter().append(\"g\").selectAll(\"g\").data(dataHandler).enter().append(\"g\").attr(\"class\", \"tick\").attr(\"transform\", function (d) {\n            return \"rotate(\" + (d.angle * 180 / Math.PI - 90) + \")translate(\" + d.radius + \",0)\";\n        });\n\n        // Add line + text for ticks.\n        var tick_coords = [];\n\n        var text_coords = [];\n\n        var text_anchor = function text_anchor(d) {\n            return d.angle > Math.PI ? \"end\" : null;\n        };\n\n        if (horizontal) {\n            tick_coords = [0, 0, 0, -4];\n            text_coords = [4, 0, \"\", \".35em\"];\n            text_anchor = null;\n        } else {\n            tick_coords = [1, 0, 4, 0];\n            text_coords = [0, 4, \".35em\", \"\"];\n        }\n\n        ticks.append(\"line\").attr(\"x1\", tick_coords[0]).attr(\"y1\", tick_coords[1]).attr(\"x2\", tick_coords[2]).attr(\"y1\", tick_coords[3]).style(\"stroke\", \"#000\");\n\n        return ticks.append(\"text\").attr(\"x\", text_coords[0]).attr(\"y\", text_coords[1]).attr(\"dx\", text_coords[2]).attr(\"dy\", text_coords[3]).attr(\"text-anchor\", text_anchor).attr(\"transform\", textTransform).text(function (d) {\n            return d.label;\n        });\n    },\n\n    /**\n     * Format number for display at a tick.\n     */\n    formatNum: function formatNum(num, sigDigits) {\n        // Use default of 2 sig. digits.\n        if (sigDigits === undefined) sigDigits = 2;\n\n        // Verify input number\n        if (num === null) return null;\n\n        // Calculate return value\n        var rval = null;\n        if (Math.abs(num) < 1) {\n            rval = num.toPrecision(sigDigits);\n        } else {\n            // Use round to turn string from toPrecision() back into a number.\n            var roundedNum = Math.round(num.toPrecision(sigDigits));\n\n            // Use abbreviations.\n            num = Math.abs(num);\n            if (num < 1000) {\n                rval = roundedNum;\n            } else if (num < 1000000) {\n                // Use K.\n                rval = Math.round((roundedNum / 1000).toPrecision(3)).toFixed(0) + \"K\";\n            } else if (num < 1000000000) {\n                // Use M.\n                rval = Math.round((roundedNum / 1000000).toPrecision(3)).toFixed(0) + \"M\";\n            }\n        }\n\n        return rval;\n    }\n};\n\n/**\n * A label track.\n */\nvar CircsterLabelTrack = Backbone.Model.extend({});\n\n/**\n * Renders a full circster visualization.\n */\nvar CircsterView = Backbone.View.extend({\n    className: \"circster\",\n\n    initialize: function initialize(options) {\n        this.genome = options.genome;\n        this.label_arc_height = 50;\n        this.scale = 1;\n        this.circular_views = null;\n        this.chords_views = null;\n\n        // When tracks added to/removed from model, update view.\n        this.model.get(\"drawables\").on(\"add\", this.add_track, this);\n        this.model.get(\"drawables\").on(\"remove\", this.remove_track, this);\n\n        // When config settings change, update view.\n        var vis_config = this.model.get(\"config\");\n        vis_config.get(\"arc_dataset_height\").on(\"change:value\", this.update_track_bounds, this);\n        vis_config.get(\"track_gap\").on(\"change:value\", this.update_track_bounds, this);\n    },\n\n    // HACKs: using track_type for circular/chord distinction in the functions below for now.\n\n    /**\n     * Returns tracks to be rendered using circular view.\n     */\n    get_circular_tracks: function get_circular_tracks() {\n        return this.model.get(\"drawables\").filter(function (track) {\n            return track.get(\"track_type\") !== \"DiagonalHeatmapTrack\";\n        });\n    },\n\n    /**\n     * Returns tracks to be rendered using chords view.\n     */\n    get_chord_tracks: function get_chord_tracks() {\n        return this.model.get(\"drawables\").filter(function (track) {\n            return track.get(\"track_type\") === \"DiagonalHeatmapTrack\";\n        });\n    },\n\n    /**\n     * Returns a list of circular tracks' radius bounds.\n     */\n    get_tracks_bounds: function get_tracks_bounds() {\n        var circular_tracks = this.get_circular_tracks();\n\n        var dataset_arc_height = this.model.get(\"config\").get_value(\"arc_dataset_height\");\n\n        var track_gap = this.model.get(\"config\").get_value(\"track_gap\");\n\n        var // Subtract 20 to make sure chrom labels are on screen.\n        min_dimension = Math.min(this.$el.width(), this.$el.height()) - 20;\n\n        var // Compute radius start based on model, will be centered\n        // and fit entirely inside element by default.\n        radius_start = min_dimension / 2 - circular_tracks.length * (dataset_arc_height + track_gap) +\n        // Add track_gap back in because no gap is needed for last track.\n        track_gap - this.label_arc_height;\n\n        var // Compute range of track starting radii.\n        tracks_start_radii = d3.range(radius_start, min_dimension / 2, dataset_arc_height + track_gap);\n\n        // Map from track start to bounds.\n        var self = this;\n        return _.map(tracks_start_radii, function (radius) {\n            return [radius, radius + dataset_arc_height];\n        });\n    },\n\n    /**\n     * Renders circular tracks, chord tracks, and label tracks.\n     */\n    render: function render() {\n        var self = this;\n        var width = self.$el.width();\n        var height = self.$el.height();\n        var circular_tracks = this.get_circular_tracks();\n        var chords_tracks = this.get_chord_tracks();\n        var total_gap = self.model.get(\"config\").get_value(\"total_gap\");\n        var tracks_bounds = this.get_tracks_bounds();\n\n        var // Set up SVG element.\n        svg = d3.select(self.$el[0]).append(\"svg\").attr(\"width\", width).attr(\"height\", height).attr(\"pointer-events\", \"all\")\n        // Set up zooming, dragging.\n        .append(\"svg:g\").call(d3.behavior.zoom().on(\"zoom\", function () {\n            // Do zoom, drag.\n            var scale = d3.event.scale;\n            svg.attr(\"transform\", \"translate(\" + d3.event.translate + \") scale(\" + scale + \")\");\n\n            // Propagate scale changes to views.\n            if (self.scale !== scale) {\n                // Use timeout to wait for zooming/dragging to stop before rendering more detail.\n                if (self.zoom_drag_timeout) {\n                    clearTimeout(self.zoom_drag_timeout);\n                }\n                self.zoom_drag_timeout = setTimeout(function () {\n                    // Render more detail in tracks' visible elements.\n                    // FIXME: do not do this right now; it is not fully implemented--e.g. data bounds\n                    // are not updated when new data is fetched--and fetching more detailed quantitative\n                    // data is not that useful.\n                    /*\n                    _.each(self.circular_views, function(view) {\n                    view.update_scale(scale);\n                    });\n                    */\n                }, 400);\n            }\n        })).attr(\"transform\", \"translate(\" + width / 2 + \",\" + height / 2 + \")\").append(\"svg:g\").attr(\"class\", \"tracks\");\n\n        // -- Render circular tracks. --\n\n        // Create a view for each track in the visualization and render.\n        this.circular_views = circular_tracks.map(function (track, index) {\n            var view = new CircsterBigWigTrackView({\n                el: svg.append(\"g\")[0],\n                track: track,\n                radius_bounds: tracks_bounds[index],\n                genome: self.genome,\n                total_gap: total_gap\n            });\n\n            view.render();\n\n            return view;\n        });\n\n        // -- Render chords tracks. --\n\n        this.chords_views = chords_tracks.map(function (track) {\n            var view = new CircsterChromInteractionsTrackView({\n                el: svg.append(\"g\")[0],\n                track: track,\n                radius_bounds: tracks_bounds[0],\n                genome: self.genome,\n                total_gap: total_gap\n            });\n\n            view.render();\n\n            return view;\n        });\n\n        // -- Render label track. --\n\n        // Track bounds are:\n        // (a) outer radius of last circular track;\n        // (b)\n        var outermost_radius = this.circular_views[this.circular_views.length - 1].radius_bounds[1];\n\n        var track_bounds = [outermost_radius, outermost_radius + this.label_arc_height];\n\n        this.label_track_view = new CircsterChromLabelTrackView({\n            el: svg.append(\"g\")[0],\n            track: new CircsterLabelTrack(),\n            radius_bounds: track_bounds,\n            genome: self.genome,\n            total_gap: total_gap\n        });\n\n        this.label_track_view.render();\n    },\n\n    /**\n     * Render a single track on the outside of the current visualization.\n     */\n    add_track: function add_track(new_track) {\n        var total_gap = this.model.get(\"config\").get_value(\"total_gap\");\n\n        if (new_track.get(\"track_type\") === \"DiagonalHeatmapTrack\") {\n            // Added chords track.\n            var innermost_radius_bounds = this.circular_views[0].radius_bounds;\n\n            var new_view = new CircsterChromInteractionsTrackView({\n                el: d3.select(\"g.tracks\").append(\"g\")[0],\n                track: new_track,\n                radius_bounds: innermost_radius_bounds,\n                genome: this.genome,\n                total_gap: total_gap\n            });\n\n            new_view.render();\n            this.chords_views.push(new_view);\n        } else {\n            // Added circular track.\n\n            // Recompute and update circular track bounds.\n            var new_track_bounds = this.get_tracks_bounds();\n            _.each(this.circular_views, function (track_view, i) {\n                track_view.update_radius_bounds(new_track_bounds[i]);\n            });\n\n            // Update chords tracks.\n            _.each(this.chords_views, function (track_view) {\n                track_view.update_radius_bounds(new_track_bounds[0]);\n            });\n\n            // Render new track.\n            var track_index = this.circular_views.length;\n\n            var track_view = new CircsterBigWigTrackView({\n                el: d3.select(\"g.tracks\").append(\"g\")[0],\n                track: new_track,\n                radius_bounds: new_track_bounds[track_index],\n                genome: this.genome,\n                total_gap: total_gap\n            });\n\n            track_view.render();\n            this.circular_views.push(track_view);\n\n            // Update label track.\n            /*\n            FIXME: should never have to update label track because vis always expands to fit area\n            within label track.\n            var track_bounds = new_track_bounds[ new_track_bounds.length-1 ];\n            track_bounds[1] = track_bounds[0];\n            this.label_track_view.update_radius_bounds(track_bounds);\n            */\n        }\n    },\n\n    /**\n     * Remove a track from the view.\n     */\n    remove_track: function remove_track(track, tracks, options) {\n        // -- Remove track from view. --\n        var track_view = this.circular_views[options.index];\n        this.circular_views.splice(options.index, 1);\n        track_view.$el.remove();\n\n        // Recompute and update track bounds.\n        var new_track_bounds = this.get_tracks_bounds();\n        _.each(this.circular_views, function (track_view, i) {\n            track_view.update_radius_bounds(new_track_bounds[i]);\n        });\n    },\n\n    update_track_bounds: function update_track_bounds() {\n        // Recompute and update track bounds.\n        var new_track_bounds = this.get_tracks_bounds();\n        _.each(this.circular_views, function (track_view, i) {\n            track_view.update_radius_bounds(new_track_bounds[i]);\n        });\n\n        // Update chords tracks.\n        _.each(this.chords_views, function (track_view) {\n            track_view.update_radius_bounds(new_track_bounds[0]);\n        });\n    }\n});\n\n/**\n * Renders a track in a Circster visualization.\n */\nvar CircsterTrackView = Backbone.View.extend({\n    tagName: \"g\",\n\n    /* ----------------------- Public Methods ------------------------- */\n\n    initialize: function initialize(options) {\n        this.bg_stroke = \"#ddd\";\n        // Fill color when loading data.\n        this.loading_bg_fill = \"#ffc\";\n        // Fill color when data has been loaded.\n        this.bg_fill = \"#ddd\";\n        this.total_gap = options.total_gap;\n        this.track = options.track;\n        this.radius_bounds = options.radius_bounds;\n        this.genome = options.genome;\n        this.chroms_layout = this._chroms_layout();\n        this.data_bounds = [];\n        this.scale = 1;\n        this.parent_elt = d3.select(this.$el[0]);\n    },\n\n    /**\n     * Get fill color from config.\n     */\n    get_fill_color: function get_fill_color() {\n        var color = this.track.get(\"config\").get_value(\"block_color\");\n        if (!color) {\n            color = this.track.get(\"config\").get_value(\"color\");\n        }\n        return color;\n    },\n\n    /**\n     * Render track's data by adding SVG elements to parent.\n     */\n    render: function render() {\n        // -- Create track group element. --\n        var track_parent_elt = this.parent_elt;\n\n        // -- Render background arcs. --\n        var genome_arcs = this.chroms_layout;\n\n        var arc_gen = d3.svg.arc().innerRadius(this.radius_bounds[0]).outerRadius(this.radius_bounds[1]);\n\n        var // Attach data to group element.\n        chroms_elts = track_parent_elt.selectAll(\"g\").data(genome_arcs).enter().append(\"svg:g\");\n\n        var // Draw chrom arcs/paths.\n        chroms_paths = chroms_elts.append(\"path\").attr(\"d\", arc_gen).attr(\"class\", \"chrom-background\").style(\"stroke\", this.bg_stroke).style(\"fill\", this.loading_bg_fill);\n\n        // Append titles to paths.\n        chroms_paths.append(\"title\").text(function (d) {\n            return d.data.chrom;\n        });\n\n        // -- Render track data and, when track data is rendered, apply preferences and update chrom_elts fill. --\n\n        var self = this;\n\n        var data_manager = self.track.get(\"data_manager\");\n\n        var // If track has a data manager, get deferred that resolves when data is ready.\n        data_ready_deferred = data_manager ? data_manager.data_is_ready() : true;\n\n        // When data is ready, render track.\n        $.when(data_ready_deferred).then(function () {\n            $.when(self._render_data(track_parent_elt)).then(function () {\n                chroms_paths.style(\"fill\", self.bg_fill);\n\n                // Render labels after data is available so that data attributes are available.\n                self.render_labels();\n            });\n        });\n    },\n\n    /**\n     * Render track labels.\n     */\n    render_labels: function render_labels() {},\n\n    /**\n     * Update radius bounds.\n     */\n    update_radius_bounds: function update_radius_bounds(radius_bounds) {\n        // Update bounds.\n        this.radius_bounds = radius_bounds;\n\n        // -- Update background arcs. --\n        var new_d = d3.svg.arc().innerRadius(this.radius_bounds[0]).outerRadius(this.radius_bounds[1]);\n\n        this.parent_elt.selectAll(\"g>path.chrom-background\").transition().duration(1000).attr(\"d\", new_d);\n\n        this._transition_chrom_data();\n\n        this._transition_labels();\n    },\n\n    /**\n     * Update view scale. This fetches more data if scale is increased.\n     */\n    update_scale: function update_scale(new_scale) {\n        // -- Update scale and return if new scale is less than old scale. --\n\n        var old_scale = this.scale;\n        this.scale = new_scale;\n        if (new_scale <= old_scale) {\n            return;\n        }\n\n        // -- Scale increased, so render visible data with more detail. --\n\n        var self = this;\n\n        var utils = new SVGUtils();\n\n        // Select all chrom data and filter to operate on those that are visible.\n        this.parent_elt.selectAll(\"path.chrom-data\").filter(function (d, i) {\n            return utils.is_visible(this);\n        }).each(function (d, i) {\n            // -- Now operating on a single path element representing chromosome data. --\n\n            var path_elt = d3.select(this);\n\n            var chrom = path_elt.attr(\"chrom\");\n            var chrom_region = self.genome.get_chrom_region(chrom);\n            var data_manager = self.track.get(\"data_manager\");\n            var data_deferred;\n\n            // If can't get more detailed data, return.\n            if (!data_manager.can_get_more_detailed_data(chrom_region)) {\n                return;\n            }\n\n            // -- Get more detailed data. --\n            data_deferred = self.track.get(\"data_manager\").get_more_detailed_data(chrom_region, \"Coverage\", 0, new_scale);\n\n            // When more data is available, use new data to redraw path.\n            $.when(data_deferred).then(function (data) {\n                // Remove current data path.\n                path_elt.remove();\n\n                // Update data bounds with new data.\n                self._update_data_bounds();\n\n                // Find chromosome arc to draw data on.\n                var chrom_arc = _.find(self.chroms_layout, function (layout) {\n                    return layout.data.chrom === chrom;\n                });\n\n                // Add new data path and apply preferences.\n                var color = self.get_fill_color();\n                self._render_chrom_data(self.parent_elt, chrom_arc, data).style(\"stroke\", color).style(\"fill\", color);\n            });\n        });\n\n        return self;\n    },\n\n    /* ----------------------- Internal Methods ------------------------- */\n\n    /**\n     * Transitions chrom data to new values (e.g new radius or data bounds).\n     */\n    _transition_chrom_data: function _transition_chrom_data() {\n        var track = this.track;\n        var chrom_arcs = this.chroms_layout;\n        var chrom_data_paths = this.parent_elt.selectAll(\"g>path.chrom-data\");\n        var num_paths = chrom_data_paths[0].length;\n\n        if (num_paths > 0) {\n            var self = this;\n            $.when(track.get(\"data_manager\").get_genome_wide_data(this.genome)).then(function (genome_wide_data) {\n                // Map chrom data to path data, filtering out null values.\n                var path_data = _.reject(_.map(genome_wide_data, function (chrom_data, i) {\n                    var rval = null;\n\n                    var path_fn = self._get_path_function(chrom_arcs[i], chrom_data);\n\n                    if (path_fn) {\n                        rval = path_fn(chrom_data.data);\n                    }\n                    return rval;\n                }), function (p_data) {\n                    return p_data === null;\n                });\n\n                // Transition each path for data and color.\n                var color = track.get(\"config\").get_value(\"color\");\n                chrom_data_paths.each(function (path, index) {\n                    d3.select(this).transition().duration(1000).style(\"stroke\", color).style(\"fill\", color).attr(\"d\", path_data[index]);\n                });\n            });\n        }\n    },\n\n    /**\n     * Transition labels to new values (e.g new radius or data bounds).\n     */\n    _transition_labels: function _transition_labels() {},\n\n    /**\n     * Update data bounds. If there are new_bounds, use them; otherwise use\n     * default data bounds.\n     */\n    _update_data_bounds: function _update_data_bounds(new_bounds) {\n        var old_bounds = this.data_bounds;\n        this.data_bounds = new_bounds || this.get_data_bounds(this.track.get(\"data_manager\").get_genome_wide_data(this.genome));\n        this._transition_chrom_data();\n    },\n\n    /**\n     * Render data as elements attached to svg.\n     */\n    _render_data: function _render_data(svg) {\n        var self = this;\n        var chrom_arcs = this.chroms_layout;\n        var track = this.track;\n        var rendered_deferred = $.Deferred();\n\n        // When genome-wide data is available, render data.\n        $.when(track.get(\"data_manager\").get_genome_wide_data(this.genome)).then(function (genome_wide_data) {\n            // Set bounds.\n            self.data_bounds = self.get_data_bounds(genome_wide_data);\n\n            // Set min, max value in config so that they can be adjusted. Make this silent\n            // because these attributes are watched for changes and the viz is updated\n            // accordingly (set up in initialize). Because we are setting up, we don't want\n            // the watch to trigger events here.\n            track.get(\"config\").set_value(\"min_value\", self.data_bounds[0], {\n                silent: true\n            });\n            track.get(\"config\").set_value(\"max_value\", self.data_bounds[1], {\n                silent: true\n            });\n\n            // Merge chroms layout with data.\n            var layout_and_data = _.zip(chrom_arcs, genome_wide_data);\n\n            // Render each chromosome's data.\n            _.each(layout_and_data, function (chrom_info) {\n                var chrom_arc = chrom_info[0];\n                var data = chrom_info[1];\n                return self._render_chrom_data(svg, chrom_arc, data);\n            });\n\n            // Apply prefs to all track data.\n            var color = self.get_fill_color();\n            self.parent_elt.selectAll(\"path.chrom-data\").style(\"stroke\", color).style(\"fill\", color);\n\n            rendered_deferred.resolve(svg);\n        });\n\n        return rendered_deferred;\n    },\n\n    /**\n     * Render a chromosome data and attach elements to svg.\n     */\n    _render_chrom_data: function _render_chrom_data(svg, chrom_arc, data) {},\n\n    /**\n     * Returns data for creating a path for the given data using chrom_arc and data bounds.\n     */\n    _get_path_function: function _get_path_function(chrom_arc, chrom_data) {},\n\n    /**\n     * Returns arc layouts for genome's chromosomes/contigs. Arcs are arranged in a circle\n     * separated by gaps.\n     */\n    _chroms_layout: function _chroms_layout() {\n        // Setup chroms layout using pie.\n        var chroms_info = this.genome.get_chroms_info();\n\n        var pie_layout = d3.layout.pie().value(function (d) {\n            return d.len;\n        }).sort(null);\n\n        var init_arcs = pie_layout(chroms_info);\n        var gap_per_chrom = 2 * Math.PI * this.total_gap / chroms_info.length;\n\n        var chrom_arcs = _.map(init_arcs, function (arc, index) {\n            // For short chroms, endAngle === startAngle.\n            var new_endAngle = arc.endAngle - gap_per_chrom;\n            arc.endAngle = new_endAngle > arc.startAngle ? new_endAngle : arc.startAngle;\n            return arc;\n        });\n\n        return chrom_arcs;\n    }\n});\n\n/**\n * Render chromosome labels.\n */\nvar CircsterChromLabelTrackView = CircsterTrackView.extend({\n    initialize: function initialize(options) {\n        CircsterTrackView.prototype.initialize.call(this, options);\n        // Use a single arc for rendering data.\n        this.innerRadius = this.radius_bounds[0];\n        this.radius_bounds[0] = this.radius_bounds[1];\n        this.bg_stroke = \"#fff\";\n        this.bg_fill = \"#fff\";\n\n        // Minimum arc distance for labels to be applied.\n        this.min_arc_len = 0.05;\n    },\n\n    /**\n     * Render labels.\n     */\n    _render_data: function _render_data(svg) {\n        // -- Add chromosome label where it will fit; an alternative labeling mechanism\n        // would be nice for small chromosomes. --\n        var self = this;\n\n        var chrom_arcs = svg.selectAll(\"g\");\n\n        chrom_arcs.selectAll(\"path\").attr(\"id\", function (d) {\n            return \"label-\" + d.data.chrom;\n        });\n\n        chrom_arcs.append(\"svg:text\").filter(function (d) {\n            return d.endAngle - d.startAngle > self.min_arc_len;\n        }).attr(\"text-anchor\", \"middle\").append(\"svg:textPath\").attr(\"class\", \"chrom-label\").attr(\"xlink:href\", function (d) {\n            return \"#label-\" + d.data.chrom;\n        }).attr(\"startOffset\", \"25%\").text(function (d) {\n            return d.data.chrom;\n        });\n\n        // -- Add ticks to denote chromosome length. --\n\n        /** Returns an array of tick angles and labels, given a chrom arc. */\n        var chromArcTicks = function chromArcTicks(d) {\n            var k = (d.endAngle - d.startAngle) / d.value;\n\n            var ticks = d3.range(0, d.value, 25000000).map(function (v, i) {\n                return {\n                    radius: self.innerRadius,\n                    angle: v * k + d.startAngle,\n                    label: i === 0 ? 0 : i % 3 ? null : self.formatNum(v)\n                };\n            });\n\n            // If there are fewer that 4 ticks, label last tick so that at least one non-zero tick is labeled.\n            if (ticks.length < 4) {\n                ticks[ticks.length - 1].label = self.formatNum(Math.round((ticks[ticks.length - 1].angle - d.startAngle) / k));\n            }\n\n            return ticks;\n        };\n\n        /** Rotate and move text as needed. */\n        var textTransform = function textTransform(d) {\n            return d.angle > Math.PI ? \"rotate(180)translate(-16)\" : null;\n        };\n\n        // Filter chroms for only those large enough for display.\n        var visibleChroms = _.filter(this.chroms_layout, function (c) {\n            return c.endAngle - c.startAngle > self.min_arc_len;\n        });\n\n        this.drawTicks(this.parent_elt, visibleChroms, chromArcTicks, textTransform);\n    }\n});\n_.extend(CircsterChromLabelTrackView.prototype, UsesTicks);\n\n/**\n * View for quantitative track in Circster.\n */\nvar CircsterQuantitativeTrackView = CircsterTrackView.extend({\n    initialize: function initialize(options) {\n        CircsterTrackView.prototype.initialize.call(this, options);\n\n        // When config settings change, update view.\n        var track_config = this.track.get(\"config\");\n        track_config.get(\"min_value\").on(\"change:value\", this._update_min_max, this);\n        track_config.get(\"max_value\").on(\"change:value\", this._update_min_max, this);\n        track_config.get(\"color\").on(\"change:value\", this._transition_chrom_data, this);\n    },\n\n    /**\n     * Update track when min and/or max are changed.\n     */\n    _update_min_max: function _update_min_max() {\n        var track_config = this.track.get(\"config\");\n\n        var new_bounds = [track_config.get_value(\"min_value\"), track_config.get_value(\"max_value\")];\n\n        this._update_data_bounds(new_bounds);\n\n        // FIXME: this works to update tick/text bounds, but there's probably a better way to do this\n        // by updating the data itself.\n        this.parent_elt.selectAll(\".min_max\").text(function (d, i) {\n            return new_bounds[i];\n        });\n    },\n\n    /**\n     * Returns quantile for an array of numbers.\n     */\n    _quantile: function _quantile(numbers, quantile) {\n        numbers.sort(d3.ascending);\n        return d3.quantile(numbers, quantile);\n    },\n\n    /**\n     * Renders quantitative data with the form [x, value] and assumes data is equally spaced across\n     * chromosome. Attachs a dict with track and chrom name information to DOM element.\n     */\n    _render_chrom_data: function _render_chrom_data(svg, chrom_arc, chrom_data) {\n        var path_data = this._get_path_function(chrom_arc, chrom_data);\n\n        if (!path_data) {\n            return null;\n        }\n\n        // There is path data, so render as path.\n        var parent = svg.datum(chrom_data.data);\n\n        var path = parent.append(\"path\").attr(\"class\", \"chrom-data\").attr(\"chrom\", chrom_arc.data.chrom).attr(\"d\", path_data);\n\n        return path;\n    },\n\n    /**\n     * Returns function for creating a path across the chrom arc.\n     */\n    _get_path_function: function _get_path_function(chrom_arc, chrom_data) {\n        // If no chrom data, return null.\n        if (typeof chrom_data === \"string\" || !chrom_data.data || chrom_data.data.length === 0) {\n            return null;\n        }\n\n        // Radius scaler.\n        var radius = d3.scale.linear().domain(this.data_bounds).range(this.radius_bounds).clamp(true);\n\n        // Scaler for placing data points across arc.\n        var angle = d3.scale.linear().domain([0, chrom_data.data.length]).range([chrom_arc.startAngle, chrom_arc.endAngle]);\n\n        // Use line generator to create area.\n        var line = d3.svg.line.radial().interpolate(\"linear\").radius(function (d) {\n            return radius(d[1]);\n        }).angle(function (d, i) {\n            return angle(i);\n        });\n\n        return d3.svg.area.radial().interpolate(line.interpolate()).innerRadius(radius(0)).outerRadius(line.radius()).angle(line.angle());\n    },\n\n    /**\n     * Render track min, max using ticks.\n     */\n    render_labels: function render_labels() {\n        var self = this;\n\n        var // Keep counter of visible chroms.\n        textTransform = function textTransform() {\n            return \"rotate(90)\";\n        };\n\n        // FIXME:\n        // (1) using min_max class below is needed for _update_min_max, which could be improved.\n        // (2) showing config on tick click should be replaced by proper track config icon.\n\n        // Draw min, max on first chrom only.\n        var ticks = this.drawTicks(this.parent_elt, [this.chroms_layout[0]], this._data_bounds_ticks_fn(), textTransform, true).classed(\"min_max\", true);\n\n        // Show config when ticks are clicked on.\n        _.each(ticks, function (tick) {\n            $(tick).click(function () {\n                var view = new _config2.default.ConfigSettingCollectionView({\n                    collection: self.track.get(\"config\")\n                });\n                view.render_in_modal(\"Configure Track\");\n            });\n        });\n\n        /*\n        // Filter for visible chroms, then for every third chrom so that labels attached to only every\n        // third chrom.\n        var visibleChroms = _.filter(this.chroms_layout, function(c) { return c.endAngle - c.startAngle > 0.08; }),\n            labeledChroms = _.filter(visibleChroms, function(c, i) { return i % 3 === 0; });\n        this.drawTicks(this.parent_elt, labeledChroms, this._data_bounds_ticks_fn(), textTransform, true);\n        */\n    },\n\n    /**\n     * Transition labels to new values (e.g new radius or data bounds).\n     */\n    _transition_labels: function _transition_labels() {\n        // FIXME: (a) pull out function for getting labeled chroms? and (b) function used in transition below\n        // is copied from UseTicks mixin, so pull out and make generally available.\n\n        // If there are no data bounds, nothing to transition.\n        if (this.data_bounds.length === 0) {\n            return;\n        }\n\n        // Transition labels to new radius bounds.\n        var self = this;\n\n        var visibleChroms = _.filter(this.chroms_layout, function (c) {\n            return c.endAngle - c.startAngle > 0.08;\n        });\n\n        var labeledChroms = _.filter(visibleChroms, function (c, i) {\n            return i % 3 === 0;\n        });\n\n        var new_data = _.flatten(_.map(labeledChroms, function (c) {\n            return self._data_bounds_ticks_fn()(c);\n        }));\n\n        this.parent_elt.selectAll(\"g.tick\").data(new_data).transition().attr(\"transform\", function (d) {\n            return \"rotate(\" + (d.angle * 180 / Math.PI - 90) + \")translate(\" + d.radius + \",0)\";\n        });\n    },\n\n    /**\n     * Get function for locating data bounds ticks.\n     */\n    _data_bounds_ticks_fn: function _data_bounds_ticks_fn() {\n        // Closure vars.\n        var self = this;\n        visibleChroms = 0;\n\n        // Return function for locating ticks based on chrom arc data.\n        return function (d // Set up data to display min, max ticks.\n        ) {\n            return [{\n                radius: self.radius_bounds[0],\n                angle: d.startAngle,\n                label: self.formatNum(self.data_bounds[0])\n            }, {\n                radius: self.radius_bounds[1],\n                angle: d.startAngle,\n                label: self.formatNum(self.data_bounds[1])\n            }];\n        };\n    },\n\n    /**\n     * Returns an array with two values denoting the minimum and maximum\n     * values for the track.\n     */\n    get_data_bounds: function get_data_bounds(data) {}\n});\n_.extend(CircsterQuantitativeTrackView.prototype, UsesTicks);\n\n/**\n * Bigwig track view in Circster.\n */\nvar CircsterBigWigTrackView = CircsterQuantitativeTrackView.extend({\n    get_data_bounds: function get_data_bounds(data) {\n        // Set max across dataset by extracting all values, flattening them into a\n        // single array, and getting third quartile.\n        var values = _.flatten(_.map(data, function (d) {\n            if (d) {\n                // Each data point has the form [position, value], so return all values.\n                return _.map(d.data, function (p // Null is used for a lack of data; resolve null to 0 for comparison.\n                ) {\n                    return parseInt(p[1], 10) || 0;\n                });\n            } else {\n                return 0;\n            }\n        }));\n\n        // For max, use 98% quantile in attempt to avoid very large values. However, this max may be 0\n        // for sparsely populated data, so use max in that case.\n        return [_.min(values), this._quantile(values, 0.98) || _.max(values)];\n    }\n});\n\n/**\n * Chromosome interactions track view in Circster.\n */\nvar CircsterChromInteractionsTrackView = CircsterTrackView.extend({\n    render: function render() {\n        var self = this;\n\n        // When data is ready, render track.\n        $.when(self.track.get(\"data_manager\").data_is_ready()).then(function () {\n            // When data has been fetched, render track.\n            $.when(self.track.get(\"data_manager\").get_genome_wide_data(self.genome)).then(function (genome_wide_data) {\n                var chord_data = [];\n                var chroms_info = self.genome.get_chroms_info();\n                // Convert chromosome data into chord data.\n                _.each(genome_wide_data, function (chrom_data, index) {\n                    // Map each interaction into chord data.\n                    var cur_chrom = chroms_info[index].chrom;\n                    var chrom_chord_data = _.map(chrom_data.data, function (datum) {\n                        // Each datum is an interaction/chord.\n                        var source_angle = self._get_region_angle(cur_chrom, datum[1]);\n\n                        var target_angle = self._get_region_angle(datum[3], datum[4]);\n\n                        return {\n                            source: {\n                                startAngle: source_angle,\n                                endAngle: source_angle + 0.01\n                            },\n                            target: {\n                                startAngle: target_angle,\n                                endAngle: target_angle + 0.01\n                            }\n                        };\n                    });\n\n                    chord_data = chord_data.concat(chrom_chord_data);\n                });\n\n                self.parent_elt.append(\"g\").attr(\"class\", \"chord\").selectAll(\"path\").data(chord_data).enter().append(\"path\").style(\"fill\", self.get_fill_color()).attr(\"d\", d3.svg.chord().radius(self.radius_bounds[0])).style(\"opacity\", 1);\n            });\n        });\n    },\n\n    update_radius_bounds: function update_radius_bounds(radius_bounds) {\n        this.radius_bounds = radius_bounds;\n        this.parent_elt.selectAll(\"path\").transition().attr(\"d\", d3.svg.chord().radius(this.radius_bounds[0]));\n    },\n\n    /**\n     * Returns radians for a genomic position.\n     */\n    _get_region_angle: function _get_region_angle(chrom, position) {\n        // Find chrom angle data\n        var chrom_angle_data = _.find(this.chroms_layout, function (chrom_layout) {\n            return chrom_layout.data.chrom === chrom;\n        });\n\n        // Return angle at position.\n        return chrom_angle_data.endAngle - (chrom_angle_data.endAngle - chrom_angle_data.startAngle) * (chrom_angle_data.data.len - position) / chrom_angle_data.data.len;\n    }\n});\n\n// circster app loader\nvar Circster = Backbone.View.extend({\n    initialize: function initialize() {\n        // load css\n        _utils2.default.cssLoadFile(\"static/style/circster.css\");\n        // -- Configure visualization --\n        var genome = new _visualization2.default.Genome(galaxy_config.app.genome);\n\n        var vis = new _visualization2.default.GenomeVisualization(galaxy_config.app.viz_config);\n\n        // Add Circster-specific config options.\n        vis.get(\"config\").add([{\n            key: \"arc_dataset_height\",\n            label: \"Arc Dataset Height\",\n            type: \"int\",\n            value: 25,\n            view: \"circster\"\n        }, {\n            key: \"track_gap\",\n            label: \"Gap Between Tracks\",\n            type: \"int\",\n            value: 5,\n            view: \"circster\"\n        }, {\n            key: \"total_gap\",\n            label: \"Gap [0-1]\",\n            type: \"float\",\n            value: 0.4,\n            view: \"circster\",\n            hidden: true\n        }]);\n\n        var viz_view = new CircsterView({\n            // view pane\n            el: $(\"#center .unified-panel-body\"),\n            genome: genome,\n            model: vis\n        });\n\n        // Render vizualization\n        viz_view.render();\n\n        // setup title\n        $(\"#center .unified-panel-header-inner\").append(galaxy_config.app.viz_config.title + \" \" + galaxy_config.app.viz_config.dbkey);\n\n        // setup menu\n        var menu = _iconButton2.default.create_icon_buttons_menu([{\n            icon_class: \"plus-button\",\n            title: (0, _localization2.default)(\"Add tracks\"),\n            on_click: function on_click() {\n                _visualization2.default.select_datasets({ dbkey: vis.get(\"dbkey\") }, function (tracks) {\n                    vis.add_tracks(tracks);\n                });\n            }\n        }, {\n            icon_class: \"gear\",\n            title: (0, _localization2.default)(\"Settings\"),\n            on_click: function on_click() {\n                var view = new _config2.default.ConfigSettingCollectionView({\n                    collection: vis.get(\"config\")\n                });\n                view.render_in_modal(\"Configure Visualization\");\n            }\n        }, {\n            icon_class: \"disk--arrow\",\n            title: (0, _localization2.default)(\"Save\"),\n            on_click: function on_click() {\n                // show saving dialog box\n                Galaxy.modal.show({\n                    title: (0, _localization2.default)(\"Saving...\"),\n                    body: \"progress\"\n                });\n\n                // send to server\n                $.ajax({\n                    url: Galaxy.root + \"visualization/save\",\n                    type: \"POST\",\n                    dataType: \"json\",\n                    data: {\n                        id: vis.get(\"vis_id\"),\n                        title: vis.get(\"title\"),\n                        dbkey: vis.get(\"dbkey\"),\n                        type: \"trackster\",\n                        vis_json: JSON.stringify(vis)\n                    }\n                }).success(function (vis_info) {\n                    Galaxy.modal.hide();\n                    vis.set(\"vis_id\", vis_info.vis_id);\n                }).error(function () {\n                    // show dialog\n                    Galaxy.modal.show({\n                        title: (0, _localization2.default)(\"Could Not Save\"),\n                        body: \"Could not save visualization. Please try again later.\",\n                        buttons: {\n                            Cancel: function Cancel() {\n                                Galaxy.modal.hide();\n                            }\n                        }\n                    });\n                });\n            }\n        }, {\n            icon_class: \"cross-circle\",\n            title: (0, _localization2.default)(\"Close\"),\n            on_click: function on_click() {\n                window.location = Galaxy.root + \"visualizations/list\";\n            }\n        }], { tooltip_config: { placement: \"bottom\" } });\n\n        // add menu\n        menu.$el.attr(\"style\", \"float: right\");\n        $(\"#center .unified-panel-header-inner\").append(menu.$el);\n\n        // manual tooltip config because default gravity is S and cannot be changed\n        $(\".menu-button\").tooltip({ placement: \"bottom\" });\n    }\n});\n\n// Module exports.\nexports.default = {\n    GalaxyApp: Circster\n};\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! libs/backbone */ 2), __webpack_require__(/*! jquery */ 0)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjk0LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL2dhbGF4eS9zY3JpcHRzL3Zpei9jaXJjc3Rlci5qcz84OWVhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBfbCBmcm9tIFwidXRpbHMvbG9jYWxpemF0aW9uXCI7XG5pbXBvcnQgKiBhcyBfIGZyb20gXCJsaWJzL3VuZGVyc2NvcmVcIjtcbmltcG9ydCAqIGFzIGQzIGZyb20gXCJsaWJzL2QzXCI7XG5pbXBvcnQgdmlzdWFsaXphdGlvbiBmcm9tIFwidml6L3Zpc3VhbGl6YXRpb25cIjtcbmltcG9ydCBtb2RfdXRpbHMgZnJvbSBcInV0aWxzL3V0aWxzXCI7XG5pbXBvcnQgY29uZmlnIGZyb20gXCJ1dGlscy9jb25maWdcIjtcbmltcG9ydCBtb2RfaWNvbl9idG4gZnJvbSBcIm12Yy91aS9pY29uLWJ1dHRvblwiO1xuaW1wb3J0IFwibGlicy9mYXJidGFzdGljXCI7XG4vKipcbiAqIFV0aWxpdHkgY2xhc3MgZm9yIHdvcmtpbmcgd2l0aCBTVkcuXG4gKi9cblxudmFyIFNWR1V0aWxzID0gQmFja2JvbmUuTW9kZWwuZXh0ZW5kKHtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgZWxlbWVudCBpcyB2aXNpYmxlLlxuICAgICAqL1xuICAgIGlzX3Zpc2libGU6IGZ1bmN0aW9uKHN2Z19lbHQsIHN2Zykge1xuICAgICAgICB2YXIgZWx0QlJlY3QgPSBzdmdfZWx0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB2YXIgc3ZnQlJlY3QgPSAkKFwic3ZnXCIpWzBdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIC8vIFRvIHRoZSBsZWZ0IG9mIHNjcmVlbj9cbiAgICAgICAgICAgIGVsdEJSZWN0LnJpZ2h0IDwgMCB8fFxuICAgICAgICAgICAgLy8gVG8gdGhlIHJpZ2h0IG9mIHNjcmVlbj9cbiAgICAgICAgICAgIGVsdEJSZWN0LmxlZnQgPiBzdmdCUmVjdC5yaWdodCB8fFxuICAgICAgICAgICAgLy8gQWJvdmUgc2NyZWVuP1xuICAgICAgICAgICAgZWx0QlJlY3QuYm90dG9tIDwgMCB8fFxuICAgICAgICAgICAgLy8gQmVsb3cgc2NyZWVuP1xuICAgICAgICAgICAgZWx0QlJlY3QudG9wID4gc3ZnQlJlY3QuYm90dG9tXG4gICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn0pO1xuXG4vKipcbiAqIE1peGluIGZvciB1c2luZyB0aWNrcy5cbiAqL1xudmFyIFVzZXNUaWNrcyA9IHtcbiAgICBkcmF3VGlja3M6IGZ1bmN0aW9uKHBhcmVudF9lbHQsIGRhdGEsIGRhdGFIYW5kbGVyLCB0ZXh0VHJhbnNmb3JtLCBob3Jpem9udGFsKSB7XG4gICAgICAgIC8vIFNldCB1cCBncm91cCBlbGVtZW50cyBmb3IgY2hyb21zIGFuZCBmb3IgZWFjaCB0aWNrLlxuICAgICAgICB2YXIgdGlja3MgPSBwYXJlbnRfZWx0XG4gICAgICAgICAgICAuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgLnNlbGVjdEFsbChcImdcIilcbiAgICAgICAgICAgIC5kYXRhKGRhdGEpXG4gICAgICAgICAgICAuZW50ZXIoKVxuICAgICAgICAgICAgLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgIC5zZWxlY3RBbGwoXCJnXCIpXG4gICAgICAgICAgICAuZGF0YShkYXRhSGFuZGxlcilcbiAgICAgICAgICAgIC5lbnRlcigpXG4gICAgICAgICAgICAuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcInRpY2tcIilcbiAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIGQgPT4gYHJvdGF0ZSgke2QuYW5nbGUgKiAxODAgLyBNYXRoLlBJIC0gOTB9KXRyYW5zbGF0ZSgke2QucmFkaXVzfSwwKWApO1xuXG4gICAgICAgIC8vIEFkZCBsaW5lICsgdGV4dCBmb3IgdGlja3MuXG4gICAgICAgIHZhciB0aWNrX2Nvb3JkcyA9IFtdO1xuXG4gICAgICAgIHZhciB0ZXh0X2Nvb3JkcyA9IFtdO1xuXG4gICAgICAgIHZhciB0ZXh0X2FuY2hvciA9IGQgPT4gKGQuYW5nbGUgPiBNYXRoLlBJID8gXCJlbmRcIiA6IG51bGwpO1xuXG4gICAgICAgIGlmIChob3Jpem9udGFsKSB7XG4gICAgICAgICAgICB0aWNrX2Nvb3JkcyA9IFswLCAwLCAwLCAtNF07XG4gICAgICAgICAgICB0ZXh0X2Nvb3JkcyA9IFs0LCAwLCBcIlwiLCBcIi4zNWVtXCJdO1xuICAgICAgICAgICAgdGV4dF9hbmNob3IgPSBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGlja19jb29yZHMgPSBbMSwgMCwgNCwgMF07XG4gICAgICAgICAgICB0ZXh0X2Nvb3JkcyA9IFswLCA0LCBcIi4zNWVtXCIsIFwiXCJdO1xuICAgICAgICB9XG5cbiAgICAgICAgdGlja3NcbiAgICAgICAgICAgIC5hcHBlbmQoXCJsaW5lXCIpXG4gICAgICAgICAgICAuYXR0cihcIngxXCIsIHRpY2tfY29vcmRzWzBdKVxuICAgICAgICAgICAgLmF0dHIoXCJ5MVwiLCB0aWNrX2Nvb3Jkc1sxXSlcbiAgICAgICAgICAgIC5hdHRyKFwieDJcIiwgdGlja19jb29yZHNbMl0pXG4gICAgICAgICAgICAuYXR0cihcInkxXCIsIHRpY2tfY29vcmRzWzNdKVxuICAgICAgICAgICAgLnN0eWxlKFwic3Ryb2tlXCIsIFwiIzAwMFwiKTtcblxuICAgICAgICByZXR1cm4gdGlja3NcbiAgICAgICAgICAgIC5hcHBlbmQoXCJ0ZXh0XCIpXG4gICAgICAgICAgICAuYXR0cihcInhcIiwgdGV4dF9jb29yZHNbMF0pXG4gICAgICAgICAgICAuYXR0cihcInlcIiwgdGV4dF9jb29yZHNbMV0pXG4gICAgICAgICAgICAuYXR0cihcImR4XCIsIHRleHRfY29vcmRzWzJdKVxuICAgICAgICAgICAgLmF0dHIoXCJkeVwiLCB0ZXh0X2Nvb3Jkc1szXSlcbiAgICAgICAgICAgIC5hdHRyKFwidGV4dC1hbmNob3JcIiwgdGV4dF9hbmNob3IpXG4gICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCB0ZXh0VHJhbnNmb3JtKVxuICAgICAgICAgICAgLnRleHQoZCA9PiBkLmxhYmVsKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRm9ybWF0IG51bWJlciBmb3IgZGlzcGxheSBhdCBhIHRpY2suXG4gICAgICovXG4gICAgZm9ybWF0TnVtOiBmdW5jdGlvbihudW0sIHNpZ0RpZ2l0cykge1xuICAgICAgICAvLyBVc2UgZGVmYXVsdCBvZiAyIHNpZy4gZGlnaXRzLlxuICAgICAgICBpZiAoc2lnRGlnaXRzID09PSB1bmRlZmluZWQpIHNpZ0RpZ2l0cyA9IDI7XG5cbiAgICAgICAgLy8gVmVyaWZ5IGlucHV0IG51bWJlclxuICAgICAgICBpZiAobnVtID09PSBudWxsKSByZXR1cm4gbnVsbDtcblxuICAgICAgICAvLyBDYWxjdWxhdGUgcmV0dXJuIHZhbHVlXG4gICAgICAgIHZhciBydmFsID0gbnVsbDtcbiAgICAgICAgaWYgKE1hdGguYWJzKG51bSkgPCAxKSB7XG4gICAgICAgICAgICBydmFsID0gbnVtLnRvUHJlY2lzaW9uKHNpZ0RpZ2l0cyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBVc2Ugcm91bmQgdG8gdHVybiBzdHJpbmcgZnJvbSB0b1ByZWNpc2lvbigpIGJhY2sgaW50byBhIG51bWJlci5cbiAgICAgICAgICAgIHZhciByb3VuZGVkTnVtID0gTWF0aC5yb3VuZChudW0udG9QcmVjaXNpb24oc2lnRGlnaXRzKSk7XG5cbiAgICAgICAgICAgIC8vIFVzZSBhYmJyZXZpYXRpb25zLlxuICAgICAgICAgICAgbnVtID0gTWF0aC5hYnMobnVtKTtcbiAgICAgICAgICAgIGlmIChudW0gPCAxMDAwKSB7XG4gICAgICAgICAgICAgICAgcnZhbCA9IHJvdW5kZWROdW07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG51bSA8IDEwMDAwMDApIHtcbiAgICAgICAgICAgICAgICAvLyBVc2UgSy5cbiAgICAgICAgICAgICAgICBydmFsID0gYCR7TWF0aC5yb3VuZCgocm91bmRlZE51bSAvIDEwMDApLnRvUHJlY2lzaW9uKDMpKS50b0ZpeGVkKDApfUtgO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChudW0gPCAxMDAwMDAwMDAwKSB7XG4gICAgICAgICAgICAgICAgLy8gVXNlIE0uXG4gICAgICAgICAgICAgICAgcnZhbCA9IGAke01hdGgucm91bmQoKHJvdW5kZWROdW0gLyAxMDAwMDAwKS50b1ByZWNpc2lvbigzKSkudG9GaXhlZCgwKX1NYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBydmFsO1xuICAgIH1cbn07XG5cbi8qKlxuICogQSBsYWJlbCB0cmFjay5cbiAqL1xudmFyIENpcmNzdGVyTGFiZWxUcmFjayA9IEJhY2tib25lLk1vZGVsLmV4dGVuZCh7fSk7XG5cbi8qKlxuICogUmVuZGVycyBhIGZ1bGwgY2lyY3N0ZXIgdmlzdWFsaXphdGlvbi5cbiAqL1xudmFyIENpcmNzdGVyVmlldyA9IEJhY2tib25lLlZpZXcuZXh0ZW5kKHtcbiAgICBjbGFzc05hbWU6IFwiY2lyY3N0ZXJcIixcblxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5nZW5vbWUgPSBvcHRpb25zLmdlbm9tZTtcbiAgICAgICAgdGhpcy5sYWJlbF9hcmNfaGVpZ2h0ID0gNTA7XG4gICAgICAgIHRoaXMuc2NhbGUgPSAxO1xuICAgICAgICB0aGlzLmNpcmN1bGFyX3ZpZXdzID0gbnVsbDtcbiAgICAgICAgdGhpcy5jaG9yZHNfdmlld3MgPSBudWxsO1xuXG4gICAgICAgIC8vIFdoZW4gdHJhY2tzIGFkZGVkIHRvL3JlbW92ZWQgZnJvbSBtb2RlbCwgdXBkYXRlIHZpZXcuXG4gICAgICAgIHRoaXMubW9kZWwuZ2V0KFwiZHJhd2FibGVzXCIpLm9uKFwiYWRkXCIsIHRoaXMuYWRkX3RyYWNrLCB0aGlzKTtcbiAgICAgICAgdGhpcy5tb2RlbC5nZXQoXCJkcmF3YWJsZXNcIikub24oXCJyZW1vdmVcIiwgdGhpcy5yZW1vdmVfdHJhY2ssIHRoaXMpO1xuXG4gICAgICAgIC8vIFdoZW4gY29uZmlnIHNldHRpbmdzIGNoYW5nZSwgdXBkYXRlIHZpZXcuXG4gICAgICAgIHZhciB2aXNfY29uZmlnID0gdGhpcy5tb2RlbC5nZXQoXCJjb25maWdcIik7XG4gICAgICAgIHZpc19jb25maWcuZ2V0KFwiYXJjX2RhdGFzZXRfaGVpZ2h0XCIpLm9uKFwiY2hhbmdlOnZhbHVlXCIsIHRoaXMudXBkYXRlX3RyYWNrX2JvdW5kcywgdGhpcyk7XG4gICAgICAgIHZpc19jb25maWcuZ2V0KFwidHJhY2tfZ2FwXCIpLm9uKFwiY2hhbmdlOnZhbHVlXCIsIHRoaXMudXBkYXRlX3RyYWNrX2JvdW5kcywgdGhpcyk7XG4gICAgfSxcblxuICAgIC8vIEhBQ0tzOiB1c2luZyB0cmFja190eXBlIGZvciBjaXJjdWxhci9jaG9yZCBkaXN0aW5jdGlvbiBpbiB0aGUgZnVuY3Rpb25zIGJlbG93IGZvciBub3cuXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRyYWNrcyB0byBiZSByZW5kZXJlZCB1c2luZyBjaXJjdWxhciB2aWV3LlxuICAgICAqL1xuICAgIGdldF9jaXJjdWxhcl90cmFja3M6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC5nZXQoXCJkcmF3YWJsZXNcIikuZmlsdGVyKHRyYWNrID0+IHRyYWNrLmdldChcInRyYWNrX3R5cGVcIikgIT09IFwiRGlhZ29uYWxIZWF0bWFwVHJhY2tcIik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJhY2tzIHRvIGJlIHJlbmRlcmVkIHVzaW5nIGNob3JkcyB2aWV3LlxuICAgICAqL1xuICAgIGdldF9jaG9yZF90cmFja3M6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC5nZXQoXCJkcmF3YWJsZXNcIikuZmlsdGVyKHRyYWNrID0+IHRyYWNrLmdldChcInRyYWNrX3R5cGVcIikgPT09IFwiRGlhZ29uYWxIZWF0bWFwVHJhY2tcIik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBsaXN0IG9mIGNpcmN1bGFyIHRyYWNrcycgcmFkaXVzIGJvdW5kcy5cbiAgICAgKi9cbiAgICBnZXRfdHJhY2tzX2JvdW5kczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjaXJjdWxhcl90cmFja3MgPSB0aGlzLmdldF9jaXJjdWxhcl90cmFja3MoKTtcblxuICAgICAgICB2YXIgZGF0YXNldF9hcmNfaGVpZ2h0ID0gdGhpcy5tb2RlbC5nZXQoXCJjb25maWdcIikuZ2V0X3ZhbHVlKFwiYXJjX2RhdGFzZXRfaGVpZ2h0XCIpO1xuXG4gICAgICAgIHZhciB0cmFja19nYXAgPSB0aGlzLm1vZGVsLmdldChcImNvbmZpZ1wiKS5nZXRfdmFsdWUoXCJ0cmFja19nYXBcIik7XG5cbiAgICAgICAgdmFyIC8vIFN1YnRyYWN0IDIwIHRvIG1ha2Ugc3VyZSBjaHJvbSBsYWJlbHMgYXJlIG9uIHNjcmVlbi5cbiAgICAgICAgbWluX2RpbWVuc2lvbiA9IE1hdGgubWluKHRoaXMuJGVsLndpZHRoKCksIHRoaXMuJGVsLmhlaWdodCgpKSAtIDIwO1xuXG4gICAgICAgIHZhciAvLyBDb21wdXRlIHJhZGl1cyBzdGFydCBiYXNlZCBvbiBtb2RlbCwgd2lsbCBiZSBjZW50ZXJlZFxuICAgICAgICAvLyBhbmQgZml0IGVudGlyZWx5IGluc2lkZSBlbGVtZW50IGJ5IGRlZmF1bHQuXG4gICAgICAgIHJhZGl1c19zdGFydCA9XG4gICAgICAgICAgICBtaW5fZGltZW5zaW9uIC8gMiAtXG4gICAgICAgICAgICBjaXJjdWxhcl90cmFja3MubGVuZ3RoICogKGRhdGFzZXRfYXJjX2hlaWdodCArIHRyYWNrX2dhcCkgK1xuICAgICAgICAgICAgLy8gQWRkIHRyYWNrX2dhcCBiYWNrIGluIGJlY2F1c2Ugbm8gZ2FwIGlzIG5lZWRlZCBmb3IgbGFzdCB0cmFjay5cbiAgICAgICAgICAgIHRyYWNrX2dhcCAtXG4gICAgICAgICAgICB0aGlzLmxhYmVsX2FyY19oZWlnaHQ7XG5cbiAgICAgICAgdmFyIC8vIENvbXB1dGUgcmFuZ2Ugb2YgdHJhY2sgc3RhcnRpbmcgcmFkaWkuXG4gICAgICAgIHRyYWNrc19zdGFydF9yYWRpaSA9IGQzLnJhbmdlKHJhZGl1c19zdGFydCwgbWluX2RpbWVuc2lvbiAvIDIsIGRhdGFzZXRfYXJjX2hlaWdodCArIHRyYWNrX2dhcCk7XG5cbiAgICAgICAgLy8gTWFwIGZyb20gdHJhY2sgc3RhcnQgdG8gYm91bmRzLlxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHJldHVybiBfLm1hcCh0cmFja3Nfc3RhcnRfcmFkaWksIHJhZGl1cyA9PiBbcmFkaXVzLCByYWRpdXMgKyBkYXRhc2V0X2FyY19oZWlnaHRdKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyBjaXJjdWxhciB0cmFja3MsIGNob3JkIHRyYWNrcywgYW5kIGxhYmVsIHRyYWNrcy5cbiAgICAgKi9cbiAgICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciB3aWR0aCA9IHNlbGYuJGVsLndpZHRoKCk7XG4gICAgICAgIHZhciBoZWlnaHQgPSBzZWxmLiRlbC5oZWlnaHQoKTtcbiAgICAgICAgdmFyIGNpcmN1bGFyX3RyYWNrcyA9IHRoaXMuZ2V0X2NpcmN1bGFyX3RyYWNrcygpO1xuICAgICAgICB2YXIgY2hvcmRzX3RyYWNrcyA9IHRoaXMuZ2V0X2Nob3JkX3RyYWNrcygpO1xuICAgICAgICB2YXIgdG90YWxfZ2FwID0gc2VsZi5tb2RlbC5nZXQoXCJjb25maWdcIikuZ2V0X3ZhbHVlKFwidG90YWxfZ2FwXCIpO1xuICAgICAgICB2YXIgdHJhY2tzX2JvdW5kcyA9IHRoaXMuZ2V0X3RyYWNrc19ib3VuZHMoKTtcblxuICAgICAgICB2YXIgLy8gU2V0IHVwIFNWRyBlbGVtZW50LlxuICAgICAgICBzdmcgPSBkM1xuICAgICAgICAgICAgLnNlbGVjdChzZWxmLiRlbFswXSlcbiAgICAgICAgICAgIC5hcHBlbmQoXCJzdmdcIilcbiAgICAgICAgICAgIC5hdHRyKFwid2lkdGhcIiwgd2lkdGgpXG4gICAgICAgICAgICAuYXR0cihcImhlaWdodFwiLCBoZWlnaHQpXG4gICAgICAgICAgICAuYXR0cihcInBvaW50ZXItZXZlbnRzXCIsIFwiYWxsXCIpXG4gICAgICAgICAgICAvLyBTZXQgdXAgem9vbWluZywgZHJhZ2dpbmcuXG4gICAgICAgICAgICAuYXBwZW5kKFwic3ZnOmdcIilcbiAgICAgICAgICAgIC5jYWxsKFxuICAgICAgICAgICAgICAgIGQzLmJlaGF2aW9yLnpvb20oKS5vbihcInpvb21cIiwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBEbyB6b29tLCBkcmFnLlxuICAgICAgICAgICAgICAgICAgICB2YXIgc2NhbGUgPSBkMy5ldmVudC5zY2FsZTtcbiAgICAgICAgICAgICAgICAgICAgc3ZnLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgYHRyYW5zbGF0ZSgke2QzLmV2ZW50LnRyYW5zbGF0ZX0pIHNjYWxlKCR7c2NhbGV9KWApO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFByb3BhZ2F0ZSBzY2FsZSBjaGFuZ2VzIHRvIHZpZXdzLlxuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5zY2FsZSAhPT0gc2NhbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVzZSB0aW1lb3V0IHRvIHdhaXQgZm9yIHpvb21pbmcvZHJhZ2dpbmcgdG8gc3RvcCBiZWZvcmUgcmVuZGVyaW5nIG1vcmUgZGV0YWlsLlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuem9vbV9kcmFnX3RpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoc2VsZi56b29tX2RyYWdfdGltZW91dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnpvb21fZHJhZ190aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVuZGVyIG1vcmUgZGV0YWlsIGluIHRyYWNrcycgdmlzaWJsZSBlbGVtZW50cy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGSVhNRTogZG8gbm90IGRvIHRoaXMgcmlnaHQgbm93OyBpdCBpcyBub3QgZnVsbHkgaW1wbGVtZW50ZWQtLWUuZy4gZGF0YSBib3VuZHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhcmUgbm90IHVwZGF0ZWQgd2hlbiBuZXcgZGF0YSBpcyBmZXRjaGVkLS1hbmQgZmV0Y2hpbmcgbW9yZSBkZXRhaWxlZCBxdWFudGl0YXRpdmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkYXRhIGlzIG5vdCB0aGF0IHVzZWZ1bC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAgICAgICAgXy5lYWNoKHNlbGYuY2lyY3VsYXJfdmlld3MsIGZ1bmN0aW9uKHZpZXcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aWV3LnVwZGF0ZV9zY2FsZShzY2FsZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCA0MDApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIGB0cmFuc2xhdGUoJHt3aWR0aCAvIDJ9LCR7aGVpZ2h0IC8gMn0pYClcbiAgICAgICAgICAgIC5hcHBlbmQoXCJzdmc6Z1wiKVxuICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcInRyYWNrc1wiKTtcblxuICAgICAgICAvLyAtLSBSZW5kZXIgY2lyY3VsYXIgdHJhY2tzLiAtLVxuXG4gICAgICAgIC8vIENyZWF0ZSBhIHZpZXcgZm9yIGVhY2ggdHJhY2sgaW4gdGhlIHZpc3VhbGl6YXRpb24gYW5kIHJlbmRlci5cbiAgICAgICAgdGhpcy5jaXJjdWxhcl92aWV3cyA9IGNpcmN1bGFyX3RyYWNrcy5tYXAoKHRyYWNrLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgdmFyIHZpZXcgPSBuZXcgQ2lyY3N0ZXJCaWdXaWdUcmFja1ZpZXcoe1xuICAgICAgICAgICAgICAgIGVsOiBzdmcuYXBwZW5kKFwiZ1wiKVswXSxcbiAgICAgICAgICAgICAgICB0cmFjazogdHJhY2ssXG4gICAgICAgICAgICAgICAgcmFkaXVzX2JvdW5kczogdHJhY2tzX2JvdW5kc1tpbmRleF0sXG4gICAgICAgICAgICAgICAgZ2Vub21lOiBzZWxmLmdlbm9tZSxcbiAgICAgICAgICAgICAgICB0b3RhbF9nYXA6IHRvdGFsX2dhcFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHZpZXcucmVuZGVyKCk7XG5cbiAgICAgICAgICAgIHJldHVybiB2aWV3O1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyAtLSBSZW5kZXIgY2hvcmRzIHRyYWNrcy4gLS1cblxuICAgICAgICB0aGlzLmNob3Jkc192aWV3cyA9IGNob3Jkc190cmFja3MubWFwKHRyYWNrID0+IHtcbiAgICAgICAgICAgIHZhciB2aWV3ID0gbmV3IENpcmNzdGVyQ2hyb21JbnRlcmFjdGlvbnNUcmFja1ZpZXcoe1xuICAgICAgICAgICAgICAgIGVsOiBzdmcuYXBwZW5kKFwiZ1wiKVswXSxcbiAgICAgICAgICAgICAgICB0cmFjazogdHJhY2ssXG4gICAgICAgICAgICAgICAgcmFkaXVzX2JvdW5kczogdHJhY2tzX2JvdW5kc1swXSxcbiAgICAgICAgICAgICAgICBnZW5vbWU6IHNlbGYuZ2Vub21lLFxuICAgICAgICAgICAgICAgIHRvdGFsX2dhcDogdG90YWxfZ2FwXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdmlldy5yZW5kZXIoKTtcblxuICAgICAgICAgICAgcmV0dXJuIHZpZXc7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIC0tIFJlbmRlciBsYWJlbCB0cmFjay4gLS1cblxuICAgICAgICAvLyBUcmFjayBib3VuZHMgYXJlOlxuICAgICAgICAvLyAoYSkgb3V0ZXIgcmFkaXVzIG9mIGxhc3QgY2lyY3VsYXIgdHJhY2s7XG4gICAgICAgIC8vIChiKVxuICAgICAgICB2YXIgb3V0ZXJtb3N0X3JhZGl1cyA9IHRoaXMuY2lyY3VsYXJfdmlld3NbdGhpcy5jaXJjdWxhcl92aWV3cy5sZW5ndGggLSAxXS5yYWRpdXNfYm91bmRzWzFdO1xuXG4gICAgICAgIHZhciB0cmFja19ib3VuZHMgPSBbb3V0ZXJtb3N0X3JhZGl1cywgb3V0ZXJtb3N0X3JhZGl1cyArIHRoaXMubGFiZWxfYXJjX2hlaWdodF07XG5cbiAgICAgICAgdGhpcy5sYWJlbF90cmFja192aWV3ID0gbmV3IENpcmNzdGVyQ2hyb21MYWJlbFRyYWNrVmlldyh7XG4gICAgICAgICAgICBlbDogc3ZnLmFwcGVuZChcImdcIilbMF0sXG4gICAgICAgICAgICB0cmFjazogbmV3IENpcmNzdGVyTGFiZWxUcmFjaygpLFxuICAgICAgICAgICAgcmFkaXVzX2JvdW5kczogdHJhY2tfYm91bmRzLFxuICAgICAgICAgICAgZ2Vub21lOiBzZWxmLmdlbm9tZSxcbiAgICAgICAgICAgIHRvdGFsX2dhcDogdG90YWxfZ2FwXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMubGFiZWxfdHJhY2tfdmlldy5yZW5kZXIoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVyIGEgc2luZ2xlIHRyYWNrIG9uIHRoZSBvdXRzaWRlIG9mIHRoZSBjdXJyZW50IHZpc3VhbGl6YXRpb24uXG4gICAgICovXG4gICAgYWRkX3RyYWNrOiBmdW5jdGlvbihuZXdfdHJhY2spIHtcbiAgICAgICAgdmFyIHRvdGFsX2dhcCA9IHRoaXMubW9kZWwuZ2V0KFwiY29uZmlnXCIpLmdldF92YWx1ZShcInRvdGFsX2dhcFwiKTtcblxuICAgICAgICBpZiAobmV3X3RyYWNrLmdldChcInRyYWNrX3R5cGVcIikgPT09IFwiRGlhZ29uYWxIZWF0bWFwVHJhY2tcIikge1xuICAgICAgICAgICAgLy8gQWRkZWQgY2hvcmRzIHRyYWNrLlxuICAgICAgICAgICAgdmFyIGlubmVybW9zdF9yYWRpdXNfYm91bmRzID0gdGhpcy5jaXJjdWxhcl92aWV3c1swXS5yYWRpdXNfYm91bmRzO1xuXG4gICAgICAgICAgICB2YXIgbmV3X3ZpZXcgPSBuZXcgQ2lyY3N0ZXJDaHJvbUludGVyYWN0aW9uc1RyYWNrVmlldyh7XG4gICAgICAgICAgICAgICAgZWw6IGQzLnNlbGVjdChcImcudHJhY2tzXCIpLmFwcGVuZChcImdcIilbMF0sXG4gICAgICAgICAgICAgICAgdHJhY2s6IG5ld190cmFjayxcbiAgICAgICAgICAgICAgICByYWRpdXNfYm91bmRzOiBpbm5lcm1vc3RfcmFkaXVzX2JvdW5kcyxcbiAgICAgICAgICAgICAgICBnZW5vbWU6IHRoaXMuZ2Vub21lLFxuICAgICAgICAgICAgICAgIHRvdGFsX2dhcDogdG90YWxfZ2FwXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgbmV3X3ZpZXcucmVuZGVyKCk7XG4gICAgICAgICAgICB0aGlzLmNob3Jkc192aWV3cy5wdXNoKG5ld192aWV3KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEFkZGVkIGNpcmN1bGFyIHRyYWNrLlxuXG4gICAgICAgICAgICAvLyBSZWNvbXB1dGUgYW5kIHVwZGF0ZSBjaXJjdWxhciB0cmFjayBib3VuZHMuXG4gICAgICAgICAgICB2YXIgbmV3X3RyYWNrX2JvdW5kcyA9IHRoaXMuZ2V0X3RyYWNrc19ib3VuZHMoKTtcbiAgICAgICAgICAgIF8uZWFjaCh0aGlzLmNpcmN1bGFyX3ZpZXdzLCAodHJhY2tfdmlldywgaSkgPT4ge1xuICAgICAgICAgICAgICAgIHRyYWNrX3ZpZXcudXBkYXRlX3JhZGl1c19ib3VuZHMobmV3X3RyYWNrX2JvdW5kc1tpXSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gVXBkYXRlIGNob3JkcyB0cmFja3MuXG4gICAgICAgICAgICBfLmVhY2godGhpcy5jaG9yZHNfdmlld3MsIHRyYWNrX3ZpZXcgPT4ge1xuICAgICAgICAgICAgICAgIHRyYWNrX3ZpZXcudXBkYXRlX3JhZGl1c19ib3VuZHMobmV3X3RyYWNrX2JvdW5kc1swXSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gUmVuZGVyIG5ldyB0cmFjay5cbiAgICAgICAgICAgIHZhciB0cmFja19pbmRleCA9IHRoaXMuY2lyY3VsYXJfdmlld3MubGVuZ3RoO1xuXG4gICAgICAgICAgICB2YXIgdHJhY2tfdmlldyA9IG5ldyBDaXJjc3RlckJpZ1dpZ1RyYWNrVmlldyh7XG4gICAgICAgICAgICAgICAgZWw6IGQzLnNlbGVjdChcImcudHJhY2tzXCIpLmFwcGVuZChcImdcIilbMF0sXG4gICAgICAgICAgICAgICAgdHJhY2s6IG5ld190cmFjayxcbiAgICAgICAgICAgICAgICByYWRpdXNfYm91bmRzOiBuZXdfdHJhY2tfYm91bmRzW3RyYWNrX2luZGV4XSxcbiAgICAgICAgICAgICAgICBnZW5vbWU6IHRoaXMuZ2Vub21lLFxuICAgICAgICAgICAgICAgIHRvdGFsX2dhcDogdG90YWxfZ2FwXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdHJhY2tfdmlldy5yZW5kZXIoKTtcbiAgICAgICAgICAgIHRoaXMuY2lyY3VsYXJfdmlld3MucHVzaCh0cmFja192aWV3KTtcblxuICAgICAgICAgICAgLy8gVXBkYXRlIGxhYmVsIHRyYWNrLlxuICAgICAgICAgICAgLypcbiAgICAgICAgICAgIEZJWE1FOiBzaG91bGQgbmV2ZXIgaGF2ZSB0byB1cGRhdGUgbGFiZWwgdHJhY2sgYmVjYXVzZSB2aXMgYWx3YXlzIGV4cGFuZHMgdG8gZml0IGFyZWFcbiAgICAgICAgICAgIHdpdGhpbiBsYWJlbCB0cmFjay5cbiAgICAgICAgICAgIHZhciB0cmFja19ib3VuZHMgPSBuZXdfdHJhY2tfYm91bmRzWyBuZXdfdHJhY2tfYm91bmRzLmxlbmd0aC0xIF07XG4gICAgICAgICAgICB0cmFja19ib3VuZHNbMV0gPSB0cmFja19ib3VuZHNbMF07XG4gICAgICAgICAgICB0aGlzLmxhYmVsX3RyYWNrX3ZpZXcudXBkYXRlX3JhZGl1c19ib3VuZHModHJhY2tfYm91bmRzKTtcbiAgICAgICAgICAgICovXG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGEgdHJhY2sgZnJvbSB0aGUgdmlldy5cbiAgICAgKi9cbiAgICByZW1vdmVfdHJhY2s6IGZ1bmN0aW9uKHRyYWNrLCB0cmFja3MsIG9wdGlvbnMpIHtcbiAgICAgICAgLy8gLS0gUmVtb3ZlIHRyYWNrIGZyb20gdmlldy4gLS1cbiAgICAgICAgdmFyIHRyYWNrX3ZpZXcgPSB0aGlzLmNpcmN1bGFyX3ZpZXdzW29wdGlvbnMuaW5kZXhdO1xuICAgICAgICB0aGlzLmNpcmN1bGFyX3ZpZXdzLnNwbGljZShvcHRpb25zLmluZGV4LCAxKTtcbiAgICAgICAgdHJhY2tfdmlldy4kZWwucmVtb3ZlKCk7XG5cbiAgICAgICAgLy8gUmVjb21wdXRlIGFuZCB1cGRhdGUgdHJhY2sgYm91bmRzLlxuICAgICAgICB2YXIgbmV3X3RyYWNrX2JvdW5kcyA9IHRoaXMuZ2V0X3RyYWNrc19ib3VuZHMoKTtcbiAgICAgICAgXy5lYWNoKHRoaXMuY2lyY3VsYXJfdmlld3MsICh0cmFja192aWV3LCBpKSA9PiB7XG4gICAgICAgICAgICB0cmFja192aWV3LnVwZGF0ZV9yYWRpdXNfYm91bmRzKG5ld190cmFja19ib3VuZHNbaV0pO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgdXBkYXRlX3RyYWNrX2JvdW5kczogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIFJlY29tcHV0ZSBhbmQgdXBkYXRlIHRyYWNrIGJvdW5kcy5cbiAgICAgICAgdmFyIG5ld190cmFja19ib3VuZHMgPSB0aGlzLmdldF90cmFja3NfYm91bmRzKCk7XG4gICAgICAgIF8uZWFjaCh0aGlzLmNpcmN1bGFyX3ZpZXdzLCAodHJhY2tfdmlldywgaSkgPT4ge1xuICAgICAgICAgICAgdHJhY2tfdmlldy51cGRhdGVfcmFkaXVzX2JvdW5kcyhuZXdfdHJhY2tfYm91bmRzW2ldKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gVXBkYXRlIGNob3JkcyB0cmFja3MuXG4gICAgICAgIF8uZWFjaCh0aGlzLmNob3Jkc192aWV3cywgdHJhY2tfdmlldyA9PiB7XG4gICAgICAgICAgICB0cmFja192aWV3LnVwZGF0ZV9yYWRpdXNfYm91bmRzKG5ld190cmFja19ib3VuZHNbMF0pO1xuICAgICAgICB9KTtcbiAgICB9XG59KTtcblxuLyoqXG4gKiBSZW5kZXJzIGEgdHJhY2sgaW4gYSBDaXJjc3RlciB2aXN1YWxpemF0aW9uLlxuICovXG52YXIgQ2lyY3N0ZXJUcmFja1ZpZXcgPSBCYWNrYm9uZS5WaWV3LmV4dGVuZCh7XG4gICAgdGFnTmFtZTogXCJnXCIsXG5cbiAgICAvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBQdWJsaWMgTWV0aG9kcyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuYmdfc3Ryb2tlID0gXCIjZGRkXCI7XG4gICAgICAgIC8vIEZpbGwgY29sb3Igd2hlbiBsb2FkaW5nIGRhdGEuXG4gICAgICAgIHRoaXMubG9hZGluZ19iZ19maWxsID0gXCIjZmZjXCI7XG4gICAgICAgIC8vIEZpbGwgY29sb3Igd2hlbiBkYXRhIGhhcyBiZWVuIGxvYWRlZC5cbiAgICAgICAgdGhpcy5iZ19maWxsID0gXCIjZGRkXCI7XG4gICAgICAgIHRoaXMudG90YWxfZ2FwID0gb3B0aW9ucy50b3RhbF9nYXA7XG4gICAgICAgIHRoaXMudHJhY2sgPSBvcHRpb25zLnRyYWNrO1xuICAgICAgICB0aGlzLnJhZGl1c19ib3VuZHMgPSBvcHRpb25zLnJhZGl1c19ib3VuZHM7XG4gICAgICAgIHRoaXMuZ2Vub21lID0gb3B0aW9ucy5nZW5vbWU7XG4gICAgICAgIHRoaXMuY2hyb21zX2xheW91dCA9IHRoaXMuX2Nocm9tc19sYXlvdXQoKTtcbiAgICAgICAgdGhpcy5kYXRhX2JvdW5kcyA9IFtdO1xuICAgICAgICB0aGlzLnNjYWxlID0gMTtcbiAgICAgICAgdGhpcy5wYXJlbnRfZWx0ID0gZDMuc2VsZWN0KHRoaXMuJGVsWzBdKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IGZpbGwgY29sb3IgZnJvbSBjb25maWcuXG4gICAgICovXG4gICAgZ2V0X2ZpbGxfY29sb3I6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY29sb3IgPSB0aGlzLnRyYWNrLmdldChcImNvbmZpZ1wiKS5nZXRfdmFsdWUoXCJibG9ja19jb2xvclwiKTtcbiAgICAgICAgaWYgKCFjb2xvcikge1xuICAgICAgICAgICAgY29sb3IgPSB0aGlzLnRyYWNrLmdldChcImNvbmZpZ1wiKS5nZXRfdmFsdWUoXCJjb2xvclwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29sb3I7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlciB0cmFjaydzIGRhdGEgYnkgYWRkaW5nIFNWRyBlbGVtZW50cyB0byBwYXJlbnQuXG4gICAgICovXG4gICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gLS0gQ3JlYXRlIHRyYWNrIGdyb3VwIGVsZW1lbnQuIC0tXG4gICAgICAgIHZhciB0cmFja19wYXJlbnRfZWx0ID0gdGhpcy5wYXJlbnRfZWx0O1xuXG4gICAgICAgIC8vIC0tIFJlbmRlciBiYWNrZ3JvdW5kIGFyY3MuIC0tXG4gICAgICAgIHZhciBnZW5vbWVfYXJjcyA9IHRoaXMuY2hyb21zX2xheW91dDtcblxuICAgICAgICB2YXIgYXJjX2dlbiA9IGQzLnN2Z1xuICAgICAgICAgICAgLmFyYygpXG4gICAgICAgICAgICAuaW5uZXJSYWRpdXModGhpcy5yYWRpdXNfYm91bmRzWzBdKVxuICAgICAgICAgICAgLm91dGVyUmFkaXVzKHRoaXMucmFkaXVzX2JvdW5kc1sxXSk7XG5cbiAgICAgICAgdmFyIC8vIEF0dGFjaCBkYXRhIHRvIGdyb3VwIGVsZW1lbnQuXG4gICAgICAgIGNocm9tc19lbHRzID0gdHJhY2tfcGFyZW50X2VsdFxuICAgICAgICAgICAgLnNlbGVjdEFsbChcImdcIilcbiAgICAgICAgICAgIC5kYXRhKGdlbm9tZV9hcmNzKVxuICAgICAgICAgICAgLmVudGVyKClcbiAgICAgICAgICAgIC5hcHBlbmQoXCJzdmc6Z1wiKTtcblxuICAgICAgICB2YXIgLy8gRHJhdyBjaHJvbSBhcmNzL3BhdGhzLlxuICAgICAgICBjaHJvbXNfcGF0aHMgPSBjaHJvbXNfZWx0c1xuICAgICAgICAgICAgLmFwcGVuZChcInBhdGhcIilcbiAgICAgICAgICAgIC5hdHRyKFwiZFwiLCBhcmNfZ2VuKVxuICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcImNocm9tLWJhY2tncm91bmRcIilcbiAgICAgICAgICAgIC5zdHlsZShcInN0cm9rZVwiLCB0aGlzLmJnX3N0cm9rZSlcbiAgICAgICAgICAgIC5zdHlsZShcImZpbGxcIiwgdGhpcy5sb2FkaW5nX2JnX2ZpbGwpO1xuXG4gICAgICAgIC8vIEFwcGVuZCB0aXRsZXMgdG8gcGF0aHMuXG4gICAgICAgIGNocm9tc19wYXRocy5hcHBlbmQoXCJ0aXRsZVwiKS50ZXh0KGQgPT4gZC5kYXRhLmNocm9tKTtcblxuICAgICAgICAvLyAtLSBSZW5kZXIgdHJhY2sgZGF0YSBhbmQsIHdoZW4gdHJhY2sgZGF0YSBpcyByZW5kZXJlZCwgYXBwbHkgcHJlZmVyZW5jZXMgYW5kIHVwZGF0ZSBjaHJvbV9lbHRzIGZpbGwuIC0tXG5cbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIHZhciBkYXRhX21hbmFnZXIgPSBzZWxmLnRyYWNrLmdldChcImRhdGFfbWFuYWdlclwiKTtcblxuICAgICAgICB2YXIgLy8gSWYgdHJhY2sgaGFzIGEgZGF0YSBtYW5hZ2VyLCBnZXQgZGVmZXJyZWQgdGhhdCByZXNvbHZlcyB3aGVuIGRhdGEgaXMgcmVhZHkuXG4gICAgICAgIGRhdGFfcmVhZHlfZGVmZXJyZWQgPSBkYXRhX21hbmFnZXIgPyBkYXRhX21hbmFnZXIuZGF0YV9pc19yZWFkeSgpIDogdHJ1ZTtcblxuICAgICAgICAvLyBXaGVuIGRhdGEgaXMgcmVhZHksIHJlbmRlciB0cmFjay5cbiAgICAgICAgJC53aGVuKGRhdGFfcmVhZHlfZGVmZXJyZWQpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgJC53aGVuKHNlbGYuX3JlbmRlcl9kYXRhKHRyYWNrX3BhcmVudF9lbHQpKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICBjaHJvbXNfcGF0aHMuc3R5bGUoXCJmaWxsXCIsIHNlbGYuYmdfZmlsbCk7XG5cbiAgICAgICAgICAgICAgICAvLyBSZW5kZXIgbGFiZWxzIGFmdGVyIGRhdGEgaXMgYXZhaWxhYmxlIHNvIHRoYXQgZGF0YSBhdHRyaWJ1dGVzIGFyZSBhdmFpbGFibGUuXG4gICAgICAgICAgICAgICAgc2VsZi5yZW5kZXJfbGFiZWxzKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlciB0cmFjayBsYWJlbHMuXG4gICAgICovXG4gICAgcmVuZGVyX2xhYmVsczogZnVuY3Rpb24oKSB7fSxcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSByYWRpdXMgYm91bmRzLlxuICAgICAqL1xuICAgIHVwZGF0ZV9yYWRpdXNfYm91bmRzOiBmdW5jdGlvbihyYWRpdXNfYm91bmRzKSB7XG4gICAgICAgIC8vIFVwZGF0ZSBib3VuZHMuXG4gICAgICAgIHRoaXMucmFkaXVzX2JvdW5kcyA9IHJhZGl1c19ib3VuZHM7XG5cbiAgICAgICAgLy8gLS0gVXBkYXRlIGJhY2tncm91bmQgYXJjcy4gLS1cbiAgICAgICAgdmFyIG5ld19kID0gZDMuc3ZnXG4gICAgICAgICAgICAuYXJjKClcbiAgICAgICAgICAgIC5pbm5lclJhZGl1cyh0aGlzLnJhZGl1c19ib3VuZHNbMF0pXG4gICAgICAgICAgICAub3V0ZXJSYWRpdXModGhpcy5yYWRpdXNfYm91bmRzWzFdKTtcblxuICAgICAgICB0aGlzLnBhcmVudF9lbHRcbiAgICAgICAgICAgIC5zZWxlY3RBbGwoXCJnPnBhdGguY2hyb20tYmFja2dyb3VuZFwiKVxuICAgICAgICAgICAgLnRyYW5zaXRpb24oKVxuICAgICAgICAgICAgLmR1cmF0aW9uKDEwMDApXG4gICAgICAgICAgICAuYXR0cihcImRcIiwgbmV3X2QpO1xuXG4gICAgICAgIHRoaXMuX3RyYW5zaXRpb25fY2hyb21fZGF0YSgpO1xuXG4gICAgICAgIHRoaXMuX3RyYW5zaXRpb25fbGFiZWxzKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB2aWV3IHNjYWxlLiBUaGlzIGZldGNoZXMgbW9yZSBkYXRhIGlmIHNjYWxlIGlzIGluY3JlYXNlZC5cbiAgICAgKi9cbiAgICB1cGRhdGVfc2NhbGU6IGZ1bmN0aW9uKG5ld19zY2FsZSkge1xuICAgICAgICAvLyAtLSBVcGRhdGUgc2NhbGUgYW5kIHJldHVybiBpZiBuZXcgc2NhbGUgaXMgbGVzcyB0aGFuIG9sZCBzY2FsZS4gLS1cblxuICAgICAgICB2YXIgb2xkX3NjYWxlID0gdGhpcy5zY2FsZTtcbiAgICAgICAgdGhpcy5zY2FsZSA9IG5ld19zY2FsZTtcbiAgICAgICAgaWYgKG5ld19zY2FsZSA8PSBvbGRfc2NhbGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIC0tIFNjYWxlIGluY3JlYXNlZCwgc28gcmVuZGVyIHZpc2libGUgZGF0YSB3aXRoIG1vcmUgZGV0YWlsLiAtLVxuXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICB2YXIgdXRpbHMgPSBuZXcgU1ZHVXRpbHMoKTtcblxuICAgICAgICAvLyBTZWxlY3QgYWxsIGNocm9tIGRhdGEgYW5kIGZpbHRlciB0byBvcGVyYXRlIG9uIHRob3NlIHRoYXQgYXJlIHZpc2libGUuXG4gICAgICAgIHRoaXMucGFyZW50X2VsdFxuICAgICAgICAgICAgLnNlbGVjdEFsbChcInBhdGguY2hyb20tZGF0YVwiKVxuICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbihkLCBpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHV0aWxzLmlzX3Zpc2libGUodGhpcyk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmVhY2goZnVuY3Rpb24oZCwgaSkge1xuICAgICAgICAgICAgICAgIC8vIC0tIE5vdyBvcGVyYXRpbmcgb24gYSBzaW5nbGUgcGF0aCBlbGVtZW50IHJlcHJlc2VudGluZyBjaHJvbW9zb21lIGRhdGEuIC0tXG5cbiAgICAgICAgICAgICAgICB2YXIgcGF0aF9lbHQgPSBkMy5zZWxlY3QodGhpcyk7XG5cbiAgICAgICAgICAgICAgICB2YXIgY2hyb20gPSBwYXRoX2VsdC5hdHRyKFwiY2hyb21cIik7XG4gICAgICAgICAgICAgICAgdmFyIGNocm9tX3JlZ2lvbiA9IHNlbGYuZ2Vub21lLmdldF9jaHJvbV9yZWdpb24oY2hyb20pO1xuICAgICAgICAgICAgICAgIHZhciBkYXRhX21hbmFnZXIgPSBzZWxmLnRyYWNrLmdldChcImRhdGFfbWFuYWdlclwiKTtcbiAgICAgICAgICAgICAgICB2YXIgZGF0YV9kZWZlcnJlZDtcblxuICAgICAgICAgICAgICAgIC8vIElmIGNhbid0IGdldCBtb3JlIGRldGFpbGVkIGRhdGEsIHJldHVybi5cbiAgICAgICAgICAgICAgICBpZiAoIWRhdGFfbWFuYWdlci5jYW5fZ2V0X21vcmVfZGV0YWlsZWRfZGF0YShjaHJvbV9yZWdpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyAtLSBHZXQgbW9yZSBkZXRhaWxlZCBkYXRhLiAtLVxuICAgICAgICAgICAgICAgIGRhdGFfZGVmZXJyZWQgPSBzZWxmLnRyYWNrXG4gICAgICAgICAgICAgICAgICAgIC5nZXQoXCJkYXRhX21hbmFnZXJcIilcbiAgICAgICAgICAgICAgICAgICAgLmdldF9tb3JlX2RldGFpbGVkX2RhdGEoY2hyb21fcmVnaW9uLCBcIkNvdmVyYWdlXCIsIDAsIG5ld19zY2FsZSk7XG5cbiAgICAgICAgICAgICAgICAvLyBXaGVuIG1vcmUgZGF0YSBpcyBhdmFpbGFibGUsIHVzZSBuZXcgZGF0YSB0byByZWRyYXcgcGF0aC5cbiAgICAgICAgICAgICAgICAkLndoZW4oZGF0YV9kZWZlcnJlZCkudGhlbihkYXRhID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGN1cnJlbnQgZGF0YSBwYXRoLlxuICAgICAgICAgICAgICAgICAgICBwYXRoX2VsdC5yZW1vdmUoKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBVcGRhdGUgZGF0YSBib3VuZHMgd2l0aCBuZXcgZGF0YS5cbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fdXBkYXRlX2RhdGFfYm91bmRzKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gRmluZCBjaHJvbW9zb21lIGFyYyB0byBkcmF3IGRhdGEgb24uXG4gICAgICAgICAgICAgICAgICAgIHZhciBjaHJvbV9hcmMgPSBfLmZpbmQoc2VsZi5jaHJvbXNfbGF5b3V0LCBsYXlvdXQgPT4gbGF5b3V0LmRhdGEuY2hyb20gPT09IGNocm9tKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBBZGQgbmV3IGRhdGEgcGF0aCBhbmQgYXBwbHkgcHJlZmVyZW5jZXMuXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb2xvciA9IHNlbGYuZ2V0X2ZpbGxfY29sb3IoKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZlxuICAgICAgICAgICAgICAgICAgICAgICAgLl9yZW5kZXJfY2hyb21fZGF0YShzZWxmLnBhcmVudF9lbHQsIGNocm9tX2FyYywgZGF0YSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZShcInN0cm9rZVwiLCBjb2xvcilcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZShcImZpbGxcIiwgY29sb3IpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfSxcblxuICAgIC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIEludGVybmFsIE1ldGhvZHMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG4gICAgLyoqXG4gICAgICogVHJhbnNpdGlvbnMgY2hyb20gZGF0YSB0byBuZXcgdmFsdWVzIChlLmcgbmV3IHJhZGl1cyBvciBkYXRhIGJvdW5kcykuXG4gICAgICovXG4gICAgX3RyYW5zaXRpb25fY2hyb21fZGF0YTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB0cmFjayA9IHRoaXMudHJhY2s7XG4gICAgICAgIHZhciBjaHJvbV9hcmNzID0gdGhpcy5jaHJvbXNfbGF5b3V0O1xuICAgICAgICB2YXIgY2hyb21fZGF0YV9wYXRocyA9IHRoaXMucGFyZW50X2VsdC5zZWxlY3RBbGwoXCJnPnBhdGguY2hyb20tZGF0YVwiKTtcbiAgICAgICAgdmFyIG51bV9wYXRocyA9IGNocm9tX2RhdGFfcGF0aHNbMF0ubGVuZ3RoO1xuXG4gICAgICAgIGlmIChudW1fcGF0aHMgPiAwKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAkLndoZW4odHJhY2suZ2V0KFwiZGF0YV9tYW5hZ2VyXCIpLmdldF9nZW5vbWVfd2lkZV9kYXRhKHRoaXMuZ2Vub21lKSkudGhlbihnZW5vbWVfd2lkZV9kYXRhID0+IHtcbiAgICAgICAgICAgICAgICAvLyBNYXAgY2hyb20gZGF0YSB0byBwYXRoIGRhdGEsIGZpbHRlcmluZyBvdXQgbnVsbCB2YWx1ZXMuXG4gICAgICAgICAgICAgICAgdmFyIHBhdGhfZGF0YSA9IF8ucmVqZWN0KFxuICAgICAgICAgICAgICAgICAgICBfLm1hcChnZW5vbWVfd2lkZV9kYXRhLCAoY2hyb21fZGF0YSwgaSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJ2YWwgPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGF0aF9mbiA9IHNlbGYuX2dldF9wYXRoX2Z1bmN0aW9uKGNocm9tX2FyY3NbaV0sIGNocm9tX2RhdGEpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGF0aF9mbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ2YWwgPSBwYXRoX2ZuKGNocm9tX2RhdGEuZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcnZhbDtcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIHBfZGF0YSA9PiBwX2RhdGEgPT09IG51bGxcbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgLy8gVHJhbnNpdGlvbiBlYWNoIHBhdGggZm9yIGRhdGEgYW5kIGNvbG9yLlxuICAgICAgICAgICAgICAgIHZhciBjb2xvciA9IHRyYWNrLmdldChcImNvbmZpZ1wiKS5nZXRfdmFsdWUoXCJjb2xvclwiKTtcbiAgICAgICAgICAgICAgICBjaHJvbV9kYXRhX3BhdGhzLmVhY2goZnVuY3Rpb24ocGF0aCwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgZDNcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zZWxlY3QodGhpcylcbiAgICAgICAgICAgICAgICAgICAgICAgIC50cmFuc2l0aW9uKClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5kdXJhdGlvbigxMDAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwic3Ryb2tlXCIsIGNvbG9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCBjb2xvcilcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwiZFwiLCBwYXRoX2RhdGFbaW5kZXhdKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRyYW5zaXRpb24gbGFiZWxzIHRvIG5ldyB2YWx1ZXMgKGUuZyBuZXcgcmFkaXVzIG9yIGRhdGEgYm91bmRzKS5cbiAgICAgKi9cbiAgICBfdHJhbnNpdGlvbl9sYWJlbHM6IGZ1bmN0aW9uKCkge30sXG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgZGF0YSBib3VuZHMuIElmIHRoZXJlIGFyZSBuZXdfYm91bmRzLCB1c2UgdGhlbTsgb3RoZXJ3aXNlIHVzZVxuICAgICAqIGRlZmF1bHQgZGF0YSBib3VuZHMuXG4gICAgICovXG4gICAgX3VwZGF0ZV9kYXRhX2JvdW5kczogZnVuY3Rpb24obmV3X2JvdW5kcykge1xuICAgICAgICB2YXIgb2xkX2JvdW5kcyA9IHRoaXMuZGF0YV9ib3VuZHM7XG4gICAgICAgIHRoaXMuZGF0YV9ib3VuZHMgPVxuICAgICAgICAgICAgbmV3X2JvdW5kcyB8fCB0aGlzLmdldF9kYXRhX2JvdW5kcyh0aGlzLnRyYWNrLmdldChcImRhdGFfbWFuYWdlclwiKS5nZXRfZ2Vub21lX3dpZGVfZGF0YSh0aGlzLmdlbm9tZSkpO1xuICAgICAgICB0aGlzLl90cmFuc2l0aW9uX2Nocm9tX2RhdGEoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVyIGRhdGEgYXMgZWxlbWVudHMgYXR0YWNoZWQgdG8gc3ZnLlxuICAgICAqL1xuICAgIF9yZW5kZXJfZGF0YTogZnVuY3Rpb24oc3ZnKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIGNocm9tX2FyY3MgPSB0aGlzLmNocm9tc19sYXlvdXQ7XG4gICAgICAgIHZhciB0cmFjayA9IHRoaXMudHJhY2s7XG4gICAgICAgIHZhciByZW5kZXJlZF9kZWZlcnJlZCA9ICQuRGVmZXJyZWQoKTtcblxuICAgICAgICAvLyBXaGVuIGdlbm9tZS13aWRlIGRhdGEgaXMgYXZhaWxhYmxlLCByZW5kZXIgZGF0YS5cbiAgICAgICAgJC53aGVuKHRyYWNrLmdldChcImRhdGFfbWFuYWdlclwiKS5nZXRfZ2Vub21lX3dpZGVfZGF0YSh0aGlzLmdlbm9tZSkpLnRoZW4oZ2Vub21lX3dpZGVfZGF0YSA9PiB7XG4gICAgICAgICAgICAvLyBTZXQgYm91bmRzLlxuICAgICAgICAgICAgc2VsZi5kYXRhX2JvdW5kcyA9IHNlbGYuZ2V0X2RhdGFfYm91bmRzKGdlbm9tZV93aWRlX2RhdGEpO1xuXG4gICAgICAgICAgICAvLyBTZXQgbWluLCBtYXggdmFsdWUgaW4gY29uZmlnIHNvIHRoYXQgdGhleSBjYW4gYmUgYWRqdXN0ZWQuIE1ha2UgdGhpcyBzaWxlbnRcbiAgICAgICAgICAgIC8vIGJlY2F1c2UgdGhlc2UgYXR0cmlidXRlcyBhcmUgd2F0Y2hlZCBmb3IgY2hhbmdlcyBhbmQgdGhlIHZpeiBpcyB1cGRhdGVkXG4gICAgICAgICAgICAvLyBhY2NvcmRpbmdseSAoc2V0IHVwIGluIGluaXRpYWxpemUpLiBCZWNhdXNlIHdlIGFyZSBzZXR0aW5nIHVwLCB3ZSBkb24ndCB3YW50XG4gICAgICAgICAgICAvLyB0aGUgd2F0Y2ggdG8gdHJpZ2dlciBldmVudHMgaGVyZS5cbiAgICAgICAgICAgIHRyYWNrLmdldChcImNvbmZpZ1wiKS5zZXRfdmFsdWUoXCJtaW5fdmFsdWVcIiwgc2VsZi5kYXRhX2JvdW5kc1swXSwge1xuICAgICAgICAgICAgICAgIHNpbGVudDogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0cmFjay5nZXQoXCJjb25maWdcIikuc2V0X3ZhbHVlKFwibWF4X3ZhbHVlXCIsIHNlbGYuZGF0YV9ib3VuZHNbMV0sIHtcbiAgICAgICAgICAgICAgICBzaWxlbnQ6IHRydWVcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBNZXJnZSBjaHJvbXMgbGF5b3V0IHdpdGggZGF0YS5cbiAgICAgICAgICAgIHZhciBsYXlvdXRfYW5kX2RhdGEgPSBfLnppcChjaHJvbV9hcmNzLCBnZW5vbWVfd2lkZV9kYXRhKTtcblxuICAgICAgICAgICAgLy8gUmVuZGVyIGVhY2ggY2hyb21vc29tZSdzIGRhdGEuXG4gICAgICAgICAgICBfLmVhY2gobGF5b3V0X2FuZF9kYXRhLCBjaHJvbV9pbmZvID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgY2hyb21fYXJjID0gY2hyb21faW5mb1swXTtcbiAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IGNocm9tX2luZm9bMV07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuX3JlbmRlcl9jaHJvbV9kYXRhKHN2ZywgY2hyb21fYXJjLCBkYXRhKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBBcHBseSBwcmVmcyB0byBhbGwgdHJhY2sgZGF0YS5cbiAgICAgICAgICAgIHZhciBjb2xvciA9IHNlbGYuZ2V0X2ZpbGxfY29sb3IoKTtcbiAgICAgICAgICAgIHNlbGYucGFyZW50X2VsdFxuICAgICAgICAgICAgICAgIC5zZWxlY3RBbGwoXCJwYXRoLmNocm9tLWRhdGFcIilcbiAgICAgICAgICAgICAgICAuc3R5bGUoXCJzdHJva2VcIiwgY29sb3IpXG4gICAgICAgICAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCBjb2xvcik7XG5cbiAgICAgICAgICAgIHJlbmRlcmVkX2RlZmVycmVkLnJlc29sdmUoc3ZnKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHJlbmRlcmVkX2RlZmVycmVkO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgYSBjaHJvbW9zb21lIGRhdGEgYW5kIGF0dGFjaCBlbGVtZW50cyB0byBzdmcuXG4gICAgICovXG4gICAgX3JlbmRlcl9jaHJvbV9kYXRhOiBmdW5jdGlvbihzdmcsIGNocm9tX2FyYywgZGF0YSkge30sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGRhdGEgZm9yIGNyZWF0aW5nIGEgcGF0aCBmb3IgdGhlIGdpdmVuIGRhdGEgdXNpbmcgY2hyb21fYXJjIGFuZCBkYXRhIGJvdW5kcy5cbiAgICAgKi9cbiAgICBfZ2V0X3BhdGhfZnVuY3Rpb246IGZ1bmN0aW9uKGNocm9tX2FyYywgY2hyb21fZGF0YSkge30sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFyYyBsYXlvdXRzIGZvciBnZW5vbWUncyBjaHJvbW9zb21lcy9jb250aWdzLiBBcmNzIGFyZSBhcnJhbmdlZCBpbiBhIGNpcmNsZVxuICAgICAqIHNlcGFyYXRlZCBieSBnYXBzLlxuICAgICAqL1xuICAgIF9jaHJvbXNfbGF5b3V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gU2V0dXAgY2hyb21zIGxheW91dCB1c2luZyBwaWUuXG4gICAgICAgIHZhciBjaHJvbXNfaW5mbyA9IHRoaXMuZ2Vub21lLmdldF9jaHJvbXNfaW5mbygpO1xuXG4gICAgICAgIHZhciBwaWVfbGF5b3V0ID0gZDMubGF5b3V0XG4gICAgICAgICAgICAucGllKClcbiAgICAgICAgICAgIC52YWx1ZShkID0+IGQubGVuKVxuICAgICAgICAgICAgLnNvcnQobnVsbCk7XG5cbiAgICAgICAgdmFyIGluaXRfYXJjcyA9IHBpZV9sYXlvdXQoY2hyb21zX2luZm8pO1xuICAgICAgICB2YXIgZ2FwX3Blcl9jaHJvbSA9IDIgKiBNYXRoLlBJICogdGhpcy50b3RhbF9nYXAgLyBjaHJvbXNfaW5mby5sZW5ndGg7XG5cbiAgICAgICAgdmFyIGNocm9tX2FyY3MgPSBfLm1hcChpbml0X2FyY3MsIChhcmMsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAvLyBGb3Igc2hvcnQgY2hyb21zLCBlbmRBbmdsZSA9PT0gc3RhcnRBbmdsZS5cbiAgICAgICAgICAgIHZhciBuZXdfZW5kQW5nbGUgPSBhcmMuZW5kQW5nbGUgLSBnYXBfcGVyX2Nocm9tO1xuICAgICAgICAgICAgYXJjLmVuZEFuZ2xlID0gbmV3X2VuZEFuZ2xlID4gYXJjLnN0YXJ0QW5nbGUgPyBuZXdfZW5kQW5nbGUgOiBhcmMuc3RhcnRBbmdsZTtcbiAgICAgICAgICAgIHJldHVybiBhcmM7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBjaHJvbV9hcmNzO1xuICAgIH1cbn0pO1xuXG4vKipcbiAqIFJlbmRlciBjaHJvbW9zb21lIGxhYmVscy5cbiAqL1xudmFyIENpcmNzdGVyQ2hyb21MYWJlbFRyYWNrVmlldyA9IENpcmNzdGVyVHJhY2tWaWV3LmV4dGVuZCh7XG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICBDaXJjc3RlclRyYWNrVmlldy5wcm90b3R5cGUuaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICAvLyBVc2UgYSBzaW5nbGUgYXJjIGZvciByZW5kZXJpbmcgZGF0YS5cbiAgICAgICAgdGhpcy5pbm5lclJhZGl1cyA9IHRoaXMucmFkaXVzX2JvdW5kc1swXTtcbiAgICAgICAgdGhpcy5yYWRpdXNfYm91bmRzWzBdID0gdGhpcy5yYWRpdXNfYm91bmRzWzFdO1xuICAgICAgICB0aGlzLmJnX3N0cm9rZSA9IFwiI2ZmZlwiO1xuICAgICAgICB0aGlzLmJnX2ZpbGwgPSBcIiNmZmZcIjtcblxuICAgICAgICAvLyBNaW5pbXVtIGFyYyBkaXN0YW5jZSBmb3IgbGFiZWxzIHRvIGJlIGFwcGxpZWQuXG4gICAgICAgIHRoaXMubWluX2FyY19sZW4gPSAwLjA1O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgbGFiZWxzLlxuICAgICAqL1xuICAgIF9yZW5kZXJfZGF0YTogZnVuY3Rpb24oc3ZnKSB7XG4gICAgICAgIC8vIC0tIEFkZCBjaHJvbW9zb21lIGxhYmVsIHdoZXJlIGl0IHdpbGwgZml0OyBhbiBhbHRlcm5hdGl2ZSBsYWJlbGluZyBtZWNoYW5pc21cbiAgICAgICAgLy8gd291bGQgYmUgbmljZSBmb3Igc21hbGwgY2hyb21vc29tZXMuIC0tXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICB2YXIgY2hyb21fYXJjcyA9IHN2Zy5zZWxlY3RBbGwoXCJnXCIpO1xuXG4gICAgICAgIGNocm9tX2FyY3Muc2VsZWN0QWxsKFwicGF0aFwiKS5hdHRyKFwiaWRcIiwgZCA9PiBgbGFiZWwtJHtkLmRhdGEuY2hyb219YCk7XG5cbiAgICAgICAgY2hyb21fYXJjc1xuICAgICAgICAgICAgLmFwcGVuZChcInN2Zzp0ZXh0XCIpXG4gICAgICAgICAgICAuZmlsdGVyKGQgPT4gZC5lbmRBbmdsZSAtIGQuc3RhcnRBbmdsZSA+IHNlbGYubWluX2FyY19sZW4pXG4gICAgICAgICAgICAuYXR0cihcInRleHQtYW5jaG9yXCIsIFwibWlkZGxlXCIpXG4gICAgICAgICAgICAuYXBwZW5kKFwic3ZnOnRleHRQYXRoXCIpXG4gICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwiY2hyb20tbGFiZWxcIilcbiAgICAgICAgICAgIC5hdHRyKFwieGxpbms6aHJlZlwiLCBkID0+IGAjbGFiZWwtJHtkLmRhdGEuY2hyb219YClcbiAgICAgICAgICAgIC5hdHRyKFwic3RhcnRPZmZzZXRcIiwgXCIyNSVcIilcbiAgICAgICAgICAgIC50ZXh0KGQgPT4gZC5kYXRhLmNocm9tKTtcblxuICAgICAgICAvLyAtLSBBZGQgdGlja3MgdG8gZGVub3RlIGNocm9tb3NvbWUgbGVuZ3RoLiAtLVxuXG4gICAgICAgIC8qKiBSZXR1cm5zIGFuIGFycmF5IG9mIHRpY2sgYW5nbGVzIGFuZCBsYWJlbHMsIGdpdmVuIGEgY2hyb20gYXJjLiAqL1xuICAgICAgICB2YXIgY2hyb21BcmNUaWNrcyA9IGQgPT4ge1xuICAgICAgICAgICAgdmFyIGsgPSAoZC5lbmRBbmdsZSAtIGQuc3RhcnRBbmdsZSkgLyBkLnZhbHVlO1xuXG4gICAgICAgICAgICB2YXIgdGlja3MgPSBkMy5yYW5nZSgwLCBkLnZhbHVlLCAyNTAwMDAwMCkubWFwKCh2LCBpKSA9PiAoe1xuICAgICAgICAgICAgICAgIHJhZGl1czogc2VsZi5pbm5lclJhZGl1cyxcbiAgICAgICAgICAgICAgICBhbmdsZTogdiAqIGsgKyBkLnN0YXJ0QW5nbGUsXG4gICAgICAgICAgICAgICAgbGFiZWw6IGkgPT09IDAgPyAwIDogaSAlIDMgPyBudWxsIDogc2VsZi5mb3JtYXROdW0odilcbiAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgLy8gSWYgdGhlcmUgYXJlIGZld2VyIHRoYXQgNCB0aWNrcywgbGFiZWwgbGFzdCB0aWNrIHNvIHRoYXQgYXQgbGVhc3Qgb25lIG5vbi16ZXJvIHRpY2sgaXMgbGFiZWxlZC5cbiAgICAgICAgICAgIGlmICh0aWNrcy5sZW5ndGggPCA0KSB7XG4gICAgICAgICAgICAgICAgdGlja3NbdGlja3MubGVuZ3RoIC0gMV0ubGFiZWwgPSBzZWxmLmZvcm1hdE51bShcbiAgICAgICAgICAgICAgICAgICAgTWF0aC5yb3VuZCgodGlja3NbdGlja3MubGVuZ3RoIC0gMV0uYW5nbGUgLSBkLnN0YXJ0QW5nbGUpIC8gaylcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGlja3M7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqIFJvdGF0ZSBhbmQgbW92ZSB0ZXh0IGFzIG5lZWRlZC4gKi9cbiAgICAgICAgdmFyIHRleHRUcmFuc2Zvcm0gPSBkID0+IChkLmFuZ2xlID4gTWF0aC5QSSA/IFwicm90YXRlKDE4MCl0cmFuc2xhdGUoLTE2KVwiIDogbnVsbCk7XG5cbiAgICAgICAgLy8gRmlsdGVyIGNocm9tcyBmb3Igb25seSB0aG9zZSBsYXJnZSBlbm91Z2ggZm9yIGRpc3BsYXkuXG4gICAgICAgIHZhciB2aXNpYmxlQ2hyb21zID0gXy5maWx0ZXIodGhpcy5jaHJvbXNfbGF5b3V0LCBjID0+IGMuZW5kQW5nbGUgLSBjLnN0YXJ0QW5nbGUgPiBzZWxmLm1pbl9hcmNfbGVuKTtcblxuICAgICAgICB0aGlzLmRyYXdUaWNrcyh0aGlzLnBhcmVudF9lbHQsIHZpc2libGVDaHJvbXMsIGNocm9tQXJjVGlja3MsIHRleHRUcmFuc2Zvcm0pO1xuICAgIH1cbn0pO1xuXy5leHRlbmQoQ2lyY3N0ZXJDaHJvbUxhYmVsVHJhY2tWaWV3LnByb3RvdHlwZSwgVXNlc1RpY2tzKTtcblxuLyoqXG4gKiBWaWV3IGZvciBxdWFudGl0YXRpdmUgdHJhY2sgaW4gQ2lyY3N0ZXIuXG4gKi9cbnZhciBDaXJjc3RlclF1YW50aXRhdGl2ZVRyYWNrVmlldyA9IENpcmNzdGVyVHJhY2tWaWV3LmV4dGVuZCh7XG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICBDaXJjc3RlclRyYWNrVmlldy5wcm90b3R5cGUuaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXG4gICAgICAgIC8vIFdoZW4gY29uZmlnIHNldHRpbmdzIGNoYW5nZSwgdXBkYXRlIHZpZXcuXG4gICAgICAgIHZhciB0cmFja19jb25maWcgPSB0aGlzLnRyYWNrLmdldChcImNvbmZpZ1wiKTtcbiAgICAgICAgdHJhY2tfY29uZmlnLmdldChcIm1pbl92YWx1ZVwiKS5vbihcImNoYW5nZTp2YWx1ZVwiLCB0aGlzLl91cGRhdGVfbWluX21heCwgdGhpcyk7XG4gICAgICAgIHRyYWNrX2NvbmZpZy5nZXQoXCJtYXhfdmFsdWVcIikub24oXCJjaGFuZ2U6dmFsdWVcIiwgdGhpcy5fdXBkYXRlX21pbl9tYXgsIHRoaXMpO1xuICAgICAgICB0cmFja19jb25maWcuZ2V0KFwiY29sb3JcIikub24oXCJjaGFuZ2U6dmFsdWVcIiwgdGhpcy5fdHJhbnNpdGlvbl9jaHJvbV9kYXRhLCB0aGlzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIHRyYWNrIHdoZW4gbWluIGFuZC9vciBtYXggYXJlIGNoYW5nZWQuXG4gICAgICovXG4gICAgX3VwZGF0ZV9taW5fbWF4OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHRyYWNrX2NvbmZpZyA9IHRoaXMudHJhY2suZ2V0KFwiY29uZmlnXCIpO1xuXG4gICAgICAgIHZhciBuZXdfYm91bmRzID0gW3RyYWNrX2NvbmZpZy5nZXRfdmFsdWUoXCJtaW5fdmFsdWVcIiksIHRyYWNrX2NvbmZpZy5nZXRfdmFsdWUoXCJtYXhfdmFsdWVcIildO1xuXG4gICAgICAgIHRoaXMuX3VwZGF0ZV9kYXRhX2JvdW5kcyhuZXdfYm91bmRzKTtcblxuICAgICAgICAvLyBGSVhNRTogdGhpcyB3b3JrcyB0byB1cGRhdGUgdGljay90ZXh0IGJvdW5kcywgYnV0IHRoZXJlJ3MgcHJvYmFibHkgYSBiZXR0ZXIgd2F5IHRvIGRvIHRoaXNcbiAgICAgICAgLy8gYnkgdXBkYXRpbmcgdGhlIGRhdGEgaXRzZWxmLlxuICAgICAgICB0aGlzLnBhcmVudF9lbHQuc2VsZWN0QWxsKFwiLm1pbl9tYXhcIikudGV4dCgoZCwgaSkgPT4gbmV3X2JvdW5kc1tpXSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgcXVhbnRpbGUgZm9yIGFuIGFycmF5IG9mIG51bWJlcnMuXG4gICAgICovXG4gICAgX3F1YW50aWxlOiBmdW5jdGlvbihudW1iZXJzLCBxdWFudGlsZSkge1xuICAgICAgICBudW1iZXJzLnNvcnQoZDMuYXNjZW5kaW5nKTtcbiAgICAgICAgcmV0dXJuIGQzLnF1YW50aWxlKG51bWJlcnMsIHF1YW50aWxlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyBxdWFudGl0YXRpdmUgZGF0YSB3aXRoIHRoZSBmb3JtIFt4LCB2YWx1ZV0gYW5kIGFzc3VtZXMgZGF0YSBpcyBlcXVhbGx5IHNwYWNlZCBhY3Jvc3NcbiAgICAgKiBjaHJvbW9zb21lLiBBdHRhY2hzIGEgZGljdCB3aXRoIHRyYWNrIGFuZCBjaHJvbSBuYW1lIGluZm9ybWF0aW9uIHRvIERPTSBlbGVtZW50LlxuICAgICAqL1xuICAgIF9yZW5kZXJfY2hyb21fZGF0YTogZnVuY3Rpb24oc3ZnLCBjaHJvbV9hcmMsIGNocm9tX2RhdGEpIHtcbiAgICAgICAgdmFyIHBhdGhfZGF0YSA9IHRoaXMuX2dldF9wYXRoX2Z1bmN0aW9uKGNocm9tX2FyYywgY2hyb21fZGF0YSk7XG5cbiAgICAgICAgaWYgKCFwYXRoX2RhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlcmUgaXMgcGF0aCBkYXRhLCBzbyByZW5kZXIgYXMgcGF0aC5cbiAgICAgICAgdmFyIHBhcmVudCA9IHN2Zy5kYXR1bShjaHJvbV9kYXRhLmRhdGEpO1xuXG4gICAgICAgIHZhciBwYXRoID0gcGFyZW50XG4gICAgICAgICAgICAuYXBwZW5kKFwicGF0aFwiKVxuICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcImNocm9tLWRhdGFcIilcbiAgICAgICAgICAgIC5hdHRyKFwiY2hyb21cIiwgY2hyb21fYXJjLmRhdGEuY2hyb20pXG4gICAgICAgICAgICAuYXR0cihcImRcIiwgcGF0aF9kYXRhKTtcblxuICAgICAgICByZXR1cm4gcGF0aDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBmdW5jdGlvbiBmb3IgY3JlYXRpbmcgYSBwYXRoIGFjcm9zcyB0aGUgY2hyb20gYXJjLlxuICAgICAqL1xuICAgIF9nZXRfcGF0aF9mdW5jdGlvbjogZnVuY3Rpb24oY2hyb21fYXJjLCBjaHJvbV9kYXRhKSB7XG4gICAgICAgIC8vIElmIG5vIGNocm9tIGRhdGEsIHJldHVybiBudWxsLlxuICAgICAgICBpZiAodHlwZW9mIGNocm9tX2RhdGEgPT09IFwic3RyaW5nXCIgfHwgIWNocm9tX2RhdGEuZGF0YSB8fCBjaHJvbV9kYXRhLmRhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJhZGl1cyBzY2FsZXIuXG4gICAgICAgIHZhciByYWRpdXMgPSBkMy5zY2FsZVxuICAgICAgICAgICAgLmxpbmVhcigpXG4gICAgICAgICAgICAuZG9tYWluKHRoaXMuZGF0YV9ib3VuZHMpXG4gICAgICAgICAgICAucmFuZ2UodGhpcy5yYWRpdXNfYm91bmRzKVxuICAgICAgICAgICAgLmNsYW1wKHRydWUpO1xuXG4gICAgICAgIC8vIFNjYWxlciBmb3IgcGxhY2luZyBkYXRhIHBvaW50cyBhY3Jvc3MgYXJjLlxuICAgICAgICB2YXIgYW5nbGUgPSBkMy5zY2FsZVxuICAgICAgICAgICAgLmxpbmVhcigpXG4gICAgICAgICAgICAuZG9tYWluKFswLCBjaHJvbV9kYXRhLmRhdGEubGVuZ3RoXSlcbiAgICAgICAgICAgIC5yYW5nZShbY2hyb21fYXJjLnN0YXJ0QW5nbGUsIGNocm9tX2FyYy5lbmRBbmdsZV0pO1xuXG4gICAgICAgIC8vIFVzZSBsaW5lIGdlbmVyYXRvciB0byBjcmVhdGUgYXJlYS5cbiAgICAgICAgdmFyIGxpbmUgPSBkMy5zdmcubGluZVxuICAgICAgICAgICAgLnJhZGlhbCgpXG4gICAgICAgICAgICAuaW50ZXJwb2xhdGUoXCJsaW5lYXJcIilcbiAgICAgICAgICAgIC5yYWRpdXMoZCA9PiByYWRpdXMoZFsxXSkpXG4gICAgICAgICAgICAuYW5nbGUoKGQsIGkpID0+IGFuZ2xlKGkpKTtcblxuICAgICAgICByZXR1cm4gZDMuc3ZnLmFyZWFcbiAgICAgICAgICAgIC5yYWRpYWwoKVxuICAgICAgICAgICAgLmludGVycG9sYXRlKGxpbmUuaW50ZXJwb2xhdGUoKSlcbiAgICAgICAgICAgIC5pbm5lclJhZGl1cyhyYWRpdXMoMCkpXG4gICAgICAgICAgICAub3V0ZXJSYWRpdXMobGluZS5yYWRpdXMoKSlcbiAgICAgICAgICAgIC5hbmdsZShsaW5lLmFuZ2xlKCkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgdHJhY2sgbWluLCBtYXggdXNpbmcgdGlja3MuXG4gICAgICovXG4gICAgcmVuZGVyX2xhYmVsczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICB2YXIgLy8gS2VlcCBjb3VudGVyIG9mIHZpc2libGUgY2hyb21zLlxuICAgICAgICB0ZXh0VHJhbnNmb3JtID0gKCkgPT4gXCJyb3RhdGUoOTApXCI7XG5cbiAgICAgICAgLy8gRklYTUU6XG4gICAgICAgIC8vICgxKSB1c2luZyBtaW5fbWF4IGNsYXNzIGJlbG93IGlzIG5lZWRlZCBmb3IgX3VwZGF0ZV9taW5fbWF4LCB3aGljaCBjb3VsZCBiZSBpbXByb3ZlZC5cbiAgICAgICAgLy8gKDIpIHNob3dpbmcgY29uZmlnIG9uIHRpY2sgY2xpY2sgc2hvdWxkIGJlIHJlcGxhY2VkIGJ5IHByb3BlciB0cmFjayBjb25maWcgaWNvbi5cblxuICAgICAgICAvLyBEcmF3IG1pbiwgbWF4IG9uIGZpcnN0IGNocm9tIG9ubHkuXG4gICAgICAgIHZhciB0aWNrcyA9IHRoaXMuZHJhd1RpY2tzKFxuICAgICAgICAgICAgdGhpcy5wYXJlbnRfZWx0LFxuICAgICAgICAgICAgW3RoaXMuY2hyb21zX2xheW91dFswXV0sXG4gICAgICAgICAgICB0aGlzLl9kYXRhX2JvdW5kc190aWNrc19mbigpLFxuICAgICAgICAgICAgdGV4dFRyYW5zZm9ybSxcbiAgICAgICAgICAgIHRydWVcbiAgICAgICAgKS5jbGFzc2VkKFwibWluX21heFwiLCB0cnVlKTtcblxuICAgICAgICAvLyBTaG93IGNvbmZpZyB3aGVuIHRpY2tzIGFyZSBjbGlja2VkIG9uLlxuICAgICAgICBfLmVhY2godGlja3MsIHRpY2sgPT4ge1xuICAgICAgICAgICAgJCh0aWNrKS5jbGljaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIHZpZXcgPSBuZXcgY29uZmlnLkNvbmZpZ1NldHRpbmdDb2xsZWN0aW9uVmlldyh7XG4gICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb246IHNlbGYudHJhY2suZ2V0KFwiY29uZmlnXCIpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdmlldy5yZW5kZXJfaW5fbW9kYWwoXCJDb25maWd1cmUgVHJhY2tcIik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLypcbiAgICAgICAgLy8gRmlsdGVyIGZvciB2aXNpYmxlIGNocm9tcywgdGhlbiBmb3IgZXZlcnkgdGhpcmQgY2hyb20gc28gdGhhdCBsYWJlbHMgYXR0YWNoZWQgdG8gb25seSBldmVyeVxuICAgICAgICAvLyB0aGlyZCBjaHJvbS5cbiAgICAgICAgdmFyIHZpc2libGVDaHJvbXMgPSBfLmZpbHRlcih0aGlzLmNocm9tc19sYXlvdXQsIGZ1bmN0aW9uKGMpIHsgcmV0dXJuIGMuZW5kQW5nbGUgLSBjLnN0YXJ0QW5nbGUgPiAwLjA4OyB9KSxcbiAgICAgICAgICAgIGxhYmVsZWRDaHJvbXMgPSBfLmZpbHRlcih2aXNpYmxlQ2hyb21zLCBmdW5jdGlvbihjLCBpKSB7IHJldHVybiBpICUgMyA9PT0gMDsgfSk7XG4gICAgICAgIHRoaXMuZHJhd1RpY2tzKHRoaXMucGFyZW50X2VsdCwgbGFiZWxlZENocm9tcywgdGhpcy5fZGF0YV9ib3VuZHNfdGlja3NfZm4oKSwgdGV4dFRyYW5zZm9ybSwgdHJ1ZSk7XG4gICAgICAgICovXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRyYW5zaXRpb24gbGFiZWxzIHRvIG5ldyB2YWx1ZXMgKGUuZyBuZXcgcmFkaXVzIG9yIGRhdGEgYm91bmRzKS5cbiAgICAgKi9cbiAgICBfdHJhbnNpdGlvbl9sYWJlbHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBGSVhNRTogKGEpIHB1bGwgb3V0IGZ1bmN0aW9uIGZvciBnZXR0aW5nIGxhYmVsZWQgY2hyb21zPyBhbmQgKGIpIGZ1bmN0aW9uIHVzZWQgaW4gdHJhbnNpdGlvbiBiZWxvd1xuICAgICAgICAvLyBpcyBjb3BpZWQgZnJvbSBVc2VUaWNrcyBtaXhpbiwgc28gcHVsbCBvdXQgYW5kIG1ha2UgZ2VuZXJhbGx5IGF2YWlsYWJsZS5cblxuICAgICAgICAvLyBJZiB0aGVyZSBhcmUgbm8gZGF0YSBib3VuZHMsIG5vdGhpbmcgdG8gdHJhbnNpdGlvbi5cbiAgICAgICAgaWYgKHRoaXMuZGF0YV9ib3VuZHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUcmFuc2l0aW9uIGxhYmVscyB0byBuZXcgcmFkaXVzIGJvdW5kcy5cbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIHZhciB2aXNpYmxlQ2hyb21zID0gXy5maWx0ZXIodGhpcy5jaHJvbXNfbGF5b3V0LCBjID0+IGMuZW5kQW5nbGUgLSBjLnN0YXJ0QW5nbGUgPiAwLjA4KTtcblxuICAgICAgICB2YXIgbGFiZWxlZENocm9tcyA9IF8uZmlsdGVyKHZpc2libGVDaHJvbXMsIChjLCBpKSA9PiBpICUgMyA9PT0gMCk7XG5cbiAgICAgICAgdmFyIG5ld19kYXRhID0gXy5mbGF0dGVuKF8ubWFwKGxhYmVsZWRDaHJvbXMsIGMgPT4gc2VsZi5fZGF0YV9ib3VuZHNfdGlja3NfZm4oKShjKSkpO1xuXG4gICAgICAgIHRoaXMucGFyZW50X2VsdFxuICAgICAgICAgICAgLnNlbGVjdEFsbChcImcudGlja1wiKVxuICAgICAgICAgICAgLmRhdGEobmV3X2RhdGEpXG4gICAgICAgICAgICAudHJhbnNpdGlvbigpXG4gICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBkID0+IGByb3RhdGUoJHtkLmFuZ2xlICogMTgwIC8gTWF0aC5QSSAtIDkwfSl0cmFuc2xhdGUoJHtkLnJhZGl1c30sMClgKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IGZ1bmN0aW9uIGZvciBsb2NhdGluZyBkYXRhIGJvdW5kcyB0aWNrcy5cbiAgICAgKi9cbiAgICBfZGF0YV9ib3VuZHNfdGlja3NfZm46IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBDbG9zdXJlIHZhcnMuXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmlzaWJsZUNocm9tcyA9IDA7XG5cbiAgICAgICAgLy8gUmV0dXJuIGZ1bmN0aW9uIGZvciBsb2NhdGluZyB0aWNrcyBiYXNlZCBvbiBjaHJvbSBhcmMgZGF0YS5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIGQgLy8gU2V0IHVwIGRhdGEgdG8gZGlzcGxheSBtaW4sIG1heCB0aWNrcy5cbiAgICAgICAgKSA9PiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmFkaXVzOiBzZWxmLnJhZGl1c19ib3VuZHNbMF0sXG4gICAgICAgICAgICAgICAgYW5nbGU6IGQuc3RhcnRBbmdsZSxcbiAgICAgICAgICAgICAgICBsYWJlbDogc2VsZi5mb3JtYXROdW0oc2VsZi5kYXRhX2JvdW5kc1swXSlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmFkaXVzOiBzZWxmLnJhZGl1c19ib3VuZHNbMV0sXG4gICAgICAgICAgICAgICAgYW5nbGU6IGQuc3RhcnRBbmdsZSxcbiAgICAgICAgICAgICAgICBsYWJlbDogc2VsZi5mb3JtYXROdW0oc2VsZi5kYXRhX2JvdW5kc1sxXSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBhcnJheSB3aXRoIHR3byB2YWx1ZXMgZGVub3RpbmcgdGhlIG1pbmltdW0gYW5kIG1heGltdW1cbiAgICAgKiB2YWx1ZXMgZm9yIHRoZSB0cmFjay5cbiAgICAgKi9cbiAgICBnZXRfZGF0YV9ib3VuZHM6IGZ1bmN0aW9uKGRhdGEpIHt9XG59KTtcbl8uZXh0ZW5kKENpcmNzdGVyUXVhbnRpdGF0aXZlVHJhY2tWaWV3LnByb3RvdHlwZSwgVXNlc1RpY2tzKTtcblxuLyoqXG4gKiBCaWd3aWcgdHJhY2sgdmlldyBpbiBDaXJjc3Rlci5cbiAqL1xudmFyIENpcmNzdGVyQmlnV2lnVHJhY2tWaWV3ID0gQ2lyY3N0ZXJRdWFudGl0YXRpdmVUcmFja1ZpZXcuZXh0ZW5kKHtcbiAgICBnZXRfZGF0YV9ib3VuZHM6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgLy8gU2V0IG1heCBhY3Jvc3MgZGF0YXNldCBieSBleHRyYWN0aW5nIGFsbCB2YWx1ZXMsIGZsYXR0ZW5pbmcgdGhlbSBpbnRvIGFcbiAgICAgICAgLy8gc2luZ2xlIGFycmF5LCBhbmQgZ2V0dGluZyB0aGlyZCBxdWFydGlsZS5cbiAgICAgICAgdmFyIHZhbHVlcyA9IF8uZmxhdHRlbihcbiAgICAgICAgICAgIF8ubWFwKGRhdGEsIGQgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEVhY2ggZGF0YSBwb2ludCBoYXMgdGhlIGZvcm0gW3Bvc2l0aW9uLCB2YWx1ZV0sIHNvIHJldHVybiBhbGwgdmFsdWVzLlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXy5tYXAoXG4gICAgICAgICAgICAgICAgICAgICAgICBkLmRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcCAvLyBOdWxsIGlzIHVzZWQgZm9yIGEgbGFjayBvZiBkYXRhOyByZXNvbHZlIG51bGwgdG8gMCBmb3IgY29tcGFyaXNvbi5cbiAgICAgICAgICAgICAgICAgICAgICAgICkgPT4gcGFyc2VJbnQocFsxXSwgMTApIHx8IDBcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIEZvciBtYXgsIHVzZSA5OCUgcXVhbnRpbGUgaW4gYXR0ZW1wdCB0byBhdm9pZCB2ZXJ5IGxhcmdlIHZhbHVlcy4gSG93ZXZlciwgdGhpcyBtYXggbWF5IGJlIDBcbiAgICAgICAgLy8gZm9yIHNwYXJzZWx5IHBvcHVsYXRlZCBkYXRhLCBzbyB1c2UgbWF4IGluIHRoYXQgY2FzZS5cbiAgICAgICAgcmV0dXJuIFtfLm1pbih2YWx1ZXMpLCB0aGlzLl9xdWFudGlsZSh2YWx1ZXMsIDAuOTgpIHx8IF8ubWF4KHZhbHVlcyldO1xuICAgIH1cbn0pO1xuXG4vKipcbiAqIENocm9tb3NvbWUgaW50ZXJhY3Rpb25zIHRyYWNrIHZpZXcgaW4gQ2lyY3N0ZXIuXG4gKi9cbnZhciBDaXJjc3RlckNocm9tSW50ZXJhY3Rpb25zVHJhY2tWaWV3ID0gQ2lyY3N0ZXJUcmFja1ZpZXcuZXh0ZW5kKHtcbiAgICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgLy8gV2hlbiBkYXRhIGlzIHJlYWR5LCByZW5kZXIgdHJhY2suXG4gICAgICAgICQud2hlbihzZWxmLnRyYWNrLmdldChcImRhdGFfbWFuYWdlclwiKS5kYXRhX2lzX3JlYWR5KCkpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgLy8gV2hlbiBkYXRhIGhhcyBiZWVuIGZldGNoZWQsIHJlbmRlciB0cmFjay5cbiAgICAgICAgICAgICQud2hlbihzZWxmLnRyYWNrLmdldChcImRhdGFfbWFuYWdlclwiKS5nZXRfZ2Vub21lX3dpZGVfZGF0YShzZWxmLmdlbm9tZSkpLnRoZW4oZ2Vub21lX3dpZGVfZGF0YSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIGNob3JkX2RhdGEgPSBbXTtcbiAgICAgICAgICAgICAgICB2YXIgY2hyb21zX2luZm8gPSBzZWxmLmdlbm9tZS5nZXRfY2hyb21zX2luZm8oKTtcbiAgICAgICAgICAgICAgICAvLyBDb252ZXJ0IGNocm9tb3NvbWUgZGF0YSBpbnRvIGNob3JkIGRhdGEuXG4gICAgICAgICAgICAgICAgXy5lYWNoKGdlbm9tZV93aWRlX2RhdGEsIChjaHJvbV9kYXRhLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBNYXAgZWFjaCBpbnRlcmFjdGlvbiBpbnRvIGNob3JkIGRhdGEuXG4gICAgICAgICAgICAgICAgICAgIHZhciBjdXJfY2hyb20gPSBjaHJvbXNfaW5mb1tpbmRleF0uY2hyb207XG4gICAgICAgICAgICAgICAgICAgIHZhciBjaHJvbV9jaG9yZF9kYXRhID0gXy5tYXAoY2hyb21fZGF0YS5kYXRhLCBkYXR1bSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBFYWNoIGRhdHVtIGlzIGFuIGludGVyYWN0aW9uL2Nob3JkLlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNvdXJjZV9hbmdsZSA9IHNlbGYuX2dldF9yZWdpb25fYW5nbGUoY3VyX2Nocm9tLCBkYXR1bVsxXSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0YXJnZXRfYW5nbGUgPSBzZWxmLl9nZXRfcmVnaW9uX2FuZ2xlKGRhdHVtWzNdLCBkYXR1bVs0XSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0QW5nbGU6IHNvdXJjZV9hbmdsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kQW5nbGU6IHNvdXJjZV9hbmdsZSArIDAuMDFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydEFuZ2xlOiB0YXJnZXRfYW5nbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZEFuZ2xlOiB0YXJnZXRfYW5nbGUgKyAwLjAxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgY2hvcmRfZGF0YSA9IGNob3JkX2RhdGEuY29uY2F0KGNocm9tX2Nob3JkX2RhdGEpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgc2VsZi5wYXJlbnRfZWx0XG4gICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoXCJnXCIpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJjaG9yZFwiKVxuICAgICAgICAgICAgICAgICAgICAuc2VsZWN0QWxsKFwicGF0aFwiKVxuICAgICAgICAgICAgICAgICAgICAuZGF0YShjaG9yZF9kYXRhKVxuICAgICAgICAgICAgICAgICAgICAuZW50ZXIoKVxuICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKFwicGF0aFwiKVxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJmaWxsXCIsIHNlbGYuZ2V0X2ZpbGxfY29sb3IoKSlcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJkXCIsIGQzLnN2Zy5jaG9yZCgpLnJhZGl1cyhzZWxmLnJhZGl1c19ib3VuZHNbMF0pKVxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIDEpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICB1cGRhdGVfcmFkaXVzX2JvdW5kczogZnVuY3Rpb24ocmFkaXVzX2JvdW5kcykge1xuICAgICAgICB0aGlzLnJhZGl1c19ib3VuZHMgPSByYWRpdXNfYm91bmRzO1xuICAgICAgICB0aGlzLnBhcmVudF9lbHRcbiAgICAgICAgICAgIC5zZWxlY3RBbGwoXCJwYXRoXCIpXG4gICAgICAgICAgICAudHJhbnNpdGlvbigpXG4gICAgICAgICAgICAuYXR0cihcImRcIiwgZDMuc3ZnLmNob3JkKCkucmFkaXVzKHRoaXMucmFkaXVzX2JvdW5kc1swXSkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHJhZGlhbnMgZm9yIGEgZ2Vub21pYyBwb3NpdGlvbi5cbiAgICAgKi9cbiAgICBfZ2V0X3JlZ2lvbl9hbmdsZTogZnVuY3Rpb24oY2hyb20sIHBvc2l0aW9uKSB7XG4gICAgICAgIC8vIEZpbmQgY2hyb20gYW5nbGUgZGF0YVxuICAgICAgICB2YXIgY2hyb21fYW5nbGVfZGF0YSA9IF8uZmluZCh0aGlzLmNocm9tc19sYXlvdXQsIGNocm9tX2xheW91dCA9PiBjaHJvbV9sYXlvdXQuZGF0YS5jaHJvbSA9PT0gY2hyb20pO1xuXG4gICAgICAgIC8vIFJldHVybiBhbmdsZSBhdCBwb3NpdGlvbi5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIGNocm9tX2FuZ2xlX2RhdGEuZW5kQW5nbGUgLVxuICAgICAgICAgICAgKGNocm9tX2FuZ2xlX2RhdGEuZW5kQW5nbGUgLSBjaHJvbV9hbmdsZV9kYXRhLnN0YXJ0QW5nbGUpICpcbiAgICAgICAgICAgICAgICAoY2hyb21fYW5nbGVfZGF0YS5kYXRhLmxlbiAtIHBvc2l0aW9uKSAvXG4gICAgICAgICAgICAgICAgY2hyb21fYW5nbGVfZGF0YS5kYXRhLmxlblxuICAgICAgICApO1xuICAgIH1cbn0pO1xuXG4vLyBjaXJjc3RlciBhcHAgbG9hZGVyXG52YXIgQ2lyY3N0ZXIgPSBCYWNrYm9uZS5WaWV3LmV4dGVuZCh7XG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIGxvYWQgY3NzXG4gICAgICAgIG1vZF91dGlscy5jc3NMb2FkRmlsZShcInN0YXRpYy9zdHlsZS9jaXJjc3Rlci5jc3NcIik7XG4gICAgICAgIC8vIC0tIENvbmZpZ3VyZSB2aXN1YWxpemF0aW9uIC0tXG4gICAgICAgIHZhciBnZW5vbWUgPSBuZXcgdmlzdWFsaXphdGlvbi5HZW5vbWUoZ2FsYXh5X2NvbmZpZy5hcHAuZ2Vub21lKTtcblxuICAgICAgICB2YXIgdmlzID0gbmV3IHZpc3VhbGl6YXRpb24uR2Vub21lVmlzdWFsaXphdGlvbihnYWxheHlfY29uZmlnLmFwcC52aXpfY29uZmlnKTtcblxuICAgICAgICAvLyBBZGQgQ2lyY3N0ZXItc3BlY2lmaWMgY29uZmlnIG9wdGlvbnMuXG4gICAgICAgIHZpcy5nZXQoXCJjb25maWdcIikuYWRkKFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBrZXk6IFwiYXJjX2RhdGFzZXRfaGVpZ2h0XCIsXG4gICAgICAgICAgICAgICAgbGFiZWw6IFwiQXJjIERhdGFzZXQgSGVpZ2h0XCIsXG4gICAgICAgICAgICAgICAgdHlwZTogXCJpbnRcIixcbiAgICAgICAgICAgICAgICB2YWx1ZTogMjUsXG4gICAgICAgICAgICAgICAgdmlldzogXCJjaXJjc3RlclwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGtleTogXCJ0cmFja19nYXBcIixcbiAgICAgICAgICAgICAgICBsYWJlbDogXCJHYXAgQmV0d2VlbiBUcmFja3NcIixcbiAgICAgICAgICAgICAgICB0eXBlOiBcImludFwiLFxuICAgICAgICAgICAgICAgIHZhbHVlOiA1LFxuICAgICAgICAgICAgICAgIHZpZXc6IFwiY2lyY3N0ZXJcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBrZXk6IFwidG90YWxfZ2FwXCIsXG4gICAgICAgICAgICAgICAgbGFiZWw6IFwiR2FwIFswLTFdXCIsXG4gICAgICAgICAgICAgICAgdHlwZTogXCJmbG9hdFwiLFxuICAgICAgICAgICAgICAgIHZhbHVlOiAwLjQsXG4gICAgICAgICAgICAgICAgdmlldzogXCJjaXJjc3RlclwiLFxuICAgICAgICAgICAgICAgIGhpZGRlbjogdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICBdKTtcblxuICAgICAgICB2YXIgdml6X3ZpZXcgPSBuZXcgQ2lyY3N0ZXJWaWV3KHtcbiAgICAgICAgICAgIC8vIHZpZXcgcGFuZVxuICAgICAgICAgICAgZWw6ICQoXCIjY2VudGVyIC51bmlmaWVkLXBhbmVsLWJvZHlcIiksXG4gICAgICAgICAgICBnZW5vbWU6IGdlbm9tZSxcbiAgICAgICAgICAgIG1vZGVsOiB2aXNcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gUmVuZGVyIHZpenVhbGl6YXRpb25cbiAgICAgICAgdml6X3ZpZXcucmVuZGVyKCk7XG5cbiAgICAgICAgLy8gc2V0dXAgdGl0bGVcbiAgICAgICAgJChcIiNjZW50ZXIgLnVuaWZpZWQtcGFuZWwtaGVhZGVyLWlubmVyXCIpLmFwcGVuZChcbiAgICAgICAgICAgIGAke2dhbGF4eV9jb25maWcuYXBwLnZpel9jb25maWcudGl0bGV9ICR7Z2FsYXh5X2NvbmZpZy5hcHAudml6X2NvbmZpZy5kYmtleX1gXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gc2V0dXAgbWVudVxuICAgICAgICB2YXIgbWVudSA9IG1vZF9pY29uX2J0bi5jcmVhdGVfaWNvbl9idXR0b25zX21lbnUoXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBpY29uX2NsYXNzOiBcInBsdXMtYnV0dG9uXCIsXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiBfbChcIkFkZCB0cmFja3NcIiksXG4gICAgICAgICAgICAgICAgICAgIG9uX2NsaWNrOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpc3VhbGl6YXRpb24uc2VsZWN0X2RhdGFzZXRzKHsgZGJrZXk6IHZpcy5nZXQoXCJkYmtleVwiKSB9LCB0cmFja3MgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpcy5hZGRfdHJhY2tzKHRyYWNrcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBpY29uX2NsYXNzOiBcImdlYXJcIixcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IF9sKFwiU2V0dGluZ3NcIiksXG4gICAgICAgICAgICAgICAgICAgIG9uX2NsaWNrOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2aWV3ID0gbmV3IGNvbmZpZy5Db25maWdTZXR0aW5nQ29sbGVjdGlvblZpZXcoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb246IHZpcy5nZXQoXCJjb25maWdcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmlldy5yZW5kZXJfaW5fbW9kYWwoXCJDb25maWd1cmUgVmlzdWFsaXphdGlvblwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBpY29uX2NsYXNzOiBcImRpc2stLWFycm93XCIsXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiBfbChcIlNhdmVcIiksXG4gICAgICAgICAgICAgICAgICAgIG9uX2NsaWNrOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNob3cgc2F2aW5nIGRpYWxvZyBib3hcbiAgICAgICAgICAgICAgICAgICAgICAgIEdhbGF4eS5tb2RhbC5zaG93KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogX2woXCJTYXZpbmcuLi5cIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9keTogXCJwcm9ncmVzc1wiXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2VuZCB0byBzZXJ2ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICQuYWpheCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiBgJHtHYWxheHkucm9vdH12aXN1YWxpemF0aW9uL3NhdmVgLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiUE9TVFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFUeXBlOiBcImpzb25cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiB2aXMuZ2V0KFwidmlzX2lkXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogdmlzLmdldChcInRpdGxlXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYmtleTogdmlzLmdldChcImRia2V5XCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInRyYWNrc3RlclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aXNfanNvbjogSlNPTi5zdHJpbmdpZnkodmlzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnN1Y2Nlc3ModmlzX2luZm8gPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBHYWxheHkubW9kYWwuaGlkZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aXMuc2V0KFwidmlzX2lkXCIsIHZpc19pbmZvLnZpc19pZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZXJyb3IoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzaG93IGRpYWxvZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBHYWxheHkubW9kYWwuc2hvdyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogX2woXCJDb3VsZCBOb3QgU2F2ZVwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IFwiQ291bGQgbm90IHNhdmUgdmlzdWFsaXphdGlvbi4gUGxlYXNlIHRyeSBhZ2FpbiBsYXRlci5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDYW5jZWw6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBHYWxheHkubW9kYWwuaGlkZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgaWNvbl9jbGFzczogXCJjcm9zcy1jaXJjbGVcIixcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IF9sKFwiQ2xvc2VcIiksXG4gICAgICAgICAgICAgICAgICAgIG9uX2NsaWNrOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbiA9IGAke0dhbGF4eS5yb290fXZpc3VhbGl6YXRpb25zL2xpc3RgO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIHsgdG9vbHRpcF9jb25maWc6IHsgcGxhY2VtZW50OiBcImJvdHRvbVwiIH0gfVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIGFkZCBtZW51XG4gICAgICAgIG1lbnUuJGVsLmF0dHIoXCJzdHlsZVwiLCBcImZsb2F0OiByaWdodFwiKTtcbiAgICAgICAgJChcIiNjZW50ZXIgLnVuaWZpZWQtcGFuZWwtaGVhZGVyLWlubmVyXCIpLmFwcGVuZChtZW51LiRlbCk7XG5cbiAgICAgICAgLy8gbWFudWFsIHRvb2x0aXAgY29uZmlnIGJlY2F1c2UgZGVmYXVsdCBncmF2aXR5IGlzIFMgYW5kIGNhbm5vdCBiZSBjaGFuZ2VkXG4gICAgICAgICQoXCIubWVudS1idXR0b25cIikudG9vbHRpcCh7IHBsYWNlbWVudDogXCJib3R0b21cIiB9KTtcbiAgICB9XG59KTtcblxuLy8gTW9kdWxlIGV4cG9ydHMuXG5leHBvcnQgZGVmYXVsdCB7XG4gICAgR2FsYXh5QXBwOiBDaXJjc3RlclxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBnYWxheHkvc2NyaXB0cy92aXovY2lyY3N0ZXIuanMiXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7OztBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUNBOzs7QUFBQTtBQUNBOzs7QUFBQTtBQUNBOzs7QUFBQTtBQUNBOzs7QUFBQTtBQUNBOzs7OztBQUFBOzs7O0FBSUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQXJCQTtBQUNBO0FBdUJBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQVdBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFPQTtBQVFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQW5GQTtBQUNBO0FBcUZBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFOQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBaFFBO0FBQ0E7QUFrUUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQW5VQTtBQUNBO0FBcVVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBSUE7QUFBQTtBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUFBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBaEVBO0FBa0VBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBR0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FBT0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUlBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUlBO0FBQ0E7QUFDQTtBQUhBO0FBTUE7QUFDQTtBQUNBO0FBSEE7QUFSQTtBQWNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBaE1BO0FBa01BO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQXZCQTtBQUNBO0FBeUJBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUZBO0FBTEE7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBdkVBO0FBQ0E7QUF5RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFDQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBUkE7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFKQTtBQWFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUhBO0FBU0E7QUFDQTtBQXZDQTtBQTBDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFDQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBbElBO0FBQ0E7QUFvSUE7QUFDQTtBQUNBO0FBREE7QSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///294\n");

/***/ }),

/***/ 295:
/*!***********************************!*\
  !*** ./galaxy/scripts/libs/d3.js ***!
  \***********************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;!function() {\n  var d3 = {\n    version: \"3.5.17\"\n  };\n  var d3_arraySlice = [].slice, d3_array = function(list) {\n    return d3_arraySlice.call(list);\n  };\n  var d3_document = this.document;\n  function d3_documentElement(node) {\n    return node && (node.ownerDocument || node.document || node).documentElement;\n  }\n  function d3_window(node) {\n    return node && (node.ownerDocument && node.ownerDocument.defaultView || node.document && node || node.defaultView);\n  }\n  if (d3_document) {\n    try {\n      d3_array(d3_document.documentElement.childNodes)[0].nodeType;\n    } catch (e) {\n      d3_array = function(list) {\n        var i = list.length, array = new Array(i);\n        while (i--) array[i] = list[i];\n        return array;\n      };\n    }\n  }\n  if (!Date.now) Date.now = function() {\n    return +new Date();\n  };\n  if (d3_document) {\n    try {\n      d3_document.createElement(\"DIV\").style.setProperty(\"opacity\", 0, \"\");\n    } catch (error) {\n      var d3_element_prototype = this.Element.prototype, d3_element_setAttribute = d3_element_prototype.setAttribute, d3_element_setAttributeNS = d3_element_prototype.setAttributeNS, d3_style_prototype = this.CSSStyleDeclaration.prototype, d3_style_setProperty = d3_style_prototype.setProperty;\n      d3_element_prototype.setAttribute = function(name, value) {\n        d3_element_setAttribute.call(this, name, value + \"\");\n      };\n      d3_element_prototype.setAttributeNS = function(space, local, value) {\n        d3_element_setAttributeNS.call(this, space, local, value + \"\");\n      };\n      d3_style_prototype.setProperty = function(name, value, priority) {\n        d3_style_setProperty.call(this, name, value + \"\", priority);\n      };\n    }\n  }\n  d3.ascending = d3_ascending;\n  function d3_ascending(a, b) {\n    return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;\n  }\n  d3.descending = function(a, b) {\n    return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;\n  };\n  d3.min = function(array, f) {\n    var i = -1, n = array.length, a, b;\n    if (arguments.length === 1) {\n      while (++i < n) if ((b = array[i]) != null && b >= b) {\n        a = b;\n        break;\n      }\n      while (++i < n) if ((b = array[i]) != null && a > b) a = b;\n    } else {\n      while (++i < n) if ((b = f.call(array, array[i], i)) != null && b >= b) {\n        a = b;\n        break;\n      }\n      while (++i < n) if ((b = f.call(array, array[i], i)) != null && a > b) a = b;\n    }\n    return a;\n  };\n  d3.max = function(array, f) {\n    var i = -1, n = array.length, a, b;\n    if (arguments.length === 1) {\n      while (++i < n) if ((b = array[i]) != null && b >= b) {\n        a = b;\n        break;\n      }\n      while (++i < n) if ((b = array[i]) != null && b > a) a = b;\n    } else {\n      while (++i < n) if ((b = f.call(array, array[i], i)) != null && b >= b) {\n        a = b;\n        break;\n      }\n      while (++i < n) if ((b = f.call(array, array[i], i)) != null && b > a) a = b;\n    }\n    return a;\n  };\n  d3.extent = function(array, f) {\n    var i = -1, n = array.length, a, b, c;\n    if (arguments.length === 1) {\n      while (++i < n) if ((b = array[i]) != null && b >= b) {\n        a = c = b;\n        break;\n      }\n      while (++i < n) if ((b = array[i]) != null) {\n        if (a > b) a = b;\n        if (c < b) c = b;\n      }\n    } else {\n      while (++i < n) if ((b = f.call(array, array[i], i)) != null && b >= b) {\n        a = c = b;\n        break;\n      }\n      while (++i < n) if ((b = f.call(array, array[i], i)) != null) {\n        if (a > b) a = b;\n        if (c < b) c = b;\n      }\n    }\n    return [ a, c ];\n  };\n  function d3_number(x) {\n    return x === null ? NaN : +x;\n  }\n  function d3_numeric(x) {\n    return !isNaN(x);\n  }\n  d3.sum = function(array, f) {\n    var s = 0, n = array.length, a, i = -1;\n    if (arguments.length === 1) {\n      while (++i < n) if (d3_numeric(a = +array[i])) s += a;\n    } else {\n      while (++i < n) if (d3_numeric(a = +f.call(array, array[i], i))) s += a;\n    }\n    return s;\n  };\n  d3.mean = function(array, f) {\n    var s = 0, n = array.length, a, i = -1, j = n;\n    if (arguments.length === 1) {\n      while (++i < n) if (d3_numeric(a = d3_number(array[i]))) s += a; else --j;\n    } else {\n      while (++i < n) if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) s += a; else --j;\n    }\n    if (j) return s / j;\n  };\n  d3.quantile = function(values, p) {\n    var H = (values.length - 1) * p + 1, h = Math.floor(H), v = +values[h - 1], e = H - h;\n    return e ? v + e * (values[h] - v) : v;\n  };\n  d3.median = function(array, f) {\n    var numbers = [], n = array.length, a, i = -1;\n    if (arguments.length === 1) {\n      while (++i < n) if (d3_numeric(a = d3_number(array[i]))) numbers.push(a);\n    } else {\n      while (++i < n) if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) numbers.push(a);\n    }\n    if (numbers.length) return d3.quantile(numbers.sort(d3_ascending), .5);\n  };\n  d3.variance = function(array, f) {\n    var n = array.length, m = 0, a, d, s = 0, i = -1, j = 0;\n    if (arguments.length === 1) {\n      while (++i < n) {\n        if (d3_numeric(a = d3_number(array[i]))) {\n          d = a - m;\n          m += d / ++j;\n          s += d * (a - m);\n        }\n      }\n    } else {\n      while (++i < n) {\n        if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) {\n          d = a - m;\n          m += d / ++j;\n          s += d * (a - m);\n        }\n      }\n    }\n    if (j > 1) return s / (j - 1);\n  };\n  d3.deviation = function() {\n    var v = d3.variance.apply(this, arguments);\n    return v ? Math.sqrt(v) : v;\n  };\n  function d3_bisector(compare) {\n    return {\n      left: function(a, x, lo, hi) {\n        if (arguments.length < 3) lo = 0;\n        if (arguments.length < 4) hi = a.length;\n        while (lo < hi) {\n          var mid = lo + hi >>> 1;\n          if (compare(a[mid], x) < 0) lo = mid + 1; else hi = mid;\n        }\n        return lo;\n      },\n      right: function(a, x, lo, hi) {\n        if (arguments.length < 3) lo = 0;\n        if (arguments.length < 4) hi = a.length;\n        while (lo < hi) {\n          var mid = lo + hi >>> 1;\n          if (compare(a[mid], x) > 0) hi = mid; else lo = mid + 1;\n        }\n        return lo;\n      }\n    };\n  }\n  var d3_bisect = d3_bisector(d3_ascending);\n  d3.bisectLeft = d3_bisect.left;\n  d3.bisect = d3.bisectRight = d3_bisect.right;\n  d3.bisector = function(f) {\n    return d3_bisector(f.length === 1 ? function(d, x) {\n      return d3_ascending(f(d), x);\n    } : f);\n  };\n  d3.shuffle = function(array, i0, i1) {\n    if ((m = arguments.length) < 3) {\n      i1 = array.length;\n      if (m < 2) i0 = 0;\n    }\n    var m = i1 - i0, t, i;\n    while (m) {\n      i = Math.random() * m-- | 0;\n      t = array[m + i0], array[m + i0] = array[i + i0], array[i + i0] = t;\n    }\n    return array;\n  };\n  d3.permute = function(array, indexes) {\n    var i = indexes.length, permutes = new Array(i);\n    while (i--) permutes[i] = array[indexes[i]];\n    return permutes;\n  };\n  d3.pairs = function(array) {\n    var i = 0, n = array.length - 1, p0, p1 = array[0], pairs = new Array(n < 0 ? 0 : n);\n    while (i < n) pairs[i] = [ p0 = p1, p1 = array[++i] ];\n    return pairs;\n  };\n  d3.transpose = function(matrix) {\n    if (!(n = matrix.length)) return [];\n    for (var i = -1, m = d3.min(matrix, d3_transposeLength), transpose = new Array(m); ++i < m; ) {\n      for (var j = -1, n, row = transpose[i] = new Array(n); ++j < n; ) {\n        row[j] = matrix[j][i];\n      }\n    }\n    return transpose;\n  };\n  function d3_transposeLength(d) {\n    return d.length;\n  }\n  d3.zip = function() {\n    return d3.transpose(arguments);\n  };\n  d3.keys = function(map) {\n    var keys = [];\n    for (var key in map) keys.push(key);\n    return keys;\n  };\n  d3.values = function(map) {\n    var values = [];\n    for (var key in map) values.push(map[key]);\n    return values;\n  };\n  d3.entries = function(map) {\n    var entries = [];\n    for (var key in map) entries.push({\n      key: key,\n      value: map[key]\n    });\n    return entries;\n  };\n  d3.merge = function(arrays) {\n    var n = arrays.length, m, i = -1, j = 0, merged, array;\n    while (++i < n) j += arrays[i].length;\n    merged = new Array(j);\n    while (--n >= 0) {\n      array = arrays[n];\n      m = array.length;\n      while (--m >= 0) {\n        merged[--j] = array[m];\n      }\n    }\n    return merged;\n  };\n  var abs = Math.abs;\n  d3.range = function(start, stop, step) {\n    if (arguments.length < 3) {\n      step = 1;\n      if (arguments.length < 2) {\n        stop = start;\n        start = 0;\n      }\n    }\n    if ((stop - start) / step === Infinity) throw new Error(\"infinite range\");\n    var range = [], k = d3_range_integerScale(abs(step)), i = -1, j;\n    start *= k, stop *= k, step *= k;\n    if (step < 0) while ((j = start + step * ++i) > stop) range.push(j / k); else while ((j = start + step * ++i) < stop) range.push(j / k);\n    return range;\n  };\n  function d3_range_integerScale(x) {\n    var k = 1;\n    while (x * k % 1) k *= 10;\n    return k;\n  }\n  function d3_class(ctor, properties) {\n    for (var key in properties) {\n      Object.defineProperty(ctor.prototype, key, {\n        value: properties[key],\n        enumerable: false\n      });\n    }\n  }\n  d3.map = function(object, f) {\n    var map = new d3_Map();\n    if (object instanceof d3_Map) {\n      object.forEach(function(key, value) {\n        map.set(key, value);\n      });\n    } else if (Array.isArray(object)) {\n      var i = -1, n = object.length, o;\n      if (arguments.length === 1) while (++i < n) map.set(i, object[i]); else while (++i < n) map.set(f.call(object, o = object[i], i), o);\n    } else {\n      for (var key in object) map.set(key, object[key]);\n    }\n    return map;\n  };\n  function d3_Map() {\n    this._ = Object.create(null);\n  }\n  var d3_map_proto = \"__proto__\", d3_map_zero = \"\\x00\";\n  d3_class(d3_Map, {\n    has: d3_map_has,\n    get: function(key) {\n      return this._[d3_map_escape(key)];\n    },\n    set: function(key, value) {\n      return this._[d3_map_escape(key)] = value;\n    },\n    remove: d3_map_remove,\n    keys: d3_map_keys,\n    values: function() {\n      var values = [];\n      for (var key in this._) values.push(this._[key]);\n      return values;\n    },\n    entries: function() {\n      var entries = [];\n      for (var key in this._) entries.push({\n        key: d3_map_unescape(key),\n        value: this._[key]\n      });\n      return entries;\n    },\n    size: d3_map_size,\n    empty: d3_map_empty,\n    forEach: function(f) {\n      for (var key in this._) f.call(this, d3_map_unescape(key), this._[key]);\n    }\n  });\n  function d3_map_escape(key) {\n    return (key += \"\") === d3_map_proto || key[0] === d3_map_zero ? d3_map_zero + key : key;\n  }\n  function d3_map_unescape(key) {\n    return (key += \"\")[0] === d3_map_zero ? key.slice(1) : key;\n  }\n  function d3_map_has(key) {\n    return d3_map_escape(key) in this._;\n  }\n  function d3_map_remove(key) {\n    return (key = d3_map_escape(key)) in this._ && delete this._[key];\n  }\n  function d3_map_keys() {\n    var keys = [];\n    for (var key in this._) keys.push(d3_map_unescape(key));\n    return keys;\n  }\n  function d3_map_size() {\n    var size = 0;\n    for (var key in this._) ++size;\n    return size;\n  }\n  function d3_map_empty() {\n    for (var key in this._) return false;\n    return true;\n  }\n  d3.nest = function() {\n    var nest = {}, keys = [], sortKeys = [], sortValues, rollup;\n    function map(mapType, array, depth) {\n      if (depth >= keys.length) return rollup ? rollup.call(nest, array) : sortValues ? array.sort(sortValues) : array;\n      var i = -1, n = array.length, key = keys[depth++], keyValue, object, setter, valuesByKey = new d3_Map(), values;\n      while (++i < n) {\n        if (values = valuesByKey.get(keyValue = key(object = array[i]))) {\n          values.push(object);\n        } else {\n          valuesByKey.set(keyValue, [ object ]);\n        }\n      }\n      if (mapType) {\n        object = mapType();\n        setter = function(keyValue, values) {\n          object.set(keyValue, map(mapType, values, depth));\n        };\n      } else {\n        object = {};\n        setter = function(keyValue, values) {\n          object[keyValue] = map(mapType, values, depth);\n        };\n      }\n      valuesByKey.forEach(setter);\n      return object;\n    }\n    function entries(map, depth) {\n      if (depth >= keys.length) return map;\n      var array = [], sortKey = sortKeys[depth++];\n      map.forEach(function(key, keyMap) {\n        array.push({\n          key: key,\n          values: entries(keyMap, depth)\n        });\n      });\n      return sortKey ? array.sort(function(a, b) {\n        return sortKey(a.key, b.key);\n      }) : array;\n    }\n    nest.map = function(array, mapType) {\n      return map(mapType, array, 0);\n    };\n    nest.entries = function(array) {\n      return entries(map(d3.map, array, 0), 0);\n    };\n    nest.key = function(d) {\n      keys.push(d);\n      return nest;\n    };\n    nest.sortKeys = function(order) {\n      sortKeys[keys.length - 1] = order;\n      return nest;\n    };\n    nest.sortValues = function(order) {\n      sortValues = order;\n      return nest;\n    };\n    nest.rollup = function(f) {\n      rollup = f;\n      return nest;\n    };\n    return nest;\n  };\n  d3.set = function(array) {\n    var set = new d3_Set();\n    if (array) for (var i = 0, n = array.length; i < n; ++i) set.add(array[i]);\n    return set;\n  };\n  function d3_Set() {\n    this._ = Object.create(null);\n  }\n  d3_class(d3_Set, {\n    has: d3_map_has,\n    add: function(key) {\n      this._[d3_map_escape(key += \"\")] = true;\n      return key;\n    },\n    remove: d3_map_remove,\n    values: d3_map_keys,\n    size: d3_map_size,\n    empty: d3_map_empty,\n    forEach: function(f) {\n      for (var key in this._) f.call(this, d3_map_unescape(key));\n    }\n  });\n  d3.behavior = {};\n  function d3_identity(d) {\n    return d;\n  }\n  d3.rebind = function(target, source) {\n    var i = 1, n = arguments.length, method;\n    while (++i < n) target[method = arguments[i]] = d3_rebind(target, source, source[method]);\n    return target;\n  };\n  function d3_rebind(target, source, method) {\n    return function() {\n      var value = method.apply(source, arguments);\n      return value === source ? target : value;\n    };\n  }\n  function d3_vendorSymbol(object, name) {\n    if (name in object) return name;\n    name = name.charAt(0).toUpperCase() + name.slice(1);\n    for (var i = 0, n = d3_vendorPrefixes.length; i < n; ++i) {\n      var prefixName = d3_vendorPrefixes[i] + name;\n      if (prefixName in object) return prefixName;\n    }\n  }\n  var d3_vendorPrefixes = [ \"webkit\", \"ms\", \"moz\", \"Moz\", \"o\", \"O\" ];\n  function d3_noop() {}\n  d3.dispatch = function() {\n    var dispatch = new d3_dispatch(), i = -1, n = arguments.length;\n    while (++i < n) dispatch[arguments[i]] = d3_dispatch_event(dispatch);\n    return dispatch;\n  };\n  function d3_dispatch() {}\n  d3_dispatch.prototype.on = function(type, listener) {\n    var i = type.indexOf(\".\"), name = \"\";\n    if (i >= 0) {\n      name = type.slice(i + 1);\n      type = type.slice(0, i);\n    }\n    if (type) return arguments.length < 2 ? this[type].on(name) : this[type].on(name, listener);\n    if (arguments.length === 2) {\n      if (listener == null) for (type in this) {\n        if (this.hasOwnProperty(type)) this[type].on(name, null);\n      }\n      return this;\n    }\n  };\n  function d3_dispatch_event(dispatch) {\n    var listeners = [], listenerByName = new d3_Map();\n    function event() {\n      var z = listeners, i = -1, n = z.length, l;\n      while (++i < n) if (l = z[i].on) l.apply(this, arguments);\n      return dispatch;\n    }\n    event.on = function(name, listener) {\n      var l = listenerByName.get(name), i;\n      if (arguments.length < 2) return l && l.on;\n      if (l) {\n        l.on = null;\n        listeners = listeners.slice(0, i = listeners.indexOf(l)).concat(listeners.slice(i + 1));\n        listenerByName.remove(name);\n      }\n      if (listener) listeners.push(listenerByName.set(name, {\n        on: listener\n      }));\n      return dispatch;\n    };\n    return event;\n  }\n  d3.event = null;\n  function d3_eventPreventDefault() {\n    d3.event.preventDefault();\n  }\n  function d3_eventSource() {\n    var e = d3.event, s;\n    while (s = e.sourceEvent) e = s;\n    return e;\n  }\n  function d3_eventDispatch(target) {\n    var dispatch = new d3_dispatch(), i = 0, n = arguments.length;\n    while (++i < n) dispatch[arguments[i]] = d3_dispatch_event(dispatch);\n    dispatch.of = function(thiz, argumentz) {\n      return function(e1) {\n        try {\n          var e0 = e1.sourceEvent = d3.event;\n          e1.target = target;\n          d3.event = e1;\n          dispatch[e1.type].apply(thiz, argumentz);\n        } finally {\n          d3.event = e0;\n        }\n      };\n    };\n    return dispatch;\n  }\n  d3.requote = function(s) {\n    return s.replace(d3_requote_re, \"\\\\$&\");\n  };\n  var d3_requote_re = /[\\\\\\^\\$\\*\\+\\?\\|\\[\\]\\(\\)\\.\\{\\}]/g;\n  var d3_subclass = {}.__proto__ ? function(object, prototype) {\n    object.__proto__ = prototype;\n  } : function(object, prototype) {\n    for (var property in prototype) object[property] = prototype[property];\n  };\n  function d3_selection(groups) {\n    d3_subclass(groups, d3_selectionPrototype);\n    return groups;\n  }\n  var d3_select = function(s, n) {\n    return n.querySelector(s);\n  }, d3_selectAll = function(s, n) {\n    return n.querySelectorAll(s);\n  }, d3_selectMatches = function(n, s) {\n    var d3_selectMatcher = n.matches || n[d3_vendorSymbol(n, \"matchesSelector\")];\n    d3_selectMatches = function(n, s) {\n      return d3_selectMatcher.call(n, s);\n    };\n    return d3_selectMatches(n, s);\n  };\n  if (typeof Sizzle === \"function\") {\n    d3_select = function(s, n) {\n      return Sizzle(s, n)[0] || null;\n    };\n    d3_selectAll = Sizzle;\n    d3_selectMatches = Sizzle.matchesSelector;\n  }\n  d3.selection = function() {\n    return d3.select(d3_document.documentElement);\n  };\n  var d3_selectionPrototype = d3.selection.prototype = [];\n  d3_selectionPrototype.select = function(selector) {\n    var subgroups = [], subgroup, subnode, group, node;\n    selector = d3_selection_selector(selector);\n    for (var j = -1, m = this.length; ++j < m; ) {\n      subgroups.push(subgroup = []);\n      subgroup.parentNode = (group = this[j]).parentNode;\n      for (var i = -1, n = group.length; ++i < n; ) {\n        if (node = group[i]) {\n          subgroup.push(subnode = selector.call(node, node.__data__, i, j));\n          if (subnode && \"__data__\" in node) subnode.__data__ = node.__data__;\n        } else {\n          subgroup.push(null);\n        }\n      }\n    }\n    return d3_selection(subgroups);\n  };\n  function d3_selection_selector(selector) {\n    return typeof selector === \"function\" ? selector : function() {\n      return d3_select(selector, this);\n    };\n  }\n  d3_selectionPrototype.selectAll = function(selector) {\n    var subgroups = [], subgroup, node;\n    selector = d3_selection_selectorAll(selector);\n    for (var j = -1, m = this.length; ++j < m; ) {\n      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {\n        if (node = group[i]) {\n          subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i, j)));\n          subgroup.parentNode = node;\n        }\n      }\n    }\n    return d3_selection(subgroups);\n  };\n  function d3_selection_selectorAll(selector) {\n    return typeof selector === \"function\" ? selector : function() {\n      return d3_selectAll(selector, this);\n    };\n  }\n  var d3_nsXhtml = \"http://www.w3.org/1999/xhtml\";\n  var d3_nsPrefix = {\n    svg: \"http://www.w3.org/2000/svg\",\n    xhtml: d3_nsXhtml,\n    xlink: \"http://www.w3.org/1999/xlink\",\n    xml: \"http://www.w3.org/XML/1998/namespace\",\n    xmlns: \"http://www.w3.org/2000/xmlns/\"\n  };\n  d3.ns = {\n    prefix: d3_nsPrefix,\n    qualify: function(name) {\n      var i = name.indexOf(\":\"), prefix = name;\n      if (i >= 0 && (prefix = name.slice(0, i)) !== \"xmlns\") name = name.slice(i + 1);\n      return d3_nsPrefix.hasOwnProperty(prefix) ? {\n        space: d3_nsPrefix[prefix],\n        local: name\n      } : name;\n    }\n  };\n  d3_selectionPrototype.attr = function(name, value) {\n    if (arguments.length < 2) {\n      if (typeof name === \"string\") {\n        var node = this.node();\n        name = d3.ns.qualify(name);\n        return name.local ? node.getAttributeNS(name.space, name.local) : node.getAttribute(name);\n      }\n      for (value in name) this.each(d3_selection_attr(value, name[value]));\n      return this;\n    }\n    return this.each(d3_selection_attr(name, value));\n  };\n  function d3_selection_attr(name, value) {\n    name = d3.ns.qualify(name);\n    function attrNull() {\n      this.removeAttribute(name);\n    }\n    function attrNullNS() {\n      this.removeAttributeNS(name.space, name.local);\n    }\n    function attrConstant() {\n      this.setAttribute(name, value);\n    }\n    function attrConstantNS() {\n      this.setAttributeNS(name.space, name.local, value);\n    }\n    function attrFunction() {\n      var x = value.apply(this, arguments);\n      if (x == null) this.removeAttribute(name); else this.setAttribute(name, x);\n    }\n    function attrFunctionNS() {\n      var x = value.apply(this, arguments);\n      if (x == null) this.removeAttributeNS(name.space, name.local); else this.setAttributeNS(name.space, name.local, x);\n    }\n    return value == null ? name.local ? attrNullNS : attrNull : typeof value === \"function\" ? name.local ? attrFunctionNS : attrFunction : name.local ? attrConstantNS : attrConstant;\n  }\n  function d3_collapse(s) {\n    return s.trim().replace(/\\s+/g, \" \");\n  }\n  d3_selectionPrototype.classed = function(name, value) {\n    if (arguments.length < 2) {\n      if (typeof name === \"string\") {\n        var node = this.node(), n = (name = d3_selection_classes(name)).length, i = -1;\n        if (value = node.classList) {\n          while (++i < n) if (!value.contains(name[i])) return false;\n        } else {\n          value = node.getAttribute(\"class\");\n          while (++i < n) if (!d3_selection_classedRe(name[i]).test(value)) return false;\n        }\n        return true;\n      }\n      for (value in name) this.each(d3_selection_classed(value, name[value]));\n      return this;\n    }\n    return this.each(d3_selection_classed(name, value));\n  };\n  function d3_selection_classedRe(name) {\n    return new RegExp(\"(?:^|\\\\s+)\" + d3.requote(name) + \"(?:\\\\s+|$)\", \"g\");\n  }\n  function d3_selection_classes(name) {\n    return (name + \"\").trim().split(/^|\\s+/);\n  }\n  function d3_selection_classed(name, value) {\n    name = d3_selection_classes(name).map(d3_selection_classedName);\n    var n = name.length;\n    function classedConstant() {\n      var i = -1;\n      while (++i < n) name[i](this, value);\n    }\n    function classedFunction() {\n      var i = -1, x = value.apply(this, arguments);\n      while (++i < n) name[i](this, x);\n    }\n    return typeof value === \"function\" ? classedFunction : classedConstant;\n  }\n  function d3_selection_classedName(name) {\n    var re = d3_selection_classedRe(name);\n    return function(node, value) {\n      if (c = node.classList) return value ? c.add(name) : c.remove(name);\n      var c = node.getAttribute(\"class\") || \"\";\n      if (value) {\n        re.lastIndex = 0;\n        if (!re.test(c)) node.setAttribute(\"class\", d3_collapse(c + \" \" + name));\n      } else {\n        node.setAttribute(\"class\", d3_collapse(c.replace(re, \" \")));\n      }\n    };\n  }\n  d3_selectionPrototype.style = function(name, value, priority) {\n    var n = arguments.length;\n    if (n < 3) {\n      if (typeof name !== \"string\") {\n        if (n < 2) value = \"\";\n        for (priority in name) this.each(d3_selection_style(priority, name[priority], value));\n        return this;\n      }\n      if (n < 2) {\n        var node = this.node();\n        return d3_window(node).getComputedStyle(node, null).getPropertyValue(name);\n      }\n      priority = \"\";\n    }\n    return this.each(d3_selection_style(name, value, priority));\n  };\n  function d3_selection_style(name, value, priority) {\n    function styleNull() {\n      this.style.removeProperty(name);\n    }\n    function styleConstant() {\n      this.style.setProperty(name, value, priority);\n    }\n    function styleFunction() {\n      var x = value.apply(this, arguments);\n      if (x == null) this.style.removeProperty(name); else this.style.setProperty(name, x, priority);\n    }\n    return value == null ? styleNull : typeof value === \"function\" ? styleFunction : styleConstant;\n  }\n  d3_selectionPrototype.property = function(name, value) {\n    if (arguments.length < 2) {\n      if (typeof name === \"string\") return this.node()[name];\n      for (value in name) this.each(d3_selection_property(value, name[value]));\n      return this;\n    }\n    return this.each(d3_selection_property(name, value));\n  };\n  function d3_selection_property(name, value) {\n    function propertyNull() {\n      delete this[name];\n    }\n    function propertyConstant() {\n      this[name] = value;\n    }\n    function propertyFunction() {\n      var x = value.apply(this, arguments);\n      if (x == null) delete this[name]; else this[name] = x;\n    }\n    return value == null ? propertyNull : typeof value === \"function\" ? propertyFunction : propertyConstant;\n  }\n  d3_selectionPrototype.text = function(value) {\n    return arguments.length ? this.each(typeof value === \"function\" ? function() {\n      var v = value.apply(this, arguments);\n      this.textContent = v == null ? \"\" : v;\n    } : value == null ? function() {\n      this.textContent = \"\";\n    } : function() {\n      this.textContent = value;\n    }) : this.node().textContent;\n  };\n  d3_selectionPrototype.html = function(value) {\n    return arguments.length ? this.each(typeof value === \"function\" ? function() {\n      var v = value.apply(this, arguments);\n      this.innerHTML = v == null ? \"\" : v;\n    } : value == null ? function() {\n      this.innerHTML = \"\";\n    } : function() {\n      this.innerHTML = value;\n    }) : this.node().innerHTML;\n  };\n  d3_selectionPrototype.append = function(name) {\n    name = d3_selection_creator(name);\n    return this.select(function() {\n      return this.appendChild(name.apply(this, arguments));\n    });\n  };\n  function d3_selection_creator(name) {\n    function create() {\n      var document = this.ownerDocument, namespace = this.namespaceURI;\n      return namespace === d3_nsXhtml && document.documentElement.namespaceURI === d3_nsXhtml ? document.createElement(name) : document.createElementNS(namespace, name);\n    }\n    function createNS() {\n      return this.ownerDocument.createElementNS(name.space, name.local);\n    }\n    return typeof name === \"function\" ? name : (name = d3.ns.qualify(name)).local ? createNS : create;\n  }\n  d3_selectionPrototype.insert = function(name, before) {\n    name = d3_selection_creator(name);\n    before = d3_selection_selector(before);\n    return this.select(function() {\n      return this.insertBefore(name.apply(this, arguments), before.apply(this, arguments) || null);\n    });\n  };\n  d3_selectionPrototype.remove = function() {\n    return this.each(d3_selectionRemove);\n  };\n  function d3_selectionRemove() {\n    var parent = this.parentNode;\n    if (parent) parent.removeChild(this);\n  }\n  d3_selectionPrototype.data = function(value, key) {\n    var i = -1, n = this.length, group, node;\n    if (!arguments.length) {\n      value = new Array(n = (group = this[0]).length);\n      while (++i < n) {\n        if (node = group[i]) {\n          value[i] = node.__data__;\n        }\n      }\n      return value;\n    }\n    function bind(group, groupData) {\n      var i, n = group.length, m = groupData.length, n0 = Math.min(n, m), updateNodes = new Array(m), enterNodes = new Array(m), exitNodes = new Array(n), node, nodeData;\n      if (key) {\n        var nodeByKeyValue = new d3_Map(), keyValues = new Array(n), keyValue;\n        for (i = -1; ++i < n; ) {\n          if (node = group[i]) {\n            if (nodeByKeyValue.has(keyValue = key.call(node, node.__data__, i))) {\n              exitNodes[i] = node;\n            } else {\n              nodeByKeyValue.set(keyValue, node);\n            }\n            keyValues[i] = keyValue;\n          }\n        }\n        for (i = -1; ++i < m; ) {\n          if (!(node = nodeByKeyValue.get(keyValue = key.call(groupData, nodeData = groupData[i], i)))) {\n            enterNodes[i] = d3_selection_dataNode(nodeData);\n          } else if (node !== true) {\n            updateNodes[i] = node;\n            node.__data__ = nodeData;\n          }\n          nodeByKeyValue.set(keyValue, true);\n        }\n        for (i = -1; ++i < n; ) {\n          if (i in keyValues && nodeByKeyValue.get(keyValues[i]) !== true) {\n            exitNodes[i] = group[i];\n          }\n        }\n      } else {\n        for (i = -1; ++i < n0; ) {\n          node = group[i];\n          nodeData = groupData[i];\n          if (node) {\n            node.__data__ = nodeData;\n            updateNodes[i] = node;\n          } else {\n            enterNodes[i] = d3_selection_dataNode(nodeData);\n          }\n        }\n        for (;i < m; ++i) {\n          enterNodes[i] = d3_selection_dataNode(groupData[i]);\n        }\n        for (;i < n; ++i) {\n          exitNodes[i] = group[i];\n        }\n      }\n      enterNodes.update = updateNodes;\n      enterNodes.parentNode = updateNodes.parentNode = exitNodes.parentNode = group.parentNode;\n      enter.push(enterNodes);\n      update.push(updateNodes);\n      exit.push(exitNodes);\n    }\n    var enter = d3_selection_enter([]), update = d3_selection([]), exit = d3_selection([]);\n    if (typeof value === \"function\") {\n      while (++i < n) {\n        bind(group = this[i], value.call(group, group.parentNode.__data__, i));\n      }\n    } else {\n      while (++i < n) {\n        bind(group = this[i], value);\n      }\n    }\n    update.enter = function() {\n      return enter;\n    };\n    update.exit = function() {\n      return exit;\n    };\n    return update;\n  };\n  function d3_selection_dataNode(data) {\n    return {\n      __data__: data\n    };\n  }\n  d3_selectionPrototype.datum = function(value) {\n    return arguments.length ? this.property(\"__data__\", value) : this.property(\"__data__\");\n  };\n  d3_selectionPrototype.filter = function(filter) {\n    var subgroups = [], subgroup, group, node;\n    if (typeof filter !== \"function\") filter = d3_selection_filter(filter);\n    for (var j = 0, m = this.length; j < m; j++) {\n      subgroups.push(subgroup = []);\n      subgroup.parentNode = (group = this[j]).parentNode;\n      for (var i = 0, n = group.length; i < n; i++) {\n        if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {\n          subgroup.push(node);\n        }\n      }\n    }\n    return d3_selection(subgroups);\n  };\n  function d3_selection_filter(selector) {\n    return function() {\n      return d3_selectMatches(this, selector);\n    };\n  }\n  d3_selectionPrototype.order = function() {\n    for (var j = -1, m = this.length; ++j < m; ) {\n      for (var group = this[j], i = group.length - 1, next = group[i], node; --i >= 0; ) {\n        if (node = group[i]) {\n          if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);\n          next = node;\n        }\n      }\n    }\n    return this;\n  };\n  d3_selectionPrototype.sort = function(comparator) {\n    comparator = d3_selection_sortComparator.apply(this, arguments);\n    for (var j = -1, m = this.length; ++j < m; ) this[j].sort(comparator);\n    return this.order();\n  };\n  function d3_selection_sortComparator(comparator) {\n    if (!arguments.length) comparator = d3_ascending;\n    return function(a, b) {\n      return a && b ? comparator(a.__data__, b.__data__) : !a - !b;\n    };\n  }\n  d3_selectionPrototype.each = function(callback) {\n    return d3_selection_each(this, function(node, i, j) {\n      callback.call(node, node.__data__, i, j);\n    });\n  };\n  function d3_selection_each(groups, callback) {\n    for (var j = 0, m = groups.length; j < m; j++) {\n      for (var group = groups[j], i = 0, n = group.length, node; i < n; i++) {\n        if (node = group[i]) callback(node, i, j);\n      }\n    }\n    return groups;\n  }\n  d3_selectionPrototype.call = function(callback) {\n    var args = d3_array(arguments);\n    callback.apply(args[0] = this, args);\n    return this;\n  };\n  d3_selectionPrototype.empty = function() {\n    return !this.node();\n  };\n  d3_selectionPrototype.node = function() {\n    for (var j = 0, m = this.length; j < m; j++) {\n      for (var group = this[j], i = 0, n = group.length; i < n; i++) {\n        var node = group[i];\n        if (node) return node;\n      }\n    }\n    return null;\n  };\n  d3_selectionPrototype.size = function() {\n    var n = 0;\n    d3_selection_each(this, function() {\n      ++n;\n    });\n    return n;\n  };\n  function d3_selection_enter(selection) {\n    d3_subclass(selection, d3_selection_enterPrototype);\n    return selection;\n  }\n  var d3_selection_enterPrototype = [];\n  d3.selection.enter = d3_selection_enter;\n  d3.selection.enter.prototype = d3_selection_enterPrototype;\n  d3_selection_enterPrototype.append = d3_selectionPrototype.append;\n  d3_selection_enterPrototype.empty = d3_selectionPrototype.empty;\n  d3_selection_enterPrototype.node = d3_selectionPrototype.node;\n  d3_selection_enterPrototype.call = d3_selectionPrototype.call;\n  d3_selection_enterPrototype.size = d3_selectionPrototype.size;\n  d3_selection_enterPrototype.select = function(selector) {\n    var subgroups = [], subgroup, subnode, upgroup, group, node;\n    for (var j = -1, m = this.length; ++j < m; ) {\n      upgroup = (group = this[j]).update;\n      subgroups.push(subgroup = []);\n      subgroup.parentNode = group.parentNode;\n      for (var i = -1, n = group.length; ++i < n; ) {\n        if (node = group[i]) {\n          subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i, j));\n          subnode.__data__ = node.__data__;\n        } else {\n          subgroup.push(null);\n        }\n      }\n    }\n    return d3_selection(subgroups);\n  };\n  d3_selection_enterPrototype.insert = function(name, before) {\n    if (arguments.length < 2) before = d3_selection_enterInsertBefore(this);\n    return d3_selectionPrototype.insert.call(this, name, before);\n  };\n  function d3_selection_enterInsertBefore(enter) {\n    var i0, j0;\n    return function(d, i, j) {\n      var group = enter[j].update, n = group.length, node;\n      if (j != j0) j0 = j, i0 = 0;\n      if (i >= i0) i0 = i + 1;\n      while (!(node = group[i0]) && ++i0 < n) ;\n      return node;\n    };\n  }\n  d3.select = function(node) {\n    var group;\n    if (typeof node === \"string\") {\n      group = [ d3_select(node, d3_document) ];\n      group.parentNode = d3_document.documentElement;\n    } else {\n      group = [ node ];\n      group.parentNode = d3_documentElement(node);\n    }\n    return d3_selection([ group ]);\n  };\n  d3.selectAll = function(nodes) {\n    var group;\n    if (typeof nodes === \"string\") {\n      group = d3_array(d3_selectAll(nodes, d3_document));\n      group.parentNode = d3_document.documentElement;\n    } else {\n      group = d3_array(nodes);\n      group.parentNode = null;\n    }\n    return d3_selection([ group ]);\n  };\n  d3_selectionPrototype.on = function(type, listener, capture) {\n    var n = arguments.length;\n    if (n < 3) {\n      if (typeof type !== \"string\") {\n        if (n < 2) listener = false;\n        for (capture in type) this.each(d3_selection_on(capture, type[capture], listener));\n        return this;\n      }\n      if (n < 2) return (n = this.node()[\"__on\" + type]) && n._;\n      capture = false;\n    }\n    return this.each(d3_selection_on(type, listener, capture));\n  };\n  function d3_selection_on(type, listener, capture) {\n    var name = \"__on\" + type, i = type.indexOf(\".\"), wrap = d3_selection_onListener;\n    if (i > 0) type = type.slice(0, i);\n    var filter = d3_selection_onFilters.get(type);\n    if (filter) type = filter, wrap = d3_selection_onFilter;\n    function onRemove() {\n      var l = this[name];\n      if (l) {\n        this.removeEventListener(type, l, l.$);\n        delete this[name];\n      }\n    }\n    function onAdd() {\n      var l = wrap(listener, d3_array(arguments));\n      onRemove.call(this);\n      this.addEventListener(type, this[name] = l, l.$ = capture);\n      l._ = listener;\n    }\n    function removeAll() {\n      var re = new RegExp(\"^__on([^.]+)\" + d3.requote(type) + \"$\"), match;\n      for (var name in this) {\n        if (match = name.match(re)) {\n          var l = this[name];\n          this.removeEventListener(match[1], l, l.$);\n          delete this[name];\n        }\n      }\n    }\n    return i ? listener ? onAdd : onRemove : listener ? d3_noop : removeAll;\n  }\n  var d3_selection_onFilters = d3.map({\n    mouseenter: \"mouseover\",\n    mouseleave: \"mouseout\"\n  });\n  if (d3_document) {\n    d3_selection_onFilters.forEach(function(k) {\n      if (\"on\" + k in d3_document) d3_selection_onFilters.remove(k);\n    });\n  }\n  function d3_selection_onListener(listener, argumentz) {\n    return function(e) {\n      var o = d3.event;\n      d3.event = e;\n      argumentz[0] = this.__data__;\n      try {\n        listener.apply(this, argumentz);\n      } finally {\n        d3.event = o;\n      }\n    };\n  }\n  function d3_selection_onFilter(listener, argumentz) {\n    var l = d3_selection_onListener(listener, argumentz);\n    return function(e) {\n      var target = this, related = e.relatedTarget;\n      if (!related || related !== target && !(related.compareDocumentPosition(target) & 8)) {\n        l.call(target, e);\n      }\n    };\n  }\n  var d3_event_dragSelect, d3_event_dragId = 0;\n  function d3_event_dragSuppress(node) {\n    var name = \".dragsuppress-\" + ++d3_event_dragId, click = \"click\" + name, w = d3.select(d3_window(node)).on(\"touchmove\" + name, d3_eventPreventDefault).on(\"dragstart\" + name, d3_eventPreventDefault).on(\"selectstart\" + name, d3_eventPreventDefault);\n    if (d3_event_dragSelect == null) {\n      d3_event_dragSelect = \"onselectstart\" in node ? false : d3_vendorSymbol(node.style, \"userSelect\");\n    }\n    if (d3_event_dragSelect) {\n      var style = d3_documentElement(node).style, select = style[d3_event_dragSelect];\n      style[d3_event_dragSelect] = \"none\";\n    }\n    return function(suppressClick) {\n      w.on(name, null);\n      if (d3_event_dragSelect) style[d3_event_dragSelect] = select;\n      if (suppressClick) {\n        var off = function() {\n          w.on(click, null);\n        };\n        w.on(click, function() {\n          d3_eventPreventDefault();\n          off();\n        }, true);\n        setTimeout(off, 0);\n      }\n    };\n  }\n  d3.mouse = function(container) {\n    return d3_mousePoint(container, d3_eventSource());\n  };\n  var d3_mouse_bug44083 = this.navigator && /WebKit/.test(this.navigator.userAgent) ? -1 : 0;\n  function d3_mousePoint(container, e) {\n    if (e.changedTouches) e = e.changedTouches[0];\n    var svg = container.ownerSVGElement || container;\n    if (svg.createSVGPoint) {\n      var point = svg.createSVGPoint();\n      if (d3_mouse_bug44083 < 0) {\n        var window = d3_window(container);\n        if (window.scrollX || window.scrollY) {\n          svg = d3.select(\"body\").append(\"svg\").style({\n            position: \"absolute\",\n            top: 0,\n            left: 0,\n            margin: 0,\n            padding: 0,\n            border: \"none\"\n          }, \"important\");\n          var ctm = svg[0][0].getScreenCTM();\n          d3_mouse_bug44083 = !(ctm.f || ctm.e);\n          svg.remove();\n        }\n      }\n      if (d3_mouse_bug44083) point.x = e.pageX, point.y = e.pageY; else point.x = e.clientX, \n      point.y = e.clientY;\n      point = point.matrixTransform(container.getScreenCTM().inverse());\n      return [ point.x, point.y ];\n    }\n    var rect = container.getBoundingClientRect();\n    return [ e.clientX - rect.left - container.clientLeft, e.clientY - rect.top - container.clientTop ];\n  }\n  d3.touch = function(container, touches, identifier) {\n    if (arguments.length < 3) identifier = touches, touches = d3_eventSource().changedTouches;\n    if (touches) for (var i = 0, n = touches.length, touch; i < n; ++i) {\n      if ((touch = touches[i]).identifier === identifier) {\n        return d3_mousePoint(container, touch);\n      }\n    }\n  };\n  d3.behavior.drag = function() {\n    var event = d3_eventDispatch(drag, \"drag\", \"dragstart\", \"dragend\"), origin = null, mousedown = dragstart(d3_noop, d3.mouse, d3_window, \"mousemove\", \"mouseup\"), touchstart = dragstart(d3_behavior_dragTouchId, d3.touch, d3_identity, \"touchmove\", \"touchend\");\n    function drag() {\n      this.on(\"mousedown.drag\", mousedown).on(\"touchstart.drag\", touchstart);\n    }\n    function dragstart(id, position, subject, move, end) {\n      return function() {\n        var that = this, target = d3.event.target.correspondingElement || d3.event.target, parent = that.parentNode, dispatch = event.of(that, arguments), dragged = 0, dragId = id(), dragName = \".drag\" + (dragId == null ? \"\" : \"-\" + dragId), dragOffset, dragSubject = d3.select(subject(target)).on(move + dragName, moved).on(end + dragName, ended), dragRestore = d3_event_dragSuppress(target), position0 = position(parent, dragId);\n        if (origin) {\n          dragOffset = origin.apply(that, arguments);\n          dragOffset = [ dragOffset.x - position0[0], dragOffset.y - position0[1] ];\n        } else {\n          dragOffset = [ 0, 0 ];\n        }\n        dispatch({\n          type: \"dragstart\"\n        });\n        function moved() {\n          var position1 = position(parent, dragId), dx, dy;\n          if (!position1) return;\n          dx = position1[0] - position0[0];\n          dy = position1[1] - position0[1];\n          dragged |= dx | dy;\n          position0 = position1;\n          dispatch({\n            type: \"drag\",\n            x: position1[0] + dragOffset[0],\n            y: position1[1] + dragOffset[1],\n            dx: dx,\n            dy: dy\n          });\n        }\n        function ended() {\n          if (!position(parent, dragId)) return;\n          dragSubject.on(move + dragName, null).on(end + dragName, null);\n          dragRestore(dragged);\n          dispatch({\n            type: \"dragend\"\n          });\n        }\n      };\n    }\n    drag.origin = function(x) {\n      if (!arguments.length) return origin;\n      origin = x;\n      return drag;\n    };\n    return d3.rebind(drag, event, \"on\");\n  };\n  function d3_behavior_dragTouchId() {\n    return d3.event.changedTouches[0].identifier;\n  }\n  d3.touches = function(container, touches) {\n    if (arguments.length < 2) touches = d3_eventSource().touches;\n    return touches ? d3_array(touches).map(function(touch) {\n      var point = d3_mousePoint(container, touch);\n      point.identifier = touch.identifier;\n      return point;\n    }) : [];\n  };\n  var  = 1e-6, 2 =  * ,  = Math.PI,  = 2 * ,  =  - , half =  / 2, d3_radians =  / 180, d3_degrees = 180 / ;\n  function d3_sgn(x) {\n    return x > 0 ? 1 : x < 0 ? -1 : 0;\n  }\n  function d3_cross2d(a, b, c) {\n    return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]);\n  }\n  function d3_acos(x) {\n    return x > 1 ? 0 : x < -1 ?  : Math.acos(x);\n  }\n  function d3_asin(x) {\n    return x > 1 ? half : x < -1 ? -half : Math.asin(x);\n  }\n  function d3_sinh(x) {\n    return ((x = Math.exp(x)) - 1 / x) / 2;\n  }\n  function d3_cosh(x) {\n    return ((x = Math.exp(x)) + 1 / x) / 2;\n  }\n  function d3_tanh(x) {\n    return ((x = Math.exp(2 * x)) - 1) / (x + 1);\n  }\n  function d3_haversin(x) {\n    return (x = Math.sin(x / 2)) * x;\n  }\n  var  = Math.SQRT2, 2 = 2, 4 = 4;\n  d3.interpolateZoom = function(p0, p1) {\n    var ux0 = p0[0], uy0 = p0[1], w0 = p0[2], ux1 = p1[0], uy1 = p1[1], w1 = p1[2], dx = ux1 - ux0, dy = uy1 - uy0, d2 = dx * dx + dy * dy, i, S;\n    if (d2 < 2) {\n      S = Math.log(w1 / w0) / ;\n      i = function(t) {\n        return [ ux0 + t * dx, uy0 + t * dy, w0 * Math.exp( * t * S) ];\n      };\n    } else {\n      var d1 = Math.sqrt(d2), b0 = (w1 * w1 - w0 * w0 + 4 * d2) / (2 * w0 * 2 * d1), b1 = (w1 * w1 - w0 * w0 - 4 * d2) / (2 * w1 * 2 * d1), r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0), r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);\n      S = (r1 - r0) / ;\n      i = function(t) {\n        var s = t * S, coshr0 = d3_cosh(r0), u = w0 / (2 * d1) * (coshr0 * d3_tanh( * s + r0) - d3_sinh(r0));\n        return [ ux0 + u * dx, uy0 + u * dy, w0 * coshr0 / d3_cosh( * s + r0) ];\n      };\n    }\n    i.duration = S * 1e3;\n    return i;\n  };\n  d3.behavior.zoom = function() {\n    var view = {\n      x: 0,\n      y: 0,\n      k: 1\n    }, translate0, center0, center, size = [ 960, 500 ], scaleExtent = d3_behavior_zoomInfinity, duration = 250, zooming = 0, mousedown = \"mousedown.zoom\", mousemove = \"mousemove.zoom\", mouseup = \"mouseup.zoom\", mousewheelTimer, touchstart = \"touchstart.zoom\", touchtime, event = d3_eventDispatch(zoom, \"zoomstart\", \"zoom\", \"zoomend\"), x0, x1, y0, y1;\n    if (!d3_behavior_zoomWheel) {\n      d3_behavior_zoomWheel = \"onwheel\" in d3_document ? (d3_behavior_zoomDelta = function() {\n        return -d3.event.deltaY * (d3.event.deltaMode ? 120 : 1);\n      }, \"wheel\") : \"onmousewheel\" in d3_document ? (d3_behavior_zoomDelta = function() {\n        return d3.event.wheelDelta;\n      }, \"mousewheel\") : (d3_behavior_zoomDelta = function() {\n        return -d3.event.detail;\n      }, \"MozMousePixelScroll\");\n    }\n    function zoom(g) {\n      g.on(mousedown, mousedowned).on(d3_behavior_zoomWheel + \".zoom\", mousewheeled).on(\"dblclick.zoom\", dblclicked).on(touchstart, touchstarted);\n    }\n    zoom.event = function(g) {\n      g.each(function() {\n        var dispatch = event.of(this, arguments), view1 = view;\n        if (d3_transitionInheritId) {\n          d3.select(this).transition().each(\"start.zoom\", function() {\n            view = this.__chart__ || {\n              x: 0,\n              y: 0,\n              k: 1\n            };\n            zoomstarted(dispatch);\n          }).tween(\"zoom:zoom\", function() {\n            var dx = size[0], dy = size[1], cx = center0 ? center0[0] : dx / 2, cy = center0 ? center0[1] : dy / 2, i = d3.interpolateZoom([ (cx - view.x) / view.k, (cy - view.y) / view.k, dx / view.k ], [ (cx - view1.x) / view1.k, (cy - view1.y) / view1.k, dx / view1.k ]);\n            return function(t) {\n              var l = i(t), k = dx / l[2];\n              this.__chart__ = view = {\n                x: cx - l[0] * k,\n                y: cy - l[1] * k,\n                k: k\n              };\n              zoomed(dispatch);\n            };\n          }).each(\"interrupt.zoom\", function() {\n            zoomended(dispatch);\n          }).each(\"end.zoom\", function() {\n            zoomended(dispatch);\n          });\n        } else {\n          this.__chart__ = view;\n          zoomstarted(dispatch);\n          zoomed(dispatch);\n          zoomended(dispatch);\n        }\n      });\n    };\n    zoom.translate = function(_) {\n      if (!arguments.length) return [ view.x, view.y ];\n      view = {\n        x: +_[0],\n        y: +_[1],\n        k: view.k\n      };\n      rescale();\n      return zoom;\n    };\n    zoom.scale = function(_) {\n      if (!arguments.length) return view.k;\n      view = {\n        x: view.x,\n        y: view.y,\n        k: null\n      };\n      scaleTo(+_);\n      rescale();\n      return zoom;\n    };\n    zoom.scaleExtent = function(_) {\n      if (!arguments.length) return scaleExtent;\n      scaleExtent = _ == null ? d3_behavior_zoomInfinity : [ +_[0], +_[1] ];\n      return zoom;\n    };\n    zoom.center = function(_) {\n      if (!arguments.length) return center;\n      center = _ && [ +_[0], +_[1] ];\n      return zoom;\n    };\n    zoom.size = function(_) {\n      if (!arguments.length) return size;\n      size = _ && [ +_[0], +_[1] ];\n      return zoom;\n    };\n    zoom.duration = function(_) {\n      if (!arguments.length) return duration;\n      duration = +_;\n      return zoom;\n    };\n    zoom.x = function(z) {\n      if (!arguments.length) return x1;\n      x1 = z;\n      x0 = z.copy();\n      view = {\n        x: 0,\n        y: 0,\n        k: 1\n      };\n      return zoom;\n    };\n    zoom.y = function(z) {\n      if (!arguments.length) return y1;\n      y1 = z;\n      y0 = z.copy();\n      view = {\n        x: 0,\n        y: 0,\n        k: 1\n      };\n      return zoom;\n    };\n    function location(p) {\n      return [ (p[0] - view.x) / view.k, (p[1] - view.y) / view.k ];\n    }\n    function point(l) {\n      return [ l[0] * view.k + view.x, l[1] * view.k + view.y ];\n    }\n    function scaleTo(s) {\n      view.k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], s));\n    }\n    function translateTo(p, l) {\n      l = point(l);\n      view.x += p[0] - l[0];\n      view.y += p[1] - l[1];\n    }\n    function zoomTo(that, p, l, k) {\n      that.__chart__ = {\n        x: view.x,\n        y: view.y,\n        k: view.k\n      };\n      scaleTo(Math.pow(2, k));\n      translateTo(center0 = p, l);\n      that = d3.select(that);\n      if (duration > 0) that = that.transition().duration(duration);\n      that.call(zoom.event);\n    }\n    function rescale() {\n      if (x1) x1.domain(x0.range().map(function(x) {\n        return (x - view.x) / view.k;\n      }).map(x0.invert));\n      if (y1) y1.domain(y0.range().map(function(y) {\n        return (y - view.y) / view.k;\n      }).map(y0.invert));\n    }\n    function zoomstarted(dispatch) {\n      if (!zooming++) dispatch({\n        type: \"zoomstart\"\n      });\n    }\n    function zoomed(dispatch) {\n      rescale();\n      dispatch({\n        type: \"zoom\",\n        scale: view.k,\n        translate: [ view.x, view.y ]\n      });\n    }\n    function zoomended(dispatch) {\n      if (!--zooming) dispatch({\n        type: \"zoomend\"\n      }), center0 = null;\n    }\n    function mousedowned() {\n      var that = this, dispatch = event.of(that, arguments), dragged = 0, subject = d3.select(d3_window(that)).on(mousemove, moved).on(mouseup, ended), location0 = location(d3.mouse(that)), dragRestore = d3_event_dragSuppress(that);\n      d3_selection_interrupt.call(that);\n      zoomstarted(dispatch);\n      function moved() {\n        dragged = 1;\n        translateTo(d3.mouse(that), location0);\n        zoomed(dispatch);\n      }\n      function ended() {\n        subject.on(mousemove, null).on(mouseup, null);\n        dragRestore(dragged);\n        zoomended(dispatch);\n      }\n    }\n    function touchstarted() {\n      var that = this, dispatch = event.of(that, arguments), locations0 = {}, distance0 = 0, scale0, zoomName = \".zoom-\" + d3.event.changedTouches[0].identifier, touchmove = \"touchmove\" + zoomName, touchend = \"touchend\" + zoomName, targets = [], subject = d3.select(that), dragRestore = d3_event_dragSuppress(that);\n      started();\n      zoomstarted(dispatch);\n      subject.on(mousedown, null).on(touchstart, started);\n      function relocate() {\n        var touches = d3.touches(that);\n        scale0 = view.k;\n        touches.forEach(function(t) {\n          if (t.identifier in locations0) locations0[t.identifier] = location(t);\n        });\n        return touches;\n      }\n      function started() {\n        var target = d3.event.target;\n        d3.select(target).on(touchmove, moved).on(touchend, ended);\n        targets.push(target);\n        var changed = d3.event.changedTouches;\n        for (var i = 0, n = changed.length; i < n; ++i) {\n          locations0[changed[i].identifier] = null;\n        }\n        var touches = relocate(), now = Date.now();\n        if (touches.length === 1) {\n          if (now - touchtime < 500) {\n            var p = touches[0];\n            zoomTo(that, p, locations0[p.identifier], Math.floor(Math.log(view.k) / Math.LN2) + 1);\n            d3_eventPreventDefault();\n          }\n          touchtime = now;\n        } else if (touches.length > 1) {\n          var p = touches[0], q = touches[1], dx = p[0] - q[0], dy = p[1] - q[1];\n          distance0 = dx * dx + dy * dy;\n        }\n      }\n      function moved() {\n        var touches = d3.touches(that), p0, l0, p1, l1;\n        d3_selection_interrupt.call(that);\n        for (var i = 0, n = touches.length; i < n; ++i, l1 = null) {\n          p1 = touches[i];\n          if (l1 = locations0[p1.identifier]) {\n            if (l0) break;\n            p0 = p1, l0 = l1;\n          }\n        }\n        if (l1) {\n          var distance1 = (distance1 = p1[0] - p0[0]) * distance1 + (distance1 = p1[1] - p0[1]) * distance1, scale1 = distance0 && Math.sqrt(distance1 / distance0);\n          p0 = [ (p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2 ];\n          l0 = [ (l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2 ];\n          scaleTo(scale1 * scale0);\n        }\n        touchtime = null;\n        translateTo(p0, l0);\n        zoomed(dispatch);\n      }\n      function ended() {\n        if (d3.event.touches.length) {\n          var changed = d3.event.changedTouches;\n          for (var i = 0, n = changed.length; i < n; ++i) {\n            delete locations0[changed[i].identifier];\n          }\n          for (var identifier in locations0) {\n            return void relocate();\n          }\n        }\n        d3.selectAll(targets).on(zoomName, null);\n        subject.on(mousedown, mousedowned).on(touchstart, touchstarted);\n        dragRestore();\n        zoomended(dispatch);\n      }\n    }\n    function mousewheeled() {\n      var dispatch = event.of(this, arguments);\n      if (mousewheelTimer) clearTimeout(mousewheelTimer); else d3_selection_interrupt.call(this), \n      translate0 = location(center0 = center || d3.mouse(this)), zoomstarted(dispatch);\n      mousewheelTimer = setTimeout(function() {\n        mousewheelTimer = null;\n        zoomended(dispatch);\n      }, 50);\n      d3_eventPreventDefault();\n      scaleTo(Math.pow(2, d3_behavior_zoomDelta() * .002) * view.k);\n      translateTo(center0, translate0);\n      zoomed(dispatch);\n    }\n    function dblclicked() {\n      var p = d3.mouse(this), k = Math.log(view.k) / Math.LN2;\n      zoomTo(this, p, location(p), d3.event.shiftKey ? Math.ceil(k) - 1 : Math.floor(k) + 1);\n    }\n    return d3.rebind(zoom, event, \"on\");\n  };\n  var d3_behavior_zoomInfinity = [ 0, Infinity ], d3_behavior_zoomDelta, d3_behavior_zoomWheel;\n  d3.color = d3_color;\n  function d3_color() {}\n  d3_color.prototype.toString = function() {\n    return this.rgb() + \"\";\n  };\n  d3.hsl = d3_hsl;\n  function d3_hsl(h, s, l) {\n    return this instanceof d3_hsl ? void (this.h = +h, this.s = +s, this.l = +l) : arguments.length < 2 ? h instanceof d3_hsl ? new d3_hsl(h.h, h.s, h.l) : d3_rgb_parse(\"\" + h, d3_rgb_hsl, d3_hsl) : new d3_hsl(h, s, l);\n  }\n  var d3_hslPrototype = d3_hsl.prototype = new d3_color();\n  d3_hslPrototype.brighter = function(k) {\n    k = Math.pow(.7, arguments.length ? k : 1);\n    return new d3_hsl(this.h, this.s, this.l / k);\n  };\n  d3_hslPrototype.darker = function(k) {\n    k = Math.pow(.7, arguments.length ? k : 1);\n    return new d3_hsl(this.h, this.s, k * this.l);\n  };\n  d3_hslPrototype.rgb = function() {\n    return d3_hsl_rgb(this.h, this.s, this.l);\n  };\n  function d3_hsl_rgb(h, s, l) {\n    var m1, m2;\n    h = isNaN(h) ? 0 : (h %= 360) < 0 ? h + 360 : h;\n    s = isNaN(s) ? 0 : s < 0 ? 0 : s > 1 ? 1 : s;\n    l = l < 0 ? 0 : l > 1 ? 1 : l;\n    m2 = l <= .5 ? l * (1 + s) : l + s - l * s;\n    m1 = 2 * l - m2;\n    function v(h) {\n      if (h > 360) h -= 360; else if (h < 0) h += 360;\n      if (h < 60) return m1 + (m2 - m1) * h / 60;\n      if (h < 180) return m2;\n      if (h < 240) return m1 + (m2 - m1) * (240 - h) / 60;\n      return m1;\n    }\n    function vv(h) {\n      return Math.round(v(h) * 255);\n    }\n    return new d3_rgb(vv(h + 120), vv(h), vv(h - 120));\n  }\n  d3.hcl = d3_hcl;\n  function d3_hcl(h, c, l) {\n    return this instanceof d3_hcl ? void (this.h = +h, this.c = +c, this.l = +l) : arguments.length < 2 ? h instanceof d3_hcl ? new d3_hcl(h.h, h.c, h.l) : h instanceof d3_lab ? d3_lab_hcl(h.l, h.a, h.b) : d3_lab_hcl((h = d3_rgb_lab((h = d3.rgb(h)).r, h.g, h.b)).l, h.a, h.b) : new d3_hcl(h, c, l);\n  }\n  var d3_hclPrototype = d3_hcl.prototype = new d3_color();\n  d3_hclPrototype.brighter = function(k) {\n    return new d3_hcl(this.h, this.c, Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)));\n  };\n  d3_hclPrototype.darker = function(k) {\n    return new d3_hcl(this.h, this.c, Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)));\n  };\n  d3_hclPrototype.rgb = function() {\n    return d3_hcl_lab(this.h, this.c, this.l).rgb();\n  };\n  function d3_hcl_lab(h, c, l) {\n    if (isNaN(h)) h = 0;\n    if (isNaN(c)) c = 0;\n    return new d3_lab(l, Math.cos(h *= d3_radians) * c, Math.sin(h) * c);\n  }\n  d3.lab = d3_lab;\n  function d3_lab(l, a, b) {\n    return this instanceof d3_lab ? void (this.l = +l, this.a = +a, this.b = +b) : arguments.length < 2 ? l instanceof d3_lab ? new d3_lab(l.l, l.a, l.b) : l instanceof d3_hcl ? d3_hcl_lab(l.h, l.c, l.l) : d3_rgb_lab((l = d3_rgb(l)).r, l.g, l.b) : new d3_lab(l, a, b);\n  }\n  var d3_lab_K = 18;\n  var d3_lab_X = .95047, d3_lab_Y = 1, d3_lab_Z = 1.08883;\n  var d3_labPrototype = d3_lab.prototype = new d3_color();\n  d3_labPrototype.brighter = function(k) {\n    return new d3_lab(Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);\n  };\n  d3_labPrototype.darker = function(k) {\n    return new d3_lab(Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);\n  };\n  d3_labPrototype.rgb = function() {\n    return d3_lab_rgb(this.l, this.a, this.b);\n  };\n  function d3_lab_rgb(l, a, b) {\n    var y = (l + 16) / 116, x = y + a / 500, z = y - b / 200;\n    x = d3_lab_xyz(x) * d3_lab_X;\n    y = d3_lab_xyz(y) * d3_lab_Y;\n    z = d3_lab_xyz(z) * d3_lab_Z;\n    return new d3_rgb(d3_xyz_rgb(3.2404542 * x - 1.5371385 * y - .4985314 * z), d3_xyz_rgb(-.969266 * x + 1.8760108 * y + .041556 * z), d3_xyz_rgb(.0556434 * x - .2040259 * y + 1.0572252 * z));\n  }\n  function d3_lab_hcl(l, a, b) {\n    return l > 0 ? new d3_hcl(Math.atan2(b, a) * d3_degrees, Math.sqrt(a * a + b * b), l) : new d3_hcl(NaN, NaN, l);\n  }\n  function d3_lab_xyz(x) {\n    return x > .206893034 ? x * x * x : (x - 4 / 29) / 7.787037;\n  }\n  function d3_xyz_lab(x) {\n    return x > .008856 ? Math.pow(x, 1 / 3) : 7.787037 * x + 4 / 29;\n  }\n  function d3_xyz_rgb(r) {\n    return Math.round(255 * (r <= .00304 ? 12.92 * r : 1.055 * Math.pow(r, 1 / 2.4) - .055));\n  }\n  d3.rgb = d3_rgb;\n  function d3_rgb(r, g, b) {\n    return this instanceof d3_rgb ? void (this.r = ~~r, this.g = ~~g, this.b = ~~b) : arguments.length < 2 ? r instanceof d3_rgb ? new d3_rgb(r.r, r.g, r.b) : d3_rgb_parse(\"\" + r, d3_rgb, d3_hsl_rgb) : new d3_rgb(r, g, b);\n  }\n  function d3_rgbNumber(value) {\n    return new d3_rgb(value >> 16, value >> 8 & 255, value & 255);\n  }\n  function d3_rgbString(value) {\n    return d3_rgbNumber(value) + \"\";\n  }\n  var d3_rgbPrototype = d3_rgb.prototype = new d3_color();\n  d3_rgbPrototype.brighter = function(k) {\n    k = Math.pow(.7, arguments.length ? k : 1);\n    var r = this.r, g = this.g, b = this.b, i = 30;\n    if (!r && !g && !b) return new d3_rgb(i, i, i);\n    if (r && r < i) r = i;\n    if (g && g < i) g = i;\n    if (b && b < i) b = i;\n    return new d3_rgb(Math.min(255, r / k), Math.min(255, g / k), Math.min(255, b / k));\n  };\n  d3_rgbPrototype.darker = function(k) {\n    k = Math.pow(.7, arguments.length ? k : 1);\n    return new d3_rgb(k * this.r, k * this.g, k * this.b);\n  };\n  d3_rgbPrototype.hsl = function() {\n    return d3_rgb_hsl(this.r, this.g, this.b);\n  };\n  d3_rgbPrototype.toString = function() {\n    return \"#\" + d3_rgb_hex(this.r) + d3_rgb_hex(this.g) + d3_rgb_hex(this.b);\n  };\n  function d3_rgb_hex(v) {\n    return v < 16 ? \"0\" + Math.max(0, v).toString(16) : Math.min(255, v).toString(16);\n  }\n  function d3_rgb_parse(format, rgb, hsl) {\n    var r = 0, g = 0, b = 0, m1, m2, color;\n    m1 = /([a-z]+)\\((.*)\\)/.exec(format = format.toLowerCase());\n    if (m1) {\n      m2 = m1[2].split(\",\");\n      switch (m1[1]) {\n       case \"hsl\":\n        {\n          return hsl(parseFloat(m2[0]), parseFloat(m2[1]) / 100, parseFloat(m2[2]) / 100);\n        }\n\n       case \"rgb\":\n        {\n          return rgb(d3_rgb_parseNumber(m2[0]), d3_rgb_parseNumber(m2[1]), d3_rgb_parseNumber(m2[2]));\n        }\n      }\n    }\n    if (color = d3_rgb_names.get(format)) {\n      return rgb(color.r, color.g, color.b);\n    }\n    if (format != null && format.charAt(0) === \"#\" && !isNaN(color = parseInt(format.slice(1), 16))) {\n      if (format.length === 4) {\n        r = (color & 3840) >> 4;\n        r = r >> 4 | r;\n        g = color & 240;\n        g = g >> 4 | g;\n        b = color & 15;\n        b = b << 4 | b;\n      } else if (format.length === 7) {\n        r = (color & 16711680) >> 16;\n        g = (color & 65280) >> 8;\n        b = color & 255;\n      }\n    }\n    return rgb(r, g, b);\n  }\n  function d3_rgb_hsl(r, g, b) {\n    var min = Math.min(r /= 255, g /= 255, b /= 255), max = Math.max(r, g, b), d = max - min, h, s, l = (max + min) / 2;\n    if (d) {\n      s = l < .5 ? d / (max + min) : d / (2 - max - min);\n      if (r == max) h = (g - b) / d + (g < b ? 6 : 0); else if (g == max) h = (b - r) / d + 2; else h = (r - g) / d + 4;\n      h *= 60;\n    } else {\n      h = NaN;\n      s = l > 0 && l < 1 ? 0 : h;\n    }\n    return new d3_hsl(h, s, l);\n  }\n  function d3_rgb_lab(r, g, b) {\n    r = d3_rgb_xyz(r);\n    g = d3_rgb_xyz(g);\n    b = d3_rgb_xyz(b);\n    var x = d3_xyz_lab((.4124564 * r + .3575761 * g + .1804375 * b) / d3_lab_X), y = d3_xyz_lab((.2126729 * r + .7151522 * g + .072175 * b) / d3_lab_Y), z = d3_xyz_lab((.0193339 * r + .119192 * g + .9503041 * b) / d3_lab_Z);\n    return d3_lab(116 * y - 16, 500 * (x - y), 200 * (y - z));\n  }\n  function d3_rgb_xyz(r) {\n    return (r /= 255) <= .04045 ? r / 12.92 : Math.pow((r + .055) / 1.055, 2.4);\n  }\n  function d3_rgb_parseNumber(c) {\n    var f = parseFloat(c);\n    return c.charAt(c.length - 1) === \"%\" ? Math.round(f * 2.55) : f;\n  }\n  var d3_rgb_names = d3.map({\n    aliceblue: 15792383,\n    antiquewhite: 16444375,\n    aqua: 65535,\n    aquamarine: 8388564,\n    azure: 15794175,\n    beige: 16119260,\n    bisque: 16770244,\n    black: 0,\n    blanchedalmond: 16772045,\n    blue: 255,\n    blueviolet: 9055202,\n    brown: 10824234,\n    burlywood: 14596231,\n    cadetblue: 6266528,\n    chartreuse: 8388352,\n    chocolate: 13789470,\n    coral: 16744272,\n    cornflowerblue: 6591981,\n    cornsilk: 16775388,\n    crimson: 14423100,\n    cyan: 65535,\n    darkblue: 139,\n    darkcyan: 35723,\n    darkgoldenrod: 12092939,\n    darkgray: 11119017,\n    darkgreen: 25600,\n    darkgrey: 11119017,\n    darkkhaki: 12433259,\n    darkmagenta: 9109643,\n    darkolivegreen: 5597999,\n    darkorange: 16747520,\n    darkorchid: 10040012,\n    darkred: 9109504,\n    darksalmon: 15308410,\n    darkseagreen: 9419919,\n    darkslateblue: 4734347,\n    darkslategray: 3100495,\n    darkslategrey: 3100495,\n    darkturquoise: 52945,\n    darkviolet: 9699539,\n    deeppink: 16716947,\n    deepskyblue: 49151,\n    dimgray: 6908265,\n    dimgrey: 6908265,\n    dodgerblue: 2003199,\n    firebrick: 11674146,\n    floralwhite: 16775920,\n    forestgreen: 2263842,\n    fuchsia: 16711935,\n    gainsboro: 14474460,\n    ghostwhite: 16316671,\n    gold: 16766720,\n    goldenrod: 14329120,\n    gray: 8421504,\n    green: 32768,\n    greenyellow: 11403055,\n    grey: 8421504,\n    honeydew: 15794160,\n    hotpink: 16738740,\n    indianred: 13458524,\n    indigo: 4915330,\n    ivory: 16777200,\n    khaki: 15787660,\n    lavender: 15132410,\n    lavenderblush: 16773365,\n    lawngreen: 8190976,\n    lemonchiffon: 16775885,\n    lightblue: 11393254,\n    lightcoral: 15761536,\n    lightcyan: 14745599,\n    lightgoldenrodyellow: 16448210,\n    lightgray: 13882323,\n    lightgreen: 9498256,\n    lightgrey: 13882323,\n    lightpink: 16758465,\n    lightsalmon: 16752762,\n    lightseagreen: 2142890,\n    lightskyblue: 8900346,\n    lightslategray: 7833753,\n    lightslategrey: 7833753,\n    lightsteelblue: 11584734,\n    lightyellow: 16777184,\n    lime: 65280,\n    limegreen: 3329330,\n    linen: 16445670,\n    magenta: 16711935,\n    maroon: 8388608,\n    mediumaquamarine: 6737322,\n    mediumblue: 205,\n    mediumorchid: 12211667,\n    mediumpurple: 9662683,\n    mediumseagreen: 3978097,\n    mediumslateblue: 8087790,\n    mediumspringgreen: 64154,\n    mediumturquoise: 4772300,\n    mediumvioletred: 13047173,\n    midnightblue: 1644912,\n    mintcream: 16121850,\n    mistyrose: 16770273,\n    moccasin: 16770229,\n    navajowhite: 16768685,\n    navy: 128,\n    oldlace: 16643558,\n    olive: 8421376,\n    olivedrab: 7048739,\n    orange: 16753920,\n    orangered: 16729344,\n    orchid: 14315734,\n    palegoldenrod: 15657130,\n    palegreen: 10025880,\n    paleturquoise: 11529966,\n    palevioletred: 14381203,\n    papayawhip: 16773077,\n    peachpuff: 16767673,\n    peru: 13468991,\n    pink: 16761035,\n    plum: 14524637,\n    powderblue: 11591910,\n    purple: 8388736,\n    rebeccapurple: 6697881,\n    red: 16711680,\n    rosybrown: 12357519,\n    royalblue: 4286945,\n    saddlebrown: 9127187,\n    salmon: 16416882,\n    sandybrown: 16032864,\n    seagreen: 3050327,\n    seashell: 16774638,\n    sienna: 10506797,\n    silver: 12632256,\n    skyblue: 8900331,\n    slateblue: 6970061,\n    slategray: 7372944,\n    slategrey: 7372944,\n    snow: 16775930,\n    springgreen: 65407,\n    steelblue: 4620980,\n    tan: 13808780,\n    teal: 32896,\n    thistle: 14204888,\n    tomato: 16737095,\n    turquoise: 4251856,\n    violet: 15631086,\n    wheat: 16113331,\n    white: 16777215,\n    whitesmoke: 16119285,\n    yellow: 16776960,\n    yellowgreen: 10145074\n  });\n  d3_rgb_names.forEach(function(key, value) {\n    d3_rgb_names.set(key, d3_rgbNumber(value));\n  });\n  function d3_functor(v) {\n    return typeof v === \"function\" ? v : function() {\n      return v;\n    };\n  }\n  d3.functor = d3_functor;\n  d3.xhr = d3_xhrType(d3_identity);\n  function d3_xhrType(response) {\n    return function(url, mimeType, callback) {\n      if (arguments.length === 2 && typeof mimeType === \"function\") callback = mimeType, \n      mimeType = null;\n      return d3_xhr(url, mimeType, response, callback);\n    };\n  }\n  function d3_xhr(url, mimeType, response, callback) {\n    var xhr = {}, dispatch = d3.dispatch(\"beforesend\", \"progress\", \"load\", \"error\"), headers = {}, request = new XMLHttpRequest(), responseType = null;\n    if (this.XDomainRequest && !(\"withCredentials\" in request) && /^(http(s)?:)?\\/\\//.test(url)) request = new XDomainRequest();\n    \"onload\" in request ? request.onload = request.onerror = respond : request.onreadystatechange = function() {\n      request.readyState > 3 && respond();\n    };\n    function respond() {\n      var status = request.status, result;\n      if (!status && d3_xhrHasResponse(request) || status >= 200 && status < 300 || status === 304) {\n        try {\n          result = response.call(xhr, request);\n        } catch (e) {\n          dispatch.error.call(xhr, e);\n          return;\n        }\n        dispatch.load.call(xhr, result);\n      } else {\n        dispatch.error.call(xhr, request);\n      }\n    }\n    request.onprogress = function(event) {\n      var o = d3.event;\n      d3.event = event;\n      try {\n        dispatch.progress.call(xhr, request);\n      } finally {\n        d3.event = o;\n      }\n    };\n    xhr.header = function(name, value) {\n      name = (name + \"\").toLowerCase();\n      if (arguments.length < 2) return headers[name];\n      if (value == null) delete headers[name]; else headers[name] = value + \"\";\n      return xhr;\n    };\n    xhr.mimeType = function(value) {\n      if (!arguments.length) return mimeType;\n      mimeType = value == null ? null : value + \"\";\n      return xhr;\n    };\n    xhr.responseType = function(value) {\n      if (!arguments.length) return responseType;\n      responseType = value;\n      return xhr;\n    };\n    xhr.response = function(value) {\n      response = value;\n      return xhr;\n    };\n    [ \"get\", \"post\" ].forEach(function(method) {\n      xhr[method] = function() {\n        return xhr.send.apply(xhr, [ method ].concat(d3_array(arguments)));\n      };\n    });\n    xhr.send = function(method, data, callback) {\n      if (arguments.length === 2 && typeof data === \"function\") callback = data, data = null;\n      request.open(method, url, true);\n      if (mimeType != null && !(\"accept\" in headers)) headers[\"accept\"] = mimeType + \",*/*\";\n      if (request.setRequestHeader) for (var name in headers) request.setRequestHeader(name, headers[name]);\n      if (mimeType != null && request.overrideMimeType) request.overrideMimeType(mimeType);\n      if (responseType != null) request.responseType = responseType;\n      if (callback != null) xhr.on(\"error\", callback).on(\"load\", function(request) {\n        callback(null, request);\n      });\n      dispatch.beforesend.call(xhr, request);\n      request.send(data == null ? null : data);\n      return xhr;\n    };\n    xhr.abort = function() {\n      request.abort();\n      return xhr;\n    };\n    d3.rebind(xhr, dispatch, \"on\");\n    return callback == null ? xhr : xhr.get(d3_xhr_fixCallback(callback));\n  }\n  function d3_xhr_fixCallback(callback) {\n    return callback.length === 1 ? function(error, request) {\n      callback(error == null ? request : null);\n    } : callback;\n  }\n  function d3_xhrHasResponse(request) {\n    var type = request.responseType;\n    return type && type !== \"text\" ? request.response : request.responseText;\n  }\n  d3.dsv = function(delimiter, mimeType) {\n    var reFormat = new RegExp('[\"' + delimiter + \"\\n]\"), delimiterCode = delimiter.charCodeAt(0);\n    function dsv(url, row, callback) {\n      if (arguments.length < 3) callback = row, row = null;\n      var xhr = d3_xhr(url, mimeType, row == null ? response : typedResponse(row), callback);\n      xhr.row = function(_) {\n        return arguments.length ? xhr.response((row = _) == null ? response : typedResponse(_)) : row;\n      };\n      return xhr;\n    }\n    function response(request) {\n      return dsv.parse(request.responseText);\n    }\n    function typedResponse(f) {\n      return function(request) {\n        return dsv.parse(request.responseText, f);\n      };\n    }\n    dsv.parse = function(text, f) {\n      var o;\n      return dsv.parseRows(text, function(row, i) {\n        if (o) return o(row, i - 1);\n        var a = new Function(\"d\", \"return {\" + row.map(function(name, i) {\n          return JSON.stringify(name) + \": d[\" + i + \"]\";\n        }).join(\",\") + \"}\");\n        o = f ? function(row, i) {\n          return f(a(row), i);\n        } : a;\n      });\n    };\n    dsv.parseRows = function(text, f) {\n      var EOL = {}, EOF = {}, rows = [], N = text.length, I = 0, n = 0, t, eol;\n      function token() {\n        if (I >= N) return EOF;\n        if (eol) return eol = false, EOL;\n        var j = I;\n        if (text.charCodeAt(j) === 34) {\n          var i = j;\n          while (i++ < N) {\n            if (text.charCodeAt(i) === 34) {\n              if (text.charCodeAt(i + 1) !== 34) break;\n              ++i;\n            }\n          }\n          I = i + 2;\n          var c = text.charCodeAt(i + 1);\n          if (c === 13) {\n            eol = true;\n            if (text.charCodeAt(i + 2) === 10) ++I;\n          } else if (c === 10) {\n            eol = true;\n          }\n          return text.slice(j + 1, i).replace(/\"\"/g, '\"');\n        }\n        while (I < N) {\n          var c = text.charCodeAt(I++), k = 1;\n          if (c === 10) eol = true; else if (c === 13) {\n            eol = true;\n            if (text.charCodeAt(I) === 10) ++I, ++k;\n          } else if (c !== delimiterCode) continue;\n          return text.slice(j, I - k);\n        }\n        return text.slice(j);\n      }\n      while ((t = token()) !== EOF) {\n        var a = [];\n        while (t !== EOL && t !== EOF) {\n          a.push(t);\n          t = token();\n        }\n        if (f && (a = f(a, n++)) == null) continue;\n        rows.push(a);\n      }\n      return rows;\n    };\n    dsv.format = function(rows) {\n      if (Array.isArray(rows[0])) return dsv.formatRows(rows);\n      var fieldSet = new d3_Set(), fields = [];\n      rows.forEach(function(row) {\n        for (var field in row) {\n          if (!fieldSet.has(field)) {\n            fields.push(fieldSet.add(field));\n          }\n        }\n      });\n      return [ fields.map(formatValue).join(delimiter) ].concat(rows.map(function(row) {\n        return fields.map(function(field) {\n          return formatValue(row[field]);\n        }).join(delimiter);\n      })).join(\"\\n\");\n    };\n    dsv.formatRows = function(rows) {\n      return rows.map(formatRow).join(\"\\n\");\n    };\n    function formatRow(row) {\n      return row.map(formatValue).join(delimiter);\n    }\n    function formatValue(text) {\n      return reFormat.test(text) ? '\"' + text.replace(/\\\"/g, '\"\"') + '\"' : text;\n    }\n    return dsv;\n  };\n  d3.csv = d3.dsv(\",\", \"text/csv\");\n  d3.tsv = d3.dsv(\"\t\", \"text/tab-separated-values\");\n  var d3_timer_queueHead, d3_timer_queueTail, d3_timer_interval, d3_timer_timeout, d3_timer_frame = this[d3_vendorSymbol(this, \"requestAnimationFrame\")] || function(callback) {\n    setTimeout(callback, 17);\n  };\n  d3.timer = function() {\n    d3_timer.apply(this, arguments);\n  };\n  function d3_timer(callback, delay, then) {\n    var n = arguments.length;\n    if (n < 2) delay = 0;\n    if (n < 3) then = Date.now();\n    var time = then + delay, timer = {\n      c: callback,\n      t: time,\n      n: null\n    };\n    if (d3_timer_queueTail) d3_timer_queueTail.n = timer; else d3_timer_queueHead = timer;\n    d3_timer_queueTail = timer;\n    if (!d3_timer_interval) {\n      d3_timer_timeout = clearTimeout(d3_timer_timeout);\n      d3_timer_interval = 1;\n      d3_timer_frame(d3_timer_step);\n    }\n    return timer;\n  }\n  function d3_timer_step() {\n    var now = d3_timer_mark(), delay = d3_timer_sweep() - now;\n    if (delay > 24) {\n      if (isFinite(delay)) {\n        clearTimeout(d3_timer_timeout);\n        d3_timer_timeout = setTimeout(d3_timer_step, delay);\n      }\n      d3_timer_interval = 0;\n    } else {\n      d3_timer_interval = 1;\n      d3_timer_frame(d3_timer_step);\n    }\n  }\n  d3.timer.flush = function() {\n    d3_timer_mark();\n    d3_timer_sweep();\n  };\n  function d3_timer_mark() {\n    var now = Date.now(), timer = d3_timer_queueHead;\n    while (timer) {\n      if (now >= timer.t && timer.c(now - timer.t)) timer.c = null;\n      timer = timer.n;\n    }\n    return now;\n  }\n  function d3_timer_sweep() {\n    var t0, t1 = d3_timer_queueHead, time = Infinity;\n    while (t1) {\n      if (t1.c) {\n        if (t1.t < time) time = t1.t;\n        t1 = (t0 = t1).n;\n      } else {\n        t1 = t0 ? t0.n = t1.n : d3_timer_queueHead = t1.n;\n      }\n    }\n    d3_timer_queueTail = t0;\n    return time;\n  }\n  function d3_format_precision(x, p) {\n    return p - (x ? Math.ceil(Math.log(x) / Math.LN10) : 1);\n  }\n  d3.round = function(x, n) {\n    return n ? Math.round(x * (n = Math.pow(10, n))) / n : Math.round(x);\n  };\n  var d3_formatPrefixes = [ \"y\", \"z\", \"a\", \"f\", \"p\", \"n\", \"\", \"m\", \"\", \"k\", \"M\", \"G\", \"T\", \"P\", \"E\", \"Z\", \"Y\" ].map(d3_formatPrefix);\n  d3.formatPrefix = function(value, precision) {\n    var i = 0;\n    if (value = +value) {\n      if (value < 0) value *= -1;\n      if (precision) value = d3.round(value, d3_format_precision(value, precision));\n      i = 1 + Math.floor(1e-12 + Math.log(value) / Math.LN10);\n      i = Math.max(-24, Math.min(24, Math.floor((i - 1) / 3) * 3));\n    }\n    return d3_formatPrefixes[8 + i / 3];\n  };\n  function d3_formatPrefix(d, i) {\n    var k = Math.pow(10, abs(8 - i) * 3);\n    return {\n      scale: i > 8 ? function(d) {\n        return d / k;\n      } : function(d) {\n        return d * k;\n      },\n      symbol: d\n    };\n  }\n  function d3_locale_numberFormat(locale) {\n    var locale_decimal = locale.decimal, locale_thousands = locale.thousands, locale_grouping = locale.grouping, locale_currency = locale.currency, formatGroup = locale_grouping && locale_thousands ? function(value, width) {\n      var i = value.length, t = [], j = 0, g = locale_grouping[0], length = 0;\n      while (i > 0 && g > 0) {\n        if (length + g + 1 > width) g = Math.max(1, width - length);\n        t.push(value.substring(i -= g, i + g));\n        if ((length += g + 1) > width) break;\n        g = locale_grouping[j = (j + 1) % locale_grouping.length];\n      }\n      return t.reverse().join(locale_thousands);\n    } : d3_identity;\n    return function(specifier) {\n      var match = d3_format_re.exec(specifier), fill = match[1] || \" \", align = match[2] || \">\", sign = match[3] || \"-\", symbol = match[4] || \"\", zfill = match[5], width = +match[6], comma = match[7], precision = match[8], type = match[9], scale = 1, prefix = \"\", suffix = \"\", integer = false, exponent = true;\n      if (precision) precision = +precision.substring(1);\n      if (zfill || fill === \"0\" && align === \"=\") {\n        zfill = fill = \"0\";\n        align = \"=\";\n      }\n      switch (type) {\n       case \"n\":\n        comma = true;\n        type = \"g\";\n        break;\n\n       case \"%\":\n        scale = 100;\n        suffix = \"%\";\n        type = \"f\";\n        break;\n\n       case \"p\":\n        scale = 100;\n        suffix = \"%\";\n        type = \"r\";\n        break;\n\n       case \"b\":\n       case \"o\":\n       case \"x\":\n       case \"X\":\n        if (symbol === \"#\") prefix = \"0\" + type.toLowerCase();\n\n       case \"c\":\n        exponent = false;\n\n       case \"d\":\n        integer = true;\n        precision = 0;\n        break;\n\n       case \"s\":\n        scale = -1;\n        type = \"r\";\n        break;\n      }\n      if (symbol === \"$\") prefix = locale_currency[0], suffix = locale_currency[1];\n      if (type == \"r\" && !precision) type = \"g\";\n      if (precision != null) {\n        if (type == \"g\") precision = Math.max(1, Math.min(21, precision)); else if (type == \"e\" || type == \"f\") precision = Math.max(0, Math.min(20, precision));\n      }\n      type = d3_format_types.get(type) || d3_format_typeDefault;\n      var zcomma = zfill && comma;\n      return function(value) {\n        var fullSuffix = suffix;\n        if (integer && value % 1) return \"\";\n        var negative = value < 0 || value === 0 && 1 / value < 0 ? (value = -value, \"-\") : sign === \"-\" ? \"\" : sign;\n        if (scale < 0) {\n          var unit = d3.formatPrefix(value, precision);\n          value = unit.scale(value);\n          fullSuffix = unit.symbol + suffix;\n        } else {\n          value *= scale;\n        }\n        value = type(value, precision);\n        var i = value.lastIndexOf(\".\"), before, after;\n        if (i < 0) {\n          var j = exponent ? value.lastIndexOf(\"e\") : -1;\n          if (j < 0) before = value, after = \"\"; else before = value.substring(0, j), after = value.substring(j);\n        } else {\n          before = value.substring(0, i);\n          after = locale_decimal + value.substring(i + 1);\n        }\n        if (!zfill && comma) before = formatGroup(before, Infinity);\n        var length = prefix.length + before.length + after.length + (zcomma ? 0 : negative.length), padding = length < width ? new Array(length = width - length + 1).join(fill) : \"\";\n        if (zcomma) before = formatGroup(padding + before, padding.length ? width - after.length : Infinity);\n        negative += prefix;\n        value = before + after;\n        return (align === \"<\" ? negative + value + padding : align === \">\" ? padding + negative + value : align === \"^\" ? padding.substring(0, length >>= 1) + negative + value + padding.substring(length) : negative + (zcomma ? value : padding + value)) + fullSuffix;\n      };\n    };\n  }\n  var d3_format_re = /(?:([^{])?([<>=^]))?([+\\- ])?([$#])?(0)?(\\d+)?(,)?(\\.-?\\d+)?([a-z%])?/i;\n  var d3_format_types = d3.map({\n    b: function(x) {\n      return x.toString(2);\n    },\n    c: function(x) {\n      return String.fromCharCode(x);\n    },\n    o: function(x) {\n      return x.toString(8);\n    },\n    x: function(x) {\n      return x.toString(16);\n    },\n    X: function(x) {\n      return x.toString(16).toUpperCase();\n    },\n    g: function(x, p) {\n      return x.toPrecision(p);\n    },\n    e: function(x, p) {\n      return x.toExponential(p);\n    },\n    f: function(x, p) {\n      return x.toFixed(p);\n    },\n    r: function(x, p) {\n      return (x = d3.round(x, d3_format_precision(x, p))).toFixed(Math.max(0, Math.min(20, d3_format_precision(x * (1 + 1e-15), p))));\n    }\n  });\n  function d3_format_typeDefault(x) {\n    return x + \"\";\n  }\n  var d3_time = d3.time = {}, d3_date = Date;\n  function d3_date_utc() {\n    this._ = new Date(arguments.length > 1 ? Date.UTC.apply(this, arguments) : arguments[0]);\n  }\n  d3_date_utc.prototype = {\n    getDate: function() {\n      return this._.getUTCDate();\n    },\n    getDay: function() {\n      return this._.getUTCDay();\n    },\n    getFullYear: function() {\n      return this._.getUTCFullYear();\n    },\n    getHours: function() {\n      return this._.getUTCHours();\n    },\n    getMilliseconds: function() {\n      return this._.getUTCMilliseconds();\n    },\n    getMinutes: function() {\n      return this._.getUTCMinutes();\n    },\n    getMonth: function() {\n      return this._.getUTCMonth();\n    },\n    getSeconds: function() {\n      return this._.getUTCSeconds();\n    },\n    getTime: function() {\n      return this._.getTime();\n    },\n    getTimezoneOffset: function() {\n      return 0;\n    },\n    valueOf: function() {\n      return this._.valueOf();\n    },\n    setDate: function() {\n      d3_time_prototype.setUTCDate.apply(this._, arguments);\n    },\n    setDay: function() {\n      d3_time_prototype.setUTCDay.apply(this._, arguments);\n    },\n    setFullYear: function() {\n      d3_time_prototype.setUTCFullYear.apply(this._, arguments);\n    },\n    setHours: function() {\n      d3_time_prototype.setUTCHours.apply(this._, arguments);\n    },\n    setMilliseconds: function() {\n      d3_time_prototype.setUTCMilliseconds.apply(this._, arguments);\n    },\n    setMinutes: function() {\n      d3_time_prototype.setUTCMinutes.apply(this._, arguments);\n    },\n    setMonth: function() {\n      d3_time_prototype.setUTCMonth.apply(this._, arguments);\n    },\n    setSeconds: function() {\n      d3_time_prototype.setUTCSeconds.apply(this._, arguments);\n    },\n    setTime: function() {\n      d3_time_prototype.setTime.apply(this._, arguments);\n    }\n  };\n  var d3_time_prototype = Date.prototype;\n  function d3_time_interval(local, step, number) {\n    function round(date) {\n      var d0 = local(date), d1 = offset(d0, 1);\n      return date - d0 < d1 - date ? d0 : d1;\n    }\n    function ceil(date) {\n      step(date = local(new d3_date(date - 1)), 1);\n      return date;\n    }\n    function offset(date, k) {\n      step(date = new d3_date(+date), k);\n      return date;\n    }\n    function range(t0, t1, dt) {\n      var time = ceil(t0), times = [];\n      if (dt > 1) {\n        while (time < t1) {\n          if (!(number(time) % dt)) times.push(new Date(+time));\n          step(time, 1);\n        }\n      } else {\n        while (time < t1) times.push(new Date(+time)), step(time, 1);\n      }\n      return times;\n    }\n    function range_utc(t0, t1, dt) {\n      try {\n        d3_date = d3_date_utc;\n        var utc = new d3_date_utc();\n        utc._ = t0;\n        return range(utc, t1, dt);\n      } finally {\n        d3_date = Date;\n      }\n    }\n    local.floor = local;\n    local.round = round;\n    local.ceil = ceil;\n    local.offset = offset;\n    local.range = range;\n    var utc = local.utc = d3_time_interval_utc(local);\n    utc.floor = utc;\n    utc.round = d3_time_interval_utc(round);\n    utc.ceil = d3_time_interval_utc(ceil);\n    utc.offset = d3_time_interval_utc(offset);\n    utc.range = range_utc;\n    return local;\n  }\n  function d3_time_interval_utc(method) {\n    return function(date, k) {\n      try {\n        d3_date = d3_date_utc;\n        var utc = new d3_date_utc();\n        utc._ = date;\n        return method(utc, k)._;\n      } finally {\n        d3_date = Date;\n      }\n    };\n  }\n  d3_time.year = d3_time_interval(function(date) {\n    date = d3_time.day(date);\n    date.setMonth(0, 1);\n    return date;\n  }, function(date, offset) {\n    date.setFullYear(date.getFullYear() + offset);\n  }, function(date) {\n    return date.getFullYear();\n  });\n  d3_time.years = d3_time.year.range;\n  d3_time.years.utc = d3_time.year.utc.range;\n  d3_time.day = d3_time_interval(function(date) {\n    var day = new d3_date(2e3, 0);\n    day.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());\n    return day;\n  }, function(date, offset) {\n    date.setDate(date.getDate() + offset);\n  }, function(date) {\n    return date.getDate() - 1;\n  });\n  d3_time.days = d3_time.day.range;\n  d3_time.days.utc = d3_time.day.utc.range;\n  d3_time.dayOfYear = function(date) {\n    var year = d3_time.year(date);\n    return Math.floor((date - year - (date.getTimezoneOffset() - year.getTimezoneOffset()) * 6e4) / 864e5);\n  };\n  [ \"sunday\", \"monday\", \"tuesday\", \"wednesday\", \"thursday\", \"friday\", \"saturday\" ].forEach(function(day, i) {\n    i = 7 - i;\n    var interval = d3_time[day] = d3_time_interval(function(date) {\n      (date = d3_time.day(date)).setDate(date.getDate() - (date.getDay() + i) % 7);\n      return date;\n    }, function(date, offset) {\n      date.setDate(date.getDate() + Math.floor(offset) * 7);\n    }, function(date) {\n      var day = d3_time.year(date).getDay();\n      return Math.floor((d3_time.dayOfYear(date) + (day + i) % 7) / 7) - (day !== i);\n    });\n    d3_time[day + \"s\"] = interval.range;\n    d3_time[day + \"s\"].utc = interval.utc.range;\n    d3_time[day + \"OfYear\"] = function(date) {\n      var day = d3_time.year(date).getDay();\n      return Math.floor((d3_time.dayOfYear(date) + (day + i) % 7) / 7);\n    };\n  });\n  d3_time.week = d3_time.sunday;\n  d3_time.weeks = d3_time.sunday.range;\n  d3_time.weeks.utc = d3_time.sunday.utc.range;\n  d3_time.weekOfYear = d3_time.sundayOfYear;\n  function d3_locale_timeFormat(locale) {\n    var locale_dateTime = locale.dateTime, locale_date = locale.date, locale_time = locale.time, locale_periods = locale.periods, locale_days = locale.days, locale_shortDays = locale.shortDays, locale_months = locale.months, locale_shortMonths = locale.shortMonths;\n    function d3_time_format(template) {\n      var n = template.length;\n      function format(date) {\n        var string = [], i = -1, j = 0, c, p, f;\n        while (++i < n) {\n          if (template.charCodeAt(i) === 37) {\n            string.push(template.slice(j, i));\n            if ((p = d3_time_formatPads[c = template.charAt(++i)]) != null) c = template.charAt(++i);\n            if (f = d3_time_formats[c]) c = f(date, p == null ? c === \"e\" ? \" \" : \"0\" : p);\n            string.push(c);\n            j = i + 1;\n          }\n        }\n        string.push(template.slice(j, i));\n        return string.join(\"\");\n      }\n      format.parse = function(string) {\n        var d = {\n          y: 1900,\n          m: 0,\n          d: 1,\n          H: 0,\n          M: 0,\n          S: 0,\n          L: 0,\n          Z: null\n        }, i = d3_time_parse(d, template, string, 0);\n        if (i != string.length) return null;\n        if (\"p\" in d) d.H = d.H % 12 + d.p * 12;\n        var localZ = d.Z != null && d3_date !== d3_date_utc, date = new (localZ ? d3_date_utc : d3_date)();\n        if (\"j\" in d) date.setFullYear(d.y, 0, d.j); else if (\"W\" in d || \"U\" in d) {\n          if (!(\"w\" in d)) d.w = \"W\" in d ? 1 : 0;\n          date.setFullYear(d.y, 0, 1);\n          date.setFullYear(d.y, 0, \"W\" in d ? (d.w + 6) % 7 + d.W * 7 - (date.getDay() + 5) % 7 : d.w + d.U * 7 - (date.getDay() + 6) % 7);\n        } else date.setFullYear(d.y, d.m, d.d);\n        date.setHours(d.H + (d.Z / 100 | 0), d.M + d.Z % 100, d.S, d.L);\n        return localZ ? date._ : date;\n      };\n      format.toString = function() {\n        return template;\n      };\n      return format;\n    }\n    function d3_time_parse(date, template, string, j) {\n      var c, p, t, i = 0, n = template.length, m = string.length;\n      while (i < n) {\n        if (j >= m) return -1;\n        c = template.charCodeAt(i++);\n        if (c === 37) {\n          t = template.charAt(i++);\n          p = d3_time_parsers[t in d3_time_formatPads ? template.charAt(i++) : t];\n          if (!p || (j = p(date, string, j)) < 0) return -1;\n        } else if (c != string.charCodeAt(j++)) {\n          return -1;\n        }\n      }\n      return j;\n    }\n    d3_time_format.utc = function(template) {\n      var local = d3_time_format(template);\n      function format(date) {\n        try {\n          d3_date = d3_date_utc;\n          var utc = new d3_date();\n          utc._ = date;\n          return local(utc);\n        } finally {\n          d3_date = Date;\n        }\n      }\n      format.parse = function(string) {\n        try {\n          d3_date = d3_date_utc;\n          var date = local.parse(string);\n          return date && date._;\n        } finally {\n          d3_date = Date;\n        }\n      };\n      format.toString = local.toString;\n      return format;\n    };\n    d3_time_format.multi = d3_time_format.utc.multi = d3_time_formatMulti;\n    var d3_time_periodLookup = d3.map(), d3_time_dayRe = d3_time_formatRe(locale_days), d3_time_dayLookup = d3_time_formatLookup(locale_days), d3_time_dayAbbrevRe = d3_time_formatRe(locale_shortDays), d3_time_dayAbbrevLookup = d3_time_formatLookup(locale_shortDays), d3_time_monthRe = d3_time_formatRe(locale_months), d3_time_monthLookup = d3_time_formatLookup(locale_months), d3_time_monthAbbrevRe = d3_time_formatRe(locale_shortMonths), d3_time_monthAbbrevLookup = d3_time_formatLookup(locale_shortMonths);\n    locale_periods.forEach(function(p, i) {\n      d3_time_periodLookup.set(p.toLowerCase(), i);\n    });\n    var d3_time_formats = {\n      a: function(d) {\n        return locale_shortDays[d.getDay()];\n      },\n      A: function(d) {\n        return locale_days[d.getDay()];\n      },\n      b: function(d) {\n        return locale_shortMonths[d.getMonth()];\n      },\n      B: function(d) {\n        return locale_months[d.getMonth()];\n      },\n      c: d3_time_format(locale_dateTime),\n      d: function(d, p) {\n        return d3_time_formatPad(d.getDate(), p, 2);\n      },\n      e: function(d, p) {\n        return d3_time_formatPad(d.getDate(), p, 2);\n      },\n      H: function(d, p) {\n        return d3_time_formatPad(d.getHours(), p, 2);\n      },\n      I: function(d, p) {\n        return d3_time_formatPad(d.getHours() % 12 || 12, p, 2);\n      },\n      j: function(d, p) {\n        return d3_time_formatPad(1 + d3_time.dayOfYear(d), p, 3);\n      },\n      L: function(d, p) {\n        return d3_time_formatPad(d.getMilliseconds(), p, 3);\n      },\n      m: function(d, p) {\n        return d3_time_formatPad(d.getMonth() + 1, p, 2);\n      },\n      M: function(d, p) {\n        return d3_time_formatPad(d.getMinutes(), p, 2);\n      },\n      p: function(d) {\n        return locale_periods[+(d.getHours() >= 12)];\n      },\n      S: function(d, p) {\n        return d3_time_formatPad(d.getSeconds(), p, 2);\n      },\n      U: function(d, p) {\n        return d3_time_formatPad(d3_time.sundayOfYear(d), p, 2);\n      },\n      w: function(d) {\n        return d.getDay();\n      },\n      W: function(d, p) {\n        return d3_time_formatPad(d3_time.mondayOfYear(d), p, 2);\n      },\n      x: d3_time_format(locale_date),\n      X: d3_time_format(locale_time),\n      y: function(d, p) {\n        return d3_time_formatPad(d.getFullYear() % 100, p, 2);\n      },\n      Y: function(d, p) {\n        return d3_time_formatPad(d.getFullYear() % 1e4, p, 4);\n      },\n      Z: d3_time_zone,\n      \"%\": function() {\n        return \"%\";\n      }\n    };\n    var d3_time_parsers = {\n      a: d3_time_parseWeekdayAbbrev,\n      A: d3_time_parseWeekday,\n      b: d3_time_parseMonthAbbrev,\n      B: d3_time_parseMonth,\n      c: d3_time_parseLocaleFull,\n      d: d3_time_parseDay,\n      e: d3_time_parseDay,\n      H: d3_time_parseHour24,\n      I: d3_time_parseHour24,\n      j: d3_time_parseDayOfYear,\n      L: d3_time_parseMilliseconds,\n      m: d3_time_parseMonthNumber,\n      M: d3_time_parseMinutes,\n      p: d3_time_parseAmPm,\n      S: d3_time_parseSeconds,\n      U: d3_time_parseWeekNumberSunday,\n      w: d3_time_parseWeekdayNumber,\n      W: d3_time_parseWeekNumberMonday,\n      x: d3_time_parseLocaleDate,\n      X: d3_time_parseLocaleTime,\n      y: d3_time_parseYear,\n      Y: d3_time_parseFullYear,\n      Z: d3_time_parseZone,\n      \"%\": d3_time_parseLiteralPercent\n    };\n    function d3_time_parseWeekdayAbbrev(date, string, i) {\n      d3_time_dayAbbrevRe.lastIndex = 0;\n      var n = d3_time_dayAbbrevRe.exec(string.slice(i));\n      return n ? (date.w = d3_time_dayAbbrevLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;\n    }\n    function d3_time_parseWeekday(date, string, i) {\n      d3_time_dayRe.lastIndex = 0;\n      var n = d3_time_dayRe.exec(string.slice(i));\n      return n ? (date.w = d3_time_dayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;\n    }\n    function d3_time_parseMonthAbbrev(date, string, i) {\n      d3_time_monthAbbrevRe.lastIndex = 0;\n      var n = d3_time_monthAbbrevRe.exec(string.slice(i));\n      return n ? (date.m = d3_time_monthAbbrevLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;\n    }\n    function d3_time_parseMonth(date, string, i) {\n      d3_time_monthRe.lastIndex = 0;\n      var n = d3_time_monthRe.exec(string.slice(i));\n      return n ? (date.m = d3_time_monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;\n    }\n    function d3_time_parseLocaleFull(date, string, i) {\n      return d3_time_parse(date, d3_time_formats.c.toString(), string, i);\n    }\n    function d3_time_parseLocaleDate(date, string, i) {\n      return d3_time_parse(date, d3_time_formats.x.toString(), string, i);\n    }\n    function d3_time_parseLocaleTime(date, string, i) {\n      return d3_time_parse(date, d3_time_formats.X.toString(), string, i);\n    }\n    function d3_time_parseAmPm(date, string, i) {\n      var n = d3_time_periodLookup.get(string.slice(i, i += 2).toLowerCase());\n      return n == null ? -1 : (date.p = n, i);\n    }\n    return d3_time_format;\n  }\n  var d3_time_formatPads = {\n    \"-\": \"\",\n    _: \" \",\n    \"0\": \"0\"\n  }, d3_time_numberRe = /^\\s*\\d+/, d3_time_percentRe = /^%/;\n  function d3_time_formatPad(value, fill, width) {\n    var sign = value < 0 ? \"-\" : \"\", string = (sign ? -value : value) + \"\", length = string.length;\n    return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);\n  }\n  function d3_time_formatRe(names) {\n    return new RegExp(\"^(?:\" + names.map(d3.requote).join(\"|\") + \")\", \"i\");\n  }\n  function d3_time_formatLookup(names) {\n    var map = new d3_Map(), i = -1, n = names.length;\n    while (++i < n) map.set(names[i].toLowerCase(), i);\n    return map;\n  }\n  function d3_time_parseWeekdayNumber(date, string, i) {\n    d3_time_numberRe.lastIndex = 0;\n    var n = d3_time_numberRe.exec(string.slice(i, i + 1));\n    return n ? (date.w = +n[0], i + n[0].length) : -1;\n  }\n  function d3_time_parseWeekNumberSunday(date, string, i) {\n    d3_time_numberRe.lastIndex = 0;\n    var n = d3_time_numberRe.exec(string.slice(i));\n    return n ? (date.U = +n[0], i + n[0].length) : -1;\n  }\n  function d3_time_parseWeekNumberMonday(date, string, i) {\n    d3_time_numberRe.lastIndex = 0;\n    var n = d3_time_numberRe.exec(string.slice(i));\n    return n ? (date.W = +n[0], i + n[0].length) : -1;\n  }\n  function d3_time_parseFullYear(date, string, i) {\n    d3_time_numberRe.lastIndex = 0;\n    var n = d3_time_numberRe.exec(string.slice(i, i + 4));\n    return n ? (date.y = +n[0], i + n[0].length) : -1;\n  }\n  function d3_time_parseYear(date, string, i) {\n    d3_time_numberRe.lastIndex = 0;\n    var n = d3_time_numberRe.exec(string.slice(i, i + 2));\n    return n ? (date.y = d3_time_expandYear(+n[0]), i + n[0].length) : -1;\n  }\n  function d3_time_parseZone(date, string, i) {\n    return /^[+-]\\d{4}$/.test(string = string.slice(i, i + 5)) ? (date.Z = -string, \n    i + 5) : -1;\n  }\n  function d3_time_expandYear(d) {\n    return d + (d > 68 ? 1900 : 2e3);\n  }\n  function d3_time_parseMonthNumber(date, string, i) {\n    d3_time_numberRe.lastIndex = 0;\n    var n = d3_time_numberRe.exec(string.slice(i, i + 2));\n    return n ? (date.m = n[0] - 1, i + n[0].length) : -1;\n  }\n  function d3_time_parseDay(date, string, i) {\n    d3_time_numberRe.lastIndex = 0;\n    var n = d3_time_numberRe.exec(string.slice(i, i + 2));\n    return n ? (date.d = +n[0], i + n[0].length) : -1;\n  }\n  function d3_time_parseDayOfYear(date, string, i) {\n    d3_time_numberRe.lastIndex = 0;\n    var n = d3_time_numberRe.exec(string.slice(i, i + 3));\n    return n ? (date.j = +n[0], i + n[0].length) : -1;\n  }\n  function d3_time_parseHour24(date, string, i) {\n    d3_time_numberRe.lastIndex = 0;\n    var n = d3_time_numberRe.exec(string.slice(i, i + 2));\n    return n ? (date.H = +n[0], i + n[0].length) : -1;\n  }\n  function d3_time_parseMinutes(date, string, i) {\n    d3_time_numberRe.lastIndex = 0;\n    var n = d3_time_numberRe.exec(string.slice(i, i + 2));\n    return n ? (date.M = +n[0], i + n[0].length) : -1;\n  }\n  function d3_time_parseSeconds(date, string, i) {\n    d3_time_numberRe.lastIndex = 0;\n    var n = d3_time_numberRe.exec(string.slice(i, i + 2));\n    return n ? (date.S = +n[0], i + n[0].length) : -1;\n  }\n  function d3_time_parseMilliseconds(date, string, i) {\n    d3_time_numberRe.lastIndex = 0;\n    var n = d3_time_numberRe.exec(string.slice(i, i + 3));\n    return n ? (date.L = +n[0], i + n[0].length) : -1;\n  }\n  function d3_time_zone(d) {\n    var z = d.getTimezoneOffset(), zs = z > 0 ? \"-\" : \"+\", zh = abs(z) / 60 | 0, zm = abs(z) % 60;\n    return zs + d3_time_formatPad(zh, \"0\", 2) + d3_time_formatPad(zm, \"0\", 2);\n  }\n  function d3_time_parseLiteralPercent(date, string, i) {\n    d3_time_percentRe.lastIndex = 0;\n    var n = d3_time_percentRe.exec(string.slice(i, i + 1));\n    return n ? i + n[0].length : -1;\n  }\n  function d3_time_formatMulti(formats) {\n    var n = formats.length, i = -1;\n    while (++i < n) formats[i][0] = this(formats[i][0]);\n    return function(date) {\n      var i = 0, f = formats[i];\n      while (!f[1](date)) f = formats[++i];\n      return f[0](date);\n    };\n  }\n  d3.locale = function(locale) {\n    return {\n      numberFormat: d3_locale_numberFormat(locale),\n      timeFormat: d3_locale_timeFormat(locale)\n    };\n  };\n  var d3_locale_enUS = d3.locale({\n    decimal: \".\",\n    thousands: \",\",\n    grouping: [ 3 ],\n    currency: [ \"$\", \"\" ],\n    dateTime: \"%a %b %e %X %Y\",\n    date: \"%m/%d/%Y\",\n    time: \"%H:%M:%S\",\n    periods: [ \"AM\", \"PM\" ],\n    days: [ \"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\" ],\n    shortDays: [ \"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\" ],\n    months: [ \"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\" ],\n    shortMonths: [ \"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\" ]\n  });\n  d3.format = d3_locale_enUS.numberFormat;\n  d3.geo = {};\n  function d3_adder() {}\n  d3_adder.prototype = {\n    s: 0,\n    t: 0,\n    add: function(y) {\n      d3_adderSum(y, this.t, d3_adderTemp);\n      d3_adderSum(d3_adderTemp.s, this.s, this);\n      if (this.s) this.t += d3_adderTemp.t; else this.s = d3_adderTemp.t;\n    },\n    reset: function() {\n      this.s = this.t = 0;\n    },\n    valueOf: function() {\n      return this.s;\n    }\n  };\n  var d3_adderTemp = new d3_adder();\n  function d3_adderSum(a, b, o) {\n    var x = o.s = a + b, bv = x - a, av = x - bv;\n    o.t = a - av + (b - bv);\n  }\n  d3.geo.stream = function(object, listener) {\n    if (object && d3_geo_streamObjectType.hasOwnProperty(object.type)) {\n      d3_geo_streamObjectType[object.type](object, listener);\n    } else {\n      d3_geo_streamGeometry(object, listener);\n    }\n  };\n  function d3_geo_streamGeometry(geometry, listener) {\n    if (geometry && d3_geo_streamGeometryType.hasOwnProperty(geometry.type)) {\n      d3_geo_streamGeometryType[geometry.type](geometry, listener);\n    }\n  }\n  var d3_geo_streamObjectType = {\n    Feature: function(feature, listener) {\n      d3_geo_streamGeometry(feature.geometry, listener);\n    },\n    FeatureCollection: function(object, listener) {\n      var features = object.features, i = -1, n = features.length;\n      while (++i < n) d3_geo_streamGeometry(features[i].geometry, listener);\n    }\n  };\n  var d3_geo_streamGeometryType = {\n    Sphere: function(object, listener) {\n      listener.sphere();\n    },\n    Point: function(object, listener) {\n      object = object.coordinates;\n      listener.point(object[0], object[1], object[2]);\n    },\n    MultiPoint: function(object, listener) {\n      var coordinates = object.coordinates, i = -1, n = coordinates.length;\n      while (++i < n) object = coordinates[i], listener.point(object[0], object[1], object[2]);\n    },\n    LineString: function(object, listener) {\n      d3_geo_streamLine(object.coordinates, listener, 0);\n    },\n    MultiLineString: function(object, listener) {\n      var coordinates = object.coordinates, i = -1, n = coordinates.length;\n      while (++i < n) d3_geo_streamLine(coordinates[i], listener, 0);\n    },\n    Polygon: function(object, listener) {\n      d3_geo_streamPolygon(object.coordinates, listener);\n    },\n    MultiPolygon: function(object, listener) {\n      var coordinates = object.coordinates, i = -1, n = coordinates.length;\n      while (++i < n) d3_geo_streamPolygon(coordinates[i], listener);\n    },\n    GeometryCollection: function(object, listener) {\n      var geometries = object.geometries, i = -1, n = geometries.length;\n      while (++i < n) d3_geo_streamGeometry(geometries[i], listener);\n    }\n  };\n  function d3_geo_streamLine(coordinates, listener, closed) {\n    var i = -1, n = coordinates.length - closed, coordinate;\n    listener.lineStart();\n    while (++i < n) coordinate = coordinates[i], listener.point(coordinate[0], coordinate[1], coordinate[2]);\n    listener.lineEnd();\n  }\n  function d3_geo_streamPolygon(coordinates, listener) {\n    var i = -1, n = coordinates.length;\n    listener.polygonStart();\n    while (++i < n) d3_geo_streamLine(coordinates[i], listener, 1);\n    listener.polygonEnd();\n  }\n  d3.geo.area = function(object) {\n    d3_geo_areaSum = 0;\n    d3.geo.stream(object, d3_geo_area);\n    return d3_geo_areaSum;\n  };\n  var d3_geo_areaSum, d3_geo_areaRingSum = new d3_adder();\n  var d3_geo_area = {\n    sphere: function() {\n      d3_geo_areaSum += 4 * ;\n    },\n    point: d3_noop,\n    lineStart: d3_noop,\n    lineEnd: d3_noop,\n    polygonStart: function() {\n      d3_geo_areaRingSum.reset();\n      d3_geo_area.lineStart = d3_geo_areaRingStart;\n    },\n    polygonEnd: function() {\n      var area = 2 * d3_geo_areaRingSum;\n      d3_geo_areaSum += area < 0 ? 4 *  + area : area;\n      d3_geo_area.lineStart = d3_geo_area.lineEnd = d3_geo_area.point = d3_noop;\n    }\n  };\n  function d3_geo_areaRingStart() {\n    var 00, 00, 0, cos0, sin0;\n    d3_geo_area.point = function(, ) {\n      d3_geo_area.point = nextPoint;\n      0 = (00 = ) * d3_radians, cos0 = Math.cos( = (00 = ) * d3_radians / 2 +  / 4), \n      sin0 = Math.sin();\n    };\n    function nextPoint(, ) {\n       *= d3_radians;\n       =  * d3_radians / 2 +  / 4;\n      var d =  - 0, sd = d >= 0 ? 1 : -1, ad = sd * d, cos = Math.cos(), sin = Math.sin(), k = sin0 * sin, u = cos0 * cos + k * Math.cos(ad), v = k * sd * Math.sin(ad);\n      d3_geo_areaRingSum.add(Math.atan2(v, u));\n      0 = , cos0 = cos, sin0 = sin;\n    }\n    d3_geo_area.lineEnd = function() {\n      nextPoint(00, 00);\n    };\n  }\n  function d3_geo_cartesian(spherical) {\n    var  = spherical[0],  = spherical[1], cos = Math.cos();\n    return [ cos * Math.cos(), cos * Math.sin(), Math.sin() ];\n  }\n  function d3_geo_cartesianDot(a, b) {\n    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\n  }\n  function d3_geo_cartesianCross(a, b) {\n    return [ a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0] ];\n  }\n  function d3_geo_cartesianAdd(a, b) {\n    a[0] += b[0];\n    a[1] += b[1];\n    a[2] += b[2];\n  }\n  function d3_geo_cartesianScale(vector, k) {\n    return [ vector[0] * k, vector[1] * k, vector[2] * k ];\n  }\n  function d3_geo_cartesianNormalize(d) {\n    var l = Math.sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);\n    d[0] /= l;\n    d[1] /= l;\n    d[2] /= l;\n  }\n  function d3_geo_spherical(cartesian) {\n    return [ Math.atan2(cartesian[1], cartesian[0]), d3_asin(cartesian[2]) ];\n  }\n  function d3_geo_sphericalEqual(a, b) {\n    return abs(a[0] - b[0]) <  && abs(a[1] - b[1]) < ;\n  }\n  d3.geo.bounds = function() {\n    var 0, 0, 1, 1, _, __, __, p0, dSum, ranges, range;\n    var bound = {\n      point: point,\n      lineStart: lineStart,\n      lineEnd: lineEnd,\n      polygonStart: function() {\n        bound.point = ringPoint;\n        bound.lineStart = ringStart;\n        bound.lineEnd = ringEnd;\n        dSum = 0;\n        d3_geo_area.polygonStart();\n      },\n      polygonEnd: function() {\n        d3_geo_area.polygonEnd();\n        bound.point = point;\n        bound.lineStart = lineStart;\n        bound.lineEnd = lineEnd;\n        if (d3_geo_areaRingSum < 0) 0 = -(1 = 180), 0 = -(1 = 90); else if (dSum > ) 1 = 90; else if (dSum < -) 0 = -90;\n        range[0] = 0, range[1] = 1;\n      }\n    };\n    function point(, ) {\n      ranges.push(range = [ 0 = , 1 =  ]);\n      if ( < 0) 0 = ;\n      if ( > 1) 1 = ;\n    }\n    function linePoint(, ) {\n      var p = d3_geo_cartesian([  * d3_radians,  * d3_radians ]);\n      if (p0) {\n        var normal = d3_geo_cartesianCross(p0, p), equatorial = [ normal[1], -normal[0], 0 ], inflection = d3_geo_cartesianCross(equatorial, normal);\n        d3_geo_cartesianNormalize(inflection);\n        inflection = d3_geo_spherical(inflection);\n        var d =  - _, s = d > 0 ? 1 : -1, i = inflection[0] * d3_degrees * s, antimeridian = abs(d) > 180;\n        if (antimeridian ^ (s * _ < i && i < s * )) {\n          var i = inflection[1] * d3_degrees;\n          if (i > 1) 1 = i;\n        } else if (i = (i + 360) % 360 - 180, antimeridian ^ (s * _ < i && i < s * )) {\n          var i = -inflection[1] * d3_degrees;\n          if (i < 0) 0 = i;\n        } else {\n          if ( < 0) 0 = ;\n          if ( > 1) 1 = ;\n        }\n        if (antimeridian) {\n          if ( < _) {\n            if (angle(0, ) > angle(0, 1)) 1 = ;\n          } else {\n            if (angle(, 1) > angle(0, 1)) 0 = ;\n          }\n        } else {\n          if (1 >= 0) {\n            if ( < 0) 0 = ;\n            if ( > 1) 1 = ;\n          } else {\n            if ( > _) {\n              if (angle(0, ) > angle(0, 1)) 1 = ;\n            } else {\n              if (angle(, 1) > angle(0, 1)) 0 = ;\n            }\n          }\n        }\n      } else {\n        point(, );\n      }\n      p0 = p, _ = ;\n    }\n    function lineStart() {\n      bound.point = linePoint;\n    }\n    function lineEnd() {\n      range[0] = 0, range[1] = 1;\n      bound.point = point;\n      p0 = null;\n    }\n    function ringPoint(, ) {\n      if (p0) {\n        var d =  - _;\n        dSum += abs(d) > 180 ? d + (d > 0 ? 360 : -360) : d;\n      } else __ = , __ = ;\n      d3_geo_area.point(, );\n      linePoint(, );\n    }\n    function ringStart() {\n      d3_geo_area.lineStart();\n    }\n    function ringEnd() {\n      ringPoint(__, __);\n      d3_geo_area.lineEnd();\n      if (abs(dSum) > ) 0 = -(1 = 180);\n      range[0] = 0, range[1] = 1;\n      p0 = null;\n    }\n    function angle(0, 1) {\n      return (1 -= 0) < 0 ? 1 + 360 : 1;\n    }\n    function compareRanges(a, b) {\n      return a[0] - b[0];\n    }\n    function withinRange(x, range) {\n      return range[0] <= range[1] ? range[0] <= x && x <= range[1] : x < range[0] || range[1] < x;\n    }\n    return function(feature) {\n      1 = 1 = -(0 = 0 = Infinity);\n      ranges = [];\n      d3.geo.stream(feature, bound);\n      var n = ranges.length;\n      if (n) {\n        ranges.sort(compareRanges);\n        for (var i = 1, a = ranges[0], b, merged = [ a ]; i < n; ++i) {\n          b = ranges[i];\n          if (withinRange(b[0], a) || withinRange(b[1], a)) {\n            if (angle(a[0], b[1]) > angle(a[0], a[1])) a[1] = b[1];\n            if (angle(b[0], a[1]) > angle(a[0], a[1])) a[0] = b[0];\n          } else {\n            merged.push(a = b);\n          }\n        }\n        var best = -Infinity, d;\n        for (var n = merged.length - 1, i = 0, a = merged[n], b; i <= n; a = b, ++i) {\n          b = merged[i];\n          if ((d = angle(a[1], b[0])) > best) best = d, 0 = b[0], 1 = a[1];\n        }\n      }\n      ranges = range = null;\n      return 0 === Infinity || 0 === Infinity ? [ [ NaN, NaN ], [ NaN, NaN ] ] : [ [ 0, 0 ], [ 1, 1 ] ];\n    };\n  }();\n  d3.geo.centroid = function(object) {\n    d3_geo_centroidW0 = d3_geo_centroidW1 = d3_geo_centroidX0 = d3_geo_centroidY0 = d3_geo_centroidZ0 = d3_geo_centroidX1 = d3_geo_centroidY1 = d3_geo_centroidZ1 = d3_geo_centroidX2 = d3_geo_centroidY2 = d3_geo_centroidZ2 = 0;\n    d3.geo.stream(object, d3_geo_centroid);\n    var x = d3_geo_centroidX2, y = d3_geo_centroidY2, z = d3_geo_centroidZ2, m = x * x + y * y + z * z;\n    if (m < 2) {\n      x = d3_geo_centroidX1, y = d3_geo_centroidY1, z = d3_geo_centroidZ1;\n      if (d3_geo_centroidW1 < ) x = d3_geo_centroidX0, y = d3_geo_centroidY0, z = d3_geo_centroidZ0;\n      m = x * x + y * y + z * z;\n      if (m < 2) return [ NaN, NaN ];\n    }\n    return [ Math.atan2(y, x) * d3_degrees, d3_asin(z / Math.sqrt(m)) * d3_degrees ];\n  };\n  var d3_geo_centroidW0, d3_geo_centroidW1, d3_geo_centroidX0, d3_geo_centroidY0, d3_geo_centroidZ0, d3_geo_centroidX1, d3_geo_centroidY1, d3_geo_centroidZ1, d3_geo_centroidX2, d3_geo_centroidY2, d3_geo_centroidZ2;\n  var d3_geo_centroid = {\n    sphere: d3_noop,\n    point: d3_geo_centroidPoint,\n    lineStart: d3_geo_centroidLineStart,\n    lineEnd: d3_geo_centroidLineEnd,\n    polygonStart: function() {\n      d3_geo_centroid.lineStart = d3_geo_centroidRingStart;\n    },\n    polygonEnd: function() {\n      d3_geo_centroid.lineStart = d3_geo_centroidLineStart;\n    }\n  };\n  function d3_geo_centroidPoint(, ) {\n     *= d3_radians;\n    var cos = Math.cos( *= d3_radians);\n    d3_geo_centroidPointXYZ(cos * Math.cos(), cos * Math.sin(), Math.sin());\n  }\n  function d3_geo_centroidPointXYZ(x, y, z) {\n    ++d3_geo_centroidW0;\n    d3_geo_centroidX0 += (x - d3_geo_centroidX0) / d3_geo_centroidW0;\n    d3_geo_centroidY0 += (y - d3_geo_centroidY0) / d3_geo_centroidW0;\n    d3_geo_centroidZ0 += (z - d3_geo_centroidZ0) / d3_geo_centroidW0;\n  }\n  function d3_geo_centroidLineStart() {\n    var x0, y0, z0;\n    d3_geo_centroid.point = function(, ) {\n       *= d3_radians;\n      var cos = Math.cos( *= d3_radians);\n      x0 = cos * Math.cos();\n      y0 = cos * Math.sin();\n      z0 = Math.sin();\n      d3_geo_centroid.point = nextPoint;\n      d3_geo_centroidPointXYZ(x0, y0, z0);\n    };\n    function nextPoint(, ) {\n       *= d3_radians;\n      var cos = Math.cos( *= d3_radians), x = cos * Math.cos(), y = cos * Math.sin(), z = Math.sin(), w = Math.atan2(Math.sqrt((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z);\n      d3_geo_centroidW1 += w;\n      d3_geo_centroidX1 += w * (x0 + (x0 = x));\n      d3_geo_centroidY1 += w * (y0 + (y0 = y));\n      d3_geo_centroidZ1 += w * (z0 + (z0 = z));\n      d3_geo_centroidPointXYZ(x0, y0, z0);\n    }\n  }\n  function d3_geo_centroidLineEnd() {\n    d3_geo_centroid.point = d3_geo_centroidPoint;\n  }\n  function d3_geo_centroidRingStart() {\n    var 00, 00, x0, y0, z0;\n    d3_geo_centroid.point = function(, ) {\n      00 = , 00 = ;\n      d3_geo_centroid.point = nextPoint;\n       *= d3_radians;\n      var cos = Math.cos( *= d3_radians);\n      x0 = cos * Math.cos();\n      y0 = cos * Math.sin();\n      z0 = Math.sin();\n      d3_geo_centroidPointXYZ(x0, y0, z0);\n    };\n    d3_geo_centroid.lineEnd = function() {\n      nextPoint(00, 00);\n      d3_geo_centroid.lineEnd = d3_geo_centroidLineEnd;\n      d3_geo_centroid.point = d3_geo_centroidPoint;\n    };\n    function nextPoint(, ) {\n       *= d3_radians;\n      var cos = Math.cos( *= d3_radians), x = cos * Math.cos(), y = cos * Math.sin(), z = Math.sin(), cx = y0 * z - z0 * y, cy = z0 * x - x0 * z, cz = x0 * y - y0 * x, m = Math.sqrt(cx * cx + cy * cy + cz * cz), u = x0 * x + y0 * y + z0 * z, v = m && -d3_acos(u) / m, w = Math.atan2(m, u);\n      d3_geo_centroidX2 += v * cx;\n      d3_geo_centroidY2 += v * cy;\n      d3_geo_centroidZ2 += v * cz;\n      d3_geo_centroidW1 += w;\n      d3_geo_centroidX1 += w * (x0 + (x0 = x));\n      d3_geo_centroidY1 += w * (y0 + (y0 = y));\n      d3_geo_centroidZ1 += w * (z0 + (z0 = z));\n      d3_geo_centroidPointXYZ(x0, y0, z0);\n    }\n  }\n  function d3_geo_compose(a, b) {\n    function compose(x, y) {\n      return x = a(x, y), b(x[0], x[1]);\n    }\n    if (a.invert && b.invert) compose.invert = function(x, y) {\n      return x = b.invert(x, y), x && a.invert(x[0], x[1]);\n    };\n    return compose;\n  }\n  function d3_true() {\n    return true;\n  }\n  function d3_geo_clipPolygon(segments, compare, clipStartInside, interpolate, listener) {\n    var subject = [], clip = [];\n    segments.forEach(function(segment) {\n      if ((n = segment.length - 1) <= 0) return;\n      var n, p0 = segment[0], p1 = segment[n];\n      if (d3_geo_sphericalEqual(p0, p1)) {\n        listener.lineStart();\n        for (var i = 0; i < n; ++i) listener.point((p0 = segment[i])[0], p0[1]);\n        listener.lineEnd();\n        return;\n      }\n      var a = new d3_geo_clipPolygonIntersection(p0, segment, null, true), b = new d3_geo_clipPolygonIntersection(p0, null, a, false);\n      a.o = b;\n      subject.push(a);\n      clip.push(b);\n      a = new d3_geo_clipPolygonIntersection(p1, segment, null, false);\n      b = new d3_geo_clipPolygonIntersection(p1, null, a, true);\n      a.o = b;\n      subject.push(a);\n      clip.push(b);\n    });\n    clip.sort(compare);\n    d3_geo_clipPolygonLinkCircular(subject);\n    d3_geo_clipPolygonLinkCircular(clip);\n    if (!subject.length) return;\n    for (var i = 0, entry = clipStartInside, n = clip.length; i < n; ++i) {\n      clip[i].e = entry = !entry;\n    }\n    var start = subject[0], points, point;\n    while (1) {\n      var current = start, isSubject = true;\n      while (current.v) if ((current = current.n) === start) return;\n      points = current.z;\n      listener.lineStart();\n      do {\n        current.v = current.o.v = true;\n        if (current.e) {\n          if (isSubject) {\n            for (var i = 0, n = points.length; i < n; ++i) listener.point((point = points[i])[0], point[1]);\n          } else {\n            interpolate(current.x, current.n.x, 1, listener);\n          }\n          current = current.n;\n        } else {\n          if (isSubject) {\n            points = current.p.z;\n            for (var i = points.length - 1; i >= 0; --i) listener.point((point = points[i])[0], point[1]);\n          } else {\n            interpolate(current.x, current.p.x, -1, listener);\n          }\n          current = current.p;\n        }\n        current = current.o;\n        points = current.z;\n        isSubject = !isSubject;\n      } while (!current.v);\n      listener.lineEnd();\n    }\n  }\n  function d3_geo_clipPolygonLinkCircular(array) {\n    if (!(n = array.length)) return;\n    var n, i = 0, a = array[0], b;\n    while (++i < n) {\n      a.n = b = array[i];\n      b.p = a;\n      a = b;\n    }\n    a.n = b = array[0];\n    b.p = a;\n  }\n  function d3_geo_clipPolygonIntersection(point, points, other, entry) {\n    this.x = point;\n    this.z = points;\n    this.o = other;\n    this.e = entry;\n    this.v = false;\n    this.n = this.p = null;\n  }\n  function d3_geo_clip(pointVisible, clipLine, interpolate, clipStart) {\n    return function(rotate, listener) {\n      var line = clipLine(listener), rotatedClipStart = rotate.invert(clipStart[0], clipStart[1]);\n      var clip = {\n        point: point,\n        lineStart: lineStart,\n        lineEnd: lineEnd,\n        polygonStart: function() {\n          clip.point = pointRing;\n          clip.lineStart = ringStart;\n          clip.lineEnd = ringEnd;\n          segments = [];\n          polygon = [];\n        },\n        polygonEnd: function() {\n          clip.point = point;\n          clip.lineStart = lineStart;\n          clip.lineEnd = lineEnd;\n          segments = d3.merge(segments);\n          var clipStartInside = d3_geo_pointInPolygon(rotatedClipStart, polygon);\n          if (segments.length) {\n            if (!polygonStarted) listener.polygonStart(), polygonStarted = true;\n            d3_geo_clipPolygon(segments, d3_geo_clipSort, clipStartInside, interpolate, listener);\n          } else if (clipStartInside) {\n            if (!polygonStarted) listener.polygonStart(), polygonStarted = true;\n            listener.lineStart();\n            interpolate(null, null, 1, listener);\n            listener.lineEnd();\n          }\n          if (polygonStarted) listener.polygonEnd(), polygonStarted = false;\n          segments = polygon = null;\n        },\n        sphere: function() {\n          listener.polygonStart();\n          listener.lineStart();\n          interpolate(null, null, 1, listener);\n          listener.lineEnd();\n          listener.polygonEnd();\n        }\n      };\n      function point(, ) {\n        var point = rotate(, );\n        if (pointVisible( = point[0],  = point[1])) listener.point(, );\n      }\n      function pointLine(, ) {\n        var point = rotate(, );\n        line.point(point[0], point[1]);\n      }\n      function lineStart() {\n        clip.point = pointLine;\n        line.lineStart();\n      }\n      function lineEnd() {\n        clip.point = point;\n        line.lineEnd();\n      }\n      var segments;\n      var buffer = d3_geo_clipBufferListener(), ringListener = clipLine(buffer), polygonStarted = false, polygon, ring;\n      function pointRing(, ) {\n        ring.push([ ,  ]);\n        var point = rotate(, );\n        ringListener.point(point[0], point[1]);\n      }\n      function ringStart() {\n        ringListener.lineStart();\n        ring = [];\n      }\n      function ringEnd() {\n        pointRing(ring[0][0], ring[0][1]);\n        ringListener.lineEnd();\n        var clean = ringListener.clean(), ringSegments = buffer.buffer(), segment, n = ringSegments.length;\n        ring.pop();\n        polygon.push(ring);\n        ring = null;\n        if (!n) return;\n        if (clean & 1) {\n          segment = ringSegments[0];\n          var n = segment.length - 1, i = -1, point;\n          if (n > 0) {\n            if (!polygonStarted) listener.polygonStart(), polygonStarted = true;\n            listener.lineStart();\n            while (++i < n) listener.point((point = segment[i])[0], point[1]);\n            listener.lineEnd();\n          }\n          return;\n        }\n        if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));\n        segments.push(ringSegments.filter(d3_geo_clipSegmentLength1));\n      }\n      return clip;\n    };\n  }\n  function d3_geo_clipSegmentLength1(segment) {\n    return segment.length > 1;\n  }\n  function d3_geo_clipBufferListener() {\n    var lines = [], line;\n    return {\n      lineStart: function() {\n        lines.push(line = []);\n      },\n      point: function(, ) {\n        line.push([ ,  ]);\n      },\n      lineEnd: d3_noop,\n      buffer: function() {\n        var buffer = lines;\n        lines = [];\n        line = null;\n        return buffer;\n      },\n      rejoin: function() {\n        if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));\n      }\n    };\n  }\n  function d3_geo_clipSort(a, b) {\n    return ((a = a.x)[0] < 0 ? a[1] - half -  : half - a[1]) - ((b = b.x)[0] < 0 ? b[1] - half -  : half - b[1]);\n  }\n  var d3_geo_clipAntimeridian = d3_geo_clip(d3_true, d3_geo_clipAntimeridianLine, d3_geo_clipAntimeridianInterpolate, [ -, - / 2 ]);\n  function d3_geo_clipAntimeridianLine(listener) {\n    var 0 = NaN, 0 = NaN, s0 = NaN, clean;\n    return {\n      lineStart: function() {\n        listener.lineStart();\n        clean = 1;\n      },\n      point: function(1, 1) {\n        var s1 = 1 > 0 ?  : -, d = abs(1 - 0);\n        if (abs(d - ) < ) {\n          listener.point(0, 0 = (0 + 1) / 2 > 0 ? half : -half);\n          listener.point(s0, 0);\n          listener.lineEnd();\n          listener.lineStart();\n          listener.point(s1, 0);\n          listener.point(1, 0);\n          clean = 0;\n        } else if (s0 !== s1 && d >= ) {\n          if (abs(0 - s0) < ) 0 -= s0 * ;\n          if (abs(1 - s1) < ) 1 -= s1 * ;\n          0 = d3_geo_clipAntimeridianIntersect(0, 0, 1, 1);\n          listener.point(s0, 0);\n          listener.lineEnd();\n          listener.lineStart();\n          listener.point(s1, 0);\n          clean = 0;\n        }\n        listener.point(0 = 1, 0 = 1);\n        s0 = s1;\n      },\n      lineEnd: function() {\n        listener.lineEnd();\n        0 = 0 = NaN;\n      },\n      clean: function() {\n        return 2 - clean;\n      }\n    };\n  }\n  function d3_geo_clipAntimeridianIntersect(0, 0, 1, 1) {\n    var cos0, cos1, sin0_1 = Math.sin(0 - 1);\n    return abs(sin0_1) >  ? Math.atan((Math.sin(0) * (cos1 = Math.cos(1)) * Math.sin(1) - Math.sin(1) * (cos0 = Math.cos(0)) * Math.sin(0)) / (cos0 * cos1 * sin0_1)) : (0 + 1) / 2;\n  }\n  function d3_geo_clipAntimeridianInterpolate(from, to, direction, listener) {\n    var ;\n    if (from == null) {\n       = direction * half;\n      listener.point(-, );\n      listener.point(0, );\n      listener.point(, );\n      listener.point(, 0);\n      listener.point(, -);\n      listener.point(0, -);\n      listener.point(-, -);\n      listener.point(-, 0);\n      listener.point(-, );\n    } else if (abs(from[0] - to[0]) > ) {\n      var s = from[0] < to[0] ?  : -;\n       = direction * s / 2;\n      listener.point(-s, );\n      listener.point(0, );\n      listener.point(s, );\n    } else {\n      listener.point(to[0], to[1]);\n    }\n  }\n  function d3_geo_pointInPolygon(point, polygon) {\n    var meridian = point[0], parallel = point[1], meridianNormal = [ Math.sin(meridian), -Math.cos(meridian), 0 ], polarAngle = 0, winding = 0;\n    d3_geo_areaRingSum.reset();\n    for (var i = 0, n = polygon.length; i < n; ++i) {\n      var ring = polygon[i], m = ring.length;\n      if (!m) continue;\n      var point0 = ring[0], 0 = point0[0], 0 = point0[1] / 2 +  / 4, sin0 = Math.sin(0), cos0 = Math.cos(0), j = 1;\n      while (true) {\n        if (j === m) j = 0;\n        point = ring[j];\n        var  = point[0],  = point[1] / 2 +  / 4, sin = Math.sin(), cos = Math.cos(), d =  - 0, sd = d >= 0 ? 1 : -1, ad = sd * d, antimeridian = ad > , k = sin0 * sin;\n        d3_geo_areaRingSum.add(Math.atan2(k * sd * Math.sin(ad), cos0 * cos + k * Math.cos(ad)));\n        polarAngle += antimeridian ? d + sd *  : d;\n        if (antimeridian ^ 0 >= meridian ^  >= meridian) {\n          var arc = d3_geo_cartesianCross(d3_geo_cartesian(point0), d3_geo_cartesian(point));\n          d3_geo_cartesianNormalize(arc);\n          var intersection = d3_geo_cartesianCross(meridianNormal, arc);\n          d3_geo_cartesianNormalize(intersection);\n          var arc = (antimeridian ^ d >= 0 ? -1 : 1) * d3_asin(intersection[2]);\n          if (parallel > arc || parallel === arc && (arc[0] || arc[1])) {\n            winding += antimeridian ^ d >= 0 ? 1 : -1;\n          }\n        }\n        if (!j++) break;\n        0 = , sin0 = sin, cos0 = cos, point0 = point;\n      }\n    }\n    return (polarAngle < - || polarAngle <  && d3_geo_areaRingSum < -) ^ winding & 1;\n  }\n  function d3_geo_clipCircle(radius) {\n    var cr = Math.cos(radius), smallRadius = cr > 0, notHemisphere = abs(cr) > , interpolate = d3_geo_circleInterpolate(radius, 6 * d3_radians);\n    return d3_geo_clip(visible, clipLine, interpolate, smallRadius ? [ 0, -radius ] : [ -, radius -  ]);\n    function visible(, ) {\n      return Math.cos() * Math.cos() > cr;\n    }\n    function clipLine(listener) {\n      var point0, c0, v0, v00, clean;\n      return {\n        lineStart: function() {\n          v00 = v0 = false;\n          clean = 1;\n        },\n        point: function(, ) {\n          var point1 = [ ,  ], point2, v = visible(, ), c = smallRadius ? v ? 0 : code(, ) : v ? code( + ( < 0 ?  : -), ) : 0;\n          if (!point0 && (v00 = v0 = v)) listener.lineStart();\n          if (v !== v0) {\n            point2 = intersect(point0, point1);\n            if (d3_geo_sphericalEqual(point0, point2) || d3_geo_sphericalEqual(point1, point2)) {\n              point1[0] += ;\n              point1[1] += ;\n              v = visible(point1[0], point1[1]);\n            }\n          }\n          if (v !== v0) {\n            clean = 0;\n            if (v) {\n              listener.lineStart();\n              point2 = intersect(point1, point0);\n              listener.point(point2[0], point2[1]);\n            } else {\n              point2 = intersect(point0, point1);\n              listener.point(point2[0], point2[1]);\n              listener.lineEnd();\n            }\n            point0 = point2;\n          } else if (notHemisphere && point0 && smallRadius ^ v) {\n            var t;\n            if (!(c & c0) && (t = intersect(point1, point0, true))) {\n              clean = 0;\n              if (smallRadius) {\n                listener.lineStart();\n                listener.point(t[0][0], t[0][1]);\n                listener.point(t[1][0], t[1][1]);\n                listener.lineEnd();\n              } else {\n                listener.point(t[1][0], t[1][1]);\n                listener.lineEnd();\n                listener.lineStart();\n                listener.point(t[0][0], t[0][1]);\n              }\n            }\n          }\n          if (v && (!point0 || !d3_geo_sphericalEqual(point0, point1))) {\n            listener.point(point1[0], point1[1]);\n          }\n          point0 = point1, v0 = v, c0 = c;\n        },\n        lineEnd: function() {\n          if (v0) listener.lineEnd();\n          point0 = null;\n        },\n        clean: function() {\n          return clean | (v00 && v0) << 1;\n        }\n      };\n    }\n    function intersect(a, b, two) {\n      var pa = d3_geo_cartesian(a), pb = d3_geo_cartesian(b);\n      var n1 = [ 1, 0, 0 ], n2 = d3_geo_cartesianCross(pa, pb), n2n2 = d3_geo_cartesianDot(n2, n2), n1n2 = n2[0], determinant = n2n2 - n1n2 * n1n2;\n      if (!determinant) return !two && a;\n      var c1 = cr * n2n2 / determinant, c2 = -cr * n1n2 / determinant, n1xn2 = d3_geo_cartesianCross(n1, n2), A = d3_geo_cartesianScale(n1, c1), B = d3_geo_cartesianScale(n2, c2);\n      d3_geo_cartesianAdd(A, B);\n      var u = n1xn2, w = d3_geo_cartesianDot(A, u), uu = d3_geo_cartesianDot(u, u), t2 = w * w - uu * (d3_geo_cartesianDot(A, A) - 1);\n      if (t2 < 0) return;\n      var t = Math.sqrt(t2), q = d3_geo_cartesianScale(u, (-w - t) / uu);\n      d3_geo_cartesianAdd(q, A);\n      q = d3_geo_spherical(q);\n      if (!two) return q;\n      var 0 = a[0], 1 = b[0], 0 = a[1], 1 = b[1], z;\n      if (1 < 0) z = 0, 0 = 1, 1 = z;\n      var  = 1 - 0, polar = abs( - ) < , meridian = polar ||  < ;\n      if (!polar && 1 < 0) z = 0, 0 = 1, 1 = z;\n      if (meridian ? polar ? 0 + 1 > 0 ^ q[1] < (abs(q[0] - 0) <  ? 0 : 1) : 0 <= q[1] && q[1] <= 1 :  >  ^ (0 <= q[0] && q[0] <= 1)) {\n        var q1 = d3_geo_cartesianScale(u, (-w + t) / uu);\n        d3_geo_cartesianAdd(q1, A);\n        return [ q, d3_geo_spherical(q1) ];\n      }\n    }\n    function code(, ) {\n      var r = smallRadius ? radius :  - radius, code = 0;\n      if ( < -r) code |= 1; else if ( > r) code |= 2;\n      if ( < -r) code |= 4; else if ( > r) code |= 8;\n      return code;\n    }\n  }\n  function d3_geom_clipLine(x0, y0, x1, y1) {\n    return function(line) {\n      var a = line.a, b = line.b, ax = a.x, ay = a.y, bx = b.x, by = b.y, t0 = 0, t1 = 1, dx = bx - ax, dy = by - ay, r;\n      r = x0 - ax;\n      if (!dx && r > 0) return;\n      r /= dx;\n      if (dx < 0) {\n        if (r < t0) return;\n        if (r < t1) t1 = r;\n      } else if (dx > 0) {\n        if (r > t1) return;\n        if (r > t0) t0 = r;\n      }\n      r = x1 - ax;\n      if (!dx && r < 0) return;\n      r /= dx;\n      if (dx < 0) {\n        if (r > t1) return;\n        if (r > t0) t0 = r;\n      } else if (dx > 0) {\n        if (r < t0) return;\n        if (r < t1) t1 = r;\n      }\n      r = y0 - ay;\n      if (!dy && r > 0) return;\n      r /= dy;\n      if (dy < 0) {\n        if (r < t0) return;\n        if (r < t1) t1 = r;\n      } else if (dy > 0) {\n        if (r > t1) return;\n        if (r > t0) t0 = r;\n      }\n      r = y1 - ay;\n      if (!dy && r < 0) return;\n      r /= dy;\n      if (dy < 0) {\n        if (r > t1) return;\n        if (r > t0) t0 = r;\n      } else if (dy > 0) {\n        if (r < t0) return;\n        if (r < t1) t1 = r;\n      }\n      if (t0 > 0) line.a = {\n        x: ax + t0 * dx,\n        y: ay + t0 * dy\n      };\n      if (t1 < 1) line.b = {\n        x: ax + t1 * dx,\n        y: ay + t1 * dy\n      };\n      return line;\n    };\n  }\n  var d3_geo_clipExtentMAX = 1e9;\n  d3.geo.clipExtent = function() {\n    var x0, y0, x1, y1, stream, clip, clipExtent = {\n      stream: function(output) {\n        if (stream) stream.valid = false;\n        stream = clip(output);\n        stream.valid = true;\n        return stream;\n      },\n      extent: function(_) {\n        if (!arguments.length) return [ [ x0, y0 ], [ x1, y1 ] ];\n        clip = d3_geo_clipExtent(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]);\n        if (stream) stream.valid = false, stream = null;\n        return clipExtent;\n      }\n    };\n    return clipExtent.extent([ [ 0, 0 ], [ 960, 500 ] ]);\n  };\n  function d3_geo_clipExtent(x0, y0, x1, y1) {\n    return function(listener) {\n      var listener_ = listener, bufferListener = d3_geo_clipBufferListener(), clipLine = d3_geom_clipLine(x0, y0, x1, y1), segments, polygon, ring;\n      var clip = {\n        point: point,\n        lineStart: lineStart,\n        lineEnd: lineEnd,\n        polygonStart: function() {\n          listener = bufferListener;\n          segments = [];\n          polygon = [];\n          clean = true;\n        },\n        polygonEnd: function() {\n          listener = listener_;\n          segments = d3.merge(segments);\n          var clipStartInside = insidePolygon([ x0, y1 ]), inside = clean && clipStartInside, visible = segments.length;\n          if (inside || visible) {\n            listener.polygonStart();\n            if (inside) {\n              listener.lineStart();\n              interpolate(null, null, 1, listener);\n              listener.lineEnd();\n            }\n            if (visible) {\n              d3_geo_clipPolygon(segments, compare, clipStartInside, interpolate, listener);\n            }\n            listener.polygonEnd();\n          }\n          segments = polygon = ring = null;\n        }\n      };\n      function insidePolygon(p) {\n        var wn = 0, n = polygon.length, y = p[1];\n        for (var i = 0; i < n; ++i) {\n          for (var j = 1, v = polygon[i], m = v.length, a = v[0], b; j < m; ++j) {\n            b = v[j];\n            if (a[1] <= y) {\n              if (b[1] > y && d3_cross2d(a, b, p) > 0) ++wn;\n            } else {\n              if (b[1] <= y && d3_cross2d(a, b, p) < 0) --wn;\n            }\n            a = b;\n          }\n        }\n        return wn !== 0;\n      }\n      function interpolate(from, to, direction, listener) {\n        var a = 0, a1 = 0;\n        if (from == null || (a = corner(from, direction)) !== (a1 = corner(to, direction)) || comparePoints(from, to) < 0 ^ direction > 0) {\n          do {\n            listener.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0);\n          } while ((a = (a + direction + 4) % 4) !== a1);\n        } else {\n          listener.point(to[0], to[1]);\n        }\n      }\n      function pointVisible(x, y) {\n        return x0 <= x && x <= x1 && y0 <= y && y <= y1;\n      }\n      function point(x, y) {\n        if (pointVisible(x, y)) listener.point(x, y);\n      }\n      var x__, y__, v__, x_, y_, v_, first, clean;\n      function lineStart() {\n        clip.point = linePoint;\n        if (polygon) polygon.push(ring = []);\n        first = true;\n        v_ = false;\n        x_ = y_ = NaN;\n      }\n      function lineEnd() {\n        if (segments) {\n          linePoint(x__, y__);\n          if (v__ && v_) bufferListener.rejoin();\n          segments.push(bufferListener.buffer());\n        }\n        clip.point = point;\n        if (v_) listener.lineEnd();\n      }\n      function linePoint(x, y) {\n        x = Math.max(-d3_geo_clipExtentMAX, Math.min(d3_geo_clipExtentMAX, x));\n        y = Math.max(-d3_geo_clipExtentMAX, Math.min(d3_geo_clipExtentMAX, y));\n        var v = pointVisible(x, y);\n        if (polygon) ring.push([ x, y ]);\n        if (first) {\n          x__ = x, y__ = y, v__ = v;\n          first = false;\n          if (v) {\n            listener.lineStart();\n            listener.point(x, y);\n          }\n        } else {\n          if (v && v_) listener.point(x, y); else {\n            var l = {\n              a: {\n                x: x_,\n                y: y_\n              },\n              b: {\n                x: x,\n                y: y\n              }\n            };\n            if (clipLine(l)) {\n              if (!v_) {\n                listener.lineStart();\n                listener.point(l.a.x, l.a.y);\n              }\n              listener.point(l.b.x, l.b.y);\n              if (!v) listener.lineEnd();\n              clean = false;\n            } else if (v) {\n              listener.lineStart();\n              listener.point(x, y);\n              clean = false;\n            }\n          }\n        }\n        x_ = x, y_ = y, v_ = v;\n      }\n      return clip;\n    };\n    function corner(p, direction) {\n      return abs(p[0] - x0) <  ? direction > 0 ? 0 : 3 : abs(p[0] - x1) <  ? direction > 0 ? 2 : 1 : abs(p[1] - y0) <  ? direction > 0 ? 1 : 0 : direction > 0 ? 3 : 2;\n    }\n    function compare(a, b) {\n      return comparePoints(a.x, b.x);\n    }\n    function comparePoints(a, b) {\n      var ca = corner(a, 1), cb = corner(b, 1);\n      return ca !== cb ? ca - cb : ca === 0 ? b[1] - a[1] : ca === 1 ? a[0] - b[0] : ca === 2 ? a[1] - b[1] : b[0] - a[0];\n    }\n  }\n  function d3_geo_conic(projectAt) {\n    var 0 = 0, 1 =  / 3, m = d3_geo_projectionMutator(projectAt), p = m(0, 1);\n    p.parallels = function(_) {\n      if (!arguments.length) return [ 0 /  * 180, 1 /  * 180 ];\n      return m(0 = _[0] *  / 180, 1 = _[1] *  / 180);\n    };\n    return p;\n  }\n  function d3_geo_conicEqualArea(0, 1) {\n    var sin0 = Math.sin(0), n = (sin0 + Math.sin(1)) / 2, C = 1 + sin0 * (2 * n - sin0), 0 = Math.sqrt(C) / n;\n    function forward(, ) {\n      var  = Math.sqrt(C - 2 * n * Math.sin()) / n;\n      return [  * Math.sin( *= n), 0 -  * Math.cos() ];\n    }\n    forward.invert = function(x, y) {\n      var 0_y = 0 - y;\n      return [ Math.atan2(x, 0_y) / n, d3_asin((C - (x * x + 0_y * 0_y) * n * n) / (2 * n)) ];\n    };\n    return forward;\n  }\n  (d3.geo.conicEqualArea = function() {\n    return d3_geo_conic(d3_geo_conicEqualArea);\n  }).raw = d3_geo_conicEqualArea;\n  d3.geo.albers = function() {\n    return d3.geo.conicEqualArea().rotate([ 96, 0 ]).center([ -.6, 38.7 ]).parallels([ 29.5, 45.5 ]).scale(1070);\n  };\n  d3.geo.albersUsa = function() {\n    var lower48 = d3.geo.albers();\n    var alaska = d3.geo.conicEqualArea().rotate([ 154, 0 ]).center([ -2, 58.5 ]).parallels([ 55, 65 ]);\n    var hawaii = d3.geo.conicEqualArea().rotate([ 157, 0 ]).center([ -3, 19.9 ]).parallels([ 8, 18 ]);\n    var point, pointStream = {\n      point: function(x, y) {\n        point = [ x, y ];\n      }\n    }, lower48Point, alaskaPoint, hawaiiPoint;\n    function albersUsa(coordinates) {\n      var x = coordinates[0], y = coordinates[1];\n      point = null;\n      (lower48Point(x, y), point) || (alaskaPoint(x, y), point) || hawaiiPoint(x, y);\n      return point;\n    }\n    albersUsa.invert = function(coordinates) {\n      var k = lower48.scale(), t = lower48.translate(), x = (coordinates[0] - t[0]) / k, y = (coordinates[1] - t[1]) / k;\n      return (y >= .12 && y < .234 && x >= -.425 && x < -.214 ? alaska : y >= .166 && y < .234 && x >= -.214 && x < -.115 ? hawaii : lower48).invert(coordinates);\n    };\n    albersUsa.stream = function(stream) {\n      var lower48Stream = lower48.stream(stream), alaskaStream = alaska.stream(stream), hawaiiStream = hawaii.stream(stream);\n      return {\n        point: function(x, y) {\n          lower48Stream.point(x, y);\n          alaskaStream.point(x, y);\n          hawaiiStream.point(x, y);\n        },\n        sphere: function() {\n          lower48Stream.sphere();\n          alaskaStream.sphere();\n          hawaiiStream.sphere();\n        },\n        lineStart: function() {\n          lower48Stream.lineStart();\n          alaskaStream.lineStart();\n          hawaiiStream.lineStart();\n        },\n        lineEnd: function() {\n          lower48Stream.lineEnd();\n          alaskaStream.lineEnd();\n          hawaiiStream.lineEnd();\n        },\n        polygonStart: function() {\n          lower48Stream.polygonStart();\n          alaskaStream.polygonStart();\n          hawaiiStream.polygonStart();\n        },\n        polygonEnd: function() {\n          lower48Stream.polygonEnd();\n          alaskaStream.polygonEnd();\n          hawaiiStream.polygonEnd();\n        }\n      };\n    };\n    albersUsa.precision = function(_) {\n      if (!arguments.length) return lower48.precision();\n      lower48.precision(_);\n      alaska.precision(_);\n      hawaii.precision(_);\n      return albersUsa;\n    };\n    albersUsa.scale = function(_) {\n      if (!arguments.length) return lower48.scale();\n      lower48.scale(_);\n      alaska.scale(_ * .35);\n      hawaii.scale(_);\n      return albersUsa.translate(lower48.translate());\n    };\n    albersUsa.translate = function(_) {\n      if (!arguments.length) return lower48.translate();\n      var k = lower48.scale(), x = +_[0], y = +_[1];\n      lower48Point = lower48.translate(_).clipExtent([ [ x - .455 * k, y - .238 * k ], [ x + .455 * k, y + .238 * k ] ]).stream(pointStream).point;\n      alaskaPoint = alaska.translate([ x - .307 * k, y + .201 * k ]).clipExtent([ [ x - .425 * k + , y + .12 * k +  ], [ x - .214 * k - , y + .234 * k -  ] ]).stream(pointStream).point;\n      hawaiiPoint = hawaii.translate([ x - .205 * k, y + .212 * k ]).clipExtent([ [ x - .214 * k + , y + .166 * k +  ], [ x - .115 * k - , y + .234 * k -  ] ]).stream(pointStream).point;\n      return albersUsa;\n    };\n    return albersUsa.scale(1070);\n  };\n  var d3_geo_pathAreaSum, d3_geo_pathAreaPolygon, d3_geo_pathArea = {\n    point: d3_noop,\n    lineStart: d3_noop,\n    lineEnd: d3_noop,\n    polygonStart: function() {\n      d3_geo_pathAreaPolygon = 0;\n      d3_geo_pathArea.lineStart = d3_geo_pathAreaRingStart;\n    },\n    polygonEnd: function() {\n      d3_geo_pathArea.lineStart = d3_geo_pathArea.lineEnd = d3_geo_pathArea.point = d3_noop;\n      d3_geo_pathAreaSum += abs(d3_geo_pathAreaPolygon / 2);\n    }\n  };\n  function d3_geo_pathAreaRingStart() {\n    var x00, y00, x0, y0;\n    d3_geo_pathArea.point = function(x, y) {\n      d3_geo_pathArea.point = nextPoint;\n      x00 = x0 = x, y00 = y0 = y;\n    };\n    function nextPoint(x, y) {\n      d3_geo_pathAreaPolygon += y0 * x - x0 * y;\n      x0 = x, y0 = y;\n    }\n    d3_geo_pathArea.lineEnd = function() {\n      nextPoint(x00, y00);\n    };\n  }\n  var d3_geo_pathBoundsX0, d3_geo_pathBoundsY0, d3_geo_pathBoundsX1, d3_geo_pathBoundsY1;\n  var d3_geo_pathBounds = {\n    point: d3_geo_pathBoundsPoint,\n    lineStart: d3_noop,\n    lineEnd: d3_noop,\n    polygonStart: d3_noop,\n    polygonEnd: d3_noop\n  };\n  function d3_geo_pathBoundsPoint(x, y) {\n    if (x < d3_geo_pathBoundsX0) d3_geo_pathBoundsX0 = x;\n    if (x > d3_geo_pathBoundsX1) d3_geo_pathBoundsX1 = x;\n    if (y < d3_geo_pathBoundsY0) d3_geo_pathBoundsY0 = y;\n    if (y > d3_geo_pathBoundsY1) d3_geo_pathBoundsY1 = y;\n  }\n  function d3_geo_pathBuffer() {\n    var pointCircle = d3_geo_pathBufferCircle(4.5), buffer = [];\n    var stream = {\n      point: point,\n      lineStart: function() {\n        stream.point = pointLineStart;\n      },\n      lineEnd: lineEnd,\n      polygonStart: function() {\n        stream.lineEnd = lineEndPolygon;\n      },\n      polygonEnd: function() {\n        stream.lineEnd = lineEnd;\n        stream.point = point;\n      },\n      pointRadius: function(_) {\n        pointCircle = d3_geo_pathBufferCircle(_);\n        return stream;\n      },\n      result: function() {\n        if (buffer.length) {\n          var result = buffer.join(\"\");\n          buffer = [];\n          return result;\n        }\n      }\n    };\n    function point(x, y) {\n      buffer.push(\"M\", x, \",\", y, pointCircle);\n    }\n    function pointLineStart(x, y) {\n      buffer.push(\"M\", x, \",\", y);\n      stream.point = pointLine;\n    }\n    function pointLine(x, y) {\n      buffer.push(\"L\", x, \",\", y);\n    }\n    function lineEnd() {\n      stream.point = point;\n    }\n    function lineEndPolygon() {\n      buffer.push(\"Z\");\n    }\n    return stream;\n  }\n  function d3_geo_pathBufferCircle(radius) {\n    return \"m0,\" + radius + \"a\" + radius + \",\" + radius + \" 0 1,1 0,\" + -2 * radius + \"a\" + radius + \",\" + radius + \" 0 1,1 0,\" + 2 * radius + \"z\";\n  }\n  var d3_geo_pathCentroid = {\n    point: d3_geo_pathCentroidPoint,\n    lineStart: d3_geo_pathCentroidLineStart,\n    lineEnd: d3_geo_pathCentroidLineEnd,\n    polygonStart: function() {\n      d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidRingStart;\n    },\n    polygonEnd: function() {\n      d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint;\n      d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidLineStart;\n      d3_geo_pathCentroid.lineEnd = d3_geo_pathCentroidLineEnd;\n    }\n  };\n  function d3_geo_pathCentroidPoint(x, y) {\n    d3_geo_centroidX0 += x;\n    d3_geo_centroidY0 += y;\n    ++d3_geo_centroidZ0;\n  }\n  function d3_geo_pathCentroidLineStart() {\n    var x0, y0;\n    d3_geo_pathCentroid.point = function(x, y) {\n      d3_geo_pathCentroid.point = nextPoint;\n      d3_geo_pathCentroidPoint(x0 = x, y0 = y);\n    };\n    function nextPoint(x, y) {\n      var dx = x - x0, dy = y - y0, z = Math.sqrt(dx * dx + dy * dy);\n      d3_geo_centroidX1 += z * (x0 + x) / 2;\n      d3_geo_centroidY1 += z * (y0 + y) / 2;\n      d3_geo_centroidZ1 += z;\n      d3_geo_pathCentroidPoint(x0 = x, y0 = y);\n    }\n  }\n  function d3_geo_pathCentroidLineEnd() {\n    d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint;\n  }\n  function d3_geo_pathCentroidRingStart() {\n    var x00, y00, x0, y0;\n    d3_geo_pathCentroid.point = function(x, y) {\n      d3_geo_pathCentroid.point = nextPoint;\n      d3_geo_pathCentroidPoint(x00 = x0 = x, y00 = y0 = y);\n    };\n    function nextPoint(x, y) {\n      var dx = x - x0, dy = y - y0, z = Math.sqrt(dx * dx + dy * dy);\n      d3_geo_centroidX1 += z * (x0 + x) / 2;\n      d3_geo_centroidY1 += z * (y0 + y) / 2;\n      d3_geo_centroidZ1 += z;\n      z = y0 * x - x0 * y;\n      d3_geo_centroidX2 += z * (x0 + x);\n      d3_geo_centroidY2 += z * (y0 + y);\n      d3_geo_centroidZ2 += z * 3;\n      d3_geo_pathCentroidPoint(x0 = x, y0 = y);\n    }\n    d3_geo_pathCentroid.lineEnd = function() {\n      nextPoint(x00, y00);\n    };\n  }\n  function d3_geo_pathContext(context) {\n    var pointRadius = 4.5;\n    var stream = {\n      point: point,\n      lineStart: function() {\n        stream.point = pointLineStart;\n      },\n      lineEnd: lineEnd,\n      polygonStart: function() {\n        stream.lineEnd = lineEndPolygon;\n      },\n      polygonEnd: function() {\n        stream.lineEnd = lineEnd;\n        stream.point = point;\n      },\n      pointRadius: function(_) {\n        pointRadius = _;\n        return stream;\n      },\n      result: d3_noop\n    };\n    function point(x, y) {\n      context.moveTo(x + pointRadius, y);\n      context.arc(x, y, pointRadius, 0, );\n    }\n    function pointLineStart(x, y) {\n      context.moveTo(x, y);\n      stream.point = pointLine;\n    }\n    function pointLine(x, y) {\n      context.lineTo(x, y);\n    }\n    function lineEnd() {\n      stream.point = point;\n    }\n    function lineEndPolygon() {\n      context.closePath();\n    }\n    return stream;\n  }\n  function d3_geo_resample(project) {\n    var 2 = .5, cosMinDistance = Math.cos(30 * d3_radians), maxDepth = 16;\n    function resample(stream) {\n      return (maxDepth ? resampleRecursive : resampleNone)(stream);\n    }\n    function resampleNone(stream) {\n      return d3_geo_transformPoint(stream, function(x, y) {\n        x = project(x, y);\n        stream.point(x[0], x[1]);\n      });\n    }\n    function resampleRecursive(stream) {\n      var 00, 00, x00, y00, a00, b00, c00, 0, x0, y0, a0, b0, c0;\n      var resample = {\n        point: point,\n        lineStart: lineStart,\n        lineEnd: lineEnd,\n        polygonStart: function() {\n          stream.polygonStart();\n          resample.lineStart = ringStart;\n        },\n        polygonEnd: function() {\n          stream.polygonEnd();\n          resample.lineStart = lineStart;\n        }\n      };\n      function point(x, y) {\n        x = project(x, y);\n        stream.point(x[0], x[1]);\n      }\n      function lineStart() {\n        x0 = NaN;\n        resample.point = linePoint;\n        stream.lineStart();\n      }\n      function linePoint(, ) {\n        var c = d3_geo_cartesian([ ,  ]), p = project(, );\n        resampleLineTo(x0, y0, 0, a0, b0, c0, x0 = p[0], y0 = p[1], 0 = , a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);\n        stream.point(x0, y0);\n      }\n      function lineEnd() {\n        resample.point = point;\n        stream.lineEnd();\n      }\n      function ringStart() {\n        lineStart();\n        resample.point = ringPoint;\n        resample.lineEnd = ringEnd;\n      }\n      function ringPoint(, ) {\n        linePoint(00 = , 00 = ), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;\n        resample.point = linePoint;\n      }\n      function ringEnd() {\n        resampleLineTo(x0, y0, 0, a0, b0, c0, x00, y00, 00, a00, b00, c00, maxDepth, stream);\n        resample.lineEnd = lineEnd;\n        lineEnd();\n      }\n      return resample;\n    }\n    function resampleLineTo(x0, y0, 0, a0, b0, c0, x1, y1, 1, a1, b1, c1, depth, stream) {\n      var dx = x1 - x0, dy = y1 - y0, d2 = dx * dx + dy * dy;\n      if (d2 > 4 * 2 && depth--) {\n        var a = a0 + a1, b = b0 + b1, c = c0 + c1, m = Math.sqrt(a * a + b * b + c * c), 2 = Math.asin(c /= m), 2 = abs(abs(c) - 1) <  || abs(0 - 1) <  ? (0 + 1) / 2 : Math.atan2(b, a), p = project(2, 2), x2 = p[0], y2 = p[1], dx2 = x2 - x0, dy2 = y2 - y0, dz = dy * dx2 - dx * dy2;\n        if (dz * dz / d2 > 2 || abs((dx * dx2 + dy * dy2) / d2 - .5) > .3 || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) {\n          resampleLineTo(x0, y0, 0, a0, b0, c0, x2, y2, 2, a /= m, b /= m, c, depth, stream);\n          stream.point(x2, y2);\n          resampleLineTo(x2, y2, 2, a, b, c, x1, y1, 1, a1, b1, c1, depth, stream);\n        }\n      }\n    }\n    resample.precision = function(_) {\n      if (!arguments.length) return Math.sqrt(2);\n      maxDepth = (2 = _ * _) > 0 && 16;\n      return resample;\n    };\n    return resample;\n  }\n  d3.geo.path = function() {\n    var pointRadius = 4.5, projection, context, projectStream, contextStream, cacheStream;\n    function path(object) {\n      if (object) {\n        if (typeof pointRadius === \"function\") contextStream.pointRadius(+pointRadius.apply(this, arguments));\n        if (!cacheStream || !cacheStream.valid) cacheStream = projectStream(contextStream);\n        d3.geo.stream(object, cacheStream);\n      }\n      return contextStream.result();\n    }\n    path.area = function(object) {\n      d3_geo_pathAreaSum = 0;\n      d3.geo.stream(object, projectStream(d3_geo_pathArea));\n      return d3_geo_pathAreaSum;\n    };\n    path.centroid = function(object) {\n      d3_geo_centroidX0 = d3_geo_centroidY0 = d3_geo_centroidZ0 = d3_geo_centroidX1 = d3_geo_centroidY1 = d3_geo_centroidZ1 = d3_geo_centroidX2 = d3_geo_centroidY2 = d3_geo_centroidZ2 = 0;\n      d3.geo.stream(object, projectStream(d3_geo_pathCentroid));\n      return d3_geo_centroidZ2 ? [ d3_geo_centroidX2 / d3_geo_centroidZ2, d3_geo_centroidY2 / d3_geo_centroidZ2 ] : d3_geo_centroidZ1 ? [ d3_geo_centroidX1 / d3_geo_centroidZ1, d3_geo_centroidY1 / d3_geo_centroidZ1 ] : d3_geo_centroidZ0 ? [ d3_geo_centroidX0 / d3_geo_centroidZ0, d3_geo_centroidY0 / d3_geo_centroidZ0 ] : [ NaN, NaN ];\n    };\n    path.bounds = function(object) {\n      d3_geo_pathBoundsX1 = d3_geo_pathBoundsY1 = -(d3_geo_pathBoundsX0 = d3_geo_pathBoundsY0 = Infinity);\n      d3.geo.stream(object, projectStream(d3_geo_pathBounds));\n      return [ [ d3_geo_pathBoundsX0, d3_geo_pathBoundsY0 ], [ d3_geo_pathBoundsX1, d3_geo_pathBoundsY1 ] ];\n    };\n    path.projection = function(_) {\n      if (!arguments.length) return projection;\n      projectStream = (projection = _) ? _.stream || d3_geo_pathProjectStream(_) : d3_identity;\n      return reset();\n    };\n    path.context = function(_) {\n      if (!arguments.length) return context;\n      contextStream = (context = _) == null ? new d3_geo_pathBuffer() : new d3_geo_pathContext(_);\n      if (typeof pointRadius !== \"function\") contextStream.pointRadius(pointRadius);\n      return reset();\n    };\n    path.pointRadius = function(_) {\n      if (!arguments.length) return pointRadius;\n      pointRadius = typeof _ === \"function\" ? _ : (contextStream.pointRadius(+_), +_);\n      return path;\n    };\n    function reset() {\n      cacheStream = null;\n      return path;\n    }\n    return path.projection(d3.geo.albersUsa()).context(null);\n  };\n  function d3_geo_pathProjectStream(project) {\n    var resample = d3_geo_resample(function(x, y) {\n      return project([ x * d3_degrees, y * d3_degrees ]);\n    });\n    return function(stream) {\n      return d3_geo_projectionRadians(resample(stream));\n    };\n  }\n  d3.geo.transform = function(methods) {\n    return {\n      stream: function(stream) {\n        var transform = new d3_geo_transform(stream);\n        for (var k in methods) transform[k] = methods[k];\n        return transform;\n      }\n    };\n  };\n  function d3_geo_transform(stream) {\n    this.stream = stream;\n  }\n  d3_geo_transform.prototype = {\n    point: function(x, y) {\n      this.stream.point(x, y);\n    },\n    sphere: function() {\n      this.stream.sphere();\n    },\n    lineStart: function() {\n      this.stream.lineStart();\n    },\n    lineEnd: function() {\n      this.stream.lineEnd();\n    },\n    polygonStart: function() {\n      this.stream.polygonStart();\n    },\n    polygonEnd: function() {\n      this.stream.polygonEnd();\n    }\n  };\n  function d3_geo_transformPoint(stream, point) {\n    return {\n      point: point,\n      sphere: function() {\n        stream.sphere();\n      },\n      lineStart: function() {\n        stream.lineStart();\n      },\n      lineEnd: function() {\n        stream.lineEnd();\n      },\n      polygonStart: function() {\n        stream.polygonStart();\n      },\n      polygonEnd: function() {\n        stream.polygonEnd();\n      }\n    };\n  }\n  d3.geo.projection = d3_geo_projection;\n  d3.geo.projectionMutator = d3_geo_projectionMutator;\n  function d3_geo_projection(project) {\n    return d3_geo_projectionMutator(function() {\n      return project;\n    })();\n  }\n  function d3_geo_projectionMutator(projectAt) {\n    var project, rotate, projectRotate, projectResample = d3_geo_resample(function(x, y) {\n      x = project(x, y);\n      return [ x[0] * k + x, y - x[1] * k ];\n    }), k = 150, x = 480, y = 250,  = 0,  = 0,  = 0,  = 0,  = 0, x, y, preclip = d3_geo_clipAntimeridian, postclip = d3_identity, clipAngle = null, clipExtent = null, stream;\n    function projection(point) {\n      point = projectRotate(point[0] * d3_radians, point[1] * d3_radians);\n      return [ point[0] * k + x, y - point[1] * k ];\n    }\n    function invert(point) {\n      point = projectRotate.invert((point[0] - x) / k, (y - point[1]) / k);\n      return point && [ point[0] * d3_degrees, point[1] * d3_degrees ];\n    }\n    projection.stream = function(output) {\n      if (stream) stream.valid = false;\n      stream = d3_geo_projectionRadians(preclip(rotate, projectResample(postclip(output))));\n      stream.valid = true;\n      return stream;\n    };\n    projection.clipAngle = function(_) {\n      if (!arguments.length) return clipAngle;\n      preclip = _ == null ? (clipAngle = _, d3_geo_clipAntimeridian) : d3_geo_clipCircle((clipAngle = +_) * d3_radians);\n      return invalidate();\n    };\n    projection.clipExtent = function(_) {\n      if (!arguments.length) return clipExtent;\n      clipExtent = _;\n      postclip = _ ? d3_geo_clipExtent(_[0][0], _[0][1], _[1][0], _[1][1]) : d3_identity;\n      return invalidate();\n    };\n    projection.scale = function(_) {\n      if (!arguments.length) return k;\n      k = +_;\n      return reset();\n    };\n    projection.translate = function(_) {\n      if (!arguments.length) return [ x, y ];\n      x = +_[0];\n      y = +_[1];\n      return reset();\n    };\n    projection.center = function(_) {\n      if (!arguments.length) return [  * d3_degrees,  * d3_degrees ];\n       = _[0] % 360 * d3_radians;\n       = _[1] % 360 * d3_radians;\n      return reset();\n    };\n    projection.rotate = function(_) {\n      if (!arguments.length) return [  * d3_degrees,  * d3_degrees,  * d3_degrees ];\n       = _[0] % 360 * d3_radians;\n       = _[1] % 360 * d3_radians;\n       = _.length > 2 ? _[2] % 360 * d3_radians : 0;\n      return reset();\n    };\n    d3.rebind(projection, projectResample, \"precision\");\n    function reset() {\n      projectRotate = d3_geo_compose(rotate = d3_geo_rotation(, , ), project);\n      var center = project(, );\n      x = x - center[0] * k;\n      y = y + center[1] * k;\n      return invalidate();\n    }\n    function invalidate() {\n      if (stream) stream.valid = false, stream = null;\n      return projection;\n    }\n    return function() {\n      project = projectAt.apply(this, arguments);\n      projection.invert = project.invert && invert;\n      return reset();\n    };\n  }\n  function d3_geo_projectionRadians(stream) {\n    return d3_geo_transformPoint(stream, function(x, y) {\n      stream.point(x * d3_radians, y * d3_radians);\n    });\n  }\n  function d3_geo_equirectangular(, ) {\n    return [ ,  ];\n  }\n  (d3.geo.equirectangular = function() {\n    return d3_geo_projection(d3_geo_equirectangular);\n  }).raw = d3_geo_equirectangular.invert = d3_geo_equirectangular;\n  d3.geo.rotation = function(rotate) {\n    rotate = d3_geo_rotation(rotate[0] % 360 * d3_radians, rotate[1] * d3_radians, rotate.length > 2 ? rotate[2] * d3_radians : 0);\n    function forward(coordinates) {\n      coordinates = rotate(coordinates[0] * d3_radians, coordinates[1] * d3_radians);\n      return coordinates[0] *= d3_degrees, coordinates[1] *= d3_degrees, coordinates;\n    }\n    forward.invert = function(coordinates) {\n      coordinates = rotate.invert(coordinates[0] * d3_radians, coordinates[1] * d3_radians);\n      return coordinates[0] *= d3_degrees, coordinates[1] *= d3_degrees, coordinates;\n    };\n    return forward;\n  };\n  function d3_geo_identityRotation(, ) {\n    return [  >  ?  -  :  < - ?  +  : ,  ];\n  }\n  d3_geo_identityRotation.invert = d3_geo_equirectangular;\n  function d3_geo_rotation(, , ) {\n    return  ?  ||  ? d3_geo_compose(d3_geo_rotation(), d3_geo_rotation(, )) : d3_geo_rotation() :  ||  ? d3_geo_rotation(, ) : d3_geo_identityRotation;\n  }\n  function d3_geo_forwardRotation() {\n    return function(, ) {\n      return  += , [  >  ?  -  :  < - ?  +  : ,  ];\n    };\n  }\n  function d3_geo_rotation() {\n    var rotation = d3_geo_forwardRotation();\n    rotation.invert = d3_geo_forwardRotation(-);\n    return rotation;\n  }\n  function d3_geo_rotation(, ) {\n    var cos = Math.cos(), sin = Math.sin(), cos = Math.cos(), sin = Math.sin();\n    function rotation(, ) {\n      var cos = Math.cos(), x = Math.cos() * cos, y = Math.sin() * cos, z = Math.sin(), k = z * cos + x * sin;\n      return [ Math.atan2(y * cos - k * sin, x * cos - z * sin), d3_asin(k * cos + y * sin) ];\n    }\n    rotation.invert = function(, ) {\n      var cos = Math.cos(), x = Math.cos() * cos, y = Math.sin() * cos, z = Math.sin(), k = z * cos - y * sin;\n      return [ Math.atan2(y * cos + z * sin, x * cos + k * sin), d3_asin(k * cos - x * sin) ];\n    };\n    return rotation;\n  }\n  d3.geo.circle = function() {\n    var origin = [ 0, 0 ], angle, precision = 6, interpolate;\n    function circle() {\n      var center = typeof origin === \"function\" ? origin.apply(this, arguments) : origin, rotate = d3_geo_rotation(-center[0] * d3_radians, -center[1] * d3_radians, 0).invert, ring = [];\n      interpolate(null, null, 1, {\n        point: function(x, y) {\n          ring.push(x = rotate(x, y));\n          x[0] *= d3_degrees, x[1] *= d3_degrees;\n        }\n      });\n      return {\n        type: \"Polygon\",\n        coordinates: [ ring ]\n      };\n    }\n    circle.origin = function(x) {\n      if (!arguments.length) return origin;\n      origin = x;\n      return circle;\n    };\n    circle.angle = function(x) {\n      if (!arguments.length) return angle;\n      interpolate = d3_geo_circleInterpolate((angle = +x) * d3_radians, precision * d3_radians);\n      return circle;\n    };\n    circle.precision = function(_) {\n      if (!arguments.length) return precision;\n      interpolate = d3_geo_circleInterpolate(angle * d3_radians, (precision = +_) * d3_radians);\n      return circle;\n    };\n    return circle.angle(90);\n  };\n  function d3_geo_circleInterpolate(radius, precision) {\n    var cr = Math.cos(radius), sr = Math.sin(radius);\n    return function(from, to, direction, listener) {\n      var step = direction * precision;\n      if (from != null) {\n        from = d3_geo_circleAngle(cr, from);\n        to = d3_geo_circleAngle(cr, to);\n        if (direction > 0 ? from < to : from > to) from += direction * ;\n      } else {\n        from = radius + direction * ;\n        to = radius - .5 * step;\n      }\n      for (var point, t = from; direction > 0 ? t > to : t < to; t -= step) {\n        listener.point((point = d3_geo_spherical([ cr, -sr * Math.cos(t), -sr * Math.sin(t) ]))[0], point[1]);\n      }\n    };\n  }\n  function d3_geo_circleAngle(cr, point) {\n    var a = d3_geo_cartesian(point);\n    a[0] -= cr;\n    d3_geo_cartesianNormalize(a);\n    var angle = d3_acos(-a[1]);\n    return ((-a[2] < 0 ? -angle : angle) + 2 * Math.PI - ) % (2 * Math.PI);\n  }\n  d3.geo.distance = function(a, b) {\n    var  = (b[0] - a[0]) * d3_radians, 0 = a[1] * d3_radians, 1 = b[1] * d3_radians, sin = Math.sin(), cos = Math.cos(), sin0 = Math.sin(0), cos0 = Math.cos(0), sin1 = Math.sin(1), cos1 = Math.cos(1), t;\n    return Math.atan2(Math.sqrt((t = cos1 * sin) * t + (t = cos0 * sin1 - sin0 * cos1 * cos) * t), sin0 * sin1 + cos0 * cos1 * cos);\n  };\n  d3.geo.graticule = function() {\n    var x1, x0, X1, X0, y1, y0, Y1, Y0, dx = 10, dy = dx, DX = 90, DY = 360, x, y, X, Y, precision = 2.5;\n    function graticule() {\n      return {\n        type: \"MultiLineString\",\n        coordinates: lines()\n      };\n    }\n    function lines() {\n      return d3.range(Math.ceil(X0 / DX) * DX, X1, DX).map(X).concat(d3.range(Math.ceil(Y0 / DY) * DY, Y1, DY).map(Y)).concat(d3.range(Math.ceil(x0 / dx) * dx, x1, dx).filter(function(x) {\n        return abs(x % DX) > ;\n      }).map(x)).concat(d3.range(Math.ceil(y0 / dy) * dy, y1, dy).filter(function(y) {\n        return abs(y % DY) > ;\n      }).map(y));\n    }\n    graticule.lines = function() {\n      return lines().map(function(coordinates) {\n        return {\n          type: \"LineString\",\n          coordinates: coordinates\n        };\n      });\n    };\n    graticule.outline = function() {\n      return {\n        type: \"Polygon\",\n        coordinates: [ X(X0).concat(Y(Y1).slice(1), X(X1).reverse().slice(1), Y(Y0).reverse().slice(1)) ]\n      };\n    };\n    graticule.extent = function(_) {\n      if (!arguments.length) return graticule.minorExtent();\n      return graticule.majorExtent(_).minorExtent(_);\n    };\n    graticule.majorExtent = function(_) {\n      if (!arguments.length) return [ [ X0, Y0 ], [ X1, Y1 ] ];\n      X0 = +_[0][0], X1 = +_[1][0];\n      Y0 = +_[0][1], Y1 = +_[1][1];\n      if (X0 > X1) _ = X0, X0 = X1, X1 = _;\n      if (Y0 > Y1) _ = Y0, Y0 = Y1, Y1 = _;\n      return graticule.precision(precision);\n    };\n    graticule.minorExtent = function(_) {\n      if (!arguments.length) return [ [ x0, y0 ], [ x1, y1 ] ];\n      x0 = +_[0][0], x1 = +_[1][0];\n      y0 = +_[0][1], y1 = +_[1][1];\n      if (x0 > x1) _ = x0, x0 = x1, x1 = _;\n      if (y0 > y1) _ = y0, y0 = y1, y1 = _;\n      return graticule.precision(precision);\n    };\n    graticule.step = function(_) {\n      if (!arguments.length) return graticule.minorStep();\n      return graticule.majorStep(_).minorStep(_);\n    };\n    graticule.majorStep = function(_) {\n      if (!arguments.length) return [ DX, DY ];\n      DX = +_[0], DY = +_[1];\n      return graticule;\n    };\n    graticule.minorStep = function(_) {\n      if (!arguments.length) return [ dx, dy ];\n      dx = +_[0], dy = +_[1];\n      return graticule;\n    };\n    graticule.precision = function(_) {\n      if (!arguments.length) return precision;\n      precision = +_;\n      x = d3_geo_graticuleX(y0, y1, 90);\n      y = d3_geo_graticuleY(x0, x1, precision);\n      X = d3_geo_graticuleX(Y0, Y1, 90);\n      Y = d3_geo_graticuleY(X0, X1, precision);\n      return graticule;\n    };\n    return graticule.majorExtent([ [ -180, -90 +  ], [ 180, 90 -  ] ]).minorExtent([ [ -180, -80 -  ], [ 180, 80 +  ] ]);\n  };\n  function d3_geo_graticuleX(y0, y1, dy) {\n    var y = d3.range(y0, y1 - , dy).concat(y1);\n    return function(x) {\n      return y.map(function(y) {\n        return [ x, y ];\n      });\n    };\n  }\n  function d3_geo_graticuleY(x0, x1, dx) {\n    var x = d3.range(x0, x1 - , dx).concat(x1);\n    return function(y) {\n      return x.map(function(x) {\n        return [ x, y ];\n      });\n    };\n  }\n  function d3_source(d) {\n    return d.source;\n  }\n  function d3_target(d) {\n    return d.target;\n  }\n  d3.geo.greatArc = function() {\n    var source = d3_source, source_, target = d3_target, target_;\n    function greatArc() {\n      return {\n        type: \"LineString\",\n        coordinates: [ source_ || source.apply(this, arguments), target_ || target.apply(this, arguments) ]\n      };\n    }\n    greatArc.distance = function() {\n      return d3.geo.distance(source_ || source.apply(this, arguments), target_ || target.apply(this, arguments));\n    };\n    greatArc.source = function(_) {\n      if (!arguments.length) return source;\n      source = _, source_ = typeof _ === \"function\" ? null : _;\n      return greatArc;\n    };\n    greatArc.target = function(_) {\n      if (!arguments.length) return target;\n      target = _, target_ = typeof _ === \"function\" ? null : _;\n      return greatArc;\n    };\n    greatArc.precision = function() {\n      return arguments.length ? greatArc : 0;\n    };\n    return greatArc;\n  };\n  d3.geo.interpolate = function(source, target) {\n    return d3_geo_interpolate(source[0] * d3_radians, source[1] * d3_radians, target[0] * d3_radians, target[1] * d3_radians);\n  };\n  function d3_geo_interpolate(x0, y0, x1, y1) {\n    var cy0 = Math.cos(y0), sy0 = Math.sin(y0), cy1 = Math.cos(y1), sy1 = Math.sin(y1), kx0 = cy0 * Math.cos(x0), ky0 = cy0 * Math.sin(x0), kx1 = cy1 * Math.cos(x1), ky1 = cy1 * Math.sin(x1), d = 2 * Math.asin(Math.sqrt(d3_haversin(y1 - y0) + cy0 * cy1 * d3_haversin(x1 - x0))), k = 1 / Math.sin(d);\n    var interpolate = d ? function(t) {\n      var B = Math.sin(t *= d) * k, A = Math.sin(d - t) * k, x = A * kx0 + B * kx1, y = A * ky0 + B * ky1, z = A * sy0 + B * sy1;\n      return [ Math.atan2(y, x) * d3_degrees, Math.atan2(z, Math.sqrt(x * x + y * y)) * d3_degrees ];\n    } : function() {\n      return [ x0 * d3_degrees, y0 * d3_degrees ];\n    };\n    interpolate.distance = d;\n    return interpolate;\n  }\n  d3.geo.length = function(object) {\n    d3_geo_lengthSum = 0;\n    d3.geo.stream(object, d3_geo_length);\n    return d3_geo_lengthSum;\n  };\n  var d3_geo_lengthSum;\n  var d3_geo_length = {\n    sphere: d3_noop,\n    point: d3_noop,\n    lineStart: d3_geo_lengthLineStart,\n    lineEnd: d3_noop,\n    polygonStart: d3_noop,\n    polygonEnd: d3_noop\n  };\n  function d3_geo_lengthLineStart() {\n    var 0, sin0, cos0;\n    d3_geo_length.point = function(, ) {\n      0 =  * d3_radians, sin0 = Math.sin( *= d3_radians), cos0 = Math.cos();\n      d3_geo_length.point = nextPoint;\n    };\n    d3_geo_length.lineEnd = function() {\n      d3_geo_length.point = d3_geo_length.lineEnd = d3_noop;\n    };\n    function nextPoint(, ) {\n      var sin = Math.sin( *= d3_radians), cos = Math.cos(), t = abs(( *= d3_radians) - 0), cos = Math.cos(t);\n      d3_geo_lengthSum += Math.atan2(Math.sqrt((t = cos * Math.sin(t)) * t + (t = cos0 * sin - sin0 * cos * cos) * t), sin0 * sin + cos0 * cos * cos);\n      0 = , sin0 = sin, cos0 = cos;\n    }\n  }\n  function d3_geo_azimuthal(scale, angle) {\n    function azimuthal(, ) {\n      var cos = Math.cos(), cos = Math.cos(), k = scale(cos * cos);\n      return [ k * cos * Math.sin(), k * Math.sin() ];\n    }\n    azimuthal.invert = function(x, y) {\n      var  = Math.sqrt(x * x + y * y), c = angle(), sinc = Math.sin(c), cosc = Math.cos(c);\n      return [ Math.atan2(x * sinc,  * cosc), Math.asin( && y * sinc / ) ];\n    };\n    return azimuthal;\n  }\n  var d3_geo_azimuthalEqualArea = d3_geo_azimuthal(function(coscos) {\n    return Math.sqrt(2 / (1 + coscos));\n  }, function() {\n    return 2 * Math.asin( / 2);\n  });\n  (d3.geo.azimuthalEqualArea = function() {\n    return d3_geo_projection(d3_geo_azimuthalEqualArea);\n  }).raw = d3_geo_azimuthalEqualArea;\n  var d3_geo_azimuthalEquidistant = d3_geo_azimuthal(function(coscos) {\n    var c = Math.acos(coscos);\n    return c && c / Math.sin(c);\n  }, d3_identity);\n  (d3.geo.azimuthalEquidistant = function() {\n    return d3_geo_projection(d3_geo_azimuthalEquidistant);\n  }).raw = d3_geo_azimuthalEquidistant;\n  function d3_geo_conicConformal(0, 1) {\n    var cos0 = Math.cos(0), t = function() {\n      return Math.tan( / 4 +  / 2);\n    }, n = 0 === 1 ? Math.sin(0) : Math.log(cos0 / Math.cos(1)) / Math.log(t(1) / t(0)), F = cos0 * Math.pow(t(0), n) / n;\n    if (!n) return d3_geo_mercator;\n    function forward(, ) {\n      if (F > 0) {\n        if ( < -half + )  = -half + ;\n      } else {\n        if ( > half - )  = half - ;\n      }\n      var  = F / Math.pow(t(), n);\n      return [  * Math.sin(n * ), F -  * Math.cos(n * ) ];\n    }\n    forward.invert = function(x, y) {\n      var 0_y = F - y,  = d3_sgn(n) * Math.sqrt(x * x + 0_y * 0_y);\n      return [ Math.atan2(x, 0_y) / n, 2 * Math.atan(Math.pow(F / , 1 / n)) - half ];\n    };\n    return forward;\n  }\n  (d3.geo.conicConformal = function() {\n    return d3_geo_conic(d3_geo_conicConformal);\n  }).raw = d3_geo_conicConformal;\n  function d3_geo_conicEquidistant(0, 1) {\n    var cos0 = Math.cos(0), n = 0 === 1 ? Math.sin(0) : (cos0 - Math.cos(1)) / (1 - 0), G = cos0 / n + 0;\n    if (abs(n) < ) return d3_geo_equirectangular;\n    function forward(, ) {\n      var  = G - ;\n      return [  * Math.sin(n * ), G -  * Math.cos(n * ) ];\n    }\n    forward.invert = function(x, y) {\n      var 0_y = G - y;\n      return [ Math.atan2(x, 0_y) / n, G - d3_sgn(n) * Math.sqrt(x * x + 0_y * 0_y) ];\n    };\n    return forward;\n  }\n  (d3.geo.conicEquidistant = function() {\n    return d3_geo_conic(d3_geo_conicEquidistant);\n  }).raw = d3_geo_conicEquidistant;\n  var d3_geo_gnomonic = d3_geo_azimuthal(function(coscos) {\n    return 1 / coscos;\n  }, Math.atan);\n  (d3.geo.gnomonic = function() {\n    return d3_geo_projection(d3_geo_gnomonic);\n  }).raw = d3_geo_gnomonic;\n  function d3_geo_mercator(, ) {\n    return [ , Math.log(Math.tan( / 4 +  / 2)) ];\n  }\n  d3_geo_mercator.invert = function(x, y) {\n    return [ x, 2 * Math.atan(Math.exp(y)) - half ];\n  };\n  function d3_geo_mercatorProjection(project) {\n    var m = d3_geo_projection(project), scale = m.scale, translate = m.translate, clipExtent = m.clipExtent, clipAuto;\n    m.scale = function() {\n      var v = scale.apply(m, arguments);\n      return v === m ? clipAuto ? m.clipExtent(null) : m : v;\n    };\n    m.translate = function() {\n      var v = translate.apply(m, arguments);\n      return v === m ? clipAuto ? m.clipExtent(null) : m : v;\n    };\n    m.clipExtent = function(_) {\n      var v = clipExtent.apply(m, arguments);\n      if (v === m) {\n        if (clipAuto = _ == null) {\n          var k =  * scale(), t = translate();\n          clipExtent([ [ t[0] - k, t[1] - k ], [ t[0] + k, t[1] + k ] ]);\n        }\n      } else if (clipAuto) {\n        v = null;\n      }\n      return v;\n    };\n    return m.clipExtent(null);\n  }\n  (d3.geo.mercator = function() {\n    return d3_geo_mercatorProjection(d3_geo_mercator);\n  }).raw = d3_geo_mercator;\n  var d3_geo_orthographic = d3_geo_azimuthal(function() {\n    return 1;\n  }, Math.asin);\n  (d3.geo.orthographic = function() {\n    return d3_geo_projection(d3_geo_orthographic);\n  }).raw = d3_geo_orthographic;\n  var d3_geo_stereographic = d3_geo_azimuthal(function(coscos) {\n    return 1 / (1 + coscos);\n  }, function() {\n    return 2 * Math.atan();\n  });\n  (d3.geo.stereographic = function() {\n    return d3_geo_projection(d3_geo_stereographic);\n  }).raw = d3_geo_stereographic;\n  function d3_geo_transverseMercator(, ) {\n    return [ Math.log(Math.tan( / 4 +  / 2)), - ];\n  }\n  d3_geo_transverseMercator.invert = function(x, y) {\n    return [ -y, 2 * Math.atan(Math.exp(x)) - half ];\n  };\n  (d3.geo.transverseMercator = function() {\n    var projection = d3_geo_mercatorProjection(d3_geo_transverseMercator), center = projection.center, rotate = projection.rotate;\n    projection.center = function(_) {\n      return _ ? center([ -_[1], _[0] ]) : (_ = center(), [ _[1], -_[0] ]);\n    };\n    projection.rotate = function(_) {\n      return _ ? rotate([ _[0], _[1], _.length > 2 ? _[2] + 90 : 90 ]) : (_ = rotate(), \n      [ _[0], _[1], _[2] - 90 ]);\n    };\n    return rotate([ 0, 0, 90 ]);\n  }).raw = d3_geo_transverseMercator;\n  d3.geom = {};\n  function d3_geom_pointX(d) {\n    return d[0];\n  }\n  function d3_geom_pointY(d) {\n    return d[1];\n  }\n  d3.geom.hull = function(vertices) {\n    var x = d3_geom_pointX, y = d3_geom_pointY;\n    if (arguments.length) return hull(vertices);\n    function hull(data) {\n      if (data.length < 3) return [];\n      var fx = d3_functor(x), fy = d3_functor(y), i, n = data.length, points = [], flippedPoints = [];\n      for (i = 0; i < n; i++) {\n        points.push([ +fx.call(this, data[i], i), +fy.call(this, data[i], i), i ]);\n      }\n      points.sort(d3_geom_hullOrder);\n      for (i = 0; i < n; i++) flippedPoints.push([ points[i][0], -points[i][1] ]);\n      var upper = d3_geom_hullUpper(points), lower = d3_geom_hullUpper(flippedPoints);\n      var skipLeft = lower[0] === upper[0], skipRight = lower[lower.length - 1] === upper[upper.length - 1], polygon = [];\n      for (i = upper.length - 1; i >= 0; --i) polygon.push(data[points[upper[i]][2]]);\n      for (i = +skipLeft; i < lower.length - skipRight; ++i) polygon.push(data[points[lower[i]][2]]);\n      return polygon;\n    }\n    hull.x = function(_) {\n      return arguments.length ? (x = _, hull) : x;\n    };\n    hull.y = function(_) {\n      return arguments.length ? (y = _, hull) : y;\n    };\n    return hull;\n  };\n  function d3_geom_hullUpper(points) {\n    var n = points.length, hull = [ 0, 1 ], hs = 2;\n    for (var i = 2; i < n; i++) {\n      while (hs > 1 && d3_cross2d(points[hull[hs - 2]], points[hull[hs - 1]], points[i]) <= 0) --hs;\n      hull[hs++] = i;\n    }\n    return hull.slice(0, hs);\n  }\n  function d3_geom_hullOrder(a, b) {\n    return a[0] - b[0] || a[1] - b[1];\n  }\n  d3.geom.polygon = function(coordinates) {\n    d3_subclass(coordinates, d3_geom_polygonPrototype);\n    return coordinates;\n  };\n  var d3_geom_polygonPrototype = d3.geom.polygon.prototype = [];\n  d3_geom_polygonPrototype.area = function() {\n    var i = -1, n = this.length, a, b = this[n - 1], area = 0;\n    while (++i < n) {\n      a = b;\n      b = this[i];\n      area += a[1] * b[0] - a[0] * b[1];\n    }\n    return area * .5;\n  };\n  d3_geom_polygonPrototype.centroid = function(k) {\n    var i = -1, n = this.length, x = 0, y = 0, a, b = this[n - 1], c;\n    if (!arguments.length) k = -1 / (6 * this.area());\n    while (++i < n) {\n      a = b;\n      b = this[i];\n      c = a[0] * b[1] - b[0] * a[1];\n      x += (a[0] + b[0]) * c;\n      y += (a[1] + b[1]) * c;\n    }\n    return [ x * k, y * k ];\n  };\n  d3_geom_polygonPrototype.clip = function(subject) {\n    var input, closed = d3_geom_polygonClosed(subject), i = -1, n = this.length - d3_geom_polygonClosed(this), j, m, a = this[n - 1], b, c, d;\n    while (++i < n) {\n      input = subject.slice();\n      subject.length = 0;\n      b = this[i];\n      c = input[(m = input.length - closed) - 1];\n      j = -1;\n      while (++j < m) {\n        d = input[j];\n        if (d3_geom_polygonInside(d, a, b)) {\n          if (!d3_geom_polygonInside(c, a, b)) {\n            subject.push(d3_geom_polygonIntersect(c, d, a, b));\n          }\n          subject.push(d);\n        } else if (d3_geom_polygonInside(c, a, b)) {\n          subject.push(d3_geom_polygonIntersect(c, d, a, b));\n        }\n        c = d;\n      }\n      if (closed) subject.push(subject[0]);\n      a = b;\n    }\n    return subject;\n  };\n  function d3_geom_polygonInside(p, a, b) {\n    return (b[0] - a[0]) * (p[1] - a[1]) < (b[1] - a[1]) * (p[0] - a[0]);\n  }\n  function d3_geom_polygonIntersect(c, d, a, b) {\n    var x1 = c[0], x3 = a[0], x21 = d[0] - x1, x43 = b[0] - x3, y1 = c[1], y3 = a[1], y21 = d[1] - y1, y43 = b[1] - y3, ua = (x43 * (y1 - y3) - y43 * (x1 - x3)) / (y43 * x21 - x43 * y21);\n    return [ x1 + ua * x21, y1 + ua * y21 ];\n  }\n  function d3_geom_polygonClosed(coordinates) {\n    var a = coordinates[0], b = coordinates[coordinates.length - 1];\n    return !(a[0] - b[0] || a[1] - b[1]);\n  }\n  var d3_geom_voronoiEdges, d3_geom_voronoiCells, d3_geom_voronoiBeaches, d3_geom_voronoiBeachPool = [], d3_geom_voronoiFirstCircle, d3_geom_voronoiCircles, d3_geom_voronoiCirclePool = [];\n  function d3_geom_voronoiBeach() {\n    d3_geom_voronoiRedBlackNode(this);\n    this.edge = this.site = this.circle = null;\n  }\n  function d3_geom_voronoiCreateBeach(site) {\n    var beach = d3_geom_voronoiBeachPool.pop() || new d3_geom_voronoiBeach();\n    beach.site = site;\n    return beach;\n  }\n  function d3_geom_voronoiDetachBeach(beach) {\n    d3_geom_voronoiDetachCircle(beach);\n    d3_geom_voronoiBeaches.remove(beach);\n    d3_geom_voronoiBeachPool.push(beach);\n    d3_geom_voronoiRedBlackNode(beach);\n  }\n  function d3_geom_voronoiRemoveBeach(beach) {\n    var circle = beach.circle, x = circle.x, y = circle.cy, vertex = {\n      x: x,\n      y: y\n    }, previous = beach.P, next = beach.N, disappearing = [ beach ];\n    d3_geom_voronoiDetachBeach(beach);\n    var lArc = previous;\n    while (lArc.circle && abs(x - lArc.circle.x) <  && abs(y - lArc.circle.cy) < ) {\n      previous = lArc.P;\n      disappearing.unshift(lArc);\n      d3_geom_voronoiDetachBeach(lArc);\n      lArc = previous;\n    }\n    disappearing.unshift(lArc);\n    d3_geom_voronoiDetachCircle(lArc);\n    var rArc = next;\n    while (rArc.circle && abs(x - rArc.circle.x) <  && abs(y - rArc.circle.cy) < ) {\n      next = rArc.N;\n      disappearing.push(rArc);\n      d3_geom_voronoiDetachBeach(rArc);\n      rArc = next;\n    }\n    disappearing.push(rArc);\n    d3_geom_voronoiDetachCircle(rArc);\n    var nArcs = disappearing.length, iArc;\n    for (iArc = 1; iArc < nArcs; ++iArc) {\n      rArc = disappearing[iArc];\n      lArc = disappearing[iArc - 1];\n      d3_geom_voronoiSetEdgeEnd(rArc.edge, lArc.site, rArc.site, vertex);\n    }\n    lArc = disappearing[0];\n    rArc = disappearing[nArcs - 1];\n    rArc.edge = d3_geom_voronoiCreateEdge(lArc.site, rArc.site, null, vertex);\n    d3_geom_voronoiAttachCircle(lArc);\n    d3_geom_voronoiAttachCircle(rArc);\n  }\n  function d3_geom_voronoiAddBeach(site) {\n    var x = site.x, directrix = site.y, lArc, rArc, dxl, dxr, node = d3_geom_voronoiBeaches._;\n    while (node) {\n      dxl = d3_geom_voronoiLeftBreakPoint(node, directrix) - x;\n      if (dxl > ) node = node.L; else {\n        dxr = x - d3_geom_voronoiRightBreakPoint(node, directrix);\n        if (dxr > ) {\n          if (!node.R) {\n            lArc = node;\n            break;\n          }\n          node = node.R;\n        } else {\n          if (dxl > -) {\n            lArc = node.P;\n            rArc = node;\n          } else if (dxr > -) {\n            lArc = node;\n            rArc = node.N;\n          } else {\n            lArc = rArc = node;\n          }\n          break;\n        }\n      }\n    }\n    var newArc = d3_geom_voronoiCreateBeach(site);\n    d3_geom_voronoiBeaches.insert(lArc, newArc);\n    if (!lArc && !rArc) return;\n    if (lArc === rArc) {\n      d3_geom_voronoiDetachCircle(lArc);\n      rArc = d3_geom_voronoiCreateBeach(lArc.site);\n      d3_geom_voronoiBeaches.insert(newArc, rArc);\n      newArc.edge = rArc.edge = d3_geom_voronoiCreateEdge(lArc.site, newArc.site);\n      d3_geom_voronoiAttachCircle(lArc);\n      d3_geom_voronoiAttachCircle(rArc);\n      return;\n    }\n    if (!rArc) {\n      newArc.edge = d3_geom_voronoiCreateEdge(lArc.site, newArc.site);\n      return;\n    }\n    d3_geom_voronoiDetachCircle(lArc);\n    d3_geom_voronoiDetachCircle(rArc);\n    var lSite = lArc.site, ax = lSite.x, ay = lSite.y, bx = site.x - ax, by = site.y - ay, rSite = rArc.site, cx = rSite.x - ax, cy = rSite.y - ay, d = 2 * (bx * cy - by * cx), hb = bx * bx + by * by, hc = cx * cx + cy * cy, vertex = {\n      x: (cy * hb - by * hc) / d + ax,\n      y: (bx * hc - cx * hb) / d + ay\n    };\n    d3_geom_voronoiSetEdgeEnd(rArc.edge, lSite, rSite, vertex);\n    newArc.edge = d3_geom_voronoiCreateEdge(lSite, site, null, vertex);\n    rArc.edge = d3_geom_voronoiCreateEdge(site, rSite, null, vertex);\n    d3_geom_voronoiAttachCircle(lArc);\n    d3_geom_voronoiAttachCircle(rArc);\n  }\n  function d3_geom_voronoiLeftBreakPoint(arc, directrix) {\n    var site = arc.site, rfocx = site.x, rfocy = site.y, pby2 = rfocy - directrix;\n    if (!pby2) return rfocx;\n    var lArc = arc.P;\n    if (!lArc) return -Infinity;\n    site = lArc.site;\n    var lfocx = site.x, lfocy = site.y, plby2 = lfocy - directrix;\n    if (!plby2) return lfocx;\n    var hl = lfocx - rfocx, aby2 = 1 / pby2 - 1 / plby2, b = hl / plby2;\n    if (aby2) return (-b + Math.sqrt(b * b - 2 * aby2 * (hl * hl / (-2 * plby2) - lfocy + plby2 / 2 + rfocy - pby2 / 2))) / aby2 + rfocx;\n    return (rfocx + lfocx) / 2;\n  }\n  function d3_geom_voronoiRightBreakPoint(arc, directrix) {\n    var rArc = arc.N;\n    if (rArc) return d3_geom_voronoiLeftBreakPoint(rArc, directrix);\n    var site = arc.site;\n    return site.y === directrix ? site.x : Infinity;\n  }\n  function d3_geom_voronoiCell(site) {\n    this.site = site;\n    this.edges = [];\n  }\n  d3_geom_voronoiCell.prototype.prepare = function() {\n    var halfEdges = this.edges, iHalfEdge = halfEdges.length, edge;\n    while (iHalfEdge--) {\n      edge = halfEdges[iHalfEdge].edge;\n      if (!edge.b || !edge.a) halfEdges.splice(iHalfEdge, 1);\n    }\n    halfEdges.sort(d3_geom_voronoiHalfEdgeOrder);\n    return halfEdges.length;\n  };\n  function d3_geom_voronoiCloseCells(extent) {\n    var x0 = extent[0][0], x1 = extent[1][0], y0 = extent[0][1], y1 = extent[1][1], x2, y2, x3, y3, cells = d3_geom_voronoiCells, iCell = cells.length, cell, iHalfEdge, halfEdges, nHalfEdges, start, end;\n    while (iCell--) {\n      cell = cells[iCell];\n      if (!cell || !cell.prepare()) continue;\n      halfEdges = cell.edges;\n      nHalfEdges = halfEdges.length;\n      iHalfEdge = 0;\n      while (iHalfEdge < nHalfEdges) {\n        end = halfEdges[iHalfEdge].end(), x3 = end.x, y3 = end.y;\n        start = halfEdges[++iHalfEdge % nHalfEdges].start(), x2 = start.x, y2 = start.y;\n        if (abs(x3 - x2) >  || abs(y3 - y2) > ) {\n          halfEdges.splice(iHalfEdge, 0, new d3_geom_voronoiHalfEdge(d3_geom_voronoiCreateBorderEdge(cell.site, end, abs(x3 - x0) <  && y1 - y3 >  ? {\n            x: x0,\n            y: abs(x2 - x0) <  ? y2 : y1\n          } : abs(y3 - y1) <  && x1 - x3 >  ? {\n            x: abs(y2 - y1) <  ? x2 : x1,\n            y: y1\n          } : abs(x3 - x1) <  && y3 - y0 >  ? {\n            x: x1,\n            y: abs(x2 - x1) <  ? y2 : y0\n          } : abs(y3 - y0) <  && x3 - x0 >  ? {\n            x: abs(y2 - y0) <  ? x2 : x0,\n            y: y0\n          } : null), cell.site, null));\n          ++nHalfEdges;\n        }\n      }\n    }\n  }\n  function d3_geom_voronoiHalfEdgeOrder(a, b) {\n    return b.angle - a.angle;\n  }\n  function d3_geom_voronoiCircle() {\n    d3_geom_voronoiRedBlackNode(this);\n    this.x = this.y = this.arc = this.site = this.cy = null;\n  }\n  function d3_geom_voronoiAttachCircle(arc) {\n    var lArc = arc.P, rArc = arc.N;\n    if (!lArc || !rArc) return;\n    var lSite = lArc.site, cSite = arc.site, rSite = rArc.site;\n    if (lSite === rSite) return;\n    var bx = cSite.x, by = cSite.y, ax = lSite.x - bx, ay = lSite.y - by, cx = rSite.x - bx, cy = rSite.y - by;\n    var d = 2 * (ax * cy - ay * cx);\n    if (d >= -2) return;\n    var ha = ax * ax + ay * ay, hc = cx * cx + cy * cy, x = (cy * ha - ay * hc) / d, y = (ax * hc - cx * ha) / d, cy = y + by;\n    var circle = d3_geom_voronoiCirclePool.pop() || new d3_geom_voronoiCircle();\n    circle.arc = arc;\n    circle.site = cSite;\n    circle.x = x + bx;\n    circle.y = cy + Math.sqrt(x * x + y * y);\n    circle.cy = cy;\n    arc.circle = circle;\n    var before = null, node = d3_geom_voronoiCircles._;\n    while (node) {\n      if (circle.y < node.y || circle.y === node.y && circle.x <= node.x) {\n        if (node.L) node = node.L; else {\n          before = node.P;\n          break;\n        }\n      } else {\n        if (node.R) node = node.R; else {\n          before = node;\n          break;\n        }\n      }\n    }\n    d3_geom_voronoiCircles.insert(before, circle);\n    if (!before) d3_geom_voronoiFirstCircle = circle;\n  }\n  function d3_geom_voronoiDetachCircle(arc) {\n    var circle = arc.circle;\n    if (circle) {\n      if (!circle.P) d3_geom_voronoiFirstCircle = circle.N;\n      d3_geom_voronoiCircles.remove(circle);\n      d3_geom_voronoiCirclePool.push(circle);\n      d3_geom_voronoiRedBlackNode(circle);\n      arc.circle = null;\n    }\n  }\n  function d3_geom_voronoiClipEdges(extent) {\n    var edges = d3_geom_voronoiEdges, clip = d3_geom_clipLine(extent[0][0], extent[0][1], extent[1][0], extent[1][1]), i = edges.length, e;\n    while (i--) {\n      e = edges[i];\n      if (!d3_geom_voronoiConnectEdge(e, extent) || !clip(e) || abs(e.a.x - e.b.x) <  && abs(e.a.y - e.b.y) < ) {\n        e.a = e.b = null;\n        edges.splice(i, 1);\n      }\n    }\n  }\n  function d3_geom_voronoiConnectEdge(edge, extent) {\n    var vb = edge.b;\n    if (vb) return true;\n    var va = edge.a, x0 = extent[0][0], x1 = extent[1][0], y0 = extent[0][1], y1 = extent[1][1], lSite = edge.l, rSite = edge.r, lx = lSite.x, ly = lSite.y, rx = rSite.x, ry = rSite.y, fx = (lx + rx) / 2, fy = (ly + ry) / 2, fm, fb;\n    if (ry === ly) {\n      if (fx < x0 || fx >= x1) return;\n      if (lx > rx) {\n        if (!va) va = {\n          x: fx,\n          y: y0\n        }; else if (va.y >= y1) return;\n        vb = {\n          x: fx,\n          y: y1\n        };\n      } else {\n        if (!va) va = {\n          x: fx,\n          y: y1\n        }; else if (va.y < y0) return;\n        vb = {\n          x: fx,\n          y: y0\n        };\n      }\n    } else {\n      fm = (lx - rx) / (ry - ly);\n      fb = fy - fm * fx;\n      if (fm < -1 || fm > 1) {\n        if (lx > rx) {\n          if (!va) va = {\n            x: (y0 - fb) / fm,\n            y: y0\n          }; else if (va.y >= y1) return;\n          vb = {\n            x: (y1 - fb) / fm,\n            y: y1\n          };\n        } else {\n          if (!va) va = {\n            x: (y1 - fb) / fm,\n            y: y1\n          }; else if (va.y < y0) return;\n          vb = {\n            x: (y0 - fb) / fm,\n            y: y0\n          };\n        }\n      } else {\n        if (ly < ry) {\n          if (!va) va = {\n            x: x0,\n            y: fm * x0 + fb\n          }; else if (va.x >= x1) return;\n          vb = {\n            x: x1,\n            y: fm * x1 + fb\n          };\n        } else {\n          if (!va) va = {\n            x: x1,\n            y: fm * x1 + fb\n          }; else if (va.x < x0) return;\n          vb = {\n            x: x0,\n            y: fm * x0 + fb\n          };\n        }\n      }\n    }\n    edge.a = va;\n    edge.b = vb;\n    return true;\n  }\n  function d3_geom_voronoiEdge(lSite, rSite) {\n    this.l = lSite;\n    this.r = rSite;\n    this.a = this.b = null;\n  }\n  function d3_geom_voronoiCreateEdge(lSite, rSite, va, vb) {\n    var edge = new d3_geom_voronoiEdge(lSite, rSite);\n    d3_geom_voronoiEdges.push(edge);\n    if (va) d3_geom_voronoiSetEdgeEnd(edge, lSite, rSite, va);\n    if (vb) d3_geom_voronoiSetEdgeEnd(edge, rSite, lSite, vb);\n    d3_geom_voronoiCells[lSite.i].edges.push(new d3_geom_voronoiHalfEdge(edge, lSite, rSite));\n    d3_geom_voronoiCells[rSite.i].edges.push(new d3_geom_voronoiHalfEdge(edge, rSite, lSite));\n    return edge;\n  }\n  function d3_geom_voronoiCreateBorderEdge(lSite, va, vb) {\n    var edge = new d3_geom_voronoiEdge(lSite, null);\n    edge.a = va;\n    edge.b = vb;\n    d3_geom_voronoiEdges.push(edge);\n    return edge;\n  }\n  function d3_geom_voronoiSetEdgeEnd(edge, lSite, rSite, vertex) {\n    if (!edge.a && !edge.b) {\n      edge.a = vertex;\n      edge.l = lSite;\n      edge.r = rSite;\n    } else if (edge.l === rSite) {\n      edge.b = vertex;\n    } else {\n      edge.a = vertex;\n    }\n  }\n  function d3_geom_voronoiHalfEdge(edge, lSite, rSite) {\n    var va = edge.a, vb = edge.b;\n    this.edge = edge;\n    this.site = lSite;\n    this.angle = rSite ? Math.atan2(rSite.y - lSite.y, rSite.x - lSite.x) : edge.l === lSite ? Math.atan2(vb.x - va.x, va.y - vb.y) : Math.atan2(va.x - vb.x, vb.y - va.y);\n  }\n  d3_geom_voronoiHalfEdge.prototype = {\n    start: function() {\n      return this.edge.l === this.site ? this.edge.a : this.edge.b;\n    },\n    end: function() {\n      return this.edge.l === this.site ? this.edge.b : this.edge.a;\n    }\n  };\n  function d3_geom_voronoiRedBlackTree() {\n    this._ = null;\n  }\n  function d3_geom_voronoiRedBlackNode(node) {\n    node.U = node.C = node.L = node.R = node.P = node.N = null;\n  }\n  d3_geom_voronoiRedBlackTree.prototype = {\n    insert: function(after, node) {\n      var parent, grandpa, uncle;\n      if (after) {\n        node.P = after;\n        node.N = after.N;\n        if (after.N) after.N.P = node;\n        after.N = node;\n        if (after.R) {\n          after = after.R;\n          while (after.L) after = after.L;\n          after.L = node;\n        } else {\n          after.R = node;\n        }\n        parent = after;\n      } else if (this._) {\n        after = d3_geom_voronoiRedBlackFirst(this._);\n        node.P = null;\n        node.N = after;\n        after.P = after.L = node;\n        parent = after;\n      } else {\n        node.P = node.N = null;\n        this._ = node;\n        parent = null;\n      }\n      node.L = node.R = null;\n      node.U = parent;\n      node.C = true;\n      after = node;\n      while (parent && parent.C) {\n        grandpa = parent.U;\n        if (parent === grandpa.L) {\n          uncle = grandpa.R;\n          if (uncle && uncle.C) {\n            parent.C = uncle.C = false;\n            grandpa.C = true;\n            after = grandpa;\n          } else {\n            if (after === parent.R) {\n              d3_geom_voronoiRedBlackRotateLeft(this, parent);\n              after = parent;\n              parent = after.U;\n            }\n            parent.C = false;\n            grandpa.C = true;\n            d3_geom_voronoiRedBlackRotateRight(this, grandpa);\n          }\n        } else {\n          uncle = grandpa.L;\n          if (uncle && uncle.C) {\n            parent.C = uncle.C = false;\n            grandpa.C = true;\n            after = grandpa;\n          } else {\n            if (after === parent.L) {\n              d3_geom_voronoiRedBlackRotateRight(this, parent);\n              after = parent;\n              parent = after.U;\n            }\n            parent.C = false;\n            grandpa.C = true;\n            d3_geom_voronoiRedBlackRotateLeft(this, grandpa);\n          }\n        }\n        parent = after.U;\n      }\n      this._.C = false;\n    },\n    remove: function(node) {\n      if (node.N) node.N.P = node.P;\n      if (node.P) node.P.N = node.N;\n      node.N = node.P = null;\n      var parent = node.U, sibling, left = node.L, right = node.R, next, red;\n      if (!left) next = right; else if (!right) next = left; else next = d3_geom_voronoiRedBlackFirst(right);\n      if (parent) {\n        if (parent.L === node) parent.L = next; else parent.R = next;\n      } else {\n        this._ = next;\n      }\n      if (left && right) {\n        red = next.C;\n        next.C = node.C;\n        next.L = left;\n        left.U = next;\n        if (next !== right) {\n          parent = next.U;\n          next.U = node.U;\n          node = next.R;\n          parent.L = node;\n          next.R = right;\n          right.U = next;\n        } else {\n          next.U = parent;\n          parent = next;\n          node = next.R;\n        }\n      } else {\n        red = node.C;\n        node = next;\n      }\n      if (node) node.U = parent;\n      if (red) return;\n      if (node && node.C) {\n        node.C = false;\n        return;\n      }\n      do {\n        if (node === this._) break;\n        if (node === parent.L) {\n          sibling = parent.R;\n          if (sibling.C) {\n            sibling.C = false;\n            parent.C = true;\n            d3_geom_voronoiRedBlackRotateLeft(this, parent);\n            sibling = parent.R;\n          }\n          if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {\n            if (!sibling.R || !sibling.R.C) {\n              sibling.L.C = false;\n              sibling.C = true;\n              d3_geom_voronoiRedBlackRotateRight(this, sibling);\n              sibling = parent.R;\n            }\n            sibling.C = parent.C;\n            parent.C = sibling.R.C = false;\n            d3_geom_voronoiRedBlackRotateLeft(this, parent);\n            node = this._;\n            break;\n          }\n        } else {\n          sibling = parent.L;\n          if (sibling.C) {\n            sibling.C = false;\n            parent.C = true;\n            d3_geom_voronoiRedBlackRotateRight(this, parent);\n            sibling = parent.L;\n          }\n          if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {\n            if (!sibling.L || !sibling.L.C) {\n              sibling.R.C = false;\n              sibling.C = true;\n              d3_geom_voronoiRedBlackRotateLeft(this, sibling);\n              sibling = parent.L;\n            }\n            sibling.C = parent.C;\n            parent.C = sibling.L.C = false;\n            d3_geom_voronoiRedBlackRotateRight(this, parent);\n            node = this._;\n            break;\n          }\n        }\n        sibling.C = true;\n        node = parent;\n        parent = parent.U;\n      } while (!node.C);\n      if (node) node.C = false;\n    }\n  };\n  function d3_geom_voronoiRedBlackRotateLeft(tree, node) {\n    var p = node, q = node.R, parent = p.U;\n    if (parent) {\n      if (parent.L === p) parent.L = q; else parent.R = q;\n    } else {\n      tree._ = q;\n    }\n    q.U = parent;\n    p.U = q;\n    p.R = q.L;\n    if (p.R) p.R.U = p;\n    q.L = p;\n  }\n  function d3_geom_voronoiRedBlackRotateRight(tree, node) {\n    var p = node, q = node.L, parent = p.U;\n    if (parent) {\n      if (parent.L === p) parent.L = q; else parent.R = q;\n    } else {\n      tree._ = q;\n    }\n    q.U = parent;\n    p.U = q;\n    p.L = q.R;\n    if (p.L) p.L.U = p;\n    q.R = p;\n  }\n  function d3_geom_voronoiRedBlackFirst(node) {\n    while (node.L) node = node.L;\n    return node;\n  }\n  function d3_geom_voronoi(sites, bbox) {\n    var site = sites.sort(d3_geom_voronoiVertexOrder).pop(), x0, y0, circle;\n    d3_geom_voronoiEdges = [];\n    d3_geom_voronoiCells = new Array(sites.length);\n    d3_geom_voronoiBeaches = new d3_geom_voronoiRedBlackTree();\n    d3_geom_voronoiCircles = new d3_geom_voronoiRedBlackTree();\n    while (true) {\n      circle = d3_geom_voronoiFirstCircle;\n      if (site && (!circle || site.y < circle.y || site.y === circle.y && site.x < circle.x)) {\n        if (site.x !== x0 || site.y !== y0) {\n          d3_geom_voronoiCells[site.i] = new d3_geom_voronoiCell(site);\n          d3_geom_voronoiAddBeach(site);\n          x0 = site.x, y0 = site.y;\n        }\n        site = sites.pop();\n      } else if (circle) {\n        d3_geom_voronoiRemoveBeach(circle.arc);\n      } else {\n        break;\n      }\n    }\n    if (bbox) d3_geom_voronoiClipEdges(bbox), d3_geom_voronoiCloseCells(bbox);\n    var diagram = {\n      cells: d3_geom_voronoiCells,\n      edges: d3_geom_voronoiEdges\n    };\n    d3_geom_voronoiBeaches = d3_geom_voronoiCircles = d3_geom_voronoiEdges = d3_geom_voronoiCells = null;\n    return diagram;\n  }\n  function d3_geom_voronoiVertexOrder(a, b) {\n    return b.y - a.y || b.x - a.x;\n  }\n  d3.geom.voronoi = function(points) {\n    var x = d3_geom_pointX, y = d3_geom_pointY, fx = x, fy = y, clipExtent = d3_geom_voronoiClipExtent;\n    if (points) return voronoi(points);\n    function voronoi(data) {\n      var polygons = new Array(data.length), x0 = clipExtent[0][0], y0 = clipExtent[0][1], x1 = clipExtent[1][0], y1 = clipExtent[1][1];\n      d3_geom_voronoi(sites(data), clipExtent).cells.forEach(function(cell, i) {\n        var edges = cell.edges, site = cell.site, polygon = polygons[i] = edges.length ? edges.map(function(e) {\n          var s = e.start();\n          return [ s.x, s.y ];\n        }) : site.x >= x0 && site.x <= x1 && site.y >= y0 && site.y <= y1 ? [ [ x0, y1 ], [ x1, y1 ], [ x1, y0 ], [ x0, y0 ] ] : [];\n        polygon.point = data[i];\n      });\n      return polygons;\n    }\n    function sites(data) {\n      return data.map(function(d, i) {\n        return {\n          x: Math.round(fx(d, i) / ) * ,\n          y: Math.round(fy(d, i) / ) * ,\n          i: i\n        };\n      });\n    }\n    voronoi.links = function(data) {\n      return d3_geom_voronoi(sites(data)).edges.filter(function(edge) {\n        return edge.l && edge.r;\n      }).map(function(edge) {\n        return {\n          source: data[edge.l.i],\n          target: data[edge.r.i]\n        };\n      });\n    };\n    voronoi.triangles = function(data) {\n      var triangles = [];\n      d3_geom_voronoi(sites(data)).cells.forEach(function(cell, i) {\n        var site = cell.site, edges = cell.edges.sort(d3_geom_voronoiHalfEdgeOrder), j = -1, m = edges.length, e0, s0, e1 = edges[m - 1].edge, s1 = e1.l === site ? e1.r : e1.l;\n        while (++j < m) {\n          e0 = e1;\n          s0 = s1;\n          e1 = edges[j].edge;\n          s1 = e1.l === site ? e1.r : e1.l;\n          if (i < s0.i && i < s1.i && d3_geom_voronoiTriangleArea(site, s0, s1) < 0) {\n            triangles.push([ data[i], data[s0.i], data[s1.i] ]);\n          }\n        }\n      });\n      return triangles;\n    };\n    voronoi.x = function(_) {\n      return arguments.length ? (fx = d3_functor(x = _), voronoi) : x;\n    };\n    voronoi.y = function(_) {\n      return arguments.length ? (fy = d3_functor(y = _), voronoi) : y;\n    };\n    voronoi.clipExtent = function(_) {\n      if (!arguments.length) return clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent;\n      clipExtent = _ == null ? d3_geom_voronoiClipExtent : _;\n      return voronoi;\n    };\n    voronoi.size = function(_) {\n      if (!arguments.length) return clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent && clipExtent[1];\n      return voronoi.clipExtent(_ && [ [ 0, 0 ], _ ]);\n    };\n    return voronoi;\n  };\n  var d3_geom_voronoiClipExtent = [ [ -1e6, -1e6 ], [ 1e6, 1e6 ] ];\n  function d3_geom_voronoiTriangleArea(a, b, c) {\n    return (a.x - c.x) * (b.y - a.y) - (a.x - b.x) * (c.y - a.y);\n  }\n  d3.geom.delaunay = function(vertices) {\n    return d3.geom.voronoi().triangles(vertices);\n  };\n  d3.geom.quadtree = function(points, x1, y1, x2, y2) {\n    var x = d3_geom_pointX, y = d3_geom_pointY, compat;\n    if (compat = arguments.length) {\n      x = d3_geom_quadtreeCompatX;\n      y = d3_geom_quadtreeCompatY;\n      if (compat === 3) {\n        y2 = y1;\n        x2 = x1;\n        y1 = x1 = 0;\n      }\n      return quadtree(points);\n    }\n    function quadtree(data) {\n      var d, fx = d3_functor(x), fy = d3_functor(y), xs, ys, i, n, x1_, y1_, x2_, y2_;\n      if (x1 != null) {\n        x1_ = x1, y1_ = y1, x2_ = x2, y2_ = y2;\n      } else {\n        x2_ = y2_ = -(x1_ = y1_ = Infinity);\n        xs = [], ys = [];\n        n = data.length;\n        if (compat) for (i = 0; i < n; ++i) {\n          d = data[i];\n          if (d.x < x1_) x1_ = d.x;\n          if (d.y < y1_) y1_ = d.y;\n          if (d.x > x2_) x2_ = d.x;\n          if (d.y > y2_) y2_ = d.y;\n          xs.push(d.x);\n          ys.push(d.y);\n        } else for (i = 0; i < n; ++i) {\n          var x_ = +fx(d = data[i], i), y_ = +fy(d, i);\n          if (x_ < x1_) x1_ = x_;\n          if (y_ < y1_) y1_ = y_;\n          if (x_ > x2_) x2_ = x_;\n          if (y_ > y2_) y2_ = y_;\n          xs.push(x_);\n          ys.push(y_);\n        }\n      }\n      var dx = x2_ - x1_, dy = y2_ - y1_;\n      if (dx > dy) y2_ = y1_ + dx; else x2_ = x1_ + dy;\n      function insert(n, d, x, y, x1, y1, x2, y2) {\n        if (isNaN(x) || isNaN(y)) return;\n        if (n.leaf) {\n          var nx = n.x, ny = n.y;\n          if (nx != null) {\n            if (abs(nx - x) + abs(ny - y) < .01) {\n              insertChild(n, d, x, y, x1, y1, x2, y2);\n            } else {\n              var nPoint = n.point;\n              n.x = n.y = n.point = null;\n              insertChild(n, nPoint, nx, ny, x1, y1, x2, y2);\n              insertChild(n, d, x, y, x1, y1, x2, y2);\n            }\n          } else {\n            n.x = x, n.y = y, n.point = d;\n          }\n        } else {\n          insertChild(n, d, x, y, x1, y1, x2, y2);\n        }\n      }\n      function insertChild(n, d, x, y, x1, y1, x2, y2) {\n        var xm = (x1 + x2) * .5, ym = (y1 + y2) * .5, right = x >= xm, below = y >= ym, i = below << 1 | right;\n        n.leaf = false;\n        n = n.nodes[i] || (n.nodes[i] = d3_geom_quadtreeNode());\n        if (right) x1 = xm; else x2 = xm;\n        if (below) y1 = ym; else y2 = ym;\n        insert(n, d, x, y, x1, y1, x2, y2);\n      }\n      var root = d3_geom_quadtreeNode();\n      root.add = function(d) {\n        insert(root, d, +fx(d, ++i), +fy(d, i), x1_, y1_, x2_, y2_);\n      };\n      root.visit = function(f) {\n        d3_geom_quadtreeVisit(f, root, x1_, y1_, x2_, y2_);\n      };\n      root.find = function(point) {\n        return d3_geom_quadtreeFind(root, point[0], point[1], x1_, y1_, x2_, y2_);\n      };\n      i = -1;\n      if (x1 == null) {\n        while (++i < n) {\n          insert(root, data[i], xs[i], ys[i], x1_, y1_, x2_, y2_);\n        }\n        --i;\n      } else data.forEach(root.add);\n      xs = ys = data = d = null;\n      return root;\n    }\n    quadtree.x = function(_) {\n      return arguments.length ? (x = _, quadtree) : x;\n    };\n    quadtree.y = function(_) {\n      return arguments.length ? (y = _, quadtree) : y;\n    };\n    quadtree.extent = function(_) {\n      if (!arguments.length) return x1 == null ? null : [ [ x1, y1 ], [ x2, y2 ] ];\n      if (_ == null) x1 = y1 = x2 = y2 = null; else x1 = +_[0][0], y1 = +_[0][1], x2 = +_[1][0], \n      y2 = +_[1][1];\n      return quadtree;\n    };\n    quadtree.size = function(_) {\n      if (!arguments.length) return x1 == null ? null : [ x2 - x1, y2 - y1 ];\n      if (_ == null) x1 = y1 = x2 = y2 = null; else x1 = y1 = 0, x2 = +_[0], y2 = +_[1];\n      return quadtree;\n    };\n    return quadtree;\n  };\n  function d3_geom_quadtreeCompatX(d) {\n    return d.x;\n  }\n  function d3_geom_quadtreeCompatY(d) {\n    return d.y;\n  }\n  function d3_geom_quadtreeNode() {\n    return {\n      leaf: true,\n      nodes: [],\n      point: null,\n      x: null,\n      y: null\n    };\n  }\n  function d3_geom_quadtreeVisit(f, node, x1, y1, x2, y2) {\n    if (!f(node, x1, y1, x2, y2)) {\n      var sx = (x1 + x2) * .5, sy = (y1 + y2) * .5, children = node.nodes;\n      if (children[0]) d3_geom_quadtreeVisit(f, children[0], x1, y1, sx, sy);\n      if (children[1]) d3_geom_quadtreeVisit(f, children[1], sx, y1, x2, sy);\n      if (children[2]) d3_geom_quadtreeVisit(f, children[2], x1, sy, sx, y2);\n      if (children[3]) d3_geom_quadtreeVisit(f, children[3], sx, sy, x2, y2);\n    }\n  }\n  function d3_geom_quadtreeFind(root, x, y, x0, y0, x3, y3) {\n    var minDistance2 = Infinity, closestPoint;\n    (function find(node, x1, y1, x2, y2) {\n      if (x1 > x3 || y1 > y3 || x2 < x0 || y2 < y0) return;\n      if (point = node.point) {\n        var point, dx = x - node.x, dy = y - node.y, distance2 = dx * dx + dy * dy;\n        if (distance2 < minDistance2) {\n          var distance = Math.sqrt(minDistance2 = distance2);\n          x0 = x - distance, y0 = y - distance;\n          x3 = x + distance, y3 = y + distance;\n          closestPoint = point;\n        }\n      }\n      var children = node.nodes, xm = (x1 + x2) * .5, ym = (y1 + y2) * .5, right = x >= xm, below = y >= ym;\n      for (var i = below << 1 | right, j = i + 4; i < j; ++i) {\n        if (node = children[i & 3]) switch (i & 3) {\n         case 0:\n          find(node, x1, y1, xm, ym);\n          break;\n\n         case 1:\n          find(node, xm, y1, x2, ym);\n          break;\n\n         case 2:\n          find(node, x1, ym, xm, y2);\n          break;\n\n         case 3:\n          find(node, xm, ym, x2, y2);\n          break;\n        }\n      }\n    })(root, x0, y0, x3, y3);\n    return closestPoint;\n  }\n  d3.interpolateRgb = d3_interpolateRgb;\n  function d3_interpolateRgb(a, b) {\n    a = d3.rgb(a);\n    b = d3.rgb(b);\n    var ar = a.r, ag = a.g, ab = a.b, br = b.r - ar, bg = b.g - ag, bb = b.b - ab;\n    return function(t) {\n      return \"#\" + d3_rgb_hex(Math.round(ar + br * t)) + d3_rgb_hex(Math.round(ag + bg * t)) + d3_rgb_hex(Math.round(ab + bb * t));\n    };\n  }\n  d3.interpolateObject = d3_interpolateObject;\n  function d3_interpolateObject(a, b) {\n    var i = {}, c = {}, k;\n    for (k in a) {\n      if (k in b) {\n        i[k] = d3_interpolate(a[k], b[k]);\n      } else {\n        c[k] = a[k];\n      }\n    }\n    for (k in b) {\n      if (!(k in a)) {\n        c[k] = b[k];\n      }\n    }\n    return function(t) {\n      for (k in i) c[k] = i[k](t);\n      return c;\n    };\n  }\n  d3.interpolateNumber = d3_interpolateNumber;\n  function d3_interpolateNumber(a, b) {\n    a = +a, b = +b;\n    return function(t) {\n      return a * (1 - t) + b * t;\n    };\n  }\n  d3.interpolateString = d3_interpolateString;\n  function d3_interpolateString(a, b) {\n    var bi = d3_interpolate_numberA.lastIndex = d3_interpolate_numberB.lastIndex = 0, am, bm, bs, i = -1, s = [], q = [];\n    a = a + \"\", b = b + \"\";\n    while ((am = d3_interpolate_numberA.exec(a)) && (bm = d3_interpolate_numberB.exec(b))) {\n      if ((bs = bm.index) > bi) {\n        bs = b.slice(bi, bs);\n        if (s[i]) s[i] += bs; else s[++i] = bs;\n      }\n      if ((am = am[0]) === (bm = bm[0])) {\n        if (s[i]) s[i] += bm; else s[++i] = bm;\n      } else {\n        s[++i] = null;\n        q.push({\n          i: i,\n          x: d3_interpolateNumber(am, bm)\n        });\n      }\n      bi = d3_interpolate_numberB.lastIndex;\n    }\n    if (bi < b.length) {\n      bs = b.slice(bi);\n      if (s[i]) s[i] += bs; else s[++i] = bs;\n    }\n    return s.length < 2 ? q[0] ? (b = q[0].x, function(t) {\n      return b(t) + \"\";\n    }) : function() {\n      return b;\n    } : (b = q.length, function(t) {\n      for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);\n      return s.join(\"\");\n    });\n  }\n  var d3_interpolate_numberA = /[-+]?(?:\\d+\\.?\\d*|\\.?\\d+)(?:[eE][-+]?\\d+)?/g, d3_interpolate_numberB = new RegExp(d3_interpolate_numberA.source, \"g\");\n  d3.interpolate = d3_interpolate;\n  function d3_interpolate(a, b) {\n    var i = d3.interpolators.length, f;\n    while (--i >= 0 && !(f = d3.interpolators[i](a, b))) ;\n    return f;\n  }\n  d3.interpolators = [ function(a, b) {\n    var t = typeof b;\n    return (t === \"string\" ? d3_rgb_names.has(b.toLowerCase()) || /^(#|rgb\\(|hsl\\()/i.test(b) ? d3_interpolateRgb : d3_interpolateString : b instanceof d3_color ? d3_interpolateRgb : Array.isArray(b) ? d3_interpolateArray : t === \"object\" && isNaN(b) ? d3_interpolateObject : d3_interpolateNumber)(a, b);\n  } ];\n  d3.interpolateArray = d3_interpolateArray;\n  function d3_interpolateArray(a, b) {\n    var x = [], c = [], na = a.length, nb = b.length, n0 = Math.min(a.length, b.length), i;\n    for (i = 0; i < n0; ++i) x.push(d3_interpolate(a[i], b[i]));\n    for (;i < na; ++i) c[i] = a[i];\n    for (;i < nb; ++i) c[i] = b[i];\n    return function(t) {\n      for (i = 0; i < n0; ++i) c[i] = x[i](t);\n      return c;\n    };\n  }\n  var d3_ease_default = function() {\n    return d3_identity;\n  };\n  var d3_ease = d3.map({\n    linear: d3_ease_default,\n    poly: d3_ease_poly,\n    quad: function() {\n      return d3_ease_quad;\n    },\n    cubic: function() {\n      return d3_ease_cubic;\n    },\n    sin: function() {\n      return d3_ease_sin;\n    },\n    exp: function() {\n      return d3_ease_exp;\n    },\n    circle: function() {\n      return d3_ease_circle;\n    },\n    elastic: d3_ease_elastic,\n    back: d3_ease_back,\n    bounce: function() {\n      return d3_ease_bounce;\n    }\n  });\n  var d3_ease_mode = d3.map({\n    \"in\": d3_identity,\n    out: d3_ease_reverse,\n    \"in-out\": d3_ease_reflect,\n    \"out-in\": function(f) {\n      return d3_ease_reflect(d3_ease_reverse(f));\n    }\n  });\n  d3.ease = function(name) {\n    var i = name.indexOf(\"-\"), t = i >= 0 ? name.slice(0, i) : name, m = i >= 0 ? name.slice(i + 1) : \"in\";\n    t = d3_ease.get(t) || d3_ease_default;\n    m = d3_ease_mode.get(m) || d3_identity;\n    return d3_ease_clamp(m(t.apply(null, d3_arraySlice.call(arguments, 1))));\n  };\n  function d3_ease_clamp(f) {\n    return function(t) {\n      return t <= 0 ? 0 : t >= 1 ? 1 : f(t);\n    };\n  }\n  function d3_ease_reverse(f) {\n    return function(t) {\n      return 1 - f(1 - t);\n    };\n  }\n  function d3_ease_reflect(f) {\n    return function(t) {\n      return .5 * (t < .5 ? f(2 * t) : 2 - f(2 - 2 * t));\n    };\n  }\n  function d3_ease_quad(t) {\n    return t * t;\n  }\n  function d3_ease_cubic(t) {\n    return t * t * t;\n  }\n  function d3_ease_cubicInOut(t) {\n    if (t <= 0) return 0;\n    if (t >= 1) return 1;\n    var t2 = t * t, t3 = t2 * t;\n    return 4 * (t < .5 ? t3 : 3 * (t - t2) + t3 - .75);\n  }\n  function d3_ease_poly(e) {\n    return function(t) {\n      return Math.pow(t, e);\n    };\n  }\n  function d3_ease_sin(t) {\n    return 1 - Math.cos(t * half);\n  }\n  function d3_ease_exp(t) {\n    return Math.pow(2, 10 * (t - 1));\n  }\n  function d3_ease_circle(t) {\n    return 1 - Math.sqrt(1 - t * t);\n  }\n  function d3_ease_elastic(a, p) {\n    var s;\n    if (arguments.length < 2) p = .45;\n    if (arguments.length) s = p /  * Math.asin(1 / a); else a = 1, s = p / 4;\n    return function(t) {\n      return 1 + a * Math.pow(2, -10 * t) * Math.sin((t - s) *  / p);\n    };\n  }\n  function d3_ease_back(s) {\n    if (!s) s = 1.70158;\n    return function(t) {\n      return t * t * ((s + 1) * t - s);\n    };\n  }\n  function d3_ease_bounce(t) {\n    return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375;\n  }\n  d3.interpolateHcl = d3_interpolateHcl;\n  function d3_interpolateHcl(a, b) {\n    a = d3.hcl(a);\n    b = d3.hcl(b);\n    var ah = a.h, ac = a.c, al = a.l, bh = b.h - ah, bc = b.c - ac, bl = b.l - al;\n    if (isNaN(bc)) bc = 0, ac = isNaN(ac) ? b.c : ac;\n    if (isNaN(bh)) bh = 0, ah = isNaN(ah) ? b.h : ah; else if (bh > 180) bh -= 360; else if (bh < -180) bh += 360;\n    return function(t) {\n      return d3_hcl_lab(ah + bh * t, ac + bc * t, al + bl * t) + \"\";\n    };\n  }\n  d3.interpolateHsl = d3_interpolateHsl;\n  function d3_interpolateHsl(a, b) {\n    a = d3.hsl(a);\n    b = d3.hsl(b);\n    var ah = a.h, as = a.s, al = a.l, bh = b.h - ah, bs = b.s - as, bl = b.l - al;\n    if (isNaN(bs)) bs = 0, as = isNaN(as) ? b.s : as;\n    if (isNaN(bh)) bh = 0, ah = isNaN(ah) ? b.h : ah; else if (bh > 180) bh -= 360; else if (bh < -180) bh += 360;\n    return function(t) {\n      return d3_hsl_rgb(ah + bh * t, as + bs * t, al + bl * t) + \"\";\n    };\n  }\n  d3.interpolateLab = d3_interpolateLab;\n  function d3_interpolateLab(a, b) {\n    a = d3.lab(a);\n    b = d3.lab(b);\n    var al = a.l, aa = a.a, ab = a.b, bl = b.l - al, ba = b.a - aa, bb = b.b - ab;\n    return function(t) {\n      return d3_lab_rgb(al + bl * t, aa + ba * t, ab + bb * t) + \"\";\n    };\n  }\n  d3.interpolateRound = d3_interpolateRound;\n  function d3_interpolateRound(a, b) {\n    b -= a;\n    return function(t) {\n      return Math.round(a + b * t);\n    };\n  }\n  d3.transform = function(string) {\n    var g = d3_document.createElementNS(d3.ns.prefix.svg, \"g\");\n    return (d3.transform = function(string) {\n      if (string != null) {\n        g.setAttribute(\"transform\", string);\n        var t = g.transform.baseVal.consolidate();\n      }\n      return new d3_transform(t ? t.matrix : d3_transformIdentity);\n    })(string);\n  };\n  function d3_transform(m) {\n    var r0 = [ m.a, m.b ], r1 = [ m.c, m.d ], kx = d3_transformNormalize(r0), kz = d3_transformDot(r0, r1), ky = d3_transformNormalize(d3_transformCombine(r1, r0, -kz)) || 0;\n    if (r0[0] * r1[1] < r1[0] * r0[1]) {\n      r0[0] *= -1;\n      r0[1] *= -1;\n      kx *= -1;\n      kz *= -1;\n    }\n    this.rotate = (kx ? Math.atan2(r0[1], r0[0]) : Math.atan2(-r1[0], r1[1])) * d3_degrees;\n    this.translate = [ m.e, m.f ];\n    this.scale = [ kx, ky ];\n    this.skew = ky ? Math.atan2(kz, ky) * d3_degrees : 0;\n  }\n  d3_transform.prototype.toString = function() {\n    return \"translate(\" + this.translate + \")rotate(\" + this.rotate + \")skewX(\" + this.skew + \")scale(\" + this.scale + \")\";\n  };\n  function d3_transformDot(a, b) {\n    return a[0] * b[0] + a[1] * b[1];\n  }\n  function d3_transformNormalize(a) {\n    var k = Math.sqrt(d3_transformDot(a, a));\n    if (k) {\n      a[0] /= k;\n      a[1] /= k;\n    }\n    return k;\n  }\n  function d3_transformCombine(a, b, k) {\n    a[0] += k * b[0];\n    a[1] += k * b[1];\n    return a;\n  }\n  var d3_transformIdentity = {\n    a: 1,\n    b: 0,\n    c: 0,\n    d: 1,\n    e: 0,\n    f: 0\n  };\n  d3.interpolateTransform = d3_interpolateTransform;\n  function d3_interpolateTransformPop(s) {\n    return s.length ? s.pop() + \",\" : \"\";\n  }\n  function d3_interpolateTranslate(ta, tb, s, q) {\n    if (ta[0] !== tb[0] || ta[1] !== tb[1]) {\n      var i = s.push(\"translate(\", null, \",\", null, \")\");\n      q.push({\n        i: i - 4,\n        x: d3_interpolateNumber(ta[0], tb[0])\n      }, {\n        i: i - 2,\n        x: d3_interpolateNumber(ta[1], tb[1])\n      });\n    } else if (tb[0] || tb[1]) {\n      s.push(\"translate(\" + tb + \")\");\n    }\n  }\n  function d3_interpolateRotate(ra, rb, s, q) {\n    if (ra !== rb) {\n      if (ra - rb > 180) rb += 360; else if (rb - ra > 180) ra += 360;\n      q.push({\n        i: s.push(d3_interpolateTransformPop(s) + \"rotate(\", null, \")\") - 2,\n        x: d3_interpolateNumber(ra, rb)\n      });\n    } else if (rb) {\n      s.push(d3_interpolateTransformPop(s) + \"rotate(\" + rb + \")\");\n    }\n  }\n  function d3_interpolateSkew(wa, wb, s, q) {\n    if (wa !== wb) {\n      q.push({\n        i: s.push(d3_interpolateTransformPop(s) + \"skewX(\", null, \")\") - 2,\n        x: d3_interpolateNumber(wa, wb)\n      });\n    } else if (wb) {\n      s.push(d3_interpolateTransformPop(s) + \"skewX(\" + wb + \")\");\n    }\n  }\n  function d3_interpolateScale(ka, kb, s, q) {\n    if (ka[0] !== kb[0] || ka[1] !== kb[1]) {\n      var i = s.push(d3_interpolateTransformPop(s) + \"scale(\", null, \",\", null, \")\");\n      q.push({\n        i: i - 4,\n        x: d3_interpolateNumber(ka[0], kb[0])\n      }, {\n        i: i - 2,\n        x: d3_interpolateNumber(ka[1], kb[1])\n      });\n    } else if (kb[0] !== 1 || kb[1] !== 1) {\n      s.push(d3_interpolateTransformPop(s) + \"scale(\" + kb + \")\");\n    }\n  }\n  function d3_interpolateTransform(a, b) {\n    var s = [], q = [];\n    a = d3.transform(a), b = d3.transform(b);\n    d3_interpolateTranslate(a.translate, b.translate, s, q);\n    d3_interpolateRotate(a.rotate, b.rotate, s, q);\n    d3_interpolateSkew(a.skew, b.skew, s, q);\n    d3_interpolateScale(a.scale, b.scale, s, q);\n    a = b = null;\n    return function(t) {\n      var i = -1, n = q.length, o;\n      while (++i < n) s[(o = q[i]).i] = o.x(t);\n      return s.join(\"\");\n    };\n  }\n  function d3_uninterpolateNumber(a, b) {\n    b = (b -= a = +a) || 1 / b;\n    return function(x) {\n      return (x - a) / b;\n    };\n  }\n  function d3_uninterpolateClamp(a, b) {\n    b = (b -= a = +a) || 1 / b;\n    return function(x) {\n      return Math.max(0, Math.min(1, (x - a) / b));\n    };\n  }\n  d3.layout = {};\n  d3.layout.bundle = function() {\n    return function(links) {\n      var paths = [], i = -1, n = links.length;\n      while (++i < n) paths.push(d3_layout_bundlePath(links[i]));\n      return paths;\n    };\n  };\n  function d3_layout_bundlePath(link) {\n    var start = link.source, end = link.target, lca = d3_layout_bundleLeastCommonAncestor(start, end), points = [ start ];\n    while (start !== lca) {\n      start = start.parent;\n      points.push(start);\n    }\n    var k = points.length;\n    while (end !== lca) {\n      points.splice(k, 0, end);\n      end = end.parent;\n    }\n    return points;\n  }\n  function d3_layout_bundleAncestors(node) {\n    var ancestors = [], parent = node.parent;\n    while (parent != null) {\n      ancestors.push(node);\n      node = parent;\n      parent = parent.parent;\n    }\n    ancestors.push(node);\n    return ancestors;\n  }\n  function d3_layout_bundleLeastCommonAncestor(a, b) {\n    if (a === b) return a;\n    var aNodes = d3_layout_bundleAncestors(a), bNodes = d3_layout_bundleAncestors(b), aNode = aNodes.pop(), bNode = bNodes.pop(), sharedNode = null;\n    while (aNode === bNode) {\n      sharedNode = aNode;\n      aNode = aNodes.pop();\n      bNode = bNodes.pop();\n    }\n    return sharedNode;\n  }\n  d3.layout.chord = function() {\n    var chord = {}, chords, groups, matrix, n, padding = 0, sortGroups, sortSubgroups, sortChords;\n    function relayout() {\n      var subgroups = {}, groupSums = [], groupIndex = d3.range(n), subgroupIndex = [], k, x, x0, i, j;\n      chords = [];\n      groups = [];\n      k = 0, i = -1;\n      while (++i < n) {\n        x = 0, j = -1;\n        while (++j < n) {\n          x += matrix[i][j];\n        }\n        groupSums.push(x);\n        subgroupIndex.push(d3.range(n));\n        k += x;\n      }\n      if (sortGroups) {\n        groupIndex.sort(function(a, b) {\n          return sortGroups(groupSums[a], groupSums[b]);\n        });\n      }\n      if (sortSubgroups) {\n        subgroupIndex.forEach(function(d, i) {\n          d.sort(function(a, b) {\n            return sortSubgroups(matrix[i][a], matrix[i][b]);\n          });\n        });\n      }\n      k = ( - padding * n) / k;\n      x = 0, i = -1;\n      while (++i < n) {\n        x0 = x, j = -1;\n        while (++j < n) {\n          var di = groupIndex[i], dj = subgroupIndex[di][j], v = matrix[di][dj], a0 = x, a1 = x += v * k;\n          subgroups[di + \"-\" + dj] = {\n            index: di,\n            subindex: dj,\n            startAngle: a0,\n            endAngle: a1,\n            value: v\n          };\n        }\n        groups[di] = {\n          index: di,\n          startAngle: x0,\n          endAngle: x,\n          value: groupSums[di]\n        };\n        x += padding;\n      }\n      i = -1;\n      while (++i < n) {\n        j = i - 1;\n        while (++j < n) {\n          var source = subgroups[i + \"-\" + j], target = subgroups[j + \"-\" + i];\n          if (source.value || target.value) {\n            chords.push(source.value < target.value ? {\n              source: target,\n              target: source\n            } : {\n              source: source,\n              target: target\n            });\n          }\n        }\n      }\n      if (sortChords) resort();\n    }\n    function resort() {\n      chords.sort(function(a, b) {\n        return sortChords((a.source.value + a.target.value) / 2, (b.source.value + b.target.value) / 2);\n      });\n    }\n    chord.matrix = function(x) {\n      if (!arguments.length) return matrix;\n      n = (matrix = x) && matrix.length;\n      chords = groups = null;\n      return chord;\n    };\n    chord.padding = function(x) {\n      if (!arguments.length) return padding;\n      padding = x;\n      chords = groups = null;\n      return chord;\n    };\n    chord.sortGroups = function(x) {\n      if (!arguments.length) return sortGroups;\n      sortGroups = x;\n      chords = groups = null;\n      return chord;\n    };\n    chord.sortSubgroups = function(x) {\n      if (!arguments.length) return sortSubgroups;\n      sortSubgroups = x;\n      chords = null;\n      return chord;\n    };\n    chord.sortChords = function(x) {\n      if (!arguments.length) return sortChords;\n      sortChords = x;\n      if (chords) resort();\n      return chord;\n    };\n    chord.chords = function() {\n      if (!chords) relayout();\n      return chords;\n    };\n    chord.groups = function() {\n      if (!groups) relayout();\n      return groups;\n    };\n    return chord;\n  };\n  d3.layout.force = function() {\n    var force = {}, event = d3.dispatch(\"start\", \"tick\", \"end\"), timer, size = [ 1, 1 ], drag, alpha, friction = .9, linkDistance = d3_layout_forceLinkDistance, linkStrength = d3_layout_forceLinkStrength, charge = -30, chargeDistance2 = d3_layout_forceChargeDistance2, gravity = .1, theta2 = .64, nodes = [], links = [], distances, strengths, charges;\n    function repulse(node) {\n      return function(quad, x1, _, x2) {\n        if (quad.point !== node) {\n          var dx = quad.cx - node.x, dy = quad.cy - node.y, dw = x2 - x1, dn = dx * dx + dy * dy;\n          if (dw * dw / theta2 < dn) {\n            if (dn < chargeDistance2) {\n              var k = quad.charge / dn;\n              node.px -= dx * k;\n              node.py -= dy * k;\n            }\n            return true;\n          }\n          if (quad.point && dn && dn < chargeDistance2) {\n            var k = quad.pointCharge / dn;\n            node.px -= dx * k;\n            node.py -= dy * k;\n          }\n        }\n        return !quad.charge;\n      };\n    }\n    force.tick = function() {\n      if ((alpha *= .99) < .005) {\n        timer = null;\n        event.end({\n          type: \"end\",\n          alpha: alpha = 0\n        });\n        return true;\n      }\n      var n = nodes.length, m = links.length, q, i, o, s, t, l, k, x, y;\n      for (i = 0; i < m; ++i) {\n        o = links[i];\n        s = o.source;\n        t = o.target;\n        x = t.x - s.x;\n        y = t.y - s.y;\n        if (l = x * x + y * y) {\n          l = alpha * strengths[i] * ((l = Math.sqrt(l)) - distances[i]) / l;\n          x *= l;\n          y *= l;\n          t.x -= x * (k = s.weight + t.weight ? s.weight / (s.weight + t.weight) : .5);\n          t.y -= y * k;\n          s.x += x * (k = 1 - k);\n          s.y += y * k;\n        }\n      }\n      if (k = alpha * gravity) {\n        x = size[0] / 2;\n        y = size[1] / 2;\n        i = -1;\n        if (k) while (++i < n) {\n          o = nodes[i];\n          o.x += (x - o.x) * k;\n          o.y += (y - o.y) * k;\n        }\n      }\n      if (charge) {\n        d3_layout_forceAccumulate(q = d3.geom.quadtree(nodes), alpha, charges);\n        i = -1;\n        while (++i < n) {\n          if (!(o = nodes[i]).fixed) {\n            q.visit(repulse(o));\n          }\n        }\n      }\n      i = -1;\n      while (++i < n) {\n        o = nodes[i];\n        if (o.fixed) {\n          o.x = o.px;\n          o.y = o.py;\n        } else {\n          o.x -= (o.px - (o.px = o.x)) * friction;\n          o.y -= (o.py - (o.py = o.y)) * friction;\n        }\n      }\n      event.tick({\n        type: \"tick\",\n        alpha: alpha\n      });\n    };\n    force.nodes = function(x) {\n      if (!arguments.length) return nodes;\n      nodes = x;\n      return force;\n    };\n    force.links = function(x) {\n      if (!arguments.length) return links;\n      links = x;\n      return force;\n    };\n    force.size = function(x) {\n      if (!arguments.length) return size;\n      size = x;\n      return force;\n    };\n    force.linkDistance = function(x) {\n      if (!arguments.length) return linkDistance;\n      linkDistance = typeof x === \"function\" ? x : +x;\n      return force;\n    };\n    force.distance = force.linkDistance;\n    force.linkStrength = function(x) {\n      if (!arguments.length) return linkStrength;\n      linkStrength = typeof x === \"function\" ? x : +x;\n      return force;\n    };\n    force.friction = function(x) {\n      if (!arguments.length) return friction;\n      friction = +x;\n      return force;\n    };\n    force.charge = function(x) {\n      if (!arguments.length) return charge;\n      charge = typeof x === \"function\" ? x : +x;\n      return force;\n    };\n    force.chargeDistance = function(x) {\n      if (!arguments.length) return Math.sqrt(chargeDistance2);\n      chargeDistance2 = x * x;\n      return force;\n    };\n    force.gravity = function(x) {\n      if (!arguments.length) return gravity;\n      gravity = +x;\n      return force;\n    };\n    force.theta = function(x) {\n      if (!arguments.length) return Math.sqrt(theta2);\n      theta2 = x * x;\n      return force;\n    };\n    force.alpha = function(x) {\n      if (!arguments.length) return alpha;\n      x = +x;\n      if (alpha) {\n        if (x > 0) {\n          alpha = x;\n        } else {\n          timer.c = null, timer.t = NaN, timer = null;\n          event.end({\n            type: \"end\",\n            alpha: alpha = 0\n          });\n        }\n      } else if (x > 0) {\n        event.start({\n          type: \"start\",\n          alpha: alpha = x\n        });\n        timer = d3_timer(force.tick);\n      }\n      return force;\n    };\n    force.start = function() {\n      var i, n = nodes.length, m = links.length, w = size[0], h = size[1], neighbors, o;\n      for (i = 0; i < n; ++i) {\n        (o = nodes[i]).index = i;\n        o.weight = 0;\n      }\n      for (i = 0; i < m; ++i) {\n        o = links[i];\n        if (typeof o.source == \"number\") o.source = nodes[o.source];\n        if (typeof o.target == \"number\") o.target = nodes[o.target];\n        ++o.source.weight;\n        ++o.target.weight;\n      }\n      for (i = 0; i < n; ++i) {\n        o = nodes[i];\n        if (isNaN(o.x)) o.x = position(\"x\", w);\n        if (isNaN(o.y)) o.y = position(\"y\", h);\n        if (isNaN(o.px)) o.px = o.x;\n        if (isNaN(o.py)) o.py = o.y;\n      }\n      distances = [];\n      if (typeof linkDistance === \"function\") for (i = 0; i < m; ++i) distances[i] = +linkDistance.call(this, links[i], i); else for (i = 0; i < m; ++i) distances[i] = linkDistance;\n      strengths = [];\n      if (typeof linkStrength === \"function\") for (i = 0; i < m; ++i) strengths[i] = +linkStrength.call(this, links[i], i); else for (i = 0; i < m; ++i) strengths[i] = linkStrength;\n      charges = [];\n      if (typeof charge === \"function\") for (i = 0; i < n; ++i) charges[i] = +charge.call(this, nodes[i], i); else for (i = 0; i < n; ++i) charges[i] = charge;\n      function position(dimension, size) {\n        if (!neighbors) {\n          neighbors = new Array(n);\n          for (j = 0; j < n; ++j) {\n            neighbors[j] = [];\n          }\n          for (j = 0; j < m; ++j) {\n            var o = links[j];\n            neighbors[o.source.index].push(o.target);\n            neighbors[o.target.index].push(o.source);\n          }\n        }\n        var candidates = neighbors[i], j = -1, l = candidates.length, x;\n        while (++j < l) if (!isNaN(x = candidates[j][dimension])) return x;\n        return Math.random() * size;\n      }\n      return force.resume();\n    };\n    force.resume = function() {\n      return force.alpha(.1);\n    };\n    force.stop = function() {\n      return force.alpha(0);\n    };\n    force.drag = function() {\n      if (!drag) drag = d3.behavior.drag().origin(d3_identity).on(\"dragstart.force\", d3_layout_forceDragstart).on(\"drag.force\", dragmove).on(\"dragend.force\", d3_layout_forceDragend);\n      if (!arguments.length) return drag;\n      this.on(\"mouseover.force\", d3_layout_forceMouseover).on(\"mouseout.force\", d3_layout_forceMouseout).call(drag);\n    };\n    function dragmove(d) {\n      d.px = d3.event.x, d.py = d3.event.y;\n      force.resume();\n    }\n    return d3.rebind(force, event, \"on\");\n  };\n  function d3_layout_forceDragstart(d) {\n    d.fixed |= 2;\n  }\n  function d3_layout_forceDragend(d) {\n    d.fixed &= ~6;\n  }\n  function d3_layout_forceMouseover(d) {\n    d.fixed |= 4;\n    d.px = d.x, d.py = d.y;\n  }\n  function d3_layout_forceMouseout(d) {\n    d.fixed &= ~4;\n  }\n  function d3_layout_forceAccumulate(quad, alpha, charges) {\n    var cx = 0, cy = 0;\n    quad.charge = 0;\n    if (!quad.leaf) {\n      var nodes = quad.nodes, n = nodes.length, i = -1, c;\n      while (++i < n) {\n        c = nodes[i];\n        if (c == null) continue;\n        d3_layout_forceAccumulate(c, alpha, charges);\n        quad.charge += c.charge;\n        cx += c.charge * c.cx;\n        cy += c.charge * c.cy;\n      }\n    }\n    if (quad.point) {\n      if (!quad.leaf) {\n        quad.point.x += Math.random() - .5;\n        quad.point.y += Math.random() - .5;\n      }\n      var k = alpha * charges[quad.point.index];\n      quad.charge += quad.pointCharge = k;\n      cx += k * quad.point.x;\n      cy += k * quad.point.y;\n    }\n    quad.cx = cx / quad.charge;\n    quad.cy = cy / quad.charge;\n  }\n  var d3_layout_forceLinkDistance = 20, d3_layout_forceLinkStrength = 1, d3_layout_forceChargeDistance2 = Infinity;\n  d3.layout.hierarchy = function() {\n    var sort = d3_layout_hierarchySort, children = d3_layout_hierarchyChildren, value = d3_layout_hierarchyValue;\n    function hierarchy(root) {\n      var stack = [ root ], nodes = [], node;\n      root.depth = 0;\n      while ((node = stack.pop()) != null) {\n        nodes.push(node);\n        if ((childs = children.call(hierarchy, node, node.depth)) && (n = childs.length)) {\n          var n, childs, child;\n          while (--n >= 0) {\n            stack.push(child = childs[n]);\n            child.parent = node;\n            child.depth = node.depth + 1;\n          }\n          if (value) node.value = 0;\n          node.children = childs;\n        } else {\n          if (value) node.value = +value.call(hierarchy, node, node.depth) || 0;\n          delete node.children;\n        }\n      }\n      d3_layout_hierarchyVisitAfter(root, function(node) {\n        var childs, parent;\n        if (sort && (childs = node.children)) childs.sort(sort);\n        if (value && (parent = node.parent)) parent.value += node.value;\n      });\n      return nodes;\n    }\n    hierarchy.sort = function(x) {\n      if (!arguments.length) return sort;\n      sort = x;\n      return hierarchy;\n    };\n    hierarchy.children = function(x) {\n      if (!arguments.length) return children;\n      children = x;\n      return hierarchy;\n    };\n    hierarchy.value = function(x) {\n      if (!arguments.length) return value;\n      value = x;\n      return hierarchy;\n    };\n    hierarchy.revalue = function(root) {\n      if (value) {\n        d3_layout_hierarchyVisitBefore(root, function(node) {\n          if (node.children) node.value = 0;\n        });\n        d3_layout_hierarchyVisitAfter(root, function(node) {\n          var parent;\n          if (!node.children) node.value = +value.call(hierarchy, node, node.depth) || 0;\n          if (parent = node.parent) parent.value += node.value;\n        });\n      }\n      return root;\n    };\n    return hierarchy;\n  };\n  function d3_layout_hierarchyRebind(object, hierarchy) {\n    d3.rebind(object, hierarchy, \"sort\", \"children\", \"value\");\n    object.nodes = object;\n    object.links = d3_layout_hierarchyLinks;\n    return object;\n  }\n  function d3_layout_hierarchyVisitBefore(node, callback) {\n    var nodes = [ node ];\n    while ((node = nodes.pop()) != null) {\n      callback(node);\n      if ((children = node.children) && (n = children.length)) {\n        var n, children;\n        while (--n >= 0) nodes.push(children[n]);\n      }\n    }\n  }\n  function d3_layout_hierarchyVisitAfter(node, callback) {\n    var nodes = [ node ], nodes2 = [];\n    while ((node = nodes.pop()) != null) {\n      nodes2.push(node);\n      if ((children = node.children) && (n = children.length)) {\n        var i = -1, n, children;\n        while (++i < n) nodes.push(children[i]);\n      }\n    }\n    while ((node = nodes2.pop()) != null) {\n      callback(node);\n    }\n  }\n  function d3_layout_hierarchyChildren(d) {\n    return d.children;\n  }\n  function d3_layout_hierarchyValue(d) {\n    return d.value;\n  }\n  function d3_layout_hierarchySort(a, b) {\n    return b.value - a.value;\n  }\n  function d3_layout_hierarchyLinks(nodes) {\n    return d3.merge(nodes.map(function(parent) {\n      return (parent.children || []).map(function(child) {\n        return {\n          source: parent,\n          target: child\n        };\n      });\n    }));\n  }\n  d3.layout.partition = function() {\n    var hierarchy = d3.layout.hierarchy(), size = [ 1, 1 ];\n    function position(node, x, dx, dy) {\n      var children = node.children;\n      node.x = x;\n      node.y = node.depth * dy;\n      node.dx = dx;\n      node.dy = dy;\n      if (children && (n = children.length)) {\n        var i = -1, n, c, d;\n        dx = node.value ? dx / node.value : 0;\n        while (++i < n) {\n          position(c = children[i], x, d = c.value * dx, dy);\n          x += d;\n        }\n      }\n    }\n    function depth(node) {\n      var children = node.children, d = 0;\n      if (children && (n = children.length)) {\n        var i = -1, n;\n        while (++i < n) d = Math.max(d, depth(children[i]));\n      }\n      return 1 + d;\n    }\n    function partition(d, i) {\n      var nodes = hierarchy.call(this, d, i);\n      position(nodes[0], 0, size[0], size[1] / depth(nodes[0]));\n      return nodes;\n    }\n    partition.size = function(x) {\n      if (!arguments.length) return size;\n      size = x;\n      return partition;\n    };\n    return d3_layout_hierarchyRebind(partition, hierarchy);\n  };\n  d3.layout.pie = function() {\n    var value = Number, sort = d3_layout_pieSortByValue, startAngle = 0, endAngle = , padAngle = 0;\n    function pie(data) {\n      var n = data.length, values = data.map(function(d, i) {\n        return +value.call(pie, d, i);\n      }), a = +(typeof startAngle === \"function\" ? startAngle.apply(this, arguments) : startAngle), da = (typeof endAngle === \"function\" ? endAngle.apply(this, arguments) : endAngle) - a, p = Math.min(Math.abs(da) / n, +(typeof padAngle === \"function\" ? padAngle.apply(this, arguments) : padAngle)), pa = p * (da < 0 ? -1 : 1), sum = d3.sum(values), k = sum ? (da - n * pa) / sum : 0, index = d3.range(n), arcs = [], v;\n      if (sort != null) index.sort(sort === d3_layout_pieSortByValue ? function(i, j) {\n        return values[j] - values[i];\n      } : function(i, j) {\n        return sort(data[i], data[j]);\n      });\n      index.forEach(function(i) {\n        arcs[i] = {\n          data: data[i],\n          value: v = values[i],\n          startAngle: a,\n          endAngle: a += v * k + pa,\n          padAngle: p\n        };\n      });\n      return arcs;\n    }\n    pie.value = function(_) {\n      if (!arguments.length) return value;\n      value = _;\n      return pie;\n    };\n    pie.sort = function(_) {\n      if (!arguments.length) return sort;\n      sort = _;\n      return pie;\n    };\n    pie.startAngle = function(_) {\n      if (!arguments.length) return startAngle;\n      startAngle = _;\n      return pie;\n    };\n    pie.endAngle = function(_) {\n      if (!arguments.length) return endAngle;\n      endAngle = _;\n      return pie;\n    };\n    pie.padAngle = function(_) {\n      if (!arguments.length) return padAngle;\n      padAngle = _;\n      return pie;\n    };\n    return pie;\n  };\n  var d3_layout_pieSortByValue = {};\n  d3.layout.stack = function() {\n    var values = d3_identity, order = d3_layout_stackOrderDefault, offset = d3_layout_stackOffsetZero, out = d3_layout_stackOut, x = d3_layout_stackX, y = d3_layout_stackY;\n    function stack(data, index) {\n      if (!(n = data.length)) return data;\n      var series = data.map(function(d, i) {\n        return values.call(stack, d, i);\n      });\n      var points = series.map(function(d) {\n        return d.map(function(v, i) {\n          return [ x.call(stack, v, i), y.call(stack, v, i) ];\n        });\n      });\n      var orders = order.call(stack, points, index);\n      series = d3.permute(series, orders);\n      points = d3.permute(points, orders);\n      var offsets = offset.call(stack, points, index);\n      var m = series[0].length, n, i, j, o;\n      for (j = 0; j < m; ++j) {\n        out.call(stack, series[0][j], o = offsets[j], points[0][j][1]);\n        for (i = 1; i < n; ++i) {\n          out.call(stack, series[i][j], o += points[i - 1][j][1], points[i][j][1]);\n        }\n      }\n      return data;\n    }\n    stack.values = function(x) {\n      if (!arguments.length) return values;\n      values = x;\n      return stack;\n    };\n    stack.order = function(x) {\n      if (!arguments.length) return order;\n      order = typeof x === \"function\" ? x : d3_layout_stackOrders.get(x) || d3_layout_stackOrderDefault;\n      return stack;\n    };\n    stack.offset = function(x) {\n      if (!arguments.length) return offset;\n      offset = typeof x === \"function\" ? x : d3_layout_stackOffsets.get(x) || d3_layout_stackOffsetZero;\n      return stack;\n    };\n    stack.x = function(z) {\n      if (!arguments.length) return x;\n      x = z;\n      return stack;\n    };\n    stack.y = function(z) {\n      if (!arguments.length) return y;\n      y = z;\n      return stack;\n    };\n    stack.out = function(z) {\n      if (!arguments.length) return out;\n      out = z;\n      return stack;\n    };\n    return stack;\n  };\n  function d3_layout_stackX(d) {\n    return d.x;\n  }\n  function d3_layout_stackY(d) {\n    return d.y;\n  }\n  function d3_layout_stackOut(d, y0, y) {\n    d.y0 = y0;\n    d.y = y;\n  }\n  var d3_layout_stackOrders = d3.map({\n    \"inside-out\": function(data) {\n      var n = data.length, i, j, max = data.map(d3_layout_stackMaxIndex), sums = data.map(d3_layout_stackReduceSum), index = d3.range(n).sort(function(a, b) {\n        return max[a] - max[b];\n      }), top = 0, bottom = 0, tops = [], bottoms = [];\n      for (i = 0; i < n; ++i) {\n        j = index[i];\n        if (top < bottom) {\n          top += sums[j];\n          tops.push(j);\n        } else {\n          bottom += sums[j];\n          bottoms.push(j);\n        }\n      }\n      return bottoms.reverse().concat(tops);\n    },\n    reverse: function(data) {\n      return d3.range(data.length).reverse();\n    },\n    \"default\": d3_layout_stackOrderDefault\n  });\n  var d3_layout_stackOffsets = d3.map({\n    silhouette: function(data) {\n      var n = data.length, m = data[0].length, sums = [], max = 0, i, j, o, y0 = [];\n      for (j = 0; j < m; ++j) {\n        for (i = 0, o = 0; i < n; i++) o += data[i][j][1];\n        if (o > max) max = o;\n        sums.push(o);\n      }\n      for (j = 0; j < m; ++j) {\n        y0[j] = (max - sums[j]) / 2;\n      }\n      return y0;\n    },\n    wiggle: function(data) {\n      var n = data.length, x = data[0], m = x.length, i, j, k, s1, s2, s3, dx, o, o0, y0 = [];\n      y0[0] = o = o0 = 0;\n      for (j = 1; j < m; ++j) {\n        for (i = 0, s1 = 0; i < n; ++i) s1 += data[i][j][1];\n        for (i = 0, s2 = 0, dx = x[j][0] - x[j - 1][0]; i < n; ++i) {\n          for (k = 0, s3 = (data[i][j][1] - data[i][j - 1][1]) / (2 * dx); k < i; ++k) {\n            s3 += (data[k][j][1] - data[k][j - 1][1]) / dx;\n          }\n          s2 += s3 * data[i][j][1];\n        }\n        y0[j] = o -= s1 ? s2 / s1 * dx : 0;\n        if (o < o0) o0 = o;\n      }\n      for (j = 0; j < m; ++j) y0[j] -= o0;\n      return y0;\n    },\n    expand: function(data) {\n      var n = data.length, m = data[0].length, k = 1 / n, i, j, o, y0 = [];\n      for (j = 0; j < m; ++j) {\n        for (i = 0, o = 0; i < n; i++) o += data[i][j][1];\n        if (o) for (i = 0; i < n; i++) data[i][j][1] /= o; else for (i = 0; i < n; i++) data[i][j][1] = k;\n      }\n      for (j = 0; j < m; ++j) y0[j] = 0;\n      return y0;\n    },\n    zero: d3_layout_stackOffsetZero\n  });\n  function d3_layout_stackOrderDefault(data) {\n    return d3.range(data.length);\n  }\n  function d3_layout_stackOffsetZero(data) {\n    var j = -1, m = data[0].length, y0 = [];\n    while (++j < m) y0[j] = 0;\n    return y0;\n  }\n  function d3_layout_stackMaxIndex(array) {\n    var i = 1, j = 0, v = array[0][1], k, n = array.length;\n    for (;i < n; ++i) {\n      if ((k = array[i][1]) > v) {\n        j = i;\n        v = k;\n      }\n    }\n    return j;\n  }\n  function d3_layout_stackReduceSum(d) {\n    return d.reduce(d3_layout_stackSum, 0);\n  }\n  function d3_layout_stackSum(p, d) {\n    return p + d[1];\n  }\n  d3.layout.histogram = function() {\n    var frequency = true, valuer = Number, ranger = d3_layout_histogramRange, binner = d3_layout_histogramBinSturges;\n    function histogram(data, i) {\n      var bins = [], values = data.map(valuer, this), range = ranger.call(this, values, i), thresholds = binner.call(this, range, values, i), bin, i = -1, n = values.length, m = thresholds.length - 1, k = frequency ? 1 : 1 / n, x;\n      while (++i < m) {\n        bin = bins[i] = [];\n        bin.dx = thresholds[i + 1] - (bin.x = thresholds[i]);\n        bin.y = 0;\n      }\n      if (m > 0) {\n        i = -1;\n        while (++i < n) {\n          x = values[i];\n          if (x >= range[0] && x <= range[1]) {\n            bin = bins[d3.bisect(thresholds, x, 1, m) - 1];\n            bin.y += k;\n            bin.push(data[i]);\n          }\n        }\n      }\n      return bins;\n    }\n    histogram.value = function(x) {\n      if (!arguments.length) return valuer;\n      valuer = x;\n      return histogram;\n    };\n    histogram.range = function(x) {\n      if (!arguments.length) return ranger;\n      ranger = d3_functor(x);\n      return histogram;\n    };\n    histogram.bins = function(x) {\n      if (!arguments.length) return binner;\n      binner = typeof x === \"number\" ? function(range) {\n        return d3_layout_histogramBinFixed(range, x);\n      } : d3_functor(x);\n      return histogram;\n    };\n    histogram.frequency = function(x) {\n      if (!arguments.length) return frequency;\n      frequency = !!x;\n      return histogram;\n    };\n    return histogram;\n  };\n  function d3_layout_histogramBinSturges(range, values) {\n    return d3_layout_histogramBinFixed(range, Math.ceil(Math.log(values.length) / Math.LN2 + 1));\n  }\n  function d3_layout_histogramBinFixed(range, n) {\n    var x = -1, b = +range[0], m = (range[1] - b) / n, f = [];\n    while (++x <= n) f[x] = m * x + b;\n    return f;\n  }\n  function d3_layout_histogramRange(values) {\n    return [ d3.min(values), d3.max(values) ];\n  }\n  d3.layout.pack = function() {\n    var hierarchy = d3.layout.hierarchy().sort(d3_layout_packSort), padding = 0, size = [ 1, 1 ], radius;\n    function pack(d, i) {\n      var nodes = hierarchy.call(this, d, i), root = nodes[0], w = size[0], h = size[1], r = radius == null ? Math.sqrt : typeof radius === \"function\" ? radius : function() {\n        return radius;\n      };\n      root.x = root.y = 0;\n      d3_layout_hierarchyVisitAfter(root, function(d) {\n        d.r = +r(d.value);\n      });\n      d3_layout_hierarchyVisitAfter(root, d3_layout_packSiblings);\n      if (padding) {\n        var dr = padding * (radius ? 1 : Math.max(2 * root.r / w, 2 * root.r / h)) / 2;\n        d3_layout_hierarchyVisitAfter(root, function(d) {\n          d.r += dr;\n        });\n        d3_layout_hierarchyVisitAfter(root, d3_layout_packSiblings);\n        d3_layout_hierarchyVisitAfter(root, function(d) {\n          d.r -= dr;\n        });\n      }\n      d3_layout_packTransform(root, w / 2, h / 2, radius ? 1 : 1 / Math.max(2 * root.r / w, 2 * root.r / h));\n      return nodes;\n    }\n    pack.size = function(_) {\n      if (!arguments.length) return size;\n      size = _;\n      return pack;\n    };\n    pack.radius = function(_) {\n      if (!arguments.length) return radius;\n      radius = _ == null || typeof _ === \"function\" ? _ : +_;\n      return pack;\n    };\n    pack.padding = function(_) {\n      if (!arguments.length) return padding;\n      padding = +_;\n      return pack;\n    };\n    return d3_layout_hierarchyRebind(pack, hierarchy);\n  };\n  function d3_layout_packSort(a, b) {\n    return a.value - b.value;\n  }\n  function d3_layout_packInsert(a, b) {\n    var c = a._pack_next;\n    a._pack_next = b;\n    b._pack_prev = a;\n    b._pack_next = c;\n    c._pack_prev = b;\n  }\n  function d3_layout_packSplice(a, b) {\n    a._pack_next = b;\n    b._pack_prev = a;\n  }\n  function d3_layout_packIntersects(a, b) {\n    var dx = b.x - a.x, dy = b.y - a.y, dr = a.r + b.r;\n    return .999 * dr * dr > dx * dx + dy * dy;\n  }\n  function d3_layout_packSiblings(node) {\n    if (!(nodes = node.children) || !(n = nodes.length)) return;\n    var nodes, xMin = Infinity, xMax = -Infinity, yMin = Infinity, yMax = -Infinity, a, b, c, i, j, k, n;\n    function bound(node) {\n      xMin = Math.min(node.x - node.r, xMin);\n      xMax = Math.max(node.x + node.r, xMax);\n      yMin = Math.min(node.y - node.r, yMin);\n      yMax = Math.max(node.y + node.r, yMax);\n    }\n    nodes.forEach(d3_layout_packLink);\n    a = nodes[0];\n    a.x = -a.r;\n    a.y = 0;\n    bound(a);\n    if (n > 1) {\n      b = nodes[1];\n      b.x = b.r;\n      b.y = 0;\n      bound(b);\n      if (n > 2) {\n        c = nodes[2];\n        d3_layout_packPlace(a, b, c);\n        bound(c);\n        d3_layout_packInsert(a, c);\n        a._pack_prev = c;\n        d3_layout_packInsert(c, b);\n        b = a._pack_next;\n        for (i = 3; i < n; i++) {\n          d3_layout_packPlace(a, b, c = nodes[i]);\n          var isect = 0, s1 = 1, s2 = 1;\n          for (j = b._pack_next; j !== b; j = j._pack_next, s1++) {\n            if (d3_layout_packIntersects(j, c)) {\n              isect = 1;\n              break;\n            }\n          }\n          if (isect == 1) {\n            for (k = a._pack_prev; k !== j._pack_prev; k = k._pack_prev, s2++) {\n              if (d3_layout_packIntersects(k, c)) {\n                break;\n              }\n            }\n          }\n          if (isect) {\n            if (s1 < s2 || s1 == s2 && b.r < a.r) d3_layout_packSplice(a, b = j); else d3_layout_packSplice(a = k, b);\n            i--;\n          } else {\n            d3_layout_packInsert(a, c);\n            b = c;\n            bound(c);\n          }\n        }\n      }\n    }\n    var cx = (xMin + xMax) / 2, cy = (yMin + yMax) / 2, cr = 0;\n    for (i = 0; i < n; i++) {\n      c = nodes[i];\n      c.x -= cx;\n      c.y -= cy;\n      cr = Math.max(cr, c.r + Math.sqrt(c.x * c.x + c.y * c.y));\n    }\n    node.r = cr;\n    nodes.forEach(d3_layout_packUnlink);\n  }\n  function d3_layout_packLink(node) {\n    node._pack_next = node._pack_prev = node;\n  }\n  function d3_layout_packUnlink(node) {\n    delete node._pack_next;\n    delete node._pack_prev;\n  }\n  function d3_layout_packTransform(node, x, y, k) {\n    var children = node.children;\n    node.x = x += k * node.x;\n    node.y = y += k * node.y;\n    node.r *= k;\n    if (children) {\n      var i = -1, n = children.length;\n      while (++i < n) d3_layout_packTransform(children[i], x, y, k);\n    }\n  }\n  function d3_layout_packPlace(a, b, c) {\n    var db = a.r + c.r, dx = b.x - a.x, dy = b.y - a.y;\n    if (db && (dx || dy)) {\n      var da = b.r + c.r, dc = dx * dx + dy * dy;\n      da *= da;\n      db *= db;\n      var x = .5 + (db - da) / (2 * dc), y = Math.sqrt(Math.max(0, 2 * da * (db + dc) - (db -= dc) * db - da * da)) / (2 * dc);\n      c.x = a.x + x * dx + y * dy;\n      c.y = a.y + x * dy - y * dx;\n    } else {\n      c.x = a.x + db;\n      c.y = a.y;\n    }\n  }\n  d3.layout.tree = function() {\n    var hierarchy = d3.layout.hierarchy().sort(null).value(null), separation = d3_layout_treeSeparation, size = [ 1, 1 ], nodeSize = null;\n    function tree(d, i) {\n      var nodes = hierarchy.call(this, d, i), root0 = nodes[0], root1 = wrapTree(root0);\n      d3_layout_hierarchyVisitAfter(root1, firstWalk), root1.parent.m = -root1.z;\n      d3_layout_hierarchyVisitBefore(root1, secondWalk);\n      if (nodeSize) d3_layout_hierarchyVisitBefore(root0, sizeNode); else {\n        var left = root0, right = root0, bottom = root0;\n        d3_layout_hierarchyVisitBefore(root0, function(node) {\n          if (node.x < left.x) left = node;\n          if (node.x > right.x) right = node;\n          if (node.depth > bottom.depth) bottom = node;\n        });\n        var tx = separation(left, right) / 2 - left.x, kx = size[0] / (right.x + separation(right, left) / 2 + tx), ky = size[1] / (bottom.depth || 1);\n        d3_layout_hierarchyVisitBefore(root0, function(node) {\n          node.x = (node.x + tx) * kx;\n          node.y = node.depth * ky;\n        });\n      }\n      return nodes;\n    }\n    function wrapTree(root0) {\n      var root1 = {\n        A: null,\n        children: [ root0 ]\n      }, queue = [ root1 ], node1;\n      while ((node1 = queue.pop()) != null) {\n        for (var children = node1.children, child, i = 0, n = children.length; i < n; ++i) {\n          queue.push((children[i] = child = {\n            _: children[i],\n            parent: node1,\n            children: (child = children[i].children) && child.slice() || [],\n            A: null,\n            a: null,\n            z: 0,\n            m: 0,\n            c: 0,\n            s: 0,\n            t: null,\n            i: i\n          }).a = child);\n        }\n      }\n      return root1.children[0];\n    }\n    function firstWalk(v) {\n      var children = v.children, siblings = v.parent.children, w = v.i ? siblings[v.i - 1] : null;\n      if (children.length) {\n        d3_layout_treeShift(v);\n        var midpoint = (children[0].z + children[children.length - 1].z) / 2;\n        if (w) {\n          v.z = w.z + separation(v._, w._);\n          v.m = v.z - midpoint;\n        } else {\n          v.z = midpoint;\n        }\n      } else if (w) {\n        v.z = w.z + separation(v._, w._);\n      }\n      v.parent.A = apportion(v, w, v.parent.A || siblings[0]);\n    }\n    function secondWalk(v) {\n      v._.x = v.z + v.parent.m;\n      v.m += v.parent.m;\n    }\n    function apportion(v, w, ancestor) {\n      if (w) {\n        var vip = v, vop = v, vim = w, vom = vip.parent.children[0], sip = vip.m, sop = vop.m, sim = vim.m, som = vom.m, shift;\n        while (vim = d3_layout_treeRight(vim), vip = d3_layout_treeLeft(vip), vim && vip) {\n          vom = d3_layout_treeLeft(vom);\n          vop = d3_layout_treeRight(vop);\n          vop.a = v;\n          shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);\n          if (shift > 0) {\n            d3_layout_treeMove(d3_layout_treeAncestor(vim, v, ancestor), v, shift);\n            sip += shift;\n            sop += shift;\n          }\n          sim += vim.m;\n          sip += vip.m;\n          som += vom.m;\n          sop += vop.m;\n        }\n        if (vim && !d3_layout_treeRight(vop)) {\n          vop.t = vim;\n          vop.m += sim - sop;\n        }\n        if (vip && !d3_layout_treeLeft(vom)) {\n          vom.t = vip;\n          vom.m += sip - som;\n          ancestor = v;\n        }\n      }\n      return ancestor;\n    }\n    function sizeNode(node) {\n      node.x *= size[0];\n      node.y = node.depth * size[1];\n    }\n    tree.separation = function(x) {\n      if (!arguments.length) return separation;\n      separation = x;\n      return tree;\n    };\n    tree.size = function(x) {\n      if (!arguments.length) return nodeSize ? null : size;\n      nodeSize = (size = x) == null ? sizeNode : null;\n      return tree;\n    };\n    tree.nodeSize = function(x) {\n      if (!arguments.length) return nodeSize ? size : null;\n      nodeSize = (size = x) == null ? null : sizeNode;\n      return tree;\n    };\n    return d3_layout_hierarchyRebind(tree, hierarchy);\n  };\n  function d3_layout_treeSeparation(a, b) {\n    return a.parent == b.parent ? 1 : 2;\n  }\n  function d3_layout_treeLeft(v) {\n    var children = v.children;\n    return children.length ? children[0] : v.t;\n  }\n  function d3_layout_treeRight(v) {\n    var children = v.children, n;\n    return (n = children.length) ? children[n - 1] : v.t;\n  }\n  function d3_layout_treeMove(wm, wp, shift) {\n    var change = shift / (wp.i - wm.i);\n    wp.c -= change;\n    wp.s += shift;\n    wm.c += change;\n    wp.z += shift;\n    wp.m += shift;\n  }\n  function d3_layout_treeShift(v) {\n    var shift = 0, change = 0, children = v.children, i = children.length, w;\n    while (--i >= 0) {\n      w = children[i];\n      w.z += shift;\n      w.m += shift;\n      shift += w.s + (change += w.c);\n    }\n  }\n  function d3_layout_treeAncestor(vim, v, ancestor) {\n    return vim.a.parent === v.parent ? vim.a : ancestor;\n  }\n  d3.layout.cluster = function() {\n    var hierarchy = d3.layout.hierarchy().sort(null).value(null), separation = d3_layout_treeSeparation, size = [ 1, 1 ], nodeSize = false;\n    function cluster(d, i) {\n      var nodes = hierarchy.call(this, d, i), root = nodes[0], previousNode, x = 0;\n      d3_layout_hierarchyVisitAfter(root, function(node) {\n        var children = node.children;\n        if (children && children.length) {\n          node.x = d3_layout_clusterX(children);\n          node.y = d3_layout_clusterY(children);\n        } else {\n          node.x = previousNode ? x += separation(node, previousNode) : 0;\n          node.y = 0;\n          previousNode = node;\n        }\n      });\n      var left = d3_layout_clusterLeft(root), right = d3_layout_clusterRight(root), x0 = left.x - separation(left, right) / 2, x1 = right.x + separation(right, left) / 2;\n      d3_layout_hierarchyVisitAfter(root, nodeSize ? function(node) {\n        node.x = (node.x - root.x) * size[0];\n        node.y = (root.y - node.y) * size[1];\n      } : function(node) {\n        node.x = (node.x - x0) / (x1 - x0) * size[0];\n        node.y = (1 - (root.y ? node.y / root.y : 1)) * size[1];\n      });\n      return nodes;\n    }\n    cluster.separation = function(x) {\n      if (!arguments.length) return separation;\n      separation = x;\n      return cluster;\n    };\n    cluster.size = function(x) {\n      if (!arguments.length) return nodeSize ? null : size;\n      nodeSize = (size = x) == null;\n      return cluster;\n    };\n    cluster.nodeSize = function(x) {\n      if (!arguments.length) return nodeSize ? size : null;\n      nodeSize = (size = x) != null;\n      return cluster;\n    };\n    return d3_layout_hierarchyRebind(cluster, hierarchy);\n  };\n  function d3_layout_clusterY(children) {\n    return 1 + d3.max(children, function(child) {\n      return child.y;\n    });\n  }\n  function d3_layout_clusterX(children) {\n    return children.reduce(function(x, child) {\n      return x + child.x;\n    }, 0) / children.length;\n  }\n  function d3_layout_clusterLeft(node) {\n    var children = node.children;\n    return children && children.length ? d3_layout_clusterLeft(children[0]) : node;\n  }\n  function d3_layout_clusterRight(node) {\n    var children = node.children, n;\n    return children && (n = children.length) ? d3_layout_clusterRight(children[n - 1]) : node;\n  }\n  d3.layout.treemap = function() {\n    var hierarchy = d3.layout.hierarchy(), round = Math.round, size = [ 1, 1 ], padding = null, pad = d3_layout_treemapPadNull, sticky = false, stickies, mode = \"squarify\", ratio = .5 * (1 + Math.sqrt(5));\n    function scale(children, k) {\n      var i = -1, n = children.length, child, area;\n      while (++i < n) {\n        area = (child = children[i]).value * (k < 0 ? 0 : k);\n        child.area = isNaN(area) || area <= 0 ? 0 : area;\n      }\n    }\n    function squarify(node) {\n      var children = node.children;\n      if (children && children.length) {\n        var rect = pad(node), row = [], remaining = children.slice(), child, best = Infinity, score, u = mode === \"slice\" ? rect.dx : mode === \"dice\" ? rect.dy : mode === \"slice-dice\" ? node.depth & 1 ? rect.dy : rect.dx : Math.min(rect.dx, rect.dy), n;\n        scale(remaining, rect.dx * rect.dy / node.value);\n        row.area = 0;\n        while ((n = remaining.length) > 0) {\n          row.push(child = remaining[n - 1]);\n          row.area += child.area;\n          if (mode !== \"squarify\" || (score = worst(row, u)) <= best) {\n            remaining.pop();\n            best = score;\n          } else {\n            row.area -= row.pop().area;\n            position(row, u, rect, false);\n            u = Math.min(rect.dx, rect.dy);\n            row.length = row.area = 0;\n            best = Infinity;\n          }\n        }\n        if (row.length) {\n          position(row, u, rect, true);\n          row.length = row.area = 0;\n        }\n        children.forEach(squarify);\n      }\n    }\n    function stickify(node) {\n      var children = node.children;\n      if (children && children.length) {\n        var rect = pad(node), remaining = children.slice(), child, row = [];\n        scale(remaining, rect.dx * rect.dy / node.value);\n        row.area = 0;\n        while (child = remaining.pop()) {\n          row.push(child);\n          row.area += child.area;\n          if (child.z != null) {\n            position(row, child.z ? rect.dx : rect.dy, rect, !remaining.length);\n            row.length = row.area = 0;\n          }\n        }\n        children.forEach(stickify);\n      }\n    }\n    function worst(row, u) {\n      var s = row.area, r, rmax = 0, rmin = Infinity, i = -1, n = row.length;\n      while (++i < n) {\n        if (!(r = row[i].area)) continue;\n        if (r < rmin) rmin = r;\n        if (r > rmax) rmax = r;\n      }\n      s *= s;\n      u *= u;\n      return s ? Math.max(u * rmax * ratio / s, s / (u * rmin * ratio)) : Infinity;\n    }\n    function position(row, u, rect, flush) {\n      var i = -1, n = row.length, x = rect.x, y = rect.y, v = u ? round(row.area / u) : 0, o;\n      if (u == rect.dx) {\n        if (flush || v > rect.dy) v = rect.dy;\n        while (++i < n) {\n          o = row[i];\n          o.x = x;\n          o.y = y;\n          o.dy = v;\n          x += o.dx = Math.min(rect.x + rect.dx - x, v ? round(o.area / v) : 0);\n        }\n        o.z = true;\n        o.dx += rect.x + rect.dx - x;\n        rect.y += v;\n        rect.dy -= v;\n      } else {\n        if (flush || v > rect.dx) v = rect.dx;\n        while (++i < n) {\n          o = row[i];\n          o.x = x;\n          o.y = y;\n          o.dx = v;\n          y += o.dy = Math.min(rect.y + rect.dy - y, v ? round(o.area / v) : 0);\n        }\n        o.z = false;\n        o.dy += rect.y + rect.dy - y;\n        rect.x += v;\n        rect.dx -= v;\n      }\n    }\n    function treemap(d) {\n      var nodes = stickies || hierarchy(d), root = nodes[0];\n      root.x = root.y = 0;\n      if (root.value) root.dx = size[0], root.dy = size[1]; else root.dx = root.dy = 0;\n      if (stickies) hierarchy.revalue(root);\n      scale([ root ], root.dx * root.dy / root.value);\n      (stickies ? stickify : squarify)(root);\n      if (sticky) stickies = nodes;\n      return nodes;\n    }\n    treemap.size = function(x) {\n      if (!arguments.length) return size;\n      size = x;\n      return treemap;\n    };\n    treemap.padding = function(x) {\n      if (!arguments.length) return padding;\n      function padFunction(node) {\n        var p = x.call(treemap, node, node.depth);\n        return p == null ? d3_layout_treemapPadNull(node) : d3_layout_treemapPad(node, typeof p === \"number\" ? [ p, p, p, p ] : p);\n      }\n      function padConstant(node) {\n        return d3_layout_treemapPad(node, x);\n      }\n      var type;\n      pad = (padding = x) == null ? d3_layout_treemapPadNull : (type = typeof x) === \"function\" ? padFunction : type === \"number\" ? (x = [ x, x, x, x ], \n      padConstant) : padConstant;\n      return treemap;\n    };\n    treemap.round = function(x) {\n      if (!arguments.length) return round != Number;\n      round = x ? Math.round : Number;\n      return treemap;\n    };\n    treemap.sticky = function(x) {\n      if (!arguments.length) return sticky;\n      sticky = x;\n      stickies = null;\n      return treemap;\n    };\n    treemap.ratio = function(x) {\n      if (!arguments.length) return ratio;\n      ratio = x;\n      return treemap;\n    };\n    treemap.mode = function(x) {\n      if (!arguments.length) return mode;\n      mode = x + \"\";\n      return treemap;\n    };\n    return d3_layout_hierarchyRebind(treemap, hierarchy);\n  };\n  function d3_layout_treemapPadNull(node) {\n    return {\n      x: node.x,\n      y: node.y,\n      dx: node.dx,\n      dy: node.dy\n    };\n  }\n  function d3_layout_treemapPad(node, padding) {\n    var x = node.x + padding[3], y = node.y + padding[0], dx = node.dx - padding[1] - padding[3], dy = node.dy - padding[0] - padding[2];\n    if (dx < 0) {\n      x += dx / 2;\n      dx = 0;\n    }\n    if (dy < 0) {\n      y += dy / 2;\n      dy = 0;\n    }\n    return {\n      x: x,\n      y: y,\n      dx: dx,\n      dy: dy\n    };\n  }\n  d3.random = {\n    normal: function(, ) {\n      var n = arguments.length;\n      if (n < 2)  = 1;\n      if (n < 1)  = 0;\n      return function() {\n        var x, y, r;\n        do {\n          x = Math.random() * 2 - 1;\n          y = Math.random() * 2 - 1;\n          r = x * x + y * y;\n        } while (!r || r > 1);\n        return  +  * x * Math.sqrt(-2 * Math.log(r) / r);\n      };\n    },\n    logNormal: function() {\n      var random = d3.random.normal.apply(d3, arguments);\n      return function() {\n        return Math.exp(random());\n      };\n    },\n    bates: function(m) {\n      var random = d3.random.irwinHall(m);\n      return function() {\n        return random() / m;\n      };\n    },\n    irwinHall: function(m) {\n      return function() {\n        for (var s = 0, j = 0; j < m; j++) s += Math.random();\n        return s;\n      };\n    }\n  };\n  d3.scale = {};\n  function d3_scaleExtent(domain) {\n    var start = domain[0], stop = domain[domain.length - 1];\n    return start < stop ? [ start, stop ] : [ stop, start ];\n  }\n  function d3_scaleRange(scale) {\n    return scale.rangeExtent ? scale.rangeExtent() : d3_scaleExtent(scale.range());\n  }\n  function d3_scale_bilinear(domain, range, uninterpolate, interpolate) {\n    var u = uninterpolate(domain[0], domain[1]), i = interpolate(range[0], range[1]);\n    return function(x) {\n      return i(u(x));\n    };\n  }\n  function d3_scale_nice(domain, nice) {\n    var i0 = 0, i1 = domain.length - 1, x0 = domain[i0], x1 = domain[i1], dx;\n    if (x1 < x0) {\n      dx = i0, i0 = i1, i1 = dx;\n      dx = x0, x0 = x1, x1 = dx;\n    }\n    domain[i0] = nice.floor(x0);\n    domain[i1] = nice.ceil(x1);\n    return domain;\n  }\n  function d3_scale_niceStep(step) {\n    return step ? {\n      floor: function(x) {\n        return Math.floor(x / step) * step;\n      },\n      ceil: function(x) {\n        return Math.ceil(x / step) * step;\n      }\n    } : d3_scale_niceIdentity;\n  }\n  var d3_scale_niceIdentity = {\n    floor: d3_identity,\n    ceil: d3_identity\n  };\n  function d3_scale_polylinear(domain, range, uninterpolate, interpolate) {\n    var u = [], i = [], j = 0, k = Math.min(domain.length, range.length) - 1;\n    if (domain[k] < domain[0]) {\n      domain = domain.slice().reverse();\n      range = range.slice().reverse();\n    }\n    while (++j <= k) {\n      u.push(uninterpolate(domain[j - 1], domain[j]));\n      i.push(interpolate(range[j - 1], range[j]));\n    }\n    return function(x) {\n      var j = d3.bisect(domain, x, 1, k) - 1;\n      return i[j](u[j](x));\n    };\n  }\n  d3.scale.linear = function() {\n    return d3_scale_linear([ 0, 1 ], [ 0, 1 ], d3_interpolate, false);\n  };\n  function d3_scale_linear(domain, range, interpolate, clamp) {\n    var output, input;\n    function rescale() {\n      var linear = Math.min(domain.length, range.length) > 2 ? d3_scale_polylinear : d3_scale_bilinear, uninterpolate = clamp ? d3_uninterpolateClamp : d3_uninterpolateNumber;\n      output = linear(domain, range, uninterpolate, interpolate);\n      input = linear(range, domain, uninterpolate, d3_interpolate);\n      return scale;\n    }\n    function scale(x) {\n      return output(x);\n    }\n    scale.invert = function(y) {\n      return input(y);\n    };\n    scale.domain = function(x) {\n      if (!arguments.length) return domain;\n      domain = x.map(Number);\n      return rescale();\n    };\n    scale.range = function(x) {\n      if (!arguments.length) return range;\n      range = x;\n      return rescale();\n    };\n    scale.rangeRound = function(x) {\n      return scale.range(x).interpolate(d3_interpolateRound);\n    };\n    scale.clamp = function(x) {\n      if (!arguments.length) return clamp;\n      clamp = x;\n      return rescale();\n    };\n    scale.interpolate = function(x) {\n      if (!arguments.length) return interpolate;\n      interpolate = x;\n      return rescale();\n    };\n    scale.ticks = function(m) {\n      return d3_scale_linearTicks(domain, m);\n    };\n    scale.tickFormat = function(m, format) {\n      return d3_scale_linearTickFormat(domain, m, format);\n    };\n    scale.nice = function(m) {\n      d3_scale_linearNice(domain, m);\n      return rescale();\n    };\n    scale.copy = function() {\n      return d3_scale_linear(domain, range, interpolate, clamp);\n    };\n    return rescale();\n  }\n  function d3_scale_linearRebind(scale, linear) {\n    return d3.rebind(scale, linear, \"range\", \"rangeRound\", \"interpolate\", \"clamp\");\n  }\n  function d3_scale_linearNice(domain, m) {\n    d3_scale_nice(domain, d3_scale_niceStep(d3_scale_linearTickRange(domain, m)[2]));\n    d3_scale_nice(domain, d3_scale_niceStep(d3_scale_linearTickRange(domain, m)[2]));\n    return domain;\n  }\n  function d3_scale_linearTickRange(domain, m) {\n    if (m == null) m = 10;\n    var extent = d3_scaleExtent(domain), span = extent[1] - extent[0], step = Math.pow(10, Math.floor(Math.log(span / m) / Math.LN10)), err = m / span * step;\n    if (err <= .15) step *= 10; else if (err <= .35) step *= 5; else if (err <= .75) step *= 2;\n    extent[0] = Math.ceil(extent[0] / step) * step;\n    extent[1] = Math.floor(extent[1] / step) * step + step * .5;\n    extent[2] = step;\n    return extent;\n  }\n  function d3_scale_linearTicks(domain, m) {\n    return d3.range.apply(d3, d3_scale_linearTickRange(domain, m));\n  }\n  function d3_scale_linearTickFormat(domain, m, format) {\n    var range = d3_scale_linearTickRange(domain, m);\n    if (format) {\n      var match = d3_format_re.exec(format);\n      match.shift();\n      if (match[8] === \"s\") {\n        var prefix = d3.formatPrefix(Math.max(abs(range[0]), abs(range[1])));\n        if (!match[7]) match[7] = \".\" + d3_scale_linearPrecision(prefix.scale(range[2]));\n        match[8] = \"f\";\n        format = d3.format(match.join(\"\"));\n        return function(d) {\n          return format(prefix.scale(d)) + prefix.symbol;\n        };\n      }\n      if (!match[7]) match[7] = \".\" + d3_scale_linearFormatPrecision(match[8], range);\n      format = match.join(\"\");\n    } else {\n      format = \",.\" + d3_scale_linearPrecision(range[2]) + \"f\";\n    }\n    return d3.format(format);\n  }\n  var d3_scale_linearFormatSignificant = {\n    s: 1,\n    g: 1,\n    p: 1,\n    r: 1,\n    e: 1\n  };\n  function d3_scale_linearPrecision(value) {\n    return -Math.floor(Math.log(value) / Math.LN10 + .01);\n  }\n  function d3_scale_linearFormatPrecision(type, range) {\n    var p = d3_scale_linearPrecision(range[2]);\n    return type in d3_scale_linearFormatSignificant ? Math.abs(p - d3_scale_linearPrecision(Math.max(abs(range[0]), abs(range[1])))) + +(type !== \"e\") : p - (type === \"%\") * 2;\n  }\n  d3.scale.log = function() {\n    return d3_scale_log(d3.scale.linear().domain([ 0, 1 ]), 10, true, [ 1, 10 ]);\n  };\n  function d3_scale_log(linear, base, positive, domain) {\n    function log(x) {\n      return (positive ? Math.log(x < 0 ? 0 : x) : -Math.log(x > 0 ? 0 : -x)) / Math.log(base);\n    }\n    function pow(x) {\n      return positive ? Math.pow(base, x) : -Math.pow(base, -x);\n    }\n    function scale(x) {\n      return linear(log(x));\n    }\n    scale.invert = function(x) {\n      return pow(linear.invert(x));\n    };\n    scale.domain = function(x) {\n      if (!arguments.length) return domain;\n      positive = x[0] >= 0;\n      linear.domain((domain = x.map(Number)).map(log));\n      return scale;\n    };\n    scale.base = function(_) {\n      if (!arguments.length) return base;\n      base = +_;\n      linear.domain(domain.map(log));\n      return scale;\n    };\n    scale.nice = function() {\n      var niced = d3_scale_nice(domain.map(log), positive ? Math : d3_scale_logNiceNegative);\n      linear.domain(niced);\n      domain = niced.map(pow);\n      return scale;\n    };\n    scale.ticks = function() {\n      var extent = d3_scaleExtent(domain), ticks = [], u = extent[0], v = extent[1], i = Math.floor(log(u)), j = Math.ceil(log(v)), n = base % 1 ? 2 : base;\n      if (isFinite(j - i)) {\n        if (positive) {\n          for (;i < j; i++) for (var k = 1; k < n; k++) ticks.push(pow(i) * k);\n          ticks.push(pow(i));\n        } else {\n          ticks.push(pow(i));\n          for (;i++ < j; ) for (var k = n - 1; k > 0; k--) ticks.push(pow(i) * k);\n        }\n        for (i = 0; ticks[i] < u; i++) {}\n        for (j = ticks.length; ticks[j - 1] > v; j--) {}\n        ticks = ticks.slice(i, j);\n      }\n      return ticks;\n    };\n    scale.tickFormat = function(n, format) {\n      if (!arguments.length) return d3_scale_logFormat;\n      if (arguments.length < 2) format = d3_scale_logFormat; else if (typeof format !== \"function\") format = d3.format(format);\n      var k = Math.max(1, base * n / scale.ticks().length);\n      return function(d) {\n        var i = d / pow(Math.round(log(d)));\n        if (i * base < base - .5) i *= base;\n        return i <= k ? format(d) : \"\";\n      };\n    };\n    scale.copy = function() {\n      return d3_scale_log(linear.copy(), base, positive, domain);\n    };\n    return d3_scale_linearRebind(scale, linear);\n  }\n  var d3_scale_logFormat = d3.format(\".0e\"), d3_scale_logNiceNegative = {\n    floor: function(x) {\n      return -Math.ceil(-x);\n    },\n    ceil: function(x) {\n      return -Math.floor(-x);\n    }\n  };\n  d3.scale.pow = function() {\n    return d3_scale_pow(d3.scale.linear(), 1, [ 0, 1 ]);\n  };\n  function d3_scale_pow(linear, exponent, domain) {\n    var powp = d3_scale_powPow(exponent), powb = d3_scale_powPow(1 / exponent);\n    function scale(x) {\n      return linear(powp(x));\n    }\n    scale.invert = function(x) {\n      return powb(linear.invert(x));\n    };\n    scale.domain = function(x) {\n      if (!arguments.length) return domain;\n      linear.domain((domain = x.map(Number)).map(powp));\n      return scale;\n    };\n    scale.ticks = function(m) {\n      return d3_scale_linearTicks(domain, m);\n    };\n    scale.tickFormat = function(m, format) {\n      return d3_scale_linearTickFormat(domain, m, format);\n    };\n    scale.nice = function(m) {\n      return scale.domain(d3_scale_linearNice(domain, m));\n    };\n    scale.exponent = function(x) {\n      if (!arguments.length) return exponent;\n      powp = d3_scale_powPow(exponent = x);\n      powb = d3_scale_powPow(1 / exponent);\n      linear.domain(domain.map(powp));\n      return scale;\n    };\n    scale.copy = function() {\n      return d3_scale_pow(linear.copy(), exponent, domain);\n    };\n    return d3_scale_linearRebind(scale, linear);\n  }\n  function d3_scale_powPow(e) {\n    return function(x) {\n      return x < 0 ? -Math.pow(-x, e) : Math.pow(x, e);\n    };\n  }\n  d3.scale.sqrt = function() {\n    return d3.scale.pow().exponent(.5);\n  };\n  d3.scale.ordinal = function() {\n    return d3_scale_ordinal([], {\n      t: \"range\",\n      a: [ [] ]\n    });\n  };\n  function d3_scale_ordinal(domain, ranger) {\n    var index, range, rangeBand;\n    function scale(x) {\n      return range[((index.get(x) || (ranger.t === \"range\" ? index.set(x, domain.push(x)) : NaN)) - 1) % range.length];\n    }\n    function steps(start, step) {\n      return d3.range(domain.length).map(function(i) {\n        return start + step * i;\n      });\n    }\n    scale.domain = function(x) {\n      if (!arguments.length) return domain;\n      domain = [];\n      index = new d3_Map();\n      var i = -1, n = x.length, xi;\n      while (++i < n) if (!index.has(xi = x[i])) index.set(xi, domain.push(xi));\n      return scale[ranger.t].apply(scale, ranger.a);\n    };\n    scale.range = function(x) {\n      if (!arguments.length) return range;\n      range = x;\n      rangeBand = 0;\n      ranger = {\n        t: \"range\",\n        a: arguments\n      };\n      return scale;\n    };\n    scale.rangePoints = function(x, padding) {\n      if (arguments.length < 2) padding = 0;\n      var start = x[0], stop = x[1], step = domain.length < 2 ? (start = (start + stop) / 2, \n      0) : (stop - start) / (domain.length - 1 + padding);\n      range = steps(start + step * padding / 2, step);\n      rangeBand = 0;\n      ranger = {\n        t: \"rangePoints\",\n        a: arguments\n      };\n      return scale;\n    };\n    scale.rangeRoundPoints = function(x, padding) {\n      if (arguments.length < 2) padding = 0;\n      var start = x[0], stop = x[1], step = domain.length < 2 ? (start = stop = Math.round((start + stop) / 2), \n      0) : (stop - start) / (domain.length - 1 + padding) | 0;\n      range = steps(start + Math.round(step * padding / 2 + (stop - start - (domain.length - 1 + padding) * step) / 2), step);\n      rangeBand = 0;\n      ranger = {\n        t: \"rangeRoundPoints\",\n        a: arguments\n      };\n      return scale;\n    };\n    scale.rangeBands = function(x, padding, outerPadding) {\n      if (arguments.length < 2) padding = 0;\n      if (arguments.length < 3) outerPadding = padding;\n      var reverse = x[1] < x[0], start = x[reverse - 0], stop = x[1 - reverse], step = (stop - start) / (domain.length - padding + 2 * outerPadding);\n      range = steps(start + step * outerPadding, step);\n      if (reverse) range.reverse();\n      rangeBand = step * (1 - padding);\n      ranger = {\n        t: \"rangeBands\",\n        a: arguments\n      };\n      return scale;\n    };\n    scale.rangeRoundBands = function(x, padding, outerPadding) {\n      if (arguments.length < 2) padding = 0;\n      if (arguments.length < 3) outerPadding = padding;\n      var reverse = x[1] < x[0], start = x[reverse - 0], stop = x[1 - reverse], step = Math.floor((stop - start) / (domain.length - padding + 2 * outerPadding));\n      range = steps(start + Math.round((stop - start - (domain.length - padding) * step) / 2), step);\n      if (reverse) range.reverse();\n      rangeBand = Math.round(step * (1 - padding));\n      ranger = {\n        t: \"rangeRoundBands\",\n        a: arguments\n      };\n      return scale;\n    };\n    scale.rangeBand = function() {\n      return rangeBand;\n    };\n    scale.rangeExtent = function() {\n      return d3_scaleExtent(ranger.a[0]);\n    };\n    scale.copy = function() {\n      return d3_scale_ordinal(domain, ranger);\n    };\n    return scale.domain(domain);\n  }\n  d3.scale.category10 = function() {\n    return d3.scale.ordinal().range(d3_category10);\n  };\n  d3.scale.category20 = function() {\n    return d3.scale.ordinal().range(d3_category20);\n  };\n  d3.scale.category20b = function() {\n    return d3.scale.ordinal().range(d3_category20b);\n  };\n  d3.scale.category20c = function() {\n    return d3.scale.ordinal().range(d3_category20c);\n  };\n  var d3_category10 = [ 2062260, 16744206, 2924588, 14034728, 9725885, 9197131, 14907330, 8355711, 12369186, 1556175 ].map(d3_rgbString);\n  var d3_category20 = [ 2062260, 11454440, 16744206, 16759672, 2924588, 10018698, 14034728, 16750742, 9725885, 12955861, 9197131, 12885140, 14907330, 16234194, 8355711, 13092807, 12369186, 14408589, 1556175, 10410725 ].map(d3_rgbString);\n  var d3_category20b = [ 3750777, 5395619, 7040719, 10264286, 6519097, 9216594, 11915115, 13556636, 9202993, 12426809, 15186514, 15190932, 8666169, 11356490, 14049643, 15177372, 8077683, 10834324, 13528509, 14589654 ].map(d3_rgbString);\n  var d3_category20c = [ 3244733, 7057110, 10406625, 13032431, 15095053, 16616764, 16625259, 16634018, 3253076, 7652470, 10607003, 13101504, 7695281, 10394312, 12369372, 14342891, 6513507, 9868950, 12434877, 14277081 ].map(d3_rgbString);\n  d3.scale.quantile = function() {\n    return d3_scale_quantile([], []);\n  };\n  function d3_scale_quantile(domain, range) {\n    var thresholds;\n    function rescale() {\n      var k = 0, q = range.length;\n      thresholds = [];\n      while (++k < q) thresholds[k - 1] = d3.quantile(domain, k / q);\n      return scale;\n    }\n    function scale(x) {\n      if (!isNaN(x = +x)) return range[d3.bisect(thresholds, x)];\n    }\n    scale.domain = function(x) {\n      if (!arguments.length) return domain;\n      domain = x.map(d3_number).filter(d3_numeric).sort(d3_ascending);\n      return rescale();\n    };\n    scale.range = function(x) {\n      if (!arguments.length) return range;\n      range = x;\n      return rescale();\n    };\n    scale.quantiles = function() {\n      return thresholds;\n    };\n    scale.invertExtent = function(y) {\n      y = range.indexOf(y);\n      return y < 0 ? [ NaN, NaN ] : [ y > 0 ? thresholds[y - 1] : domain[0], y < thresholds.length ? thresholds[y] : domain[domain.length - 1] ];\n    };\n    scale.copy = function() {\n      return d3_scale_quantile(domain, range);\n    };\n    return rescale();\n  }\n  d3.scale.quantize = function() {\n    return d3_scale_quantize(0, 1, [ 0, 1 ]);\n  };\n  function d3_scale_quantize(x0, x1, range) {\n    var kx, i;\n    function scale(x) {\n      return range[Math.max(0, Math.min(i, Math.floor(kx * (x - x0))))];\n    }\n    function rescale() {\n      kx = range.length / (x1 - x0);\n      i = range.length - 1;\n      return scale;\n    }\n    scale.domain = function(x) {\n      if (!arguments.length) return [ x0, x1 ];\n      x0 = +x[0];\n      x1 = +x[x.length - 1];\n      return rescale();\n    };\n    scale.range = function(x) {\n      if (!arguments.length) return range;\n      range = x;\n      return rescale();\n    };\n    scale.invertExtent = function(y) {\n      y = range.indexOf(y);\n      y = y < 0 ? NaN : y / kx + x0;\n      return [ y, y + 1 / kx ];\n    };\n    scale.copy = function() {\n      return d3_scale_quantize(x0, x1, range);\n    };\n    return rescale();\n  }\n  d3.scale.threshold = function() {\n    return d3_scale_threshold([ .5 ], [ 0, 1 ]);\n  };\n  function d3_scale_threshold(domain, range) {\n    function scale(x) {\n      if (x <= x) return range[d3.bisect(domain, x)];\n    }\n    scale.domain = function(_) {\n      if (!arguments.length) return domain;\n      domain = _;\n      return scale;\n    };\n    scale.range = function(_) {\n      if (!arguments.length) return range;\n      range = _;\n      return scale;\n    };\n    scale.invertExtent = function(y) {\n      y = range.indexOf(y);\n      return [ domain[y - 1], domain[y] ];\n    };\n    scale.copy = function() {\n      return d3_scale_threshold(domain, range);\n    };\n    return scale;\n  }\n  d3.scale.identity = function() {\n    return d3_scale_identity([ 0, 1 ]);\n  };\n  function d3_scale_identity(domain) {\n    function identity(x) {\n      return +x;\n    }\n    identity.invert = identity;\n    identity.domain = identity.range = function(x) {\n      if (!arguments.length) return domain;\n      domain = x.map(identity);\n      return identity;\n    };\n    identity.ticks = function(m) {\n      return d3_scale_linearTicks(domain, m);\n    };\n    identity.tickFormat = function(m, format) {\n      return d3_scale_linearTickFormat(domain, m, format);\n    };\n    identity.copy = function() {\n      return d3_scale_identity(domain);\n    };\n    return identity;\n  }\n  d3.svg = {};\n  function d3_zero() {\n    return 0;\n  }\n  d3.svg.arc = function() {\n    var innerRadius = d3_svg_arcInnerRadius, outerRadius = d3_svg_arcOuterRadius, cornerRadius = d3_zero, padRadius = d3_svg_arcAuto, startAngle = d3_svg_arcStartAngle, endAngle = d3_svg_arcEndAngle, padAngle = d3_svg_arcPadAngle;\n    function arc() {\n      var r0 = Math.max(0, +innerRadius.apply(this, arguments)), r1 = Math.max(0, +outerRadius.apply(this, arguments)), a0 = startAngle.apply(this, arguments) - half, a1 = endAngle.apply(this, arguments) - half, da = Math.abs(a1 - a0), cw = a0 > a1 ? 0 : 1;\n      if (r1 < r0) rc = r1, r1 = r0, r0 = rc;\n      if (da >= ) return circleSegment(r1, cw) + (r0 ? circleSegment(r0, 1 - cw) : \"\") + \"Z\";\n      var rc, cr, rp, ap, p0 = 0, p1 = 0, x0, y0, x1, y1, x2, y2, x3, y3, path = [];\n      if (ap = (+padAngle.apply(this, arguments) || 0) / 2) {\n        rp = padRadius === d3_svg_arcAuto ? Math.sqrt(r0 * r0 + r1 * r1) : +padRadius.apply(this, arguments);\n        if (!cw) p1 *= -1;\n        if (r1) p1 = d3_asin(rp / r1 * Math.sin(ap));\n        if (r0) p0 = d3_asin(rp / r0 * Math.sin(ap));\n      }\n      if (r1) {\n        x0 = r1 * Math.cos(a0 + p1);\n        y0 = r1 * Math.sin(a0 + p1);\n        x1 = r1 * Math.cos(a1 - p1);\n        y1 = r1 * Math.sin(a1 - p1);\n        var l1 = Math.abs(a1 - a0 - 2 * p1) <=  ? 0 : 1;\n        if (p1 && d3_svg_arcSweep(x0, y0, x1, y1) === cw ^ l1) {\n          var h1 = (a0 + a1) / 2;\n          x0 = r1 * Math.cos(h1);\n          y0 = r1 * Math.sin(h1);\n          x1 = y1 = null;\n        }\n      } else {\n        x0 = y0 = 0;\n      }\n      if (r0) {\n        x2 = r0 * Math.cos(a1 - p0);\n        y2 = r0 * Math.sin(a1 - p0);\n        x3 = r0 * Math.cos(a0 + p0);\n        y3 = r0 * Math.sin(a0 + p0);\n        var l0 = Math.abs(a0 - a1 + 2 * p0) <=  ? 0 : 1;\n        if (p0 && d3_svg_arcSweep(x2, y2, x3, y3) === 1 - cw ^ l0) {\n          var h0 = (a0 + a1) / 2;\n          x2 = r0 * Math.cos(h0);\n          y2 = r0 * Math.sin(h0);\n          x3 = y3 = null;\n        }\n      } else {\n        x2 = y2 = 0;\n      }\n      if (da >  && (rc = Math.min(Math.abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments))) > .001) {\n        cr = r0 < r1 ^ cw ? 0 : 1;\n        var rc1 = rc, rc0 = rc;\n        if (da < ) {\n          var oc = x3 == null ? [ x2, y2 ] : x1 == null ? [ x0, y0 ] : d3_geom_polygonIntersect([ x0, y0 ], [ x3, y3 ], [ x1, y1 ], [ x2, y2 ]), ax = x0 - oc[0], ay = y0 - oc[1], bx = x1 - oc[0], by = y1 - oc[1], kc = 1 / Math.sin(Math.acos((ax * bx + ay * by) / (Math.sqrt(ax * ax + ay * ay) * Math.sqrt(bx * bx + by * by))) / 2), lc = Math.sqrt(oc[0] * oc[0] + oc[1] * oc[1]);\n          rc0 = Math.min(rc, (r0 - lc) / (kc - 1));\n          rc1 = Math.min(rc, (r1 - lc) / (kc + 1));\n        }\n        if (x1 != null) {\n          var t30 = d3_svg_arcCornerTangents(x3 == null ? [ x2, y2 ] : [ x3, y3 ], [ x0, y0 ], r1, rc1, cw), t12 = d3_svg_arcCornerTangents([ x1, y1 ], [ x2, y2 ], r1, rc1, cw);\n          if (rc === rc1) {\n            path.push(\"M\", t30[0], \"A\", rc1, \",\", rc1, \" 0 0,\", cr, \" \", t30[1], \"A\", r1, \",\", r1, \" 0 \", 1 - cw ^ d3_svg_arcSweep(t30[1][0], t30[1][1], t12[1][0], t12[1][1]), \",\", cw, \" \", t12[1], \"A\", rc1, \",\", rc1, \" 0 0,\", cr, \" \", t12[0]);\n          } else {\n            path.push(\"M\", t30[0], \"A\", rc1, \",\", rc1, \" 0 1,\", cr, \" \", t12[0]);\n          }\n        } else {\n          path.push(\"M\", x0, \",\", y0);\n        }\n        if (x3 != null) {\n          var t03 = d3_svg_arcCornerTangents([ x0, y0 ], [ x3, y3 ], r0, -rc0, cw), t21 = d3_svg_arcCornerTangents([ x2, y2 ], x1 == null ? [ x0, y0 ] : [ x1, y1 ], r0, -rc0, cw);\n          if (rc === rc0) {\n            path.push(\"L\", t21[0], \"A\", rc0, \",\", rc0, \" 0 0,\", cr, \" \", t21[1], \"A\", r0, \",\", r0, \" 0 \", cw ^ d3_svg_arcSweep(t21[1][0], t21[1][1], t03[1][0], t03[1][1]), \",\", 1 - cw, \" \", t03[1], \"A\", rc0, \",\", rc0, \" 0 0,\", cr, \" \", t03[0]);\n          } else {\n            path.push(\"L\", t21[0], \"A\", rc0, \",\", rc0, \" 0 0,\", cr, \" \", t03[0]);\n          }\n        } else {\n          path.push(\"L\", x2, \",\", y2);\n        }\n      } else {\n        path.push(\"M\", x0, \",\", y0);\n        if (x1 != null) path.push(\"A\", r1, \",\", r1, \" 0 \", l1, \",\", cw, \" \", x1, \",\", y1);\n        path.push(\"L\", x2, \",\", y2);\n        if (x3 != null) path.push(\"A\", r0, \",\", r0, \" 0 \", l0, \",\", 1 - cw, \" \", x3, \",\", y3);\n      }\n      path.push(\"Z\");\n      return path.join(\"\");\n    }\n    function circleSegment(r1, cw) {\n      return \"M0,\" + r1 + \"A\" + r1 + \",\" + r1 + \" 0 1,\" + cw + \" 0,\" + -r1 + \"A\" + r1 + \",\" + r1 + \" 0 1,\" + cw + \" 0,\" + r1;\n    }\n    arc.innerRadius = function(v) {\n      if (!arguments.length) return innerRadius;\n      innerRadius = d3_functor(v);\n      return arc;\n    };\n    arc.outerRadius = function(v) {\n      if (!arguments.length) return outerRadius;\n      outerRadius = d3_functor(v);\n      return arc;\n    };\n    arc.cornerRadius = function(v) {\n      if (!arguments.length) return cornerRadius;\n      cornerRadius = d3_functor(v);\n      return arc;\n    };\n    arc.padRadius = function(v) {\n      if (!arguments.length) return padRadius;\n      padRadius = v == d3_svg_arcAuto ? d3_svg_arcAuto : d3_functor(v);\n      return arc;\n    };\n    arc.startAngle = function(v) {\n      if (!arguments.length) return startAngle;\n      startAngle = d3_functor(v);\n      return arc;\n    };\n    arc.endAngle = function(v) {\n      if (!arguments.length) return endAngle;\n      endAngle = d3_functor(v);\n      return arc;\n    };\n    arc.padAngle = function(v) {\n      if (!arguments.length) return padAngle;\n      padAngle = d3_functor(v);\n      return arc;\n    };\n    arc.centroid = function() {\n      var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2, a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - half;\n      return [ Math.cos(a) * r, Math.sin(a) * r ];\n    };\n    return arc;\n  };\n  var d3_svg_arcAuto = \"auto\";\n  function d3_svg_arcInnerRadius(d) {\n    return d.innerRadius;\n  }\n  function d3_svg_arcOuterRadius(d) {\n    return d.outerRadius;\n  }\n  function d3_svg_arcStartAngle(d) {\n    return d.startAngle;\n  }\n  function d3_svg_arcEndAngle(d) {\n    return d.endAngle;\n  }\n  function d3_svg_arcPadAngle(d) {\n    return d && d.padAngle;\n  }\n  function d3_svg_arcSweep(x0, y0, x1, y1) {\n    return (x0 - x1) * y0 - (y0 - y1) * x0 > 0 ? 0 : 1;\n  }\n  function d3_svg_arcCornerTangents(p0, p1, r1, rc, cw) {\n    var x01 = p0[0] - p1[0], y01 = p0[1] - p1[1], lo = (cw ? rc : -rc) / Math.sqrt(x01 * x01 + y01 * y01), ox = lo * y01, oy = -lo * x01, x1 = p0[0] + ox, y1 = p0[1] + oy, x2 = p1[0] + ox, y2 = p1[1] + oy, x3 = (x1 + x2) / 2, y3 = (y1 + y2) / 2, dx = x2 - x1, dy = y2 - y1, d2 = dx * dx + dy * dy, r = r1 - rc, D = x1 * y2 - x2 * y1, d = (dy < 0 ? -1 : 1) * Math.sqrt(Math.max(0, r * r * d2 - D * D)), cx0 = (D * dy - dx * d) / d2, cy0 = (-D * dx - dy * d) / d2, cx1 = (D * dy + dx * d) / d2, cy1 = (-D * dx + dy * d) / d2, dx0 = cx0 - x3, dy0 = cy0 - y3, dx1 = cx1 - x3, dy1 = cy1 - y3;\n    if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;\n    return [ [ cx0 - ox, cy0 - oy ], [ cx0 * r1 / r, cy0 * r1 / r ] ];\n  }\n  function d3_svg_line(projection) {\n    var x = d3_geom_pointX, y = d3_geom_pointY, defined = d3_true, interpolate = d3_svg_lineLinear, interpolateKey = interpolate.key, tension = .7;\n    function line(data) {\n      var segments = [], points = [], i = -1, n = data.length, d, fx = d3_functor(x), fy = d3_functor(y);\n      function segment() {\n        segments.push(\"M\", interpolate(projection(points), tension));\n      }\n      while (++i < n) {\n        if (defined.call(this, d = data[i], i)) {\n          points.push([ +fx.call(this, d, i), +fy.call(this, d, i) ]);\n        } else if (points.length) {\n          segment();\n          points = [];\n        }\n      }\n      if (points.length) segment();\n      return segments.length ? segments.join(\"\") : null;\n    }\n    line.x = function(_) {\n      if (!arguments.length) return x;\n      x = _;\n      return line;\n    };\n    line.y = function(_) {\n      if (!arguments.length) return y;\n      y = _;\n      return line;\n    };\n    line.defined = function(_) {\n      if (!arguments.length) return defined;\n      defined = _;\n      return line;\n    };\n    line.interpolate = function(_) {\n      if (!arguments.length) return interpolateKey;\n      if (typeof _ === \"function\") interpolateKey = interpolate = _; else interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;\n      return line;\n    };\n    line.tension = function(_) {\n      if (!arguments.length) return tension;\n      tension = _;\n      return line;\n    };\n    return line;\n  }\n  d3.svg.line = function() {\n    return d3_svg_line(d3_identity);\n  };\n  var d3_svg_lineInterpolators = d3.map({\n    linear: d3_svg_lineLinear,\n    \"linear-closed\": d3_svg_lineLinearClosed,\n    step: d3_svg_lineStep,\n    \"step-before\": d3_svg_lineStepBefore,\n    \"step-after\": d3_svg_lineStepAfter,\n    basis: d3_svg_lineBasis,\n    \"basis-open\": d3_svg_lineBasisOpen,\n    \"basis-closed\": d3_svg_lineBasisClosed,\n    bundle: d3_svg_lineBundle,\n    cardinal: d3_svg_lineCardinal,\n    \"cardinal-open\": d3_svg_lineCardinalOpen,\n    \"cardinal-closed\": d3_svg_lineCardinalClosed,\n    monotone: d3_svg_lineMonotone\n  });\n  d3_svg_lineInterpolators.forEach(function(key, value) {\n    value.key = key;\n    value.closed = /-closed$/.test(key);\n  });\n  function d3_svg_lineLinear(points) {\n    return points.length > 1 ? points.join(\"L\") : points + \"Z\";\n  }\n  function d3_svg_lineLinearClosed(points) {\n    return points.join(\"L\") + \"Z\";\n  }\n  function d3_svg_lineStep(points) {\n    var i = 0, n = points.length, p = points[0], path = [ p[0], \",\", p[1] ];\n    while (++i < n) path.push(\"H\", (p[0] + (p = points[i])[0]) / 2, \"V\", p[1]);\n    if (n > 1) path.push(\"H\", p[0]);\n    return path.join(\"\");\n  }\n  function d3_svg_lineStepBefore(points) {\n    var i = 0, n = points.length, p = points[0], path = [ p[0], \",\", p[1] ];\n    while (++i < n) path.push(\"V\", (p = points[i])[1], \"H\", p[0]);\n    return path.join(\"\");\n  }\n  function d3_svg_lineStepAfter(points) {\n    var i = 0, n = points.length, p = points[0], path = [ p[0], \",\", p[1] ];\n    while (++i < n) path.push(\"H\", (p = points[i])[0], \"V\", p[1]);\n    return path.join(\"\");\n  }\n  function d3_svg_lineCardinalOpen(points, tension) {\n    return points.length < 4 ? d3_svg_lineLinear(points) : points[1] + d3_svg_lineHermite(points.slice(1, -1), d3_svg_lineCardinalTangents(points, tension));\n  }\n  function d3_svg_lineCardinalClosed(points, tension) {\n    return points.length < 3 ? d3_svg_lineLinearClosed(points) : points[0] + d3_svg_lineHermite((points.push(points[0]), \n    points), d3_svg_lineCardinalTangents([ points[points.length - 2] ].concat(points, [ points[1] ]), tension));\n  }\n  function d3_svg_lineCardinal(points, tension) {\n    return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineCardinalTangents(points, tension));\n  }\n  function d3_svg_lineHermite(points, tangents) {\n    if (tangents.length < 1 || points.length != tangents.length && points.length != tangents.length + 2) {\n      return d3_svg_lineLinear(points);\n    }\n    var quad = points.length != tangents.length, path = \"\", p0 = points[0], p = points[1], t0 = tangents[0], t = t0, pi = 1;\n    if (quad) {\n      path += \"Q\" + (p[0] - t0[0] * 2 / 3) + \",\" + (p[1] - t0[1] * 2 / 3) + \",\" + p[0] + \",\" + p[1];\n      p0 = points[1];\n      pi = 2;\n    }\n    if (tangents.length > 1) {\n      t = tangents[1];\n      p = points[pi];\n      pi++;\n      path += \"C\" + (p0[0] + t0[0]) + \",\" + (p0[1] + t0[1]) + \",\" + (p[0] - t[0]) + \",\" + (p[1] - t[1]) + \",\" + p[0] + \",\" + p[1];\n      for (var i = 2; i < tangents.length; i++, pi++) {\n        p = points[pi];\n        t = tangents[i];\n        path += \"S\" + (p[0] - t[0]) + \",\" + (p[1] - t[1]) + \",\" + p[0] + \",\" + p[1];\n      }\n    }\n    if (quad) {\n      var lp = points[pi];\n      path += \"Q\" + (p[0] + t[0] * 2 / 3) + \",\" + (p[1] + t[1] * 2 / 3) + \",\" + lp[0] + \",\" + lp[1];\n    }\n    return path;\n  }\n  function d3_svg_lineCardinalTangents(points, tension) {\n    var tangents = [], a = (1 - tension) / 2, p0, p1 = points[0], p2 = points[1], i = 1, n = points.length;\n    while (++i < n) {\n      p0 = p1;\n      p1 = p2;\n      p2 = points[i];\n      tangents.push([ a * (p2[0] - p0[0]), a * (p2[1] - p0[1]) ]);\n    }\n    return tangents;\n  }\n  function d3_svg_lineBasis(points) {\n    if (points.length < 3) return d3_svg_lineLinear(points);\n    var i = 1, n = points.length, pi = points[0], x0 = pi[0], y0 = pi[1], px = [ x0, x0, x0, (pi = points[1])[0] ], py = [ y0, y0, y0, pi[1] ], path = [ x0, \",\", y0, \"L\", d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), \",\", d3_svg_lineDot4(d3_svg_lineBasisBezier3, py) ];\n    points.push(points[n - 1]);\n    while (++i <= n) {\n      pi = points[i];\n      px.shift();\n      px.push(pi[0]);\n      py.shift();\n      py.push(pi[1]);\n      d3_svg_lineBasisBezier(path, px, py);\n    }\n    points.pop();\n    path.push(\"L\", pi);\n    return path.join(\"\");\n  }\n  function d3_svg_lineBasisOpen(points) {\n    if (points.length < 4) return d3_svg_lineLinear(points);\n    var path = [], i = -1, n = points.length, pi, px = [ 0 ], py = [ 0 ];\n    while (++i < 3) {\n      pi = points[i];\n      px.push(pi[0]);\n      py.push(pi[1]);\n    }\n    path.push(d3_svg_lineDot4(d3_svg_lineBasisBezier3, px) + \",\" + d3_svg_lineDot4(d3_svg_lineBasisBezier3, py));\n    --i;\n    while (++i < n) {\n      pi = points[i];\n      px.shift();\n      px.push(pi[0]);\n      py.shift();\n      py.push(pi[1]);\n      d3_svg_lineBasisBezier(path, px, py);\n    }\n    return path.join(\"\");\n  }\n  function d3_svg_lineBasisClosed(points) {\n    var path, i = -1, n = points.length, m = n + 4, pi, px = [], py = [];\n    while (++i < 4) {\n      pi = points[i % n];\n      px.push(pi[0]);\n      py.push(pi[1]);\n    }\n    path = [ d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), \",\", d3_svg_lineDot4(d3_svg_lineBasisBezier3, py) ];\n    --i;\n    while (++i < m) {\n      pi = points[i % n];\n      px.shift();\n      px.push(pi[0]);\n      py.shift();\n      py.push(pi[1]);\n      d3_svg_lineBasisBezier(path, px, py);\n    }\n    return path.join(\"\");\n  }\n  function d3_svg_lineBundle(points, tension) {\n    var n = points.length - 1;\n    if (n) {\n      var x0 = points[0][0], y0 = points[0][1], dx = points[n][0] - x0, dy = points[n][1] - y0, i = -1, p, t;\n      while (++i <= n) {\n        p = points[i];\n        t = i / n;\n        p[0] = tension * p[0] + (1 - tension) * (x0 + t * dx);\n        p[1] = tension * p[1] + (1 - tension) * (y0 + t * dy);\n      }\n    }\n    return d3_svg_lineBasis(points);\n  }\n  function d3_svg_lineDot4(a, b) {\n    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];\n  }\n  var d3_svg_lineBasisBezier1 = [ 0, 2 / 3, 1 / 3, 0 ], d3_svg_lineBasisBezier2 = [ 0, 1 / 3, 2 / 3, 0 ], d3_svg_lineBasisBezier3 = [ 0, 1 / 6, 2 / 3, 1 / 6 ];\n  function d3_svg_lineBasisBezier(path, x, y) {\n    path.push(\"C\", d3_svg_lineDot4(d3_svg_lineBasisBezier1, x), \",\", d3_svg_lineDot4(d3_svg_lineBasisBezier1, y), \",\", d3_svg_lineDot4(d3_svg_lineBasisBezier2, x), \",\", d3_svg_lineDot4(d3_svg_lineBasisBezier2, y), \",\", d3_svg_lineDot4(d3_svg_lineBasisBezier3, x), \",\", d3_svg_lineDot4(d3_svg_lineBasisBezier3, y));\n  }\n  function d3_svg_lineSlope(p0, p1) {\n    return (p1[1] - p0[1]) / (p1[0] - p0[0]);\n  }\n  function d3_svg_lineFiniteDifferences(points) {\n    var i = 0, j = points.length - 1, m = [], p0 = points[0], p1 = points[1], d = m[0] = d3_svg_lineSlope(p0, p1);\n    while (++i < j) {\n      m[i] = (d + (d = d3_svg_lineSlope(p0 = p1, p1 = points[i + 1]))) / 2;\n    }\n    m[i] = d;\n    return m;\n  }\n  function d3_svg_lineMonotoneTangents(points) {\n    var tangents = [], d, a, b, s, m = d3_svg_lineFiniteDifferences(points), i = -1, j = points.length - 1;\n    while (++i < j) {\n      d = d3_svg_lineSlope(points[i], points[i + 1]);\n      if (abs(d) < ) {\n        m[i] = m[i + 1] = 0;\n      } else {\n        a = m[i] / d;\n        b = m[i + 1] / d;\n        s = a * a + b * b;\n        if (s > 9) {\n          s = d * 3 / Math.sqrt(s);\n          m[i] = s * a;\n          m[i + 1] = s * b;\n        }\n      }\n    }\n    i = -1;\n    while (++i <= j) {\n      s = (points[Math.min(j, i + 1)][0] - points[Math.max(0, i - 1)][0]) / (6 * (1 + m[i] * m[i]));\n      tangents.push([ s || 0, m[i] * s || 0 ]);\n    }\n    return tangents;\n  }\n  function d3_svg_lineMonotone(points) {\n    return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineMonotoneTangents(points));\n  }\n  d3.svg.line.radial = function() {\n    var line = d3_svg_line(d3_svg_lineRadial);\n    line.radius = line.x, delete line.x;\n    line.angle = line.y, delete line.y;\n    return line;\n  };\n  function d3_svg_lineRadial(points) {\n    var point, i = -1, n = points.length, r, a;\n    while (++i < n) {\n      point = points[i];\n      r = point[0];\n      a = point[1] - half;\n      point[0] = r * Math.cos(a);\n      point[1] = r * Math.sin(a);\n    }\n    return points;\n  }\n  function d3_svg_area(projection) {\n    var x0 = d3_geom_pointX, x1 = d3_geom_pointX, y0 = 0, y1 = d3_geom_pointY, defined = d3_true, interpolate = d3_svg_lineLinear, interpolateKey = interpolate.key, interpolateReverse = interpolate, L = \"L\", tension = .7;\n    function area(data) {\n      var segments = [], points0 = [], points1 = [], i = -1, n = data.length, d, fx0 = d3_functor(x0), fy0 = d3_functor(y0), fx1 = x0 === x1 ? function() {\n        return x;\n      } : d3_functor(x1), fy1 = y0 === y1 ? function() {\n        return y;\n      } : d3_functor(y1), x, y;\n      function segment() {\n        segments.push(\"M\", interpolate(projection(points1), tension), L, interpolateReverse(projection(points0.reverse()), tension), \"Z\");\n      }\n      while (++i < n) {\n        if (defined.call(this, d = data[i], i)) {\n          points0.push([ x = +fx0.call(this, d, i), y = +fy0.call(this, d, i) ]);\n          points1.push([ +fx1.call(this, d, i), +fy1.call(this, d, i) ]);\n        } else if (points0.length) {\n          segment();\n          points0 = [];\n          points1 = [];\n        }\n      }\n      if (points0.length) segment();\n      return segments.length ? segments.join(\"\") : null;\n    }\n    area.x = function(_) {\n      if (!arguments.length) return x1;\n      x0 = x1 = _;\n      return area;\n    };\n    area.x0 = function(_) {\n      if (!arguments.length) return x0;\n      x0 = _;\n      return area;\n    };\n    area.x1 = function(_) {\n      if (!arguments.length) return x1;\n      x1 = _;\n      return area;\n    };\n    area.y = function(_) {\n      if (!arguments.length) return y1;\n      y0 = y1 = _;\n      return area;\n    };\n    area.y0 = function(_) {\n      if (!arguments.length) return y0;\n      y0 = _;\n      return area;\n    };\n    area.y1 = function(_) {\n      if (!arguments.length) return y1;\n      y1 = _;\n      return area;\n    };\n    area.defined = function(_) {\n      if (!arguments.length) return defined;\n      defined = _;\n      return area;\n    };\n    area.interpolate = function(_) {\n      if (!arguments.length) return interpolateKey;\n      if (typeof _ === \"function\") interpolateKey = interpolate = _; else interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;\n      interpolateReverse = interpolate.reverse || interpolate;\n      L = interpolate.closed ? \"M\" : \"L\";\n      return area;\n    };\n    area.tension = function(_) {\n      if (!arguments.length) return tension;\n      tension = _;\n      return area;\n    };\n    return area;\n  }\n  d3_svg_lineStepBefore.reverse = d3_svg_lineStepAfter;\n  d3_svg_lineStepAfter.reverse = d3_svg_lineStepBefore;\n  d3.svg.area = function() {\n    return d3_svg_area(d3_identity);\n  };\n  d3.svg.area.radial = function() {\n    var area = d3_svg_area(d3_svg_lineRadial);\n    area.radius = area.x, delete area.x;\n    area.innerRadius = area.x0, delete area.x0;\n    area.outerRadius = area.x1, delete area.x1;\n    area.angle = area.y, delete area.y;\n    area.startAngle = area.y0, delete area.y0;\n    area.endAngle = area.y1, delete area.y1;\n    return area;\n  };\n  d3.svg.chord = function() {\n    var source = d3_source, target = d3_target, radius = d3_svg_chordRadius, startAngle = d3_svg_arcStartAngle, endAngle = d3_svg_arcEndAngle;\n    function chord(d, i) {\n      var s = subgroup(this, source, d, i), t = subgroup(this, target, d, i);\n      return \"M\" + s.p0 + arc(s.r, s.p1, s.a1 - s.a0) + (equals(s, t) ? curve(s.r, s.p1, s.r, s.p0) : curve(s.r, s.p1, t.r, t.p0) + arc(t.r, t.p1, t.a1 - t.a0) + curve(t.r, t.p1, s.r, s.p0)) + \"Z\";\n    }\n    function subgroup(self, f, d, i) {\n      var subgroup = f.call(self, d, i), r = radius.call(self, subgroup, i), a0 = startAngle.call(self, subgroup, i) - half, a1 = endAngle.call(self, subgroup, i) - half;\n      return {\n        r: r,\n        a0: a0,\n        a1: a1,\n        p0: [ r * Math.cos(a0), r * Math.sin(a0) ],\n        p1: [ r * Math.cos(a1), r * Math.sin(a1) ]\n      };\n    }\n    function equals(a, b) {\n      return a.a0 == b.a0 && a.a1 == b.a1;\n    }\n    function arc(r, p, a) {\n      return \"A\" + r + \",\" + r + \" 0 \" + +(a > ) + \",1 \" + p;\n    }\n    function curve(r0, p0, r1, p1) {\n      return \"Q 0,0 \" + p1;\n    }\n    chord.radius = function(v) {\n      if (!arguments.length) return radius;\n      radius = d3_functor(v);\n      return chord;\n    };\n    chord.source = function(v) {\n      if (!arguments.length) return source;\n      source = d3_functor(v);\n      return chord;\n    };\n    chord.target = function(v) {\n      if (!arguments.length) return target;\n      target = d3_functor(v);\n      return chord;\n    };\n    chord.startAngle = function(v) {\n      if (!arguments.length) return startAngle;\n      startAngle = d3_functor(v);\n      return chord;\n    };\n    chord.endAngle = function(v) {\n      if (!arguments.length) return endAngle;\n      endAngle = d3_functor(v);\n      return chord;\n    };\n    return chord;\n  };\n  function d3_svg_chordRadius(d) {\n    return d.radius;\n  }\n  d3.svg.diagonal = function() {\n    var source = d3_source, target = d3_target, projection = d3_svg_diagonalProjection;\n    function diagonal(d, i) {\n      var p0 = source.call(this, d, i), p3 = target.call(this, d, i), m = (p0.y + p3.y) / 2, p = [ p0, {\n        x: p0.x,\n        y: m\n      }, {\n        x: p3.x,\n        y: m\n      }, p3 ];\n      p = p.map(projection);\n      return \"M\" + p[0] + \"C\" + p[1] + \" \" + p[2] + \" \" + p[3];\n    }\n    diagonal.source = function(x) {\n      if (!arguments.length) return source;\n      source = d3_functor(x);\n      return diagonal;\n    };\n    diagonal.target = function(x) {\n      if (!arguments.length) return target;\n      target = d3_functor(x);\n      return diagonal;\n    };\n    diagonal.projection = function(x) {\n      if (!arguments.length) return projection;\n      projection = x;\n      return diagonal;\n    };\n    return diagonal;\n  };\n  function d3_svg_diagonalProjection(d) {\n    return [ d.x, d.y ];\n  }\n  d3.svg.diagonal.radial = function() {\n    var diagonal = d3.svg.diagonal(), projection = d3_svg_diagonalProjection, projection_ = diagonal.projection;\n    diagonal.projection = function(x) {\n      return arguments.length ? projection_(d3_svg_diagonalRadialProjection(projection = x)) : projection;\n    };\n    return diagonal;\n  };\n  function d3_svg_diagonalRadialProjection(projection) {\n    return function() {\n      var d = projection.apply(this, arguments), r = d[0], a = d[1] - half;\n      return [ r * Math.cos(a), r * Math.sin(a) ];\n    };\n  }\n  d3.svg.symbol = function() {\n    var type = d3_svg_symbolType, size = d3_svg_symbolSize;\n    function symbol(d, i) {\n      return (d3_svg_symbols.get(type.call(this, d, i)) || d3_svg_symbolCircle)(size.call(this, d, i));\n    }\n    symbol.type = function(x) {\n      if (!arguments.length) return type;\n      type = d3_functor(x);\n      return symbol;\n    };\n    symbol.size = function(x) {\n      if (!arguments.length) return size;\n      size = d3_functor(x);\n      return symbol;\n    };\n    return symbol;\n  };\n  function d3_svg_symbolSize() {\n    return 64;\n  }\n  function d3_svg_symbolType() {\n    return \"circle\";\n  }\n  function d3_svg_symbolCircle(size) {\n    var r = Math.sqrt(size / );\n    return \"M0,\" + r + \"A\" + r + \",\" + r + \" 0 1,1 0,\" + -r + \"A\" + r + \",\" + r + \" 0 1,1 0,\" + r + \"Z\";\n  }\n  var d3_svg_symbols = d3.map({\n    circle: d3_svg_symbolCircle,\n    cross: function(size) {\n      var r = Math.sqrt(size / 5) / 2;\n      return \"M\" + -3 * r + \",\" + -r + \"H\" + -r + \"V\" + -3 * r + \"H\" + r + \"V\" + -r + \"H\" + 3 * r + \"V\" + r + \"H\" + r + \"V\" + 3 * r + \"H\" + -r + \"V\" + r + \"H\" + -3 * r + \"Z\";\n    },\n    diamond: function(size) {\n      var ry = Math.sqrt(size / (2 * d3_svg_symbolTan30)), rx = ry * d3_svg_symbolTan30;\n      return \"M0,\" + -ry + \"L\" + rx + \",0\" + \" 0,\" + ry + \" \" + -rx + \",0\" + \"Z\";\n    },\n    square: function(size) {\n      var r = Math.sqrt(size) / 2;\n      return \"M\" + -r + \",\" + -r + \"L\" + r + \",\" + -r + \" \" + r + \",\" + r + \" \" + -r + \",\" + r + \"Z\";\n    },\n    \"triangle-down\": function(size) {\n      var rx = Math.sqrt(size / d3_svg_symbolSqrt3), ry = rx * d3_svg_symbolSqrt3 / 2;\n      return \"M0,\" + ry + \"L\" + rx + \",\" + -ry + \" \" + -rx + \",\" + -ry + \"Z\";\n    },\n    \"triangle-up\": function(size) {\n      var rx = Math.sqrt(size / d3_svg_symbolSqrt3), ry = rx * d3_svg_symbolSqrt3 / 2;\n      return \"M0,\" + -ry + \"L\" + rx + \",\" + ry + \" \" + -rx + \",\" + ry + \"Z\";\n    }\n  });\n  d3.svg.symbolTypes = d3_svg_symbols.keys();\n  var d3_svg_symbolSqrt3 = Math.sqrt(3), d3_svg_symbolTan30 = Math.tan(30 * d3_radians);\n  d3_selectionPrototype.transition = function(name) {\n    var id = d3_transitionInheritId || ++d3_transitionId, ns = d3_transitionNamespace(name), subgroups = [], subgroup, node, transition = d3_transitionInherit || {\n      time: Date.now(),\n      ease: d3_ease_cubicInOut,\n      delay: 0,\n      duration: 250\n    };\n    for (var j = -1, m = this.length; ++j < m; ) {\n      subgroups.push(subgroup = []);\n      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {\n        if (node = group[i]) d3_transitionNode(node, i, ns, id, transition);\n        subgroup.push(node);\n      }\n    }\n    return d3_transition(subgroups, ns, id);\n  };\n  d3_selectionPrototype.interrupt = function(name) {\n    return this.each(name == null ? d3_selection_interrupt : d3_selection_interruptNS(d3_transitionNamespace(name)));\n  };\n  var d3_selection_interrupt = d3_selection_interruptNS(d3_transitionNamespace());\n  function d3_selection_interruptNS(ns) {\n    return function() {\n      var lock, activeId, active;\n      if ((lock = this[ns]) && (active = lock[activeId = lock.active])) {\n        active.timer.c = null;\n        active.timer.t = NaN;\n        if (--lock.count) delete lock[activeId]; else delete this[ns];\n        lock.active += .5;\n        active.event && active.event.interrupt.call(this, this.__data__, active.index);\n      }\n    };\n  }\n  function d3_transition(groups, ns, id) {\n    d3_subclass(groups, d3_transitionPrototype);\n    groups.namespace = ns;\n    groups.id = id;\n    return groups;\n  }\n  var d3_transitionPrototype = [], d3_transitionId = 0, d3_transitionInheritId, d3_transitionInherit;\n  d3_transitionPrototype.call = d3_selectionPrototype.call;\n  d3_transitionPrototype.empty = d3_selectionPrototype.empty;\n  d3_transitionPrototype.node = d3_selectionPrototype.node;\n  d3_transitionPrototype.size = d3_selectionPrototype.size;\n  d3.transition = function(selection, name) {\n    return selection && selection.transition ? d3_transitionInheritId ? selection.transition(name) : selection : d3.selection().transition(selection);\n  };\n  d3.transition.prototype = d3_transitionPrototype;\n  d3_transitionPrototype.select = function(selector) {\n    var id = this.id, ns = this.namespace, subgroups = [], subgroup, subnode, node;\n    selector = d3_selection_selector(selector);\n    for (var j = -1, m = this.length; ++j < m; ) {\n      subgroups.push(subgroup = []);\n      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {\n        if ((node = group[i]) && (subnode = selector.call(node, node.__data__, i, j))) {\n          if (\"__data__\" in node) subnode.__data__ = node.__data__;\n          d3_transitionNode(subnode, i, ns, id, node[ns][id]);\n          subgroup.push(subnode);\n        } else {\n          subgroup.push(null);\n        }\n      }\n    }\n    return d3_transition(subgroups, ns, id);\n  };\n  d3_transitionPrototype.selectAll = function(selector) {\n    var id = this.id, ns = this.namespace, subgroups = [], subgroup, subnodes, node, subnode, transition;\n    selector = d3_selection_selectorAll(selector);\n    for (var j = -1, m = this.length; ++j < m; ) {\n      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {\n        if (node = group[i]) {\n          transition = node[ns][id];\n          subnodes = selector.call(node, node.__data__, i, j);\n          subgroups.push(subgroup = []);\n          for (var k = -1, o = subnodes.length; ++k < o; ) {\n            if (subnode = subnodes[k]) d3_transitionNode(subnode, k, ns, id, transition);\n            subgroup.push(subnode);\n          }\n        }\n      }\n    }\n    return d3_transition(subgroups, ns, id);\n  };\n  d3_transitionPrototype.filter = function(filter) {\n    var subgroups = [], subgroup, group, node;\n    if (typeof filter !== \"function\") filter = d3_selection_filter(filter);\n    for (var j = 0, m = this.length; j < m; j++) {\n      subgroups.push(subgroup = []);\n      for (var group = this[j], i = 0, n = group.length; i < n; i++) {\n        if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {\n          subgroup.push(node);\n        }\n      }\n    }\n    return d3_transition(subgroups, this.namespace, this.id);\n  };\n  d3_transitionPrototype.tween = function(name, tween) {\n    var id = this.id, ns = this.namespace;\n    if (arguments.length < 2) return this.node()[ns][id].tween.get(name);\n    return d3_selection_each(this, tween == null ? function(node) {\n      node[ns][id].tween.remove(name);\n    } : function(node) {\n      node[ns][id].tween.set(name, tween);\n    });\n  };\n  function d3_transition_tween(groups, name, value, tween) {\n    var id = groups.id, ns = groups.namespace;\n    return d3_selection_each(groups, typeof value === \"function\" ? function(node, i, j) {\n      node[ns][id].tween.set(name, tween(value.call(node, node.__data__, i, j)));\n    } : (value = tween(value), function(node) {\n      node[ns][id].tween.set(name, value);\n    }));\n  }\n  d3_transitionPrototype.attr = function(nameNS, value) {\n    if (arguments.length < 2) {\n      for (value in nameNS) this.attr(value, nameNS[value]);\n      return this;\n    }\n    var interpolate = nameNS == \"transform\" ? d3_interpolateTransform : d3_interpolate, name = d3.ns.qualify(nameNS);\n    function attrNull() {\n      this.removeAttribute(name);\n    }\n    function attrNullNS() {\n      this.removeAttributeNS(name.space, name.local);\n    }\n    function attrTween(b) {\n      return b == null ? attrNull : (b += \"\", function() {\n        var a = this.getAttribute(name), i;\n        return a !== b && (i = interpolate(a, b), function(t) {\n          this.setAttribute(name, i(t));\n        });\n      });\n    }\n    function attrTweenNS(b) {\n      return b == null ? attrNullNS : (b += \"\", function() {\n        var a = this.getAttributeNS(name.space, name.local), i;\n        return a !== b && (i = interpolate(a, b), function(t) {\n          this.setAttributeNS(name.space, name.local, i(t));\n        });\n      });\n    }\n    return d3_transition_tween(this, \"attr.\" + nameNS, value, name.local ? attrTweenNS : attrTween);\n  };\n  d3_transitionPrototype.attrTween = function(nameNS, tween) {\n    var name = d3.ns.qualify(nameNS);\n    function attrTween(d, i) {\n      var f = tween.call(this, d, i, this.getAttribute(name));\n      return f && function(t) {\n        this.setAttribute(name, f(t));\n      };\n    }\n    function attrTweenNS(d, i) {\n      var f = tween.call(this, d, i, this.getAttributeNS(name.space, name.local));\n      return f && function(t) {\n        this.setAttributeNS(name.space, name.local, f(t));\n      };\n    }\n    return this.tween(\"attr.\" + nameNS, name.local ? attrTweenNS : attrTween);\n  };\n  d3_transitionPrototype.style = function(name, value, priority) {\n    var n = arguments.length;\n    if (n < 3) {\n      if (typeof name !== \"string\") {\n        if (n < 2) value = \"\";\n        for (priority in name) this.style(priority, name[priority], value);\n        return this;\n      }\n      priority = \"\";\n    }\n    function styleNull() {\n      this.style.removeProperty(name);\n    }\n    function styleString(b) {\n      return b == null ? styleNull : (b += \"\", function() {\n        var a = d3_window(this).getComputedStyle(this, null).getPropertyValue(name), i;\n        return a !== b && (i = d3_interpolate(a, b), function(t) {\n          this.style.setProperty(name, i(t), priority);\n        });\n      });\n    }\n    return d3_transition_tween(this, \"style.\" + name, value, styleString);\n  };\n  d3_transitionPrototype.styleTween = function(name, tween, priority) {\n    if (arguments.length < 3) priority = \"\";\n    function styleTween(d, i) {\n      var f = tween.call(this, d, i, d3_window(this).getComputedStyle(this, null).getPropertyValue(name));\n      return f && function(t) {\n        this.style.setProperty(name, f(t), priority);\n      };\n    }\n    return this.tween(\"style.\" + name, styleTween);\n  };\n  d3_transitionPrototype.text = function(value) {\n    return d3_transition_tween(this, \"text\", value, d3_transition_text);\n  };\n  function d3_transition_text(b) {\n    if (b == null) b = \"\";\n    return function() {\n      this.textContent = b;\n    };\n  }\n  d3_transitionPrototype.remove = function() {\n    var ns = this.namespace;\n    return this.each(\"end.transition\", function() {\n      var p;\n      if (this[ns].count < 2 && (p = this.parentNode)) p.removeChild(this);\n    });\n  };\n  d3_transitionPrototype.ease = function(value) {\n    var id = this.id, ns = this.namespace;\n    if (arguments.length < 1) return this.node()[ns][id].ease;\n    if (typeof value !== \"function\") value = d3.ease.apply(d3, arguments);\n    return d3_selection_each(this, function(node) {\n      node[ns][id].ease = value;\n    });\n  };\n  d3_transitionPrototype.delay = function(value) {\n    var id = this.id, ns = this.namespace;\n    if (arguments.length < 1) return this.node()[ns][id].delay;\n    return d3_selection_each(this, typeof value === \"function\" ? function(node, i, j) {\n      node[ns][id].delay = +value.call(node, node.__data__, i, j);\n    } : (value = +value, function(node) {\n      node[ns][id].delay = value;\n    }));\n  };\n  d3_transitionPrototype.duration = function(value) {\n    var id = this.id, ns = this.namespace;\n    if (arguments.length < 1) return this.node()[ns][id].duration;\n    return d3_selection_each(this, typeof value === \"function\" ? function(node, i, j) {\n      node[ns][id].duration = Math.max(1, value.call(node, node.__data__, i, j));\n    } : (value = Math.max(1, value), function(node) {\n      node[ns][id].duration = value;\n    }));\n  };\n  d3_transitionPrototype.each = function(type, listener) {\n    var id = this.id, ns = this.namespace;\n    if (arguments.length < 2) {\n      var inherit = d3_transitionInherit, inheritId = d3_transitionInheritId;\n      try {\n        d3_transitionInheritId = id;\n        d3_selection_each(this, function(node, i, j) {\n          d3_transitionInherit = node[ns][id];\n          type.call(node, node.__data__, i, j);\n        });\n      } finally {\n        d3_transitionInherit = inherit;\n        d3_transitionInheritId = inheritId;\n      }\n    } else {\n      d3_selection_each(this, function(node) {\n        var transition = node[ns][id];\n        (transition.event || (transition.event = d3.dispatch(\"start\", \"end\", \"interrupt\"))).on(type, listener);\n      });\n    }\n    return this;\n  };\n  d3_transitionPrototype.transition = function() {\n    var id0 = this.id, id1 = ++d3_transitionId, ns = this.namespace, subgroups = [], subgroup, group, node, transition;\n    for (var j = 0, m = this.length; j < m; j++) {\n      subgroups.push(subgroup = []);\n      for (var group = this[j], i = 0, n = group.length; i < n; i++) {\n        if (node = group[i]) {\n          transition = node[ns][id0];\n          d3_transitionNode(node, i, ns, id1, {\n            time: transition.time,\n            ease: transition.ease,\n            delay: transition.delay + transition.duration,\n            duration: transition.duration\n          });\n        }\n        subgroup.push(node);\n      }\n    }\n    return d3_transition(subgroups, ns, id1);\n  };\n  function d3_transitionNamespace(name) {\n    return name == null ? \"__transition__\" : \"__transition_\" + name + \"__\";\n  }\n  function d3_transitionNode(node, i, ns, id, inherit) {\n    var lock = node[ns] || (node[ns] = {\n      active: 0,\n      count: 0\n    }), transition = lock[id], time, timer, duration, ease, tweens;\n    function schedule(elapsed) {\n      var delay = transition.delay;\n      timer.t = delay + time;\n      if (delay <= elapsed) return start(elapsed - delay);\n      timer.c = start;\n    }\n    function start(elapsed) {\n      var activeId = lock.active, active = lock[activeId];\n      if (active) {\n        active.timer.c = null;\n        active.timer.t = NaN;\n        --lock.count;\n        delete lock[activeId];\n        active.event && active.event.interrupt.call(node, node.__data__, active.index);\n      }\n      for (var cancelId in lock) {\n        if (+cancelId < id) {\n          var cancel = lock[cancelId];\n          cancel.timer.c = null;\n          cancel.timer.t = NaN;\n          --lock.count;\n          delete lock[cancelId];\n        }\n      }\n      timer.c = tick;\n      d3_timer(function() {\n        if (timer.c && tick(elapsed || 1)) {\n          timer.c = null;\n          timer.t = NaN;\n        }\n        return 1;\n      }, 0, time);\n      lock.active = id;\n      transition.event && transition.event.start.call(node, node.__data__, i);\n      tweens = [];\n      transition.tween.forEach(function(key, value) {\n        if (value = value.call(node, node.__data__, i)) {\n          tweens.push(value);\n        }\n      });\n      ease = transition.ease;\n      duration = transition.duration;\n    }\n    function tick(elapsed) {\n      var t = elapsed / duration, e = ease(t), n = tweens.length;\n      while (n > 0) {\n        tweens[--n].call(node, e);\n      }\n      if (t >= 1) {\n        transition.event && transition.event.end.call(node, node.__data__, i);\n        if (--lock.count) delete lock[id]; else delete node[ns];\n        return 1;\n      }\n    }\n    if (!transition) {\n      time = inherit.time;\n      timer = d3_timer(schedule, 0, time);\n      transition = lock[id] = {\n        tween: new d3_Map(),\n        time: time,\n        timer: timer,\n        delay: inherit.delay,\n        duration: inherit.duration,\n        ease: inherit.ease,\n        index: i\n      };\n      inherit = null;\n      ++lock.count;\n    }\n  }\n  d3.svg.axis = function() {\n    var scale = d3.scale.linear(), orient = d3_svg_axisDefaultOrient, innerTickSize = 6, outerTickSize = 6, tickPadding = 3, tickArguments_ = [ 10 ], tickValues = null, tickFormat_;\n    function axis(g) {\n      g.each(function() {\n        var g = d3.select(this);\n        var scale0 = this.__chart__ || scale, scale1 = this.__chart__ = scale.copy();\n        var ticks = tickValues == null ? scale1.ticks ? scale1.ticks.apply(scale1, tickArguments_) : scale1.domain() : tickValues, tickFormat = tickFormat_ == null ? scale1.tickFormat ? scale1.tickFormat.apply(scale1, tickArguments_) : d3_identity : tickFormat_, tick = g.selectAll(\".tick\").data(ticks, scale1), tickEnter = tick.enter().insert(\"g\", \".domain\").attr(\"class\", \"tick\").style(\"opacity\", ), tickExit = d3.transition(tick.exit()).style(\"opacity\", ).remove(), tickUpdate = d3.transition(tick.order()).style(\"opacity\", 1), tickSpacing = Math.max(innerTickSize, 0) + tickPadding, tickTransform;\n        var range = d3_scaleRange(scale1), path = g.selectAll(\".domain\").data([ 0 ]), pathUpdate = (path.enter().append(\"path\").attr(\"class\", \"domain\"), \n        d3.transition(path));\n        tickEnter.append(\"line\");\n        tickEnter.append(\"text\");\n        var lineEnter = tickEnter.select(\"line\"), lineUpdate = tickUpdate.select(\"line\"), text = tick.select(\"text\").text(tickFormat), textEnter = tickEnter.select(\"text\"), textUpdate = tickUpdate.select(\"text\"), sign = orient === \"top\" || orient === \"left\" ? -1 : 1, x1, x2, y1, y2;\n        if (orient === \"bottom\" || orient === \"top\") {\n          tickTransform = d3_svg_axisX, x1 = \"x\", y1 = \"y\", x2 = \"x2\", y2 = \"y2\";\n          text.attr(\"dy\", sign < 0 ? \"0em\" : \".71em\").style(\"text-anchor\", \"middle\");\n          pathUpdate.attr(\"d\", \"M\" + range[0] + \",\" + sign * outerTickSize + \"V0H\" + range[1] + \"V\" + sign * outerTickSize);\n        } else {\n          tickTransform = d3_svg_axisY, x1 = \"y\", y1 = \"x\", x2 = \"y2\", y2 = \"x2\";\n          text.attr(\"dy\", \".32em\").style(\"text-anchor\", sign < 0 ? \"end\" : \"start\");\n          pathUpdate.attr(\"d\", \"M\" + sign * outerTickSize + \",\" + range[0] + \"H0V\" + range[1] + \"H\" + sign * outerTickSize);\n        }\n        lineEnter.attr(y2, sign * innerTickSize);\n        textEnter.attr(y1, sign * tickSpacing);\n        lineUpdate.attr(x2, 0).attr(y2, sign * innerTickSize);\n        textUpdate.attr(x1, 0).attr(y1, sign * tickSpacing);\n        if (scale1.rangeBand) {\n          var x = scale1, dx = x.rangeBand() / 2;\n          scale0 = scale1 = function(d) {\n            return x(d) + dx;\n          };\n        } else if (scale0.rangeBand) {\n          scale0 = scale1;\n        } else {\n          tickExit.call(tickTransform, scale1, scale0);\n        }\n        tickEnter.call(tickTransform, scale0, scale1);\n        tickUpdate.call(tickTransform, scale1, scale1);\n      });\n    }\n    axis.scale = function(x) {\n      if (!arguments.length) return scale;\n      scale = x;\n      return axis;\n    };\n    axis.orient = function(x) {\n      if (!arguments.length) return orient;\n      orient = x in d3_svg_axisOrients ? x + \"\" : d3_svg_axisDefaultOrient;\n      return axis;\n    };\n    axis.ticks = function() {\n      if (!arguments.length) return tickArguments_;\n      tickArguments_ = d3_array(arguments);\n      return axis;\n    };\n    axis.tickValues = function(x) {\n      if (!arguments.length) return tickValues;\n      tickValues = x;\n      return axis;\n    };\n    axis.tickFormat = function(x) {\n      if (!arguments.length) return tickFormat_;\n      tickFormat_ = x;\n      return axis;\n    };\n    axis.tickSize = function(x) {\n      var n = arguments.length;\n      if (!n) return innerTickSize;\n      innerTickSize = +x;\n      outerTickSize = +arguments[n - 1];\n      return axis;\n    };\n    axis.innerTickSize = function(x) {\n      if (!arguments.length) return innerTickSize;\n      innerTickSize = +x;\n      return axis;\n    };\n    axis.outerTickSize = function(x) {\n      if (!arguments.length) return outerTickSize;\n      outerTickSize = +x;\n      return axis;\n    };\n    axis.tickPadding = function(x) {\n      if (!arguments.length) return tickPadding;\n      tickPadding = +x;\n      return axis;\n    };\n    axis.tickSubdivide = function() {\n      return arguments.length && axis;\n    };\n    return axis;\n  };\n  var d3_svg_axisDefaultOrient = \"bottom\", d3_svg_axisOrients = {\n    top: 1,\n    right: 1,\n    bottom: 1,\n    left: 1\n  };\n  function d3_svg_axisX(selection, x0, x1) {\n    selection.attr(\"transform\", function(d) {\n      var v0 = x0(d);\n      return \"translate(\" + (isFinite(v0) ? v0 : x1(d)) + \",0)\";\n    });\n  }\n  function d3_svg_axisY(selection, y0, y1) {\n    selection.attr(\"transform\", function(d) {\n      var v0 = y0(d);\n      return \"translate(0,\" + (isFinite(v0) ? v0 : y1(d)) + \")\";\n    });\n  }\n  d3.svg.brush = function() {\n    var event = d3_eventDispatch(brush, \"brushstart\", \"brush\", \"brushend\"), x = null, y = null, xExtent = [ 0, 0 ], yExtent = [ 0, 0 ], xExtentDomain, yExtentDomain, xClamp = true, yClamp = true, resizes = d3_svg_brushResizes[0];\n    function brush(g) {\n      g.each(function() {\n        var g = d3.select(this).style(\"pointer-events\", \"all\").style(\"-webkit-tap-highlight-color\", \"rgba(0,0,0,0)\").on(\"mousedown.brush\", brushstart).on(\"touchstart.brush\", brushstart);\n        var background = g.selectAll(\".background\").data([ 0 ]);\n        background.enter().append(\"rect\").attr(\"class\", \"background\").style(\"visibility\", \"hidden\").style(\"cursor\", \"crosshair\");\n        g.selectAll(\".extent\").data([ 0 ]).enter().append(\"rect\").attr(\"class\", \"extent\").style(\"cursor\", \"move\");\n        var resize = g.selectAll(\".resize\").data(resizes, d3_identity);\n        resize.exit().remove();\n        resize.enter().append(\"g\").attr(\"class\", function(d) {\n          return \"resize \" + d;\n        }).style(\"cursor\", function(d) {\n          return d3_svg_brushCursor[d];\n        }).append(\"rect\").attr(\"x\", function(d) {\n          return /[ew]$/.test(d) ? -3 : null;\n        }).attr(\"y\", function(d) {\n          return /^[ns]/.test(d) ? -3 : null;\n        }).attr(\"width\", 6).attr(\"height\", 6).style(\"visibility\", \"hidden\");\n        resize.style(\"display\", brush.empty() ? \"none\" : null);\n        var gUpdate = d3.transition(g), backgroundUpdate = d3.transition(background), range;\n        if (x) {\n          range = d3_scaleRange(x);\n          backgroundUpdate.attr(\"x\", range[0]).attr(\"width\", range[1] - range[0]);\n          redrawX(gUpdate);\n        }\n        if (y) {\n          range = d3_scaleRange(y);\n          backgroundUpdate.attr(\"y\", range[0]).attr(\"height\", range[1] - range[0]);\n          redrawY(gUpdate);\n        }\n        redraw(gUpdate);\n      });\n    }\n    brush.event = function(g) {\n      g.each(function() {\n        var event_ = event.of(this, arguments), extent1 = {\n          x: xExtent,\n          y: yExtent,\n          i: xExtentDomain,\n          j: yExtentDomain\n        }, extent0 = this.__chart__ || extent1;\n        this.__chart__ = extent1;\n        if (d3_transitionInheritId) {\n          d3.select(this).transition().each(\"start.brush\", function() {\n            xExtentDomain = extent0.i;\n            yExtentDomain = extent0.j;\n            xExtent = extent0.x;\n            yExtent = extent0.y;\n            event_({\n              type: \"brushstart\"\n            });\n          }).tween(\"brush:brush\", function() {\n            var xi = d3_interpolateArray(xExtent, extent1.x), yi = d3_interpolateArray(yExtent, extent1.y);\n            xExtentDomain = yExtentDomain = null;\n            return function(t) {\n              xExtent = extent1.x = xi(t);\n              yExtent = extent1.y = yi(t);\n              event_({\n                type: \"brush\",\n                mode: \"resize\"\n              });\n            };\n          }).each(\"end.brush\", function() {\n            xExtentDomain = extent1.i;\n            yExtentDomain = extent1.j;\n            event_({\n              type: \"brush\",\n              mode: \"resize\"\n            });\n            event_({\n              type: \"brushend\"\n            });\n          });\n        } else {\n          event_({\n            type: \"brushstart\"\n          });\n          event_({\n            type: \"brush\",\n            mode: \"resize\"\n          });\n          event_({\n            type: \"brushend\"\n          });\n        }\n      });\n    };\n    function redraw(g) {\n      g.selectAll(\".resize\").attr(\"transform\", function(d) {\n        return \"translate(\" + xExtent[+/e$/.test(d)] + \",\" + yExtent[+/^s/.test(d)] + \")\";\n      });\n    }\n    function redrawX(g) {\n      g.select(\".extent\").attr(\"x\", xExtent[0]);\n      g.selectAll(\".extent,.n>rect,.s>rect\").attr(\"width\", xExtent[1] - xExtent[0]);\n    }\n    function redrawY(g) {\n      g.select(\".extent\").attr(\"y\", yExtent[0]);\n      g.selectAll(\".extent,.e>rect,.w>rect\").attr(\"height\", yExtent[1] - yExtent[0]);\n    }\n    function brushstart() {\n      var target = this, eventTarget = d3.select(d3.event.target), event_ = event.of(target, arguments), g = d3.select(target), resizing = eventTarget.datum(), resizingX = !/^(n|s)$/.test(resizing) && x, resizingY = !/^(e|w)$/.test(resizing) && y, dragging = eventTarget.classed(\"extent\"), dragRestore = d3_event_dragSuppress(target), center, origin = d3.mouse(target), offset;\n      var w = d3.select(d3_window(target)).on(\"keydown.brush\", keydown).on(\"keyup.brush\", keyup);\n      if (d3.event.changedTouches) {\n        w.on(\"touchmove.brush\", brushmove).on(\"touchend.brush\", brushend);\n      } else {\n        w.on(\"mousemove.brush\", brushmove).on(\"mouseup.brush\", brushend);\n      }\n      g.interrupt().selectAll(\"*\").interrupt();\n      if (dragging) {\n        origin[0] = xExtent[0] - origin[0];\n        origin[1] = yExtent[0] - origin[1];\n      } else if (resizing) {\n        var ex = +/w$/.test(resizing), ey = +/^n/.test(resizing);\n        offset = [ xExtent[1 - ex] - origin[0], yExtent[1 - ey] - origin[1] ];\n        origin[0] = xExtent[ex];\n        origin[1] = yExtent[ey];\n      } else if (d3.event.altKey) center = origin.slice();\n      g.style(\"pointer-events\", \"none\").selectAll(\".resize\").style(\"display\", null);\n      d3.select(\"body\").style(\"cursor\", eventTarget.style(\"cursor\"));\n      event_({\n        type: \"brushstart\"\n      });\n      brushmove();\n      function keydown() {\n        if (d3.event.keyCode == 32) {\n          if (!dragging) {\n            center = null;\n            origin[0] -= xExtent[1];\n            origin[1] -= yExtent[1];\n            dragging = 2;\n          }\n          d3_eventPreventDefault();\n        }\n      }\n      function keyup() {\n        if (d3.event.keyCode == 32 && dragging == 2) {\n          origin[0] += xExtent[1];\n          origin[1] += yExtent[1];\n          dragging = 0;\n          d3_eventPreventDefault();\n        }\n      }\n      function brushmove() {\n        var point = d3.mouse(target), moved = false;\n        if (offset) {\n          point[0] += offset[0];\n          point[1] += offset[1];\n        }\n        if (!dragging) {\n          if (d3.event.altKey) {\n            if (!center) center = [ (xExtent[0] + xExtent[1]) / 2, (yExtent[0] + yExtent[1]) / 2 ];\n            origin[0] = xExtent[+(point[0] < center[0])];\n            origin[1] = yExtent[+(point[1] < center[1])];\n          } else center = null;\n        }\n        if (resizingX && move1(point, x, 0)) {\n          redrawX(g);\n          moved = true;\n        }\n        if (resizingY && move1(point, y, 1)) {\n          redrawY(g);\n          moved = true;\n        }\n        if (moved) {\n          redraw(g);\n          event_({\n            type: \"brush\",\n            mode: dragging ? \"move\" : \"resize\"\n          });\n        }\n      }\n      function move1(point, scale, i) {\n        var range = d3_scaleRange(scale), r0 = range[0], r1 = range[1], position = origin[i], extent = i ? yExtent : xExtent, size = extent[1] - extent[0], min, max;\n        if (dragging) {\n          r0 -= position;\n          r1 -= size + position;\n        }\n        min = (i ? yClamp : xClamp) ? Math.max(r0, Math.min(r1, point[i])) : point[i];\n        if (dragging) {\n          max = (min += position) + size;\n        } else {\n          if (center) position = Math.max(r0, Math.min(r1, 2 * center[i] - min));\n          if (position < min) {\n            max = min;\n            min = position;\n          } else {\n            max = position;\n          }\n        }\n        if (extent[0] != min || extent[1] != max) {\n          if (i) yExtentDomain = null; else xExtentDomain = null;\n          extent[0] = min;\n          extent[1] = max;\n          return true;\n        }\n      }\n      function brushend() {\n        brushmove();\n        g.style(\"pointer-events\", \"all\").selectAll(\".resize\").style(\"display\", brush.empty() ? \"none\" : null);\n        d3.select(\"body\").style(\"cursor\", null);\n        w.on(\"mousemove.brush\", null).on(\"mouseup.brush\", null).on(\"touchmove.brush\", null).on(\"touchend.brush\", null).on(\"keydown.brush\", null).on(\"keyup.brush\", null);\n        dragRestore();\n        event_({\n          type: \"brushend\"\n        });\n      }\n    }\n    brush.x = function(z) {\n      if (!arguments.length) return x;\n      x = z;\n      resizes = d3_svg_brushResizes[!x << 1 | !y];\n      return brush;\n    };\n    brush.y = function(z) {\n      if (!arguments.length) return y;\n      y = z;\n      resizes = d3_svg_brushResizes[!x << 1 | !y];\n      return brush;\n    };\n    brush.clamp = function(z) {\n      if (!arguments.length) return x && y ? [ xClamp, yClamp ] : x ? xClamp : y ? yClamp : null;\n      if (x && y) xClamp = !!z[0], yClamp = !!z[1]; else if (x) xClamp = !!z; else if (y) yClamp = !!z;\n      return brush;\n    };\n    brush.extent = function(z) {\n      var x0, x1, y0, y1, t;\n      if (!arguments.length) {\n        if (x) {\n          if (xExtentDomain) {\n            x0 = xExtentDomain[0], x1 = xExtentDomain[1];\n          } else {\n            x0 = xExtent[0], x1 = xExtent[1];\n            if (x.invert) x0 = x.invert(x0), x1 = x.invert(x1);\n            if (x1 < x0) t = x0, x0 = x1, x1 = t;\n          }\n        }\n        if (y) {\n          if (yExtentDomain) {\n            y0 = yExtentDomain[0], y1 = yExtentDomain[1];\n          } else {\n            y0 = yExtent[0], y1 = yExtent[1];\n            if (y.invert) y0 = y.invert(y0), y1 = y.invert(y1);\n            if (y1 < y0) t = y0, y0 = y1, y1 = t;\n          }\n        }\n        return x && y ? [ [ x0, y0 ], [ x1, y1 ] ] : x ? [ x0, x1 ] : y && [ y0, y1 ];\n      }\n      if (x) {\n        x0 = z[0], x1 = z[1];\n        if (y) x0 = x0[0], x1 = x1[0];\n        xExtentDomain = [ x0, x1 ];\n        if (x.invert) x0 = x(x0), x1 = x(x1);\n        if (x1 < x0) t = x0, x0 = x1, x1 = t;\n        if (x0 != xExtent[0] || x1 != xExtent[1]) xExtent = [ x0, x1 ];\n      }\n      if (y) {\n        y0 = z[0], y1 = z[1];\n        if (x) y0 = y0[1], y1 = y1[1];\n        yExtentDomain = [ y0, y1 ];\n        if (y.invert) y0 = y(y0), y1 = y(y1);\n        if (y1 < y0) t = y0, y0 = y1, y1 = t;\n        if (y0 != yExtent[0] || y1 != yExtent[1]) yExtent = [ y0, y1 ];\n      }\n      return brush;\n    };\n    brush.clear = function() {\n      if (!brush.empty()) {\n        xExtent = [ 0, 0 ], yExtent = [ 0, 0 ];\n        xExtentDomain = yExtentDomain = null;\n      }\n      return brush;\n    };\n    brush.empty = function() {\n      return !!x && xExtent[0] == xExtent[1] || !!y && yExtent[0] == yExtent[1];\n    };\n    return d3.rebind(brush, event, \"on\");\n  };\n  var d3_svg_brushCursor = {\n    n: \"ns-resize\",\n    e: \"ew-resize\",\n    s: \"ns-resize\",\n    w: \"ew-resize\",\n    nw: \"nwse-resize\",\n    ne: \"nesw-resize\",\n    se: \"nwse-resize\",\n    sw: \"nesw-resize\"\n  };\n  var d3_svg_brushResizes = [ [ \"n\", \"e\", \"s\", \"w\", \"nw\", \"ne\", \"se\", \"sw\" ], [ \"e\", \"w\" ], [ \"n\", \"s\" ], [] ];\n  var d3_time_format = d3_time.format = d3_locale_enUS.timeFormat;\n  var d3_time_formatUtc = d3_time_format.utc;\n  var d3_time_formatIso = d3_time_formatUtc(\"%Y-%m-%dT%H:%M:%S.%LZ\");\n  d3_time_format.iso = Date.prototype.toISOString && +new Date(\"2000-01-01T00:00:00.000Z\") ? d3_time_formatIsoNative : d3_time_formatIso;\n  function d3_time_formatIsoNative(date) {\n    return date.toISOString();\n  }\n  d3_time_formatIsoNative.parse = function(string) {\n    var date = new Date(string);\n    return isNaN(date) ? null : date;\n  };\n  d3_time_formatIsoNative.toString = d3_time_formatIso.toString;\n  d3_time.second = d3_time_interval(function(date) {\n    return new d3_date(Math.floor(date / 1e3) * 1e3);\n  }, function(date, offset) {\n    date.setTime(date.getTime() + Math.floor(offset) * 1e3);\n  }, function(date) {\n    return date.getSeconds();\n  });\n  d3_time.seconds = d3_time.second.range;\n  d3_time.seconds.utc = d3_time.second.utc.range;\n  d3_time.minute = d3_time_interval(function(date) {\n    return new d3_date(Math.floor(date / 6e4) * 6e4);\n  }, function(date, offset) {\n    date.setTime(date.getTime() + Math.floor(offset) * 6e4);\n  }, function(date) {\n    return date.getMinutes();\n  });\n  d3_time.minutes = d3_time.minute.range;\n  d3_time.minutes.utc = d3_time.minute.utc.range;\n  d3_time.hour = d3_time_interval(function(date) {\n    var timezone = date.getTimezoneOffset() / 60;\n    return new d3_date((Math.floor(date / 36e5 - timezone) + timezone) * 36e5);\n  }, function(date, offset) {\n    date.setTime(date.getTime() + Math.floor(offset) * 36e5);\n  }, function(date) {\n    return date.getHours();\n  });\n  d3_time.hours = d3_time.hour.range;\n  d3_time.hours.utc = d3_time.hour.utc.range;\n  d3_time.month = d3_time_interval(function(date) {\n    date = d3_time.day(date);\n    date.setDate(1);\n    return date;\n  }, function(date, offset) {\n    date.setMonth(date.getMonth() + offset);\n  }, function(date) {\n    return date.getMonth();\n  });\n  d3_time.months = d3_time.month.range;\n  d3_time.months.utc = d3_time.month.utc.range;\n  function d3_time_scale(linear, methods, format) {\n    function scale(x) {\n      return linear(x);\n    }\n    scale.invert = function(x) {\n      return d3_time_scaleDate(linear.invert(x));\n    };\n    scale.domain = function(x) {\n      if (!arguments.length) return linear.domain().map(d3_time_scaleDate);\n      linear.domain(x);\n      return scale;\n    };\n    function tickMethod(extent, count) {\n      var span = extent[1] - extent[0], target = span / count, i = d3.bisect(d3_time_scaleSteps, target);\n      return i == d3_time_scaleSteps.length ? [ methods.year, d3_scale_linearTickRange(extent.map(function(d) {\n        return d / 31536e6;\n      }), count)[2] ] : !i ? [ d3_time_scaleMilliseconds, d3_scale_linearTickRange(extent, count)[2] ] : methods[target / d3_time_scaleSteps[i - 1] < d3_time_scaleSteps[i] / target ? i - 1 : i];\n    }\n    scale.nice = function(interval, skip) {\n      var domain = scale.domain(), extent = d3_scaleExtent(domain), method = interval == null ? tickMethod(extent, 10) : typeof interval === \"number\" && tickMethod(extent, interval);\n      if (method) interval = method[0], skip = method[1];\n      function skipped(date) {\n        return !isNaN(date) && !interval.range(date, d3_time_scaleDate(+date + 1), skip).length;\n      }\n      return scale.domain(d3_scale_nice(domain, skip > 1 ? {\n        floor: function(date) {\n          while (skipped(date = interval.floor(date))) date = d3_time_scaleDate(date - 1);\n          return date;\n        },\n        ceil: function(date) {\n          while (skipped(date = interval.ceil(date))) date = d3_time_scaleDate(+date + 1);\n          return date;\n        }\n      } : interval));\n    };\n    scale.ticks = function(interval, skip) {\n      var extent = d3_scaleExtent(scale.domain()), method = interval == null ? tickMethod(extent, 10) : typeof interval === \"number\" ? tickMethod(extent, interval) : !interval.range && [ {\n        range: interval\n      }, skip ];\n      if (method) interval = method[0], skip = method[1];\n      return interval.range(extent[0], d3_time_scaleDate(+extent[1] + 1), skip < 1 ? 1 : skip);\n    };\n    scale.tickFormat = function() {\n      return format;\n    };\n    scale.copy = function() {\n      return d3_time_scale(linear.copy(), methods, format);\n    };\n    return d3_scale_linearRebind(scale, linear);\n  }\n  function d3_time_scaleDate(t) {\n    return new Date(t);\n  }\n  var d3_time_scaleSteps = [ 1e3, 5e3, 15e3, 3e4, 6e4, 3e5, 9e5, 18e5, 36e5, 108e5, 216e5, 432e5, 864e5, 1728e5, 6048e5, 2592e6, 7776e6, 31536e6 ];\n  var d3_time_scaleLocalMethods = [ [ d3_time.second, 1 ], [ d3_time.second, 5 ], [ d3_time.second, 15 ], [ d3_time.second, 30 ], [ d3_time.minute, 1 ], [ d3_time.minute, 5 ], [ d3_time.minute, 15 ], [ d3_time.minute, 30 ], [ d3_time.hour, 1 ], [ d3_time.hour, 3 ], [ d3_time.hour, 6 ], [ d3_time.hour, 12 ], [ d3_time.day, 1 ], [ d3_time.day, 2 ], [ d3_time.week, 1 ], [ d3_time.month, 1 ], [ d3_time.month, 3 ], [ d3_time.year, 1 ] ];\n  var d3_time_scaleLocalFormat = d3_time_format.multi([ [ \".%L\", function(d) {\n    return d.getMilliseconds();\n  } ], [ \":%S\", function(d) {\n    return d.getSeconds();\n  } ], [ \"%I:%M\", function(d) {\n    return d.getMinutes();\n  } ], [ \"%I %p\", function(d) {\n    return d.getHours();\n  } ], [ \"%a %d\", function(d) {\n    return d.getDay() && d.getDate() != 1;\n  } ], [ \"%b %d\", function(d) {\n    return d.getDate() != 1;\n  } ], [ \"%B\", function(d) {\n    return d.getMonth();\n  } ], [ \"%Y\", d3_true ] ]);\n  var d3_time_scaleMilliseconds = {\n    range: function(start, stop, step) {\n      return d3.range(Math.ceil(start / step) * step, +stop, step).map(d3_time_scaleDate);\n    },\n    floor: d3_identity,\n    ceil: d3_identity\n  };\n  d3_time_scaleLocalMethods.year = d3_time.year;\n  d3_time.scale = function() {\n    return d3_time_scale(d3.scale.linear(), d3_time_scaleLocalMethods, d3_time_scaleLocalFormat);\n  };\n  var d3_time_scaleUtcMethods = d3_time_scaleLocalMethods.map(function(m) {\n    return [ m[0].utc, m[1] ];\n  });\n  var d3_time_scaleUtcFormat = d3_time_formatUtc.multi([ [ \".%L\", function(d) {\n    return d.getUTCMilliseconds();\n  } ], [ \":%S\", function(d) {\n    return d.getUTCSeconds();\n  } ], [ \"%I:%M\", function(d) {\n    return d.getUTCMinutes();\n  } ], [ \"%I %p\", function(d) {\n    return d.getUTCHours();\n  } ], [ \"%a %d\", function(d) {\n    return d.getUTCDay() && d.getUTCDate() != 1;\n  } ], [ \"%b %d\", function(d) {\n    return d.getUTCDate() != 1;\n  } ], [ \"%B\", function(d) {\n    return d.getUTCMonth();\n  } ], [ \"%Y\", d3_true ] ]);\n  d3_time_scaleUtcMethods.year = d3_time.year.utc;\n  d3_time.scale.utc = function() {\n    return d3_time_scale(d3.scale.linear(), d3_time_scaleUtcMethods, d3_time_scaleUtcFormat);\n  };\n  d3.text = d3_xhrType(function(request) {\n    return request.responseText;\n  });\n  d3.json = function(url, callback) {\n    return d3_xhr(url, \"application/json\", d3_json, callback);\n  };\n  function d3_json(request) {\n    return JSON.parse(request.responseText);\n  }\n  d3.html = function(url, callback) {\n    return d3_xhr(url, \"text/html\", d3_html, callback);\n  };\n  function d3_html(request) {\n    var range = d3_document.createRange();\n    range.selectNode(d3_document.body);\n    return range.createContextualFragment(request.responseText);\n  }\n  d3.xml = d3_xhrType(function(request) {\n    return request.responseXML;\n  });\n  if (true) this.d3 = d3, !(__WEBPACK_AMD_DEFINE_FACTORY__ = (d3),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); else if (typeof module === \"object\" && module.exports) module.exports = d3; else this.d3 = d3;\n}();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjk1LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vZ2FsYXh5L3NjcmlwdHMvbGlicy9kMy5qcz8zOTY0Il0sInNvdXJjZXNDb250ZW50IjpbIiFmdW5jdGlvbigpIHtcbiAgdmFyIGQzID0ge1xuICAgIHZlcnNpb246IFwiMy41LjE3XCJcbiAgfTtcbiAgdmFyIGQzX2FycmF5U2xpY2UgPSBbXS5zbGljZSwgZDNfYXJyYXkgPSBmdW5jdGlvbihsaXN0KSB7XG4gICAgcmV0dXJuIGQzX2FycmF5U2xpY2UuY2FsbChsaXN0KTtcbiAgfTtcbiAgdmFyIGQzX2RvY3VtZW50ID0gdGhpcy5kb2N1bWVudDtcbiAgZnVuY3Rpb24gZDNfZG9jdW1lbnRFbGVtZW50KG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZSAmJiAobm9kZS5vd25lckRvY3VtZW50IHx8IG5vZGUuZG9jdW1lbnQgfHwgbm9kZSkuZG9jdW1lbnRFbGVtZW50O1xuICB9XG4gIGZ1bmN0aW9uIGQzX3dpbmRvdyhub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUgJiYgKG5vZGUub3duZXJEb2N1bWVudCAmJiBub2RlLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcgfHwgbm9kZS5kb2N1bWVudCAmJiBub2RlIHx8IG5vZGUuZGVmYXVsdFZpZXcpO1xuICB9XG4gIGlmIChkM19kb2N1bWVudCkge1xuICAgIHRyeSB7XG4gICAgICBkM19hcnJheShkM19kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2hpbGROb2RlcylbMF0ubm9kZVR5cGU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZDNfYXJyYXkgPSBmdW5jdGlvbihsaXN0KSB7XG4gICAgICAgIHZhciBpID0gbGlzdC5sZW5ndGgsIGFycmF5ID0gbmV3IEFycmF5KGkpO1xuICAgICAgICB3aGlsZSAoaS0tKSBhcnJheVtpXSA9IGxpc3RbaV07XG4gICAgICAgIHJldHVybiBhcnJheTtcbiAgICAgIH07XG4gICAgfVxuICB9XG4gIGlmICghRGF0ZS5ub3cpIERhdGUubm93ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICtuZXcgRGF0ZSgpO1xuICB9O1xuICBpZiAoZDNfZG9jdW1lbnQpIHtcbiAgICB0cnkge1xuICAgICAgZDNfZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIkRJVlwiKS5zdHlsZS5zZXRQcm9wZXJ0eShcIm9wYWNpdHlcIiwgMCwgXCJcIik7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHZhciBkM19lbGVtZW50X3Byb3RvdHlwZSA9IHRoaXMuRWxlbWVudC5wcm90b3R5cGUsIGQzX2VsZW1lbnRfc2V0QXR0cmlidXRlID0gZDNfZWxlbWVudF9wcm90b3R5cGUuc2V0QXR0cmlidXRlLCBkM19lbGVtZW50X3NldEF0dHJpYnV0ZU5TID0gZDNfZWxlbWVudF9wcm90b3R5cGUuc2V0QXR0cmlidXRlTlMsIGQzX3N0eWxlX3Byb3RvdHlwZSA9IHRoaXMuQ1NTU3R5bGVEZWNsYXJhdGlvbi5wcm90b3R5cGUsIGQzX3N0eWxlX3NldFByb3BlcnR5ID0gZDNfc3R5bGVfcHJvdG90eXBlLnNldFByb3BlcnR5O1xuICAgICAgZDNfZWxlbWVudF9wcm90b3R5cGUuc2V0QXR0cmlidXRlID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICAgICAgZDNfZWxlbWVudF9zZXRBdHRyaWJ1dGUuY2FsbCh0aGlzLCBuYW1lLCB2YWx1ZSArIFwiXCIpO1xuICAgICAgfTtcbiAgICAgIGQzX2VsZW1lbnRfcHJvdG90eXBlLnNldEF0dHJpYnV0ZU5TID0gZnVuY3Rpb24oc3BhY2UsIGxvY2FsLCB2YWx1ZSkge1xuICAgICAgICBkM19lbGVtZW50X3NldEF0dHJpYnV0ZU5TLmNhbGwodGhpcywgc3BhY2UsIGxvY2FsLCB2YWx1ZSArIFwiXCIpO1xuICAgICAgfTtcbiAgICAgIGQzX3N0eWxlX3Byb3RvdHlwZS5zZXRQcm9wZXJ0eSA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlLCBwcmlvcml0eSkge1xuICAgICAgICBkM19zdHlsZV9zZXRQcm9wZXJ0eS5jYWxsKHRoaXMsIG5hbWUsIHZhbHVlICsgXCJcIiwgcHJpb3JpdHkpO1xuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgZDMuYXNjZW5kaW5nID0gZDNfYXNjZW5kaW5nO1xuICBmdW5jdGlvbiBkM19hc2NlbmRpbmcoYSwgYikge1xuICAgIHJldHVybiBhIDwgYiA/IC0xIDogYSA+IGIgPyAxIDogYSA+PSBiID8gMCA6IE5hTjtcbiAgfVxuICBkMy5kZXNjZW5kaW5nID0gZnVuY3Rpb24oYSwgYikge1xuICAgIHJldHVybiBiIDwgYSA/IC0xIDogYiA+IGEgPyAxIDogYiA+PSBhID8gMCA6IE5hTjtcbiAgfTtcbiAgZDMubWluID0gZnVuY3Rpb24oYXJyYXksIGYpIHtcbiAgICB2YXIgaSA9IC0xLCBuID0gYXJyYXkubGVuZ3RoLCBhLCBiO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICB3aGlsZSAoKytpIDwgbikgaWYgKChiID0gYXJyYXlbaV0pICE9IG51bGwgJiYgYiA+PSBiKSB7XG4gICAgICAgIGEgPSBiO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHdoaWxlICgrK2kgPCBuKSBpZiAoKGIgPSBhcnJheVtpXSkgIT0gbnVsbCAmJiBhID4gYikgYSA9IGI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdoaWxlICgrK2kgPCBuKSBpZiAoKGIgPSBmLmNhbGwoYXJyYXksIGFycmF5W2ldLCBpKSkgIT0gbnVsbCAmJiBiID49IGIpIHtcbiAgICAgICAgYSA9IGI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgd2hpbGUgKCsraSA8IG4pIGlmICgoYiA9IGYuY2FsbChhcnJheSwgYXJyYXlbaV0sIGkpKSAhPSBudWxsICYmIGEgPiBiKSBhID0gYjtcbiAgICB9XG4gICAgcmV0dXJuIGE7XG4gIH07XG4gIGQzLm1heCA9IGZ1bmN0aW9uKGFycmF5LCBmKSB7XG4gICAgdmFyIGkgPSAtMSwgbiA9IGFycmF5Lmxlbmd0aCwgYSwgYjtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgd2hpbGUgKCsraSA8IG4pIGlmICgoYiA9IGFycmF5W2ldKSAhPSBudWxsICYmIGIgPj0gYikge1xuICAgICAgICBhID0gYjtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICB3aGlsZSAoKytpIDwgbikgaWYgKChiID0gYXJyYXlbaV0pICE9IG51bGwgJiYgYiA+IGEpIGEgPSBiO1xuICAgIH0gZWxzZSB7XG4gICAgICB3aGlsZSAoKytpIDwgbikgaWYgKChiID0gZi5jYWxsKGFycmF5LCBhcnJheVtpXSwgaSkpICE9IG51bGwgJiYgYiA+PSBiKSB7XG4gICAgICAgIGEgPSBiO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHdoaWxlICgrK2kgPCBuKSBpZiAoKGIgPSBmLmNhbGwoYXJyYXksIGFycmF5W2ldLCBpKSkgIT0gbnVsbCAmJiBiID4gYSkgYSA9IGI7XG4gICAgfVxuICAgIHJldHVybiBhO1xuICB9O1xuICBkMy5leHRlbnQgPSBmdW5jdGlvbihhcnJheSwgZikge1xuICAgIHZhciBpID0gLTEsIG4gPSBhcnJheS5sZW5ndGgsIGEsIGIsIGM7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHdoaWxlICgrK2kgPCBuKSBpZiAoKGIgPSBhcnJheVtpXSkgIT0gbnVsbCAmJiBiID49IGIpIHtcbiAgICAgICAgYSA9IGMgPSBiO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHdoaWxlICgrK2kgPCBuKSBpZiAoKGIgPSBhcnJheVtpXSkgIT0gbnVsbCkge1xuICAgICAgICBpZiAoYSA+IGIpIGEgPSBiO1xuICAgICAgICBpZiAoYyA8IGIpIGMgPSBiO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB3aGlsZSAoKytpIDwgbikgaWYgKChiID0gZi5jYWxsKGFycmF5LCBhcnJheVtpXSwgaSkpICE9IG51bGwgJiYgYiA+PSBiKSB7XG4gICAgICAgIGEgPSBjID0gYjtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICB3aGlsZSAoKytpIDwgbikgaWYgKChiID0gZi5jYWxsKGFycmF5LCBhcnJheVtpXSwgaSkpICE9IG51bGwpIHtcbiAgICAgICAgaWYgKGEgPiBiKSBhID0gYjtcbiAgICAgICAgaWYgKGMgPCBiKSBjID0gYjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFsgYSwgYyBdO1xuICB9O1xuICBmdW5jdGlvbiBkM19udW1iZXIoeCkge1xuICAgIHJldHVybiB4ID09PSBudWxsID8gTmFOIDogK3g7XG4gIH1cbiAgZnVuY3Rpb24gZDNfbnVtZXJpYyh4KSB7XG4gICAgcmV0dXJuICFpc05hTih4KTtcbiAgfVxuICBkMy5zdW0gPSBmdW5jdGlvbihhcnJheSwgZikge1xuICAgIHZhciBzID0gMCwgbiA9IGFycmF5Lmxlbmd0aCwgYSwgaSA9IC0xO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICB3aGlsZSAoKytpIDwgbikgaWYgKGQzX251bWVyaWMoYSA9ICthcnJheVtpXSkpIHMgKz0gYTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2hpbGUgKCsraSA8IG4pIGlmIChkM19udW1lcmljKGEgPSArZi5jYWxsKGFycmF5LCBhcnJheVtpXSwgaSkpKSBzICs9IGE7XG4gICAgfVxuICAgIHJldHVybiBzO1xuICB9O1xuICBkMy5tZWFuID0gZnVuY3Rpb24oYXJyYXksIGYpIHtcbiAgICB2YXIgcyA9IDAsIG4gPSBhcnJheS5sZW5ndGgsIGEsIGkgPSAtMSwgaiA9IG47XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHdoaWxlICgrK2kgPCBuKSBpZiAoZDNfbnVtZXJpYyhhID0gZDNfbnVtYmVyKGFycmF5W2ldKSkpIHMgKz0gYTsgZWxzZSAtLWo7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdoaWxlICgrK2kgPCBuKSBpZiAoZDNfbnVtZXJpYyhhID0gZDNfbnVtYmVyKGYuY2FsbChhcnJheSwgYXJyYXlbaV0sIGkpKSkpIHMgKz0gYTsgZWxzZSAtLWo7XG4gICAgfVxuICAgIGlmIChqKSByZXR1cm4gcyAvIGo7XG4gIH07XG4gIGQzLnF1YW50aWxlID0gZnVuY3Rpb24odmFsdWVzLCBwKSB7XG4gICAgdmFyIEggPSAodmFsdWVzLmxlbmd0aCAtIDEpICogcCArIDEsIGggPSBNYXRoLmZsb29yKEgpLCB2ID0gK3ZhbHVlc1toIC0gMV0sIGUgPSBIIC0gaDtcbiAgICByZXR1cm4gZSA/IHYgKyBlICogKHZhbHVlc1toXSAtIHYpIDogdjtcbiAgfTtcbiAgZDMubWVkaWFuID0gZnVuY3Rpb24oYXJyYXksIGYpIHtcbiAgICB2YXIgbnVtYmVycyA9IFtdLCBuID0gYXJyYXkubGVuZ3RoLCBhLCBpID0gLTE7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHdoaWxlICgrK2kgPCBuKSBpZiAoZDNfbnVtZXJpYyhhID0gZDNfbnVtYmVyKGFycmF5W2ldKSkpIG51bWJlcnMucHVzaChhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2hpbGUgKCsraSA8IG4pIGlmIChkM19udW1lcmljKGEgPSBkM19udW1iZXIoZi5jYWxsKGFycmF5LCBhcnJheVtpXSwgaSkpKSkgbnVtYmVycy5wdXNoKGEpO1xuICAgIH1cbiAgICBpZiAobnVtYmVycy5sZW5ndGgpIHJldHVybiBkMy5xdWFudGlsZShudW1iZXJzLnNvcnQoZDNfYXNjZW5kaW5nKSwgLjUpO1xuICB9O1xuICBkMy52YXJpYW5jZSA9IGZ1bmN0aW9uKGFycmF5LCBmKSB7XG4gICAgdmFyIG4gPSBhcnJheS5sZW5ndGgsIG0gPSAwLCBhLCBkLCBzID0gMCwgaSA9IC0xLCBqID0gMDtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgaWYgKGQzX251bWVyaWMoYSA9IGQzX251bWJlcihhcnJheVtpXSkpKSB7XG4gICAgICAgICAgZCA9IGEgLSBtO1xuICAgICAgICAgIG0gKz0gZCAvICsrajtcbiAgICAgICAgICBzICs9IGQgKiAoYSAtIG0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgIGlmIChkM19udW1lcmljKGEgPSBkM19udW1iZXIoZi5jYWxsKGFycmF5LCBhcnJheVtpXSwgaSkpKSkge1xuICAgICAgICAgIGQgPSBhIC0gbTtcbiAgICAgICAgICBtICs9IGQgLyArK2o7XG4gICAgICAgICAgcyArPSBkICogKGEgLSBtKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaiA+IDEpIHJldHVybiBzIC8gKGogLSAxKTtcbiAgfTtcbiAgZDMuZGV2aWF0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHYgPSBkMy52YXJpYW5jZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHJldHVybiB2ID8gTWF0aC5zcXJ0KHYpIDogdjtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfYmlzZWN0b3IoY29tcGFyZSkge1xuICAgIHJldHVybiB7XG4gICAgICBsZWZ0OiBmdW5jdGlvbihhLCB4LCBsbywgaGkpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAzKSBsbyA9IDA7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgNCkgaGkgPSBhLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGxvIDwgaGkpIHtcbiAgICAgICAgICB2YXIgbWlkID0gbG8gKyBoaSA+Pj4gMTtcbiAgICAgICAgICBpZiAoY29tcGFyZShhW21pZF0sIHgpIDwgMCkgbG8gPSBtaWQgKyAxOyBlbHNlIGhpID0gbWlkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsbztcbiAgICAgIH0sXG4gICAgICByaWdodDogZnVuY3Rpb24oYSwgeCwgbG8sIGhpKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMykgbG8gPSAwO1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDQpIGhpID0gYS5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChsbyA8IGhpKSB7XG4gICAgICAgICAgdmFyIG1pZCA9IGxvICsgaGkgPj4+IDE7XG4gICAgICAgICAgaWYgKGNvbXBhcmUoYVttaWRdLCB4KSA+IDApIGhpID0gbWlkOyBlbHNlIGxvID0gbWlkICsgMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbG87XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICB2YXIgZDNfYmlzZWN0ID0gZDNfYmlzZWN0b3IoZDNfYXNjZW5kaW5nKTtcbiAgZDMuYmlzZWN0TGVmdCA9IGQzX2Jpc2VjdC5sZWZ0O1xuICBkMy5iaXNlY3QgPSBkMy5iaXNlY3RSaWdodCA9IGQzX2Jpc2VjdC5yaWdodDtcbiAgZDMuYmlzZWN0b3IgPSBmdW5jdGlvbihmKSB7XG4gICAgcmV0dXJuIGQzX2Jpc2VjdG9yKGYubGVuZ3RoID09PSAxID8gZnVuY3Rpb24oZCwgeCkge1xuICAgICAgcmV0dXJuIGQzX2FzY2VuZGluZyhmKGQpLCB4KTtcbiAgICB9IDogZik7XG4gIH07XG4gIGQzLnNodWZmbGUgPSBmdW5jdGlvbihhcnJheSwgaTAsIGkxKSB7XG4gICAgaWYgKChtID0gYXJndW1lbnRzLmxlbmd0aCkgPCAzKSB7XG4gICAgICBpMSA9IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmIChtIDwgMikgaTAgPSAwO1xuICAgIH1cbiAgICB2YXIgbSA9IGkxIC0gaTAsIHQsIGk7XG4gICAgd2hpbGUgKG0pIHtcbiAgICAgIGkgPSBNYXRoLnJhbmRvbSgpICogbS0tIHwgMDtcbiAgICAgIHQgPSBhcnJheVttICsgaTBdLCBhcnJheVttICsgaTBdID0gYXJyYXlbaSArIGkwXSwgYXJyYXlbaSArIGkwXSA9IHQ7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbiAgfTtcbiAgZDMucGVybXV0ZSA9IGZ1bmN0aW9uKGFycmF5LCBpbmRleGVzKSB7XG4gICAgdmFyIGkgPSBpbmRleGVzLmxlbmd0aCwgcGVybXV0ZXMgPSBuZXcgQXJyYXkoaSk7XG4gICAgd2hpbGUgKGktLSkgcGVybXV0ZXNbaV0gPSBhcnJheVtpbmRleGVzW2ldXTtcbiAgICByZXR1cm4gcGVybXV0ZXM7XG4gIH07XG4gIGQzLnBhaXJzID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICB2YXIgaSA9IDAsIG4gPSBhcnJheS5sZW5ndGggLSAxLCBwMCwgcDEgPSBhcnJheVswXSwgcGFpcnMgPSBuZXcgQXJyYXkobiA8IDAgPyAwIDogbik7XG4gICAgd2hpbGUgKGkgPCBuKSBwYWlyc1tpXSA9IFsgcDAgPSBwMSwgcDEgPSBhcnJheVsrK2ldIF07XG4gICAgcmV0dXJuIHBhaXJzO1xuICB9O1xuICBkMy50cmFuc3Bvc2UgPSBmdW5jdGlvbihtYXRyaXgpIHtcbiAgICBpZiAoIShuID0gbWF0cml4Lmxlbmd0aCkpIHJldHVybiBbXTtcbiAgICBmb3IgKHZhciBpID0gLTEsIG0gPSBkMy5taW4obWF0cml4LCBkM190cmFuc3Bvc2VMZW5ndGgpLCB0cmFuc3Bvc2UgPSBuZXcgQXJyYXkobSk7ICsraSA8IG07ICkge1xuICAgICAgZm9yICh2YXIgaiA9IC0xLCBuLCByb3cgPSB0cmFuc3Bvc2VbaV0gPSBuZXcgQXJyYXkobik7ICsraiA8IG47ICkge1xuICAgICAgICByb3dbal0gPSBtYXRyaXhbal1baV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cmFuc3Bvc2U7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX3RyYW5zcG9zZUxlbmd0aChkKSB7XG4gICAgcmV0dXJuIGQubGVuZ3RoO1xuICB9XG4gIGQzLnppcCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkMy50cmFuc3Bvc2UoYXJndW1lbnRzKTtcbiAgfTtcbiAgZDMua2V5cyA9IGZ1bmN0aW9uKG1hcCkge1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG1hcCkga2V5cy5wdXNoKGtleSk7XG4gICAgcmV0dXJuIGtleXM7XG4gIH07XG4gIGQzLnZhbHVlcyA9IGZ1bmN0aW9uKG1hcCkge1xuICAgIHZhciB2YWx1ZXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gbWFwKSB2YWx1ZXMucHVzaChtYXBba2V5XSk7XG4gICAgcmV0dXJuIHZhbHVlcztcbiAgfTtcbiAgZDMuZW50cmllcyA9IGZ1bmN0aW9uKG1hcCkge1xuICAgIHZhciBlbnRyaWVzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG1hcCkgZW50cmllcy5wdXNoKHtcbiAgICAgIGtleToga2V5LFxuICAgICAgdmFsdWU6IG1hcFtrZXldXG4gICAgfSk7XG4gICAgcmV0dXJuIGVudHJpZXM7XG4gIH07XG4gIGQzLm1lcmdlID0gZnVuY3Rpb24oYXJyYXlzKSB7XG4gICAgdmFyIG4gPSBhcnJheXMubGVuZ3RoLCBtLCBpID0gLTEsIGogPSAwLCBtZXJnZWQsIGFycmF5O1xuICAgIHdoaWxlICgrK2kgPCBuKSBqICs9IGFycmF5c1tpXS5sZW5ndGg7XG4gICAgbWVyZ2VkID0gbmV3IEFycmF5KGopO1xuICAgIHdoaWxlICgtLW4gPj0gMCkge1xuICAgICAgYXJyYXkgPSBhcnJheXNbbl07XG4gICAgICBtID0gYXJyYXkubGVuZ3RoO1xuICAgICAgd2hpbGUgKC0tbSA+PSAwKSB7XG4gICAgICAgIG1lcmdlZFstLWpdID0gYXJyYXlbbV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtZXJnZWQ7XG4gIH07XG4gIHZhciBhYnMgPSBNYXRoLmFicztcbiAgZDMucmFuZ2UgPSBmdW5jdGlvbihzdGFydCwgc3RvcCwgc3RlcCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMykge1xuICAgICAgc3RlcCA9IDE7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgc3RvcCA9IHN0YXJ0O1xuICAgICAgICBzdGFydCA9IDA7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICgoc3RvcCAtIHN0YXJ0KSAvIHN0ZXAgPT09IEluZmluaXR5KSB0aHJvdyBuZXcgRXJyb3IoXCJpbmZpbml0ZSByYW5nZVwiKTtcbiAgICB2YXIgcmFuZ2UgPSBbXSwgayA9IGQzX3JhbmdlX2ludGVnZXJTY2FsZShhYnMoc3RlcCkpLCBpID0gLTEsIGo7XG4gICAgc3RhcnQgKj0gaywgc3RvcCAqPSBrLCBzdGVwICo9IGs7XG4gICAgaWYgKHN0ZXAgPCAwKSB3aGlsZSAoKGogPSBzdGFydCArIHN0ZXAgKiArK2kpID4gc3RvcCkgcmFuZ2UucHVzaChqIC8gayk7IGVsc2Ugd2hpbGUgKChqID0gc3RhcnQgKyBzdGVwICogKytpKSA8IHN0b3ApIHJhbmdlLnB1c2goaiAvIGspO1xuICAgIHJldHVybiByYW5nZTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfcmFuZ2VfaW50ZWdlclNjYWxlKHgpIHtcbiAgICB2YXIgayA9IDE7XG4gICAgd2hpbGUgKHggKiBrICUgMSkgayAqPSAxMDtcbiAgICByZXR1cm4gaztcbiAgfVxuICBmdW5jdGlvbiBkM19jbGFzcyhjdG9yLCBwcm9wZXJ0aWVzKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHByb3BlcnRpZXMpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdG9yLnByb3RvdHlwZSwga2V5LCB7XG4gICAgICAgIHZhbHVlOiBwcm9wZXJ0aWVzW2tleV0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgZDMubWFwID0gZnVuY3Rpb24ob2JqZWN0LCBmKSB7XG4gICAgdmFyIG1hcCA9IG5ldyBkM19NYXAoKTtcbiAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgZDNfTWFwKSB7XG4gICAgICBvYmplY3QuZm9yRWFjaChmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICAgIG1hcC5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkob2JqZWN0KSkge1xuICAgICAgdmFyIGkgPSAtMSwgbiA9IG9iamVjdC5sZW5ndGgsIG87XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkgd2hpbGUgKCsraSA8IG4pIG1hcC5zZXQoaSwgb2JqZWN0W2ldKTsgZWxzZSB3aGlsZSAoKytpIDwgbikgbWFwLnNldChmLmNhbGwob2JqZWN0LCBvID0gb2JqZWN0W2ldLCBpKSwgbyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIG1hcC5zZXQoa2V5LCBvYmplY3Rba2V5XSk7XG4gICAgfVxuICAgIHJldHVybiBtYXA7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX01hcCgpIHtcbiAgICB0aGlzLl8gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB9XG4gIHZhciBkM19tYXBfcHJvdG8gPSBcIl9fcHJvdG9fX1wiLCBkM19tYXBfemVybyA9IFwiXFx4MDBcIjtcbiAgZDNfY2xhc3MoZDNfTWFwLCB7XG4gICAgaGFzOiBkM19tYXBfaGFzLFxuICAgIGdldDogZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy5fW2QzX21hcF9lc2NhcGUoa2V5KV07XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9bZDNfbWFwX2VzY2FwZShrZXkpXSA9IHZhbHVlO1xuICAgIH0sXG4gICAgcmVtb3ZlOiBkM19tYXBfcmVtb3ZlLFxuICAgIGtleXM6IGQzX21hcF9rZXlzLFxuICAgIHZhbHVlczogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdmFsdWVzID0gW107XG4gICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5fKSB2YWx1ZXMucHVzaCh0aGlzLl9ba2V5XSk7XG4gICAgICByZXR1cm4gdmFsdWVzO1xuICAgIH0sXG4gICAgZW50cmllczogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZW50cmllcyA9IFtdO1xuICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMuXykgZW50cmllcy5wdXNoKHtcbiAgICAgICAga2V5OiBkM19tYXBfdW5lc2NhcGUoa2V5KSxcbiAgICAgICAgdmFsdWU6IHRoaXMuX1trZXldXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBlbnRyaWVzO1xuICAgIH0sXG4gICAgc2l6ZTogZDNfbWFwX3NpemUsXG4gICAgZW1wdHk6IGQzX21hcF9lbXB0eSxcbiAgICBmb3JFYWNoOiBmdW5jdGlvbihmKSB7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5fKSBmLmNhbGwodGhpcywgZDNfbWFwX3VuZXNjYXBlKGtleSksIHRoaXMuX1trZXldKTtcbiAgICB9XG4gIH0pO1xuICBmdW5jdGlvbiBkM19tYXBfZXNjYXBlKGtleSkge1xuICAgIHJldHVybiAoa2V5ICs9IFwiXCIpID09PSBkM19tYXBfcHJvdG8gfHwga2V5WzBdID09PSBkM19tYXBfemVybyA/IGQzX21hcF96ZXJvICsga2V5IDoga2V5O1xuICB9XG4gIGZ1bmN0aW9uIGQzX21hcF91bmVzY2FwZShrZXkpIHtcbiAgICByZXR1cm4gKGtleSArPSBcIlwiKVswXSA9PT0gZDNfbWFwX3plcm8gPyBrZXkuc2xpY2UoMSkgOiBrZXk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfbWFwX2hhcyhrZXkpIHtcbiAgICByZXR1cm4gZDNfbWFwX2VzY2FwZShrZXkpIGluIHRoaXMuXztcbiAgfVxuICBmdW5jdGlvbiBkM19tYXBfcmVtb3ZlKGtleSkge1xuICAgIHJldHVybiAoa2V5ID0gZDNfbWFwX2VzY2FwZShrZXkpKSBpbiB0aGlzLl8gJiYgZGVsZXRlIHRoaXMuX1trZXldO1xuICB9XG4gIGZ1bmN0aW9uIGQzX21hcF9rZXlzKCkge1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIHRoaXMuXykga2V5cy5wdXNoKGQzX21hcF91bmVzY2FwZShrZXkpKTtcbiAgICByZXR1cm4ga2V5cztcbiAgfVxuICBmdW5jdGlvbiBkM19tYXBfc2l6ZSgpIHtcbiAgICB2YXIgc2l6ZSA9IDA7XG4gICAgZm9yICh2YXIga2V5IGluIHRoaXMuXykgKytzaXplO1xuICAgIHJldHVybiBzaXplO1xuICB9XG4gIGZ1bmN0aW9uIGQzX21hcF9lbXB0eSgpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5fKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZDMubmVzdCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBuZXN0ID0ge30sIGtleXMgPSBbXSwgc29ydEtleXMgPSBbXSwgc29ydFZhbHVlcywgcm9sbHVwO1xuICAgIGZ1bmN0aW9uIG1hcChtYXBUeXBlLCBhcnJheSwgZGVwdGgpIHtcbiAgICAgIGlmIChkZXB0aCA+PSBrZXlzLmxlbmd0aCkgcmV0dXJuIHJvbGx1cCA/IHJvbGx1cC5jYWxsKG5lc3QsIGFycmF5KSA6IHNvcnRWYWx1ZXMgPyBhcnJheS5zb3J0KHNvcnRWYWx1ZXMpIDogYXJyYXk7XG4gICAgICB2YXIgaSA9IC0xLCBuID0gYXJyYXkubGVuZ3RoLCBrZXkgPSBrZXlzW2RlcHRoKytdLCBrZXlWYWx1ZSwgb2JqZWN0LCBzZXR0ZXIsIHZhbHVlc0J5S2V5ID0gbmV3IGQzX01hcCgpLCB2YWx1ZXM7XG4gICAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICBpZiAodmFsdWVzID0gdmFsdWVzQnlLZXkuZ2V0KGtleVZhbHVlID0ga2V5KG9iamVjdCA9IGFycmF5W2ldKSkpIHtcbiAgICAgICAgICB2YWx1ZXMucHVzaChvYmplY3QpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlc0J5S2V5LnNldChrZXlWYWx1ZSwgWyBvYmplY3QgXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChtYXBUeXBlKSB7XG4gICAgICAgIG9iamVjdCA9IG1hcFR5cGUoKTtcbiAgICAgICAgc2V0dGVyID0gZnVuY3Rpb24oa2V5VmFsdWUsIHZhbHVlcykge1xuICAgICAgICAgIG9iamVjdC5zZXQoa2V5VmFsdWUsIG1hcChtYXBUeXBlLCB2YWx1ZXMsIGRlcHRoKSk7XG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvYmplY3QgPSB7fTtcbiAgICAgICAgc2V0dGVyID0gZnVuY3Rpb24oa2V5VmFsdWUsIHZhbHVlcykge1xuICAgICAgICAgIG9iamVjdFtrZXlWYWx1ZV0gPSBtYXAobWFwVHlwZSwgdmFsdWVzLCBkZXB0aCk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICB2YWx1ZXNCeUtleS5mb3JFYWNoKHNldHRlcik7XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBlbnRyaWVzKG1hcCwgZGVwdGgpIHtcbiAgICAgIGlmIChkZXB0aCA+PSBrZXlzLmxlbmd0aCkgcmV0dXJuIG1hcDtcbiAgICAgIHZhciBhcnJheSA9IFtdLCBzb3J0S2V5ID0gc29ydEtleXNbZGVwdGgrK107XG4gICAgICBtYXAuZm9yRWFjaChmdW5jdGlvbihrZXksIGtleU1hcCkge1xuICAgICAgICBhcnJheS5wdXNoKHtcbiAgICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgICB2YWx1ZXM6IGVudHJpZXMoa2V5TWFwLCBkZXB0aClcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBzb3J0S2V5ID8gYXJyYXkuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgIHJldHVybiBzb3J0S2V5KGEua2V5LCBiLmtleSk7XG4gICAgICB9KSA6IGFycmF5O1xuICAgIH1cbiAgICBuZXN0Lm1hcCA9IGZ1bmN0aW9uKGFycmF5LCBtYXBUeXBlKSB7XG4gICAgICByZXR1cm4gbWFwKG1hcFR5cGUsIGFycmF5LCAwKTtcbiAgICB9O1xuICAgIG5lc3QuZW50cmllcyA9IGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgICByZXR1cm4gZW50cmllcyhtYXAoZDMubWFwLCBhcnJheSwgMCksIDApO1xuICAgIH07XG4gICAgbmVzdC5rZXkgPSBmdW5jdGlvbihkKSB7XG4gICAgICBrZXlzLnB1c2goZCk7XG4gICAgICByZXR1cm4gbmVzdDtcbiAgICB9O1xuICAgIG5lc3Quc29ydEtleXMgPSBmdW5jdGlvbihvcmRlcikge1xuICAgICAgc29ydEtleXNba2V5cy5sZW5ndGggLSAxXSA9IG9yZGVyO1xuICAgICAgcmV0dXJuIG5lc3Q7XG4gICAgfTtcbiAgICBuZXN0LnNvcnRWYWx1ZXMgPSBmdW5jdGlvbihvcmRlcikge1xuICAgICAgc29ydFZhbHVlcyA9IG9yZGVyO1xuICAgICAgcmV0dXJuIG5lc3Q7XG4gICAgfTtcbiAgICBuZXN0LnJvbGx1cCA9IGZ1bmN0aW9uKGYpIHtcbiAgICAgIHJvbGx1cCA9IGY7XG4gICAgICByZXR1cm4gbmVzdDtcbiAgICB9O1xuICAgIHJldHVybiBuZXN0O1xuICB9O1xuICBkMy5zZXQgPSBmdW5jdGlvbihhcnJheSkge1xuICAgIHZhciBzZXQgPSBuZXcgZDNfU2V0KCk7XG4gICAgaWYgKGFycmF5KSBmb3IgKHZhciBpID0gMCwgbiA9IGFycmF5Lmxlbmd0aDsgaSA8IG47ICsraSkgc2V0LmFkZChhcnJheVtpXSk7XG4gICAgcmV0dXJuIHNldDtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfU2V0KCkge1xuICAgIHRoaXMuXyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIH1cbiAgZDNfY2xhc3MoZDNfU2V0LCB7XG4gICAgaGFzOiBkM19tYXBfaGFzLFxuICAgIGFkZDogZnVuY3Rpb24oa2V5KSB7XG4gICAgICB0aGlzLl9bZDNfbWFwX2VzY2FwZShrZXkgKz0gXCJcIildID0gdHJ1ZTtcbiAgICAgIHJldHVybiBrZXk7XG4gICAgfSxcbiAgICByZW1vdmU6IGQzX21hcF9yZW1vdmUsXG4gICAgdmFsdWVzOiBkM19tYXBfa2V5cyxcbiAgICBzaXplOiBkM19tYXBfc2l6ZSxcbiAgICBlbXB0eTogZDNfbWFwX2VtcHR5LFxuICAgIGZvckVhY2g6IGZ1bmN0aW9uKGYpIHtcbiAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzLl8pIGYuY2FsbCh0aGlzLCBkM19tYXBfdW5lc2NhcGUoa2V5KSk7XG4gICAgfVxuICB9KTtcbiAgZDMuYmVoYXZpb3IgPSB7fTtcbiAgZnVuY3Rpb24gZDNfaWRlbnRpdHkoZCkge1xuICAgIHJldHVybiBkO1xuICB9XG4gIGQzLnJlYmluZCA9IGZ1bmN0aW9uKHRhcmdldCwgc291cmNlKSB7XG4gICAgdmFyIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aCwgbWV0aG9kO1xuICAgIHdoaWxlICgrK2kgPCBuKSB0YXJnZXRbbWV0aG9kID0gYXJndW1lbnRzW2ldXSA9IGQzX3JlYmluZCh0YXJnZXQsIHNvdXJjZSwgc291cmNlW21ldGhvZF0pO1xuICAgIHJldHVybiB0YXJnZXQ7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX3JlYmluZCh0YXJnZXQsIHNvdXJjZSwgbWV0aG9kKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHZhbHVlID0gbWV0aG9kLmFwcGx5KHNvdXJjZSwgYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gc291cmNlID8gdGFyZ2V0IDogdmFsdWU7XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBkM192ZW5kb3JTeW1ib2wob2JqZWN0LCBuYW1lKSB7XG4gICAgaWYgKG5hbWUgaW4gb2JqZWN0KSByZXR1cm4gbmFtZTtcbiAgICBuYW1lID0gbmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIG5hbWUuc2xpY2UoMSk7XG4gICAgZm9yICh2YXIgaSA9IDAsIG4gPSBkM192ZW5kb3JQcmVmaXhlcy5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgIHZhciBwcmVmaXhOYW1lID0gZDNfdmVuZG9yUHJlZml4ZXNbaV0gKyBuYW1lO1xuICAgICAgaWYgKHByZWZpeE5hbWUgaW4gb2JqZWN0KSByZXR1cm4gcHJlZml4TmFtZTtcbiAgICB9XG4gIH1cbiAgdmFyIGQzX3ZlbmRvclByZWZpeGVzID0gWyBcIndlYmtpdFwiLCBcIm1zXCIsIFwibW96XCIsIFwiTW96XCIsIFwib1wiLCBcIk9cIiBdO1xuICBmdW5jdGlvbiBkM19ub29wKCkge31cbiAgZDMuZGlzcGF0Y2ggPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZGlzcGF0Y2ggPSBuZXcgZDNfZGlzcGF0Y2goKSwgaSA9IC0xLCBuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB3aGlsZSAoKytpIDwgbikgZGlzcGF0Y2hbYXJndW1lbnRzW2ldXSA9IGQzX2Rpc3BhdGNoX2V2ZW50KGRpc3BhdGNoKTtcbiAgICByZXR1cm4gZGlzcGF0Y2g7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX2Rpc3BhdGNoKCkge31cbiAgZDNfZGlzcGF0Y2gucHJvdG90eXBlLm9uID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgICB2YXIgaSA9IHR5cGUuaW5kZXhPZihcIi5cIiksIG5hbWUgPSBcIlwiO1xuICAgIGlmIChpID49IDApIHtcbiAgICAgIG5hbWUgPSB0eXBlLnNsaWNlKGkgKyAxKTtcbiAgICAgIHR5cGUgPSB0eXBlLnNsaWNlKDAsIGkpO1xuICAgIH1cbiAgICBpZiAodHlwZSkgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPCAyID8gdGhpc1t0eXBlXS5vbihuYW1lKSA6IHRoaXNbdHlwZV0ub24obmFtZSwgbGlzdGVuZXIpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICBpZiAobGlzdGVuZXIgPT0gbnVsbCkgZm9yICh0eXBlIGluIHRoaXMpIHtcbiAgICAgICAgaWYgKHRoaXMuaGFzT3duUHJvcGVydHkodHlwZSkpIHRoaXNbdHlwZV0ub24obmFtZSwgbnVsbCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH07XG4gIGZ1bmN0aW9uIGQzX2Rpc3BhdGNoX2V2ZW50KGRpc3BhdGNoKSB7XG4gICAgdmFyIGxpc3RlbmVycyA9IFtdLCBsaXN0ZW5lckJ5TmFtZSA9IG5ldyBkM19NYXAoKTtcbiAgICBmdW5jdGlvbiBldmVudCgpIHtcbiAgICAgIHZhciB6ID0gbGlzdGVuZXJzLCBpID0gLTEsIG4gPSB6Lmxlbmd0aCwgbDtcbiAgICAgIHdoaWxlICgrK2kgPCBuKSBpZiAobCA9IHpbaV0ub24pIGwuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiBkaXNwYXRjaDtcbiAgICB9XG4gICAgZXZlbnQub24gPSBmdW5jdGlvbihuYW1lLCBsaXN0ZW5lcikge1xuICAgICAgdmFyIGwgPSBsaXN0ZW5lckJ5TmFtZS5nZXQobmFtZSksIGk7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHJldHVybiBsICYmIGwub247XG4gICAgICBpZiAobCkge1xuICAgICAgICBsLm9uID0gbnVsbDtcbiAgICAgICAgbGlzdGVuZXJzID0gbGlzdGVuZXJzLnNsaWNlKDAsIGkgPSBsaXN0ZW5lcnMuaW5kZXhPZihsKSkuY29uY2F0KGxpc3RlbmVycy5zbGljZShpICsgMSkpO1xuICAgICAgICBsaXN0ZW5lckJ5TmFtZS5yZW1vdmUobmFtZSk7XG4gICAgICB9XG4gICAgICBpZiAobGlzdGVuZXIpIGxpc3RlbmVycy5wdXNoKGxpc3RlbmVyQnlOYW1lLnNldChuYW1lLCB7XG4gICAgICAgIG9uOiBsaXN0ZW5lclxuICAgICAgfSkpO1xuICAgICAgcmV0dXJuIGRpc3BhdGNoO1xuICAgIH07XG4gICAgcmV0dXJuIGV2ZW50O1xuICB9XG4gIGQzLmV2ZW50ID0gbnVsbDtcbiAgZnVuY3Rpb24gZDNfZXZlbnRQcmV2ZW50RGVmYXVsdCgpIHtcbiAgICBkMy5ldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2V2ZW50U291cmNlKCkge1xuICAgIHZhciBlID0gZDMuZXZlbnQsIHM7XG4gICAgd2hpbGUgKHMgPSBlLnNvdXJjZUV2ZW50KSBlID0gcztcbiAgICByZXR1cm4gZTtcbiAgfVxuICBmdW5jdGlvbiBkM19ldmVudERpc3BhdGNoKHRhcmdldCkge1xuICAgIHZhciBkaXNwYXRjaCA9IG5ldyBkM19kaXNwYXRjaCgpLCBpID0gMCwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgd2hpbGUgKCsraSA8IG4pIGRpc3BhdGNoW2FyZ3VtZW50c1tpXV0gPSBkM19kaXNwYXRjaF9ldmVudChkaXNwYXRjaCk7XG4gICAgZGlzcGF0Y2gub2YgPSBmdW5jdGlvbih0aGl6LCBhcmd1bWVudHopIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihlMSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciBlMCA9IGUxLnNvdXJjZUV2ZW50ID0gZDMuZXZlbnQ7XG4gICAgICAgICAgZTEudGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgICAgIGQzLmV2ZW50ID0gZTE7XG4gICAgICAgICAgZGlzcGF0Y2hbZTEudHlwZV0uYXBwbHkodGhpeiwgYXJndW1lbnR6KTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBkMy5ldmVudCA9IGUwO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIGRpc3BhdGNoO1xuICB9XG4gIGQzLnJlcXVvdGUgPSBmdW5jdGlvbihzKSB7XG4gICAgcmV0dXJuIHMucmVwbGFjZShkM19yZXF1b3RlX3JlLCBcIlxcXFwkJlwiKTtcbiAgfTtcbiAgdmFyIGQzX3JlcXVvdGVfcmUgPSAvW1xcXFxcXF5cXCRcXCpcXCtcXD9cXHxcXFtcXF1cXChcXClcXC5cXHtcXH1dL2c7XG4gIHZhciBkM19zdWJjbGFzcyA9IHt9Ll9fcHJvdG9fXyA/IGZ1bmN0aW9uKG9iamVjdCwgcHJvdG90eXBlKSB7XG4gICAgb2JqZWN0Ll9fcHJvdG9fXyA9IHByb3RvdHlwZTtcbiAgfSA6IGZ1bmN0aW9uKG9iamVjdCwgcHJvdG90eXBlKSB7XG4gICAgZm9yICh2YXIgcHJvcGVydHkgaW4gcHJvdG90eXBlKSBvYmplY3RbcHJvcGVydHldID0gcHJvdG90eXBlW3Byb3BlcnR5XTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfc2VsZWN0aW9uKGdyb3Vwcykge1xuICAgIGQzX3N1YmNsYXNzKGdyb3VwcywgZDNfc2VsZWN0aW9uUHJvdG90eXBlKTtcbiAgICByZXR1cm4gZ3JvdXBzO1xuICB9XG4gIHZhciBkM19zZWxlY3QgPSBmdW5jdGlvbihzLCBuKSB7XG4gICAgcmV0dXJuIG4ucXVlcnlTZWxlY3RvcihzKTtcbiAgfSwgZDNfc2VsZWN0QWxsID0gZnVuY3Rpb24ocywgbikge1xuICAgIHJldHVybiBuLnF1ZXJ5U2VsZWN0b3JBbGwocyk7XG4gIH0sIGQzX3NlbGVjdE1hdGNoZXMgPSBmdW5jdGlvbihuLCBzKSB7XG4gICAgdmFyIGQzX3NlbGVjdE1hdGNoZXIgPSBuLm1hdGNoZXMgfHwgbltkM192ZW5kb3JTeW1ib2wobiwgXCJtYXRjaGVzU2VsZWN0b3JcIildO1xuICAgIGQzX3NlbGVjdE1hdGNoZXMgPSBmdW5jdGlvbihuLCBzKSB7XG4gICAgICByZXR1cm4gZDNfc2VsZWN0TWF0Y2hlci5jYWxsKG4sIHMpO1xuICAgIH07XG4gICAgcmV0dXJuIGQzX3NlbGVjdE1hdGNoZXMobiwgcyk7XG4gIH07XG4gIGlmICh0eXBlb2YgU2l6emxlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBkM19zZWxlY3QgPSBmdW5jdGlvbihzLCBuKSB7XG4gICAgICByZXR1cm4gU2l6emxlKHMsIG4pWzBdIHx8IG51bGw7XG4gICAgfTtcbiAgICBkM19zZWxlY3RBbGwgPSBTaXp6bGU7XG4gICAgZDNfc2VsZWN0TWF0Y2hlcyA9IFNpenpsZS5tYXRjaGVzU2VsZWN0b3I7XG4gIH1cbiAgZDMuc2VsZWN0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGQzLnNlbGVjdChkM19kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpO1xuICB9O1xuICB2YXIgZDNfc2VsZWN0aW9uUHJvdG90eXBlID0gZDMuc2VsZWN0aW9uLnByb3RvdHlwZSA9IFtdO1xuICBkM19zZWxlY3Rpb25Qcm90b3R5cGUuc2VsZWN0ID0gZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAgICB2YXIgc3ViZ3JvdXBzID0gW10sIHN1Ymdyb3VwLCBzdWJub2RlLCBncm91cCwgbm9kZTtcbiAgICBzZWxlY3RvciA9IGQzX3NlbGVjdGlvbl9zZWxlY3RvcihzZWxlY3Rvcik7XG4gICAgZm9yICh2YXIgaiA9IC0xLCBtID0gdGhpcy5sZW5ndGg7ICsraiA8IG07ICkge1xuICAgICAgc3ViZ3JvdXBzLnB1c2goc3ViZ3JvdXAgPSBbXSk7XG4gICAgICBzdWJncm91cC5wYXJlbnROb2RlID0gKGdyb3VwID0gdGhpc1tqXSkucGFyZW50Tm9kZTtcbiAgICAgIGZvciAodmFyIGkgPSAtMSwgbiA9IGdyb3VwLmxlbmd0aDsgKytpIDwgbjsgKSB7XG4gICAgICAgIGlmIChub2RlID0gZ3JvdXBbaV0pIHtcbiAgICAgICAgICBzdWJncm91cC5wdXNoKHN1Ym5vZGUgPSBzZWxlY3Rvci5jYWxsKG5vZGUsIG5vZGUuX19kYXRhX18sIGksIGopKTtcbiAgICAgICAgICBpZiAoc3Vibm9kZSAmJiBcIl9fZGF0YV9fXCIgaW4gbm9kZSkgc3Vibm9kZS5fX2RhdGFfXyA9IG5vZGUuX19kYXRhX187XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3ViZ3JvdXAucHVzaChudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZDNfc2VsZWN0aW9uKHN1Ymdyb3Vwcyk7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX3NlbGVjdGlvbl9zZWxlY3RvcihzZWxlY3Rvcikge1xuICAgIHJldHVybiB0eXBlb2Ygc2VsZWN0b3IgPT09IFwiZnVuY3Rpb25cIiA/IHNlbGVjdG9yIDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZDNfc2VsZWN0KHNlbGVjdG9yLCB0aGlzKTtcbiAgICB9O1xuICB9XG4gIGQzX3NlbGVjdGlvblByb3RvdHlwZS5zZWxlY3RBbGwgPSBmdW5jdGlvbihzZWxlY3Rvcikge1xuICAgIHZhciBzdWJncm91cHMgPSBbXSwgc3ViZ3JvdXAsIG5vZGU7XG4gICAgc2VsZWN0b3IgPSBkM19zZWxlY3Rpb25fc2VsZWN0b3JBbGwoc2VsZWN0b3IpO1xuICAgIGZvciAodmFyIGogPSAtMSwgbSA9IHRoaXMubGVuZ3RoOyArK2ogPCBtOyApIHtcbiAgICAgIGZvciAodmFyIGdyb3VwID0gdGhpc1tqXSwgaSA9IC0xLCBuID0gZ3JvdXAubGVuZ3RoOyArK2kgPCBuOyApIHtcbiAgICAgICAgaWYgKG5vZGUgPSBncm91cFtpXSkge1xuICAgICAgICAgIHN1Ymdyb3Vwcy5wdXNoKHN1Ymdyb3VwID0gZDNfYXJyYXkoc2VsZWN0b3IuY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBpLCBqKSkpO1xuICAgICAgICAgIHN1Ymdyb3VwLnBhcmVudE5vZGUgPSBub2RlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkM19zZWxlY3Rpb24oc3ViZ3JvdXBzKTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfc2VsZWN0aW9uX3NlbGVjdG9yQWxsKHNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJmdW5jdGlvblwiID8gc2VsZWN0b3IgOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBkM19zZWxlY3RBbGwoc2VsZWN0b3IsIHRoaXMpO1xuICAgIH07XG4gIH1cbiAgdmFyIGQzX25zWGh0bWwgPSBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIjtcbiAgdmFyIGQzX25zUHJlZml4ID0ge1xuICAgIHN2ZzogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLFxuICAgIHhodG1sOiBkM19uc1hodG1sLFxuICAgIHhsaW5rOiBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIixcbiAgICB4bWw6IFwiaHR0cDovL3d3dy53My5vcmcvWE1MLzE5OTgvbmFtZXNwYWNlXCIsXG4gICAgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC94bWxucy9cIlxuICB9O1xuICBkMy5ucyA9IHtcbiAgICBwcmVmaXg6IGQzX25zUHJlZml4LFxuICAgIHF1YWxpZnk6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIHZhciBpID0gbmFtZS5pbmRleE9mKFwiOlwiKSwgcHJlZml4ID0gbmFtZTtcbiAgICAgIGlmIChpID49IDAgJiYgKHByZWZpeCA9IG5hbWUuc2xpY2UoMCwgaSkpICE9PSBcInhtbG5zXCIpIG5hbWUgPSBuYW1lLnNsaWNlKGkgKyAxKTtcbiAgICAgIHJldHVybiBkM19uc1ByZWZpeC5oYXNPd25Qcm9wZXJ0eShwcmVmaXgpID8ge1xuICAgICAgICBzcGFjZTogZDNfbnNQcmVmaXhbcHJlZml4XSxcbiAgICAgICAgbG9jYWw6IG5hbWVcbiAgICAgIH0gOiBuYW1lO1xuICAgIH1cbiAgfTtcbiAgZDNfc2VsZWN0aW9uUHJvdG90eXBlLmF0dHIgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgICAgaWYgKHR5cGVvZiBuYW1lID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHZhciBub2RlID0gdGhpcy5ub2RlKCk7XG4gICAgICAgIG5hbWUgPSBkMy5ucy5xdWFsaWZ5KG5hbWUpO1xuICAgICAgICByZXR1cm4gbmFtZS5sb2NhbCA/IG5vZGUuZ2V0QXR0cmlidXRlTlMobmFtZS5zcGFjZSwgbmFtZS5sb2NhbCkgOiBub2RlLmdldEF0dHJpYnV0ZShuYW1lKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFsdWUgaW4gbmFtZSkgdGhpcy5lYWNoKGQzX3NlbGVjdGlvbl9hdHRyKHZhbHVlLCBuYW1lW3ZhbHVlXSkpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmVhY2goZDNfc2VsZWN0aW9uX2F0dHIobmFtZSwgdmFsdWUpKTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfc2VsZWN0aW9uX2F0dHIobmFtZSwgdmFsdWUpIHtcbiAgICBuYW1lID0gZDMubnMucXVhbGlmeShuYW1lKTtcbiAgICBmdW5jdGlvbiBhdHRyTnVsbCgpIHtcbiAgICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhdHRyTnVsbE5TKCkge1xuICAgICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGVOUyhuYW1lLnNwYWNlLCBuYW1lLmxvY2FsKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYXR0ckNvbnN0YW50KCkge1xuICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhdHRyQ29uc3RhbnROUygpIHtcbiAgICAgIHRoaXMuc2V0QXR0cmlidXRlTlMobmFtZS5zcGFjZSwgbmFtZS5sb2NhbCwgdmFsdWUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhdHRyRnVuY3Rpb24oKSB7XG4gICAgICB2YXIgeCA9IHZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICBpZiAoeCA9PSBudWxsKSB0aGlzLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTsgZWxzZSB0aGlzLnNldEF0dHJpYnV0ZShuYW1lLCB4KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYXR0ckZ1bmN0aW9uTlMoKSB7XG4gICAgICB2YXIgeCA9IHZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICBpZiAoeCA9PSBudWxsKSB0aGlzLnJlbW92ZUF0dHJpYnV0ZU5TKG5hbWUuc3BhY2UsIG5hbWUubG9jYWwpOyBlbHNlIHRoaXMuc2V0QXR0cmlidXRlTlMobmFtZS5zcGFjZSwgbmFtZS5sb2NhbCwgeCk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZSA9PSBudWxsID8gbmFtZS5sb2NhbCA/IGF0dHJOdWxsTlMgOiBhdHRyTnVsbCA6IHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiID8gbmFtZS5sb2NhbCA/IGF0dHJGdW5jdGlvbk5TIDogYXR0ckZ1bmN0aW9uIDogbmFtZS5sb2NhbCA/IGF0dHJDb25zdGFudE5TIDogYXR0ckNvbnN0YW50O1xuICB9XG4gIGZ1bmN0aW9uIGQzX2NvbGxhcHNlKHMpIHtcbiAgICByZXR1cm4gcy50cmltKCkucmVwbGFjZSgvXFxzKy9nLCBcIiBcIik7XG4gIH1cbiAgZDNfc2VsZWN0aW9uUHJvdG90eXBlLmNsYXNzZWQgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgICAgaWYgKHR5cGVvZiBuYW1lID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHZhciBub2RlID0gdGhpcy5ub2RlKCksIG4gPSAobmFtZSA9IGQzX3NlbGVjdGlvbl9jbGFzc2VzKG5hbWUpKS5sZW5ndGgsIGkgPSAtMTtcbiAgICAgICAgaWYgKHZhbHVlID0gbm9kZS5jbGFzc0xpc3QpIHtcbiAgICAgICAgICB3aGlsZSAoKytpIDwgbikgaWYgKCF2YWx1ZS5jb250YWlucyhuYW1lW2ldKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0gbm9kZS5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKTtcbiAgICAgICAgICB3aGlsZSAoKytpIDwgbikgaWYgKCFkM19zZWxlY3Rpb25fY2xhc3NlZFJlKG5hbWVbaV0pLnRlc3QodmFsdWUpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBmb3IgKHZhbHVlIGluIG5hbWUpIHRoaXMuZWFjaChkM19zZWxlY3Rpb25fY2xhc3NlZCh2YWx1ZSwgbmFtZVt2YWx1ZV0pKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5lYWNoKGQzX3NlbGVjdGlvbl9jbGFzc2VkKG5hbWUsIHZhbHVlKSk7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX3NlbGVjdGlvbl9jbGFzc2VkUmUobmFtZSkge1xuICAgIHJldHVybiBuZXcgUmVnRXhwKFwiKD86XnxcXFxccyspXCIgKyBkMy5yZXF1b3RlKG5hbWUpICsgXCIoPzpcXFxccyt8JClcIiwgXCJnXCIpO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3NlbGVjdGlvbl9jbGFzc2VzKG5hbWUpIHtcbiAgICByZXR1cm4gKG5hbWUgKyBcIlwiKS50cmltKCkuc3BsaXQoL158XFxzKy8pO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3NlbGVjdGlvbl9jbGFzc2VkKG5hbWUsIHZhbHVlKSB7XG4gICAgbmFtZSA9IGQzX3NlbGVjdGlvbl9jbGFzc2VzKG5hbWUpLm1hcChkM19zZWxlY3Rpb25fY2xhc3NlZE5hbWUpO1xuICAgIHZhciBuID0gbmFtZS5sZW5ndGg7XG4gICAgZnVuY3Rpb24gY2xhc3NlZENvbnN0YW50KCkge1xuICAgICAgdmFyIGkgPSAtMTtcbiAgICAgIHdoaWxlICgrK2kgPCBuKSBuYW1lW2ldKHRoaXMsIHZhbHVlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2xhc3NlZEZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGkgPSAtMSwgeCA9IHZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB3aGlsZSAoKytpIDwgbikgbmFtZVtpXSh0aGlzLCB4KTtcbiAgICB9XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiID8gY2xhc3NlZEZ1bmN0aW9uIDogY2xhc3NlZENvbnN0YW50O1xuICB9XG4gIGZ1bmN0aW9uIGQzX3NlbGVjdGlvbl9jbGFzc2VkTmFtZShuYW1lKSB7XG4gICAgdmFyIHJlID0gZDNfc2VsZWN0aW9uX2NsYXNzZWRSZShuYW1lKTtcbiAgICByZXR1cm4gZnVuY3Rpb24obm9kZSwgdmFsdWUpIHtcbiAgICAgIGlmIChjID0gbm9kZS5jbGFzc0xpc3QpIHJldHVybiB2YWx1ZSA/IGMuYWRkKG5hbWUpIDogYy5yZW1vdmUobmFtZSk7XG4gICAgICB2YXIgYyA9IG5vZGUuZ2V0QXR0cmlidXRlKFwiY2xhc3NcIikgfHwgXCJcIjtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICByZS5sYXN0SW5kZXggPSAwO1xuICAgICAgICBpZiAoIXJlLnRlc3QoYykpIG5vZGUuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgZDNfY29sbGFwc2UoYyArIFwiIFwiICsgbmFtZSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBkM19jb2xsYXBzZShjLnJlcGxhY2UocmUsIFwiIFwiKSkpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgZDNfc2VsZWN0aW9uUHJvdG90eXBlLnN0eWxlID0gZnVuY3Rpb24obmFtZSwgdmFsdWUsIHByaW9yaXR5KSB7XG4gICAgdmFyIG4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGlmIChuIDwgMykge1xuICAgICAgaWYgKHR5cGVvZiBuYW1lICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGlmIChuIDwgMikgdmFsdWUgPSBcIlwiO1xuICAgICAgICBmb3IgKHByaW9yaXR5IGluIG5hbWUpIHRoaXMuZWFjaChkM19zZWxlY3Rpb25fc3R5bGUocHJpb3JpdHksIG5hbWVbcHJpb3JpdHldLCB2YWx1ZSkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIGlmIChuIDwgMikge1xuICAgICAgICB2YXIgbm9kZSA9IHRoaXMubm9kZSgpO1xuICAgICAgICByZXR1cm4gZDNfd2luZG93KG5vZGUpLmdldENvbXB1dGVkU3R5bGUobm9kZSwgbnVsbCkuZ2V0UHJvcGVydHlWYWx1ZShuYW1lKTtcbiAgICAgIH1cbiAgICAgIHByaW9yaXR5ID0gXCJcIjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZWFjaChkM19zZWxlY3Rpb25fc3R5bGUobmFtZSwgdmFsdWUsIHByaW9yaXR5KSk7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX3NlbGVjdGlvbl9zdHlsZShuYW1lLCB2YWx1ZSwgcHJpb3JpdHkpIHtcbiAgICBmdW5jdGlvbiBzdHlsZU51bGwoKSB7XG4gICAgICB0aGlzLnN0eWxlLnJlbW92ZVByb3BlcnR5KG5hbWUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzdHlsZUNvbnN0YW50KCkge1xuICAgICAgdGhpcy5zdHlsZS5zZXRQcm9wZXJ0eShuYW1lLCB2YWx1ZSwgcHJpb3JpdHkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzdHlsZUZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHggPSB2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgaWYgKHggPT0gbnVsbCkgdGhpcy5zdHlsZS5yZW1vdmVQcm9wZXJ0eShuYW1lKTsgZWxzZSB0aGlzLnN0eWxlLnNldFByb3BlcnR5KG5hbWUsIHgsIHByaW9yaXR5KTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlID09IG51bGwgPyBzdHlsZU51bGwgOiB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIiA/IHN0eWxlRnVuY3Rpb24gOiBzdHlsZUNvbnN0YW50O1xuICB9XG4gIGQzX3NlbGVjdGlvblByb3RvdHlwZS5wcm9wZXJ0eSA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgICBpZiAodHlwZW9mIG5hbWUgPT09IFwic3RyaW5nXCIpIHJldHVybiB0aGlzLm5vZGUoKVtuYW1lXTtcbiAgICAgIGZvciAodmFsdWUgaW4gbmFtZSkgdGhpcy5lYWNoKGQzX3NlbGVjdGlvbl9wcm9wZXJ0eSh2YWx1ZSwgbmFtZVt2YWx1ZV0pKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5lYWNoKGQzX3NlbGVjdGlvbl9wcm9wZXJ0eShuYW1lLCB2YWx1ZSkpO1xuICB9O1xuICBmdW5jdGlvbiBkM19zZWxlY3Rpb25fcHJvcGVydHkobmFtZSwgdmFsdWUpIHtcbiAgICBmdW5jdGlvbiBwcm9wZXJ0eU51bGwoKSB7XG4gICAgICBkZWxldGUgdGhpc1tuYW1lXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHJvcGVydHlDb25zdGFudCgpIHtcbiAgICAgIHRoaXNbbmFtZV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHJvcGVydHlGdW5jdGlvbigpIHtcbiAgICAgIHZhciB4ID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIGlmICh4ID09IG51bGwpIGRlbGV0ZSB0aGlzW25hbWVdOyBlbHNlIHRoaXNbbmFtZV0gPSB4O1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/IHByb3BlcnR5TnVsbCA6IHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiID8gcHJvcGVydHlGdW5jdGlvbiA6IHByb3BlcnR5Q29uc3RhbnQ7XG4gIH1cbiAgZDNfc2VsZWN0aW9uUHJvdG90eXBlLnRleHQgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gdGhpcy5lYWNoKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiID8gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdiA9IHZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB0aGlzLnRleHRDb250ZW50ID0gdiA9PSBudWxsID8gXCJcIiA6IHY7XG4gICAgfSA6IHZhbHVlID09IG51bGwgPyBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMudGV4dENvbnRlbnQgPSBcIlwiO1xuICAgIH0gOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMudGV4dENvbnRlbnQgPSB2YWx1ZTtcbiAgICB9KSA6IHRoaXMubm9kZSgpLnRleHRDb250ZW50O1xuICB9O1xuICBkM19zZWxlY3Rpb25Qcm90b3R5cGUuaHRtbCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyB0aGlzLmVhY2godHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIgPyBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB2ID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHRoaXMuaW5uZXJIVE1MID0gdiA9PSBudWxsID8gXCJcIiA6IHY7XG4gICAgfSA6IHZhbHVlID09IG51bGwgPyBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuaW5uZXJIVE1MID0gXCJcIjtcbiAgICB9IDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmlubmVySFRNTCA9IHZhbHVlO1xuICAgIH0pIDogdGhpcy5ub2RlKCkuaW5uZXJIVE1MO1xuICB9O1xuICBkM19zZWxlY3Rpb25Qcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24obmFtZSkge1xuICAgIG5hbWUgPSBkM19zZWxlY3Rpb25fY3JlYXRvcihuYW1lKTtcbiAgICByZXR1cm4gdGhpcy5zZWxlY3QoZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5hcHBlbmRDaGlsZChuYW1lLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICAgIH0pO1xuICB9O1xuICBmdW5jdGlvbiBkM19zZWxlY3Rpb25fY3JlYXRvcihuYW1lKSB7XG4gICAgZnVuY3Rpb24gY3JlYXRlKCkge1xuICAgICAgdmFyIGRvY3VtZW50ID0gdGhpcy5vd25lckRvY3VtZW50LCBuYW1lc3BhY2UgPSB0aGlzLm5hbWVzcGFjZVVSSTtcbiAgICAgIHJldHVybiBuYW1lc3BhY2UgPT09IGQzX25zWGh0bWwgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50Lm5hbWVzcGFjZVVSSSA9PT0gZDNfbnNYaHRtbCA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQobmFtZSkgOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobmFtZXNwYWNlLCBuYW1lKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlTlMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhuYW1lLnNwYWNlLCBuYW1lLmxvY2FsKTtcbiAgICB9XG4gICAgcmV0dXJuIHR5cGVvZiBuYW1lID09PSBcImZ1bmN0aW9uXCIgPyBuYW1lIDogKG5hbWUgPSBkMy5ucy5xdWFsaWZ5KG5hbWUpKS5sb2NhbCA/IGNyZWF0ZU5TIDogY3JlYXRlO1xuICB9XG4gIGQzX3NlbGVjdGlvblByb3RvdHlwZS5pbnNlcnQgPSBmdW5jdGlvbihuYW1lLCBiZWZvcmUpIHtcbiAgICBuYW1lID0gZDNfc2VsZWN0aW9uX2NyZWF0b3IobmFtZSk7XG4gICAgYmVmb3JlID0gZDNfc2VsZWN0aW9uX3NlbGVjdG9yKGJlZm9yZSk7XG4gICAgcmV0dXJuIHRoaXMuc2VsZWN0KGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuaW5zZXJ0QmVmb3JlKG5hbWUuYXBwbHkodGhpcywgYXJndW1lbnRzKSwgYmVmb3JlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgbnVsbCk7XG4gICAgfSk7XG4gIH07XG4gIGQzX3NlbGVjdGlvblByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGQzX3NlbGVjdGlvblJlbW92ZSk7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX3NlbGVjdGlvblJlbW92ZSgpIHtcbiAgICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnROb2RlO1xuICAgIGlmIChwYXJlbnQpIHBhcmVudC5yZW1vdmVDaGlsZCh0aGlzKTtcbiAgfVxuICBkM19zZWxlY3Rpb25Qcm90b3R5cGUuZGF0YSA9IGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICB2YXIgaSA9IC0xLCBuID0gdGhpcy5sZW5ndGgsIGdyb3VwLCBub2RlO1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgdmFsdWUgPSBuZXcgQXJyYXkobiA9IChncm91cCA9IHRoaXNbMF0pLmxlbmd0aCk7XG4gICAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSB7XG4gICAgICAgICAgdmFsdWVbaV0gPSBub2RlLl9fZGF0YV9fO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGJpbmQoZ3JvdXAsIGdyb3VwRGF0YSkge1xuICAgICAgdmFyIGksIG4gPSBncm91cC5sZW5ndGgsIG0gPSBncm91cERhdGEubGVuZ3RoLCBuMCA9IE1hdGgubWluKG4sIG0pLCB1cGRhdGVOb2RlcyA9IG5ldyBBcnJheShtKSwgZW50ZXJOb2RlcyA9IG5ldyBBcnJheShtKSwgZXhpdE5vZGVzID0gbmV3IEFycmF5KG4pLCBub2RlLCBub2RlRGF0YTtcbiAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgdmFyIG5vZGVCeUtleVZhbHVlID0gbmV3IGQzX01hcCgpLCBrZXlWYWx1ZXMgPSBuZXcgQXJyYXkobiksIGtleVZhbHVlO1xuICAgICAgICBmb3IgKGkgPSAtMTsgKytpIDwgbjsgKSB7XG4gICAgICAgICAgaWYgKG5vZGUgPSBncm91cFtpXSkge1xuICAgICAgICAgICAgaWYgKG5vZGVCeUtleVZhbHVlLmhhcyhrZXlWYWx1ZSA9IGtleS5jYWxsKG5vZGUsIG5vZGUuX19kYXRhX18sIGkpKSkge1xuICAgICAgICAgICAgICBleGl0Tm9kZXNbaV0gPSBub2RlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbm9kZUJ5S2V5VmFsdWUuc2V0KGtleVZhbHVlLCBub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGtleVZhbHVlc1tpXSA9IGtleVZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSAtMTsgKytpIDwgbTsgKSB7XG4gICAgICAgICAgaWYgKCEobm9kZSA9IG5vZGVCeUtleVZhbHVlLmdldChrZXlWYWx1ZSA9IGtleS5jYWxsKGdyb3VwRGF0YSwgbm9kZURhdGEgPSBncm91cERhdGFbaV0sIGkpKSkpIHtcbiAgICAgICAgICAgIGVudGVyTm9kZXNbaV0gPSBkM19zZWxlY3Rpb25fZGF0YU5vZGUobm9kZURhdGEpO1xuICAgICAgICAgIH0gZWxzZSBpZiAobm9kZSAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgdXBkYXRlTm9kZXNbaV0gPSBub2RlO1xuICAgICAgICAgICAgbm9kZS5fX2RhdGFfXyA9IG5vZGVEYXRhO1xuICAgICAgICAgIH1cbiAgICAgICAgICBub2RlQnlLZXlWYWx1ZS5zZXQoa2V5VmFsdWUsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IC0xOyArK2kgPCBuOyApIHtcbiAgICAgICAgICBpZiAoaSBpbiBrZXlWYWx1ZXMgJiYgbm9kZUJ5S2V5VmFsdWUuZ2V0KGtleVZhbHVlc1tpXSkgIT09IHRydWUpIHtcbiAgICAgICAgICAgIGV4aXROb2Rlc1tpXSA9IGdyb3VwW2ldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChpID0gLTE7ICsraSA8IG4wOyApIHtcbiAgICAgICAgICBub2RlID0gZ3JvdXBbaV07XG4gICAgICAgICAgbm9kZURhdGEgPSBncm91cERhdGFbaV07XG4gICAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgIG5vZGUuX19kYXRhX18gPSBub2RlRGF0YTtcbiAgICAgICAgICAgIHVwZGF0ZU5vZGVzW2ldID0gbm9kZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZW50ZXJOb2Rlc1tpXSA9IGQzX3NlbGVjdGlvbl9kYXRhTm9kZShub2RlRGF0YSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAoO2kgPCBtOyArK2kpIHtcbiAgICAgICAgICBlbnRlck5vZGVzW2ldID0gZDNfc2VsZWN0aW9uX2RhdGFOb2RlKGdyb3VwRGF0YVtpXSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICg7aSA8IG47ICsraSkge1xuICAgICAgICAgIGV4aXROb2Rlc1tpXSA9IGdyb3VwW2ldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbnRlck5vZGVzLnVwZGF0ZSA9IHVwZGF0ZU5vZGVzO1xuICAgICAgZW50ZXJOb2Rlcy5wYXJlbnROb2RlID0gdXBkYXRlTm9kZXMucGFyZW50Tm9kZSA9IGV4aXROb2Rlcy5wYXJlbnROb2RlID0gZ3JvdXAucGFyZW50Tm9kZTtcbiAgICAgIGVudGVyLnB1c2goZW50ZXJOb2Rlcyk7XG4gICAgICB1cGRhdGUucHVzaCh1cGRhdGVOb2Rlcyk7XG4gICAgICBleGl0LnB1c2goZXhpdE5vZGVzKTtcbiAgICB9XG4gICAgdmFyIGVudGVyID0gZDNfc2VsZWN0aW9uX2VudGVyKFtdKSwgdXBkYXRlID0gZDNfc2VsZWN0aW9uKFtdKSwgZXhpdCA9IGQzX3NlbGVjdGlvbihbXSk7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICBiaW5kKGdyb3VwID0gdGhpc1tpXSwgdmFsdWUuY2FsbChncm91cCwgZ3JvdXAucGFyZW50Tm9kZS5fX2RhdGFfXywgaSkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICBiaW5kKGdyb3VwID0gdGhpc1tpXSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGUuZW50ZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBlbnRlcjtcbiAgICB9O1xuICAgIHVwZGF0ZS5leGl0ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZXhpdDtcbiAgICB9O1xuICAgIHJldHVybiB1cGRhdGU7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX3NlbGVjdGlvbl9kYXRhTm9kZShkYXRhKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIF9fZGF0YV9fOiBkYXRhXG4gICAgfTtcbiAgfVxuICBkM19zZWxlY3Rpb25Qcm90b3R5cGUuZGF0dW0gPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gdGhpcy5wcm9wZXJ0eShcIl9fZGF0YV9fXCIsIHZhbHVlKSA6IHRoaXMucHJvcGVydHkoXCJfX2RhdGFfX1wiKTtcbiAgfTtcbiAgZDNfc2VsZWN0aW9uUHJvdG90eXBlLmZpbHRlciA9IGZ1bmN0aW9uKGZpbHRlcikge1xuICAgIHZhciBzdWJncm91cHMgPSBbXSwgc3ViZ3JvdXAsIGdyb3VwLCBub2RlO1xuICAgIGlmICh0eXBlb2YgZmlsdGVyICE9PSBcImZ1bmN0aW9uXCIpIGZpbHRlciA9IGQzX3NlbGVjdGlvbl9maWx0ZXIoZmlsdGVyKTtcbiAgICBmb3IgKHZhciBqID0gMCwgbSA9IHRoaXMubGVuZ3RoOyBqIDwgbTsgaisrKSB7XG4gICAgICBzdWJncm91cHMucHVzaChzdWJncm91cCA9IFtdKTtcbiAgICAgIHN1Ymdyb3VwLnBhcmVudE5vZGUgPSAoZ3JvdXAgPSB0aGlzW2pdKS5wYXJlbnROb2RlO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBncm91cC5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgaWYgKChub2RlID0gZ3JvdXBbaV0pICYmIGZpbHRlci5jYWxsKG5vZGUsIG5vZGUuX19kYXRhX18sIGksIGopKSB7XG4gICAgICAgICAgc3ViZ3JvdXAucHVzaChub2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZDNfc2VsZWN0aW9uKHN1Ymdyb3Vwcyk7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX3NlbGVjdGlvbl9maWx0ZXIoc2VsZWN0b3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZDNfc2VsZWN0TWF0Y2hlcyh0aGlzLCBzZWxlY3Rvcik7XG4gICAgfTtcbiAgfVxuICBkM19zZWxlY3Rpb25Qcm90b3R5cGUub3JkZXIgPSBmdW5jdGlvbigpIHtcbiAgICBmb3IgKHZhciBqID0gLTEsIG0gPSB0aGlzLmxlbmd0aDsgKytqIDwgbTsgKSB7XG4gICAgICBmb3IgKHZhciBncm91cCA9IHRoaXNbal0sIGkgPSBncm91cC5sZW5ndGggLSAxLCBuZXh0ID0gZ3JvdXBbaV0sIG5vZGU7IC0taSA+PSAwOyApIHtcbiAgICAgICAgaWYgKG5vZGUgPSBncm91cFtpXSkge1xuICAgICAgICAgIGlmIChuZXh0ICYmIG5leHQgIT09IG5vZGUubmV4dFNpYmxpbmcpIG5leHQucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobm9kZSwgbmV4dCk7XG4gICAgICAgICAgbmV4dCA9IG5vZGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIGQzX3NlbGVjdGlvblByb3RvdHlwZS5zb3J0ID0gZnVuY3Rpb24oY29tcGFyYXRvcikge1xuICAgIGNvbXBhcmF0b3IgPSBkM19zZWxlY3Rpb25fc29ydENvbXBhcmF0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBmb3IgKHZhciBqID0gLTEsIG0gPSB0aGlzLmxlbmd0aDsgKytqIDwgbTsgKSB0aGlzW2pdLnNvcnQoY29tcGFyYXRvcik7XG4gICAgcmV0dXJuIHRoaXMub3JkZXIoKTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfc2VsZWN0aW9uX3NvcnRDb21wYXJhdG9yKGNvbXBhcmF0b3IpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIGNvbXBhcmF0b3IgPSBkM19hc2NlbmRpbmc7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgIHJldHVybiBhICYmIGIgPyBjb21wYXJhdG9yKGEuX19kYXRhX18sIGIuX19kYXRhX18pIDogIWEgLSAhYjtcbiAgICB9O1xuICB9XG4gIGQzX3NlbGVjdGlvblByb3RvdHlwZS5lYWNoID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICByZXR1cm4gZDNfc2VsZWN0aW9uX2VhY2godGhpcywgZnVuY3Rpb24obm9kZSwgaSwgaikge1xuICAgICAgY2FsbGJhY2suY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBpLCBqKTtcbiAgICB9KTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfc2VsZWN0aW9uX2VhY2goZ3JvdXBzLCBjYWxsYmFjaykge1xuICAgIGZvciAodmFyIGogPSAwLCBtID0gZ3JvdXBzLmxlbmd0aDsgaiA8IG07IGorKykge1xuICAgICAgZm9yICh2YXIgZ3JvdXAgPSBncm91cHNbal0sIGkgPSAwLCBuID0gZ3JvdXAubGVuZ3RoLCBub2RlOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIGlmIChub2RlID0gZ3JvdXBbaV0pIGNhbGxiYWNrKG5vZGUsIGksIGopO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZ3JvdXBzO1xuICB9XG4gIGQzX3NlbGVjdGlvblByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICB2YXIgYXJncyA9IGQzX2FycmF5KGFyZ3VtZW50cyk7XG4gICAgY2FsbGJhY2suYXBwbHkoYXJnc1swXSA9IHRoaXMsIGFyZ3MpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBkM19zZWxlY3Rpb25Qcm90b3R5cGUuZW1wdHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gIXRoaXMubm9kZSgpO1xuICB9O1xuICBkM19zZWxlY3Rpb25Qcm90b3R5cGUubm9kZSA9IGZ1bmN0aW9uKCkge1xuICAgIGZvciAodmFyIGogPSAwLCBtID0gdGhpcy5sZW5ndGg7IGogPCBtOyBqKyspIHtcbiAgICAgIGZvciAodmFyIGdyb3VwID0gdGhpc1tqXSwgaSA9IDAsIG4gPSBncm91cC5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgdmFyIG5vZGUgPSBncm91cFtpXTtcbiAgICAgICAgaWYgKG5vZGUpIHJldHVybiBub2RlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcbiAgZDNfc2VsZWN0aW9uUHJvdG90eXBlLnNpemUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgbiA9IDA7XG4gICAgZDNfc2VsZWN0aW9uX2VhY2godGhpcywgZnVuY3Rpb24oKSB7XG4gICAgICArK247XG4gICAgfSk7XG4gICAgcmV0dXJuIG47XG4gIH07XG4gIGZ1bmN0aW9uIGQzX3NlbGVjdGlvbl9lbnRlcihzZWxlY3Rpb24pIHtcbiAgICBkM19zdWJjbGFzcyhzZWxlY3Rpb24sIGQzX3NlbGVjdGlvbl9lbnRlclByb3RvdHlwZSk7XG4gICAgcmV0dXJuIHNlbGVjdGlvbjtcbiAgfVxuICB2YXIgZDNfc2VsZWN0aW9uX2VudGVyUHJvdG90eXBlID0gW107XG4gIGQzLnNlbGVjdGlvbi5lbnRlciA9IGQzX3NlbGVjdGlvbl9lbnRlcjtcbiAgZDMuc2VsZWN0aW9uLmVudGVyLnByb3RvdHlwZSA9IGQzX3NlbGVjdGlvbl9lbnRlclByb3RvdHlwZTtcbiAgZDNfc2VsZWN0aW9uX2VudGVyUHJvdG90eXBlLmFwcGVuZCA9IGQzX3NlbGVjdGlvblByb3RvdHlwZS5hcHBlbmQ7XG4gIGQzX3NlbGVjdGlvbl9lbnRlclByb3RvdHlwZS5lbXB0eSA9IGQzX3NlbGVjdGlvblByb3RvdHlwZS5lbXB0eTtcbiAgZDNfc2VsZWN0aW9uX2VudGVyUHJvdG90eXBlLm5vZGUgPSBkM19zZWxlY3Rpb25Qcm90b3R5cGUubm9kZTtcbiAgZDNfc2VsZWN0aW9uX2VudGVyUHJvdG90eXBlLmNhbGwgPSBkM19zZWxlY3Rpb25Qcm90b3R5cGUuY2FsbDtcbiAgZDNfc2VsZWN0aW9uX2VudGVyUHJvdG90eXBlLnNpemUgPSBkM19zZWxlY3Rpb25Qcm90b3R5cGUuc2l6ZTtcbiAgZDNfc2VsZWN0aW9uX2VudGVyUHJvdG90eXBlLnNlbGVjdCA9IGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG4gICAgdmFyIHN1Ymdyb3VwcyA9IFtdLCBzdWJncm91cCwgc3Vibm9kZSwgdXBncm91cCwgZ3JvdXAsIG5vZGU7XG4gICAgZm9yICh2YXIgaiA9IC0xLCBtID0gdGhpcy5sZW5ndGg7ICsraiA8IG07ICkge1xuICAgICAgdXBncm91cCA9IChncm91cCA9IHRoaXNbal0pLnVwZGF0ZTtcbiAgICAgIHN1Ymdyb3Vwcy5wdXNoKHN1Ymdyb3VwID0gW10pO1xuICAgICAgc3ViZ3JvdXAucGFyZW50Tm9kZSA9IGdyb3VwLnBhcmVudE5vZGU7XG4gICAgICBmb3IgKHZhciBpID0gLTEsIG4gPSBncm91cC5sZW5ndGg7ICsraSA8IG47ICkge1xuICAgICAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSB7XG4gICAgICAgICAgc3ViZ3JvdXAucHVzaCh1cGdyb3VwW2ldID0gc3Vibm9kZSA9IHNlbGVjdG9yLmNhbGwoZ3JvdXAucGFyZW50Tm9kZSwgbm9kZS5fX2RhdGFfXywgaSwgaikpO1xuICAgICAgICAgIHN1Ym5vZGUuX19kYXRhX18gPSBub2RlLl9fZGF0YV9fO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN1Ymdyb3VwLnB1c2gobnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGQzX3NlbGVjdGlvbihzdWJncm91cHMpO1xuICB9O1xuICBkM19zZWxlY3Rpb25fZW50ZXJQcm90b3R5cGUuaW5zZXJ0ID0gZnVuY3Rpb24obmFtZSwgYmVmb3JlKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSBiZWZvcmUgPSBkM19zZWxlY3Rpb25fZW50ZXJJbnNlcnRCZWZvcmUodGhpcyk7XG4gICAgcmV0dXJuIGQzX3NlbGVjdGlvblByb3RvdHlwZS5pbnNlcnQuY2FsbCh0aGlzLCBuYW1lLCBiZWZvcmUpO1xuICB9O1xuICBmdW5jdGlvbiBkM19zZWxlY3Rpb25fZW50ZXJJbnNlcnRCZWZvcmUoZW50ZXIpIHtcbiAgICB2YXIgaTAsIGowO1xuICAgIHJldHVybiBmdW5jdGlvbihkLCBpLCBqKSB7XG4gICAgICB2YXIgZ3JvdXAgPSBlbnRlcltqXS51cGRhdGUsIG4gPSBncm91cC5sZW5ndGgsIG5vZGU7XG4gICAgICBpZiAoaiAhPSBqMCkgajAgPSBqLCBpMCA9IDA7XG4gICAgICBpZiAoaSA+PSBpMCkgaTAgPSBpICsgMTtcbiAgICAgIHdoaWxlICghKG5vZGUgPSBncm91cFtpMF0pICYmICsraTAgPCBuKSA7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9O1xuICB9XG4gIGQzLnNlbGVjdCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICB2YXIgZ3JvdXA7XG4gICAgaWYgKHR5cGVvZiBub2RlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBncm91cCA9IFsgZDNfc2VsZWN0KG5vZGUsIGQzX2RvY3VtZW50KSBdO1xuICAgICAgZ3JvdXAucGFyZW50Tm9kZSA9IGQzX2RvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgZ3JvdXAgPSBbIG5vZGUgXTtcbiAgICAgIGdyb3VwLnBhcmVudE5vZGUgPSBkM19kb2N1bWVudEVsZW1lbnQobm9kZSk7XG4gICAgfVxuICAgIHJldHVybiBkM19zZWxlY3Rpb24oWyBncm91cCBdKTtcbiAgfTtcbiAgZDMuc2VsZWN0QWxsID0gZnVuY3Rpb24obm9kZXMpIHtcbiAgICB2YXIgZ3JvdXA7XG4gICAgaWYgKHR5cGVvZiBub2RlcyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgZ3JvdXAgPSBkM19hcnJheShkM19zZWxlY3RBbGwobm9kZXMsIGQzX2RvY3VtZW50KSk7XG4gICAgICBncm91cC5wYXJlbnROb2RlID0gZDNfZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICBncm91cCA9IGQzX2FycmF5KG5vZGVzKTtcbiAgICAgIGdyb3VwLnBhcmVudE5vZGUgPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gZDNfc2VsZWN0aW9uKFsgZ3JvdXAgXSk7XG4gIH07XG4gIGQzX3NlbGVjdGlvblByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyLCBjYXB0dXJlKSB7XG4gICAgdmFyIG4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGlmIChuIDwgMykge1xuICAgICAgaWYgKHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGlmIChuIDwgMikgbGlzdGVuZXIgPSBmYWxzZTtcbiAgICAgICAgZm9yIChjYXB0dXJlIGluIHR5cGUpIHRoaXMuZWFjaChkM19zZWxlY3Rpb25fb24oY2FwdHVyZSwgdHlwZVtjYXB0dXJlXSwgbGlzdGVuZXIpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBpZiAobiA8IDIpIHJldHVybiAobiA9IHRoaXMubm9kZSgpW1wiX19vblwiICsgdHlwZV0pICYmIG4uXztcbiAgICAgIGNhcHR1cmUgPSBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZWFjaChkM19zZWxlY3Rpb25fb24odHlwZSwgbGlzdGVuZXIsIGNhcHR1cmUpKTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfc2VsZWN0aW9uX29uKHR5cGUsIGxpc3RlbmVyLCBjYXB0dXJlKSB7XG4gICAgdmFyIG5hbWUgPSBcIl9fb25cIiArIHR5cGUsIGkgPSB0eXBlLmluZGV4T2YoXCIuXCIpLCB3cmFwID0gZDNfc2VsZWN0aW9uX29uTGlzdGVuZXI7XG4gICAgaWYgKGkgPiAwKSB0eXBlID0gdHlwZS5zbGljZSgwLCBpKTtcbiAgICB2YXIgZmlsdGVyID0gZDNfc2VsZWN0aW9uX29uRmlsdGVycy5nZXQodHlwZSk7XG4gICAgaWYgKGZpbHRlcikgdHlwZSA9IGZpbHRlciwgd3JhcCA9IGQzX3NlbGVjdGlvbl9vbkZpbHRlcjtcbiAgICBmdW5jdGlvbiBvblJlbW92ZSgpIHtcbiAgICAgIHZhciBsID0gdGhpc1tuYW1lXTtcbiAgICAgIGlmIChsKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBsLCBsLiQpO1xuICAgICAgICBkZWxldGUgdGhpc1tuYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gb25BZGQoKSB7XG4gICAgICB2YXIgbCA9IHdyYXAobGlzdGVuZXIsIGQzX2FycmF5KGFyZ3VtZW50cykpO1xuICAgICAgb25SZW1vdmUuY2FsbCh0aGlzKTtcbiAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCB0aGlzW25hbWVdID0gbCwgbC4kID0gY2FwdHVyZSk7XG4gICAgICBsLl8gPSBsaXN0ZW5lcjtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVtb3ZlQWxsKCkge1xuICAgICAgdmFyIHJlID0gbmV3IFJlZ0V4cChcIl5fX29uKFteLl0rKVwiICsgZDMucmVxdW90ZSh0eXBlKSArIFwiJFwiKSwgbWF0Y2g7XG4gICAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMpIHtcbiAgICAgICAgaWYgKG1hdGNoID0gbmFtZS5tYXRjaChyZSkpIHtcbiAgICAgICAgICB2YXIgbCA9IHRoaXNbbmFtZV07XG4gICAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKG1hdGNoWzFdLCBsLCBsLiQpO1xuICAgICAgICAgIGRlbGV0ZSB0aGlzW25hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpID8gbGlzdGVuZXIgPyBvbkFkZCA6IG9uUmVtb3ZlIDogbGlzdGVuZXIgPyBkM19ub29wIDogcmVtb3ZlQWxsO1xuICB9XG4gIHZhciBkM19zZWxlY3Rpb25fb25GaWx0ZXJzID0gZDMubWFwKHtcbiAgICBtb3VzZWVudGVyOiBcIm1vdXNlb3ZlclwiLFxuICAgIG1vdXNlbGVhdmU6IFwibW91c2VvdXRcIlxuICB9KTtcbiAgaWYgKGQzX2RvY3VtZW50KSB7XG4gICAgZDNfc2VsZWN0aW9uX29uRmlsdGVycy5mb3JFYWNoKGZ1bmN0aW9uKGspIHtcbiAgICAgIGlmIChcIm9uXCIgKyBrIGluIGQzX2RvY3VtZW50KSBkM19zZWxlY3Rpb25fb25GaWx0ZXJzLnJlbW92ZShrKTtcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBkM19zZWxlY3Rpb25fb25MaXN0ZW5lcihsaXN0ZW5lciwgYXJndW1lbnR6KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGUpIHtcbiAgICAgIHZhciBvID0gZDMuZXZlbnQ7XG4gICAgICBkMy5ldmVudCA9IGU7XG4gICAgICBhcmd1bWVudHpbMF0gPSB0aGlzLl9fZGF0YV9fO1xuICAgICAgdHJ5IHtcbiAgICAgICAgbGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnR6KTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGQzLmV2ZW50ID0gbztcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGQzX3NlbGVjdGlvbl9vbkZpbHRlcihsaXN0ZW5lciwgYXJndW1lbnR6KSB7XG4gICAgdmFyIGwgPSBkM19zZWxlY3Rpb25fb25MaXN0ZW5lcihsaXN0ZW5lciwgYXJndW1lbnR6KTtcbiAgICByZXR1cm4gZnVuY3Rpb24oZSkge1xuICAgICAgdmFyIHRhcmdldCA9IHRoaXMsIHJlbGF0ZWQgPSBlLnJlbGF0ZWRUYXJnZXQ7XG4gICAgICBpZiAoIXJlbGF0ZWQgfHwgcmVsYXRlZCAhPT0gdGFyZ2V0ICYmICEocmVsYXRlZC5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbih0YXJnZXQpICYgOCkpIHtcbiAgICAgICAgbC5jYWxsKHRhcmdldCwgZSk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICB2YXIgZDNfZXZlbnRfZHJhZ1NlbGVjdCwgZDNfZXZlbnRfZHJhZ0lkID0gMDtcbiAgZnVuY3Rpb24gZDNfZXZlbnRfZHJhZ1N1cHByZXNzKG5vZGUpIHtcbiAgICB2YXIgbmFtZSA9IFwiLmRyYWdzdXBwcmVzcy1cIiArICsrZDNfZXZlbnRfZHJhZ0lkLCBjbGljayA9IFwiY2xpY2tcIiArIG5hbWUsIHcgPSBkMy5zZWxlY3QoZDNfd2luZG93KG5vZGUpKS5vbihcInRvdWNobW92ZVwiICsgbmFtZSwgZDNfZXZlbnRQcmV2ZW50RGVmYXVsdCkub24oXCJkcmFnc3RhcnRcIiArIG5hbWUsIGQzX2V2ZW50UHJldmVudERlZmF1bHQpLm9uKFwic2VsZWN0c3RhcnRcIiArIG5hbWUsIGQzX2V2ZW50UHJldmVudERlZmF1bHQpO1xuICAgIGlmIChkM19ldmVudF9kcmFnU2VsZWN0ID09IG51bGwpIHtcbiAgICAgIGQzX2V2ZW50X2RyYWdTZWxlY3QgPSBcIm9uc2VsZWN0c3RhcnRcIiBpbiBub2RlID8gZmFsc2UgOiBkM192ZW5kb3JTeW1ib2wobm9kZS5zdHlsZSwgXCJ1c2VyU2VsZWN0XCIpO1xuICAgIH1cbiAgICBpZiAoZDNfZXZlbnRfZHJhZ1NlbGVjdCkge1xuICAgICAgdmFyIHN0eWxlID0gZDNfZG9jdW1lbnRFbGVtZW50KG5vZGUpLnN0eWxlLCBzZWxlY3QgPSBzdHlsZVtkM19ldmVudF9kcmFnU2VsZWN0XTtcbiAgICAgIHN0eWxlW2QzX2V2ZW50X2RyYWdTZWxlY3RdID0gXCJub25lXCI7XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbihzdXBwcmVzc0NsaWNrKSB7XG4gICAgICB3Lm9uKG5hbWUsIG51bGwpO1xuICAgICAgaWYgKGQzX2V2ZW50X2RyYWdTZWxlY3QpIHN0eWxlW2QzX2V2ZW50X2RyYWdTZWxlY3RdID0gc2VsZWN0O1xuICAgICAgaWYgKHN1cHByZXNzQ2xpY2spIHtcbiAgICAgICAgdmFyIG9mZiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHcub24oY2xpY2ssIG51bGwpO1xuICAgICAgICB9O1xuICAgICAgICB3Lm9uKGNsaWNrLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICBkM19ldmVudFByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgb2ZmKCk7XG4gICAgICAgIH0sIHRydWUpO1xuICAgICAgICBzZXRUaW1lb3V0KG9mZiwgMCk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBkMy5tb3VzZSA9IGZ1bmN0aW9uKGNvbnRhaW5lcikge1xuICAgIHJldHVybiBkM19tb3VzZVBvaW50KGNvbnRhaW5lciwgZDNfZXZlbnRTb3VyY2UoKSk7XG4gIH07XG4gIHZhciBkM19tb3VzZV9idWc0NDA4MyA9IHRoaXMubmF2aWdhdG9yICYmIC9XZWJLaXQvLnRlc3QodGhpcy5uYXZpZ2F0b3IudXNlckFnZW50KSA/IC0xIDogMDtcbiAgZnVuY3Rpb24gZDNfbW91c2VQb2ludChjb250YWluZXIsIGUpIHtcbiAgICBpZiAoZS5jaGFuZ2VkVG91Y2hlcykgZSA9IGUuY2hhbmdlZFRvdWNoZXNbMF07XG4gICAgdmFyIHN2ZyA9IGNvbnRhaW5lci5vd25lclNWR0VsZW1lbnQgfHwgY29udGFpbmVyO1xuICAgIGlmIChzdmcuY3JlYXRlU1ZHUG9pbnQpIHtcbiAgICAgIHZhciBwb2ludCA9IHN2Zy5jcmVhdGVTVkdQb2ludCgpO1xuICAgICAgaWYgKGQzX21vdXNlX2J1ZzQ0MDgzIDwgMCkge1xuICAgICAgICB2YXIgd2luZG93ID0gZDNfd2luZG93KGNvbnRhaW5lcik7XG4gICAgICAgIGlmICh3aW5kb3cuc2Nyb2xsWCB8fCB3aW5kb3cuc2Nyb2xsWSkge1xuICAgICAgICAgIHN2ZyA9IGQzLnNlbGVjdChcImJvZHlcIikuYXBwZW5kKFwic3ZnXCIpLnN0eWxlKHtcbiAgICAgICAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG4gICAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgICBsZWZ0OiAwLFxuICAgICAgICAgICAgbWFyZ2luOiAwLFxuICAgICAgICAgICAgcGFkZGluZzogMCxcbiAgICAgICAgICAgIGJvcmRlcjogXCJub25lXCJcbiAgICAgICAgICB9LCBcImltcG9ydGFudFwiKTtcbiAgICAgICAgICB2YXIgY3RtID0gc3ZnWzBdWzBdLmdldFNjcmVlbkNUTSgpO1xuICAgICAgICAgIGQzX21vdXNlX2J1ZzQ0MDgzID0gIShjdG0uZiB8fCBjdG0uZSk7XG4gICAgICAgICAgc3ZnLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZDNfbW91c2VfYnVnNDQwODMpIHBvaW50LnggPSBlLnBhZ2VYLCBwb2ludC55ID0gZS5wYWdlWTsgZWxzZSBwb2ludC54ID0gZS5jbGllbnRYLCBcbiAgICAgIHBvaW50LnkgPSBlLmNsaWVudFk7XG4gICAgICBwb2ludCA9IHBvaW50Lm1hdHJpeFRyYW5zZm9ybShjb250YWluZXIuZ2V0U2NyZWVuQ1RNKCkuaW52ZXJzZSgpKTtcbiAgICAgIHJldHVybiBbIHBvaW50LngsIHBvaW50LnkgXTtcbiAgICB9XG4gICAgdmFyIHJlY3QgPSBjb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgcmV0dXJuIFsgZS5jbGllbnRYIC0gcmVjdC5sZWZ0IC0gY29udGFpbmVyLmNsaWVudExlZnQsIGUuY2xpZW50WSAtIHJlY3QudG9wIC0gY29udGFpbmVyLmNsaWVudFRvcCBdO1xuICB9XG4gIGQzLnRvdWNoID0gZnVuY3Rpb24oY29udGFpbmVyLCB0b3VjaGVzLCBpZGVudGlmaWVyKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAzKSBpZGVudGlmaWVyID0gdG91Y2hlcywgdG91Y2hlcyA9IGQzX2V2ZW50U291cmNlKCkuY2hhbmdlZFRvdWNoZXM7XG4gICAgaWYgKHRvdWNoZXMpIGZvciAodmFyIGkgPSAwLCBuID0gdG91Y2hlcy5sZW5ndGgsIHRvdWNoOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAoKHRvdWNoID0gdG91Y2hlc1tpXSkuaWRlbnRpZmllciA9PT0gaWRlbnRpZmllcikge1xuICAgICAgICByZXR1cm4gZDNfbW91c2VQb2ludChjb250YWluZXIsIHRvdWNoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIGQzLmJlaGF2aW9yLmRyYWcgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZXZlbnQgPSBkM19ldmVudERpc3BhdGNoKGRyYWcsIFwiZHJhZ1wiLCBcImRyYWdzdGFydFwiLCBcImRyYWdlbmRcIiksIG9yaWdpbiA9IG51bGwsIG1vdXNlZG93biA9IGRyYWdzdGFydChkM19ub29wLCBkMy5tb3VzZSwgZDNfd2luZG93LCBcIm1vdXNlbW92ZVwiLCBcIm1vdXNldXBcIiksIHRvdWNoc3RhcnQgPSBkcmFnc3RhcnQoZDNfYmVoYXZpb3JfZHJhZ1RvdWNoSWQsIGQzLnRvdWNoLCBkM19pZGVudGl0eSwgXCJ0b3VjaG1vdmVcIiwgXCJ0b3VjaGVuZFwiKTtcbiAgICBmdW5jdGlvbiBkcmFnKCkge1xuICAgICAgdGhpcy5vbihcIm1vdXNlZG93bi5kcmFnXCIsIG1vdXNlZG93bikub24oXCJ0b3VjaHN0YXJ0LmRyYWdcIiwgdG91Y2hzdGFydCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRyYWdzdGFydChpZCwgcG9zaXRpb24sIHN1YmplY3QsIG1vdmUsIGVuZCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXMsIHRhcmdldCA9IGQzLmV2ZW50LnRhcmdldC5jb3JyZXNwb25kaW5nRWxlbWVudCB8fCBkMy5ldmVudC50YXJnZXQsIHBhcmVudCA9IHRoYXQucGFyZW50Tm9kZSwgZGlzcGF0Y2ggPSBldmVudC5vZih0aGF0LCBhcmd1bWVudHMpLCBkcmFnZ2VkID0gMCwgZHJhZ0lkID0gaWQoKSwgZHJhZ05hbWUgPSBcIi5kcmFnXCIgKyAoZHJhZ0lkID09IG51bGwgPyBcIlwiIDogXCItXCIgKyBkcmFnSWQpLCBkcmFnT2Zmc2V0LCBkcmFnU3ViamVjdCA9IGQzLnNlbGVjdChzdWJqZWN0KHRhcmdldCkpLm9uKG1vdmUgKyBkcmFnTmFtZSwgbW92ZWQpLm9uKGVuZCArIGRyYWdOYW1lLCBlbmRlZCksIGRyYWdSZXN0b3JlID0gZDNfZXZlbnRfZHJhZ1N1cHByZXNzKHRhcmdldCksIHBvc2l0aW9uMCA9IHBvc2l0aW9uKHBhcmVudCwgZHJhZ0lkKTtcbiAgICAgICAgaWYgKG9yaWdpbikge1xuICAgICAgICAgIGRyYWdPZmZzZXQgPSBvcmlnaW4uYXBwbHkodGhhdCwgYXJndW1lbnRzKTtcbiAgICAgICAgICBkcmFnT2Zmc2V0ID0gWyBkcmFnT2Zmc2V0LnggLSBwb3NpdGlvbjBbMF0sIGRyYWdPZmZzZXQueSAtIHBvc2l0aW9uMFsxXSBdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRyYWdPZmZzZXQgPSBbIDAsIDAgXTtcbiAgICAgICAgfVxuICAgICAgICBkaXNwYXRjaCh7XG4gICAgICAgICAgdHlwZTogXCJkcmFnc3RhcnRcIlxuICAgICAgICB9KTtcbiAgICAgICAgZnVuY3Rpb24gbW92ZWQoKSB7XG4gICAgICAgICAgdmFyIHBvc2l0aW9uMSA9IHBvc2l0aW9uKHBhcmVudCwgZHJhZ0lkKSwgZHgsIGR5O1xuICAgICAgICAgIGlmICghcG9zaXRpb24xKSByZXR1cm47XG4gICAgICAgICAgZHggPSBwb3NpdGlvbjFbMF0gLSBwb3NpdGlvbjBbMF07XG4gICAgICAgICAgZHkgPSBwb3NpdGlvbjFbMV0gLSBwb3NpdGlvbjBbMV07XG4gICAgICAgICAgZHJhZ2dlZCB8PSBkeCB8IGR5O1xuICAgICAgICAgIHBvc2l0aW9uMCA9IHBvc2l0aW9uMTtcbiAgICAgICAgICBkaXNwYXRjaCh7XG4gICAgICAgICAgICB0eXBlOiBcImRyYWdcIixcbiAgICAgICAgICAgIHg6IHBvc2l0aW9uMVswXSArIGRyYWdPZmZzZXRbMF0sXG4gICAgICAgICAgICB5OiBwb3NpdGlvbjFbMV0gKyBkcmFnT2Zmc2V0WzFdLFxuICAgICAgICAgICAgZHg6IGR4LFxuICAgICAgICAgICAgZHk6IGR5XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZW5kZWQoKSB7XG4gICAgICAgICAgaWYgKCFwb3NpdGlvbihwYXJlbnQsIGRyYWdJZCkpIHJldHVybjtcbiAgICAgICAgICBkcmFnU3ViamVjdC5vbihtb3ZlICsgZHJhZ05hbWUsIG51bGwpLm9uKGVuZCArIGRyYWdOYW1lLCBudWxsKTtcbiAgICAgICAgICBkcmFnUmVzdG9yZShkcmFnZ2VkKTtcbiAgICAgICAgICBkaXNwYXRjaCh7XG4gICAgICAgICAgICB0eXBlOiBcImRyYWdlbmRcIlxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICBkcmFnLm9yaWdpbiA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG9yaWdpbjtcbiAgICAgIG9yaWdpbiA9IHg7XG4gICAgICByZXR1cm4gZHJhZztcbiAgICB9O1xuICAgIHJldHVybiBkMy5yZWJpbmQoZHJhZywgZXZlbnQsIFwib25cIik7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX2JlaGF2aW9yX2RyYWdUb3VjaElkKCkge1xuICAgIHJldHVybiBkMy5ldmVudC5jaGFuZ2VkVG91Y2hlc1swXS5pZGVudGlmaWVyO1xuICB9XG4gIGQzLnRvdWNoZXMgPSBmdW5jdGlvbihjb250YWluZXIsIHRvdWNoZXMpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHRvdWNoZXMgPSBkM19ldmVudFNvdXJjZSgpLnRvdWNoZXM7XG4gICAgcmV0dXJuIHRvdWNoZXMgPyBkM19hcnJheSh0b3VjaGVzKS5tYXAoZnVuY3Rpb24odG91Y2gpIHtcbiAgICAgIHZhciBwb2ludCA9IGQzX21vdXNlUG9pbnQoY29udGFpbmVyLCB0b3VjaCk7XG4gICAgICBwb2ludC5pZGVudGlmaWVyID0gdG91Y2guaWRlbnRpZmllcjtcbiAgICAgIHJldHVybiBwb2ludDtcbiAgICB9KSA6IFtdO1xuICB9O1xuICB2YXIgzrUgPSAxZS02LCDOtTIgPSDOtSAqIM61LCDPgCA9IE1hdGguUEksIM+EID0gMiAqIM+ALCDPhM61ID0gz4QgLSDOtSwgaGFsZs+AID0gz4AgLyAyLCBkM19yYWRpYW5zID0gz4AgLyAxODAsIGQzX2RlZ3JlZXMgPSAxODAgLyDPgDtcbiAgZnVuY3Rpb24gZDNfc2duKHgpIHtcbiAgICByZXR1cm4geCA+IDAgPyAxIDogeCA8IDAgPyAtMSA6IDA7XG4gIH1cbiAgZnVuY3Rpb24gZDNfY3Jvc3MyZChhLCBiLCBjKSB7XG4gICAgcmV0dXJuIChiWzBdIC0gYVswXSkgKiAoY1sxXSAtIGFbMV0pIC0gKGJbMV0gLSBhWzFdKSAqIChjWzBdIC0gYVswXSk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfYWNvcyh4KSB7XG4gICAgcmV0dXJuIHggPiAxID8gMCA6IHggPCAtMSA/IM+AIDogTWF0aC5hY29zKHgpO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2FzaW4oeCkge1xuICAgIHJldHVybiB4ID4gMSA/IGhhbGbPgCA6IHggPCAtMSA/IC1oYWxmz4AgOiBNYXRoLmFzaW4oeCk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfc2luaCh4KSB7XG4gICAgcmV0dXJuICgoeCA9IE1hdGguZXhwKHgpKSAtIDEgLyB4KSAvIDI7XG4gIH1cbiAgZnVuY3Rpb24gZDNfY29zaCh4KSB7XG4gICAgcmV0dXJuICgoeCA9IE1hdGguZXhwKHgpKSArIDEgLyB4KSAvIDI7XG4gIH1cbiAgZnVuY3Rpb24gZDNfdGFuaCh4KSB7XG4gICAgcmV0dXJuICgoeCA9IE1hdGguZXhwKDIgKiB4KSkgLSAxKSAvICh4ICsgMSk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfaGF2ZXJzaW4oeCkge1xuICAgIHJldHVybiAoeCA9IE1hdGguc2luKHggLyAyKSkgKiB4O1xuICB9XG4gIHZhciDPgSA9IE1hdGguU1FSVDIsIM+BMiA9IDIsIM+BNCA9IDQ7XG4gIGQzLmludGVycG9sYXRlWm9vbSA9IGZ1bmN0aW9uKHAwLCBwMSkge1xuICAgIHZhciB1eDAgPSBwMFswXSwgdXkwID0gcDBbMV0sIHcwID0gcDBbMl0sIHV4MSA9IHAxWzBdLCB1eTEgPSBwMVsxXSwgdzEgPSBwMVsyXSwgZHggPSB1eDEgLSB1eDAsIGR5ID0gdXkxIC0gdXkwLCBkMiA9IGR4ICogZHggKyBkeSAqIGR5LCBpLCBTO1xuICAgIGlmIChkMiA8IM61Mikge1xuICAgICAgUyA9IE1hdGgubG9nKHcxIC8gdzApIC8gz4E7XG4gICAgICBpID0gZnVuY3Rpb24odCkge1xuICAgICAgICByZXR1cm4gWyB1eDAgKyB0ICogZHgsIHV5MCArIHQgKiBkeSwgdzAgKiBNYXRoLmV4cCjPgSAqIHQgKiBTKSBdO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGQxID0gTWF0aC5zcXJ0KGQyKSwgYjAgPSAodzEgKiB3MSAtIHcwICogdzAgKyDPgTQgKiBkMikgLyAoMiAqIHcwICogz4EyICogZDEpLCBiMSA9ICh3MSAqIHcxIC0gdzAgKiB3MCAtIM+BNCAqIGQyKSAvICgyICogdzEgKiDPgTIgKiBkMSksIHIwID0gTWF0aC5sb2coTWF0aC5zcXJ0KGIwICogYjAgKyAxKSAtIGIwKSwgcjEgPSBNYXRoLmxvZyhNYXRoLnNxcnQoYjEgKiBiMSArIDEpIC0gYjEpO1xuICAgICAgUyA9IChyMSAtIHIwKSAvIM+BO1xuICAgICAgaSA9IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgdmFyIHMgPSB0ICogUywgY29zaHIwID0gZDNfY29zaChyMCksIHUgPSB3MCAvICjPgTIgKiBkMSkgKiAoY29zaHIwICogZDNfdGFuaCjPgSAqIHMgKyByMCkgLSBkM19zaW5oKHIwKSk7XG4gICAgICAgIHJldHVybiBbIHV4MCArIHUgKiBkeCwgdXkwICsgdSAqIGR5LCB3MCAqIGNvc2hyMCAvIGQzX2Nvc2goz4EgKiBzICsgcjApIF07XG4gICAgICB9O1xuICAgIH1cbiAgICBpLmR1cmF0aW9uID0gUyAqIDFlMztcbiAgICByZXR1cm4gaTtcbiAgfTtcbiAgZDMuYmVoYXZpb3Iuem9vbSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB2aWV3ID0ge1xuICAgICAgeDogMCxcbiAgICAgIHk6IDAsXG4gICAgICBrOiAxXG4gICAgfSwgdHJhbnNsYXRlMCwgY2VudGVyMCwgY2VudGVyLCBzaXplID0gWyA5NjAsIDUwMCBdLCBzY2FsZUV4dGVudCA9IGQzX2JlaGF2aW9yX3pvb21JbmZpbml0eSwgZHVyYXRpb24gPSAyNTAsIHpvb21pbmcgPSAwLCBtb3VzZWRvd24gPSBcIm1vdXNlZG93bi56b29tXCIsIG1vdXNlbW92ZSA9IFwibW91c2Vtb3ZlLnpvb21cIiwgbW91c2V1cCA9IFwibW91c2V1cC56b29tXCIsIG1vdXNld2hlZWxUaW1lciwgdG91Y2hzdGFydCA9IFwidG91Y2hzdGFydC56b29tXCIsIHRvdWNodGltZSwgZXZlbnQgPSBkM19ldmVudERpc3BhdGNoKHpvb20sIFwiem9vbXN0YXJ0XCIsIFwiem9vbVwiLCBcInpvb21lbmRcIiksIHgwLCB4MSwgeTAsIHkxO1xuICAgIGlmICghZDNfYmVoYXZpb3Jfem9vbVdoZWVsKSB7XG4gICAgICBkM19iZWhhdmlvcl96b29tV2hlZWwgPSBcIm9ud2hlZWxcIiBpbiBkM19kb2N1bWVudCA/IChkM19iZWhhdmlvcl96b29tRGVsdGEgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIC1kMy5ldmVudC5kZWx0YVkgKiAoZDMuZXZlbnQuZGVsdGFNb2RlID8gMTIwIDogMSk7XG4gICAgICB9LCBcIndoZWVsXCIpIDogXCJvbm1vdXNld2hlZWxcIiBpbiBkM19kb2N1bWVudCA/IChkM19iZWhhdmlvcl96b29tRGVsdGEgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGQzLmV2ZW50LndoZWVsRGVsdGE7XG4gICAgICB9LCBcIm1vdXNld2hlZWxcIikgOiAoZDNfYmVoYXZpb3Jfem9vbURlbHRhID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAtZDMuZXZlbnQuZGV0YWlsO1xuICAgICAgfSwgXCJNb3pNb3VzZVBpeGVsU2Nyb2xsXCIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB6b29tKGcpIHtcbiAgICAgIGcub24obW91c2Vkb3duLCBtb3VzZWRvd25lZCkub24oZDNfYmVoYXZpb3Jfem9vbVdoZWVsICsgXCIuem9vbVwiLCBtb3VzZXdoZWVsZWQpLm9uKFwiZGJsY2xpY2suem9vbVwiLCBkYmxjbGlja2VkKS5vbih0b3VjaHN0YXJ0LCB0b3VjaHN0YXJ0ZWQpO1xuICAgIH1cbiAgICB6b29tLmV2ZW50ID0gZnVuY3Rpb24oZykge1xuICAgICAgZy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZGlzcGF0Y2ggPSBldmVudC5vZih0aGlzLCBhcmd1bWVudHMpLCB2aWV3MSA9IHZpZXc7XG4gICAgICAgIGlmIChkM190cmFuc2l0aW9uSW5oZXJpdElkKSB7XG4gICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLnRyYW5zaXRpb24oKS5lYWNoKFwic3RhcnQuem9vbVwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZpZXcgPSB0aGlzLl9fY2hhcnRfXyB8fCB7XG4gICAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgICAgIGs6IDFcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB6b29tc3RhcnRlZChkaXNwYXRjaCk7XG4gICAgICAgICAgfSkudHdlZW4oXCJ6b29tOnpvb21cIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgZHggPSBzaXplWzBdLCBkeSA9IHNpemVbMV0sIGN4ID0gY2VudGVyMCA/IGNlbnRlcjBbMF0gOiBkeCAvIDIsIGN5ID0gY2VudGVyMCA/IGNlbnRlcjBbMV0gOiBkeSAvIDIsIGkgPSBkMy5pbnRlcnBvbGF0ZVpvb20oWyAoY3ggLSB2aWV3LngpIC8gdmlldy5rLCAoY3kgLSB2aWV3LnkpIC8gdmlldy5rLCBkeCAvIHZpZXcuayBdLCBbIChjeCAtIHZpZXcxLngpIC8gdmlldzEuaywgKGN5IC0gdmlldzEueSkgLyB2aWV3MS5rLCBkeCAvIHZpZXcxLmsgXSk7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgICAgICAgICB2YXIgbCA9IGkodCksIGsgPSBkeCAvIGxbMl07XG4gICAgICAgICAgICAgIHRoaXMuX19jaGFydF9fID0gdmlldyA9IHtcbiAgICAgICAgICAgICAgICB4OiBjeCAtIGxbMF0gKiBrLFxuICAgICAgICAgICAgICAgIHk6IGN5IC0gbFsxXSAqIGssXG4gICAgICAgICAgICAgICAgazoga1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB6b29tZWQoZGlzcGF0Y2gpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9KS5lYWNoKFwiaW50ZXJydXB0Lnpvb21cIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB6b29tZW5kZWQoZGlzcGF0Y2gpO1xuICAgICAgICAgIH0pLmVhY2goXCJlbmQuem9vbVwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHpvb21lbmRlZChkaXNwYXRjaCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fX2NoYXJ0X18gPSB2aWV3O1xuICAgICAgICAgIHpvb21zdGFydGVkKGRpc3BhdGNoKTtcbiAgICAgICAgICB6b29tZWQoZGlzcGF0Y2gpO1xuICAgICAgICAgIHpvb21lbmRlZChkaXNwYXRjaCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gICAgem9vbS50cmFuc2xhdGUgPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBbIHZpZXcueCwgdmlldy55IF07XG4gICAgICB2aWV3ID0ge1xuICAgICAgICB4OiArX1swXSxcbiAgICAgICAgeTogK19bMV0sXG4gICAgICAgIGs6IHZpZXcua1xuICAgICAgfTtcbiAgICAgIHJlc2NhbGUoKTtcbiAgICAgIHJldHVybiB6b29tO1xuICAgIH07XG4gICAgem9vbS5zY2FsZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHZpZXcuaztcbiAgICAgIHZpZXcgPSB7XG4gICAgICAgIHg6IHZpZXcueCxcbiAgICAgICAgeTogdmlldy55LFxuICAgICAgICBrOiBudWxsXG4gICAgICB9O1xuICAgICAgc2NhbGVUbygrXyk7XG4gICAgICByZXNjYWxlKCk7XG4gICAgICByZXR1cm4gem9vbTtcbiAgICB9O1xuICAgIHpvb20uc2NhbGVFeHRlbnQgPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBzY2FsZUV4dGVudDtcbiAgICAgIHNjYWxlRXh0ZW50ID0gXyA9PSBudWxsID8gZDNfYmVoYXZpb3Jfem9vbUluZmluaXR5IDogWyArX1swXSwgK19bMV0gXTtcbiAgICAgIHJldHVybiB6b29tO1xuICAgIH07XG4gICAgem9vbS5jZW50ZXIgPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBjZW50ZXI7XG4gICAgICBjZW50ZXIgPSBfICYmIFsgK19bMF0sICtfWzFdIF07XG4gICAgICByZXR1cm4gem9vbTtcbiAgICB9O1xuICAgIHpvb20uc2l6ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHNpemU7XG4gICAgICBzaXplID0gXyAmJiBbICtfWzBdLCArX1sxXSBdO1xuICAgICAgcmV0dXJuIHpvb207XG4gICAgfTtcbiAgICB6b29tLmR1cmF0aW9uID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZHVyYXRpb247XG4gICAgICBkdXJhdGlvbiA9ICtfO1xuICAgICAgcmV0dXJuIHpvb207XG4gICAgfTtcbiAgICB6b29tLnggPSBmdW5jdGlvbih6KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB4MTtcbiAgICAgIHgxID0gejtcbiAgICAgIHgwID0gei5jb3B5KCk7XG4gICAgICB2aWV3ID0ge1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwLFxuICAgICAgICBrOiAxXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHpvb207XG4gICAgfTtcbiAgICB6b29tLnkgPSBmdW5jdGlvbih6KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB5MTtcbiAgICAgIHkxID0gejtcbiAgICAgIHkwID0gei5jb3B5KCk7XG4gICAgICB2aWV3ID0ge1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwLFxuICAgICAgICBrOiAxXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHpvb207XG4gICAgfTtcbiAgICBmdW5jdGlvbiBsb2NhdGlvbihwKSB7XG4gICAgICByZXR1cm4gWyAocFswXSAtIHZpZXcueCkgLyB2aWV3LmssIChwWzFdIC0gdmlldy55KSAvIHZpZXcuayBdO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwb2ludChsKSB7XG4gICAgICByZXR1cm4gWyBsWzBdICogdmlldy5rICsgdmlldy54LCBsWzFdICogdmlldy5rICsgdmlldy55IF07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNjYWxlVG8ocykge1xuICAgICAgdmlldy5rID0gTWF0aC5tYXgoc2NhbGVFeHRlbnRbMF0sIE1hdGgubWluKHNjYWxlRXh0ZW50WzFdLCBzKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRyYW5zbGF0ZVRvKHAsIGwpIHtcbiAgICAgIGwgPSBwb2ludChsKTtcbiAgICAgIHZpZXcueCArPSBwWzBdIC0gbFswXTtcbiAgICAgIHZpZXcueSArPSBwWzFdIC0gbFsxXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gem9vbVRvKHRoYXQsIHAsIGwsIGspIHtcbiAgICAgIHRoYXQuX19jaGFydF9fID0ge1xuICAgICAgICB4OiB2aWV3LngsXG4gICAgICAgIHk6IHZpZXcueSxcbiAgICAgICAgazogdmlldy5rXG4gICAgICB9O1xuICAgICAgc2NhbGVUbyhNYXRoLnBvdygyLCBrKSk7XG4gICAgICB0cmFuc2xhdGVUbyhjZW50ZXIwID0gcCwgbCk7XG4gICAgICB0aGF0ID0gZDMuc2VsZWN0KHRoYXQpO1xuICAgICAgaWYgKGR1cmF0aW9uID4gMCkgdGhhdCA9IHRoYXQudHJhbnNpdGlvbigpLmR1cmF0aW9uKGR1cmF0aW9uKTtcbiAgICAgIHRoYXQuY2FsbCh6b29tLmV2ZW50KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVzY2FsZSgpIHtcbiAgICAgIGlmICh4MSkgeDEuZG9tYWluKHgwLnJhbmdlKCkubWFwKGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgcmV0dXJuICh4IC0gdmlldy54KSAvIHZpZXcuaztcbiAgICAgIH0pLm1hcCh4MC5pbnZlcnQpKTtcbiAgICAgIGlmICh5MSkgeTEuZG9tYWluKHkwLnJhbmdlKCkubWFwKGZ1bmN0aW9uKHkpIHtcbiAgICAgICAgcmV0dXJuICh5IC0gdmlldy55KSAvIHZpZXcuaztcbiAgICAgIH0pLm1hcCh5MC5pbnZlcnQpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gem9vbXN0YXJ0ZWQoZGlzcGF0Y2gpIHtcbiAgICAgIGlmICghem9vbWluZysrKSBkaXNwYXRjaCh7XG4gICAgICAgIHR5cGU6IFwiem9vbXN0YXJ0XCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiB6b29tZWQoZGlzcGF0Y2gpIHtcbiAgICAgIHJlc2NhbGUoKTtcbiAgICAgIGRpc3BhdGNoKHtcbiAgICAgICAgdHlwZTogXCJ6b29tXCIsXG4gICAgICAgIHNjYWxlOiB2aWV3LmssXG4gICAgICAgIHRyYW5zbGF0ZTogWyB2aWV3LngsIHZpZXcueSBdXG4gICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gem9vbWVuZGVkKGRpc3BhdGNoKSB7XG4gICAgICBpZiAoIS0tem9vbWluZykgZGlzcGF0Y2goe1xuICAgICAgICB0eXBlOiBcInpvb21lbmRcIlxuICAgICAgfSksIGNlbnRlcjAgPSBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtb3VzZWRvd25lZCgpIHtcbiAgICAgIHZhciB0aGF0ID0gdGhpcywgZGlzcGF0Y2ggPSBldmVudC5vZih0aGF0LCBhcmd1bWVudHMpLCBkcmFnZ2VkID0gMCwgc3ViamVjdCA9IGQzLnNlbGVjdChkM193aW5kb3codGhhdCkpLm9uKG1vdXNlbW92ZSwgbW92ZWQpLm9uKG1vdXNldXAsIGVuZGVkKSwgbG9jYXRpb24wID0gbG9jYXRpb24oZDMubW91c2UodGhhdCkpLCBkcmFnUmVzdG9yZSA9IGQzX2V2ZW50X2RyYWdTdXBwcmVzcyh0aGF0KTtcbiAgICAgIGQzX3NlbGVjdGlvbl9pbnRlcnJ1cHQuY2FsbCh0aGF0KTtcbiAgICAgIHpvb21zdGFydGVkKGRpc3BhdGNoKTtcbiAgICAgIGZ1bmN0aW9uIG1vdmVkKCkge1xuICAgICAgICBkcmFnZ2VkID0gMTtcbiAgICAgICAgdHJhbnNsYXRlVG8oZDMubW91c2UodGhhdCksIGxvY2F0aW9uMCk7XG4gICAgICAgIHpvb21lZChkaXNwYXRjaCk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBlbmRlZCgpIHtcbiAgICAgICAgc3ViamVjdC5vbihtb3VzZW1vdmUsIG51bGwpLm9uKG1vdXNldXAsIG51bGwpO1xuICAgICAgICBkcmFnUmVzdG9yZShkcmFnZ2VkKTtcbiAgICAgICAgem9vbWVuZGVkKGRpc3BhdGNoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdG91Y2hzdGFydGVkKCkge1xuICAgICAgdmFyIHRoYXQgPSB0aGlzLCBkaXNwYXRjaCA9IGV2ZW50Lm9mKHRoYXQsIGFyZ3VtZW50cyksIGxvY2F0aW9uczAgPSB7fSwgZGlzdGFuY2UwID0gMCwgc2NhbGUwLCB6b29tTmFtZSA9IFwiLnpvb20tXCIgKyBkMy5ldmVudC5jaGFuZ2VkVG91Y2hlc1swXS5pZGVudGlmaWVyLCB0b3VjaG1vdmUgPSBcInRvdWNobW92ZVwiICsgem9vbU5hbWUsIHRvdWNoZW5kID0gXCJ0b3VjaGVuZFwiICsgem9vbU5hbWUsIHRhcmdldHMgPSBbXSwgc3ViamVjdCA9IGQzLnNlbGVjdCh0aGF0KSwgZHJhZ1Jlc3RvcmUgPSBkM19ldmVudF9kcmFnU3VwcHJlc3ModGhhdCk7XG4gICAgICBzdGFydGVkKCk7XG4gICAgICB6b29tc3RhcnRlZChkaXNwYXRjaCk7XG4gICAgICBzdWJqZWN0Lm9uKG1vdXNlZG93biwgbnVsbCkub24odG91Y2hzdGFydCwgc3RhcnRlZCk7XG4gICAgICBmdW5jdGlvbiByZWxvY2F0ZSgpIHtcbiAgICAgICAgdmFyIHRvdWNoZXMgPSBkMy50b3VjaGVzKHRoYXQpO1xuICAgICAgICBzY2FsZTAgPSB2aWV3Lms7XG4gICAgICAgIHRvdWNoZXMuZm9yRWFjaChmdW5jdGlvbih0KSB7XG4gICAgICAgICAgaWYgKHQuaWRlbnRpZmllciBpbiBsb2NhdGlvbnMwKSBsb2NhdGlvbnMwW3QuaWRlbnRpZmllcl0gPSBsb2NhdGlvbih0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0b3VjaGVzO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gc3RhcnRlZCgpIHtcbiAgICAgICAgdmFyIHRhcmdldCA9IGQzLmV2ZW50LnRhcmdldDtcbiAgICAgICAgZDMuc2VsZWN0KHRhcmdldCkub24odG91Y2htb3ZlLCBtb3ZlZCkub24odG91Y2hlbmQsIGVuZGVkKTtcbiAgICAgICAgdGFyZ2V0cy5wdXNoKHRhcmdldCk7XG4gICAgICAgIHZhciBjaGFuZ2VkID0gZDMuZXZlbnQuY2hhbmdlZFRvdWNoZXM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gY2hhbmdlZC5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICBsb2NhdGlvbnMwW2NoYW5nZWRbaV0uaWRlbnRpZmllcl0gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0b3VjaGVzID0gcmVsb2NhdGUoKSwgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgaWYgKHRvdWNoZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgaWYgKG5vdyAtIHRvdWNodGltZSA8IDUwMCkge1xuICAgICAgICAgICAgdmFyIHAgPSB0b3VjaGVzWzBdO1xuICAgICAgICAgICAgem9vbVRvKHRoYXQsIHAsIGxvY2F0aW9uczBbcC5pZGVudGlmaWVyXSwgTWF0aC5mbG9vcihNYXRoLmxvZyh2aWV3LmspIC8gTWF0aC5MTjIpICsgMSk7XG4gICAgICAgICAgICBkM19ldmVudFByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRvdWNodGltZSA9IG5vdztcbiAgICAgICAgfSBlbHNlIGlmICh0b3VjaGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICB2YXIgcCA9IHRvdWNoZXNbMF0sIHEgPSB0b3VjaGVzWzFdLCBkeCA9IHBbMF0gLSBxWzBdLCBkeSA9IHBbMV0gLSBxWzFdO1xuICAgICAgICAgIGRpc3RhbmNlMCA9IGR4ICogZHggKyBkeSAqIGR5O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBtb3ZlZCgpIHtcbiAgICAgICAgdmFyIHRvdWNoZXMgPSBkMy50b3VjaGVzKHRoYXQpLCBwMCwgbDAsIHAxLCBsMTtcbiAgICAgICAgZDNfc2VsZWN0aW9uX2ludGVycnVwdC5jYWxsKHRoYXQpO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IHRvdWNoZXMubGVuZ3RoOyBpIDwgbjsgKytpLCBsMSA9IG51bGwpIHtcbiAgICAgICAgICBwMSA9IHRvdWNoZXNbaV07XG4gICAgICAgICAgaWYgKGwxID0gbG9jYXRpb25zMFtwMS5pZGVudGlmaWVyXSkge1xuICAgICAgICAgICAgaWYgKGwwKSBicmVhaztcbiAgICAgICAgICAgIHAwID0gcDEsIGwwID0gbDE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChsMSkge1xuICAgICAgICAgIHZhciBkaXN0YW5jZTEgPSAoZGlzdGFuY2UxID0gcDFbMF0gLSBwMFswXSkgKiBkaXN0YW5jZTEgKyAoZGlzdGFuY2UxID0gcDFbMV0gLSBwMFsxXSkgKiBkaXN0YW5jZTEsIHNjYWxlMSA9IGRpc3RhbmNlMCAmJiBNYXRoLnNxcnQoZGlzdGFuY2UxIC8gZGlzdGFuY2UwKTtcbiAgICAgICAgICBwMCA9IFsgKHAwWzBdICsgcDFbMF0pIC8gMiwgKHAwWzFdICsgcDFbMV0pIC8gMiBdO1xuICAgICAgICAgIGwwID0gWyAobDBbMF0gKyBsMVswXSkgLyAyLCAobDBbMV0gKyBsMVsxXSkgLyAyIF07XG4gICAgICAgICAgc2NhbGVUbyhzY2FsZTEgKiBzY2FsZTApO1xuICAgICAgICB9XG4gICAgICAgIHRvdWNodGltZSA9IG51bGw7XG4gICAgICAgIHRyYW5zbGF0ZVRvKHAwLCBsMCk7XG4gICAgICAgIHpvb21lZChkaXNwYXRjaCk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBlbmRlZCgpIHtcbiAgICAgICAgaWYgKGQzLmV2ZW50LnRvdWNoZXMubGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIGNoYW5nZWQgPSBkMy5ldmVudC5jaGFuZ2VkVG91Y2hlcztcbiAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IGNoYW5nZWQubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgICBkZWxldGUgbG9jYXRpb25zMFtjaGFuZ2VkW2ldLmlkZW50aWZpZXJdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKHZhciBpZGVudGlmaWVyIGluIGxvY2F0aW9uczApIHtcbiAgICAgICAgICAgIHJldHVybiB2b2lkIHJlbG9jYXRlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGQzLnNlbGVjdEFsbCh0YXJnZXRzKS5vbih6b29tTmFtZSwgbnVsbCk7XG4gICAgICAgIHN1YmplY3Qub24obW91c2Vkb3duLCBtb3VzZWRvd25lZCkub24odG91Y2hzdGFydCwgdG91Y2hzdGFydGVkKTtcbiAgICAgICAgZHJhZ1Jlc3RvcmUoKTtcbiAgICAgICAgem9vbWVuZGVkKGRpc3BhdGNoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gbW91c2V3aGVlbGVkKCkge1xuICAgICAgdmFyIGRpc3BhdGNoID0gZXZlbnQub2YodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIGlmIChtb3VzZXdoZWVsVGltZXIpIGNsZWFyVGltZW91dChtb3VzZXdoZWVsVGltZXIpOyBlbHNlIGQzX3NlbGVjdGlvbl9pbnRlcnJ1cHQuY2FsbCh0aGlzKSwgXG4gICAgICB0cmFuc2xhdGUwID0gbG9jYXRpb24oY2VudGVyMCA9IGNlbnRlciB8fCBkMy5tb3VzZSh0aGlzKSksIHpvb21zdGFydGVkKGRpc3BhdGNoKTtcbiAgICAgIG1vdXNld2hlZWxUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIG1vdXNld2hlZWxUaW1lciA9IG51bGw7XG4gICAgICAgIHpvb21lbmRlZChkaXNwYXRjaCk7XG4gICAgICB9LCA1MCk7XG4gICAgICBkM19ldmVudFByZXZlbnREZWZhdWx0KCk7XG4gICAgICBzY2FsZVRvKE1hdGgucG93KDIsIGQzX2JlaGF2aW9yX3pvb21EZWx0YSgpICogLjAwMikgKiB2aWV3LmspO1xuICAgICAgdHJhbnNsYXRlVG8oY2VudGVyMCwgdHJhbnNsYXRlMCk7XG4gICAgICB6b29tZWQoZGlzcGF0Y2gpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkYmxjbGlja2VkKCkge1xuICAgICAgdmFyIHAgPSBkMy5tb3VzZSh0aGlzKSwgayA9IE1hdGgubG9nKHZpZXcuaykgLyBNYXRoLkxOMjtcbiAgICAgIHpvb21Ubyh0aGlzLCBwLCBsb2NhdGlvbihwKSwgZDMuZXZlbnQuc2hpZnRLZXkgPyBNYXRoLmNlaWwoaykgLSAxIDogTWF0aC5mbG9vcihrKSArIDEpO1xuICAgIH1cbiAgICByZXR1cm4gZDMucmViaW5kKHpvb20sIGV2ZW50LCBcIm9uXCIpO1xuICB9O1xuICB2YXIgZDNfYmVoYXZpb3Jfem9vbUluZmluaXR5ID0gWyAwLCBJbmZpbml0eSBdLCBkM19iZWhhdmlvcl96b29tRGVsdGEsIGQzX2JlaGF2aW9yX3pvb21XaGVlbDtcbiAgZDMuY29sb3IgPSBkM19jb2xvcjtcbiAgZnVuY3Rpb24gZDNfY29sb3IoKSB7fVxuICBkM19jb2xvci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5yZ2IoKSArIFwiXCI7XG4gIH07XG4gIGQzLmhzbCA9IGQzX2hzbDtcbiAgZnVuY3Rpb24gZDNfaHNsKGgsIHMsIGwpIHtcbiAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIGQzX2hzbCA/IHZvaWQgKHRoaXMuaCA9ICtoLCB0aGlzLnMgPSArcywgdGhpcy5sID0gK2wpIDogYXJndW1lbnRzLmxlbmd0aCA8IDIgPyBoIGluc3RhbmNlb2YgZDNfaHNsID8gbmV3IGQzX2hzbChoLmgsIGgucywgaC5sKSA6IGQzX3JnYl9wYXJzZShcIlwiICsgaCwgZDNfcmdiX2hzbCwgZDNfaHNsKSA6IG5ldyBkM19oc2woaCwgcywgbCk7XG4gIH1cbiAgdmFyIGQzX2hzbFByb3RvdHlwZSA9IGQzX2hzbC5wcm90b3R5cGUgPSBuZXcgZDNfY29sb3IoKTtcbiAgZDNfaHNsUHJvdG90eXBlLmJyaWdodGVyID0gZnVuY3Rpb24oaykge1xuICAgIGsgPSBNYXRoLnBvdyguNywgYXJndW1lbnRzLmxlbmd0aCA/IGsgOiAxKTtcbiAgICByZXR1cm4gbmV3IGQzX2hzbCh0aGlzLmgsIHRoaXMucywgdGhpcy5sIC8gayk7XG4gIH07XG4gIGQzX2hzbFByb3RvdHlwZS5kYXJrZXIgPSBmdW5jdGlvbihrKSB7XG4gICAgayA9IE1hdGgucG93KC43LCBhcmd1bWVudHMubGVuZ3RoID8gayA6IDEpO1xuICAgIHJldHVybiBuZXcgZDNfaHNsKHRoaXMuaCwgdGhpcy5zLCBrICogdGhpcy5sKTtcbiAgfTtcbiAgZDNfaHNsUHJvdG90eXBlLnJnYiA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkM19oc2xfcmdiKHRoaXMuaCwgdGhpcy5zLCB0aGlzLmwpO1xuICB9O1xuICBmdW5jdGlvbiBkM19oc2xfcmdiKGgsIHMsIGwpIHtcbiAgICB2YXIgbTEsIG0yO1xuICAgIGggPSBpc05hTihoKSA/IDAgOiAoaCAlPSAzNjApIDwgMCA/IGggKyAzNjAgOiBoO1xuICAgIHMgPSBpc05hTihzKSA/IDAgOiBzIDwgMCA/IDAgOiBzID4gMSA/IDEgOiBzO1xuICAgIGwgPSBsIDwgMCA/IDAgOiBsID4gMSA/IDEgOiBsO1xuICAgIG0yID0gbCA8PSAuNSA/IGwgKiAoMSArIHMpIDogbCArIHMgLSBsICogcztcbiAgICBtMSA9IDIgKiBsIC0gbTI7XG4gICAgZnVuY3Rpb24gdihoKSB7XG4gICAgICBpZiAoaCA+IDM2MCkgaCAtPSAzNjA7IGVsc2UgaWYgKGggPCAwKSBoICs9IDM2MDtcbiAgICAgIGlmIChoIDwgNjApIHJldHVybiBtMSArIChtMiAtIG0xKSAqIGggLyA2MDtcbiAgICAgIGlmIChoIDwgMTgwKSByZXR1cm4gbTI7XG4gICAgICBpZiAoaCA8IDI0MCkgcmV0dXJuIG0xICsgKG0yIC0gbTEpICogKDI0MCAtIGgpIC8gNjA7XG4gICAgICByZXR1cm4gbTE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHZ2KGgpIHtcbiAgICAgIHJldHVybiBNYXRoLnJvdW5kKHYoaCkgKiAyNTUpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IGQzX3JnYih2dihoICsgMTIwKSwgdnYoaCksIHZ2KGggLSAxMjApKTtcbiAgfVxuICBkMy5oY2wgPSBkM19oY2w7XG4gIGZ1bmN0aW9uIGQzX2hjbChoLCBjLCBsKSB7XG4gICAgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBkM19oY2wgPyB2b2lkICh0aGlzLmggPSAraCwgdGhpcy5jID0gK2MsIHRoaXMubCA9ICtsKSA6IGFyZ3VtZW50cy5sZW5ndGggPCAyID8gaCBpbnN0YW5jZW9mIGQzX2hjbCA/IG5ldyBkM19oY2woaC5oLCBoLmMsIGgubCkgOiBoIGluc3RhbmNlb2YgZDNfbGFiID8gZDNfbGFiX2hjbChoLmwsIGguYSwgaC5iKSA6IGQzX2xhYl9oY2woKGggPSBkM19yZ2JfbGFiKChoID0gZDMucmdiKGgpKS5yLCBoLmcsIGguYikpLmwsIGguYSwgaC5iKSA6IG5ldyBkM19oY2woaCwgYywgbCk7XG4gIH1cbiAgdmFyIGQzX2hjbFByb3RvdHlwZSA9IGQzX2hjbC5wcm90b3R5cGUgPSBuZXcgZDNfY29sb3IoKTtcbiAgZDNfaGNsUHJvdG90eXBlLmJyaWdodGVyID0gZnVuY3Rpb24oaykge1xuICAgIHJldHVybiBuZXcgZDNfaGNsKHRoaXMuaCwgdGhpcy5jLCBNYXRoLm1pbigxMDAsIHRoaXMubCArIGQzX2xhYl9LICogKGFyZ3VtZW50cy5sZW5ndGggPyBrIDogMSkpKTtcbiAgfTtcbiAgZDNfaGNsUHJvdG90eXBlLmRhcmtlciA9IGZ1bmN0aW9uKGspIHtcbiAgICByZXR1cm4gbmV3IGQzX2hjbCh0aGlzLmgsIHRoaXMuYywgTWF0aC5tYXgoMCwgdGhpcy5sIC0gZDNfbGFiX0sgKiAoYXJndW1lbnRzLmxlbmd0aCA/IGsgOiAxKSkpO1xuICB9O1xuICBkM19oY2xQcm90b3R5cGUucmdiID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGQzX2hjbF9sYWIodGhpcy5oLCB0aGlzLmMsIHRoaXMubCkucmdiKCk7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX2hjbF9sYWIoaCwgYywgbCkge1xuICAgIGlmIChpc05hTihoKSkgaCA9IDA7XG4gICAgaWYgKGlzTmFOKGMpKSBjID0gMDtcbiAgICByZXR1cm4gbmV3IGQzX2xhYihsLCBNYXRoLmNvcyhoICo9IGQzX3JhZGlhbnMpICogYywgTWF0aC5zaW4oaCkgKiBjKTtcbiAgfVxuICBkMy5sYWIgPSBkM19sYWI7XG4gIGZ1bmN0aW9uIGQzX2xhYihsLCBhLCBiKSB7XG4gICAgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBkM19sYWIgPyB2b2lkICh0aGlzLmwgPSArbCwgdGhpcy5hID0gK2EsIHRoaXMuYiA9ICtiKSA6IGFyZ3VtZW50cy5sZW5ndGggPCAyID8gbCBpbnN0YW5jZW9mIGQzX2xhYiA/IG5ldyBkM19sYWIobC5sLCBsLmEsIGwuYikgOiBsIGluc3RhbmNlb2YgZDNfaGNsID8gZDNfaGNsX2xhYihsLmgsIGwuYywgbC5sKSA6IGQzX3JnYl9sYWIoKGwgPSBkM19yZ2IobCkpLnIsIGwuZywgbC5iKSA6IG5ldyBkM19sYWIobCwgYSwgYik7XG4gIH1cbiAgdmFyIGQzX2xhYl9LID0gMTg7XG4gIHZhciBkM19sYWJfWCA9IC45NTA0NywgZDNfbGFiX1kgPSAxLCBkM19sYWJfWiA9IDEuMDg4ODM7XG4gIHZhciBkM19sYWJQcm90b3R5cGUgPSBkM19sYWIucHJvdG90eXBlID0gbmV3IGQzX2NvbG9yKCk7XG4gIGQzX2xhYlByb3RvdHlwZS5icmlnaHRlciA9IGZ1bmN0aW9uKGspIHtcbiAgICByZXR1cm4gbmV3IGQzX2xhYihNYXRoLm1pbigxMDAsIHRoaXMubCArIGQzX2xhYl9LICogKGFyZ3VtZW50cy5sZW5ndGggPyBrIDogMSkpLCB0aGlzLmEsIHRoaXMuYik7XG4gIH07XG4gIGQzX2xhYlByb3RvdHlwZS5kYXJrZXIgPSBmdW5jdGlvbihrKSB7XG4gICAgcmV0dXJuIG5ldyBkM19sYWIoTWF0aC5tYXgoMCwgdGhpcy5sIC0gZDNfbGFiX0sgKiAoYXJndW1lbnRzLmxlbmd0aCA/IGsgOiAxKSksIHRoaXMuYSwgdGhpcy5iKTtcbiAgfTtcbiAgZDNfbGFiUHJvdG90eXBlLnJnYiA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkM19sYWJfcmdiKHRoaXMubCwgdGhpcy5hLCB0aGlzLmIpO1xuICB9O1xuICBmdW5jdGlvbiBkM19sYWJfcmdiKGwsIGEsIGIpIHtcbiAgICB2YXIgeSA9IChsICsgMTYpIC8gMTE2LCB4ID0geSArIGEgLyA1MDAsIHogPSB5IC0gYiAvIDIwMDtcbiAgICB4ID0gZDNfbGFiX3h5eih4KSAqIGQzX2xhYl9YO1xuICAgIHkgPSBkM19sYWJfeHl6KHkpICogZDNfbGFiX1k7XG4gICAgeiA9IGQzX2xhYl94eXooeikgKiBkM19sYWJfWjtcbiAgICByZXR1cm4gbmV3IGQzX3JnYihkM194eXpfcmdiKDMuMjQwNDU0MiAqIHggLSAxLjUzNzEzODUgKiB5IC0gLjQ5ODUzMTQgKiB6KSwgZDNfeHl6X3JnYigtLjk2OTI2NiAqIHggKyAxLjg3NjAxMDggKiB5ICsgLjA0MTU1NiAqIHopLCBkM194eXpfcmdiKC4wNTU2NDM0ICogeCAtIC4yMDQwMjU5ICogeSArIDEuMDU3MjI1MiAqIHopKTtcbiAgfVxuICBmdW5jdGlvbiBkM19sYWJfaGNsKGwsIGEsIGIpIHtcbiAgICByZXR1cm4gbCA+IDAgPyBuZXcgZDNfaGNsKE1hdGguYXRhbjIoYiwgYSkgKiBkM19kZWdyZWVzLCBNYXRoLnNxcnQoYSAqIGEgKyBiICogYiksIGwpIDogbmV3IGQzX2hjbChOYU4sIE5hTiwgbCk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfbGFiX3h5eih4KSB7XG4gICAgcmV0dXJuIHggPiAuMjA2ODkzMDM0ID8geCAqIHggKiB4IDogKHggLSA0IC8gMjkpIC8gNy43ODcwMzc7XG4gIH1cbiAgZnVuY3Rpb24gZDNfeHl6X2xhYih4KSB7XG4gICAgcmV0dXJuIHggPiAuMDA4ODU2ID8gTWF0aC5wb3coeCwgMSAvIDMpIDogNy43ODcwMzcgKiB4ICsgNCAvIDI5O1xuICB9XG4gIGZ1bmN0aW9uIGQzX3h5el9yZ2Iocikge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKDI1NSAqIChyIDw9IC4wMDMwNCA/IDEyLjkyICogciA6IDEuMDU1ICogTWF0aC5wb3cociwgMSAvIDIuNCkgLSAuMDU1KSk7XG4gIH1cbiAgZDMucmdiID0gZDNfcmdiO1xuICBmdW5jdGlvbiBkM19yZ2IociwgZywgYikge1xuICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2YgZDNfcmdiID8gdm9pZCAodGhpcy5yID0gfn5yLCB0aGlzLmcgPSB+fmcsIHRoaXMuYiA9IH5+YikgOiBhcmd1bWVudHMubGVuZ3RoIDwgMiA/IHIgaW5zdGFuY2VvZiBkM19yZ2IgPyBuZXcgZDNfcmdiKHIuciwgci5nLCByLmIpIDogZDNfcmdiX3BhcnNlKFwiXCIgKyByLCBkM19yZ2IsIGQzX2hzbF9yZ2IpIDogbmV3IGQzX3JnYihyLCBnLCBiKTtcbiAgfVxuICBmdW5jdGlvbiBkM19yZ2JOdW1iZXIodmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IGQzX3JnYih2YWx1ZSA+PiAxNiwgdmFsdWUgPj4gOCAmIDI1NSwgdmFsdWUgJiAyNTUpO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3JnYlN0cmluZyh2YWx1ZSkge1xuICAgIHJldHVybiBkM19yZ2JOdW1iZXIodmFsdWUpICsgXCJcIjtcbiAgfVxuICB2YXIgZDNfcmdiUHJvdG90eXBlID0gZDNfcmdiLnByb3RvdHlwZSA9IG5ldyBkM19jb2xvcigpO1xuICBkM19yZ2JQcm90b3R5cGUuYnJpZ2h0ZXIgPSBmdW5jdGlvbihrKSB7XG4gICAgayA9IE1hdGgucG93KC43LCBhcmd1bWVudHMubGVuZ3RoID8gayA6IDEpO1xuICAgIHZhciByID0gdGhpcy5yLCBnID0gdGhpcy5nLCBiID0gdGhpcy5iLCBpID0gMzA7XG4gICAgaWYgKCFyICYmICFnICYmICFiKSByZXR1cm4gbmV3IGQzX3JnYihpLCBpLCBpKTtcbiAgICBpZiAociAmJiByIDwgaSkgciA9IGk7XG4gICAgaWYgKGcgJiYgZyA8IGkpIGcgPSBpO1xuICAgIGlmIChiICYmIGIgPCBpKSBiID0gaTtcbiAgICByZXR1cm4gbmV3IGQzX3JnYihNYXRoLm1pbigyNTUsIHIgLyBrKSwgTWF0aC5taW4oMjU1LCBnIC8gayksIE1hdGgubWluKDI1NSwgYiAvIGspKTtcbiAgfTtcbiAgZDNfcmdiUHJvdG90eXBlLmRhcmtlciA9IGZ1bmN0aW9uKGspIHtcbiAgICBrID0gTWF0aC5wb3coLjcsIGFyZ3VtZW50cy5sZW5ndGggPyBrIDogMSk7XG4gICAgcmV0dXJuIG5ldyBkM19yZ2IoayAqIHRoaXMuciwgayAqIHRoaXMuZywgayAqIHRoaXMuYik7XG4gIH07XG4gIGQzX3JnYlByb3RvdHlwZS5oc2wgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZDNfcmdiX2hzbCh0aGlzLnIsIHRoaXMuZywgdGhpcy5iKTtcbiAgfTtcbiAgZDNfcmdiUHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFwiI1wiICsgZDNfcmdiX2hleCh0aGlzLnIpICsgZDNfcmdiX2hleCh0aGlzLmcpICsgZDNfcmdiX2hleCh0aGlzLmIpO1xuICB9O1xuICBmdW5jdGlvbiBkM19yZ2JfaGV4KHYpIHtcbiAgICByZXR1cm4gdiA8IDE2ID8gXCIwXCIgKyBNYXRoLm1heCgwLCB2KS50b1N0cmluZygxNikgOiBNYXRoLm1pbigyNTUsIHYpLnRvU3RyaW5nKDE2KTtcbiAgfVxuICBmdW5jdGlvbiBkM19yZ2JfcGFyc2UoZm9ybWF0LCByZ2IsIGhzbCkge1xuICAgIHZhciByID0gMCwgZyA9IDAsIGIgPSAwLCBtMSwgbTIsIGNvbG9yO1xuICAgIG0xID0gLyhbYS16XSspXFwoKC4qKVxcKS8uZXhlYyhmb3JtYXQgPSBmb3JtYXQudG9Mb3dlckNhc2UoKSk7XG4gICAgaWYgKG0xKSB7XG4gICAgICBtMiA9IG0xWzJdLnNwbGl0KFwiLFwiKTtcbiAgICAgIHN3aXRjaCAobTFbMV0pIHtcbiAgICAgICBjYXNlIFwiaHNsXCI6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gaHNsKHBhcnNlRmxvYXQobTJbMF0pLCBwYXJzZUZsb2F0KG0yWzFdKSAvIDEwMCwgcGFyc2VGbG9hdChtMlsyXSkgLyAxMDApO1xuICAgICAgICB9XG5cbiAgICAgICBjYXNlIFwicmdiXCI6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gcmdiKGQzX3JnYl9wYXJzZU51bWJlcihtMlswXSksIGQzX3JnYl9wYXJzZU51bWJlcihtMlsxXSksIGQzX3JnYl9wYXJzZU51bWJlcihtMlsyXSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjb2xvciA9IGQzX3JnYl9uYW1lcy5nZXQoZm9ybWF0KSkge1xuICAgICAgcmV0dXJuIHJnYihjb2xvci5yLCBjb2xvci5nLCBjb2xvci5iKTtcbiAgICB9XG4gICAgaWYgKGZvcm1hdCAhPSBudWxsICYmIGZvcm1hdC5jaGFyQXQoMCkgPT09IFwiI1wiICYmICFpc05hTihjb2xvciA9IHBhcnNlSW50KGZvcm1hdC5zbGljZSgxKSwgMTYpKSkge1xuICAgICAgaWYgKGZvcm1hdC5sZW5ndGggPT09IDQpIHtcbiAgICAgICAgciA9IChjb2xvciAmIDM4NDApID4+IDQ7XG4gICAgICAgIHIgPSByID4+IDQgfCByO1xuICAgICAgICBnID0gY29sb3IgJiAyNDA7XG4gICAgICAgIGcgPSBnID4+IDQgfCBnO1xuICAgICAgICBiID0gY29sb3IgJiAxNTtcbiAgICAgICAgYiA9IGIgPDwgNCB8IGI7XG4gICAgICB9IGVsc2UgaWYgKGZvcm1hdC5sZW5ndGggPT09IDcpIHtcbiAgICAgICAgciA9IChjb2xvciAmIDE2NzExNjgwKSA+PiAxNjtcbiAgICAgICAgZyA9IChjb2xvciAmIDY1MjgwKSA+PiA4O1xuICAgICAgICBiID0gY29sb3IgJiAyNTU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZ2IociwgZywgYik7XG4gIH1cbiAgZnVuY3Rpb24gZDNfcmdiX2hzbChyLCBnLCBiKSB7XG4gICAgdmFyIG1pbiA9IE1hdGgubWluKHIgLz0gMjU1LCBnIC89IDI1NSwgYiAvPSAyNTUpLCBtYXggPSBNYXRoLm1heChyLCBnLCBiKSwgZCA9IG1heCAtIG1pbiwgaCwgcywgbCA9IChtYXggKyBtaW4pIC8gMjtcbiAgICBpZiAoZCkge1xuICAgICAgcyA9IGwgPCAuNSA/IGQgLyAobWF4ICsgbWluKSA6IGQgLyAoMiAtIG1heCAtIG1pbik7XG4gICAgICBpZiAociA9PSBtYXgpIGggPSAoZyAtIGIpIC8gZCArIChnIDwgYiA/IDYgOiAwKTsgZWxzZSBpZiAoZyA9PSBtYXgpIGggPSAoYiAtIHIpIC8gZCArIDI7IGVsc2UgaCA9IChyIC0gZykgLyBkICsgNDtcbiAgICAgIGggKj0gNjA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGggPSBOYU47XG4gICAgICBzID0gbCA+IDAgJiYgbCA8IDEgPyAwIDogaDtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBkM19oc2woaCwgcywgbCk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfcmdiX2xhYihyLCBnLCBiKSB7XG4gICAgciA9IGQzX3JnYl94eXoocik7XG4gICAgZyA9IGQzX3JnYl94eXooZyk7XG4gICAgYiA9IGQzX3JnYl94eXooYik7XG4gICAgdmFyIHggPSBkM194eXpfbGFiKCguNDEyNDU2NCAqIHIgKyAuMzU3NTc2MSAqIGcgKyAuMTgwNDM3NSAqIGIpIC8gZDNfbGFiX1gpLCB5ID0gZDNfeHl6X2xhYigoLjIxMjY3MjkgKiByICsgLjcxNTE1MjIgKiBnICsgLjA3MjE3NSAqIGIpIC8gZDNfbGFiX1kpLCB6ID0gZDNfeHl6X2xhYigoLjAxOTMzMzkgKiByICsgLjExOTE5MiAqIGcgKyAuOTUwMzA0MSAqIGIpIC8gZDNfbGFiX1opO1xuICAgIHJldHVybiBkM19sYWIoMTE2ICogeSAtIDE2LCA1MDAgKiAoeCAtIHkpLCAyMDAgKiAoeSAtIHopKTtcbiAgfVxuICBmdW5jdGlvbiBkM19yZ2JfeHl6KHIpIHtcbiAgICByZXR1cm4gKHIgLz0gMjU1KSA8PSAuMDQwNDUgPyByIC8gMTIuOTIgOiBNYXRoLnBvdygociArIC4wNTUpIC8gMS4wNTUsIDIuNCk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfcmdiX3BhcnNlTnVtYmVyKGMpIHtcbiAgICB2YXIgZiA9IHBhcnNlRmxvYXQoYyk7XG4gICAgcmV0dXJuIGMuY2hhckF0KGMubGVuZ3RoIC0gMSkgPT09IFwiJVwiID8gTWF0aC5yb3VuZChmICogMi41NSkgOiBmO1xuICB9XG4gIHZhciBkM19yZ2JfbmFtZXMgPSBkMy5tYXAoe1xuICAgIGFsaWNlYmx1ZTogMTU3OTIzODMsXG4gICAgYW50aXF1ZXdoaXRlOiAxNjQ0NDM3NSxcbiAgICBhcXVhOiA2NTUzNSxcbiAgICBhcXVhbWFyaW5lOiA4Mzg4NTY0LFxuICAgIGF6dXJlOiAxNTc5NDE3NSxcbiAgICBiZWlnZTogMTYxMTkyNjAsXG4gICAgYmlzcXVlOiAxNjc3MDI0NCxcbiAgICBibGFjazogMCxcbiAgICBibGFuY2hlZGFsbW9uZDogMTY3NzIwNDUsXG4gICAgYmx1ZTogMjU1LFxuICAgIGJsdWV2aW9sZXQ6IDkwNTUyMDIsXG4gICAgYnJvd246IDEwODI0MjM0LFxuICAgIGJ1cmx5d29vZDogMTQ1OTYyMzEsXG4gICAgY2FkZXRibHVlOiA2MjY2NTI4LFxuICAgIGNoYXJ0cmV1c2U6IDgzODgzNTIsXG4gICAgY2hvY29sYXRlOiAxMzc4OTQ3MCxcbiAgICBjb3JhbDogMTY3NDQyNzIsXG4gICAgY29ybmZsb3dlcmJsdWU6IDY1OTE5ODEsXG4gICAgY29ybnNpbGs6IDE2Nzc1Mzg4LFxuICAgIGNyaW1zb246IDE0NDIzMTAwLFxuICAgIGN5YW46IDY1NTM1LFxuICAgIGRhcmtibHVlOiAxMzksXG4gICAgZGFya2N5YW46IDM1NzIzLFxuICAgIGRhcmtnb2xkZW5yb2Q6IDEyMDkyOTM5LFxuICAgIGRhcmtncmF5OiAxMTExOTAxNyxcbiAgICBkYXJrZ3JlZW46IDI1NjAwLFxuICAgIGRhcmtncmV5OiAxMTExOTAxNyxcbiAgICBkYXJra2hha2k6IDEyNDMzMjU5LFxuICAgIGRhcmttYWdlbnRhOiA5MTA5NjQzLFxuICAgIGRhcmtvbGl2ZWdyZWVuOiA1NTk3OTk5LFxuICAgIGRhcmtvcmFuZ2U6IDE2NzQ3NTIwLFxuICAgIGRhcmtvcmNoaWQ6IDEwMDQwMDEyLFxuICAgIGRhcmtyZWQ6IDkxMDk1MDQsXG4gICAgZGFya3NhbG1vbjogMTUzMDg0MTAsXG4gICAgZGFya3NlYWdyZWVuOiA5NDE5OTE5LFxuICAgIGRhcmtzbGF0ZWJsdWU6IDQ3MzQzNDcsXG4gICAgZGFya3NsYXRlZ3JheTogMzEwMDQ5NSxcbiAgICBkYXJrc2xhdGVncmV5OiAzMTAwNDk1LFxuICAgIGRhcmt0dXJxdW9pc2U6IDUyOTQ1LFxuICAgIGRhcmt2aW9sZXQ6IDk2OTk1MzksXG4gICAgZGVlcHBpbms6IDE2NzE2OTQ3LFxuICAgIGRlZXBza3libHVlOiA0OTE1MSxcbiAgICBkaW1ncmF5OiA2OTA4MjY1LFxuICAgIGRpbWdyZXk6IDY5MDgyNjUsXG4gICAgZG9kZ2VyYmx1ZTogMjAwMzE5OSxcbiAgICBmaXJlYnJpY2s6IDExNjc0MTQ2LFxuICAgIGZsb3JhbHdoaXRlOiAxNjc3NTkyMCxcbiAgICBmb3Jlc3RncmVlbjogMjI2Mzg0MixcbiAgICBmdWNoc2lhOiAxNjcxMTkzNSxcbiAgICBnYWluc2Jvcm86IDE0NDc0NDYwLFxuICAgIGdob3N0d2hpdGU6IDE2MzE2NjcxLFxuICAgIGdvbGQ6IDE2NzY2NzIwLFxuICAgIGdvbGRlbnJvZDogMTQzMjkxMjAsXG4gICAgZ3JheTogODQyMTUwNCxcbiAgICBncmVlbjogMzI3NjgsXG4gICAgZ3JlZW55ZWxsb3c6IDExNDAzMDU1LFxuICAgIGdyZXk6IDg0MjE1MDQsXG4gICAgaG9uZXlkZXc6IDE1Nzk0MTYwLFxuICAgIGhvdHBpbms6IDE2NzM4NzQwLFxuICAgIGluZGlhbnJlZDogMTM0NTg1MjQsXG4gICAgaW5kaWdvOiA0OTE1MzMwLFxuICAgIGl2b3J5OiAxNjc3NzIwMCxcbiAgICBraGFraTogMTU3ODc2NjAsXG4gICAgbGF2ZW5kZXI6IDE1MTMyNDEwLFxuICAgIGxhdmVuZGVyYmx1c2g6IDE2NzczMzY1LFxuICAgIGxhd25ncmVlbjogODE5MDk3NixcbiAgICBsZW1vbmNoaWZmb246IDE2Nzc1ODg1LFxuICAgIGxpZ2h0Ymx1ZTogMTEzOTMyNTQsXG4gICAgbGlnaHRjb3JhbDogMTU3NjE1MzYsXG4gICAgbGlnaHRjeWFuOiAxNDc0NTU5OSxcbiAgICBsaWdodGdvbGRlbnJvZHllbGxvdzogMTY0NDgyMTAsXG4gICAgbGlnaHRncmF5OiAxMzg4MjMyMyxcbiAgICBsaWdodGdyZWVuOiA5NDk4MjU2LFxuICAgIGxpZ2h0Z3JleTogMTM4ODIzMjMsXG4gICAgbGlnaHRwaW5rOiAxNjc1ODQ2NSxcbiAgICBsaWdodHNhbG1vbjogMTY3NTI3NjIsXG4gICAgbGlnaHRzZWFncmVlbjogMjE0Mjg5MCxcbiAgICBsaWdodHNreWJsdWU6IDg5MDAzNDYsXG4gICAgbGlnaHRzbGF0ZWdyYXk6IDc4MzM3NTMsXG4gICAgbGlnaHRzbGF0ZWdyZXk6IDc4MzM3NTMsXG4gICAgbGlnaHRzdGVlbGJsdWU6IDExNTg0NzM0LFxuICAgIGxpZ2h0eWVsbG93OiAxNjc3NzE4NCxcbiAgICBsaW1lOiA2NTI4MCxcbiAgICBsaW1lZ3JlZW46IDMzMjkzMzAsXG4gICAgbGluZW46IDE2NDQ1NjcwLFxuICAgIG1hZ2VudGE6IDE2NzExOTM1LFxuICAgIG1hcm9vbjogODM4ODYwOCxcbiAgICBtZWRpdW1hcXVhbWFyaW5lOiA2NzM3MzIyLFxuICAgIG1lZGl1bWJsdWU6IDIwNSxcbiAgICBtZWRpdW1vcmNoaWQ6IDEyMjExNjY3LFxuICAgIG1lZGl1bXB1cnBsZTogOTY2MjY4MyxcbiAgICBtZWRpdW1zZWFncmVlbjogMzk3ODA5NyxcbiAgICBtZWRpdW1zbGF0ZWJsdWU6IDgwODc3OTAsXG4gICAgbWVkaXVtc3ByaW5nZ3JlZW46IDY0MTU0LFxuICAgIG1lZGl1bXR1cnF1b2lzZTogNDc3MjMwMCxcbiAgICBtZWRpdW12aW9sZXRyZWQ6IDEzMDQ3MTczLFxuICAgIG1pZG5pZ2h0Ymx1ZTogMTY0NDkxMixcbiAgICBtaW50Y3JlYW06IDE2MTIxODUwLFxuICAgIG1pc3R5cm9zZTogMTY3NzAyNzMsXG4gICAgbW9jY2FzaW46IDE2NzcwMjI5LFxuICAgIG5hdmFqb3doaXRlOiAxNjc2ODY4NSxcbiAgICBuYXZ5OiAxMjgsXG4gICAgb2xkbGFjZTogMTY2NDM1NTgsXG4gICAgb2xpdmU6IDg0MjEzNzYsXG4gICAgb2xpdmVkcmFiOiA3MDQ4NzM5LFxuICAgIG9yYW5nZTogMTY3NTM5MjAsXG4gICAgb3JhbmdlcmVkOiAxNjcyOTM0NCxcbiAgICBvcmNoaWQ6IDE0MzE1NzM0LFxuICAgIHBhbGVnb2xkZW5yb2Q6IDE1NjU3MTMwLFxuICAgIHBhbGVncmVlbjogMTAwMjU4ODAsXG4gICAgcGFsZXR1cnF1b2lzZTogMTE1Mjk5NjYsXG4gICAgcGFsZXZpb2xldHJlZDogMTQzODEyMDMsXG4gICAgcGFwYXlhd2hpcDogMTY3NzMwNzcsXG4gICAgcGVhY2hwdWZmOiAxNjc2NzY3MyxcbiAgICBwZXJ1OiAxMzQ2ODk5MSxcbiAgICBwaW5rOiAxNjc2MTAzNSxcbiAgICBwbHVtOiAxNDUyNDYzNyxcbiAgICBwb3dkZXJibHVlOiAxMTU5MTkxMCxcbiAgICBwdXJwbGU6IDgzODg3MzYsXG4gICAgcmViZWNjYXB1cnBsZTogNjY5Nzg4MSxcbiAgICByZWQ6IDE2NzExNjgwLFxuICAgIHJvc3licm93bjogMTIzNTc1MTksXG4gICAgcm95YWxibHVlOiA0Mjg2OTQ1LFxuICAgIHNhZGRsZWJyb3duOiA5MTI3MTg3LFxuICAgIHNhbG1vbjogMTY0MTY4ODIsXG4gICAgc2FuZHlicm93bjogMTYwMzI4NjQsXG4gICAgc2VhZ3JlZW46IDMwNTAzMjcsXG4gICAgc2Vhc2hlbGw6IDE2Nzc0NjM4LFxuICAgIHNpZW5uYTogMTA1MDY3OTcsXG4gICAgc2lsdmVyOiAxMjYzMjI1NixcbiAgICBza3libHVlOiA4OTAwMzMxLFxuICAgIHNsYXRlYmx1ZTogNjk3MDA2MSxcbiAgICBzbGF0ZWdyYXk6IDczNzI5NDQsXG4gICAgc2xhdGVncmV5OiA3MzcyOTQ0LFxuICAgIHNub3c6IDE2Nzc1OTMwLFxuICAgIHNwcmluZ2dyZWVuOiA2NTQwNyxcbiAgICBzdGVlbGJsdWU6IDQ2MjA5ODAsXG4gICAgdGFuOiAxMzgwODc4MCxcbiAgICB0ZWFsOiAzMjg5NixcbiAgICB0aGlzdGxlOiAxNDIwNDg4OCxcbiAgICB0b21hdG86IDE2NzM3MDk1LFxuICAgIHR1cnF1b2lzZTogNDI1MTg1NixcbiAgICB2aW9sZXQ6IDE1NjMxMDg2LFxuICAgIHdoZWF0OiAxNjExMzMzMSxcbiAgICB3aGl0ZTogMTY3NzcyMTUsXG4gICAgd2hpdGVzbW9rZTogMTYxMTkyODUsXG4gICAgeWVsbG93OiAxNjc3Njk2MCxcbiAgICB5ZWxsb3dncmVlbjogMTAxNDUwNzRcbiAgfSk7XG4gIGQzX3JnYl9uYW1lcy5mb3JFYWNoKGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICBkM19yZ2JfbmFtZXMuc2V0KGtleSwgZDNfcmdiTnVtYmVyKHZhbHVlKSk7XG4gIH0pO1xuICBmdW5jdGlvbiBkM19mdW5jdG9yKHYpIHtcbiAgICByZXR1cm4gdHlwZW9mIHYgPT09IFwiZnVuY3Rpb25cIiA/IHYgOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB2O1xuICAgIH07XG4gIH1cbiAgZDMuZnVuY3RvciA9IGQzX2Z1bmN0b3I7XG4gIGQzLnhociA9IGQzX3hoclR5cGUoZDNfaWRlbnRpdHkpO1xuICBmdW5jdGlvbiBkM194aHJUeXBlKHJlc3BvbnNlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHVybCwgbWltZVR5cGUsIGNhbGxiYWNrKSB7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMiAmJiB0eXBlb2YgbWltZVR5cGUgPT09IFwiZnVuY3Rpb25cIikgY2FsbGJhY2sgPSBtaW1lVHlwZSwgXG4gICAgICBtaW1lVHlwZSA9IG51bGw7XG4gICAgICByZXR1cm4gZDNfeGhyKHVybCwgbWltZVR5cGUsIHJlc3BvbnNlLCBjYWxsYmFjayk7XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBkM194aHIodXJsLCBtaW1lVHlwZSwgcmVzcG9uc2UsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHhociA9IHt9LCBkaXNwYXRjaCA9IGQzLmRpc3BhdGNoKFwiYmVmb3Jlc2VuZFwiLCBcInByb2dyZXNzXCIsIFwibG9hZFwiLCBcImVycm9yXCIpLCBoZWFkZXJzID0ge30sIHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKSwgcmVzcG9uc2VUeXBlID0gbnVsbDtcbiAgICBpZiAodGhpcy5YRG9tYWluUmVxdWVzdCAmJiAhKFwid2l0aENyZWRlbnRpYWxzXCIgaW4gcmVxdWVzdCkgJiYgL14oaHR0cChzKT86KT9cXC9cXC8vLnRlc3QodXJsKSkgcmVxdWVzdCA9IG5ldyBYRG9tYWluUmVxdWVzdCgpO1xuICAgIFwib25sb2FkXCIgaW4gcmVxdWVzdCA/IHJlcXVlc3Qub25sb2FkID0gcmVxdWVzdC5vbmVycm9yID0gcmVzcG9uZCA6IHJlcXVlc3Qub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXF1ZXN0LnJlYWR5U3RhdGUgPiAzICYmIHJlc3BvbmQoKTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIHJlc3BvbmQoKSB7XG4gICAgICB2YXIgc3RhdHVzID0gcmVxdWVzdC5zdGF0dXMsIHJlc3VsdDtcbiAgICAgIGlmICghc3RhdHVzICYmIGQzX3hockhhc1Jlc3BvbnNlKHJlcXVlc3QpIHx8IHN0YXR1cyA+PSAyMDAgJiYgc3RhdHVzIDwgMzAwIHx8IHN0YXR1cyA9PT0gMzA0KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmVzdWx0ID0gcmVzcG9uc2UuY2FsbCh4aHIsIHJlcXVlc3QpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgZGlzcGF0Y2guZXJyb3IuY2FsbCh4aHIsIGUpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBkaXNwYXRjaC5sb2FkLmNhbGwoeGhyLCByZXN1bHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGlzcGF0Y2guZXJyb3IuY2FsbCh4aHIsIHJlcXVlc3QpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXF1ZXN0Lm9ucHJvZ3Jlc3MgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgdmFyIG8gPSBkMy5ldmVudDtcbiAgICAgIGQzLmV2ZW50ID0gZXZlbnQ7XG4gICAgICB0cnkge1xuICAgICAgICBkaXNwYXRjaC5wcm9ncmVzcy5jYWxsKHhociwgcmVxdWVzdCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBkMy5ldmVudCA9IG87XG4gICAgICB9XG4gICAgfTtcbiAgICB4aHIuaGVhZGVyID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICAgIG5hbWUgPSAobmFtZSArIFwiXCIpLnRvTG93ZXJDYXNlKCk7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHJldHVybiBoZWFkZXJzW25hbWVdO1xuICAgICAgaWYgKHZhbHVlID09IG51bGwpIGRlbGV0ZSBoZWFkZXJzW25hbWVdOyBlbHNlIGhlYWRlcnNbbmFtZV0gPSB2YWx1ZSArIFwiXCI7XG4gICAgICByZXR1cm4geGhyO1xuICAgIH07XG4gICAgeGhyLm1pbWVUeXBlID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG1pbWVUeXBlO1xuICAgICAgbWltZVR5cGUgPSB2YWx1ZSA9PSBudWxsID8gbnVsbCA6IHZhbHVlICsgXCJcIjtcbiAgICAgIHJldHVybiB4aHI7XG4gICAgfTtcbiAgICB4aHIucmVzcG9uc2VUeXBlID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHJlc3BvbnNlVHlwZTtcbiAgICAgIHJlc3BvbnNlVHlwZSA9IHZhbHVlO1xuICAgICAgcmV0dXJuIHhocjtcbiAgICB9O1xuICAgIHhoci5yZXNwb25zZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXNwb25zZSA9IHZhbHVlO1xuICAgICAgcmV0dXJuIHhocjtcbiAgICB9O1xuICAgIFsgXCJnZXRcIiwgXCJwb3N0XCIgXS5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgICAgeGhyW21ldGhvZF0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHhoci5zZW5kLmFwcGx5KHhociwgWyBtZXRob2QgXS5jb25jYXQoZDNfYXJyYXkoYXJndW1lbnRzKSkpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgICB4aHIuc2VuZCA9IGZ1bmN0aW9uKG1ldGhvZCwgZGF0YSwgY2FsbGJhY2spIHtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyICYmIHR5cGVvZiBkYXRhID09PSBcImZ1bmN0aW9uXCIpIGNhbGxiYWNrID0gZGF0YSwgZGF0YSA9IG51bGw7XG4gICAgICByZXF1ZXN0Lm9wZW4obWV0aG9kLCB1cmwsIHRydWUpO1xuICAgICAgaWYgKG1pbWVUeXBlICE9IG51bGwgJiYgIShcImFjY2VwdFwiIGluIGhlYWRlcnMpKSBoZWFkZXJzW1wiYWNjZXB0XCJdID0gbWltZVR5cGUgKyBcIiwqLypcIjtcbiAgICAgIGlmIChyZXF1ZXN0LnNldFJlcXVlc3RIZWFkZXIpIGZvciAodmFyIG5hbWUgaW4gaGVhZGVycykgcmVxdWVzdC5zZXRSZXF1ZXN0SGVhZGVyKG5hbWUsIGhlYWRlcnNbbmFtZV0pO1xuICAgICAgaWYgKG1pbWVUeXBlICE9IG51bGwgJiYgcmVxdWVzdC5vdmVycmlkZU1pbWVUeXBlKSByZXF1ZXN0Lm92ZXJyaWRlTWltZVR5cGUobWltZVR5cGUpO1xuICAgICAgaWYgKHJlc3BvbnNlVHlwZSAhPSBudWxsKSByZXF1ZXN0LnJlc3BvbnNlVHlwZSA9IHJlc3BvbnNlVHlwZTtcbiAgICAgIGlmIChjYWxsYmFjayAhPSBudWxsKSB4aHIub24oXCJlcnJvclwiLCBjYWxsYmFjaykub24oXCJsb2FkXCIsIGZ1bmN0aW9uKHJlcXVlc3QpIHtcbiAgICAgICAgY2FsbGJhY2sobnVsbCwgcmVxdWVzdCk7XG4gICAgICB9KTtcbiAgICAgIGRpc3BhdGNoLmJlZm9yZXNlbmQuY2FsbCh4aHIsIHJlcXVlc3QpO1xuICAgICAgcmVxdWVzdC5zZW5kKGRhdGEgPT0gbnVsbCA/IG51bGwgOiBkYXRhKTtcbiAgICAgIHJldHVybiB4aHI7XG4gICAgfTtcbiAgICB4aHIuYWJvcnQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJlcXVlc3QuYWJvcnQoKTtcbiAgICAgIHJldHVybiB4aHI7XG4gICAgfTtcbiAgICBkMy5yZWJpbmQoeGhyLCBkaXNwYXRjaCwgXCJvblwiKTtcbiAgICByZXR1cm4gY2FsbGJhY2sgPT0gbnVsbCA/IHhociA6IHhoci5nZXQoZDNfeGhyX2ZpeENhbGxiYWNrKGNhbGxiYWNrKSk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfeGhyX2ZpeENhbGxiYWNrKGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrLmxlbmd0aCA9PT0gMSA/IGZ1bmN0aW9uKGVycm9yLCByZXF1ZXN0KSB7XG4gICAgICBjYWxsYmFjayhlcnJvciA9PSBudWxsID8gcmVxdWVzdCA6IG51bGwpO1xuICAgIH0gOiBjYWxsYmFjaztcbiAgfVxuICBmdW5jdGlvbiBkM194aHJIYXNSZXNwb25zZShyZXF1ZXN0KSB7XG4gICAgdmFyIHR5cGUgPSByZXF1ZXN0LnJlc3BvbnNlVHlwZTtcbiAgICByZXR1cm4gdHlwZSAmJiB0eXBlICE9PSBcInRleHRcIiA/IHJlcXVlc3QucmVzcG9uc2UgOiByZXF1ZXN0LnJlc3BvbnNlVGV4dDtcbiAgfVxuICBkMy5kc3YgPSBmdW5jdGlvbihkZWxpbWl0ZXIsIG1pbWVUeXBlKSB7XG4gICAgdmFyIHJlRm9ybWF0ID0gbmV3IFJlZ0V4cCgnW1wiJyArIGRlbGltaXRlciArIFwiXFxuXVwiKSwgZGVsaW1pdGVyQ29kZSA9IGRlbGltaXRlci5jaGFyQ29kZUF0KDApO1xuICAgIGZ1bmN0aW9uIGRzdih1cmwsIHJvdywgY2FsbGJhY2spIHtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMykgY2FsbGJhY2sgPSByb3csIHJvdyA9IG51bGw7XG4gICAgICB2YXIgeGhyID0gZDNfeGhyKHVybCwgbWltZVR5cGUsIHJvdyA9PSBudWxsID8gcmVzcG9uc2UgOiB0eXBlZFJlc3BvbnNlKHJvdyksIGNhbGxiYWNrKTtcbiAgICAgIHhoci5yb3cgPSBmdW5jdGlvbihfKSB7XG4gICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8geGhyLnJlc3BvbnNlKChyb3cgPSBfKSA9PSBudWxsID8gcmVzcG9uc2UgOiB0eXBlZFJlc3BvbnNlKF8pKSA6IHJvdztcbiAgICAgIH07XG4gICAgICByZXR1cm4geGhyO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXNwb25zZShyZXF1ZXN0KSB7XG4gICAgICByZXR1cm4gZHN2LnBhcnNlKHJlcXVlc3QucmVzcG9uc2VUZXh0KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdHlwZWRSZXNwb25zZShmKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24ocmVxdWVzdCkge1xuICAgICAgICByZXR1cm4gZHN2LnBhcnNlKHJlcXVlc3QucmVzcG9uc2VUZXh0LCBmKTtcbiAgICAgIH07XG4gICAgfVxuICAgIGRzdi5wYXJzZSA9IGZ1bmN0aW9uKHRleHQsIGYpIHtcbiAgICAgIHZhciBvO1xuICAgICAgcmV0dXJuIGRzdi5wYXJzZVJvd3ModGV4dCwgZnVuY3Rpb24ocm93LCBpKSB7XG4gICAgICAgIGlmIChvKSByZXR1cm4gbyhyb3csIGkgLSAxKTtcbiAgICAgICAgdmFyIGEgPSBuZXcgRnVuY3Rpb24oXCJkXCIsIFwicmV0dXJuIHtcIiArIHJvdy5tYXAoZnVuY3Rpb24obmFtZSwgaSkge1xuICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShuYW1lKSArIFwiOiBkW1wiICsgaSArIFwiXVwiO1xuICAgICAgICB9KS5qb2luKFwiLFwiKSArIFwifVwiKTtcbiAgICAgICAgbyA9IGYgPyBmdW5jdGlvbihyb3csIGkpIHtcbiAgICAgICAgICByZXR1cm4gZihhKHJvdyksIGkpO1xuICAgICAgICB9IDogYTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgZHN2LnBhcnNlUm93cyA9IGZ1bmN0aW9uKHRleHQsIGYpIHtcbiAgICAgIHZhciBFT0wgPSB7fSwgRU9GID0ge30sIHJvd3MgPSBbXSwgTiA9IHRleHQubGVuZ3RoLCBJID0gMCwgbiA9IDAsIHQsIGVvbDtcbiAgICAgIGZ1bmN0aW9uIHRva2VuKCkge1xuICAgICAgICBpZiAoSSA+PSBOKSByZXR1cm4gRU9GO1xuICAgICAgICBpZiAoZW9sKSByZXR1cm4gZW9sID0gZmFsc2UsIEVPTDtcbiAgICAgICAgdmFyIGogPSBJO1xuICAgICAgICBpZiAodGV4dC5jaGFyQ29kZUF0KGopID09PSAzNCkge1xuICAgICAgICAgIHZhciBpID0gajtcbiAgICAgICAgICB3aGlsZSAoaSsrIDwgTikge1xuICAgICAgICAgICAgaWYgKHRleHQuY2hhckNvZGVBdChpKSA9PT0gMzQpIHtcbiAgICAgICAgICAgICAgaWYgKHRleHQuY2hhckNvZGVBdChpICsgMSkgIT09IDM0KSBicmVhaztcbiAgICAgICAgICAgICAgKytpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBJID0gaSArIDI7XG4gICAgICAgICAgdmFyIGMgPSB0ZXh0LmNoYXJDb2RlQXQoaSArIDEpO1xuICAgICAgICAgIGlmIChjID09PSAxMykge1xuICAgICAgICAgICAgZW9sID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICh0ZXh0LmNoYXJDb2RlQXQoaSArIDIpID09PSAxMCkgKytJO1xuICAgICAgICAgIH0gZWxzZSBpZiAoYyA9PT0gMTApIHtcbiAgICAgICAgICAgIGVvbCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0ZXh0LnNsaWNlKGogKyAxLCBpKS5yZXBsYWNlKC9cIlwiL2csICdcIicpO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChJIDwgTikge1xuICAgICAgICAgIHZhciBjID0gdGV4dC5jaGFyQ29kZUF0KEkrKyksIGsgPSAxO1xuICAgICAgICAgIGlmIChjID09PSAxMCkgZW9sID0gdHJ1ZTsgZWxzZSBpZiAoYyA9PT0gMTMpIHtcbiAgICAgICAgICAgIGVvbCA9IHRydWU7XG4gICAgICAgICAgICBpZiAodGV4dC5jaGFyQ29kZUF0KEkpID09PSAxMCkgKytJLCArK2s7XG4gICAgICAgICAgfSBlbHNlIGlmIChjICE9PSBkZWxpbWl0ZXJDb2RlKSBjb250aW51ZTtcbiAgICAgICAgICByZXR1cm4gdGV4dC5zbGljZShqLCBJIC0gayk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRleHQuc2xpY2Uoaik7XG4gICAgICB9XG4gICAgICB3aGlsZSAoKHQgPSB0b2tlbigpKSAhPT0gRU9GKSB7XG4gICAgICAgIHZhciBhID0gW107XG4gICAgICAgIHdoaWxlICh0ICE9PSBFT0wgJiYgdCAhPT0gRU9GKSB7XG4gICAgICAgICAgYS5wdXNoKHQpO1xuICAgICAgICAgIHQgPSB0b2tlbigpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmICYmIChhID0gZihhLCBuKyspKSA9PSBudWxsKSBjb250aW51ZTtcbiAgICAgICAgcm93cy5wdXNoKGEpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJvd3M7XG4gICAgfTtcbiAgICBkc3YuZm9ybWF0ID0gZnVuY3Rpb24ocm93cykge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkocm93c1swXSkpIHJldHVybiBkc3YuZm9ybWF0Um93cyhyb3dzKTtcbiAgICAgIHZhciBmaWVsZFNldCA9IG5ldyBkM19TZXQoKSwgZmllbGRzID0gW107XG4gICAgICByb3dzLmZvckVhY2goZnVuY3Rpb24ocm93KSB7XG4gICAgICAgIGZvciAodmFyIGZpZWxkIGluIHJvdykge1xuICAgICAgICAgIGlmICghZmllbGRTZXQuaGFzKGZpZWxkKSkge1xuICAgICAgICAgICAgZmllbGRzLnB1c2goZmllbGRTZXQuYWRkKGZpZWxkKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBbIGZpZWxkcy5tYXAoZm9ybWF0VmFsdWUpLmpvaW4oZGVsaW1pdGVyKSBdLmNvbmNhdChyb3dzLm1hcChmdW5jdGlvbihyb3cpIHtcbiAgICAgICAgcmV0dXJuIGZpZWxkcy5tYXAoZnVuY3Rpb24oZmllbGQpIHtcbiAgICAgICAgICByZXR1cm4gZm9ybWF0VmFsdWUocm93W2ZpZWxkXSk7XG4gICAgICAgIH0pLmpvaW4oZGVsaW1pdGVyKTtcbiAgICAgIH0pKS5qb2luKFwiXFxuXCIpO1xuICAgIH07XG4gICAgZHN2LmZvcm1hdFJvd3MgPSBmdW5jdGlvbihyb3dzKSB7XG4gICAgICByZXR1cm4gcm93cy5tYXAoZm9ybWF0Um93KS5qb2luKFwiXFxuXCIpO1xuICAgIH07XG4gICAgZnVuY3Rpb24gZm9ybWF0Um93KHJvdykge1xuICAgICAgcmV0dXJuIHJvdy5tYXAoZm9ybWF0VmFsdWUpLmpvaW4oZGVsaW1pdGVyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZm9ybWF0VmFsdWUodGV4dCkge1xuICAgICAgcmV0dXJuIHJlRm9ybWF0LnRlc3QodGV4dCkgPyAnXCInICsgdGV4dC5yZXBsYWNlKC9cXFwiL2csICdcIlwiJykgKyAnXCInIDogdGV4dDtcbiAgICB9XG4gICAgcmV0dXJuIGRzdjtcbiAgfTtcbiAgZDMuY3N2ID0gZDMuZHN2KFwiLFwiLCBcInRleHQvY3N2XCIpO1xuICBkMy50c3YgPSBkMy5kc3YoXCJcdFwiLCBcInRleHQvdGFiLXNlcGFyYXRlZC12YWx1ZXNcIik7XG4gIHZhciBkM190aW1lcl9xdWV1ZUhlYWQsIGQzX3RpbWVyX3F1ZXVlVGFpbCwgZDNfdGltZXJfaW50ZXJ2YWwsIGQzX3RpbWVyX3RpbWVvdXQsIGQzX3RpbWVyX2ZyYW1lID0gdGhpc1tkM192ZW5kb3JTeW1ib2wodGhpcywgXCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWVcIildIHx8IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgc2V0VGltZW91dChjYWxsYmFjaywgMTcpO1xuICB9O1xuICBkMy50aW1lciA9IGZ1bmN0aW9uKCkge1xuICAgIGQzX3RpbWVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX3RpbWVyKGNhbGxiYWNrLCBkZWxheSwgdGhlbikge1xuICAgIHZhciBuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICBpZiAobiA8IDIpIGRlbGF5ID0gMDtcbiAgICBpZiAobiA8IDMpIHRoZW4gPSBEYXRlLm5vdygpO1xuICAgIHZhciB0aW1lID0gdGhlbiArIGRlbGF5LCB0aW1lciA9IHtcbiAgICAgIGM6IGNhbGxiYWNrLFxuICAgICAgdDogdGltZSxcbiAgICAgIG46IG51bGxcbiAgICB9O1xuICAgIGlmIChkM190aW1lcl9xdWV1ZVRhaWwpIGQzX3RpbWVyX3F1ZXVlVGFpbC5uID0gdGltZXI7IGVsc2UgZDNfdGltZXJfcXVldWVIZWFkID0gdGltZXI7XG4gICAgZDNfdGltZXJfcXVldWVUYWlsID0gdGltZXI7XG4gICAgaWYgKCFkM190aW1lcl9pbnRlcnZhbCkge1xuICAgICAgZDNfdGltZXJfdGltZW91dCA9IGNsZWFyVGltZW91dChkM190aW1lcl90aW1lb3V0KTtcbiAgICAgIGQzX3RpbWVyX2ludGVydmFsID0gMTtcbiAgICAgIGQzX3RpbWVyX2ZyYW1lKGQzX3RpbWVyX3N0ZXApO1xuICAgIH1cbiAgICByZXR1cm4gdGltZXI7XG4gIH1cbiAgZnVuY3Rpb24gZDNfdGltZXJfc3RlcCgpIHtcbiAgICB2YXIgbm93ID0gZDNfdGltZXJfbWFyaygpLCBkZWxheSA9IGQzX3RpbWVyX3N3ZWVwKCkgLSBub3c7XG4gICAgaWYgKGRlbGF5ID4gMjQpIHtcbiAgICAgIGlmIChpc0Zpbml0ZShkZWxheSkpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KGQzX3RpbWVyX3RpbWVvdXQpO1xuICAgICAgICBkM190aW1lcl90aW1lb3V0ID0gc2V0VGltZW91dChkM190aW1lcl9zdGVwLCBkZWxheSk7XG4gICAgICB9XG4gICAgICBkM190aW1lcl9pbnRlcnZhbCA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGQzX3RpbWVyX2ludGVydmFsID0gMTtcbiAgICAgIGQzX3RpbWVyX2ZyYW1lKGQzX3RpbWVyX3N0ZXApO1xuICAgIH1cbiAgfVxuICBkMy50aW1lci5mbHVzaCA9IGZ1bmN0aW9uKCkge1xuICAgIGQzX3RpbWVyX21hcmsoKTtcbiAgICBkM190aW1lcl9zd2VlcCgpO1xuICB9O1xuICBmdW5jdGlvbiBkM190aW1lcl9tYXJrKCkge1xuICAgIHZhciBub3cgPSBEYXRlLm5vdygpLCB0aW1lciA9IGQzX3RpbWVyX3F1ZXVlSGVhZDtcbiAgICB3aGlsZSAodGltZXIpIHtcbiAgICAgIGlmIChub3cgPj0gdGltZXIudCAmJiB0aW1lci5jKG5vdyAtIHRpbWVyLnQpKSB0aW1lci5jID0gbnVsbDtcbiAgICAgIHRpbWVyID0gdGltZXIubjtcbiAgICB9XG4gICAgcmV0dXJuIG5vdztcbiAgfVxuICBmdW5jdGlvbiBkM190aW1lcl9zd2VlcCgpIHtcbiAgICB2YXIgdDAsIHQxID0gZDNfdGltZXJfcXVldWVIZWFkLCB0aW1lID0gSW5maW5pdHk7XG4gICAgd2hpbGUgKHQxKSB7XG4gICAgICBpZiAodDEuYykge1xuICAgICAgICBpZiAodDEudCA8IHRpbWUpIHRpbWUgPSB0MS50O1xuICAgICAgICB0MSA9ICh0MCA9IHQxKS5uO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdDEgPSB0MCA/IHQwLm4gPSB0MS5uIDogZDNfdGltZXJfcXVldWVIZWFkID0gdDEubjtcbiAgICAgIH1cbiAgICB9XG4gICAgZDNfdGltZXJfcXVldWVUYWlsID0gdDA7XG4gICAgcmV0dXJuIHRpbWU7XG4gIH1cbiAgZnVuY3Rpb24gZDNfZm9ybWF0X3ByZWNpc2lvbih4LCBwKSB7XG4gICAgcmV0dXJuIHAgLSAoeCA/IE1hdGguY2VpbChNYXRoLmxvZyh4KSAvIE1hdGguTE4xMCkgOiAxKTtcbiAgfVxuICBkMy5yb3VuZCA9IGZ1bmN0aW9uKHgsIG4pIHtcbiAgICByZXR1cm4gbiA/IE1hdGgucm91bmQoeCAqIChuID0gTWF0aC5wb3coMTAsIG4pKSkgLyBuIDogTWF0aC5yb3VuZCh4KTtcbiAgfTtcbiAgdmFyIGQzX2Zvcm1hdFByZWZpeGVzID0gWyBcInlcIiwgXCJ6XCIsIFwiYVwiLCBcImZcIiwgXCJwXCIsIFwiblwiLCBcIsK1XCIsIFwibVwiLCBcIlwiLCBcImtcIiwgXCJNXCIsIFwiR1wiLCBcIlRcIiwgXCJQXCIsIFwiRVwiLCBcIlpcIiwgXCJZXCIgXS5tYXAoZDNfZm9ybWF0UHJlZml4KTtcbiAgZDMuZm9ybWF0UHJlZml4ID0gZnVuY3Rpb24odmFsdWUsIHByZWNpc2lvbikge1xuICAgIHZhciBpID0gMDtcbiAgICBpZiAodmFsdWUgPSArdmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSA8IDApIHZhbHVlICo9IC0xO1xuICAgICAgaWYgKHByZWNpc2lvbikgdmFsdWUgPSBkMy5yb3VuZCh2YWx1ZSwgZDNfZm9ybWF0X3ByZWNpc2lvbih2YWx1ZSwgcHJlY2lzaW9uKSk7XG4gICAgICBpID0gMSArIE1hdGguZmxvb3IoMWUtMTIgKyBNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMTApO1xuICAgICAgaSA9IE1hdGgubWF4KC0yNCwgTWF0aC5taW4oMjQsIE1hdGguZmxvb3IoKGkgLSAxKSAvIDMpICogMykpO1xuICAgIH1cbiAgICByZXR1cm4gZDNfZm9ybWF0UHJlZml4ZXNbOCArIGkgLyAzXTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfZm9ybWF0UHJlZml4KGQsIGkpIHtcbiAgICB2YXIgayA9IE1hdGgucG93KDEwLCBhYnMoOCAtIGkpICogMyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNjYWxlOiBpID4gOCA/IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgcmV0dXJuIGQgLyBrO1xuICAgICAgfSA6IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgcmV0dXJuIGQgKiBrO1xuICAgICAgfSxcbiAgICAgIHN5bWJvbDogZFxuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gZDNfbG9jYWxlX251bWJlckZvcm1hdChsb2NhbGUpIHtcbiAgICB2YXIgbG9jYWxlX2RlY2ltYWwgPSBsb2NhbGUuZGVjaW1hbCwgbG9jYWxlX3Rob3VzYW5kcyA9IGxvY2FsZS50aG91c2FuZHMsIGxvY2FsZV9ncm91cGluZyA9IGxvY2FsZS5ncm91cGluZywgbG9jYWxlX2N1cnJlbmN5ID0gbG9jYWxlLmN1cnJlbmN5LCBmb3JtYXRHcm91cCA9IGxvY2FsZV9ncm91cGluZyAmJiBsb2NhbGVfdGhvdXNhbmRzID8gZnVuY3Rpb24odmFsdWUsIHdpZHRoKSB7XG4gICAgICB2YXIgaSA9IHZhbHVlLmxlbmd0aCwgdCA9IFtdLCBqID0gMCwgZyA9IGxvY2FsZV9ncm91cGluZ1swXSwgbGVuZ3RoID0gMDtcbiAgICAgIHdoaWxlIChpID4gMCAmJiBnID4gMCkge1xuICAgICAgICBpZiAobGVuZ3RoICsgZyArIDEgPiB3aWR0aCkgZyA9IE1hdGgubWF4KDEsIHdpZHRoIC0gbGVuZ3RoKTtcbiAgICAgICAgdC5wdXNoKHZhbHVlLnN1YnN0cmluZyhpIC09IGcsIGkgKyBnKSk7XG4gICAgICAgIGlmICgobGVuZ3RoICs9IGcgKyAxKSA+IHdpZHRoKSBicmVhaztcbiAgICAgICAgZyA9IGxvY2FsZV9ncm91cGluZ1tqID0gKGogKyAxKSAlIGxvY2FsZV9ncm91cGluZy5sZW5ndGhdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHQucmV2ZXJzZSgpLmpvaW4obG9jYWxlX3Rob3VzYW5kcyk7XG4gICAgfSA6IGQzX2lkZW50aXR5O1xuICAgIHJldHVybiBmdW5jdGlvbihzcGVjaWZpZXIpIHtcbiAgICAgIHZhciBtYXRjaCA9IGQzX2Zvcm1hdF9yZS5leGVjKHNwZWNpZmllciksIGZpbGwgPSBtYXRjaFsxXSB8fCBcIiBcIiwgYWxpZ24gPSBtYXRjaFsyXSB8fCBcIj5cIiwgc2lnbiA9IG1hdGNoWzNdIHx8IFwiLVwiLCBzeW1ib2wgPSBtYXRjaFs0XSB8fCBcIlwiLCB6ZmlsbCA9IG1hdGNoWzVdLCB3aWR0aCA9ICttYXRjaFs2XSwgY29tbWEgPSBtYXRjaFs3XSwgcHJlY2lzaW9uID0gbWF0Y2hbOF0sIHR5cGUgPSBtYXRjaFs5XSwgc2NhbGUgPSAxLCBwcmVmaXggPSBcIlwiLCBzdWZmaXggPSBcIlwiLCBpbnRlZ2VyID0gZmFsc2UsIGV4cG9uZW50ID0gdHJ1ZTtcbiAgICAgIGlmIChwcmVjaXNpb24pIHByZWNpc2lvbiA9ICtwcmVjaXNpb24uc3Vic3RyaW5nKDEpO1xuICAgICAgaWYgKHpmaWxsIHx8IGZpbGwgPT09IFwiMFwiICYmIGFsaWduID09PSBcIj1cIikge1xuICAgICAgICB6ZmlsbCA9IGZpbGwgPSBcIjBcIjtcbiAgICAgICAgYWxpZ24gPSBcIj1cIjtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgIGNhc2UgXCJuXCI6XG4gICAgICAgIGNvbW1hID0gdHJ1ZTtcbiAgICAgICAgdHlwZSA9IFwiZ1wiO1xuICAgICAgICBicmVhaztcblxuICAgICAgIGNhc2UgXCIlXCI6XG4gICAgICAgIHNjYWxlID0gMTAwO1xuICAgICAgICBzdWZmaXggPSBcIiVcIjtcbiAgICAgICAgdHlwZSA9IFwiZlwiO1xuICAgICAgICBicmVhaztcblxuICAgICAgIGNhc2UgXCJwXCI6XG4gICAgICAgIHNjYWxlID0gMTAwO1xuICAgICAgICBzdWZmaXggPSBcIiVcIjtcbiAgICAgICAgdHlwZSA9IFwiclwiO1xuICAgICAgICBicmVhaztcblxuICAgICAgIGNhc2UgXCJiXCI6XG4gICAgICAgY2FzZSBcIm9cIjpcbiAgICAgICBjYXNlIFwieFwiOlxuICAgICAgIGNhc2UgXCJYXCI6XG4gICAgICAgIGlmIChzeW1ib2wgPT09IFwiI1wiKSBwcmVmaXggPSBcIjBcIiArIHR5cGUudG9Mb3dlckNhc2UoKTtcblxuICAgICAgIGNhc2UgXCJjXCI6XG4gICAgICAgIGV4cG9uZW50ID0gZmFsc2U7XG5cbiAgICAgICBjYXNlIFwiZFwiOlxuICAgICAgICBpbnRlZ2VyID0gdHJ1ZTtcbiAgICAgICAgcHJlY2lzaW9uID0gMDtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgICBjYXNlIFwic1wiOlxuICAgICAgICBzY2FsZSA9IC0xO1xuICAgICAgICB0eXBlID0gXCJyXCI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKHN5bWJvbCA9PT0gXCIkXCIpIHByZWZpeCA9IGxvY2FsZV9jdXJyZW5jeVswXSwgc3VmZml4ID0gbG9jYWxlX2N1cnJlbmN5WzFdO1xuICAgICAgaWYgKHR5cGUgPT0gXCJyXCIgJiYgIXByZWNpc2lvbikgdHlwZSA9IFwiZ1wiO1xuICAgICAgaWYgKHByZWNpc2lvbiAhPSBudWxsKSB7XG4gICAgICAgIGlmICh0eXBlID09IFwiZ1wiKSBwcmVjaXNpb24gPSBNYXRoLm1heCgxLCBNYXRoLm1pbigyMSwgcHJlY2lzaW9uKSk7IGVsc2UgaWYgKHR5cGUgPT0gXCJlXCIgfHwgdHlwZSA9PSBcImZcIikgcHJlY2lzaW9uID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMjAsIHByZWNpc2lvbikpO1xuICAgICAgfVxuICAgICAgdHlwZSA9IGQzX2Zvcm1hdF90eXBlcy5nZXQodHlwZSkgfHwgZDNfZm9ybWF0X3R5cGVEZWZhdWx0O1xuICAgICAgdmFyIHpjb21tYSA9IHpmaWxsICYmIGNvbW1hO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHZhciBmdWxsU3VmZml4ID0gc3VmZml4O1xuICAgICAgICBpZiAoaW50ZWdlciAmJiB2YWx1ZSAlIDEpIHJldHVybiBcIlwiO1xuICAgICAgICB2YXIgbmVnYXRpdmUgPSB2YWx1ZSA8IDAgfHwgdmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCA/ICh2YWx1ZSA9IC12YWx1ZSwgXCItXCIpIDogc2lnbiA9PT0gXCItXCIgPyBcIlwiIDogc2lnbjtcbiAgICAgICAgaWYgKHNjYWxlIDwgMCkge1xuICAgICAgICAgIHZhciB1bml0ID0gZDMuZm9ybWF0UHJlZml4KHZhbHVlLCBwcmVjaXNpb24pO1xuICAgICAgICAgIHZhbHVlID0gdW5pdC5zY2FsZSh2YWx1ZSk7XG4gICAgICAgICAgZnVsbFN1ZmZpeCA9IHVuaXQuc3ltYm9sICsgc3VmZml4O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlICo9IHNjYWxlO1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlID0gdHlwZSh2YWx1ZSwgcHJlY2lzaW9uKTtcbiAgICAgICAgdmFyIGkgPSB2YWx1ZS5sYXN0SW5kZXhPZihcIi5cIiksIGJlZm9yZSwgYWZ0ZXI7XG4gICAgICAgIGlmIChpIDwgMCkge1xuICAgICAgICAgIHZhciBqID0gZXhwb25lbnQgPyB2YWx1ZS5sYXN0SW5kZXhPZihcImVcIikgOiAtMTtcbiAgICAgICAgICBpZiAoaiA8IDApIGJlZm9yZSA9IHZhbHVlLCBhZnRlciA9IFwiXCI7IGVsc2UgYmVmb3JlID0gdmFsdWUuc3Vic3RyaW5nKDAsIGopLCBhZnRlciA9IHZhbHVlLnN1YnN0cmluZyhqKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBiZWZvcmUgPSB2YWx1ZS5zdWJzdHJpbmcoMCwgaSk7XG4gICAgICAgICAgYWZ0ZXIgPSBsb2NhbGVfZGVjaW1hbCArIHZhbHVlLnN1YnN0cmluZyhpICsgMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF6ZmlsbCAmJiBjb21tYSkgYmVmb3JlID0gZm9ybWF0R3JvdXAoYmVmb3JlLCBJbmZpbml0eSk7XG4gICAgICAgIHZhciBsZW5ndGggPSBwcmVmaXgubGVuZ3RoICsgYmVmb3JlLmxlbmd0aCArIGFmdGVyLmxlbmd0aCArICh6Y29tbWEgPyAwIDogbmVnYXRpdmUubGVuZ3RoKSwgcGFkZGluZyA9IGxlbmd0aCA8IHdpZHRoID8gbmV3IEFycmF5KGxlbmd0aCA9IHdpZHRoIC0gbGVuZ3RoICsgMSkuam9pbihmaWxsKSA6IFwiXCI7XG4gICAgICAgIGlmICh6Y29tbWEpIGJlZm9yZSA9IGZvcm1hdEdyb3VwKHBhZGRpbmcgKyBiZWZvcmUsIHBhZGRpbmcubGVuZ3RoID8gd2lkdGggLSBhZnRlci5sZW5ndGggOiBJbmZpbml0eSk7XG4gICAgICAgIG5lZ2F0aXZlICs9IHByZWZpeDtcbiAgICAgICAgdmFsdWUgPSBiZWZvcmUgKyBhZnRlcjtcbiAgICAgICAgcmV0dXJuIChhbGlnbiA9PT0gXCI8XCIgPyBuZWdhdGl2ZSArIHZhbHVlICsgcGFkZGluZyA6IGFsaWduID09PSBcIj5cIiA/IHBhZGRpbmcgKyBuZWdhdGl2ZSArIHZhbHVlIDogYWxpZ24gPT09IFwiXlwiID8gcGFkZGluZy5zdWJzdHJpbmcoMCwgbGVuZ3RoID4+PSAxKSArIG5lZ2F0aXZlICsgdmFsdWUgKyBwYWRkaW5nLnN1YnN0cmluZyhsZW5ndGgpIDogbmVnYXRpdmUgKyAoemNvbW1hID8gdmFsdWUgOiBwYWRkaW5nICsgdmFsdWUpKSArIGZ1bGxTdWZmaXg7XG4gICAgICB9O1xuICAgIH07XG4gIH1cbiAgdmFyIGQzX2Zvcm1hdF9yZSA9IC8oPzooW157XSk/KFs8Pj1eXSkpPyhbK1xcLSBdKT8oWyQjXSk/KDApPyhcXGQrKT8oLCk/KFxcLi0/XFxkKyk/KFthLXolXSk/L2k7XG4gIHZhciBkM19mb3JtYXRfdHlwZXMgPSBkMy5tYXAoe1xuICAgIGI6IGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiB4LnRvU3RyaW5nKDIpO1xuICAgIH0sXG4gICAgYzogZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoeCk7XG4gICAgfSxcbiAgICBvOiBmdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4geC50b1N0cmluZyg4KTtcbiAgICB9LFxuICAgIHg6IGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiB4LnRvU3RyaW5nKDE2KTtcbiAgICB9LFxuICAgIFg6IGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiB4LnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO1xuICAgIH0sXG4gICAgZzogZnVuY3Rpb24oeCwgcCkge1xuICAgICAgcmV0dXJuIHgudG9QcmVjaXNpb24ocCk7XG4gICAgfSxcbiAgICBlOiBmdW5jdGlvbih4LCBwKSB7XG4gICAgICByZXR1cm4geC50b0V4cG9uZW50aWFsKHApO1xuICAgIH0sXG4gICAgZjogZnVuY3Rpb24oeCwgcCkge1xuICAgICAgcmV0dXJuIHgudG9GaXhlZChwKTtcbiAgICB9LFxuICAgIHI6IGZ1bmN0aW9uKHgsIHApIHtcbiAgICAgIHJldHVybiAoeCA9IGQzLnJvdW5kKHgsIGQzX2Zvcm1hdF9wcmVjaXNpb24oeCwgcCkpKS50b0ZpeGVkKE1hdGgubWF4KDAsIE1hdGgubWluKDIwLCBkM19mb3JtYXRfcHJlY2lzaW9uKHggKiAoMSArIDFlLTE1KSwgcCkpKSk7XG4gICAgfVxuICB9KTtcbiAgZnVuY3Rpb24gZDNfZm9ybWF0X3R5cGVEZWZhdWx0KHgpIHtcbiAgICByZXR1cm4geCArIFwiXCI7XG4gIH1cbiAgdmFyIGQzX3RpbWUgPSBkMy50aW1lID0ge30sIGQzX2RhdGUgPSBEYXRlO1xuICBmdW5jdGlvbiBkM19kYXRlX3V0YygpIHtcbiAgICB0aGlzLl8gPSBuZXcgRGF0ZShhcmd1bWVudHMubGVuZ3RoID4gMSA/IERhdGUuVVRDLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiBhcmd1bWVudHNbMF0pO1xuICB9XG4gIGQzX2RhdGVfdXRjLnByb3RvdHlwZSA9IHtcbiAgICBnZXREYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl8uZ2V0VVRDRGF0ZSgpO1xuICAgIH0sXG4gICAgZ2V0RGF5OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl8uZ2V0VVRDRGF5KCk7XG4gICAgfSxcbiAgICBnZXRGdWxsWWVhcjogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fLmdldFVUQ0Z1bGxZZWFyKCk7XG4gICAgfSxcbiAgICBnZXRIb3VyczogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fLmdldFVUQ0hvdXJzKCk7XG4gICAgfSxcbiAgICBnZXRNaWxsaXNlY29uZHM6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuXy5nZXRVVENNaWxsaXNlY29uZHMoKTtcbiAgICB9LFxuICAgIGdldE1pbnV0ZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuXy5nZXRVVENNaW51dGVzKCk7XG4gICAgfSxcbiAgICBnZXRNb250aDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fLmdldFVUQ01vbnRoKCk7XG4gICAgfSxcbiAgICBnZXRTZWNvbmRzOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl8uZ2V0VVRDU2Vjb25kcygpO1xuICAgIH0sXG4gICAgZ2V0VGltZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fLmdldFRpbWUoKTtcbiAgICB9LFxuICAgIGdldFRpbWV6b25lT2Zmc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH0sXG4gICAgdmFsdWVPZjogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fLnZhbHVlT2YoKTtcbiAgICB9LFxuICAgIHNldERhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgZDNfdGltZV9wcm90b3R5cGUuc2V0VVRDRGF0ZS5hcHBseSh0aGlzLl8sIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICBzZXREYXk6IGZ1bmN0aW9uKCkge1xuICAgICAgZDNfdGltZV9wcm90b3R5cGUuc2V0VVRDRGF5LmFwcGx5KHRoaXMuXywgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIHNldEZ1bGxZZWFyOiBmdW5jdGlvbigpIHtcbiAgICAgIGQzX3RpbWVfcHJvdG90eXBlLnNldFVUQ0Z1bGxZZWFyLmFwcGx5KHRoaXMuXywgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIHNldEhvdXJzOiBmdW5jdGlvbigpIHtcbiAgICAgIGQzX3RpbWVfcHJvdG90eXBlLnNldFVUQ0hvdXJzLmFwcGx5KHRoaXMuXywgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIHNldE1pbGxpc2Vjb25kczogZnVuY3Rpb24oKSB7XG4gICAgICBkM190aW1lX3Byb3RvdHlwZS5zZXRVVENNaWxsaXNlY29uZHMuYXBwbHkodGhpcy5fLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgc2V0TWludXRlczogZnVuY3Rpb24oKSB7XG4gICAgICBkM190aW1lX3Byb3RvdHlwZS5zZXRVVENNaW51dGVzLmFwcGx5KHRoaXMuXywgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIHNldE1vbnRoOiBmdW5jdGlvbigpIHtcbiAgICAgIGQzX3RpbWVfcHJvdG90eXBlLnNldFVUQ01vbnRoLmFwcGx5KHRoaXMuXywgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIHNldFNlY29uZHM6IGZ1bmN0aW9uKCkge1xuICAgICAgZDNfdGltZV9wcm90b3R5cGUuc2V0VVRDU2Vjb25kcy5hcHBseSh0aGlzLl8sIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICBzZXRUaW1lOiBmdW5jdGlvbigpIHtcbiAgICAgIGQzX3RpbWVfcHJvdG90eXBlLnNldFRpbWUuYXBwbHkodGhpcy5fLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfTtcbiAgdmFyIGQzX3RpbWVfcHJvdG90eXBlID0gRGF0ZS5wcm90b3R5cGU7XG4gIGZ1bmN0aW9uIGQzX3RpbWVfaW50ZXJ2YWwobG9jYWwsIHN0ZXAsIG51bWJlcikge1xuICAgIGZ1bmN0aW9uIHJvdW5kKGRhdGUpIHtcbiAgICAgIHZhciBkMCA9IGxvY2FsKGRhdGUpLCBkMSA9IG9mZnNldChkMCwgMSk7XG4gICAgICByZXR1cm4gZGF0ZSAtIGQwIDwgZDEgLSBkYXRlID8gZDAgOiBkMTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2VpbChkYXRlKSB7XG4gICAgICBzdGVwKGRhdGUgPSBsb2NhbChuZXcgZDNfZGF0ZShkYXRlIC0gMSkpLCAxKTtcbiAgICAgIHJldHVybiBkYXRlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvZmZzZXQoZGF0ZSwgaykge1xuICAgICAgc3RlcChkYXRlID0gbmV3IGQzX2RhdGUoK2RhdGUpLCBrKTtcbiAgICAgIHJldHVybiBkYXRlO1xuICAgIH1cbiAgICBmdW5jdGlvbiByYW5nZSh0MCwgdDEsIGR0KSB7XG4gICAgICB2YXIgdGltZSA9IGNlaWwodDApLCB0aW1lcyA9IFtdO1xuICAgICAgaWYgKGR0ID4gMSkge1xuICAgICAgICB3aGlsZSAodGltZSA8IHQxKSB7XG4gICAgICAgICAgaWYgKCEobnVtYmVyKHRpbWUpICUgZHQpKSB0aW1lcy5wdXNoKG5ldyBEYXRlKCt0aW1lKSk7XG4gICAgICAgICAgc3RlcCh0aW1lLCAxKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2hpbGUgKHRpbWUgPCB0MSkgdGltZXMucHVzaChuZXcgRGF0ZSgrdGltZSkpLCBzdGVwKHRpbWUsIDEpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRpbWVzO1xuICAgIH1cbiAgICBmdW5jdGlvbiByYW5nZV91dGModDAsIHQxLCBkdCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZDNfZGF0ZSA9IGQzX2RhdGVfdXRjO1xuICAgICAgICB2YXIgdXRjID0gbmV3IGQzX2RhdGVfdXRjKCk7XG4gICAgICAgIHV0Yy5fID0gdDA7XG4gICAgICAgIHJldHVybiByYW5nZSh1dGMsIHQxLCBkdCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBkM19kYXRlID0gRGF0ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgbG9jYWwuZmxvb3IgPSBsb2NhbDtcbiAgICBsb2NhbC5yb3VuZCA9IHJvdW5kO1xuICAgIGxvY2FsLmNlaWwgPSBjZWlsO1xuICAgIGxvY2FsLm9mZnNldCA9IG9mZnNldDtcbiAgICBsb2NhbC5yYW5nZSA9IHJhbmdlO1xuICAgIHZhciB1dGMgPSBsb2NhbC51dGMgPSBkM190aW1lX2ludGVydmFsX3V0Yyhsb2NhbCk7XG4gICAgdXRjLmZsb29yID0gdXRjO1xuICAgIHV0Yy5yb3VuZCA9IGQzX3RpbWVfaW50ZXJ2YWxfdXRjKHJvdW5kKTtcbiAgICB1dGMuY2VpbCA9IGQzX3RpbWVfaW50ZXJ2YWxfdXRjKGNlaWwpO1xuICAgIHV0Yy5vZmZzZXQgPSBkM190aW1lX2ludGVydmFsX3V0YyhvZmZzZXQpO1xuICAgIHV0Yy5yYW5nZSA9IHJhbmdlX3V0YztcbiAgICByZXR1cm4gbG9jYWw7XG4gIH1cbiAgZnVuY3Rpb24gZDNfdGltZV9pbnRlcnZhbF91dGMobWV0aG9kKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGRhdGUsIGspIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGQzX2RhdGUgPSBkM19kYXRlX3V0YztcbiAgICAgICAgdmFyIHV0YyA9IG5ldyBkM19kYXRlX3V0YygpO1xuICAgICAgICB1dGMuXyA9IGRhdGU7XG4gICAgICAgIHJldHVybiBtZXRob2QodXRjLCBrKS5fO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgZDNfZGF0ZSA9IERhdGU7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBkM190aW1lLnllYXIgPSBkM190aW1lX2ludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgICBkYXRlID0gZDNfdGltZS5kYXkoZGF0ZSk7XG4gICAgZGF0ZS5zZXRNb250aCgwLCAxKTtcbiAgICByZXR1cm4gZGF0ZTtcbiAgfSwgZnVuY3Rpb24oZGF0ZSwgb2Zmc2V0KSB7XG4gICAgZGF0ZS5zZXRGdWxsWWVhcihkYXRlLmdldEZ1bGxZZWFyKCkgKyBvZmZzZXQpO1xuICB9LCBmdW5jdGlvbihkYXRlKSB7XG4gICAgcmV0dXJuIGRhdGUuZ2V0RnVsbFllYXIoKTtcbiAgfSk7XG4gIGQzX3RpbWUueWVhcnMgPSBkM190aW1lLnllYXIucmFuZ2U7XG4gIGQzX3RpbWUueWVhcnMudXRjID0gZDNfdGltZS55ZWFyLnV0Yy5yYW5nZTtcbiAgZDNfdGltZS5kYXkgPSBkM190aW1lX2ludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgICB2YXIgZGF5ID0gbmV3IGQzX2RhdGUoMmUzLCAwKTtcbiAgICBkYXkuc2V0RnVsbFllYXIoZGF0ZS5nZXRGdWxsWWVhcigpLCBkYXRlLmdldE1vbnRoKCksIGRhdGUuZ2V0RGF0ZSgpKTtcbiAgICByZXR1cm4gZGF5O1xuICB9LCBmdW5jdGlvbihkYXRlLCBvZmZzZXQpIHtcbiAgICBkYXRlLnNldERhdGUoZGF0ZS5nZXREYXRlKCkgKyBvZmZzZXQpO1xuICB9LCBmdW5jdGlvbihkYXRlKSB7XG4gICAgcmV0dXJuIGRhdGUuZ2V0RGF0ZSgpIC0gMTtcbiAgfSk7XG4gIGQzX3RpbWUuZGF5cyA9IGQzX3RpbWUuZGF5LnJhbmdlO1xuICBkM190aW1lLmRheXMudXRjID0gZDNfdGltZS5kYXkudXRjLnJhbmdlO1xuICBkM190aW1lLmRheU9mWWVhciA9IGZ1bmN0aW9uKGRhdGUpIHtcbiAgICB2YXIgeWVhciA9IGQzX3RpbWUueWVhcihkYXRlKTtcbiAgICByZXR1cm4gTWF0aC5mbG9vcigoZGF0ZSAtIHllYXIgLSAoZGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpIC0geWVhci5nZXRUaW1lem9uZU9mZnNldCgpKSAqIDZlNCkgLyA4NjRlNSk7XG4gIH07XG4gIFsgXCJzdW5kYXlcIiwgXCJtb25kYXlcIiwgXCJ0dWVzZGF5XCIsIFwid2VkbmVzZGF5XCIsIFwidGh1cnNkYXlcIiwgXCJmcmlkYXlcIiwgXCJzYXR1cmRheVwiIF0uZm9yRWFjaChmdW5jdGlvbihkYXksIGkpIHtcbiAgICBpID0gNyAtIGk7XG4gICAgdmFyIGludGVydmFsID0gZDNfdGltZVtkYXldID0gZDNfdGltZV9pbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gICAgICAoZGF0ZSA9IGQzX3RpbWUuZGF5KGRhdGUpKS5zZXREYXRlKGRhdGUuZ2V0RGF0ZSgpIC0gKGRhdGUuZ2V0RGF5KCkgKyBpKSAlIDcpO1xuICAgICAgcmV0dXJuIGRhdGU7XG4gICAgfSwgZnVuY3Rpb24oZGF0ZSwgb2Zmc2V0KSB7XG4gICAgICBkYXRlLnNldERhdGUoZGF0ZS5nZXREYXRlKCkgKyBNYXRoLmZsb29yKG9mZnNldCkgKiA3KTtcbiAgICB9LCBmdW5jdGlvbihkYXRlKSB7XG4gICAgICB2YXIgZGF5ID0gZDNfdGltZS55ZWFyKGRhdGUpLmdldERheSgpO1xuICAgICAgcmV0dXJuIE1hdGguZmxvb3IoKGQzX3RpbWUuZGF5T2ZZZWFyKGRhdGUpICsgKGRheSArIGkpICUgNykgLyA3KSAtIChkYXkgIT09IGkpO1xuICAgIH0pO1xuICAgIGQzX3RpbWVbZGF5ICsgXCJzXCJdID0gaW50ZXJ2YWwucmFuZ2U7XG4gICAgZDNfdGltZVtkYXkgKyBcInNcIl0udXRjID0gaW50ZXJ2YWwudXRjLnJhbmdlO1xuICAgIGQzX3RpbWVbZGF5ICsgXCJPZlllYXJcIl0gPSBmdW5jdGlvbihkYXRlKSB7XG4gICAgICB2YXIgZGF5ID0gZDNfdGltZS55ZWFyKGRhdGUpLmdldERheSgpO1xuICAgICAgcmV0dXJuIE1hdGguZmxvb3IoKGQzX3RpbWUuZGF5T2ZZZWFyKGRhdGUpICsgKGRheSArIGkpICUgNykgLyA3KTtcbiAgICB9O1xuICB9KTtcbiAgZDNfdGltZS53ZWVrID0gZDNfdGltZS5zdW5kYXk7XG4gIGQzX3RpbWUud2Vla3MgPSBkM190aW1lLnN1bmRheS5yYW5nZTtcbiAgZDNfdGltZS53ZWVrcy51dGMgPSBkM190aW1lLnN1bmRheS51dGMucmFuZ2U7XG4gIGQzX3RpbWUud2Vla09mWWVhciA9IGQzX3RpbWUuc3VuZGF5T2ZZZWFyO1xuICBmdW5jdGlvbiBkM19sb2NhbGVfdGltZUZvcm1hdChsb2NhbGUpIHtcbiAgICB2YXIgbG9jYWxlX2RhdGVUaW1lID0gbG9jYWxlLmRhdGVUaW1lLCBsb2NhbGVfZGF0ZSA9IGxvY2FsZS5kYXRlLCBsb2NhbGVfdGltZSA9IGxvY2FsZS50aW1lLCBsb2NhbGVfcGVyaW9kcyA9IGxvY2FsZS5wZXJpb2RzLCBsb2NhbGVfZGF5cyA9IGxvY2FsZS5kYXlzLCBsb2NhbGVfc2hvcnREYXlzID0gbG9jYWxlLnNob3J0RGF5cywgbG9jYWxlX21vbnRocyA9IGxvY2FsZS5tb250aHMsIGxvY2FsZV9zaG9ydE1vbnRocyA9IGxvY2FsZS5zaG9ydE1vbnRocztcbiAgICBmdW5jdGlvbiBkM190aW1lX2Zvcm1hdCh0ZW1wbGF0ZSkge1xuICAgICAgdmFyIG4gPSB0ZW1wbGF0ZS5sZW5ndGg7XG4gICAgICBmdW5jdGlvbiBmb3JtYXQoZGF0ZSkge1xuICAgICAgICB2YXIgc3RyaW5nID0gW10sIGkgPSAtMSwgaiA9IDAsIGMsIHAsIGY7XG4gICAgICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgICAgaWYgKHRlbXBsYXRlLmNoYXJDb2RlQXQoaSkgPT09IDM3KSB7XG4gICAgICAgICAgICBzdHJpbmcucHVzaCh0ZW1wbGF0ZS5zbGljZShqLCBpKSk7XG4gICAgICAgICAgICBpZiAoKHAgPSBkM190aW1lX2Zvcm1hdFBhZHNbYyA9IHRlbXBsYXRlLmNoYXJBdCgrK2kpXSkgIT0gbnVsbCkgYyA9IHRlbXBsYXRlLmNoYXJBdCgrK2kpO1xuICAgICAgICAgICAgaWYgKGYgPSBkM190aW1lX2Zvcm1hdHNbY10pIGMgPSBmKGRhdGUsIHAgPT0gbnVsbCA/IGMgPT09IFwiZVwiID8gXCIgXCIgOiBcIjBcIiA6IHApO1xuICAgICAgICAgICAgc3RyaW5nLnB1c2goYyk7XG4gICAgICAgICAgICBqID0gaSArIDE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0cmluZy5wdXNoKHRlbXBsYXRlLnNsaWNlKGosIGkpKTtcbiAgICAgICAgcmV0dXJuIHN0cmluZy5qb2luKFwiXCIpO1xuICAgICAgfVxuICAgICAgZm9ybWF0LnBhcnNlID0gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICAgIHZhciBkID0ge1xuICAgICAgICAgIHk6IDE5MDAsXG4gICAgICAgICAgbTogMCxcbiAgICAgICAgICBkOiAxLFxuICAgICAgICAgIEg6IDAsXG4gICAgICAgICAgTTogMCxcbiAgICAgICAgICBTOiAwLFxuICAgICAgICAgIEw6IDAsXG4gICAgICAgICAgWjogbnVsbFxuICAgICAgICB9LCBpID0gZDNfdGltZV9wYXJzZShkLCB0ZW1wbGF0ZSwgc3RyaW5nLCAwKTtcbiAgICAgICAgaWYgKGkgIT0gc3RyaW5nLmxlbmd0aCkgcmV0dXJuIG51bGw7XG4gICAgICAgIGlmIChcInBcIiBpbiBkKSBkLkggPSBkLkggJSAxMiArIGQucCAqIDEyO1xuICAgICAgICB2YXIgbG9jYWxaID0gZC5aICE9IG51bGwgJiYgZDNfZGF0ZSAhPT0gZDNfZGF0ZV91dGMsIGRhdGUgPSBuZXcgKGxvY2FsWiA/IGQzX2RhdGVfdXRjIDogZDNfZGF0ZSkoKTtcbiAgICAgICAgaWYgKFwialwiIGluIGQpIGRhdGUuc2V0RnVsbFllYXIoZC55LCAwLCBkLmopOyBlbHNlIGlmIChcIldcIiBpbiBkIHx8IFwiVVwiIGluIGQpIHtcbiAgICAgICAgICBpZiAoIShcIndcIiBpbiBkKSkgZC53ID0gXCJXXCIgaW4gZCA/IDEgOiAwO1xuICAgICAgICAgIGRhdGUuc2V0RnVsbFllYXIoZC55LCAwLCAxKTtcbiAgICAgICAgICBkYXRlLnNldEZ1bGxZZWFyKGQueSwgMCwgXCJXXCIgaW4gZCA/IChkLncgKyA2KSAlIDcgKyBkLlcgKiA3IC0gKGRhdGUuZ2V0RGF5KCkgKyA1KSAlIDcgOiBkLncgKyBkLlUgKiA3IC0gKGRhdGUuZ2V0RGF5KCkgKyA2KSAlIDcpO1xuICAgICAgICB9IGVsc2UgZGF0ZS5zZXRGdWxsWWVhcihkLnksIGQubSwgZC5kKTtcbiAgICAgICAgZGF0ZS5zZXRIb3VycyhkLkggKyAoZC5aIC8gMTAwIHwgMCksIGQuTSArIGQuWiAlIDEwMCwgZC5TLCBkLkwpO1xuICAgICAgICByZXR1cm4gbG9jYWxaID8gZGF0ZS5fIDogZGF0ZTtcbiAgICAgIH07XG4gICAgICBmb3JtYXQudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRlbXBsYXRlO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBmb3JtYXQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGQzX3RpbWVfcGFyc2UoZGF0ZSwgdGVtcGxhdGUsIHN0cmluZywgaikge1xuICAgICAgdmFyIGMsIHAsIHQsIGkgPSAwLCBuID0gdGVtcGxhdGUubGVuZ3RoLCBtID0gc3RyaW5nLmxlbmd0aDtcbiAgICAgIHdoaWxlIChpIDwgbikge1xuICAgICAgICBpZiAoaiA+PSBtKSByZXR1cm4gLTE7XG4gICAgICAgIGMgPSB0ZW1wbGF0ZS5jaGFyQ29kZUF0KGkrKyk7XG4gICAgICAgIGlmIChjID09PSAzNykge1xuICAgICAgICAgIHQgPSB0ZW1wbGF0ZS5jaGFyQXQoaSsrKTtcbiAgICAgICAgICBwID0gZDNfdGltZV9wYXJzZXJzW3QgaW4gZDNfdGltZV9mb3JtYXRQYWRzID8gdGVtcGxhdGUuY2hhckF0KGkrKykgOiB0XTtcbiAgICAgICAgICBpZiAoIXAgfHwgKGogPSBwKGRhdGUsIHN0cmluZywgaikpIDwgMCkgcmV0dXJuIC0xO1xuICAgICAgICB9IGVsc2UgaWYgKGMgIT0gc3RyaW5nLmNoYXJDb2RlQXQoaisrKSkge1xuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGo7XG4gICAgfVxuICAgIGQzX3RpbWVfZm9ybWF0LnV0YyA9IGZ1bmN0aW9uKHRlbXBsYXRlKSB7XG4gICAgICB2YXIgbG9jYWwgPSBkM190aW1lX2Zvcm1hdCh0ZW1wbGF0ZSk7XG4gICAgICBmdW5jdGlvbiBmb3JtYXQoZGF0ZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGQzX2RhdGUgPSBkM19kYXRlX3V0YztcbiAgICAgICAgICB2YXIgdXRjID0gbmV3IGQzX2RhdGUoKTtcbiAgICAgICAgICB1dGMuXyA9IGRhdGU7XG4gICAgICAgICAgcmV0dXJuIGxvY2FsKHV0Yyk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgZDNfZGF0ZSA9IERhdGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZvcm1hdC5wYXJzZSA9IGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGQzX2RhdGUgPSBkM19kYXRlX3V0YztcbiAgICAgICAgICB2YXIgZGF0ZSA9IGxvY2FsLnBhcnNlKHN0cmluZyk7XG4gICAgICAgICAgcmV0dXJuIGRhdGUgJiYgZGF0ZS5fO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGQzX2RhdGUgPSBEYXRlO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgZm9ybWF0LnRvU3RyaW5nID0gbG9jYWwudG9TdHJpbmc7XG4gICAgICByZXR1cm4gZm9ybWF0O1xuICAgIH07XG4gICAgZDNfdGltZV9mb3JtYXQubXVsdGkgPSBkM190aW1lX2Zvcm1hdC51dGMubXVsdGkgPSBkM190aW1lX2Zvcm1hdE11bHRpO1xuICAgIHZhciBkM190aW1lX3BlcmlvZExvb2t1cCA9IGQzLm1hcCgpLCBkM190aW1lX2RheVJlID0gZDNfdGltZV9mb3JtYXRSZShsb2NhbGVfZGF5cyksIGQzX3RpbWVfZGF5TG9va3VwID0gZDNfdGltZV9mb3JtYXRMb29rdXAobG9jYWxlX2RheXMpLCBkM190aW1lX2RheUFiYnJldlJlID0gZDNfdGltZV9mb3JtYXRSZShsb2NhbGVfc2hvcnREYXlzKSwgZDNfdGltZV9kYXlBYmJyZXZMb29rdXAgPSBkM190aW1lX2Zvcm1hdExvb2t1cChsb2NhbGVfc2hvcnREYXlzKSwgZDNfdGltZV9tb250aFJlID0gZDNfdGltZV9mb3JtYXRSZShsb2NhbGVfbW9udGhzKSwgZDNfdGltZV9tb250aExvb2t1cCA9IGQzX3RpbWVfZm9ybWF0TG9va3VwKGxvY2FsZV9tb250aHMpLCBkM190aW1lX21vbnRoQWJicmV2UmUgPSBkM190aW1lX2Zvcm1hdFJlKGxvY2FsZV9zaG9ydE1vbnRocyksIGQzX3RpbWVfbW9udGhBYmJyZXZMb29rdXAgPSBkM190aW1lX2Zvcm1hdExvb2t1cChsb2NhbGVfc2hvcnRNb250aHMpO1xuICAgIGxvY2FsZV9wZXJpb2RzLmZvckVhY2goZnVuY3Rpb24ocCwgaSkge1xuICAgICAgZDNfdGltZV9wZXJpb2RMb29rdXAuc2V0KHAudG9Mb3dlckNhc2UoKSwgaSk7XG4gICAgfSk7XG4gICAgdmFyIGQzX3RpbWVfZm9ybWF0cyA9IHtcbiAgICAgIGE6IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZV9zaG9ydERheXNbZC5nZXREYXkoKV07XG4gICAgICB9LFxuICAgICAgQTogZnVuY3Rpb24oZCkge1xuICAgICAgICByZXR1cm4gbG9jYWxlX2RheXNbZC5nZXREYXkoKV07XG4gICAgICB9LFxuICAgICAgYjogZnVuY3Rpb24oZCkge1xuICAgICAgICByZXR1cm4gbG9jYWxlX3Nob3J0TW9udGhzW2QuZ2V0TW9udGgoKV07XG4gICAgICB9LFxuICAgICAgQjogZnVuY3Rpb24oZCkge1xuICAgICAgICByZXR1cm4gbG9jYWxlX21vbnRoc1tkLmdldE1vbnRoKCldO1xuICAgICAgfSxcbiAgICAgIGM6IGQzX3RpbWVfZm9ybWF0KGxvY2FsZV9kYXRlVGltZSksXG4gICAgICBkOiBmdW5jdGlvbihkLCBwKSB7XG4gICAgICAgIHJldHVybiBkM190aW1lX2Zvcm1hdFBhZChkLmdldERhdGUoKSwgcCwgMik7XG4gICAgICB9LFxuICAgICAgZTogZnVuY3Rpb24oZCwgcCkge1xuICAgICAgICByZXR1cm4gZDNfdGltZV9mb3JtYXRQYWQoZC5nZXREYXRlKCksIHAsIDIpO1xuICAgICAgfSxcbiAgICAgIEg6IGZ1bmN0aW9uKGQsIHApIHtcbiAgICAgICAgcmV0dXJuIGQzX3RpbWVfZm9ybWF0UGFkKGQuZ2V0SG91cnMoKSwgcCwgMik7XG4gICAgICB9LFxuICAgICAgSTogZnVuY3Rpb24oZCwgcCkge1xuICAgICAgICByZXR1cm4gZDNfdGltZV9mb3JtYXRQYWQoZC5nZXRIb3VycygpICUgMTIgfHwgMTIsIHAsIDIpO1xuICAgICAgfSxcbiAgICAgIGo6IGZ1bmN0aW9uKGQsIHApIHtcbiAgICAgICAgcmV0dXJuIGQzX3RpbWVfZm9ybWF0UGFkKDEgKyBkM190aW1lLmRheU9mWWVhcihkKSwgcCwgMyk7XG4gICAgICB9LFxuICAgICAgTDogZnVuY3Rpb24oZCwgcCkge1xuICAgICAgICByZXR1cm4gZDNfdGltZV9mb3JtYXRQYWQoZC5nZXRNaWxsaXNlY29uZHMoKSwgcCwgMyk7XG4gICAgICB9LFxuICAgICAgbTogZnVuY3Rpb24oZCwgcCkge1xuICAgICAgICByZXR1cm4gZDNfdGltZV9mb3JtYXRQYWQoZC5nZXRNb250aCgpICsgMSwgcCwgMik7XG4gICAgICB9LFxuICAgICAgTTogZnVuY3Rpb24oZCwgcCkge1xuICAgICAgICByZXR1cm4gZDNfdGltZV9mb3JtYXRQYWQoZC5nZXRNaW51dGVzKCksIHAsIDIpO1xuICAgICAgfSxcbiAgICAgIHA6IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZV9wZXJpb2RzWysoZC5nZXRIb3VycygpID49IDEyKV07XG4gICAgICB9LFxuICAgICAgUzogZnVuY3Rpb24oZCwgcCkge1xuICAgICAgICByZXR1cm4gZDNfdGltZV9mb3JtYXRQYWQoZC5nZXRTZWNvbmRzKCksIHAsIDIpO1xuICAgICAgfSxcbiAgICAgIFU6IGZ1bmN0aW9uKGQsIHApIHtcbiAgICAgICAgcmV0dXJuIGQzX3RpbWVfZm9ybWF0UGFkKGQzX3RpbWUuc3VuZGF5T2ZZZWFyKGQpLCBwLCAyKTtcbiAgICAgIH0sXG4gICAgICB3OiBmdW5jdGlvbihkKSB7XG4gICAgICAgIHJldHVybiBkLmdldERheSgpO1xuICAgICAgfSxcbiAgICAgIFc6IGZ1bmN0aW9uKGQsIHApIHtcbiAgICAgICAgcmV0dXJuIGQzX3RpbWVfZm9ybWF0UGFkKGQzX3RpbWUubW9uZGF5T2ZZZWFyKGQpLCBwLCAyKTtcbiAgICAgIH0sXG4gICAgICB4OiBkM190aW1lX2Zvcm1hdChsb2NhbGVfZGF0ZSksXG4gICAgICBYOiBkM190aW1lX2Zvcm1hdChsb2NhbGVfdGltZSksXG4gICAgICB5OiBmdW5jdGlvbihkLCBwKSB7XG4gICAgICAgIHJldHVybiBkM190aW1lX2Zvcm1hdFBhZChkLmdldEZ1bGxZZWFyKCkgJSAxMDAsIHAsIDIpO1xuICAgICAgfSxcbiAgICAgIFk6IGZ1bmN0aW9uKGQsIHApIHtcbiAgICAgICAgcmV0dXJuIGQzX3RpbWVfZm9ybWF0UGFkKGQuZ2V0RnVsbFllYXIoKSAlIDFlNCwgcCwgNCk7XG4gICAgICB9LFxuICAgICAgWjogZDNfdGltZV96b25lLFxuICAgICAgXCIlXCI6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gXCIlXCI7XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgZDNfdGltZV9wYXJzZXJzID0ge1xuICAgICAgYTogZDNfdGltZV9wYXJzZVdlZWtkYXlBYmJyZXYsXG4gICAgICBBOiBkM190aW1lX3BhcnNlV2Vla2RheSxcbiAgICAgIGI6IGQzX3RpbWVfcGFyc2VNb250aEFiYnJldixcbiAgICAgIEI6IGQzX3RpbWVfcGFyc2VNb250aCxcbiAgICAgIGM6IGQzX3RpbWVfcGFyc2VMb2NhbGVGdWxsLFxuICAgICAgZDogZDNfdGltZV9wYXJzZURheSxcbiAgICAgIGU6IGQzX3RpbWVfcGFyc2VEYXksXG4gICAgICBIOiBkM190aW1lX3BhcnNlSG91cjI0LFxuICAgICAgSTogZDNfdGltZV9wYXJzZUhvdXIyNCxcbiAgICAgIGo6IGQzX3RpbWVfcGFyc2VEYXlPZlllYXIsXG4gICAgICBMOiBkM190aW1lX3BhcnNlTWlsbGlzZWNvbmRzLFxuICAgICAgbTogZDNfdGltZV9wYXJzZU1vbnRoTnVtYmVyLFxuICAgICAgTTogZDNfdGltZV9wYXJzZU1pbnV0ZXMsXG4gICAgICBwOiBkM190aW1lX3BhcnNlQW1QbSxcbiAgICAgIFM6IGQzX3RpbWVfcGFyc2VTZWNvbmRzLFxuICAgICAgVTogZDNfdGltZV9wYXJzZVdlZWtOdW1iZXJTdW5kYXksXG4gICAgICB3OiBkM190aW1lX3BhcnNlV2Vla2RheU51bWJlcixcbiAgICAgIFc6IGQzX3RpbWVfcGFyc2VXZWVrTnVtYmVyTW9uZGF5LFxuICAgICAgeDogZDNfdGltZV9wYXJzZUxvY2FsZURhdGUsXG4gICAgICBYOiBkM190aW1lX3BhcnNlTG9jYWxlVGltZSxcbiAgICAgIHk6IGQzX3RpbWVfcGFyc2VZZWFyLFxuICAgICAgWTogZDNfdGltZV9wYXJzZUZ1bGxZZWFyLFxuICAgICAgWjogZDNfdGltZV9wYXJzZVpvbmUsXG4gICAgICBcIiVcIjogZDNfdGltZV9wYXJzZUxpdGVyYWxQZXJjZW50XG4gICAgfTtcbiAgICBmdW5jdGlvbiBkM190aW1lX3BhcnNlV2Vla2RheUFiYnJldihkYXRlLCBzdHJpbmcsIGkpIHtcbiAgICAgIGQzX3RpbWVfZGF5QWJicmV2UmUubGFzdEluZGV4ID0gMDtcbiAgICAgIHZhciBuID0gZDNfdGltZV9kYXlBYmJyZXZSZS5leGVjKHN0cmluZy5zbGljZShpKSk7XG4gICAgICByZXR1cm4gbiA/IChkYXRlLncgPSBkM190aW1lX2RheUFiYnJldkxvb2t1cC5nZXQoblswXS50b0xvd2VyQ2FzZSgpKSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkM190aW1lX3BhcnNlV2Vla2RheShkYXRlLCBzdHJpbmcsIGkpIHtcbiAgICAgIGQzX3RpbWVfZGF5UmUubGFzdEluZGV4ID0gMDtcbiAgICAgIHZhciBuID0gZDNfdGltZV9kYXlSZS5leGVjKHN0cmluZy5zbGljZShpKSk7XG4gICAgICByZXR1cm4gbiA/IChkYXRlLncgPSBkM190aW1lX2RheUxvb2t1cC5nZXQoblswXS50b0xvd2VyQ2FzZSgpKSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkM190aW1lX3BhcnNlTW9udGhBYmJyZXYoZGF0ZSwgc3RyaW5nLCBpKSB7XG4gICAgICBkM190aW1lX21vbnRoQWJicmV2UmUubGFzdEluZGV4ID0gMDtcbiAgICAgIHZhciBuID0gZDNfdGltZV9tb250aEFiYnJldlJlLmV4ZWMoc3RyaW5nLnNsaWNlKGkpKTtcbiAgICAgIHJldHVybiBuID8gKGRhdGUubSA9IGQzX3RpbWVfbW9udGhBYmJyZXZMb29rdXAuZ2V0KG5bMF0udG9Mb3dlckNhc2UoKSksIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZDNfdGltZV9wYXJzZU1vbnRoKGRhdGUsIHN0cmluZywgaSkge1xuICAgICAgZDNfdGltZV9tb250aFJlLmxhc3RJbmRleCA9IDA7XG4gICAgICB2YXIgbiA9IGQzX3RpbWVfbW9udGhSZS5leGVjKHN0cmluZy5zbGljZShpKSk7XG4gICAgICByZXR1cm4gbiA/IChkYXRlLm0gPSBkM190aW1lX21vbnRoTG9va3VwLmdldChuWzBdLnRvTG93ZXJDYXNlKCkpLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGQzX3RpbWVfcGFyc2VMb2NhbGVGdWxsKGRhdGUsIHN0cmluZywgaSkge1xuICAgICAgcmV0dXJuIGQzX3RpbWVfcGFyc2UoZGF0ZSwgZDNfdGltZV9mb3JtYXRzLmMudG9TdHJpbmcoKSwgc3RyaW5nLCBpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZDNfdGltZV9wYXJzZUxvY2FsZURhdGUoZGF0ZSwgc3RyaW5nLCBpKSB7XG4gICAgICByZXR1cm4gZDNfdGltZV9wYXJzZShkYXRlLCBkM190aW1lX2Zvcm1hdHMueC50b1N0cmluZygpLCBzdHJpbmcsIGkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkM190aW1lX3BhcnNlTG9jYWxlVGltZShkYXRlLCBzdHJpbmcsIGkpIHtcbiAgICAgIHJldHVybiBkM190aW1lX3BhcnNlKGRhdGUsIGQzX3RpbWVfZm9ybWF0cy5YLnRvU3RyaW5nKCksIHN0cmluZywgaSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGQzX3RpbWVfcGFyc2VBbVBtKGRhdGUsIHN0cmluZywgaSkge1xuICAgICAgdmFyIG4gPSBkM190aW1lX3BlcmlvZExvb2t1cC5nZXQoc3RyaW5nLnNsaWNlKGksIGkgKz0gMikudG9Mb3dlckNhc2UoKSk7XG4gICAgICByZXR1cm4gbiA9PSBudWxsID8gLTEgOiAoZGF0ZS5wID0gbiwgaSk7XG4gICAgfVxuICAgIHJldHVybiBkM190aW1lX2Zvcm1hdDtcbiAgfVxuICB2YXIgZDNfdGltZV9mb3JtYXRQYWRzID0ge1xuICAgIFwiLVwiOiBcIlwiLFxuICAgIF86IFwiIFwiLFxuICAgIFwiMFwiOiBcIjBcIlxuICB9LCBkM190aW1lX251bWJlclJlID0gL15cXHMqXFxkKy8sIGQzX3RpbWVfcGVyY2VudFJlID0gL14lLztcbiAgZnVuY3Rpb24gZDNfdGltZV9mb3JtYXRQYWQodmFsdWUsIGZpbGwsIHdpZHRoKSB7XG4gICAgdmFyIHNpZ24gPSB2YWx1ZSA8IDAgPyBcIi1cIiA6IFwiXCIsIHN0cmluZyA9IChzaWduID8gLXZhbHVlIDogdmFsdWUpICsgXCJcIiwgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcbiAgICByZXR1cm4gc2lnbiArIChsZW5ndGggPCB3aWR0aCA/IG5ldyBBcnJheSh3aWR0aCAtIGxlbmd0aCArIDEpLmpvaW4oZmlsbCkgKyBzdHJpbmcgOiBzdHJpbmcpO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3RpbWVfZm9ybWF0UmUobmFtZXMpIHtcbiAgICByZXR1cm4gbmV3IFJlZ0V4cChcIl4oPzpcIiArIG5hbWVzLm1hcChkMy5yZXF1b3RlKS5qb2luKFwifFwiKSArIFwiKVwiLCBcImlcIik7XG4gIH1cbiAgZnVuY3Rpb24gZDNfdGltZV9mb3JtYXRMb29rdXAobmFtZXMpIHtcbiAgICB2YXIgbWFwID0gbmV3IGQzX01hcCgpLCBpID0gLTEsIG4gPSBuYW1lcy5sZW5ndGg7XG4gICAgd2hpbGUgKCsraSA8IG4pIG1hcC5zZXQobmFtZXNbaV0udG9Mb3dlckNhc2UoKSwgaSk7XG4gICAgcmV0dXJuIG1hcDtcbiAgfVxuICBmdW5jdGlvbiBkM190aW1lX3BhcnNlV2Vla2RheU51bWJlcihkYXRlLCBzdHJpbmcsIGkpIHtcbiAgICBkM190aW1lX251bWJlclJlLmxhc3RJbmRleCA9IDA7XG4gICAgdmFyIG4gPSBkM190aW1lX251bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyAxKSk7XG4gICAgcmV0dXJuIG4gPyAoZGF0ZS53ID0gK25bMF0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbiAgfVxuICBmdW5jdGlvbiBkM190aW1lX3BhcnNlV2Vla051bWJlclN1bmRheShkYXRlLCBzdHJpbmcsIGkpIHtcbiAgICBkM190aW1lX251bWJlclJlLmxhc3RJbmRleCA9IDA7XG4gICAgdmFyIG4gPSBkM190aW1lX251bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGkpKTtcbiAgICByZXR1cm4gbiA/IChkYXRlLlUgPSArblswXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3RpbWVfcGFyc2VXZWVrTnVtYmVyTW9uZGF5KGRhdGUsIHN0cmluZywgaSkge1xuICAgIGQzX3RpbWVfbnVtYmVyUmUubGFzdEluZGV4ID0gMDtcbiAgICB2YXIgbiA9IGQzX3RpbWVfbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSkpO1xuICAgIHJldHVybiBuID8gKGRhdGUuVyA9ICtuWzBdLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG4gIH1cbiAgZnVuY3Rpb24gZDNfdGltZV9wYXJzZUZ1bGxZZWFyKGRhdGUsIHN0cmluZywgaSkge1xuICAgIGQzX3RpbWVfbnVtYmVyUmUubGFzdEluZGV4ID0gMDtcbiAgICB2YXIgbiA9IGQzX3RpbWVfbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDQpKTtcbiAgICByZXR1cm4gbiA/IChkYXRlLnkgPSArblswXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3RpbWVfcGFyc2VZZWFyKGRhdGUsIHN0cmluZywgaSkge1xuICAgIGQzX3RpbWVfbnVtYmVyUmUubGFzdEluZGV4ID0gMDtcbiAgICB2YXIgbiA9IGQzX3RpbWVfbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDIpKTtcbiAgICByZXR1cm4gbiA/IChkYXRlLnkgPSBkM190aW1lX2V4cGFuZFllYXIoK25bMF0pLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG4gIH1cbiAgZnVuY3Rpb24gZDNfdGltZV9wYXJzZVpvbmUoZGF0ZSwgc3RyaW5nLCBpKSB7XG4gICAgcmV0dXJuIC9eWystXVxcZHs0fSQvLnRlc3Qoc3RyaW5nID0gc3RyaW5nLnNsaWNlKGksIGkgKyA1KSkgPyAoZGF0ZS5aID0gLXN0cmluZywgXG4gICAgaSArIDUpIDogLTE7XG4gIH1cbiAgZnVuY3Rpb24gZDNfdGltZV9leHBhbmRZZWFyKGQpIHtcbiAgICByZXR1cm4gZCArIChkID4gNjggPyAxOTAwIDogMmUzKTtcbiAgfVxuICBmdW5jdGlvbiBkM190aW1lX3BhcnNlTW9udGhOdW1iZXIoZGF0ZSwgc3RyaW5nLCBpKSB7XG4gICAgZDNfdGltZV9udW1iZXJSZS5sYXN0SW5kZXggPSAwO1xuICAgIHZhciBuID0gZDNfdGltZV9udW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgMikpO1xuICAgIHJldHVybiBuID8gKGRhdGUubSA9IG5bMF0gLSAxLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG4gIH1cbiAgZnVuY3Rpb24gZDNfdGltZV9wYXJzZURheShkYXRlLCBzdHJpbmcsIGkpIHtcbiAgICBkM190aW1lX251bWJlclJlLmxhc3RJbmRleCA9IDA7XG4gICAgdmFyIG4gPSBkM190aW1lX251bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyAyKSk7XG4gICAgcmV0dXJuIG4gPyAoZGF0ZS5kID0gK25bMF0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbiAgfVxuICBmdW5jdGlvbiBkM190aW1lX3BhcnNlRGF5T2ZZZWFyKGRhdGUsIHN0cmluZywgaSkge1xuICAgIGQzX3RpbWVfbnVtYmVyUmUubGFzdEluZGV4ID0gMDtcbiAgICB2YXIgbiA9IGQzX3RpbWVfbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDMpKTtcbiAgICByZXR1cm4gbiA/IChkYXRlLmogPSArblswXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3RpbWVfcGFyc2VIb3VyMjQoZGF0ZSwgc3RyaW5nLCBpKSB7XG4gICAgZDNfdGltZV9udW1iZXJSZS5sYXN0SW5kZXggPSAwO1xuICAgIHZhciBuID0gZDNfdGltZV9udW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgMikpO1xuICAgIHJldHVybiBuID8gKGRhdGUuSCA9ICtuWzBdLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG4gIH1cbiAgZnVuY3Rpb24gZDNfdGltZV9wYXJzZU1pbnV0ZXMoZGF0ZSwgc3RyaW5nLCBpKSB7XG4gICAgZDNfdGltZV9udW1iZXJSZS5sYXN0SW5kZXggPSAwO1xuICAgIHZhciBuID0gZDNfdGltZV9udW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgMikpO1xuICAgIHJldHVybiBuID8gKGRhdGUuTSA9ICtuWzBdLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG4gIH1cbiAgZnVuY3Rpb24gZDNfdGltZV9wYXJzZVNlY29uZHMoZGF0ZSwgc3RyaW5nLCBpKSB7XG4gICAgZDNfdGltZV9udW1iZXJSZS5sYXN0SW5kZXggPSAwO1xuICAgIHZhciBuID0gZDNfdGltZV9udW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgMikpO1xuICAgIHJldHVybiBuID8gKGRhdGUuUyA9ICtuWzBdLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG4gIH1cbiAgZnVuY3Rpb24gZDNfdGltZV9wYXJzZU1pbGxpc2Vjb25kcyhkYXRlLCBzdHJpbmcsIGkpIHtcbiAgICBkM190aW1lX251bWJlclJlLmxhc3RJbmRleCA9IDA7XG4gICAgdmFyIG4gPSBkM190aW1lX251bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyAzKSk7XG4gICAgcmV0dXJuIG4gPyAoZGF0ZS5MID0gK25bMF0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbiAgfVxuICBmdW5jdGlvbiBkM190aW1lX3pvbmUoZCkge1xuICAgIHZhciB6ID0gZC5nZXRUaW1lem9uZU9mZnNldCgpLCB6cyA9IHogPiAwID8gXCItXCIgOiBcIitcIiwgemggPSBhYnMoeikgLyA2MCB8IDAsIHptID0gYWJzKHopICUgNjA7XG4gICAgcmV0dXJuIHpzICsgZDNfdGltZV9mb3JtYXRQYWQoemgsIFwiMFwiLCAyKSArIGQzX3RpbWVfZm9ybWF0UGFkKHptLCBcIjBcIiwgMik7XG4gIH1cbiAgZnVuY3Rpb24gZDNfdGltZV9wYXJzZUxpdGVyYWxQZXJjZW50KGRhdGUsIHN0cmluZywgaSkge1xuICAgIGQzX3RpbWVfcGVyY2VudFJlLmxhc3RJbmRleCA9IDA7XG4gICAgdmFyIG4gPSBkM190aW1lX3BlcmNlbnRSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgMSkpO1xuICAgIHJldHVybiBuID8gaSArIG5bMF0ubGVuZ3RoIDogLTE7XG4gIH1cbiAgZnVuY3Rpb24gZDNfdGltZV9mb3JtYXRNdWx0aShmb3JtYXRzKSB7XG4gICAgdmFyIG4gPSBmb3JtYXRzLmxlbmd0aCwgaSA9IC0xO1xuICAgIHdoaWxlICgrK2kgPCBuKSBmb3JtYXRzW2ldWzBdID0gdGhpcyhmb3JtYXRzW2ldWzBdKTtcbiAgICByZXR1cm4gZnVuY3Rpb24oZGF0ZSkge1xuICAgICAgdmFyIGkgPSAwLCBmID0gZm9ybWF0c1tpXTtcbiAgICAgIHdoaWxlICghZlsxXShkYXRlKSkgZiA9IGZvcm1hdHNbKytpXTtcbiAgICAgIHJldHVybiBmWzBdKGRhdGUpO1xuICAgIH07XG4gIH1cbiAgZDMubG9jYWxlID0gZnVuY3Rpb24obG9jYWxlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG51bWJlckZvcm1hdDogZDNfbG9jYWxlX251bWJlckZvcm1hdChsb2NhbGUpLFxuICAgICAgdGltZUZvcm1hdDogZDNfbG9jYWxlX3RpbWVGb3JtYXQobG9jYWxlKVxuICAgIH07XG4gIH07XG4gIHZhciBkM19sb2NhbGVfZW5VUyA9IGQzLmxvY2FsZSh7XG4gICAgZGVjaW1hbDogXCIuXCIsXG4gICAgdGhvdXNhbmRzOiBcIixcIixcbiAgICBncm91cGluZzogWyAzIF0sXG4gICAgY3VycmVuY3k6IFsgXCIkXCIsIFwiXCIgXSxcbiAgICBkYXRlVGltZTogXCIlYSAlYiAlZSAlWCAlWVwiLFxuICAgIGRhdGU6IFwiJW0vJWQvJVlcIixcbiAgICB0aW1lOiBcIiVIOiVNOiVTXCIsXG4gICAgcGVyaW9kczogWyBcIkFNXCIsIFwiUE1cIiBdLFxuICAgIGRheXM6IFsgXCJTdW5kYXlcIiwgXCJNb25kYXlcIiwgXCJUdWVzZGF5XCIsIFwiV2VkbmVzZGF5XCIsIFwiVGh1cnNkYXlcIiwgXCJGcmlkYXlcIiwgXCJTYXR1cmRheVwiIF0sXG4gICAgc2hvcnREYXlzOiBbIFwiU3VuXCIsIFwiTW9uXCIsIFwiVHVlXCIsIFwiV2VkXCIsIFwiVGh1XCIsIFwiRnJpXCIsIFwiU2F0XCIgXSxcbiAgICBtb250aHM6IFsgXCJKYW51YXJ5XCIsIFwiRmVicnVhcnlcIiwgXCJNYXJjaFwiLCBcIkFwcmlsXCIsIFwiTWF5XCIsIFwiSnVuZVwiLCBcIkp1bHlcIiwgXCJBdWd1c3RcIiwgXCJTZXB0ZW1iZXJcIiwgXCJPY3RvYmVyXCIsIFwiTm92ZW1iZXJcIiwgXCJEZWNlbWJlclwiIF0sXG4gICAgc2hvcnRNb250aHM6IFsgXCJKYW5cIiwgXCJGZWJcIiwgXCJNYXJcIiwgXCJBcHJcIiwgXCJNYXlcIiwgXCJKdW5cIiwgXCJKdWxcIiwgXCJBdWdcIiwgXCJTZXBcIiwgXCJPY3RcIiwgXCJOb3ZcIiwgXCJEZWNcIiBdXG4gIH0pO1xuICBkMy5mb3JtYXQgPSBkM19sb2NhbGVfZW5VUy5udW1iZXJGb3JtYXQ7XG4gIGQzLmdlbyA9IHt9O1xuICBmdW5jdGlvbiBkM19hZGRlcigpIHt9XG4gIGQzX2FkZGVyLnByb3RvdHlwZSA9IHtcbiAgICBzOiAwLFxuICAgIHQ6IDAsXG4gICAgYWRkOiBmdW5jdGlvbih5KSB7XG4gICAgICBkM19hZGRlclN1bSh5LCB0aGlzLnQsIGQzX2FkZGVyVGVtcCk7XG4gICAgICBkM19hZGRlclN1bShkM19hZGRlclRlbXAucywgdGhpcy5zLCB0aGlzKTtcbiAgICAgIGlmICh0aGlzLnMpIHRoaXMudCArPSBkM19hZGRlclRlbXAudDsgZWxzZSB0aGlzLnMgPSBkM19hZGRlclRlbXAudDtcbiAgICB9LFxuICAgIHJlc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMucyA9IHRoaXMudCA9IDA7XG4gICAgfSxcbiAgICB2YWx1ZU9mOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnM7XG4gICAgfVxuICB9O1xuICB2YXIgZDNfYWRkZXJUZW1wID0gbmV3IGQzX2FkZGVyKCk7XG4gIGZ1bmN0aW9uIGQzX2FkZGVyU3VtKGEsIGIsIG8pIHtcbiAgICB2YXIgeCA9IG8ucyA9IGEgKyBiLCBidiA9IHggLSBhLCBhdiA9IHggLSBidjtcbiAgICBvLnQgPSBhIC0gYXYgKyAoYiAtIGJ2KTtcbiAgfVxuICBkMy5nZW8uc3RyZWFtID0gZnVuY3Rpb24ob2JqZWN0LCBsaXN0ZW5lcikge1xuICAgIGlmIChvYmplY3QgJiYgZDNfZ2VvX3N0cmVhbU9iamVjdFR5cGUuaGFzT3duUHJvcGVydHkob2JqZWN0LnR5cGUpKSB7XG4gICAgICBkM19nZW9fc3RyZWFtT2JqZWN0VHlwZVtvYmplY3QudHlwZV0ob2JqZWN0LCBsaXN0ZW5lcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGQzX2dlb19zdHJlYW1HZW9tZXRyeShvYmplY3QsIGxpc3RlbmVyKTtcbiAgICB9XG4gIH07XG4gIGZ1bmN0aW9uIGQzX2dlb19zdHJlYW1HZW9tZXRyeShnZW9tZXRyeSwgbGlzdGVuZXIpIHtcbiAgICBpZiAoZ2VvbWV0cnkgJiYgZDNfZ2VvX3N0cmVhbUdlb21ldHJ5VHlwZS5oYXNPd25Qcm9wZXJ0eShnZW9tZXRyeS50eXBlKSkge1xuICAgICAgZDNfZ2VvX3N0cmVhbUdlb21ldHJ5VHlwZVtnZW9tZXRyeS50eXBlXShnZW9tZXRyeSwgbGlzdGVuZXIpO1xuICAgIH1cbiAgfVxuICB2YXIgZDNfZ2VvX3N0cmVhbU9iamVjdFR5cGUgPSB7XG4gICAgRmVhdHVyZTogZnVuY3Rpb24oZmVhdHVyZSwgbGlzdGVuZXIpIHtcbiAgICAgIGQzX2dlb19zdHJlYW1HZW9tZXRyeShmZWF0dXJlLmdlb21ldHJ5LCBsaXN0ZW5lcik7XG4gICAgfSxcbiAgICBGZWF0dXJlQ29sbGVjdGlvbjogZnVuY3Rpb24ob2JqZWN0LCBsaXN0ZW5lcikge1xuICAgICAgdmFyIGZlYXR1cmVzID0gb2JqZWN0LmZlYXR1cmVzLCBpID0gLTEsIG4gPSBmZWF0dXJlcy5sZW5ndGg7XG4gICAgICB3aGlsZSAoKytpIDwgbikgZDNfZ2VvX3N0cmVhbUdlb21ldHJ5KGZlYXR1cmVzW2ldLmdlb21ldHJ5LCBsaXN0ZW5lcik7XG4gICAgfVxuICB9O1xuICB2YXIgZDNfZ2VvX3N0cmVhbUdlb21ldHJ5VHlwZSA9IHtcbiAgICBTcGhlcmU6IGZ1bmN0aW9uKG9iamVjdCwgbGlzdGVuZXIpIHtcbiAgICAgIGxpc3RlbmVyLnNwaGVyZSgpO1xuICAgIH0sXG4gICAgUG9pbnQ6IGZ1bmN0aW9uKG9iamVjdCwgbGlzdGVuZXIpIHtcbiAgICAgIG9iamVjdCA9IG9iamVjdC5jb29yZGluYXRlcztcbiAgICAgIGxpc3RlbmVyLnBvaW50KG9iamVjdFswXSwgb2JqZWN0WzFdLCBvYmplY3RbMl0pO1xuICAgIH0sXG4gICAgTXVsdGlQb2ludDogZnVuY3Rpb24ob2JqZWN0LCBsaXN0ZW5lcikge1xuICAgICAgdmFyIGNvb3JkaW5hdGVzID0gb2JqZWN0LmNvb3JkaW5hdGVzLCBpID0gLTEsIG4gPSBjb29yZGluYXRlcy5sZW5ndGg7XG4gICAgICB3aGlsZSAoKytpIDwgbikgb2JqZWN0ID0gY29vcmRpbmF0ZXNbaV0sIGxpc3RlbmVyLnBvaW50KG9iamVjdFswXSwgb2JqZWN0WzFdLCBvYmplY3RbMl0pO1xuICAgIH0sXG4gICAgTGluZVN0cmluZzogZnVuY3Rpb24ob2JqZWN0LCBsaXN0ZW5lcikge1xuICAgICAgZDNfZ2VvX3N0cmVhbUxpbmUob2JqZWN0LmNvb3JkaW5hdGVzLCBsaXN0ZW5lciwgMCk7XG4gICAgfSxcbiAgICBNdWx0aUxpbmVTdHJpbmc6IGZ1bmN0aW9uKG9iamVjdCwgbGlzdGVuZXIpIHtcbiAgICAgIHZhciBjb29yZGluYXRlcyA9IG9iamVjdC5jb29yZGluYXRlcywgaSA9IC0xLCBuID0gY29vcmRpbmF0ZXMubGVuZ3RoO1xuICAgICAgd2hpbGUgKCsraSA8IG4pIGQzX2dlb19zdHJlYW1MaW5lKGNvb3JkaW5hdGVzW2ldLCBsaXN0ZW5lciwgMCk7XG4gICAgfSxcbiAgICBQb2x5Z29uOiBmdW5jdGlvbihvYmplY3QsIGxpc3RlbmVyKSB7XG4gICAgICBkM19nZW9fc3RyZWFtUG9seWdvbihvYmplY3QuY29vcmRpbmF0ZXMsIGxpc3RlbmVyKTtcbiAgICB9LFxuICAgIE11bHRpUG9seWdvbjogZnVuY3Rpb24ob2JqZWN0LCBsaXN0ZW5lcikge1xuICAgICAgdmFyIGNvb3JkaW5hdGVzID0gb2JqZWN0LmNvb3JkaW5hdGVzLCBpID0gLTEsIG4gPSBjb29yZGluYXRlcy5sZW5ndGg7XG4gICAgICB3aGlsZSAoKytpIDwgbikgZDNfZ2VvX3N0cmVhbVBvbHlnb24oY29vcmRpbmF0ZXNbaV0sIGxpc3RlbmVyKTtcbiAgICB9LFxuICAgIEdlb21ldHJ5Q29sbGVjdGlvbjogZnVuY3Rpb24ob2JqZWN0LCBsaXN0ZW5lcikge1xuICAgICAgdmFyIGdlb21ldHJpZXMgPSBvYmplY3QuZ2VvbWV0cmllcywgaSA9IC0xLCBuID0gZ2VvbWV0cmllcy5sZW5ndGg7XG4gICAgICB3aGlsZSAoKytpIDwgbikgZDNfZ2VvX3N0cmVhbUdlb21ldHJ5KGdlb21ldHJpZXNbaV0sIGxpc3RlbmVyKTtcbiAgICB9XG4gIH07XG4gIGZ1bmN0aW9uIGQzX2dlb19zdHJlYW1MaW5lKGNvb3JkaW5hdGVzLCBsaXN0ZW5lciwgY2xvc2VkKSB7XG4gICAgdmFyIGkgPSAtMSwgbiA9IGNvb3JkaW5hdGVzLmxlbmd0aCAtIGNsb3NlZCwgY29vcmRpbmF0ZTtcbiAgICBsaXN0ZW5lci5saW5lU3RhcnQoKTtcbiAgICB3aGlsZSAoKytpIDwgbikgY29vcmRpbmF0ZSA9IGNvb3JkaW5hdGVzW2ldLCBsaXN0ZW5lci5wb2ludChjb29yZGluYXRlWzBdLCBjb29yZGluYXRlWzFdLCBjb29yZGluYXRlWzJdKTtcbiAgICBsaXN0ZW5lci5saW5lRW5kKCk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvX3N0cmVhbVBvbHlnb24oY29vcmRpbmF0ZXMsIGxpc3RlbmVyKSB7XG4gICAgdmFyIGkgPSAtMSwgbiA9IGNvb3JkaW5hdGVzLmxlbmd0aDtcbiAgICBsaXN0ZW5lci5wb2x5Z29uU3RhcnQoKTtcbiAgICB3aGlsZSAoKytpIDwgbikgZDNfZ2VvX3N0cmVhbUxpbmUoY29vcmRpbmF0ZXNbaV0sIGxpc3RlbmVyLCAxKTtcbiAgICBsaXN0ZW5lci5wb2x5Z29uRW5kKCk7XG4gIH1cbiAgZDMuZ2VvLmFyZWEgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICBkM19nZW9fYXJlYVN1bSA9IDA7XG4gICAgZDMuZ2VvLnN0cmVhbShvYmplY3QsIGQzX2dlb19hcmVhKTtcbiAgICByZXR1cm4gZDNfZ2VvX2FyZWFTdW07XG4gIH07XG4gIHZhciBkM19nZW9fYXJlYVN1bSwgZDNfZ2VvX2FyZWFSaW5nU3VtID0gbmV3IGQzX2FkZGVyKCk7XG4gIHZhciBkM19nZW9fYXJlYSA9IHtcbiAgICBzcGhlcmU6IGZ1bmN0aW9uKCkge1xuICAgICAgZDNfZ2VvX2FyZWFTdW0gKz0gNCAqIM+AO1xuICAgIH0sXG4gICAgcG9pbnQ6IGQzX25vb3AsXG4gICAgbGluZVN0YXJ0OiBkM19ub29wLFxuICAgIGxpbmVFbmQ6IGQzX25vb3AsXG4gICAgcG9seWdvblN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgIGQzX2dlb19hcmVhUmluZ1N1bS5yZXNldCgpO1xuICAgICAgZDNfZ2VvX2FyZWEubGluZVN0YXJ0ID0gZDNfZ2VvX2FyZWFSaW5nU3RhcnQ7XG4gICAgfSxcbiAgICBwb2x5Z29uRW5kOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBhcmVhID0gMiAqIGQzX2dlb19hcmVhUmluZ1N1bTtcbiAgICAgIGQzX2dlb19hcmVhU3VtICs9IGFyZWEgPCAwID8gNCAqIM+AICsgYXJlYSA6IGFyZWE7XG4gICAgICBkM19nZW9fYXJlYS5saW5lU3RhcnQgPSBkM19nZW9fYXJlYS5saW5lRW5kID0gZDNfZ2VvX2FyZWEucG9pbnQgPSBkM19ub29wO1xuICAgIH1cbiAgfTtcbiAgZnVuY3Rpb24gZDNfZ2VvX2FyZWFSaW5nU3RhcnQoKSB7XG4gICAgdmFyIM67MDAsIM+GMDAsIM67MCwgY29zz4YwLCBzaW7PhjA7XG4gICAgZDNfZ2VvX2FyZWEucG9pbnQgPSBmdW5jdGlvbijOuywgz4YpIHtcbiAgICAgIGQzX2dlb19hcmVhLnBvaW50ID0gbmV4dFBvaW50O1xuICAgICAgzrswID0gKM67MDAgPSDOuykgKiBkM19yYWRpYW5zLCBjb3PPhjAgPSBNYXRoLmNvcyjPhiA9ICjPhjAwID0gz4YpICogZDNfcmFkaWFucyAvIDIgKyDPgCAvIDQpLCBcbiAgICAgIHNpbs+GMCA9IE1hdGguc2luKM+GKTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIG5leHRQb2ludCjOuywgz4YpIHtcbiAgICAgIM67ICo9IGQzX3JhZGlhbnM7XG4gICAgICDPhiA9IM+GICogZDNfcmFkaWFucyAvIDIgKyDPgCAvIDQ7XG4gICAgICB2YXIgZM67ID0gzrsgLSDOuzAsIHNkzrsgPSBkzrsgPj0gMCA/IDEgOiAtMSwgYWTOuyA9IHNkzrsgKiBkzrssIGNvc8+GID0gTWF0aC5jb3Moz4YpLCBzaW7PhiA9IE1hdGguc2luKM+GKSwgayA9IHNpbs+GMCAqIHNpbs+GLCB1ID0gY29zz4YwICogY29zz4YgKyBrICogTWF0aC5jb3MoYWTOuyksIHYgPSBrICogc2TOuyAqIE1hdGguc2luKGFkzrspO1xuICAgICAgZDNfZ2VvX2FyZWFSaW5nU3VtLmFkZChNYXRoLmF0YW4yKHYsIHUpKTtcbiAgICAgIM67MCA9IM67LCBjb3PPhjAgPSBjb3PPhiwgc2luz4YwID0gc2luz4Y7XG4gICAgfVxuICAgIGQzX2dlb19hcmVhLmxpbmVFbmQgPSBmdW5jdGlvbigpIHtcbiAgICAgIG5leHRQb2ludCjOuzAwLCDPhjAwKTtcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb19jYXJ0ZXNpYW4oc3BoZXJpY2FsKSB7XG4gICAgdmFyIM67ID0gc3BoZXJpY2FsWzBdLCDPhiA9IHNwaGVyaWNhbFsxXSwgY29zz4YgPSBNYXRoLmNvcyjPhik7XG4gICAgcmV0dXJuIFsgY29zz4YgKiBNYXRoLmNvcyjOuyksIGNvc8+GICogTWF0aC5zaW4ozrspLCBNYXRoLnNpbijPhikgXTtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9fY2FydGVzaWFuRG90KGEsIGIpIHtcbiAgICByZXR1cm4gYVswXSAqIGJbMF0gKyBhWzFdICogYlsxXSArIGFbMl0gKiBiWzJdO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb19jYXJ0ZXNpYW5Dcm9zcyhhLCBiKSB7XG4gICAgcmV0dXJuIFsgYVsxXSAqIGJbMl0gLSBhWzJdICogYlsxXSwgYVsyXSAqIGJbMF0gLSBhWzBdICogYlsyXSwgYVswXSAqIGJbMV0gLSBhWzFdICogYlswXSBdO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb19jYXJ0ZXNpYW5BZGQoYSwgYikge1xuICAgIGFbMF0gKz0gYlswXTtcbiAgICBhWzFdICs9IGJbMV07XG4gICAgYVsyXSArPSBiWzJdO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb19jYXJ0ZXNpYW5TY2FsZSh2ZWN0b3IsIGspIHtcbiAgICByZXR1cm4gWyB2ZWN0b3JbMF0gKiBrLCB2ZWN0b3JbMV0gKiBrLCB2ZWN0b3JbMl0gKiBrIF07XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvX2NhcnRlc2lhbk5vcm1hbGl6ZShkKSB7XG4gICAgdmFyIGwgPSBNYXRoLnNxcnQoZFswXSAqIGRbMF0gKyBkWzFdICogZFsxXSArIGRbMl0gKiBkWzJdKTtcbiAgICBkWzBdIC89IGw7XG4gICAgZFsxXSAvPSBsO1xuICAgIGRbMl0gLz0gbDtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9fc3BoZXJpY2FsKGNhcnRlc2lhbikge1xuICAgIHJldHVybiBbIE1hdGguYXRhbjIoY2FydGVzaWFuWzFdLCBjYXJ0ZXNpYW5bMF0pLCBkM19hc2luKGNhcnRlc2lhblsyXSkgXTtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9fc3BoZXJpY2FsRXF1YWwoYSwgYikge1xuICAgIHJldHVybiBhYnMoYVswXSAtIGJbMF0pIDwgzrUgJiYgYWJzKGFbMV0gLSBiWzFdKSA8IM61O1xuICB9XG4gIGQzLmdlby5ib3VuZHMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgzrswLCDPhjAsIM67MSwgz4YxLCDOu18sIM67X18sIM+GX18sIHAwLCBkzrtTdW0sIHJhbmdlcywgcmFuZ2U7XG4gICAgdmFyIGJvdW5kID0ge1xuICAgICAgcG9pbnQ6IHBvaW50LFxuICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXG4gICAgICBsaW5lRW5kOiBsaW5lRW5kLFxuICAgICAgcG9seWdvblN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgYm91bmQucG9pbnQgPSByaW5nUG9pbnQ7XG4gICAgICAgIGJvdW5kLmxpbmVTdGFydCA9IHJpbmdTdGFydDtcbiAgICAgICAgYm91bmQubGluZUVuZCA9IHJpbmdFbmQ7XG4gICAgICAgIGTOu1N1bSA9IDA7XG4gICAgICAgIGQzX2dlb19hcmVhLnBvbHlnb25TdGFydCgpO1xuICAgICAgfSxcbiAgICAgIHBvbHlnb25FbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBkM19nZW9fYXJlYS5wb2x5Z29uRW5kKCk7XG4gICAgICAgIGJvdW5kLnBvaW50ID0gcG9pbnQ7XG4gICAgICAgIGJvdW5kLmxpbmVTdGFydCA9IGxpbmVTdGFydDtcbiAgICAgICAgYm91bmQubGluZUVuZCA9IGxpbmVFbmQ7XG4gICAgICAgIGlmIChkM19nZW9fYXJlYVJpbmdTdW0gPCAwKSDOuzAgPSAtKM67MSA9IDE4MCksIM+GMCA9IC0oz4YxID0gOTApOyBlbHNlIGlmIChkzrtTdW0gPiDOtSkgz4YxID0gOTA7IGVsc2UgaWYgKGTOu1N1bSA8IC3OtSkgz4YwID0gLTkwO1xuICAgICAgICByYW5nZVswXSA9IM67MCwgcmFuZ2VbMV0gPSDOuzE7XG4gICAgICB9XG4gICAgfTtcbiAgICBmdW5jdGlvbiBwb2ludCjOuywgz4YpIHtcbiAgICAgIHJhbmdlcy5wdXNoKHJhbmdlID0gWyDOuzAgPSDOuywgzrsxID0gzrsgXSk7XG4gICAgICBpZiAoz4YgPCDPhjApIM+GMCA9IM+GO1xuICAgICAgaWYgKM+GID4gz4YxKSDPhjEgPSDPhjtcbiAgICB9XG4gICAgZnVuY3Rpb24gbGluZVBvaW50KM67LCDPhikge1xuICAgICAgdmFyIHAgPSBkM19nZW9fY2FydGVzaWFuKFsgzrsgKiBkM19yYWRpYW5zLCDPhiAqIGQzX3JhZGlhbnMgXSk7XG4gICAgICBpZiAocDApIHtcbiAgICAgICAgdmFyIG5vcm1hbCA9IGQzX2dlb19jYXJ0ZXNpYW5Dcm9zcyhwMCwgcCksIGVxdWF0b3JpYWwgPSBbIG5vcm1hbFsxXSwgLW5vcm1hbFswXSwgMCBdLCBpbmZsZWN0aW9uID0gZDNfZ2VvX2NhcnRlc2lhbkNyb3NzKGVxdWF0b3JpYWwsIG5vcm1hbCk7XG4gICAgICAgIGQzX2dlb19jYXJ0ZXNpYW5Ob3JtYWxpemUoaW5mbGVjdGlvbik7XG4gICAgICAgIGluZmxlY3Rpb24gPSBkM19nZW9fc3BoZXJpY2FsKGluZmxlY3Rpb24pO1xuICAgICAgICB2YXIgZM67ID0gzrsgLSDOu18sIHMgPSBkzrsgPiAwID8gMSA6IC0xLCDOu2kgPSBpbmZsZWN0aW9uWzBdICogZDNfZGVncmVlcyAqIHMsIGFudGltZXJpZGlhbiA9IGFicyhkzrspID4gMTgwO1xuICAgICAgICBpZiAoYW50aW1lcmlkaWFuIF4gKHMgKiDOu18gPCDOu2kgJiYgzrtpIDwgcyAqIM67KSkge1xuICAgICAgICAgIHZhciDPhmkgPSBpbmZsZWN0aW9uWzFdICogZDNfZGVncmVlcztcbiAgICAgICAgICBpZiAoz4ZpID4gz4YxKSDPhjEgPSDPhmk7XG4gICAgICAgIH0gZWxzZSBpZiAozrtpID0gKM67aSArIDM2MCkgJSAzNjAgLSAxODAsIGFudGltZXJpZGlhbiBeIChzICogzrtfIDwgzrtpICYmIM67aSA8IHMgKiDOuykpIHtcbiAgICAgICAgICB2YXIgz4ZpID0gLWluZmxlY3Rpb25bMV0gKiBkM19kZWdyZWVzO1xuICAgICAgICAgIGlmICjPhmkgPCDPhjApIM+GMCA9IM+GaTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoz4YgPCDPhjApIM+GMCA9IM+GO1xuICAgICAgICAgIGlmICjPhiA+IM+GMSkgz4YxID0gz4Y7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFudGltZXJpZGlhbikge1xuICAgICAgICAgIGlmICjOuyA8IM67Xykge1xuICAgICAgICAgICAgaWYgKGFuZ2xlKM67MCwgzrspID4gYW5nbGUozrswLCDOuzEpKSDOuzEgPSDOuztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGFuZ2xlKM67LCDOuzEpID4gYW5nbGUozrswLCDOuzEpKSDOuzAgPSDOuztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKM67MSA+PSDOuzApIHtcbiAgICAgICAgICAgIGlmICjOuyA8IM67MCkgzrswID0gzrs7XG4gICAgICAgICAgICBpZiAozrsgPiDOuzEpIM67MSA9IM67O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAozrsgPiDOu18pIHtcbiAgICAgICAgICAgICAgaWYgKGFuZ2xlKM67MCwgzrspID4gYW5nbGUozrswLCDOuzEpKSDOuzEgPSDOuztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChhbmdsZSjOuywgzrsxKSA+IGFuZ2xlKM67MCwgzrsxKSkgzrswID0gzrs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwb2ludCjOuywgz4YpO1xuICAgICAgfVxuICAgICAgcDAgPSBwLCDOu18gPSDOuztcbiAgICB9XG4gICAgZnVuY3Rpb24gbGluZVN0YXJ0KCkge1xuICAgICAgYm91bmQucG9pbnQgPSBsaW5lUG9pbnQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGxpbmVFbmQoKSB7XG4gICAgICByYW5nZVswXSA9IM67MCwgcmFuZ2VbMV0gPSDOuzE7XG4gICAgICBib3VuZC5wb2ludCA9IHBvaW50O1xuICAgICAgcDAgPSBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiByaW5nUG9pbnQozrssIM+GKSB7XG4gICAgICBpZiAocDApIHtcbiAgICAgICAgdmFyIGTOuyA9IM67IC0gzrtfO1xuICAgICAgICBkzrtTdW0gKz0gYWJzKGTOuykgPiAxODAgPyBkzrsgKyAoZM67ID4gMCA/IDM2MCA6IC0zNjApIDogZM67O1xuICAgICAgfSBlbHNlIM67X18gPSDOuywgz4ZfXyA9IM+GO1xuICAgICAgZDNfZ2VvX2FyZWEucG9pbnQozrssIM+GKTtcbiAgICAgIGxpbmVQb2ludCjOuywgz4YpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByaW5nU3RhcnQoKSB7XG4gICAgICBkM19nZW9fYXJlYS5saW5lU3RhcnQoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmluZ0VuZCgpIHtcbiAgICAgIHJpbmdQb2ludCjOu19fLCDPhl9fKTtcbiAgICAgIGQzX2dlb19hcmVhLmxpbmVFbmQoKTtcbiAgICAgIGlmIChhYnMoZM67U3VtKSA+IM61KSDOuzAgPSAtKM67MSA9IDE4MCk7XG4gICAgICByYW5nZVswXSA9IM67MCwgcmFuZ2VbMV0gPSDOuzE7XG4gICAgICBwMCA9IG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFuZ2xlKM67MCwgzrsxKSB7XG4gICAgICByZXR1cm4gKM67MSAtPSDOuzApIDwgMCA/IM67MSArIDM2MCA6IM67MTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tcGFyZVJhbmdlcyhhLCBiKSB7XG4gICAgICByZXR1cm4gYVswXSAtIGJbMF07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdpdGhpblJhbmdlKHgsIHJhbmdlKSB7XG4gICAgICByZXR1cm4gcmFuZ2VbMF0gPD0gcmFuZ2VbMV0gPyByYW5nZVswXSA8PSB4ICYmIHggPD0gcmFuZ2VbMV0gOiB4IDwgcmFuZ2VbMF0gfHwgcmFuZ2VbMV0gPCB4O1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24oZmVhdHVyZSkge1xuICAgICAgz4YxID0gzrsxID0gLSjOuzAgPSDPhjAgPSBJbmZpbml0eSk7XG4gICAgICByYW5nZXMgPSBbXTtcbiAgICAgIGQzLmdlby5zdHJlYW0oZmVhdHVyZSwgYm91bmQpO1xuICAgICAgdmFyIG4gPSByYW5nZXMubGVuZ3RoO1xuICAgICAgaWYgKG4pIHtcbiAgICAgICAgcmFuZ2VzLnNvcnQoY29tcGFyZVJhbmdlcyk7XG4gICAgICAgIGZvciAodmFyIGkgPSAxLCBhID0gcmFuZ2VzWzBdLCBiLCBtZXJnZWQgPSBbIGEgXTsgaSA8IG47ICsraSkge1xuICAgICAgICAgIGIgPSByYW5nZXNbaV07XG4gICAgICAgICAgaWYgKHdpdGhpblJhbmdlKGJbMF0sIGEpIHx8IHdpdGhpblJhbmdlKGJbMV0sIGEpKSB7XG4gICAgICAgICAgICBpZiAoYW5nbGUoYVswXSwgYlsxXSkgPiBhbmdsZShhWzBdLCBhWzFdKSkgYVsxXSA9IGJbMV07XG4gICAgICAgICAgICBpZiAoYW5nbGUoYlswXSwgYVsxXSkgPiBhbmdsZShhWzBdLCBhWzFdKSkgYVswXSA9IGJbMF07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1lcmdlZC5wdXNoKGEgPSBiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJlc3QgPSAtSW5maW5pdHksIGTOuztcbiAgICAgICAgZm9yICh2YXIgbiA9IG1lcmdlZC5sZW5ndGggLSAxLCBpID0gMCwgYSA9IG1lcmdlZFtuXSwgYjsgaSA8PSBuOyBhID0gYiwgKytpKSB7XG4gICAgICAgICAgYiA9IG1lcmdlZFtpXTtcbiAgICAgICAgICBpZiAoKGTOuyA9IGFuZ2xlKGFbMV0sIGJbMF0pKSA+IGJlc3QpIGJlc3QgPSBkzrssIM67MCA9IGJbMF0sIM67MSA9IGFbMV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJhbmdlcyA9IHJhbmdlID0gbnVsbDtcbiAgICAgIHJldHVybiDOuzAgPT09IEluZmluaXR5IHx8IM+GMCA9PT0gSW5maW5pdHkgPyBbIFsgTmFOLCBOYU4gXSwgWyBOYU4sIE5hTiBdIF0gOiBbIFsgzrswLCDPhjAgXSwgWyDOuzEsIM+GMSBdIF07XG4gICAgfTtcbiAgfSgpO1xuICBkMy5nZW8uY2VudHJvaWQgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICBkM19nZW9fY2VudHJvaWRXMCA9IGQzX2dlb19jZW50cm9pZFcxID0gZDNfZ2VvX2NlbnRyb2lkWDAgPSBkM19nZW9fY2VudHJvaWRZMCA9IGQzX2dlb19jZW50cm9pZFowID0gZDNfZ2VvX2NlbnRyb2lkWDEgPSBkM19nZW9fY2VudHJvaWRZMSA9IGQzX2dlb19jZW50cm9pZFoxID0gZDNfZ2VvX2NlbnRyb2lkWDIgPSBkM19nZW9fY2VudHJvaWRZMiA9IGQzX2dlb19jZW50cm9pZFoyID0gMDtcbiAgICBkMy5nZW8uc3RyZWFtKG9iamVjdCwgZDNfZ2VvX2NlbnRyb2lkKTtcbiAgICB2YXIgeCA9IGQzX2dlb19jZW50cm9pZFgyLCB5ID0gZDNfZ2VvX2NlbnRyb2lkWTIsIHogPSBkM19nZW9fY2VudHJvaWRaMiwgbSA9IHggKiB4ICsgeSAqIHkgKyB6ICogejtcbiAgICBpZiAobSA8IM61Mikge1xuICAgICAgeCA9IGQzX2dlb19jZW50cm9pZFgxLCB5ID0gZDNfZ2VvX2NlbnRyb2lkWTEsIHogPSBkM19nZW9fY2VudHJvaWRaMTtcbiAgICAgIGlmIChkM19nZW9fY2VudHJvaWRXMSA8IM61KSB4ID0gZDNfZ2VvX2NlbnRyb2lkWDAsIHkgPSBkM19nZW9fY2VudHJvaWRZMCwgeiA9IGQzX2dlb19jZW50cm9pZFowO1xuICAgICAgbSA9IHggKiB4ICsgeSAqIHkgKyB6ICogejtcbiAgICAgIGlmIChtIDwgzrUyKSByZXR1cm4gWyBOYU4sIE5hTiBdO1xuICAgIH1cbiAgICByZXR1cm4gWyBNYXRoLmF0YW4yKHksIHgpICogZDNfZGVncmVlcywgZDNfYXNpbih6IC8gTWF0aC5zcXJ0KG0pKSAqIGQzX2RlZ3JlZXMgXTtcbiAgfTtcbiAgdmFyIGQzX2dlb19jZW50cm9pZFcwLCBkM19nZW9fY2VudHJvaWRXMSwgZDNfZ2VvX2NlbnRyb2lkWDAsIGQzX2dlb19jZW50cm9pZFkwLCBkM19nZW9fY2VudHJvaWRaMCwgZDNfZ2VvX2NlbnRyb2lkWDEsIGQzX2dlb19jZW50cm9pZFkxLCBkM19nZW9fY2VudHJvaWRaMSwgZDNfZ2VvX2NlbnRyb2lkWDIsIGQzX2dlb19jZW50cm9pZFkyLCBkM19nZW9fY2VudHJvaWRaMjtcbiAgdmFyIGQzX2dlb19jZW50cm9pZCA9IHtcbiAgICBzcGhlcmU6IGQzX25vb3AsXG4gICAgcG9pbnQ6IGQzX2dlb19jZW50cm9pZFBvaW50LFxuICAgIGxpbmVTdGFydDogZDNfZ2VvX2NlbnRyb2lkTGluZVN0YXJ0LFxuICAgIGxpbmVFbmQ6IGQzX2dlb19jZW50cm9pZExpbmVFbmQsXG4gICAgcG9seWdvblN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgIGQzX2dlb19jZW50cm9pZC5saW5lU3RhcnQgPSBkM19nZW9fY2VudHJvaWRSaW5nU3RhcnQ7XG4gICAgfSxcbiAgICBwb2x5Z29uRW5kOiBmdW5jdGlvbigpIHtcbiAgICAgIGQzX2dlb19jZW50cm9pZC5saW5lU3RhcnQgPSBkM19nZW9fY2VudHJvaWRMaW5lU3RhcnQ7XG4gICAgfVxuICB9O1xuICBmdW5jdGlvbiBkM19nZW9fY2VudHJvaWRQb2ludCjOuywgz4YpIHtcbiAgICDOuyAqPSBkM19yYWRpYW5zO1xuICAgIHZhciBjb3PPhiA9IE1hdGguY29zKM+GICo9IGQzX3JhZGlhbnMpO1xuICAgIGQzX2dlb19jZW50cm9pZFBvaW50WFlaKGNvc8+GICogTWF0aC5jb3MozrspLCBjb3PPhiAqIE1hdGguc2luKM67KSwgTWF0aC5zaW4oz4YpKTtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9fY2VudHJvaWRQb2ludFhZWih4LCB5LCB6KSB7XG4gICAgKytkM19nZW9fY2VudHJvaWRXMDtcbiAgICBkM19nZW9fY2VudHJvaWRYMCArPSAoeCAtIGQzX2dlb19jZW50cm9pZFgwKSAvIGQzX2dlb19jZW50cm9pZFcwO1xuICAgIGQzX2dlb19jZW50cm9pZFkwICs9ICh5IC0gZDNfZ2VvX2NlbnRyb2lkWTApIC8gZDNfZ2VvX2NlbnRyb2lkVzA7XG4gICAgZDNfZ2VvX2NlbnRyb2lkWjAgKz0gKHogLSBkM19nZW9fY2VudHJvaWRaMCkgLyBkM19nZW9fY2VudHJvaWRXMDtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9fY2VudHJvaWRMaW5lU3RhcnQoKSB7XG4gICAgdmFyIHgwLCB5MCwgejA7XG4gICAgZDNfZ2VvX2NlbnRyb2lkLnBvaW50ID0gZnVuY3Rpb24ozrssIM+GKSB7XG4gICAgICDOuyAqPSBkM19yYWRpYW5zO1xuICAgICAgdmFyIGNvc8+GID0gTWF0aC5jb3Moz4YgKj0gZDNfcmFkaWFucyk7XG4gICAgICB4MCA9IGNvc8+GICogTWF0aC5jb3MozrspO1xuICAgICAgeTAgPSBjb3PPhiAqIE1hdGguc2luKM67KTtcbiAgICAgIHowID0gTWF0aC5zaW4oz4YpO1xuICAgICAgZDNfZ2VvX2NlbnRyb2lkLnBvaW50ID0gbmV4dFBvaW50O1xuICAgICAgZDNfZ2VvX2NlbnRyb2lkUG9pbnRYWVooeDAsIHkwLCB6MCk7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBuZXh0UG9pbnQozrssIM+GKSB7XG4gICAgICDOuyAqPSBkM19yYWRpYW5zO1xuICAgICAgdmFyIGNvc8+GID0gTWF0aC5jb3Moz4YgKj0gZDNfcmFkaWFucyksIHggPSBjb3PPhiAqIE1hdGguY29zKM67KSwgeSA9IGNvc8+GICogTWF0aC5zaW4ozrspLCB6ID0gTWF0aC5zaW4oz4YpLCB3ID0gTWF0aC5hdGFuMihNYXRoLnNxcnQoKHcgPSB5MCAqIHogLSB6MCAqIHkpICogdyArICh3ID0gejAgKiB4IC0geDAgKiB6KSAqIHcgKyAodyA9IHgwICogeSAtIHkwICogeCkgKiB3KSwgeDAgKiB4ICsgeTAgKiB5ICsgejAgKiB6KTtcbiAgICAgIGQzX2dlb19jZW50cm9pZFcxICs9IHc7XG4gICAgICBkM19nZW9fY2VudHJvaWRYMSArPSB3ICogKHgwICsgKHgwID0geCkpO1xuICAgICAgZDNfZ2VvX2NlbnRyb2lkWTEgKz0gdyAqICh5MCArICh5MCA9IHkpKTtcbiAgICAgIGQzX2dlb19jZW50cm9pZFoxICs9IHcgKiAoejAgKyAoejAgPSB6KSk7XG4gICAgICBkM19nZW9fY2VudHJvaWRQb2ludFhZWih4MCwgeTAsIHowKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvX2NlbnRyb2lkTGluZUVuZCgpIHtcbiAgICBkM19nZW9fY2VudHJvaWQucG9pbnQgPSBkM19nZW9fY2VudHJvaWRQb2ludDtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9fY2VudHJvaWRSaW5nU3RhcnQoKSB7XG4gICAgdmFyIM67MDAsIM+GMDAsIHgwLCB5MCwgejA7XG4gICAgZDNfZ2VvX2NlbnRyb2lkLnBvaW50ID0gZnVuY3Rpb24ozrssIM+GKSB7XG4gICAgICDOuzAwID0gzrssIM+GMDAgPSDPhjtcbiAgICAgIGQzX2dlb19jZW50cm9pZC5wb2ludCA9IG5leHRQb2ludDtcbiAgICAgIM67ICo9IGQzX3JhZGlhbnM7XG4gICAgICB2YXIgY29zz4YgPSBNYXRoLmNvcyjPhiAqPSBkM19yYWRpYW5zKTtcbiAgICAgIHgwID0gY29zz4YgKiBNYXRoLmNvcyjOuyk7XG4gICAgICB5MCA9IGNvc8+GICogTWF0aC5zaW4ozrspO1xuICAgICAgejAgPSBNYXRoLnNpbijPhik7XG4gICAgICBkM19nZW9fY2VudHJvaWRQb2ludFhZWih4MCwgeTAsIHowKTtcbiAgICB9O1xuICAgIGQzX2dlb19jZW50cm9pZC5saW5lRW5kID0gZnVuY3Rpb24oKSB7XG4gICAgICBuZXh0UG9pbnQozrswMCwgz4YwMCk7XG4gICAgICBkM19nZW9fY2VudHJvaWQubGluZUVuZCA9IGQzX2dlb19jZW50cm9pZExpbmVFbmQ7XG4gICAgICBkM19nZW9fY2VudHJvaWQucG9pbnQgPSBkM19nZW9fY2VudHJvaWRQb2ludDtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIG5leHRQb2ludCjOuywgz4YpIHtcbiAgICAgIM67ICo9IGQzX3JhZGlhbnM7XG4gICAgICB2YXIgY29zz4YgPSBNYXRoLmNvcyjPhiAqPSBkM19yYWRpYW5zKSwgeCA9IGNvc8+GICogTWF0aC5jb3MozrspLCB5ID0gY29zz4YgKiBNYXRoLnNpbijOuyksIHogPSBNYXRoLnNpbijPhiksIGN4ID0geTAgKiB6IC0gejAgKiB5LCBjeSA9IHowICogeCAtIHgwICogeiwgY3ogPSB4MCAqIHkgLSB5MCAqIHgsIG0gPSBNYXRoLnNxcnQoY3ggKiBjeCArIGN5ICogY3kgKyBjeiAqIGN6KSwgdSA9IHgwICogeCArIHkwICogeSArIHowICogeiwgdiA9IG0gJiYgLWQzX2Fjb3ModSkgLyBtLCB3ID0gTWF0aC5hdGFuMihtLCB1KTtcbiAgICAgIGQzX2dlb19jZW50cm9pZFgyICs9IHYgKiBjeDtcbiAgICAgIGQzX2dlb19jZW50cm9pZFkyICs9IHYgKiBjeTtcbiAgICAgIGQzX2dlb19jZW50cm9pZFoyICs9IHYgKiBjejtcbiAgICAgIGQzX2dlb19jZW50cm9pZFcxICs9IHc7XG4gICAgICBkM19nZW9fY2VudHJvaWRYMSArPSB3ICogKHgwICsgKHgwID0geCkpO1xuICAgICAgZDNfZ2VvX2NlbnRyb2lkWTEgKz0gdyAqICh5MCArICh5MCA9IHkpKTtcbiAgICAgIGQzX2dlb19jZW50cm9pZFoxICs9IHcgKiAoejAgKyAoejAgPSB6KSk7XG4gICAgICBkM19nZW9fY2VudHJvaWRQb2ludFhZWih4MCwgeTAsIHowKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvX2NvbXBvc2UoYSwgYikge1xuICAgIGZ1bmN0aW9uIGNvbXBvc2UoeCwgeSkge1xuICAgICAgcmV0dXJuIHggPSBhKHgsIHkpLCBiKHhbMF0sIHhbMV0pO1xuICAgIH1cbiAgICBpZiAoYS5pbnZlcnQgJiYgYi5pbnZlcnQpIGNvbXBvc2UuaW52ZXJ0ID0gZnVuY3Rpb24oeCwgeSkge1xuICAgICAgcmV0dXJuIHggPSBiLmludmVydCh4LCB5KSwgeCAmJiBhLmludmVydCh4WzBdLCB4WzFdKTtcbiAgICB9O1xuICAgIHJldHVybiBjb21wb3NlO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3RydWUoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvX2NsaXBQb2x5Z29uKHNlZ21lbnRzLCBjb21wYXJlLCBjbGlwU3RhcnRJbnNpZGUsIGludGVycG9sYXRlLCBsaXN0ZW5lcikge1xuICAgIHZhciBzdWJqZWN0ID0gW10sIGNsaXAgPSBbXTtcbiAgICBzZWdtZW50cy5mb3JFYWNoKGZ1bmN0aW9uKHNlZ21lbnQpIHtcbiAgICAgIGlmICgobiA9IHNlZ21lbnQubGVuZ3RoIC0gMSkgPD0gMCkgcmV0dXJuO1xuICAgICAgdmFyIG4sIHAwID0gc2VnbWVudFswXSwgcDEgPSBzZWdtZW50W25dO1xuICAgICAgaWYgKGQzX2dlb19zcGhlcmljYWxFcXVhbChwMCwgcDEpKSB7XG4gICAgICAgIGxpc3RlbmVyLmxpbmVTdGFydCgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSkgbGlzdGVuZXIucG9pbnQoKHAwID0gc2VnbWVudFtpXSlbMF0sIHAwWzFdKTtcbiAgICAgICAgbGlzdGVuZXIubGluZUVuZCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgYSA9IG5ldyBkM19nZW9fY2xpcFBvbHlnb25JbnRlcnNlY3Rpb24ocDAsIHNlZ21lbnQsIG51bGwsIHRydWUpLCBiID0gbmV3IGQzX2dlb19jbGlwUG9seWdvbkludGVyc2VjdGlvbihwMCwgbnVsbCwgYSwgZmFsc2UpO1xuICAgICAgYS5vID0gYjtcbiAgICAgIHN1YmplY3QucHVzaChhKTtcbiAgICAgIGNsaXAucHVzaChiKTtcbiAgICAgIGEgPSBuZXcgZDNfZ2VvX2NsaXBQb2x5Z29uSW50ZXJzZWN0aW9uKHAxLCBzZWdtZW50LCBudWxsLCBmYWxzZSk7XG4gICAgICBiID0gbmV3IGQzX2dlb19jbGlwUG9seWdvbkludGVyc2VjdGlvbihwMSwgbnVsbCwgYSwgdHJ1ZSk7XG4gICAgICBhLm8gPSBiO1xuICAgICAgc3ViamVjdC5wdXNoKGEpO1xuICAgICAgY2xpcC5wdXNoKGIpO1xuICAgIH0pO1xuICAgIGNsaXAuc29ydChjb21wYXJlKTtcbiAgICBkM19nZW9fY2xpcFBvbHlnb25MaW5rQ2lyY3VsYXIoc3ViamVjdCk7XG4gICAgZDNfZ2VvX2NsaXBQb2x5Z29uTGlua0NpcmN1bGFyKGNsaXApO1xuICAgIGlmICghc3ViamVjdC5sZW5ndGgpIHJldHVybjtcbiAgICBmb3IgKHZhciBpID0gMCwgZW50cnkgPSBjbGlwU3RhcnRJbnNpZGUsIG4gPSBjbGlwLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgY2xpcFtpXS5lID0gZW50cnkgPSAhZW50cnk7XG4gICAgfVxuICAgIHZhciBzdGFydCA9IHN1YmplY3RbMF0sIHBvaW50cywgcG9pbnQ7XG4gICAgd2hpbGUgKDEpIHtcbiAgICAgIHZhciBjdXJyZW50ID0gc3RhcnQsIGlzU3ViamVjdCA9IHRydWU7XG4gICAgICB3aGlsZSAoY3VycmVudC52KSBpZiAoKGN1cnJlbnQgPSBjdXJyZW50Lm4pID09PSBzdGFydCkgcmV0dXJuO1xuICAgICAgcG9pbnRzID0gY3VycmVudC56O1xuICAgICAgbGlzdGVuZXIubGluZVN0YXJ0KCk7XG4gICAgICBkbyB7XG4gICAgICAgIGN1cnJlbnQudiA9IGN1cnJlbnQuby52ID0gdHJ1ZTtcbiAgICAgICAgaWYgKGN1cnJlbnQuZSkge1xuICAgICAgICAgIGlmIChpc1N1YmplY3QpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gcG9pbnRzLmxlbmd0aDsgaSA8IG47ICsraSkgbGlzdGVuZXIucG9pbnQoKHBvaW50ID0gcG9pbnRzW2ldKVswXSwgcG9pbnRbMV0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbnRlcnBvbGF0ZShjdXJyZW50LngsIGN1cnJlbnQubi54LCAxLCBsaXN0ZW5lcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGlzU3ViamVjdCkge1xuICAgICAgICAgICAgcG9pbnRzID0gY3VycmVudC5wLno7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gcG9pbnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSBsaXN0ZW5lci5wb2ludCgocG9pbnQgPSBwb2ludHNbaV0pWzBdLCBwb2ludFsxXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGludGVycG9sYXRlKGN1cnJlbnQueCwgY3VycmVudC5wLngsIC0xLCBsaXN0ZW5lcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnA7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubztcbiAgICAgICAgcG9pbnRzID0gY3VycmVudC56O1xuICAgICAgICBpc1N1YmplY3QgPSAhaXNTdWJqZWN0O1xuICAgICAgfSB3aGlsZSAoIWN1cnJlbnQudik7XG4gICAgICBsaXN0ZW5lci5saW5lRW5kKCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb19jbGlwUG9seWdvbkxpbmtDaXJjdWxhcihhcnJheSkge1xuICAgIGlmICghKG4gPSBhcnJheS5sZW5ndGgpKSByZXR1cm47XG4gICAgdmFyIG4sIGkgPSAwLCBhID0gYXJyYXlbMF0sIGI7XG4gICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgIGEubiA9IGIgPSBhcnJheVtpXTtcbiAgICAgIGIucCA9IGE7XG4gICAgICBhID0gYjtcbiAgICB9XG4gICAgYS5uID0gYiA9IGFycmF5WzBdO1xuICAgIGIucCA9IGE7XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvX2NsaXBQb2x5Z29uSW50ZXJzZWN0aW9uKHBvaW50LCBwb2ludHMsIG90aGVyLCBlbnRyeSkge1xuICAgIHRoaXMueCA9IHBvaW50O1xuICAgIHRoaXMueiA9IHBvaW50cztcbiAgICB0aGlzLm8gPSBvdGhlcjtcbiAgICB0aGlzLmUgPSBlbnRyeTtcbiAgICB0aGlzLnYgPSBmYWxzZTtcbiAgICB0aGlzLm4gPSB0aGlzLnAgPSBudWxsO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb19jbGlwKHBvaW50VmlzaWJsZSwgY2xpcExpbmUsIGludGVycG9sYXRlLCBjbGlwU3RhcnQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24ocm90YXRlLCBsaXN0ZW5lcikge1xuICAgICAgdmFyIGxpbmUgPSBjbGlwTGluZShsaXN0ZW5lciksIHJvdGF0ZWRDbGlwU3RhcnQgPSByb3RhdGUuaW52ZXJ0KGNsaXBTdGFydFswXSwgY2xpcFN0YXJ0WzFdKTtcbiAgICAgIHZhciBjbGlwID0ge1xuICAgICAgICBwb2ludDogcG9pbnQsXG4gICAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxuICAgICAgICBsaW5lRW5kOiBsaW5lRW5kLFxuICAgICAgICBwb2x5Z29uU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGNsaXAucG9pbnQgPSBwb2ludFJpbmc7XG4gICAgICAgICAgY2xpcC5saW5lU3RhcnQgPSByaW5nU3RhcnQ7XG4gICAgICAgICAgY2xpcC5saW5lRW5kID0gcmluZ0VuZDtcbiAgICAgICAgICBzZWdtZW50cyA9IFtdO1xuICAgICAgICAgIHBvbHlnb24gPSBbXTtcbiAgICAgICAgfSxcbiAgICAgICAgcG9seWdvbkVuZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgY2xpcC5wb2ludCA9IHBvaW50O1xuICAgICAgICAgIGNsaXAubGluZVN0YXJ0ID0gbGluZVN0YXJ0O1xuICAgICAgICAgIGNsaXAubGluZUVuZCA9IGxpbmVFbmQ7XG4gICAgICAgICAgc2VnbWVudHMgPSBkMy5tZXJnZShzZWdtZW50cyk7XG4gICAgICAgICAgdmFyIGNsaXBTdGFydEluc2lkZSA9IGQzX2dlb19wb2ludEluUG9seWdvbihyb3RhdGVkQ2xpcFN0YXJ0LCBwb2x5Z29uKTtcbiAgICAgICAgICBpZiAoc2VnbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoIXBvbHlnb25TdGFydGVkKSBsaXN0ZW5lci5wb2x5Z29uU3RhcnQoKSwgcG9seWdvblN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgZDNfZ2VvX2NsaXBQb2x5Z29uKHNlZ21lbnRzLCBkM19nZW9fY2xpcFNvcnQsIGNsaXBTdGFydEluc2lkZSwgaW50ZXJwb2xhdGUsIGxpc3RlbmVyKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNsaXBTdGFydEluc2lkZSkge1xuICAgICAgICAgICAgaWYgKCFwb2x5Z29uU3RhcnRlZCkgbGlzdGVuZXIucG9seWdvblN0YXJ0KCksIHBvbHlnb25TdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGxpc3RlbmVyLmxpbmVTdGFydCgpO1xuICAgICAgICAgICAgaW50ZXJwb2xhdGUobnVsbCwgbnVsbCwgMSwgbGlzdGVuZXIpO1xuICAgICAgICAgICAgbGlzdGVuZXIubGluZUVuZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocG9seWdvblN0YXJ0ZWQpIGxpc3RlbmVyLnBvbHlnb25FbmQoKSwgcG9seWdvblN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgICBzZWdtZW50cyA9IHBvbHlnb24gPSBudWxsO1xuICAgICAgICB9LFxuICAgICAgICBzcGhlcmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGxpc3RlbmVyLnBvbHlnb25TdGFydCgpO1xuICAgICAgICAgIGxpc3RlbmVyLmxpbmVTdGFydCgpO1xuICAgICAgICAgIGludGVycG9sYXRlKG51bGwsIG51bGwsIDEsIGxpc3RlbmVyKTtcbiAgICAgICAgICBsaXN0ZW5lci5saW5lRW5kKCk7XG4gICAgICAgICAgbGlzdGVuZXIucG9seWdvbkVuZCgpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgZnVuY3Rpb24gcG9pbnQozrssIM+GKSB7XG4gICAgICAgIHZhciBwb2ludCA9IHJvdGF0ZSjOuywgz4YpO1xuICAgICAgICBpZiAocG9pbnRWaXNpYmxlKM67ID0gcG9pbnRbMF0sIM+GID0gcG9pbnRbMV0pKSBsaXN0ZW5lci5wb2ludCjOuywgz4YpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcG9pbnRMaW5lKM67LCDPhikge1xuICAgICAgICB2YXIgcG9pbnQgPSByb3RhdGUozrssIM+GKTtcbiAgICAgICAgbGluZS5wb2ludChwb2ludFswXSwgcG9pbnRbMV0pO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gbGluZVN0YXJ0KCkge1xuICAgICAgICBjbGlwLnBvaW50ID0gcG9pbnRMaW5lO1xuICAgICAgICBsaW5lLmxpbmVTdGFydCgpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gbGluZUVuZCgpIHtcbiAgICAgICAgY2xpcC5wb2ludCA9IHBvaW50O1xuICAgICAgICBsaW5lLmxpbmVFbmQoKTtcbiAgICAgIH1cbiAgICAgIHZhciBzZWdtZW50cztcbiAgICAgIHZhciBidWZmZXIgPSBkM19nZW9fY2xpcEJ1ZmZlckxpc3RlbmVyKCksIHJpbmdMaXN0ZW5lciA9IGNsaXBMaW5lKGJ1ZmZlciksIHBvbHlnb25TdGFydGVkID0gZmFsc2UsIHBvbHlnb24sIHJpbmc7XG4gICAgICBmdW5jdGlvbiBwb2ludFJpbmcozrssIM+GKSB7XG4gICAgICAgIHJpbmcucHVzaChbIM67LCDPhiBdKTtcbiAgICAgICAgdmFyIHBvaW50ID0gcm90YXRlKM67LCDPhik7XG4gICAgICAgIHJpbmdMaXN0ZW5lci5wb2ludChwb2ludFswXSwgcG9pbnRbMV0pO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcmluZ1N0YXJ0KCkge1xuICAgICAgICByaW5nTGlzdGVuZXIubGluZVN0YXJ0KCk7XG4gICAgICAgIHJpbmcgPSBbXTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHJpbmdFbmQoKSB7XG4gICAgICAgIHBvaW50UmluZyhyaW5nWzBdWzBdLCByaW5nWzBdWzFdKTtcbiAgICAgICAgcmluZ0xpc3RlbmVyLmxpbmVFbmQoKTtcbiAgICAgICAgdmFyIGNsZWFuID0gcmluZ0xpc3RlbmVyLmNsZWFuKCksIHJpbmdTZWdtZW50cyA9IGJ1ZmZlci5idWZmZXIoKSwgc2VnbWVudCwgbiA9IHJpbmdTZWdtZW50cy5sZW5ndGg7XG4gICAgICAgIHJpbmcucG9wKCk7XG4gICAgICAgIHBvbHlnb24ucHVzaChyaW5nKTtcbiAgICAgICAgcmluZyA9IG51bGw7XG4gICAgICAgIGlmICghbikgcmV0dXJuO1xuICAgICAgICBpZiAoY2xlYW4gJiAxKSB7XG4gICAgICAgICAgc2VnbWVudCA9IHJpbmdTZWdtZW50c1swXTtcbiAgICAgICAgICB2YXIgbiA9IHNlZ21lbnQubGVuZ3RoIC0gMSwgaSA9IC0xLCBwb2ludDtcbiAgICAgICAgICBpZiAobiA+IDApIHtcbiAgICAgICAgICAgIGlmICghcG9seWdvblN0YXJ0ZWQpIGxpc3RlbmVyLnBvbHlnb25TdGFydCgpLCBwb2x5Z29uU3RhcnRlZCA9IHRydWU7XG4gICAgICAgICAgICBsaXN0ZW5lci5saW5lU3RhcnQoKTtcbiAgICAgICAgICAgIHdoaWxlICgrK2kgPCBuKSBsaXN0ZW5lci5wb2ludCgocG9pbnQgPSBzZWdtZW50W2ldKVswXSwgcG9pbnRbMV0pO1xuICAgICAgICAgICAgbGlzdGVuZXIubGluZUVuZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG4gPiAxICYmIGNsZWFuICYgMikgcmluZ1NlZ21lbnRzLnB1c2gocmluZ1NlZ21lbnRzLnBvcCgpLmNvbmNhdChyaW5nU2VnbWVudHMuc2hpZnQoKSkpO1xuICAgICAgICBzZWdtZW50cy5wdXNoKHJpbmdTZWdtZW50cy5maWx0ZXIoZDNfZ2VvX2NsaXBTZWdtZW50TGVuZ3RoMSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNsaXA7XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9fY2xpcFNlZ21lbnRMZW5ndGgxKHNlZ21lbnQpIHtcbiAgICByZXR1cm4gc2VnbWVudC5sZW5ndGggPiAxO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb19jbGlwQnVmZmVyTGlzdGVuZXIoKSB7XG4gICAgdmFyIGxpbmVzID0gW10sIGxpbmU7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGxpbmVzLnB1c2gobGluZSA9IFtdKTtcbiAgICAgIH0sXG4gICAgICBwb2ludDogZnVuY3Rpb24ozrssIM+GKSB7XG4gICAgICAgIGxpbmUucHVzaChbIM67LCDPhiBdKTtcbiAgICAgIH0sXG4gICAgICBsaW5lRW5kOiBkM19ub29wLFxuICAgICAgYnVmZmVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGJ1ZmZlciA9IGxpbmVzO1xuICAgICAgICBsaW5lcyA9IFtdO1xuICAgICAgICBsaW5lID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIGJ1ZmZlcjtcbiAgICAgIH0sXG4gICAgICByZWpvaW46IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAobGluZXMubGVuZ3RoID4gMSkgbGluZXMucHVzaChsaW5lcy5wb3AoKS5jb25jYXQobGluZXMuc2hpZnQoKSkpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvX2NsaXBTb3J0KGEsIGIpIHtcbiAgICByZXR1cm4gKChhID0gYS54KVswXSA8IDAgPyBhWzFdIC0gaGFsZs+AIC0gzrUgOiBoYWxmz4AgLSBhWzFdKSAtICgoYiA9IGIueClbMF0gPCAwID8gYlsxXSAtIGhhbGbPgCAtIM61IDogaGFsZs+AIC0gYlsxXSk7XG4gIH1cbiAgdmFyIGQzX2dlb19jbGlwQW50aW1lcmlkaWFuID0gZDNfZ2VvX2NsaXAoZDNfdHJ1ZSwgZDNfZ2VvX2NsaXBBbnRpbWVyaWRpYW5MaW5lLCBkM19nZW9fY2xpcEFudGltZXJpZGlhbkludGVycG9sYXRlLCBbIC3PgCwgLc+AIC8gMiBdKTtcbiAgZnVuY3Rpb24gZDNfZ2VvX2NsaXBBbnRpbWVyaWRpYW5MaW5lKGxpc3RlbmVyKSB7XG4gICAgdmFyIM67MCA9IE5hTiwgz4YwID0gTmFOLCBzzrswID0gTmFOLCBjbGVhbjtcbiAgICByZXR1cm4ge1xuICAgICAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgbGlzdGVuZXIubGluZVN0YXJ0KCk7XG4gICAgICAgIGNsZWFuID0gMTtcbiAgICAgIH0sXG4gICAgICBwb2ludDogZnVuY3Rpb24ozrsxLCDPhjEpIHtcbiAgICAgICAgdmFyIHPOuzEgPSDOuzEgPiAwID8gz4AgOiAtz4AsIGTOuyA9IGFicyjOuzEgLSDOuzApO1xuICAgICAgICBpZiAoYWJzKGTOuyAtIM+AKSA8IM61KSB7XG4gICAgICAgICAgbGlzdGVuZXIucG9pbnQozrswLCDPhjAgPSAoz4YwICsgz4YxKSAvIDIgPiAwID8gaGFsZs+AIDogLWhhbGbPgCk7XG4gICAgICAgICAgbGlzdGVuZXIucG9pbnQoc867MCwgz4YwKTtcbiAgICAgICAgICBsaXN0ZW5lci5saW5lRW5kKCk7XG4gICAgICAgICAgbGlzdGVuZXIubGluZVN0YXJ0KCk7XG4gICAgICAgICAgbGlzdGVuZXIucG9pbnQoc867MSwgz4YwKTtcbiAgICAgICAgICBsaXN0ZW5lci5wb2ludCjOuzEsIM+GMCk7XG4gICAgICAgICAgY2xlYW4gPSAwO1xuICAgICAgICB9IGVsc2UgaWYgKHPOuzAgIT09IHPOuzEgJiYgZM67ID49IM+AKSB7XG4gICAgICAgICAgaWYgKGFicyjOuzAgLSBzzrswKSA8IM61KSDOuzAgLT0gc867MCAqIM61O1xuICAgICAgICAgIGlmIChhYnMozrsxIC0gc867MSkgPCDOtSkgzrsxIC09IHPOuzEgKiDOtTtcbiAgICAgICAgICDPhjAgPSBkM19nZW9fY2xpcEFudGltZXJpZGlhbkludGVyc2VjdCjOuzAsIM+GMCwgzrsxLCDPhjEpO1xuICAgICAgICAgIGxpc3RlbmVyLnBvaW50KHPOuzAsIM+GMCk7XG4gICAgICAgICAgbGlzdGVuZXIubGluZUVuZCgpO1xuICAgICAgICAgIGxpc3RlbmVyLmxpbmVTdGFydCgpO1xuICAgICAgICAgIGxpc3RlbmVyLnBvaW50KHPOuzEsIM+GMCk7XG4gICAgICAgICAgY2xlYW4gPSAwO1xuICAgICAgICB9XG4gICAgICAgIGxpc3RlbmVyLnBvaW50KM67MCA9IM67MSwgz4YwID0gz4YxKTtcbiAgICAgICAgc867MCA9IHPOuzE7XG4gICAgICB9LFxuICAgICAgbGluZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGxpc3RlbmVyLmxpbmVFbmQoKTtcbiAgICAgICAgzrswID0gz4YwID0gTmFOO1xuICAgICAgfSxcbiAgICAgIGNsZWFuOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIDIgLSBjbGVhbjtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb19jbGlwQW50aW1lcmlkaWFuSW50ZXJzZWN0KM67MCwgz4YwLCDOuzEsIM+GMSkge1xuICAgIHZhciBjb3PPhjAsIGNvc8+GMSwgc2luzrswX867MSA9IE1hdGguc2luKM67MCAtIM67MSk7XG4gICAgcmV0dXJuIGFicyhzaW7OuzBfzrsxKSA+IM61ID8gTWF0aC5hdGFuKChNYXRoLnNpbijPhjApICogKGNvc8+GMSA9IE1hdGguY29zKM+GMSkpICogTWF0aC5zaW4ozrsxKSAtIE1hdGguc2luKM+GMSkgKiAoY29zz4YwID0gTWF0aC5jb3Moz4YwKSkgKiBNYXRoLnNpbijOuzApKSAvIChjb3PPhjAgKiBjb3PPhjEgKiBzaW7OuzBfzrsxKSkgOiAoz4YwICsgz4YxKSAvIDI7XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvX2NsaXBBbnRpbWVyaWRpYW5JbnRlcnBvbGF0ZShmcm9tLCB0bywgZGlyZWN0aW9uLCBsaXN0ZW5lcikge1xuICAgIHZhciDPhjtcbiAgICBpZiAoZnJvbSA9PSBudWxsKSB7XG4gICAgICDPhiA9IGRpcmVjdGlvbiAqIGhhbGbPgDtcbiAgICAgIGxpc3RlbmVyLnBvaW50KC3PgCwgz4YpO1xuICAgICAgbGlzdGVuZXIucG9pbnQoMCwgz4YpO1xuICAgICAgbGlzdGVuZXIucG9pbnQoz4AsIM+GKTtcbiAgICAgIGxpc3RlbmVyLnBvaW50KM+ALCAwKTtcbiAgICAgIGxpc3RlbmVyLnBvaW50KM+ALCAtz4YpO1xuICAgICAgbGlzdGVuZXIucG9pbnQoMCwgLc+GKTtcbiAgICAgIGxpc3RlbmVyLnBvaW50KC3PgCwgLc+GKTtcbiAgICAgIGxpc3RlbmVyLnBvaW50KC3PgCwgMCk7XG4gICAgICBsaXN0ZW5lci5wb2ludCgtz4AsIM+GKTtcbiAgICB9IGVsc2UgaWYgKGFicyhmcm9tWzBdIC0gdG9bMF0pID4gzrUpIHtcbiAgICAgIHZhciBzID0gZnJvbVswXSA8IHRvWzBdID8gz4AgOiAtz4A7XG4gICAgICDPhiA9IGRpcmVjdGlvbiAqIHMgLyAyO1xuICAgICAgbGlzdGVuZXIucG9pbnQoLXMsIM+GKTtcbiAgICAgIGxpc3RlbmVyLnBvaW50KDAsIM+GKTtcbiAgICAgIGxpc3RlbmVyLnBvaW50KHMsIM+GKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGlzdGVuZXIucG9pbnQodG9bMF0sIHRvWzFdKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvX3BvaW50SW5Qb2x5Z29uKHBvaW50LCBwb2x5Z29uKSB7XG4gICAgdmFyIG1lcmlkaWFuID0gcG9pbnRbMF0sIHBhcmFsbGVsID0gcG9pbnRbMV0sIG1lcmlkaWFuTm9ybWFsID0gWyBNYXRoLnNpbihtZXJpZGlhbiksIC1NYXRoLmNvcyhtZXJpZGlhbiksIDAgXSwgcG9sYXJBbmdsZSA9IDAsIHdpbmRpbmcgPSAwO1xuICAgIGQzX2dlb19hcmVhUmluZ1N1bS5yZXNldCgpO1xuICAgIGZvciAodmFyIGkgPSAwLCBuID0gcG9seWdvbi5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgIHZhciByaW5nID0gcG9seWdvbltpXSwgbSA9IHJpbmcubGVuZ3RoO1xuICAgICAgaWYgKCFtKSBjb250aW51ZTtcbiAgICAgIHZhciBwb2ludDAgPSByaW5nWzBdLCDOuzAgPSBwb2ludDBbMF0sIM+GMCA9IHBvaW50MFsxXSAvIDIgKyDPgCAvIDQsIHNpbs+GMCA9IE1hdGguc2luKM+GMCksIGNvc8+GMCA9IE1hdGguY29zKM+GMCksIGogPSAxO1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgaWYgKGogPT09IG0pIGogPSAwO1xuICAgICAgICBwb2ludCA9IHJpbmdbal07XG4gICAgICAgIHZhciDOuyA9IHBvaW50WzBdLCDPhiA9IHBvaW50WzFdIC8gMiArIM+AIC8gNCwgc2luz4YgPSBNYXRoLnNpbijPhiksIGNvc8+GID0gTWF0aC5jb3Moz4YpLCBkzrsgPSDOuyAtIM67MCwgc2TOuyA9IGTOuyA+PSAwID8gMSA6IC0xLCBhZM67ID0gc2TOuyAqIGTOuywgYW50aW1lcmlkaWFuID0gYWTOuyA+IM+ALCBrID0gc2luz4YwICogc2luz4Y7XG4gICAgICAgIGQzX2dlb19hcmVhUmluZ1N1bS5hZGQoTWF0aC5hdGFuMihrICogc2TOuyAqIE1hdGguc2luKGFkzrspLCBjb3PPhjAgKiBjb3PPhiArIGsgKiBNYXRoLmNvcyhhZM67KSkpO1xuICAgICAgICBwb2xhckFuZ2xlICs9IGFudGltZXJpZGlhbiA/IGTOuyArIHNkzrsgKiDPhCA6IGTOuztcbiAgICAgICAgaWYgKGFudGltZXJpZGlhbiBeIM67MCA+PSBtZXJpZGlhbiBeIM67ID49IG1lcmlkaWFuKSB7XG4gICAgICAgICAgdmFyIGFyYyA9IGQzX2dlb19jYXJ0ZXNpYW5Dcm9zcyhkM19nZW9fY2FydGVzaWFuKHBvaW50MCksIGQzX2dlb19jYXJ0ZXNpYW4ocG9pbnQpKTtcbiAgICAgICAgICBkM19nZW9fY2FydGVzaWFuTm9ybWFsaXplKGFyYyk7XG4gICAgICAgICAgdmFyIGludGVyc2VjdGlvbiA9IGQzX2dlb19jYXJ0ZXNpYW5Dcm9zcyhtZXJpZGlhbk5vcm1hbCwgYXJjKTtcbiAgICAgICAgICBkM19nZW9fY2FydGVzaWFuTm9ybWFsaXplKGludGVyc2VjdGlvbik7XG4gICAgICAgICAgdmFyIM+GYXJjID0gKGFudGltZXJpZGlhbiBeIGTOuyA+PSAwID8gLTEgOiAxKSAqIGQzX2FzaW4oaW50ZXJzZWN0aW9uWzJdKTtcbiAgICAgICAgICBpZiAocGFyYWxsZWwgPiDPhmFyYyB8fCBwYXJhbGxlbCA9PT0gz4ZhcmMgJiYgKGFyY1swXSB8fCBhcmNbMV0pKSB7XG4gICAgICAgICAgICB3aW5kaW5nICs9IGFudGltZXJpZGlhbiBeIGTOuyA+PSAwID8gMSA6IC0xO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWorKykgYnJlYWs7XG4gICAgICAgIM67MCA9IM67LCBzaW7PhjAgPSBzaW7PhiwgY29zz4YwID0gY29zz4YsIHBvaW50MCA9IHBvaW50O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gKHBvbGFyQW5nbGUgPCAtzrUgfHwgcG9sYXJBbmdsZSA8IM61ICYmIGQzX2dlb19hcmVhUmluZ1N1bSA8IC3OtSkgXiB3aW5kaW5nICYgMTtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9fY2xpcENpcmNsZShyYWRpdXMpIHtcbiAgICB2YXIgY3IgPSBNYXRoLmNvcyhyYWRpdXMpLCBzbWFsbFJhZGl1cyA9IGNyID4gMCwgbm90SGVtaXNwaGVyZSA9IGFicyhjcikgPiDOtSwgaW50ZXJwb2xhdGUgPSBkM19nZW9fY2lyY2xlSW50ZXJwb2xhdGUocmFkaXVzLCA2ICogZDNfcmFkaWFucyk7XG4gICAgcmV0dXJuIGQzX2dlb19jbGlwKHZpc2libGUsIGNsaXBMaW5lLCBpbnRlcnBvbGF0ZSwgc21hbGxSYWRpdXMgPyBbIDAsIC1yYWRpdXMgXSA6IFsgLc+ALCByYWRpdXMgLSDPgCBdKTtcbiAgICBmdW5jdGlvbiB2aXNpYmxlKM67LCDPhikge1xuICAgICAgcmV0dXJuIE1hdGguY29zKM67KSAqIE1hdGguY29zKM+GKSA+IGNyO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjbGlwTGluZShsaXN0ZW5lcikge1xuICAgICAgdmFyIHBvaW50MCwgYzAsIHYwLCB2MDAsIGNsZWFuO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2MDAgPSB2MCA9IGZhbHNlO1xuICAgICAgICAgIGNsZWFuID0gMTtcbiAgICAgICAgfSxcbiAgICAgICAgcG9pbnQ6IGZ1bmN0aW9uKM67LCDPhikge1xuICAgICAgICAgIHZhciBwb2ludDEgPSBbIM67LCDPhiBdLCBwb2ludDIsIHYgPSB2aXNpYmxlKM67LCDPhiksIGMgPSBzbWFsbFJhZGl1cyA/IHYgPyAwIDogY29kZSjOuywgz4YpIDogdiA/IGNvZGUozrsgKyAozrsgPCAwID8gz4AgOiAtz4ApLCDPhikgOiAwO1xuICAgICAgICAgIGlmICghcG9pbnQwICYmICh2MDAgPSB2MCA9IHYpKSBsaXN0ZW5lci5saW5lU3RhcnQoKTtcbiAgICAgICAgICBpZiAodiAhPT0gdjApIHtcbiAgICAgICAgICAgIHBvaW50MiA9IGludGVyc2VjdChwb2ludDAsIHBvaW50MSk7XG4gICAgICAgICAgICBpZiAoZDNfZ2VvX3NwaGVyaWNhbEVxdWFsKHBvaW50MCwgcG9pbnQyKSB8fCBkM19nZW9fc3BoZXJpY2FsRXF1YWwocG9pbnQxLCBwb2ludDIpKSB7XG4gICAgICAgICAgICAgIHBvaW50MVswXSArPSDOtTtcbiAgICAgICAgICAgICAgcG9pbnQxWzFdICs9IM61O1xuICAgICAgICAgICAgICB2ID0gdmlzaWJsZShwb2ludDFbMF0sIHBvaW50MVsxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh2ICE9PSB2MCkge1xuICAgICAgICAgICAgY2xlYW4gPSAwO1xuICAgICAgICAgICAgaWYgKHYpIHtcbiAgICAgICAgICAgICAgbGlzdGVuZXIubGluZVN0YXJ0KCk7XG4gICAgICAgICAgICAgIHBvaW50MiA9IGludGVyc2VjdChwb2ludDEsIHBvaW50MCk7XG4gICAgICAgICAgICAgIGxpc3RlbmVyLnBvaW50KHBvaW50MlswXSwgcG9pbnQyWzFdKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHBvaW50MiA9IGludGVyc2VjdChwb2ludDAsIHBvaW50MSk7XG4gICAgICAgICAgICAgIGxpc3RlbmVyLnBvaW50KHBvaW50MlswXSwgcG9pbnQyWzFdKTtcbiAgICAgICAgICAgICAgbGlzdGVuZXIubGluZUVuZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9pbnQwID0gcG9pbnQyO1xuICAgICAgICAgIH0gZWxzZSBpZiAobm90SGVtaXNwaGVyZSAmJiBwb2ludDAgJiYgc21hbGxSYWRpdXMgXiB2KSB7XG4gICAgICAgICAgICB2YXIgdDtcbiAgICAgICAgICAgIGlmICghKGMgJiBjMCkgJiYgKHQgPSBpbnRlcnNlY3QocG9pbnQxLCBwb2ludDAsIHRydWUpKSkge1xuICAgICAgICAgICAgICBjbGVhbiA9IDA7XG4gICAgICAgICAgICAgIGlmIChzbWFsbFJhZGl1cykge1xuICAgICAgICAgICAgICAgIGxpc3RlbmVyLmxpbmVTdGFydCgpO1xuICAgICAgICAgICAgICAgIGxpc3RlbmVyLnBvaW50KHRbMF1bMF0sIHRbMF1bMV0pO1xuICAgICAgICAgICAgICAgIGxpc3RlbmVyLnBvaW50KHRbMV1bMF0sIHRbMV1bMV0pO1xuICAgICAgICAgICAgICAgIGxpc3RlbmVyLmxpbmVFbmQoKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lci5wb2ludCh0WzFdWzBdLCB0WzFdWzFdKTtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lci5saW5lRW5kKCk7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXIubGluZVN0YXJ0KCk7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXIucG9pbnQodFswXVswXSwgdFswXVsxXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHYgJiYgKCFwb2ludDAgfHwgIWQzX2dlb19zcGhlcmljYWxFcXVhbChwb2ludDAsIHBvaW50MSkpKSB7XG4gICAgICAgICAgICBsaXN0ZW5lci5wb2ludChwb2ludDFbMF0sIHBvaW50MVsxXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBvaW50MCA9IHBvaW50MSwgdjAgPSB2LCBjMCA9IGM7XG4gICAgICAgIH0sXG4gICAgICAgIGxpbmVFbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmICh2MCkgbGlzdGVuZXIubGluZUVuZCgpO1xuICAgICAgICAgIHBvaW50MCA9IG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgIGNsZWFuOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gY2xlYW4gfCAodjAwICYmIHYwKSA8PCAxO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBpbnRlcnNlY3QoYSwgYiwgdHdvKSB7XG4gICAgICB2YXIgcGEgPSBkM19nZW9fY2FydGVzaWFuKGEpLCBwYiA9IGQzX2dlb19jYXJ0ZXNpYW4oYik7XG4gICAgICB2YXIgbjEgPSBbIDEsIDAsIDAgXSwgbjIgPSBkM19nZW9fY2FydGVzaWFuQ3Jvc3MocGEsIHBiKSwgbjJuMiA9IGQzX2dlb19jYXJ0ZXNpYW5Eb3QobjIsIG4yKSwgbjFuMiA9IG4yWzBdLCBkZXRlcm1pbmFudCA9IG4ybjIgLSBuMW4yICogbjFuMjtcbiAgICAgIGlmICghZGV0ZXJtaW5hbnQpIHJldHVybiAhdHdvICYmIGE7XG4gICAgICB2YXIgYzEgPSBjciAqIG4ybjIgLyBkZXRlcm1pbmFudCwgYzIgPSAtY3IgKiBuMW4yIC8gZGV0ZXJtaW5hbnQsIG4xeG4yID0gZDNfZ2VvX2NhcnRlc2lhbkNyb3NzKG4xLCBuMiksIEEgPSBkM19nZW9fY2FydGVzaWFuU2NhbGUobjEsIGMxKSwgQiA9IGQzX2dlb19jYXJ0ZXNpYW5TY2FsZShuMiwgYzIpO1xuICAgICAgZDNfZ2VvX2NhcnRlc2lhbkFkZChBLCBCKTtcbiAgICAgIHZhciB1ID0gbjF4bjIsIHcgPSBkM19nZW9fY2FydGVzaWFuRG90KEEsIHUpLCB1dSA9IGQzX2dlb19jYXJ0ZXNpYW5Eb3QodSwgdSksIHQyID0gdyAqIHcgLSB1dSAqIChkM19nZW9fY2FydGVzaWFuRG90KEEsIEEpIC0gMSk7XG4gICAgICBpZiAodDIgPCAwKSByZXR1cm47XG4gICAgICB2YXIgdCA9IE1hdGguc3FydCh0MiksIHEgPSBkM19nZW9fY2FydGVzaWFuU2NhbGUodSwgKC13IC0gdCkgLyB1dSk7XG4gICAgICBkM19nZW9fY2FydGVzaWFuQWRkKHEsIEEpO1xuICAgICAgcSA9IGQzX2dlb19zcGhlcmljYWwocSk7XG4gICAgICBpZiAoIXR3bykgcmV0dXJuIHE7XG4gICAgICB2YXIgzrswID0gYVswXSwgzrsxID0gYlswXSwgz4YwID0gYVsxXSwgz4YxID0gYlsxXSwgejtcbiAgICAgIGlmICjOuzEgPCDOuzApIHogPSDOuzAsIM67MCA9IM67MSwgzrsxID0gejtcbiAgICAgIHZhciDOtM67ID0gzrsxIC0gzrswLCBwb2xhciA9IGFicyjOtM67IC0gz4ApIDwgzrUsIG1lcmlkaWFuID0gcG9sYXIgfHwgzrTOuyA8IM61O1xuICAgICAgaWYgKCFwb2xhciAmJiDPhjEgPCDPhjApIHogPSDPhjAsIM+GMCA9IM+GMSwgz4YxID0gejtcbiAgICAgIGlmIChtZXJpZGlhbiA/IHBvbGFyID8gz4YwICsgz4YxID4gMCBeIHFbMV0gPCAoYWJzKHFbMF0gLSDOuzApIDwgzrUgPyDPhjAgOiDPhjEpIDogz4YwIDw9IHFbMV0gJiYgcVsxXSA8PSDPhjEgOiDOtM67ID4gz4AgXiAozrswIDw9IHFbMF0gJiYgcVswXSA8PSDOuzEpKSB7XG4gICAgICAgIHZhciBxMSA9IGQzX2dlb19jYXJ0ZXNpYW5TY2FsZSh1LCAoLXcgKyB0KSAvIHV1KTtcbiAgICAgICAgZDNfZ2VvX2NhcnRlc2lhbkFkZChxMSwgQSk7XG4gICAgICAgIHJldHVybiBbIHEsIGQzX2dlb19zcGhlcmljYWwocTEpIF07XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvZGUozrssIM+GKSB7XG4gICAgICB2YXIgciA9IHNtYWxsUmFkaXVzID8gcmFkaXVzIDogz4AgLSByYWRpdXMsIGNvZGUgPSAwO1xuICAgICAgaWYgKM67IDwgLXIpIGNvZGUgfD0gMTsgZWxzZSBpZiAozrsgPiByKSBjb2RlIHw9IDI7XG4gICAgICBpZiAoz4YgPCAtcikgY29kZSB8PSA0OyBlbHNlIGlmICjPhiA+IHIpIGNvZGUgfD0gODtcbiAgICAgIHJldHVybiBjb2RlO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBkM19nZW9tX2NsaXBMaW5lKHgwLCB5MCwgeDEsIHkxKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgIHZhciBhID0gbGluZS5hLCBiID0gbGluZS5iLCBheCA9IGEueCwgYXkgPSBhLnksIGJ4ID0gYi54LCBieSA9IGIueSwgdDAgPSAwLCB0MSA9IDEsIGR4ID0gYnggLSBheCwgZHkgPSBieSAtIGF5LCByO1xuICAgICAgciA9IHgwIC0gYXg7XG4gICAgICBpZiAoIWR4ICYmIHIgPiAwKSByZXR1cm47XG4gICAgICByIC89IGR4O1xuICAgICAgaWYgKGR4IDwgMCkge1xuICAgICAgICBpZiAociA8IHQwKSByZXR1cm47XG4gICAgICAgIGlmIChyIDwgdDEpIHQxID0gcjtcbiAgICAgIH0gZWxzZSBpZiAoZHggPiAwKSB7XG4gICAgICAgIGlmIChyID4gdDEpIHJldHVybjtcbiAgICAgICAgaWYgKHIgPiB0MCkgdDAgPSByO1xuICAgICAgfVxuICAgICAgciA9IHgxIC0gYXg7XG4gICAgICBpZiAoIWR4ICYmIHIgPCAwKSByZXR1cm47XG4gICAgICByIC89IGR4O1xuICAgICAgaWYgKGR4IDwgMCkge1xuICAgICAgICBpZiAociA+IHQxKSByZXR1cm47XG4gICAgICAgIGlmIChyID4gdDApIHQwID0gcjtcbiAgICAgIH0gZWxzZSBpZiAoZHggPiAwKSB7XG4gICAgICAgIGlmIChyIDwgdDApIHJldHVybjtcbiAgICAgICAgaWYgKHIgPCB0MSkgdDEgPSByO1xuICAgICAgfVxuICAgICAgciA9IHkwIC0gYXk7XG4gICAgICBpZiAoIWR5ICYmIHIgPiAwKSByZXR1cm47XG4gICAgICByIC89IGR5O1xuICAgICAgaWYgKGR5IDwgMCkge1xuICAgICAgICBpZiAociA8IHQwKSByZXR1cm47XG4gICAgICAgIGlmIChyIDwgdDEpIHQxID0gcjtcbiAgICAgIH0gZWxzZSBpZiAoZHkgPiAwKSB7XG4gICAgICAgIGlmIChyID4gdDEpIHJldHVybjtcbiAgICAgICAgaWYgKHIgPiB0MCkgdDAgPSByO1xuICAgICAgfVxuICAgICAgciA9IHkxIC0gYXk7XG4gICAgICBpZiAoIWR5ICYmIHIgPCAwKSByZXR1cm47XG4gICAgICByIC89IGR5O1xuICAgICAgaWYgKGR5IDwgMCkge1xuICAgICAgICBpZiAociA+IHQxKSByZXR1cm47XG4gICAgICAgIGlmIChyID4gdDApIHQwID0gcjtcbiAgICAgIH0gZWxzZSBpZiAoZHkgPiAwKSB7XG4gICAgICAgIGlmIChyIDwgdDApIHJldHVybjtcbiAgICAgICAgaWYgKHIgPCB0MSkgdDEgPSByO1xuICAgICAgfVxuICAgICAgaWYgKHQwID4gMCkgbGluZS5hID0ge1xuICAgICAgICB4OiBheCArIHQwICogZHgsXG4gICAgICAgIHk6IGF5ICsgdDAgKiBkeVxuICAgICAgfTtcbiAgICAgIGlmICh0MSA8IDEpIGxpbmUuYiA9IHtcbiAgICAgICAgeDogYXggKyB0MSAqIGR4LFxuICAgICAgICB5OiBheSArIHQxICogZHlcbiAgICAgIH07XG4gICAgICByZXR1cm4gbGluZTtcbiAgICB9O1xuICB9XG4gIHZhciBkM19nZW9fY2xpcEV4dGVudE1BWCA9IDFlOTtcbiAgZDMuZ2VvLmNsaXBFeHRlbnQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgeDAsIHkwLCB4MSwgeTEsIHN0cmVhbSwgY2xpcCwgY2xpcEV4dGVudCA9IHtcbiAgICAgIHN0cmVhbTogZnVuY3Rpb24ob3V0cHV0KSB7XG4gICAgICAgIGlmIChzdHJlYW0pIHN0cmVhbS52YWxpZCA9IGZhbHNlO1xuICAgICAgICBzdHJlYW0gPSBjbGlwKG91dHB1dCk7XG4gICAgICAgIHN0cmVhbS52YWxpZCA9IHRydWU7XG4gICAgICAgIHJldHVybiBzdHJlYW07XG4gICAgICB9LFxuICAgICAgZXh0ZW50OiBmdW5jdGlvbihfKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIFsgWyB4MCwgeTAgXSwgWyB4MSwgeTEgXSBdO1xuICAgICAgICBjbGlwID0gZDNfZ2VvX2NsaXBFeHRlbnQoeDAgPSArX1swXVswXSwgeTAgPSArX1swXVsxXSwgeDEgPSArX1sxXVswXSwgeTEgPSArX1sxXVsxXSk7XG4gICAgICAgIGlmIChzdHJlYW0pIHN0cmVhbS52YWxpZCA9IGZhbHNlLCBzdHJlYW0gPSBudWxsO1xuICAgICAgICByZXR1cm4gY2xpcEV4dGVudDtcbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBjbGlwRXh0ZW50LmV4dGVudChbIFsgMCwgMCBdLCBbIDk2MCwgNTAwIF0gXSk7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX2dlb19jbGlwRXh0ZW50KHgwLCB5MCwgeDEsIHkxKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGxpc3RlbmVyKSB7XG4gICAgICB2YXIgbGlzdGVuZXJfID0gbGlzdGVuZXIsIGJ1ZmZlckxpc3RlbmVyID0gZDNfZ2VvX2NsaXBCdWZmZXJMaXN0ZW5lcigpLCBjbGlwTGluZSA9IGQzX2dlb21fY2xpcExpbmUoeDAsIHkwLCB4MSwgeTEpLCBzZWdtZW50cywgcG9seWdvbiwgcmluZztcbiAgICAgIHZhciBjbGlwID0ge1xuICAgICAgICBwb2ludDogcG9pbnQsXG4gICAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxuICAgICAgICBsaW5lRW5kOiBsaW5lRW5kLFxuICAgICAgICBwb2x5Z29uU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGxpc3RlbmVyID0gYnVmZmVyTGlzdGVuZXI7XG4gICAgICAgICAgc2VnbWVudHMgPSBbXTtcbiAgICAgICAgICBwb2x5Z29uID0gW107XG4gICAgICAgICAgY2xlYW4gPSB0cnVlO1xuICAgICAgICB9LFxuICAgICAgICBwb2x5Z29uRW5kOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBsaXN0ZW5lciA9IGxpc3RlbmVyXztcbiAgICAgICAgICBzZWdtZW50cyA9IGQzLm1lcmdlKHNlZ21lbnRzKTtcbiAgICAgICAgICB2YXIgY2xpcFN0YXJ0SW5zaWRlID0gaW5zaWRlUG9seWdvbihbIHgwLCB5MSBdKSwgaW5zaWRlID0gY2xlYW4gJiYgY2xpcFN0YXJ0SW5zaWRlLCB2aXNpYmxlID0gc2VnbWVudHMubGVuZ3RoO1xuICAgICAgICAgIGlmIChpbnNpZGUgfHwgdmlzaWJsZSkge1xuICAgICAgICAgICAgbGlzdGVuZXIucG9seWdvblN0YXJ0KCk7XG4gICAgICAgICAgICBpZiAoaW5zaWRlKSB7XG4gICAgICAgICAgICAgIGxpc3RlbmVyLmxpbmVTdGFydCgpO1xuICAgICAgICAgICAgICBpbnRlcnBvbGF0ZShudWxsLCBudWxsLCAxLCBsaXN0ZW5lcik7XG4gICAgICAgICAgICAgIGxpc3RlbmVyLmxpbmVFbmQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2aXNpYmxlKSB7XG4gICAgICAgICAgICAgIGQzX2dlb19jbGlwUG9seWdvbihzZWdtZW50cywgY29tcGFyZSwgY2xpcFN0YXJ0SW5zaWRlLCBpbnRlcnBvbGF0ZSwgbGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGlzdGVuZXIucG9seWdvbkVuZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzZWdtZW50cyA9IHBvbHlnb24gPSByaW5nID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGZ1bmN0aW9uIGluc2lkZVBvbHlnb24ocCkge1xuICAgICAgICB2YXIgd24gPSAwLCBuID0gcG9seWdvbi5sZW5ndGgsIHkgPSBwWzFdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICAgIGZvciAodmFyIGogPSAxLCB2ID0gcG9seWdvbltpXSwgbSA9IHYubGVuZ3RoLCBhID0gdlswXSwgYjsgaiA8IG07ICsraikge1xuICAgICAgICAgICAgYiA9IHZbal07XG4gICAgICAgICAgICBpZiAoYVsxXSA8PSB5KSB7XG4gICAgICAgICAgICAgIGlmIChiWzFdID4geSAmJiBkM19jcm9zczJkKGEsIGIsIHApID4gMCkgKyt3bjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChiWzFdIDw9IHkgJiYgZDNfY3Jvc3MyZChhLCBiLCBwKSA8IDApIC0td247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhID0gYjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHduICE9PSAwO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gaW50ZXJwb2xhdGUoZnJvbSwgdG8sIGRpcmVjdGlvbiwgbGlzdGVuZXIpIHtcbiAgICAgICAgdmFyIGEgPSAwLCBhMSA9IDA7XG4gICAgICAgIGlmIChmcm9tID09IG51bGwgfHwgKGEgPSBjb3JuZXIoZnJvbSwgZGlyZWN0aW9uKSkgIT09IChhMSA9IGNvcm5lcih0bywgZGlyZWN0aW9uKSkgfHwgY29tcGFyZVBvaW50cyhmcm9tLCB0bykgPCAwIF4gZGlyZWN0aW9uID4gMCkge1xuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgIGxpc3RlbmVyLnBvaW50KGEgPT09IDAgfHwgYSA9PT0gMyA/IHgwIDogeDEsIGEgPiAxID8geTEgOiB5MCk7XG4gICAgICAgICAgfSB3aGlsZSAoKGEgPSAoYSArIGRpcmVjdGlvbiArIDQpICUgNCkgIT09IGExKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsaXN0ZW5lci5wb2ludCh0b1swXSwgdG9bMV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBwb2ludFZpc2libGUoeCwgeSkge1xuICAgICAgICByZXR1cm4geDAgPD0geCAmJiB4IDw9IHgxICYmIHkwIDw9IHkgJiYgeSA8PSB5MTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHBvaW50KHgsIHkpIHtcbiAgICAgICAgaWYgKHBvaW50VmlzaWJsZSh4LCB5KSkgbGlzdGVuZXIucG9pbnQoeCwgeSk7XG4gICAgICB9XG4gICAgICB2YXIgeF9fLCB5X18sIHZfXywgeF8sIHlfLCB2XywgZmlyc3QsIGNsZWFuO1xuICAgICAgZnVuY3Rpb24gbGluZVN0YXJ0KCkge1xuICAgICAgICBjbGlwLnBvaW50ID0gbGluZVBvaW50O1xuICAgICAgICBpZiAocG9seWdvbikgcG9seWdvbi5wdXNoKHJpbmcgPSBbXSk7XG4gICAgICAgIGZpcnN0ID0gdHJ1ZTtcbiAgICAgICAgdl8gPSBmYWxzZTtcbiAgICAgICAgeF8gPSB5XyA9IE5hTjtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGxpbmVFbmQoKSB7XG4gICAgICAgIGlmIChzZWdtZW50cykge1xuICAgICAgICAgIGxpbmVQb2ludCh4X18sIHlfXyk7XG4gICAgICAgICAgaWYgKHZfXyAmJiB2XykgYnVmZmVyTGlzdGVuZXIucmVqb2luKCk7XG4gICAgICAgICAgc2VnbWVudHMucHVzaChidWZmZXJMaXN0ZW5lci5idWZmZXIoKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2xpcC5wb2ludCA9IHBvaW50O1xuICAgICAgICBpZiAodl8pIGxpc3RlbmVyLmxpbmVFbmQoKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGxpbmVQb2ludCh4LCB5KSB7XG4gICAgICAgIHggPSBNYXRoLm1heCgtZDNfZ2VvX2NsaXBFeHRlbnRNQVgsIE1hdGgubWluKGQzX2dlb19jbGlwRXh0ZW50TUFYLCB4KSk7XG4gICAgICAgIHkgPSBNYXRoLm1heCgtZDNfZ2VvX2NsaXBFeHRlbnRNQVgsIE1hdGgubWluKGQzX2dlb19jbGlwRXh0ZW50TUFYLCB5KSk7XG4gICAgICAgIHZhciB2ID0gcG9pbnRWaXNpYmxlKHgsIHkpO1xuICAgICAgICBpZiAocG9seWdvbikgcmluZy5wdXNoKFsgeCwgeSBdKTtcbiAgICAgICAgaWYgKGZpcnN0KSB7XG4gICAgICAgICAgeF9fID0geCwgeV9fID0geSwgdl9fID0gdjtcbiAgICAgICAgICBmaXJzdCA9IGZhbHNlO1xuICAgICAgICAgIGlmICh2KSB7XG4gICAgICAgICAgICBsaXN0ZW5lci5saW5lU3RhcnQoKTtcbiAgICAgICAgICAgIGxpc3RlbmVyLnBvaW50KHgsIHkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodiAmJiB2XykgbGlzdGVuZXIucG9pbnQoeCwgeSk7IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGwgPSB7XG4gICAgICAgICAgICAgIGE6IHtcbiAgICAgICAgICAgICAgICB4OiB4XyxcbiAgICAgICAgICAgICAgICB5OiB5X1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBiOiB7XG4gICAgICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgICAgICB5OiB5XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoY2xpcExpbmUobCkpIHtcbiAgICAgICAgICAgICAgaWYgKCF2Xykge1xuICAgICAgICAgICAgICAgIGxpc3RlbmVyLmxpbmVTdGFydCgpO1xuICAgICAgICAgICAgICAgIGxpc3RlbmVyLnBvaW50KGwuYS54LCBsLmEueSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbGlzdGVuZXIucG9pbnQobC5iLngsIGwuYi55KTtcbiAgICAgICAgICAgICAgaWYgKCF2KSBsaXN0ZW5lci5saW5lRW5kKCk7XG4gICAgICAgICAgICAgIGNsZWFuID0gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHYpIHtcbiAgICAgICAgICAgICAgbGlzdGVuZXIubGluZVN0YXJ0KCk7XG4gICAgICAgICAgICAgIGxpc3RlbmVyLnBvaW50KHgsIHkpO1xuICAgICAgICAgICAgICBjbGVhbiA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB4XyA9IHgsIHlfID0geSwgdl8gPSB2O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNsaXA7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBjb3JuZXIocCwgZGlyZWN0aW9uKSB7XG4gICAgICByZXR1cm4gYWJzKHBbMF0gLSB4MCkgPCDOtSA/IGRpcmVjdGlvbiA+IDAgPyAwIDogMyA6IGFicyhwWzBdIC0geDEpIDwgzrUgPyBkaXJlY3Rpb24gPiAwID8gMiA6IDEgOiBhYnMocFsxXSAtIHkwKSA8IM61ID8gZGlyZWN0aW9uID4gMCA/IDEgOiAwIDogZGlyZWN0aW9uID4gMCA/IDMgOiAyO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21wYXJlKGEsIGIpIHtcbiAgICAgIHJldHVybiBjb21wYXJlUG9pbnRzKGEueCwgYi54KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tcGFyZVBvaW50cyhhLCBiKSB7XG4gICAgICB2YXIgY2EgPSBjb3JuZXIoYSwgMSksIGNiID0gY29ybmVyKGIsIDEpO1xuICAgICAgcmV0dXJuIGNhICE9PSBjYiA/IGNhIC0gY2IgOiBjYSA9PT0gMCA/IGJbMV0gLSBhWzFdIDogY2EgPT09IDEgPyBhWzBdIC0gYlswXSA6IGNhID09PSAyID8gYVsxXSAtIGJbMV0gOiBiWzBdIC0gYVswXTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvX2NvbmljKHByb2plY3RBdCkge1xuICAgIHZhciDPhjAgPSAwLCDPhjEgPSDPgCAvIDMsIG0gPSBkM19nZW9fcHJvamVjdGlvbk11dGF0b3IocHJvamVjdEF0KSwgcCA9IG0oz4YwLCDPhjEpO1xuICAgIHAucGFyYWxsZWxzID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gWyDPhjAgLyDPgCAqIDE4MCwgz4YxIC8gz4AgKiAxODAgXTtcbiAgICAgIHJldHVybiBtKM+GMCA9IF9bMF0gKiDPgCAvIDE4MCwgz4YxID0gX1sxXSAqIM+AIC8gMTgwKTtcbiAgICB9O1xuICAgIHJldHVybiBwO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb19jb25pY0VxdWFsQXJlYSjPhjAsIM+GMSkge1xuICAgIHZhciBzaW7PhjAgPSBNYXRoLnNpbijPhjApLCBuID0gKHNpbs+GMCArIE1hdGguc2luKM+GMSkpIC8gMiwgQyA9IDEgKyBzaW7PhjAgKiAoMiAqIG4gLSBzaW7PhjApLCDPgTAgPSBNYXRoLnNxcnQoQykgLyBuO1xuICAgIGZ1bmN0aW9uIGZvcndhcmQozrssIM+GKSB7XG4gICAgICB2YXIgz4EgPSBNYXRoLnNxcnQoQyAtIDIgKiBuICogTWF0aC5zaW4oz4YpKSAvIG47XG4gICAgICByZXR1cm4gWyDPgSAqIE1hdGguc2luKM67ICo9IG4pLCDPgTAgLSDPgSAqIE1hdGguY29zKM67KSBdO1xuICAgIH1cbiAgICBmb3J3YXJkLmludmVydCA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgIHZhciDPgTBfeSA9IM+BMCAtIHk7XG4gICAgICByZXR1cm4gWyBNYXRoLmF0YW4yKHgsIM+BMF95KSAvIG4sIGQzX2FzaW4oKEMgLSAoeCAqIHggKyDPgTBfeSAqIM+BMF95KSAqIG4gKiBuKSAvICgyICogbikpIF07XG4gICAgfTtcbiAgICByZXR1cm4gZm9yd2FyZDtcbiAgfVxuICAoZDMuZ2VvLmNvbmljRXF1YWxBcmVhID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGQzX2dlb19jb25pYyhkM19nZW9fY29uaWNFcXVhbEFyZWEpO1xuICB9KS5yYXcgPSBkM19nZW9fY29uaWNFcXVhbEFyZWE7XG4gIGQzLmdlby5hbGJlcnMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZDMuZ2VvLmNvbmljRXF1YWxBcmVhKCkucm90YXRlKFsgOTYsIDAgXSkuY2VudGVyKFsgLS42LCAzOC43IF0pLnBhcmFsbGVscyhbIDI5LjUsIDQ1LjUgXSkuc2NhbGUoMTA3MCk7XG4gIH07XG4gIGQzLmdlby5hbGJlcnNVc2EgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgbG93ZXI0OCA9IGQzLmdlby5hbGJlcnMoKTtcbiAgICB2YXIgYWxhc2thID0gZDMuZ2VvLmNvbmljRXF1YWxBcmVhKCkucm90YXRlKFsgMTU0LCAwIF0pLmNlbnRlcihbIC0yLCA1OC41IF0pLnBhcmFsbGVscyhbIDU1LCA2NSBdKTtcbiAgICB2YXIgaGF3YWlpID0gZDMuZ2VvLmNvbmljRXF1YWxBcmVhKCkucm90YXRlKFsgMTU3LCAwIF0pLmNlbnRlcihbIC0zLCAxOS45IF0pLnBhcmFsbGVscyhbIDgsIDE4IF0pO1xuICAgIHZhciBwb2ludCwgcG9pbnRTdHJlYW0gPSB7XG4gICAgICBwb2ludDogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICBwb2ludCA9IFsgeCwgeSBdO1xuICAgICAgfVxuICAgIH0sIGxvd2VyNDhQb2ludCwgYWxhc2thUG9pbnQsIGhhd2FpaVBvaW50O1xuICAgIGZ1bmN0aW9uIGFsYmVyc1VzYShjb29yZGluYXRlcykge1xuICAgICAgdmFyIHggPSBjb29yZGluYXRlc1swXSwgeSA9IGNvb3JkaW5hdGVzWzFdO1xuICAgICAgcG9pbnQgPSBudWxsO1xuICAgICAgKGxvd2VyNDhQb2ludCh4LCB5KSwgcG9pbnQpIHx8IChhbGFza2FQb2ludCh4LCB5KSwgcG9pbnQpIHx8IGhhd2FpaVBvaW50KHgsIHkpO1xuICAgICAgcmV0dXJuIHBvaW50O1xuICAgIH1cbiAgICBhbGJlcnNVc2EuaW52ZXJ0ID0gZnVuY3Rpb24oY29vcmRpbmF0ZXMpIHtcbiAgICAgIHZhciBrID0gbG93ZXI0OC5zY2FsZSgpLCB0ID0gbG93ZXI0OC50cmFuc2xhdGUoKSwgeCA9IChjb29yZGluYXRlc1swXSAtIHRbMF0pIC8gaywgeSA9IChjb29yZGluYXRlc1sxXSAtIHRbMV0pIC8gaztcbiAgICAgIHJldHVybiAoeSA+PSAuMTIgJiYgeSA8IC4yMzQgJiYgeCA+PSAtLjQyNSAmJiB4IDwgLS4yMTQgPyBhbGFza2EgOiB5ID49IC4xNjYgJiYgeSA8IC4yMzQgJiYgeCA+PSAtLjIxNCAmJiB4IDwgLS4xMTUgPyBoYXdhaWkgOiBsb3dlcjQ4KS5pbnZlcnQoY29vcmRpbmF0ZXMpO1xuICAgIH07XG4gICAgYWxiZXJzVXNhLnN0cmVhbSA9IGZ1bmN0aW9uKHN0cmVhbSkge1xuICAgICAgdmFyIGxvd2VyNDhTdHJlYW0gPSBsb3dlcjQ4LnN0cmVhbShzdHJlYW0pLCBhbGFza2FTdHJlYW0gPSBhbGFza2Euc3RyZWFtKHN0cmVhbSksIGhhd2FpaVN0cmVhbSA9IGhhd2FpaS5zdHJlYW0oc3RyZWFtKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBvaW50OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgICAgbG93ZXI0OFN0cmVhbS5wb2ludCh4LCB5KTtcbiAgICAgICAgICBhbGFza2FTdHJlYW0ucG9pbnQoeCwgeSk7XG4gICAgICAgICAgaGF3YWlpU3RyZWFtLnBvaW50KHgsIHkpO1xuICAgICAgICB9LFxuICAgICAgICBzcGhlcmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGxvd2VyNDhTdHJlYW0uc3BoZXJlKCk7XG4gICAgICAgICAgYWxhc2thU3RyZWFtLnNwaGVyZSgpO1xuICAgICAgICAgIGhhd2FpaVN0cmVhbS5zcGhlcmUoKTtcbiAgICAgICAgfSxcbiAgICAgICAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBsb3dlcjQ4U3RyZWFtLmxpbmVTdGFydCgpO1xuICAgICAgICAgIGFsYXNrYVN0cmVhbS5saW5lU3RhcnQoKTtcbiAgICAgICAgICBoYXdhaWlTdHJlYW0ubGluZVN0YXJ0KCk7XG4gICAgICAgIH0sXG4gICAgICAgIGxpbmVFbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGxvd2VyNDhTdHJlYW0ubGluZUVuZCgpO1xuICAgICAgICAgIGFsYXNrYVN0cmVhbS5saW5lRW5kKCk7XG4gICAgICAgICAgaGF3YWlpU3RyZWFtLmxpbmVFbmQoKTtcbiAgICAgICAgfSxcbiAgICAgICAgcG9seWdvblN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBsb3dlcjQ4U3RyZWFtLnBvbHlnb25TdGFydCgpO1xuICAgICAgICAgIGFsYXNrYVN0cmVhbS5wb2x5Z29uU3RhcnQoKTtcbiAgICAgICAgICBoYXdhaWlTdHJlYW0ucG9seWdvblN0YXJ0KCk7XG4gICAgICAgIH0sXG4gICAgICAgIHBvbHlnb25FbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGxvd2VyNDhTdHJlYW0ucG9seWdvbkVuZCgpO1xuICAgICAgICAgIGFsYXNrYVN0cmVhbS5wb2x5Z29uRW5kKCk7XG4gICAgICAgICAgaGF3YWlpU3RyZWFtLnBvbHlnb25FbmQoKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9O1xuICAgIGFsYmVyc1VzYS5wcmVjaXNpb24gPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBsb3dlcjQ4LnByZWNpc2lvbigpO1xuICAgICAgbG93ZXI0OC5wcmVjaXNpb24oXyk7XG4gICAgICBhbGFza2EucHJlY2lzaW9uKF8pO1xuICAgICAgaGF3YWlpLnByZWNpc2lvbihfKTtcbiAgICAgIHJldHVybiBhbGJlcnNVc2E7XG4gICAgfTtcbiAgICBhbGJlcnNVc2Euc2NhbGUgPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBsb3dlcjQ4LnNjYWxlKCk7XG4gICAgICBsb3dlcjQ4LnNjYWxlKF8pO1xuICAgICAgYWxhc2thLnNjYWxlKF8gKiAuMzUpO1xuICAgICAgaGF3YWlpLnNjYWxlKF8pO1xuICAgICAgcmV0dXJuIGFsYmVyc1VzYS50cmFuc2xhdGUobG93ZXI0OC50cmFuc2xhdGUoKSk7XG4gICAgfTtcbiAgICBhbGJlcnNVc2EudHJhbnNsYXRlID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gbG93ZXI0OC50cmFuc2xhdGUoKTtcbiAgICAgIHZhciBrID0gbG93ZXI0OC5zY2FsZSgpLCB4ID0gK19bMF0sIHkgPSArX1sxXTtcbiAgICAgIGxvd2VyNDhQb2ludCA9IGxvd2VyNDgudHJhbnNsYXRlKF8pLmNsaXBFeHRlbnQoWyBbIHggLSAuNDU1ICogaywgeSAtIC4yMzggKiBrIF0sIFsgeCArIC40NTUgKiBrLCB5ICsgLjIzOCAqIGsgXSBdKS5zdHJlYW0ocG9pbnRTdHJlYW0pLnBvaW50O1xuICAgICAgYWxhc2thUG9pbnQgPSBhbGFza2EudHJhbnNsYXRlKFsgeCAtIC4zMDcgKiBrLCB5ICsgLjIwMSAqIGsgXSkuY2xpcEV4dGVudChbIFsgeCAtIC40MjUgKiBrICsgzrUsIHkgKyAuMTIgKiBrICsgzrUgXSwgWyB4IC0gLjIxNCAqIGsgLSDOtSwgeSArIC4yMzQgKiBrIC0gzrUgXSBdKS5zdHJlYW0ocG9pbnRTdHJlYW0pLnBvaW50O1xuICAgICAgaGF3YWlpUG9pbnQgPSBoYXdhaWkudHJhbnNsYXRlKFsgeCAtIC4yMDUgKiBrLCB5ICsgLjIxMiAqIGsgXSkuY2xpcEV4dGVudChbIFsgeCAtIC4yMTQgKiBrICsgzrUsIHkgKyAuMTY2ICogayArIM61IF0sIFsgeCAtIC4xMTUgKiBrIC0gzrUsIHkgKyAuMjM0ICogayAtIM61IF0gXSkuc3RyZWFtKHBvaW50U3RyZWFtKS5wb2ludDtcbiAgICAgIHJldHVybiBhbGJlcnNVc2E7XG4gICAgfTtcbiAgICByZXR1cm4gYWxiZXJzVXNhLnNjYWxlKDEwNzApO1xuICB9O1xuICB2YXIgZDNfZ2VvX3BhdGhBcmVhU3VtLCBkM19nZW9fcGF0aEFyZWFQb2x5Z29uLCBkM19nZW9fcGF0aEFyZWEgPSB7XG4gICAgcG9pbnQ6IGQzX25vb3AsXG4gICAgbGluZVN0YXJ0OiBkM19ub29wLFxuICAgIGxpbmVFbmQ6IGQzX25vb3AsXG4gICAgcG9seWdvblN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgIGQzX2dlb19wYXRoQXJlYVBvbHlnb24gPSAwO1xuICAgICAgZDNfZ2VvX3BhdGhBcmVhLmxpbmVTdGFydCA9IGQzX2dlb19wYXRoQXJlYVJpbmdTdGFydDtcbiAgICB9LFxuICAgIHBvbHlnb25FbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgZDNfZ2VvX3BhdGhBcmVhLmxpbmVTdGFydCA9IGQzX2dlb19wYXRoQXJlYS5saW5lRW5kID0gZDNfZ2VvX3BhdGhBcmVhLnBvaW50ID0gZDNfbm9vcDtcbiAgICAgIGQzX2dlb19wYXRoQXJlYVN1bSArPSBhYnMoZDNfZ2VvX3BhdGhBcmVhUG9seWdvbiAvIDIpO1xuICAgIH1cbiAgfTtcbiAgZnVuY3Rpb24gZDNfZ2VvX3BhdGhBcmVhUmluZ1N0YXJ0KCkge1xuICAgIHZhciB4MDAsIHkwMCwgeDAsIHkwO1xuICAgIGQzX2dlb19wYXRoQXJlYS5wb2ludCA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgIGQzX2dlb19wYXRoQXJlYS5wb2ludCA9IG5leHRQb2ludDtcbiAgICAgIHgwMCA9IHgwID0geCwgeTAwID0geTAgPSB5O1xuICAgIH07XG4gICAgZnVuY3Rpb24gbmV4dFBvaW50KHgsIHkpIHtcbiAgICAgIGQzX2dlb19wYXRoQXJlYVBvbHlnb24gKz0geTAgKiB4IC0geDAgKiB5O1xuICAgICAgeDAgPSB4LCB5MCA9IHk7XG4gICAgfVxuICAgIGQzX2dlb19wYXRoQXJlYS5saW5lRW5kID0gZnVuY3Rpb24oKSB7XG4gICAgICBuZXh0UG9pbnQoeDAwLCB5MDApO1xuICAgIH07XG4gIH1cbiAgdmFyIGQzX2dlb19wYXRoQm91bmRzWDAsIGQzX2dlb19wYXRoQm91bmRzWTAsIGQzX2dlb19wYXRoQm91bmRzWDEsIGQzX2dlb19wYXRoQm91bmRzWTE7XG4gIHZhciBkM19nZW9fcGF0aEJvdW5kcyA9IHtcbiAgICBwb2ludDogZDNfZ2VvX3BhdGhCb3VuZHNQb2ludCxcbiAgICBsaW5lU3RhcnQ6IGQzX25vb3AsXG4gICAgbGluZUVuZDogZDNfbm9vcCxcbiAgICBwb2x5Z29uU3RhcnQ6IGQzX25vb3AsXG4gICAgcG9seWdvbkVuZDogZDNfbm9vcFxuICB9O1xuICBmdW5jdGlvbiBkM19nZW9fcGF0aEJvdW5kc1BvaW50KHgsIHkpIHtcbiAgICBpZiAoeCA8IGQzX2dlb19wYXRoQm91bmRzWDApIGQzX2dlb19wYXRoQm91bmRzWDAgPSB4O1xuICAgIGlmICh4ID4gZDNfZ2VvX3BhdGhCb3VuZHNYMSkgZDNfZ2VvX3BhdGhCb3VuZHNYMSA9IHg7XG4gICAgaWYgKHkgPCBkM19nZW9fcGF0aEJvdW5kc1kwKSBkM19nZW9fcGF0aEJvdW5kc1kwID0geTtcbiAgICBpZiAoeSA+IGQzX2dlb19wYXRoQm91bmRzWTEpIGQzX2dlb19wYXRoQm91bmRzWTEgPSB5O1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb19wYXRoQnVmZmVyKCkge1xuICAgIHZhciBwb2ludENpcmNsZSA9IGQzX2dlb19wYXRoQnVmZmVyQ2lyY2xlKDQuNSksIGJ1ZmZlciA9IFtdO1xuICAgIHZhciBzdHJlYW0gPSB7XG4gICAgICBwb2ludDogcG9pbnQsXG4gICAgICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBzdHJlYW0ucG9pbnQgPSBwb2ludExpbmVTdGFydDtcbiAgICAgIH0sXG4gICAgICBsaW5lRW5kOiBsaW5lRW5kLFxuICAgICAgcG9seWdvblN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgc3RyZWFtLmxpbmVFbmQgPSBsaW5lRW5kUG9seWdvbjtcbiAgICAgIH0sXG4gICAgICBwb2x5Z29uRW5kOiBmdW5jdGlvbigpIHtcbiAgICAgICAgc3RyZWFtLmxpbmVFbmQgPSBsaW5lRW5kO1xuICAgICAgICBzdHJlYW0ucG9pbnQgPSBwb2ludDtcbiAgICAgIH0sXG4gICAgICBwb2ludFJhZGl1czogZnVuY3Rpb24oXykge1xuICAgICAgICBwb2ludENpcmNsZSA9IGQzX2dlb19wYXRoQnVmZmVyQ2lyY2xlKF8pO1xuICAgICAgICByZXR1cm4gc3RyZWFtO1xuICAgICAgfSxcbiAgICAgIHJlc3VsdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChidWZmZXIubGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IGJ1ZmZlci5qb2luKFwiXCIpO1xuICAgICAgICAgIGJ1ZmZlciA9IFtdO1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGZ1bmN0aW9uIHBvaW50KHgsIHkpIHtcbiAgICAgIGJ1ZmZlci5wdXNoKFwiTVwiLCB4LCBcIixcIiwgeSwgcG9pbnRDaXJjbGUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwb2ludExpbmVTdGFydCh4LCB5KSB7XG4gICAgICBidWZmZXIucHVzaChcIk1cIiwgeCwgXCIsXCIsIHkpO1xuICAgICAgc3RyZWFtLnBvaW50ID0gcG9pbnRMaW5lO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwb2ludExpbmUoeCwgeSkge1xuICAgICAgYnVmZmVyLnB1c2goXCJMXCIsIHgsIFwiLFwiLCB5KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbGluZUVuZCgpIHtcbiAgICAgIHN0cmVhbS5wb2ludCA9IHBvaW50O1xuICAgIH1cbiAgICBmdW5jdGlvbiBsaW5lRW5kUG9seWdvbigpIHtcbiAgICAgIGJ1ZmZlci5wdXNoKFwiWlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cmVhbTtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9fcGF0aEJ1ZmZlckNpcmNsZShyYWRpdXMpIHtcbiAgICByZXR1cm4gXCJtMCxcIiArIHJhZGl1cyArIFwiYVwiICsgcmFkaXVzICsgXCIsXCIgKyByYWRpdXMgKyBcIiAwIDEsMSAwLFwiICsgLTIgKiByYWRpdXMgKyBcImFcIiArIHJhZGl1cyArIFwiLFwiICsgcmFkaXVzICsgXCIgMCAxLDEgMCxcIiArIDIgKiByYWRpdXMgKyBcInpcIjtcbiAgfVxuICB2YXIgZDNfZ2VvX3BhdGhDZW50cm9pZCA9IHtcbiAgICBwb2ludDogZDNfZ2VvX3BhdGhDZW50cm9pZFBvaW50LFxuICAgIGxpbmVTdGFydDogZDNfZ2VvX3BhdGhDZW50cm9pZExpbmVTdGFydCxcbiAgICBsaW5lRW5kOiBkM19nZW9fcGF0aENlbnRyb2lkTGluZUVuZCxcbiAgICBwb2x5Z29uU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgZDNfZ2VvX3BhdGhDZW50cm9pZC5saW5lU3RhcnQgPSBkM19nZW9fcGF0aENlbnRyb2lkUmluZ1N0YXJ0O1xuICAgIH0sXG4gICAgcG9seWdvbkVuZDogZnVuY3Rpb24oKSB7XG4gICAgICBkM19nZW9fcGF0aENlbnRyb2lkLnBvaW50ID0gZDNfZ2VvX3BhdGhDZW50cm9pZFBvaW50O1xuICAgICAgZDNfZ2VvX3BhdGhDZW50cm9pZC5saW5lU3RhcnQgPSBkM19nZW9fcGF0aENlbnRyb2lkTGluZVN0YXJ0O1xuICAgICAgZDNfZ2VvX3BhdGhDZW50cm9pZC5saW5lRW5kID0gZDNfZ2VvX3BhdGhDZW50cm9pZExpbmVFbmQ7XG4gICAgfVxuICB9O1xuICBmdW5jdGlvbiBkM19nZW9fcGF0aENlbnRyb2lkUG9pbnQoeCwgeSkge1xuICAgIGQzX2dlb19jZW50cm9pZFgwICs9IHg7XG4gICAgZDNfZ2VvX2NlbnRyb2lkWTAgKz0geTtcbiAgICArK2QzX2dlb19jZW50cm9pZFowO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb19wYXRoQ2VudHJvaWRMaW5lU3RhcnQoKSB7XG4gICAgdmFyIHgwLCB5MDtcbiAgICBkM19nZW9fcGF0aENlbnRyb2lkLnBvaW50ID0gZnVuY3Rpb24oeCwgeSkge1xuICAgICAgZDNfZ2VvX3BhdGhDZW50cm9pZC5wb2ludCA9IG5leHRQb2ludDtcbiAgICAgIGQzX2dlb19wYXRoQ2VudHJvaWRQb2ludCh4MCA9IHgsIHkwID0geSk7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBuZXh0UG9pbnQoeCwgeSkge1xuICAgICAgdmFyIGR4ID0geCAtIHgwLCBkeSA9IHkgLSB5MCwgeiA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgICBkM19nZW9fY2VudHJvaWRYMSArPSB6ICogKHgwICsgeCkgLyAyO1xuICAgICAgZDNfZ2VvX2NlbnRyb2lkWTEgKz0geiAqICh5MCArIHkpIC8gMjtcbiAgICAgIGQzX2dlb19jZW50cm9pZFoxICs9IHo7XG4gICAgICBkM19nZW9fcGF0aENlbnRyb2lkUG9pbnQoeDAgPSB4LCB5MCA9IHkpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBkM19nZW9fcGF0aENlbnRyb2lkTGluZUVuZCgpIHtcbiAgICBkM19nZW9fcGF0aENlbnRyb2lkLnBvaW50ID0gZDNfZ2VvX3BhdGhDZW50cm9pZFBvaW50O1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb19wYXRoQ2VudHJvaWRSaW5nU3RhcnQoKSB7XG4gICAgdmFyIHgwMCwgeTAwLCB4MCwgeTA7XG4gICAgZDNfZ2VvX3BhdGhDZW50cm9pZC5wb2ludCA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgIGQzX2dlb19wYXRoQ2VudHJvaWQucG9pbnQgPSBuZXh0UG9pbnQ7XG4gICAgICBkM19nZW9fcGF0aENlbnRyb2lkUG9pbnQoeDAwID0geDAgPSB4LCB5MDAgPSB5MCA9IHkpO1xuICAgIH07XG4gICAgZnVuY3Rpb24gbmV4dFBvaW50KHgsIHkpIHtcbiAgICAgIHZhciBkeCA9IHggLSB4MCwgZHkgPSB5IC0geTAsIHogPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgICAgZDNfZ2VvX2NlbnRyb2lkWDEgKz0geiAqICh4MCArIHgpIC8gMjtcbiAgICAgIGQzX2dlb19jZW50cm9pZFkxICs9IHogKiAoeTAgKyB5KSAvIDI7XG4gICAgICBkM19nZW9fY2VudHJvaWRaMSArPSB6O1xuICAgICAgeiA9IHkwICogeCAtIHgwICogeTtcbiAgICAgIGQzX2dlb19jZW50cm9pZFgyICs9IHogKiAoeDAgKyB4KTtcbiAgICAgIGQzX2dlb19jZW50cm9pZFkyICs9IHogKiAoeTAgKyB5KTtcbiAgICAgIGQzX2dlb19jZW50cm9pZFoyICs9IHogKiAzO1xuICAgICAgZDNfZ2VvX3BhdGhDZW50cm9pZFBvaW50KHgwID0geCwgeTAgPSB5KTtcbiAgICB9XG4gICAgZDNfZ2VvX3BhdGhDZW50cm9pZC5saW5lRW5kID0gZnVuY3Rpb24oKSB7XG4gICAgICBuZXh0UG9pbnQoeDAwLCB5MDApO1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvX3BhdGhDb250ZXh0KGNvbnRleHQpIHtcbiAgICB2YXIgcG9pbnRSYWRpdXMgPSA0LjU7XG4gICAgdmFyIHN0cmVhbSA9IHtcbiAgICAgIHBvaW50OiBwb2ludCxcbiAgICAgIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHN0cmVhbS5wb2ludCA9IHBvaW50TGluZVN0YXJ0O1xuICAgICAgfSxcbiAgICAgIGxpbmVFbmQ6IGxpbmVFbmQsXG4gICAgICBwb2x5Z29uU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBzdHJlYW0ubGluZUVuZCA9IGxpbmVFbmRQb2x5Z29uO1xuICAgICAgfSxcbiAgICAgIHBvbHlnb25FbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBzdHJlYW0ubGluZUVuZCA9IGxpbmVFbmQ7XG4gICAgICAgIHN0cmVhbS5wb2ludCA9IHBvaW50O1xuICAgICAgfSxcbiAgICAgIHBvaW50UmFkaXVzOiBmdW5jdGlvbihfKSB7XG4gICAgICAgIHBvaW50UmFkaXVzID0gXztcbiAgICAgICAgcmV0dXJuIHN0cmVhbTtcbiAgICAgIH0sXG4gICAgICByZXN1bHQ6IGQzX25vb3BcbiAgICB9O1xuICAgIGZ1bmN0aW9uIHBvaW50KHgsIHkpIHtcbiAgICAgIGNvbnRleHQubW92ZVRvKHggKyBwb2ludFJhZGl1cywgeSk7XG4gICAgICBjb250ZXh0LmFyYyh4LCB5LCBwb2ludFJhZGl1cywgMCwgz4QpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwb2ludExpbmVTdGFydCh4LCB5KSB7XG4gICAgICBjb250ZXh0Lm1vdmVUbyh4LCB5KTtcbiAgICAgIHN0cmVhbS5wb2ludCA9IHBvaW50TGluZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcG9pbnRMaW5lKHgsIHkpIHtcbiAgICAgIGNvbnRleHQubGluZVRvKHgsIHkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBsaW5lRW5kKCkge1xuICAgICAgc3RyZWFtLnBvaW50ID0gcG9pbnQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGxpbmVFbmRQb2x5Z29uKCkge1xuICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cmVhbTtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9fcmVzYW1wbGUocHJvamVjdCkge1xuICAgIHZhciDOtDIgPSAuNSwgY29zTWluRGlzdGFuY2UgPSBNYXRoLmNvcygzMCAqIGQzX3JhZGlhbnMpLCBtYXhEZXB0aCA9IDE2O1xuICAgIGZ1bmN0aW9uIHJlc2FtcGxlKHN0cmVhbSkge1xuICAgICAgcmV0dXJuIChtYXhEZXB0aCA/IHJlc2FtcGxlUmVjdXJzaXZlIDogcmVzYW1wbGVOb25lKShzdHJlYW0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXNhbXBsZU5vbmUoc3RyZWFtKSB7XG4gICAgICByZXR1cm4gZDNfZ2VvX3RyYW5zZm9ybVBvaW50KHN0cmVhbSwgZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICB4ID0gcHJvamVjdCh4LCB5KTtcbiAgICAgICAgc3RyZWFtLnBvaW50KHhbMF0sIHhbMV0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc2FtcGxlUmVjdXJzaXZlKHN0cmVhbSkge1xuICAgICAgdmFyIM67MDAsIM+GMDAsIHgwMCwgeTAwLCBhMDAsIGIwMCwgYzAwLCDOuzAsIHgwLCB5MCwgYTAsIGIwLCBjMDtcbiAgICAgIHZhciByZXNhbXBsZSA9IHtcbiAgICAgICAgcG9pbnQ6IHBvaW50LFxuICAgICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgICAgbGluZUVuZDogbGluZUVuZCxcbiAgICAgICAgcG9seWdvblN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBzdHJlYW0ucG9seWdvblN0YXJ0KCk7XG4gICAgICAgICAgcmVzYW1wbGUubGluZVN0YXJ0ID0gcmluZ1N0YXJ0O1xuICAgICAgICB9LFxuICAgICAgICBwb2x5Z29uRW5kOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBzdHJlYW0ucG9seWdvbkVuZCgpO1xuICAgICAgICAgIHJlc2FtcGxlLmxpbmVTdGFydCA9IGxpbmVTdGFydDtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGZ1bmN0aW9uIHBvaW50KHgsIHkpIHtcbiAgICAgICAgeCA9IHByb2plY3QoeCwgeSk7XG4gICAgICAgIHN0cmVhbS5wb2ludCh4WzBdLCB4WzFdKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGxpbmVTdGFydCgpIHtcbiAgICAgICAgeDAgPSBOYU47XG4gICAgICAgIHJlc2FtcGxlLnBvaW50ID0gbGluZVBvaW50O1xuICAgICAgICBzdHJlYW0ubGluZVN0YXJ0KCk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBsaW5lUG9pbnQozrssIM+GKSB7XG4gICAgICAgIHZhciBjID0gZDNfZ2VvX2NhcnRlc2lhbihbIM67LCDPhiBdKSwgcCA9IHByb2plY3QozrssIM+GKTtcbiAgICAgICAgcmVzYW1wbGVMaW5lVG8oeDAsIHkwLCDOuzAsIGEwLCBiMCwgYzAsIHgwID0gcFswXSwgeTAgPSBwWzFdLCDOuzAgPSDOuywgYTAgPSBjWzBdLCBiMCA9IGNbMV0sIGMwID0gY1syXSwgbWF4RGVwdGgsIHN0cmVhbSk7XG4gICAgICAgIHN0cmVhbS5wb2ludCh4MCwgeTApO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gbGluZUVuZCgpIHtcbiAgICAgICAgcmVzYW1wbGUucG9pbnQgPSBwb2ludDtcbiAgICAgICAgc3RyZWFtLmxpbmVFbmQoKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHJpbmdTdGFydCgpIHtcbiAgICAgICAgbGluZVN0YXJ0KCk7XG4gICAgICAgIHJlc2FtcGxlLnBvaW50ID0gcmluZ1BvaW50O1xuICAgICAgICByZXNhbXBsZS5saW5lRW5kID0gcmluZ0VuZDtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHJpbmdQb2ludCjOuywgz4YpIHtcbiAgICAgICAgbGluZVBvaW50KM67MDAgPSDOuywgz4YwMCA9IM+GKSwgeDAwID0geDAsIHkwMCA9IHkwLCBhMDAgPSBhMCwgYjAwID0gYjAsIGMwMCA9IGMwO1xuICAgICAgICByZXNhbXBsZS5wb2ludCA9IGxpbmVQb2ludDtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHJpbmdFbmQoKSB7XG4gICAgICAgIHJlc2FtcGxlTGluZVRvKHgwLCB5MCwgzrswLCBhMCwgYjAsIGMwLCB4MDAsIHkwMCwgzrswMCwgYTAwLCBiMDAsIGMwMCwgbWF4RGVwdGgsIHN0cmVhbSk7XG4gICAgICAgIHJlc2FtcGxlLmxpbmVFbmQgPSBsaW5lRW5kO1xuICAgICAgICBsaW5lRW5kKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzYW1wbGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc2FtcGxlTGluZVRvKHgwLCB5MCwgzrswLCBhMCwgYjAsIGMwLCB4MSwgeTEsIM67MSwgYTEsIGIxLCBjMSwgZGVwdGgsIHN0cmVhbSkge1xuICAgICAgdmFyIGR4ID0geDEgLSB4MCwgZHkgPSB5MSAtIHkwLCBkMiA9IGR4ICogZHggKyBkeSAqIGR5O1xuICAgICAgaWYgKGQyID4gNCAqIM60MiAmJiBkZXB0aC0tKSB7XG4gICAgICAgIHZhciBhID0gYTAgKyBhMSwgYiA9IGIwICsgYjEsIGMgPSBjMCArIGMxLCBtID0gTWF0aC5zcXJ0KGEgKiBhICsgYiAqIGIgKyBjICogYyksIM+GMiA9IE1hdGguYXNpbihjIC89IG0pLCDOuzIgPSBhYnMoYWJzKGMpIC0gMSkgPCDOtSB8fCBhYnMozrswIC0gzrsxKSA8IM61ID8gKM67MCArIM67MSkgLyAyIDogTWF0aC5hdGFuMihiLCBhKSwgcCA9IHByb2plY3QozrsyLCDPhjIpLCB4MiA9IHBbMF0sIHkyID0gcFsxXSwgZHgyID0geDIgLSB4MCwgZHkyID0geTIgLSB5MCwgZHogPSBkeSAqIGR4MiAtIGR4ICogZHkyO1xuICAgICAgICBpZiAoZHogKiBkeiAvIGQyID4gzrQyIHx8IGFicygoZHggKiBkeDIgKyBkeSAqIGR5MikgLyBkMiAtIC41KSA+IC4zIHx8IGEwICogYTEgKyBiMCAqIGIxICsgYzAgKiBjMSA8IGNvc01pbkRpc3RhbmNlKSB7XG4gICAgICAgICAgcmVzYW1wbGVMaW5lVG8oeDAsIHkwLCDOuzAsIGEwLCBiMCwgYzAsIHgyLCB5MiwgzrsyLCBhIC89IG0sIGIgLz0gbSwgYywgZGVwdGgsIHN0cmVhbSk7XG4gICAgICAgICAgc3RyZWFtLnBvaW50KHgyLCB5Mik7XG4gICAgICAgICAgcmVzYW1wbGVMaW5lVG8oeDIsIHkyLCDOuzIsIGEsIGIsIGMsIHgxLCB5MSwgzrsxLCBhMSwgYjEsIGMxLCBkZXB0aCwgc3RyZWFtKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXNhbXBsZS5wcmVjaXNpb24gPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBNYXRoLnNxcnQozrQyKTtcbiAgICAgIG1heERlcHRoID0gKM60MiA9IF8gKiBfKSA+IDAgJiYgMTY7XG4gICAgICByZXR1cm4gcmVzYW1wbGU7XG4gICAgfTtcbiAgICByZXR1cm4gcmVzYW1wbGU7XG4gIH1cbiAgZDMuZ2VvLnBhdGggPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcG9pbnRSYWRpdXMgPSA0LjUsIHByb2plY3Rpb24sIGNvbnRleHQsIHByb2plY3RTdHJlYW0sIGNvbnRleHRTdHJlYW0sIGNhY2hlU3RyZWFtO1xuICAgIGZ1bmN0aW9uIHBhdGgob2JqZWN0KSB7XG4gICAgICBpZiAob2JqZWN0KSB7XG4gICAgICAgIGlmICh0eXBlb2YgcG9pbnRSYWRpdXMgPT09IFwiZnVuY3Rpb25cIikgY29udGV4dFN0cmVhbS5wb2ludFJhZGl1cygrcG9pbnRSYWRpdXMuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgICAgIGlmICghY2FjaGVTdHJlYW0gfHwgIWNhY2hlU3RyZWFtLnZhbGlkKSBjYWNoZVN0cmVhbSA9IHByb2plY3RTdHJlYW0oY29udGV4dFN0cmVhbSk7XG4gICAgICAgIGQzLmdlby5zdHJlYW0ob2JqZWN0LCBjYWNoZVN0cmVhbSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29udGV4dFN0cmVhbS5yZXN1bHQoKTtcbiAgICB9XG4gICAgcGF0aC5hcmVhID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICBkM19nZW9fcGF0aEFyZWFTdW0gPSAwO1xuICAgICAgZDMuZ2VvLnN0cmVhbShvYmplY3QsIHByb2plY3RTdHJlYW0oZDNfZ2VvX3BhdGhBcmVhKSk7XG4gICAgICByZXR1cm4gZDNfZ2VvX3BhdGhBcmVhU3VtO1xuICAgIH07XG4gICAgcGF0aC5jZW50cm9pZCA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgZDNfZ2VvX2NlbnRyb2lkWDAgPSBkM19nZW9fY2VudHJvaWRZMCA9IGQzX2dlb19jZW50cm9pZFowID0gZDNfZ2VvX2NlbnRyb2lkWDEgPSBkM19nZW9fY2VudHJvaWRZMSA9IGQzX2dlb19jZW50cm9pZFoxID0gZDNfZ2VvX2NlbnRyb2lkWDIgPSBkM19nZW9fY2VudHJvaWRZMiA9IGQzX2dlb19jZW50cm9pZFoyID0gMDtcbiAgICAgIGQzLmdlby5zdHJlYW0ob2JqZWN0LCBwcm9qZWN0U3RyZWFtKGQzX2dlb19wYXRoQ2VudHJvaWQpKTtcbiAgICAgIHJldHVybiBkM19nZW9fY2VudHJvaWRaMiA/IFsgZDNfZ2VvX2NlbnRyb2lkWDIgLyBkM19nZW9fY2VudHJvaWRaMiwgZDNfZ2VvX2NlbnRyb2lkWTIgLyBkM19nZW9fY2VudHJvaWRaMiBdIDogZDNfZ2VvX2NlbnRyb2lkWjEgPyBbIGQzX2dlb19jZW50cm9pZFgxIC8gZDNfZ2VvX2NlbnRyb2lkWjEsIGQzX2dlb19jZW50cm9pZFkxIC8gZDNfZ2VvX2NlbnRyb2lkWjEgXSA6IGQzX2dlb19jZW50cm9pZFowID8gWyBkM19nZW9fY2VudHJvaWRYMCAvIGQzX2dlb19jZW50cm9pZFowLCBkM19nZW9fY2VudHJvaWRZMCAvIGQzX2dlb19jZW50cm9pZFowIF0gOiBbIE5hTiwgTmFOIF07XG4gICAgfTtcbiAgICBwYXRoLmJvdW5kcyA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgZDNfZ2VvX3BhdGhCb3VuZHNYMSA9IGQzX2dlb19wYXRoQm91bmRzWTEgPSAtKGQzX2dlb19wYXRoQm91bmRzWDAgPSBkM19nZW9fcGF0aEJvdW5kc1kwID0gSW5maW5pdHkpO1xuICAgICAgZDMuZ2VvLnN0cmVhbShvYmplY3QsIHByb2plY3RTdHJlYW0oZDNfZ2VvX3BhdGhCb3VuZHMpKTtcbiAgICAgIHJldHVybiBbIFsgZDNfZ2VvX3BhdGhCb3VuZHNYMCwgZDNfZ2VvX3BhdGhCb3VuZHNZMCBdLCBbIGQzX2dlb19wYXRoQm91bmRzWDEsIGQzX2dlb19wYXRoQm91bmRzWTEgXSBdO1xuICAgIH07XG4gICAgcGF0aC5wcm9qZWN0aW9uID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gcHJvamVjdGlvbjtcbiAgICAgIHByb2plY3RTdHJlYW0gPSAocHJvamVjdGlvbiA9IF8pID8gXy5zdHJlYW0gfHwgZDNfZ2VvX3BhdGhQcm9qZWN0U3RyZWFtKF8pIDogZDNfaWRlbnRpdHk7XG4gICAgICByZXR1cm4gcmVzZXQoKTtcbiAgICB9O1xuICAgIHBhdGguY29udGV4dCA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGNvbnRleHQ7XG4gICAgICBjb250ZXh0U3RyZWFtID0gKGNvbnRleHQgPSBfKSA9PSBudWxsID8gbmV3IGQzX2dlb19wYXRoQnVmZmVyKCkgOiBuZXcgZDNfZ2VvX3BhdGhDb250ZXh0KF8pO1xuICAgICAgaWYgKHR5cGVvZiBwb2ludFJhZGl1cyAhPT0gXCJmdW5jdGlvblwiKSBjb250ZXh0U3RyZWFtLnBvaW50UmFkaXVzKHBvaW50UmFkaXVzKTtcbiAgICAgIHJldHVybiByZXNldCgpO1xuICAgIH07XG4gICAgcGF0aC5wb2ludFJhZGl1cyA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHBvaW50UmFkaXVzO1xuICAgICAgcG9pbnRSYWRpdXMgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IChjb250ZXh0U3RyZWFtLnBvaW50UmFkaXVzKCtfKSwgK18pO1xuICAgICAgcmV0dXJuIHBhdGg7XG4gICAgfTtcbiAgICBmdW5jdGlvbiByZXNldCgpIHtcbiAgICAgIGNhY2hlU3RyZWFtID0gbnVsbDtcbiAgICAgIHJldHVybiBwYXRoO1xuICAgIH1cbiAgICByZXR1cm4gcGF0aC5wcm9qZWN0aW9uKGQzLmdlby5hbGJlcnNVc2EoKSkuY29udGV4dChudWxsKTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfZ2VvX3BhdGhQcm9qZWN0U3RyZWFtKHByb2plY3QpIHtcbiAgICB2YXIgcmVzYW1wbGUgPSBkM19nZW9fcmVzYW1wbGUoZnVuY3Rpb24oeCwgeSkge1xuICAgICAgcmV0dXJuIHByb2plY3QoWyB4ICogZDNfZGVncmVlcywgeSAqIGQzX2RlZ3JlZXMgXSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHN0cmVhbSkge1xuICAgICAgcmV0dXJuIGQzX2dlb19wcm9qZWN0aW9uUmFkaWFucyhyZXNhbXBsZShzdHJlYW0pKTtcbiAgICB9O1xuICB9XG4gIGQzLmdlby50cmFuc2Zvcm0gPSBmdW5jdGlvbihtZXRob2RzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0cmVhbTogZnVuY3Rpb24oc3RyZWFtKSB7XG4gICAgICAgIHZhciB0cmFuc2Zvcm0gPSBuZXcgZDNfZ2VvX3RyYW5zZm9ybShzdHJlYW0pO1xuICAgICAgICBmb3IgKHZhciBrIGluIG1ldGhvZHMpIHRyYW5zZm9ybVtrXSA9IG1ldGhvZHNba107XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm07XG4gICAgICB9XG4gICAgfTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfZ2VvX3RyYW5zZm9ybShzdHJlYW0pIHtcbiAgICB0aGlzLnN0cmVhbSA9IHN0cmVhbTtcbiAgfVxuICBkM19nZW9fdHJhbnNmb3JtLnByb3RvdHlwZSA9IHtcbiAgICBwb2ludDogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgdGhpcy5zdHJlYW0ucG9pbnQoeCwgeSk7XG4gICAgfSxcbiAgICBzcGhlcmU6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5zdHJlYW0uc3BoZXJlKCk7XG4gICAgfSxcbiAgICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5zdHJlYW0ubGluZVN0YXJ0KCk7XG4gICAgfSxcbiAgICBsaW5lRW5kOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuc3RyZWFtLmxpbmVFbmQoKTtcbiAgICB9LFxuICAgIHBvbHlnb25TdGFydDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnN0cmVhbS5wb2x5Z29uU3RhcnQoKTtcbiAgICB9LFxuICAgIHBvbHlnb25FbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5zdHJlYW0ucG9seWdvbkVuZCgpO1xuICAgIH1cbiAgfTtcbiAgZnVuY3Rpb24gZDNfZ2VvX3RyYW5zZm9ybVBvaW50KHN0cmVhbSwgcG9pbnQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcG9pbnQ6IHBvaW50LFxuICAgICAgc3BoZXJlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgc3RyZWFtLnNwaGVyZSgpO1xuICAgICAgfSxcbiAgICAgIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHN0cmVhbS5saW5lU3RhcnQoKTtcbiAgICAgIH0sXG4gICAgICBsaW5lRW5kOiBmdW5jdGlvbigpIHtcbiAgICAgICAgc3RyZWFtLmxpbmVFbmQoKTtcbiAgICAgIH0sXG4gICAgICBwb2x5Z29uU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBzdHJlYW0ucG9seWdvblN0YXJ0KCk7XG4gICAgICB9LFxuICAgICAgcG9seWdvbkVuZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHN0cmVhbS5wb2x5Z29uRW5kKCk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBkMy5nZW8ucHJvamVjdGlvbiA9IGQzX2dlb19wcm9qZWN0aW9uO1xuICBkMy5nZW8ucHJvamVjdGlvbk11dGF0b3IgPSBkM19nZW9fcHJvamVjdGlvbk11dGF0b3I7XG4gIGZ1bmN0aW9uIGQzX2dlb19wcm9qZWN0aW9uKHByb2plY3QpIHtcbiAgICByZXR1cm4gZDNfZ2VvX3Byb2plY3Rpb25NdXRhdG9yKGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHByb2plY3Q7XG4gICAgfSkoKTtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9fcHJvamVjdGlvbk11dGF0b3IocHJvamVjdEF0KSB7XG4gICAgdmFyIHByb2plY3QsIHJvdGF0ZSwgcHJvamVjdFJvdGF0ZSwgcHJvamVjdFJlc2FtcGxlID0gZDNfZ2VvX3Jlc2FtcGxlKGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgIHggPSBwcm9qZWN0KHgsIHkpO1xuICAgICAgcmV0dXJuIFsgeFswXSAqIGsgKyDOtHgsIM60eSAtIHhbMV0gKiBrIF07XG4gICAgfSksIGsgPSAxNTAsIHggPSA0ODAsIHkgPSAyNTAsIM67ID0gMCwgz4YgPSAwLCDOtM67ID0gMCwgzrTPhiA9IDAsIM60zrMgPSAwLCDOtHgsIM60eSwgcHJlY2xpcCA9IGQzX2dlb19jbGlwQW50aW1lcmlkaWFuLCBwb3N0Y2xpcCA9IGQzX2lkZW50aXR5LCBjbGlwQW5nbGUgPSBudWxsLCBjbGlwRXh0ZW50ID0gbnVsbCwgc3RyZWFtO1xuICAgIGZ1bmN0aW9uIHByb2plY3Rpb24ocG9pbnQpIHtcbiAgICAgIHBvaW50ID0gcHJvamVjdFJvdGF0ZShwb2ludFswXSAqIGQzX3JhZGlhbnMsIHBvaW50WzFdICogZDNfcmFkaWFucyk7XG4gICAgICByZXR1cm4gWyBwb2ludFswXSAqIGsgKyDOtHgsIM60eSAtIHBvaW50WzFdICogayBdO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpbnZlcnQocG9pbnQpIHtcbiAgICAgIHBvaW50ID0gcHJvamVjdFJvdGF0ZS5pbnZlcnQoKHBvaW50WzBdIC0gzrR4KSAvIGssICjOtHkgLSBwb2ludFsxXSkgLyBrKTtcbiAgICAgIHJldHVybiBwb2ludCAmJiBbIHBvaW50WzBdICogZDNfZGVncmVlcywgcG9pbnRbMV0gKiBkM19kZWdyZWVzIF07XG4gICAgfVxuICAgIHByb2plY3Rpb24uc3RyZWFtID0gZnVuY3Rpb24ob3V0cHV0KSB7XG4gICAgICBpZiAoc3RyZWFtKSBzdHJlYW0udmFsaWQgPSBmYWxzZTtcbiAgICAgIHN0cmVhbSA9IGQzX2dlb19wcm9qZWN0aW9uUmFkaWFucyhwcmVjbGlwKHJvdGF0ZSwgcHJvamVjdFJlc2FtcGxlKHBvc3RjbGlwKG91dHB1dCkpKSk7XG4gICAgICBzdHJlYW0udmFsaWQgPSB0cnVlO1xuICAgICAgcmV0dXJuIHN0cmVhbTtcbiAgICB9O1xuICAgIHByb2plY3Rpb24uY2xpcEFuZ2xlID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gY2xpcEFuZ2xlO1xuICAgICAgcHJlY2xpcCA9IF8gPT0gbnVsbCA/IChjbGlwQW5nbGUgPSBfLCBkM19nZW9fY2xpcEFudGltZXJpZGlhbikgOiBkM19nZW9fY2xpcENpcmNsZSgoY2xpcEFuZ2xlID0gK18pICogZDNfcmFkaWFucyk7XG4gICAgICByZXR1cm4gaW52YWxpZGF0ZSgpO1xuICAgIH07XG4gICAgcHJvamVjdGlvbi5jbGlwRXh0ZW50ID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gY2xpcEV4dGVudDtcbiAgICAgIGNsaXBFeHRlbnQgPSBfO1xuICAgICAgcG9zdGNsaXAgPSBfID8gZDNfZ2VvX2NsaXBFeHRlbnQoX1swXVswXSwgX1swXVsxXSwgX1sxXVswXSwgX1sxXVsxXSkgOiBkM19pZGVudGl0eTtcbiAgICAgIHJldHVybiBpbnZhbGlkYXRlKCk7XG4gICAgfTtcbiAgICBwcm9qZWN0aW9uLnNjYWxlID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gaztcbiAgICAgIGsgPSArXztcbiAgICAgIHJldHVybiByZXNldCgpO1xuICAgIH07XG4gICAgcHJvamVjdGlvbi50cmFuc2xhdGUgPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBbIHgsIHkgXTtcbiAgICAgIHggPSArX1swXTtcbiAgICAgIHkgPSArX1sxXTtcbiAgICAgIHJldHVybiByZXNldCgpO1xuICAgIH07XG4gICAgcHJvamVjdGlvbi5jZW50ZXIgPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBbIM67ICogZDNfZGVncmVlcywgz4YgKiBkM19kZWdyZWVzIF07XG4gICAgICDOuyA9IF9bMF0gJSAzNjAgKiBkM19yYWRpYW5zO1xuICAgICAgz4YgPSBfWzFdICUgMzYwICogZDNfcmFkaWFucztcbiAgICAgIHJldHVybiByZXNldCgpO1xuICAgIH07XG4gICAgcHJvamVjdGlvbi5yb3RhdGUgPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBbIM60zrsgKiBkM19kZWdyZWVzLCDOtM+GICogZDNfZGVncmVlcywgzrTOsyAqIGQzX2RlZ3JlZXMgXTtcbiAgICAgIM60zrsgPSBfWzBdICUgMzYwICogZDNfcmFkaWFucztcbiAgICAgIM60z4YgPSBfWzFdICUgMzYwICogZDNfcmFkaWFucztcbiAgICAgIM60zrMgPSBfLmxlbmd0aCA+IDIgPyBfWzJdICUgMzYwICogZDNfcmFkaWFucyA6IDA7XG4gICAgICByZXR1cm4gcmVzZXQoKTtcbiAgICB9O1xuICAgIGQzLnJlYmluZChwcm9qZWN0aW9uLCBwcm9qZWN0UmVzYW1wbGUsIFwicHJlY2lzaW9uXCIpO1xuICAgIGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgICAgcHJvamVjdFJvdGF0ZSA9IGQzX2dlb19jb21wb3NlKHJvdGF0ZSA9IGQzX2dlb19yb3RhdGlvbijOtM67LCDOtM+GLCDOtM6zKSwgcHJvamVjdCk7XG4gICAgICB2YXIgY2VudGVyID0gcHJvamVjdCjOuywgz4YpO1xuICAgICAgzrR4ID0geCAtIGNlbnRlclswXSAqIGs7XG4gICAgICDOtHkgPSB5ICsgY2VudGVyWzFdICogaztcbiAgICAgIHJldHVybiBpbnZhbGlkYXRlKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGludmFsaWRhdGUoKSB7XG4gICAgICBpZiAoc3RyZWFtKSBzdHJlYW0udmFsaWQgPSBmYWxzZSwgc3RyZWFtID0gbnVsbDtcbiAgICAgIHJldHVybiBwcm9qZWN0aW9uO1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICBwcm9qZWN0ID0gcHJvamVjdEF0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICBwcm9qZWN0aW9uLmludmVydCA9IHByb2plY3QuaW52ZXJ0ICYmIGludmVydDtcbiAgICAgIHJldHVybiByZXNldCgpO1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvX3Byb2plY3Rpb25SYWRpYW5zKHN0cmVhbSkge1xuICAgIHJldHVybiBkM19nZW9fdHJhbnNmb3JtUG9pbnQoc3RyZWFtLCBmdW5jdGlvbih4LCB5KSB7XG4gICAgICBzdHJlYW0ucG9pbnQoeCAqIGQzX3JhZGlhbnMsIHkgKiBkM19yYWRpYW5zKTtcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9fZXF1aXJlY3Rhbmd1bGFyKM67LCDPhikge1xuICAgIHJldHVybiBbIM67LCDPhiBdO1xuICB9XG4gIChkMy5nZW8uZXF1aXJlY3Rhbmd1bGFyID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGQzX2dlb19wcm9qZWN0aW9uKGQzX2dlb19lcXVpcmVjdGFuZ3VsYXIpO1xuICB9KS5yYXcgPSBkM19nZW9fZXF1aXJlY3Rhbmd1bGFyLmludmVydCA9IGQzX2dlb19lcXVpcmVjdGFuZ3VsYXI7XG4gIGQzLmdlby5yb3RhdGlvbiA9IGZ1bmN0aW9uKHJvdGF0ZSkge1xuICAgIHJvdGF0ZSA9IGQzX2dlb19yb3RhdGlvbihyb3RhdGVbMF0gJSAzNjAgKiBkM19yYWRpYW5zLCByb3RhdGVbMV0gKiBkM19yYWRpYW5zLCByb3RhdGUubGVuZ3RoID4gMiA/IHJvdGF0ZVsyXSAqIGQzX3JhZGlhbnMgOiAwKTtcbiAgICBmdW5jdGlvbiBmb3J3YXJkKGNvb3JkaW5hdGVzKSB7XG4gICAgICBjb29yZGluYXRlcyA9IHJvdGF0ZShjb29yZGluYXRlc1swXSAqIGQzX3JhZGlhbnMsIGNvb3JkaW5hdGVzWzFdICogZDNfcmFkaWFucyk7XG4gICAgICByZXR1cm4gY29vcmRpbmF0ZXNbMF0gKj0gZDNfZGVncmVlcywgY29vcmRpbmF0ZXNbMV0gKj0gZDNfZGVncmVlcywgY29vcmRpbmF0ZXM7XG4gICAgfVxuICAgIGZvcndhcmQuaW52ZXJ0ID0gZnVuY3Rpb24oY29vcmRpbmF0ZXMpIHtcbiAgICAgIGNvb3JkaW5hdGVzID0gcm90YXRlLmludmVydChjb29yZGluYXRlc1swXSAqIGQzX3JhZGlhbnMsIGNvb3JkaW5hdGVzWzFdICogZDNfcmFkaWFucyk7XG4gICAgICByZXR1cm4gY29vcmRpbmF0ZXNbMF0gKj0gZDNfZGVncmVlcywgY29vcmRpbmF0ZXNbMV0gKj0gZDNfZGVncmVlcywgY29vcmRpbmF0ZXM7XG4gICAgfTtcbiAgICByZXR1cm4gZm9yd2FyZDtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfZ2VvX2lkZW50aXR5Um90YXRpb24ozrssIM+GKSB7XG4gICAgcmV0dXJuIFsgzrsgPiDPgCA/IM67IC0gz4QgOiDOuyA8IC3PgCA/IM67ICsgz4QgOiDOuywgz4YgXTtcbiAgfVxuICBkM19nZW9faWRlbnRpdHlSb3RhdGlvbi5pbnZlcnQgPSBkM19nZW9fZXF1aXJlY3Rhbmd1bGFyO1xuICBmdW5jdGlvbiBkM19nZW9fcm90YXRpb24ozrTOuywgzrTPhiwgzrTOsykge1xuICAgIHJldHVybiDOtM67ID8gzrTPhiB8fCDOtM6zID8gZDNfZ2VvX2NvbXBvc2UoZDNfZ2VvX3JvdGF0aW9uzrsozrTOuyksIGQzX2dlb19yb3RhdGlvbs+GzrMozrTPhiwgzrTOsykpIDogZDNfZ2VvX3JvdGF0aW9uzrsozrTOuykgOiDOtM+GIHx8IM60zrMgPyBkM19nZW9fcm90YXRpb27Phs6zKM60z4YsIM60zrMpIDogZDNfZ2VvX2lkZW50aXR5Um90YXRpb247XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvX2ZvcndhcmRSb3RhdGlvbs67KM60zrspIHtcbiAgICByZXR1cm4gZnVuY3Rpb24ozrssIM+GKSB7XG4gICAgICByZXR1cm4gzrsgKz0gzrTOuywgWyDOuyA+IM+AID8gzrsgLSDPhCA6IM67IDwgLc+AID8gzrsgKyDPhCA6IM67LCDPhiBdO1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvX3JvdGF0aW9uzrsozrTOuykge1xuICAgIHZhciByb3RhdGlvbiA9IGQzX2dlb19mb3J3YXJkUm90YXRpb27OuyjOtM67KTtcbiAgICByb3RhdGlvbi5pbnZlcnQgPSBkM19nZW9fZm9yd2FyZFJvdGF0aW9uzrsoLc60zrspO1xuICAgIHJldHVybiByb3RhdGlvbjtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9fcm90YXRpb27Phs6zKM60z4YsIM60zrMpIHtcbiAgICB2YXIgY29zzrTPhiA9IE1hdGguY29zKM60z4YpLCBzaW7OtM+GID0gTWF0aC5zaW4ozrTPhiksIGNvc860zrMgPSBNYXRoLmNvcyjOtM6zKSwgc2luzrTOsyA9IE1hdGguc2luKM60zrMpO1xuICAgIGZ1bmN0aW9uIHJvdGF0aW9uKM67LCDPhikge1xuICAgICAgdmFyIGNvc8+GID0gTWF0aC5jb3Moz4YpLCB4ID0gTWF0aC5jb3MozrspICogY29zz4YsIHkgPSBNYXRoLnNpbijOuykgKiBjb3PPhiwgeiA9IE1hdGguc2luKM+GKSwgayA9IHogKiBjb3POtM+GICsgeCAqIHNpbs60z4Y7XG4gICAgICByZXR1cm4gWyBNYXRoLmF0YW4yKHkgKiBjb3POtM6zIC0gayAqIHNpbs60zrMsIHggKiBjb3POtM+GIC0geiAqIHNpbs60z4YpLCBkM19hc2luKGsgKiBjb3POtM6zICsgeSAqIHNpbs60zrMpIF07XG4gICAgfVxuICAgIHJvdGF0aW9uLmludmVydCA9IGZ1bmN0aW9uKM67LCDPhikge1xuICAgICAgdmFyIGNvc8+GID0gTWF0aC5jb3Moz4YpLCB4ID0gTWF0aC5jb3MozrspICogY29zz4YsIHkgPSBNYXRoLnNpbijOuykgKiBjb3PPhiwgeiA9IE1hdGguc2luKM+GKSwgayA9IHogKiBjb3POtM6zIC0geSAqIHNpbs60zrM7XG4gICAgICByZXR1cm4gWyBNYXRoLmF0YW4yKHkgKiBjb3POtM6zICsgeiAqIHNpbs60zrMsIHggKiBjb3POtM+GICsgayAqIHNpbs60z4YpLCBkM19hc2luKGsgKiBjb3POtM+GIC0geCAqIHNpbs60z4YpIF07XG4gICAgfTtcbiAgICByZXR1cm4gcm90YXRpb247XG4gIH1cbiAgZDMuZ2VvLmNpcmNsZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvcmlnaW4gPSBbIDAsIDAgXSwgYW5nbGUsIHByZWNpc2lvbiA9IDYsIGludGVycG9sYXRlO1xuICAgIGZ1bmN0aW9uIGNpcmNsZSgpIHtcbiAgICAgIHZhciBjZW50ZXIgPSB0eXBlb2Ygb3JpZ2luID09PSBcImZ1bmN0aW9uXCIgPyBvcmlnaW4uYXBwbHkodGhpcywgYXJndW1lbnRzKSA6IG9yaWdpbiwgcm90YXRlID0gZDNfZ2VvX3JvdGF0aW9uKC1jZW50ZXJbMF0gKiBkM19yYWRpYW5zLCAtY2VudGVyWzFdICogZDNfcmFkaWFucywgMCkuaW52ZXJ0LCByaW5nID0gW107XG4gICAgICBpbnRlcnBvbGF0ZShudWxsLCBudWxsLCAxLCB7XG4gICAgICAgIHBvaW50OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgICAgcmluZy5wdXNoKHggPSByb3RhdGUoeCwgeSkpO1xuICAgICAgICAgIHhbMF0gKj0gZDNfZGVncmVlcywgeFsxXSAqPSBkM19kZWdyZWVzO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiUG9seWdvblwiLFxuICAgICAgICBjb29yZGluYXRlczogWyByaW5nIF1cbiAgICAgIH07XG4gICAgfVxuICAgIGNpcmNsZS5vcmlnaW4gPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBvcmlnaW47XG4gICAgICBvcmlnaW4gPSB4O1xuICAgICAgcmV0dXJuIGNpcmNsZTtcbiAgICB9O1xuICAgIGNpcmNsZS5hbmdsZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGFuZ2xlO1xuICAgICAgaW50ZXJwb2xhdGUgPSBkM19nZW9fY2lyY2xlSW50ZXJwb2xhdGUoKGFuZ2xlID0gK3gpICogZDNfcmFkaWFucywgcHJlY2lzaW9uICogZDNfcmFkaWFucyk7XG4gICAgICByZXR1cm4gY2lyY2xlO1xuICAgIH07XG4gICAgY2lyY2xlLnByZWNpc2lvbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHByZWNpc2lvbjtcbiAgICAgIGludGVycG9sYXRlID0gZDNfZ2VvX2NpcmNsZUludGVycG9sYXRlKGFuZ2xlICogZDNfcmFkaWFucywgKHByZWNpc2lvbiA9ICtfKSAqIGQzX3JhZGlhbnMpO1xuICAgICAgcmV0dXJuIGNpcmNsZTtcbiAgICB9O1xuICAgIHJldHVybiBjaXJjbGUuYW5nbGUoOTApO1xuICB9O1xuICBmdW5jdGlvbiBkM19nZW9fY2lyY2xlSW50ZXJwb2xhdGUocmFkaXVzLCBwcmVjaXNpb24pIHtcbiAgICB2YXIgY3IgPSBNYXRoLmNvcyhyYWRpdXMpLCBzciA9IE1hdGguc2luKHJhZGl1cyk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGZyb20sIHRvLCBkaXJlY3Rpb24sIGxpc3RlbmVyKSB7XG4gICAgICB2YXIgc3RlcCA9IGRpcmVjdGlvbiAqIHByZWNpc2lvbjtcbiAgICAgIGlmIChmcm9tICE9IG51bGwpIHtcbiAgICAgICAgZnJvbSA9IGQzX2dlb19jaXJjbGVBbmdsZShjciwgZnJvbSk7XG4gICAgICAgIHRvID0gZDNfZ2VvX2NpcmNsZUFuZ2xlKGNyLCB0byk7XG4gICAgICAgIGlmIChkaXJlY3Rpb24gPiAwID8gZnJvbSA8IHRvIDogZnJvbSA+IHRvKSBmcm9tICs9IGRpcmVjdGlvbiAqIM+EO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZnJvbSA9IHJhZGl1cyArIGRpcmVjdGlvbiAqIM+EO1xuICAgICAgICB0byA9IHJhZGl1cyAtIC41ICogc3RlcDtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIHBvaW50LCB0ID0gZnJvbTsgZGlyZWN0aW9uID4gMCA/IHQgPiB0byA6IHQgPCB0bzsgdCAtPSBzdGVwKSB7XG4gICAgICAgIGxpc3RlbmVyLnBvaW50KChwb2ludCA9IGQzX2dlb19zcGhlcmljYWwoWyBjciwgLXNyICogTWF0aC5jb3ModCksIC1zciAqIE1hdGguc2luKHQpIF0pKVswXSwgcG9pbnRbMV0pO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvX2NpcmNsZUFuZ2xlKGNyLCBwb2ludCkge1xuICAgIHZhciBhID0gZDNfZ2VvX2NhcnRlc2lhbihwb2ludCk7XG4gICAgYVswXSAtPSBjcjtcbiAgICBkM19nZW9fY2FydGVzaWFuTm9ybWFsaXplKGEpO1xuICAgIHZhciBhbmdsZSA9IGQzX2Fjb3MoLWFbMV0pO1xuICAgIHJldHVybiAoKC1hWzJdIDwgMCA/IC1hbmdsZSA6IGFuZ2xlKSArIDIgKiBNYXRoLlBJIC0gzrUpICUgKDIgKiBNYXRoLlBJKTtcbiAgfVxuICBkMy5nZW8uZGlzdGFuY2UgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgdmFyIM6UzrsgPSAoYlswXSAtIGFbMF0pICogZDNfcmFkaWFucywgz4YwID0gYVsxXSAqIGQzX3JhZGlhbnMsIM+GMSA9IGJbMV0gKiBkM19yYWRpYW5zLCBzaW7OlM67ID0gTWF0aC5zaW4ozpTOuyksIGNvc86UzrsgPSBNYXRoLmNvcyjOlM67KSwgc2luz4YwID0gTWF0aC5zaW4oz4YwKSwgY29zz4YwID0gTWF0aC5jb3Moz4YwKSwgc2luz4YxID0gTWF0aC5zaW4oz4YxKSwgY29zz4YxID0gTWF0aC5jb3Moz4YxKSwgdDtcbiAgICByZXR1cm4gTWF0aC5hdGFuMihNYXRoLnNxcnQoKHQgPSBjb3PPhjEgKiBzaW7OlM67KSAqIHQgKyAodCA9IGNvc8+GMCAqIHNpbs+GMSAtIHNpbs+GMCAqIGNvc8+GMSAqIGNvc86UzrspICogdCksIHNpbs+GMCAqIHNpbs+GMSArIGNvc8+GMCAqIGNvc8+GMSAqIGNvc86UzrspO1xuICB9O1xuICBkMy5nZW8uZ3JhdGljdWxlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHgxLCB4MCwgWDEsIFgwLCB5MSwgeTAsIFkxLCBZMCwgZHggPSAxMCwgZHkgPSBkeCwgRFggPSA5MCwgRFkgPSAzNjAsIHgsIHksIFgsIFksIHByZWNpc2lvbiA9IDIuNTtcbiAgICBmdW5jdGlvbiBncmF0aWN1bGUoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcIk11bHRpTGluZVN0cmluZ1wiLFxuICAgICAgICBjb29yZGluYXRlczogbGluZXMoKVxuICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbGluZXMoKSB7XG4gICAgICByZXR1cm4gZDMucmFuZ2UoTWF0aC5jZWlsKFgwIC8gRFgpICogRFgsIFgxLCBEWCkubWFwKFgpLmNvbmNhdChkMy5yYW5nZShNYXRoLmNlaWwoWTAgLyBEWSkgKiBEWSwgWTEsIERZKS5tYXAoWSkpLmNvbmNhdChkMy5yYW5nZShNYXRoLmNlaWwoeDAgLyBkeCkgKiBkeCwgeDEsIGR4KS5maWx0ZXIoZnVuY3Rpb24oeCkge1xuICAgICAgICByZXR1cm4gYWJzKHggJSBEWCkgPiDOtTtcbiAgICAgIH0pLm1hcCh4KSkuY29uY2F0KGQzLnJhbmdlKE1hdGguY2VpbCh5MCAvIGR5KSAqIGR5LCB5MSwgZHkpLmZpbHRlcihmdW5jdGlvbih5KSB7XG4gICAgICAgIHJldHVybiBhYnMoeSAlIERZKSA+IM61O1xuICAgICAgfSkubWFwKHkpKTtcbiAgICB9XG4gICAgZ3JhdGljdWxlLmxpbmVzID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbGluZXMoKS5tYXAoZnVuY3Rpb24oY29vcmRpbmF0ZXMpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiBcIkxpbmVTdHJpbmdcIixcbiAgICAgICAgICBjb29yZGluYXRlczogY29vcmRpbmF0ZXNcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgZ3JhdGljdWxlLm91dGxpbmUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiUG9seWdvblwiLFxuICAgICAgICBjb29yZGluYXRlczogWyBYKFgwKS5jb25jYXQoWShZMSkuc2xpY2UoMSksIFgoWDEpLnJldmVyc2UoKS5zbGljZSgxKSwgWShZMCkucmV2ZXJzZSgpLnNsaWNlKDEpKSBdXG4gICAgICB9O1xuICAgIH07XG4gICAgZ3JhdGljdWxlLmV4dGVudCA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGdyYXRpY3VsZS5taW5vckV4dGVudCgpO1xuICAgICAgcmV0dXJuIGdyYXRpY3VsZS5tYWpvckV4dGVudChfKS5taW5vckV4dGVudChfKTtcbiAgICB9O1xuICAgIGdyYXRpY3VsZS5tYWpvckV4dGVudCA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIFsgWyBYMCwgWTAgXSwgWyBYMSwgWTEgXSBdO1xuICAgICAgWDAgPSArX1swXVswXSwgWDEgPSArX1sxXVswXTtcbiAgICAgIFkwID0gK19bMF1bMV0sIFkxID0gK19bMV1bMV07XG4gICAgICBpZiAoWDAgPiBYMSkgXyA9IFgwLCBYMCA9IFgxLCBYMSA9IF87XG4gICAgICBpZiAoWTAgPiBZMSkgXyA9IFkwLCBZMCA9IFkxLCBZMSA9IF87XG4gICAgICByZXR1cm4gZ3JhdGljdWxlLnByZWNpc2lvbihwcmVjaXNpb24pO1xuICAgIH07XG4gICAgZ3JhdGljdWxlLm1pbm9yRXh0ZW50ID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gWyBbIHgwLCB5MCBdLCBbIHgxLCB5MSBdIF07XG4gICAgICB4MCA9ICtfWzBdWzBdLCB4MSA9ICtfWzFdWzBdO1xuICAgICAgeTAgPSArX1swXVsxXSwgeTEgPSArX1sxXVsxXTtcbiAgICAgIGlmICh4MCA+IHgxKSBfID0geDAsIHgwID0geDEsIHgxID0gXztcbiAgICAgIGlmICh5MCA+IHkxKSBfID0geTAsIHkwID0geTEsIHkxID0gXztcbiAgICAgIHJldHVybiBncmF0aWN1bGUucHJlY2lzaW9uKHByZWNpc2lvbik7XG4gICAgfTtcbiAgICBncmF0aWN1bGUuc3RlcCA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGdyYXRpY3VsZS5taW5vclN0ZXAoKTtcbiAgICAgIHJldHVybiBncmF0aWN1bGUubWFqb3JTdGVwKF8pLm1pbm9yU3RlcChfKTtcbiAgICB9O1xuICAgIGdyYXRpY3VsZS5tYWpvclN0ZXAgPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBbIERYLCBEWSBdO1xuICAgICAgRFggPSArX1swXSwgRFkgPSArX1sxXTtcbiAgICAgIHJldHVybiBncmF0aWN1bGU7XG4gICAgfTtcbiAgICBncmF0aWN1bGUubWlub3JTdGVwID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gWyBkeCwgZHkgXTtcbiAgICAgIGR4ID0gK19bMF0sIGR5ID0gK19bMV07XG4gICAgICByZXR1cm4gZ3JhdGljdWxlO1xuICAgIH07XG4gICAgZ3JhdGljdWxlLnByZWNpc2lvbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHByZWNpc2lvbjtcbiAgICAgIHByZWNpc2lvbiA9ICtfO1xuICAgICAgeCA9IGQzX2dlb19ncmF0aWN1bGVYKHkwLCB5MSwgOTApO1xuICAgICAgeSA9IGQzX2dlb19ncmF0aWN1bGVZKHgwLCB4MSwgcHJlY2lzaW9uKTtcbiAgICAgIFggPSBkM19nZW9fZ3JhdGljdWxlWChZMCwgWTEsIDkwKTtcbiAgICAgIFkgPSBkM19nZW9fZ3JhdGljdWxlWShYMCwgWDEsIHByZWNpc2lvbik7XG4gICAgICByZXR1cm4gZ3JhdGljdWxlO1xuICAgIH07XG4gICAgcmV0dXJuIGdyYXRpY3VsZS5tYWpvckV4dGVudChbIFsgLTE4MCwgLTkwICsgzrUgXSwgWyAxODAsIDkwIC0gzrUgXSBdKS5taW5vckV4dGVudChbIFsgLTE4MCwgLTgwIC0gzrUgXSwgWyAxODAsIDgwICsgzrUgXSBdKTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfZ2VvX2dyYXRpY3VsZVgoeTAsIHkxLCBkeSkge1xuICAgIHZhciB5ID0gZDMucmFuZ2UoeTAsIHkxIC0gzrUsIGR5KS5jb25jYXQoeTEpO1xuICAgIHJldHVybiBmdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4geS5tYXAoZnVuY3Rpb24oeSkge1xuICAgICAgICByZXR1cm4gWyB4LCB5IF07XG4gICAgICB9KTtcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb19ncmF0aWN1bGVZKHgwLCB4MSwgZHgpIHtcbiAgICB2YXIgeCA9IGQzLnJhbmdlKHgwLCB4MSAtIM61LCBkeCkuY29uY2F0KHgxKTtcbiAgICByZXR1cm4gZnVuY3Rpb24oeSkge1xuICAgICAgcmV0dXJuIHgubWFwKGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgcmV0dXJuIFsgeCwgeSBdO1xuICAgICAgfSk7XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBkM19zb3VyY2UoZCkge1xuICAgIHJldHVybiBkLnNvdXJjZTtcbiAgfVxuICBmdW5jdGlvbiBkM190YXJnZXQoZCkge1xuICAgIHJldHVybiBkLnRhcmdldDtcbiAgfVxuICBkMy5nZW8uZ3JlYXRBcmMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgc291cmNlID0gZDNfc291cmNlLCBzb3VyY2VfLCB0YXJnZXQgPSBkM190YXJnZXQsIHRhcmdldF87XG4gICAgZnVuY3Rpb24gZ3JlYXRBcmMoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcIkxpbmVTdHJpbmdcIixcbiAgICAgICAgY29vcmRpbmF0ZXM6IFsgc291cmNlXyB8fCBzb3VyY2UuYXBwbHkodGhpcywgYXJndW1lbnRzKSwgdGFyZ2V0XyB8fCB0YXJnZXQuYXBwbHkodGhpcywgYXJndW1lbnRzKSBdXG4gICAgICB9O1xuICAgIH1cbiAgICBncmVhdEFyYy5kaXN0YW5jZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGQzLmdlby5kaXN0YW5jZShzb3VyY2VfIHx8IHNvdXJjZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpLCB0YXJnZXRfIHx8IHRhcmdldC5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgICB9O1xuICAgIGdyZWF0QXJjLnNvdXJjZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHNvdXJjZTtcbiAgICAgIHNvdXJjZSA9IF8sIHNvdXJjZV8gPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gbnVsbCA6IF87XG4gICAgICByZXR1cm4gZ3JlYXRBcmM7XG4gICAgfTtcbiAgICBncmVhdEFyYy50YXJnZXQgPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0YXJnZXQ7XG4gICAgICB0YXJnZXQgPSBfLCB0YXJnZXRfID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IG51bGwgOiBfO1xuICAgICAgcmV0dXJuIGdyZWF0QXJjO1xuICAgIH07XG4gICAgZ3JlYXRBcmMucHJlY2lzaW9uID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IGdyZWF0QXJjIDogMDtcbiAgICB9O1xuICAgIHJldHVybiBncmVhdEFyYztcbiAgfTtcbiAgZDMuZ2VvLmludGVycG9sYXRlID0gZnVuY3Rpb24oc291cmNlLCB0YXJnZXQpIHtcbiAgICByZXR1cm4gZDNfZ2VvX2ludGVycG9sYXRlKHNvdXJjZVswXSAqIGQzX3JhZGlhbnMsIHNvdXJjZVsxXSAqIGQzX3JhZGlhbnMsIHRhcmdldFswXSAqIGQzX3JhZGlhbnMsIHRhcmdldFsxXSAqIGQzX3JhZGlhbnMpO1xuICB9O1xuICBmdW5jdGlvbiBkM19nZW9faW50ZXJwb2xhdGUoeDAsIHkwLCB4MSwgeTEpIHtcbiAgICB2YXIgY3kwID0gTWF0aC5jb3MoeTApLCBzeTAgPSBNYXRoLnNpbih5MCksIGN5MSA9IE1hdGguY29zKHkxKSwgc3kxID0gTWF0aC5zaW4oeTEpLCBreDAgPSBjeTAgKiBNYXRoLmNvcyh4MCksIGt5MCA9IGN5MCAqIE1hdGguc2luKHgwKSwga3gxID0gY3kxICogTWF0aC5jb3MoeDEpLCBreTEgPSBjeTEgKiBNYXRoLnNpbih4MSksIGQgPSAyICogTWF0aC5hc2luKE1hdGguc3FydChkM19oYXZlcnNpbih5MSAtIHkwKSArIGN5MCAqIGN5MSAqIGQzX2hhdmVyc2luKHgxIC0geDApKSksIGsgPSAxIC8gTWF0aC5zaW4oZCk7XG4gICAgdmFyIGludGVycG9sYXRlID0gZCA/IGZ1bmN0aW9uKHQpIHtcbiAgICAgIHZhciBCID0gTWF0aC5zaW4odCAqPSBkKSAqIGssIEEgPSBNYXRoLnNpbihkIC0gdCkgKiBrLCB4ID0gQSAqIGt4MCArIEIgKiBreDEsIHkgPSBBICoga3kwICsgQiAqIGt5MSwgeiA9IEEgKiBzeTAgKyBCICogc3kxO1xuICAgICAgcmV0dXJuIFsgTWF0aC5hdGFuMih5LCB4KSAqIGQzX2RlZ3JlZXMsIE1hdGguYXRhbjIoeiwgTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpKSAqIGQzX2RlZ3JlZXMgXTtcbiAgICB9IDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gWyB4MCAqIGQzX2RlZ3JlZXMsIHkwICogZDNfZGVncmVlcyBdO1xuICAgIH07XG4gICAgaW50ZXJwb2xhdGUuZGlzdGFuY2UgPSBkO1xuICAgIHJldHVybiBpbnRlcnBvbGF0ZTtcbiAgfVxuICBkMy5nZW8ubGVuZ3RoID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgZDNfZ2VvX2xlbmd0aFN1bSA9IDA7XG4gICAgZDMuZ2VvLnN0cmVhbShvYmplY3QsIGQzX2dlb19sZW5ndGgpO1xuICAgIHJldHVybiBkM19nZW9fbGVuZ3RoU3VtO1xuICB9O1xuICB2YXIgZDNfZ2VvX2xlbmd0aFN1bTtcbiAgdmFyIGQzX2dlb19sZW5ndGggPSB7XG4gICAgc3BoZXJlOiBkM19ub29wLFxuICAgIHBvaW50OiBkM19ub29wLFxuICAgIGxpbmVTdGFydDogZDNfZ2VvX2xlbmd0aExpbmVTdGFydCxcbiAgICBsaW5lRW5kOiBkM19ub29wLFxuICAgIHBvbHlnb25TdGFydDogZDNfbm9vcCxcbiAgICBwb2x5Z29uRW5kOiBkM19ub29wXG4gIH07XG4gIGZ1bmN0aW9uIGQzX2dlb19sZW5ndGhMaW5lU3RhcnQoKSB7XG4gICAgdmFyIM67MCwgc2luz4YwLCBjb3PPhjA7XG4gICAgZDNfZ2VvX2xlbmd0aC5wb2ludCA9IGZ1bmN0aW9uKM67LCDPhikge1xuICAgICAgzrswID0gzrsgKiBkM19yYWRpYW5zLCBzaW7PhjAgPSBNYXRoLnNpbijPhiAqPSBkM19yYWRpYW5zKSwgY29zz4YwID0gTWF0aC5jb3Moz4YpO1xuICAgICAgZDNfZ2VvX2xlbmd0aC5wb2ludCA9IG5leHRQb2ludDtcbiAgICB9O1xuICAgIGQzX2dlb19sZW5ndGgubGluZUVuZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgZDNfZ2VvX2xlbmd0aC5wb2ludCA9IGQzX2dlb19sZW5ndGgubGluZUVuZCA9IGQzX25vb3A7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBuZXh0UG9pbnQozrssIM+GKSB7XG4gICAgICB2YXIgc2luz4YgPSBNYXRoLnNpbijPhiAqPSBkM19yYWRpYW5zKSwgY29zz4YgPSBNYXRoLmNvcyjPhiksIHQgPSBhYnMoKM67ICo9IGQzX3JhZGlhbnMpIC0gzrswKSwgY29zzpTOuyA9IE1hdGguY29zKHQpO1xuICAgICAgZDNfZ2VvX2xlbmd0aFN1bSArPSBNYXRoLmF0YW4yKE1hdGguc3FydCgodCA9IGNvc8+GICogTWF0aC5zaW4odCkpICogdCArICh0ID0gY29zz4YwICogc2luz4YgLSBzaW7PhjAgKiBjb3PPhiAqIGNvc86UzrspICogdCksIHNpbs+GMCAqIHNpbs+GICsgY29zz4YwICogY29zz4YgKiBjb3POlM67KTtcbiAgICAgIM67MCA9IM67LCBzaW7PhjAgPSBzaW7PhiwgY29zz4YwID0gY29zz4Y7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb19hemltdXRoYWwoc2NhbGUsIGFuZ2xlKSB7XG4gICAgZnVuY3Rpb24gYXppbXV0aGFsKM67LCDPhikge1xuICAgICAgdmFyIGNvc867ID0gTWF0aC5jb3MozrspLCBjb3PPhiA9IE1hdGguY29zKM+GKSwgayA9IHNjYWxlKGNvc867ICogY29zz4YpO1xuICAgICAgcmV0dXJuIFsgayAqIGNvc8+GICogTWF0aC5zaW4ozrspLCBrICogTWF0aC5zaW4oz4YpIF07XG4gICAgfVxuICAgIGF6aW11dGhhbC5pbnZlcnQgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgICB2YXIgz4EgPSBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSksIGMgPSBhbmdsZSjPgSksIHNpbmMgPSBNYXRoLnNpbihjKSwgY29zYyA9IE1hdGguY29zKGMpO1xuICAgICAgcmV0dXJuIFsgTWF0aC5hdGFuMih4ICogc2luYywgz4EgKiBjb3NjKSwgTWF0aC5hc2luKM+BICYmIHkgKiBzaW5jIC8gz4EpIF07XG4gICAgfTtcbiAgICByZXR1cm4gYXppbXV0aGFsO1xuICB9XG4gIHZhciBkM19nZW9fYXppbXV0aGFsRXF1YWxBcmVhID0gZDNfZ2VvX2F6aW11dGhhbChmdW5jdGlvbihjb3POu2Nvc8+GKSB7XG4gICAgcmV0dXJuIE1hdGguc3FydCgyIC8gKDEgKyBjb3POu2Nvc8+GKSk7XG4gIH0sIGZ1bmN0aW9uKM+BKSB7XG4gICAgcmV0dXJuIDIgKiBNYXRoLmFzaW4oz4EgLyAyKTtcbiAgfSk7XG4gIChkMy5nZW8uYXppbXV0aGFsRXF1YWxBcmVhID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGQzX2dlb19wcm9qZWN0aW9uKGQzX2dlb19hemltdXRoYWxFcXVhbEFyZWEpO1xuICB9KS5yYXcgPSBkM19nZW9fYXppbXV0aGFsRXF1YWxBcmVhO1xuICB2YXIgZDNfZ2VvX2F6aW11dGhhbEVxdWlkaXN0YW50ID0gZDNfZ2VvX2F6aW11dGhhbChmdW5jdGlvbihjb3POu2Nvc8+GKSB7XG4gICAgdmFyIGMgPSBNYXRoLmFjb3MoY29zzrtjb3PPhik7XG4gICAgcmV0dXJuIGMgJiYgYyAvIE1hdGguc2luKGMpO1xuICB9LCBkM19pZGVudGl0eSk7XG4gIChkMy5nZW8uYXppbXV0aGFsRXF1aWRpc3RhbnQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZDNfZ2VvX3Byb2plY3Rpb24oZDNfZ2VvX2F6aW11dGhhbEVxdWlkaXN0YW50KTtcbiAgfSkucmF3ID0gZDNfZ2VvX2F6aW11dGhhbEVxdWlkaXN0YW50O1xuICBmdW5jdGlvbiBkM19nZW9fY29uaWNDb25mb3JtYWwoz4YwLCDPhjEpIHtcbiAgICB2YXIgY29zz4YwID0gTWF0aC5jb3Moz4YwKSwgdCA9IGZ1bmN0aW9uKM+GKSB7XG4gICAgICByZXR1cm4gTWF0aC50YW4oz4AgLyA0ICsgz4YgLyAyKTtcbiAgICB9LCBuID0gz4YwID09PSDPhjEgPyBNYXRoLnNpbijPhjApIDogTWF0aC5sb2coY29zz4YwIC8gTWF0aC5jb3Moz4YxKSkgLyBNYXRoLmxvZyh0KM+GMSkgLyB0KM+GMCkpLCBGID0gY29zz4YwICogTWF0aC5wb3codCjPhjApLCBuKSAvIG47XG4gICAgaWYgKCFuKSByZXR1cm4gZDNfZ2VvX21lcmNhdG9yO1xuICAgIGZ1bmN0aW9uIGZvcndhcmQozrssIM+GKSB7XG4gICAgICBpZiAoRiA+IDApIHtcbiAgICAgICAgaWYgKM+GIDwgLWhhbGbPgCArIM61KSDPhiA9IC1oYWxmz4AgKyDOtTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICjPhiA+IGhhbGbPgCAtIM61KSDPhiA9IGhhbGbPgCAtIM61O1xuICAgICAgfVxuICAgICAgdmFyIM+BID0gRiAvIE1hdGgucG93KHQoz4YpLCBuKTtcbiAgICAgIHJldHVybiBbIM+BICogTWF0aC5zaW4obiAqIM67KSwgRiAtIM+BICogTWF0aC5jb3MobiAqIM67KSBdO1xuICAgIH1cbiAgICBmb3J3YXJkLmludmVydCA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgIHZhciDPgTBfeSA9IEYgLSB5LCDPgSA9IGQzX3NnbihuKSAqIE1hdGguc3FydCh4ICogeCArIM+BMF95ICogz4EwX3kpO1xuICAgICAgcmV0dXJuIFsgTWF0aC5hdGFuMih4LCDPgTBfeSkgLyBuLCAyICogTWF0aC5hdGFuKE1hdGgucG93KEYgLyDPgSwgMSAvIG4pKSAtIGhhbGbPgCBdO1xuICAgIH07XG4gICAgcmV0dXJuIGZvcndhcmQ7XG4gIH1cbiAgKGQzLmdlby5jb25pY0NvbmZvcm1hbCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkM19nZW9fY29uaWMoZDNfZ2VvX2NvbmljQ29uZm9ybWFsKTtcbiAgfSkucmF3ID0gZDNfZ2VvX2NvbmljQ29uZm9ybWFsO1xuICBmdW5jdGlvbiBkM19nZW9fY29uaWNFcXVpZGlzdGFudCjPhjAsIM+GMSkge1xuICAgIHZhciBjb3PPhjAgPSBNYXRoLmNvcyjPhjApLCBuID0gz4YwID09PSDPhjEgPyBNYXRoLnNpbijPhjApIDogKGNvc8+GMCAtIE1hdGguY29zKM+GMSkpIC8gKM+GMSAtIM+GMCksIEcgPSBjb3PPhjAgLyBuICsgz4YwO1xuICAgIGlmIChhYnMobikgPCDOtSkgcmV0dXJuIGQzX2dlb19lcXVpcmVjdGFuZ3VsYXI7XG4gICAgZnVuY3Rpb24gZm9yd2FyZCjOuywgz4YpIHtcbiAgICAgIHZhciDPgSA9IEcgLSDPhjtcbiAgICAgIHJldHVybiBbIM+BICogTWF0aC5zaW4obiAqIM67KSwgRyAtIM+BICogTWF0aC5jb3MobiAqIM67KSBdO1xuICAgIH1cbiAgICBmb3J3YXJkLmludmVydCA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgIHZhciDPgTBfeSA9IEcgLSB5O1xuICAgICAgcmV0dXJuIFsgTWF0aC5hdGFuMih4LCDPgTBfeSkgLyBuLCBHIC0gZDNfc2duKG4pICogTWF0aC5zcXJ0KHggKiB4ICsgz4EwX3kgKiDPgTBfeSkgXTtcbiAgICB9O1xuICAgIHJldHVybiBmb3J3YXJkO1xuICB9XG4gIChkMy5nZW8uY29uaWNFcXVpZGlzdGFudCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkM19nZW9fY29uaWMoZDNfZ2VvX2NvbmljRXF1aWRpc3RhbnQpO1xuICB9KS5yYXcgPSBkM19nZW9fY29uaWNFcXVpZGlzdGFudDtcbiAgdmFyIGQzX2dlb19nbm9tb25pYyA9IGQzX2dlb19hemltdXRoYWwoZnVuY3Rpb24oY29zzrtjb3PPhikge1xuICAgIHJldHVybiAxIC8gY29zzrtjb3PPhjtcbiAgfSwgTWF0aC5hdGFuKTtcbiAgKGQzLmdlby5nbm9tb25pYyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkM19nZW9fcHJvamVjdGlvbihkM19nZW9fZ25vbW9uaWMpO1xuICB9KS5yYXcgPSBkM19nZW9fZ25vbW9uaWM7XG4gIGZ1bmN0aW9uIGQzX2dlb19tZXJjYXRvcijOuywgz4YpIHtcbiAgICByZXR1cm4gWyDOuywgTWF0aC5sb2coTWF0aC50YW4oz4AgLyA0ICsgz4YgLyAyKSkgXTtcbiAgfVxuICBkM19nZW9fbWVyY2F0b3IuaW52ZXJ0ID0gZnVuY3Rpb24oeCwgeSkge1xuICAgIHJldHVybiBbIHgsIDIgKiBNYXRoLmF0YW4oTWF0aC5leHAoeSkpIC0gaGFsZs+AIF07XG4gIH07XG4gIGZ1bmN0aW9uIGQzX2dlb19tZXJjYXRvclByb2plY3Rpb24ocHJvamVjdCkge1xuICAgIHZhciBtID0gZDNfZ2VvX3Byb2plY3Rpb24ocHJvamVjdCksIHNjYWxlID0gbS5zY2FsZSwgdHJhbnNsYXRlID0gbS50cmFuc2xhdGUsIGNsaXBFeHRlbnQgPSBtLmNsaXBFeHRlbnQsIGNsaXBBdXRvO1xuICAgIG0uc2NhbGUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB2ID0gc2NhbGUuYXBwbHkobSwgYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiB2ID09PSBtID8gY2xpcEF1dG8gPyBtLmNsaXBFeHRlbnQobnVsbCkgOiBtIDogdjtcbiAgICB9O1xuICAgIG0udHJhbnNsYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdiA9IHRyYW5zbGF0ZS5hcHBseShtLCBhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIHYgPT09IG0gPyBjbGlwQXV0byA/IG0uY2xpcEV4dGVudChudWxsKSA6IG0gOiB2O1xuICAgIH07XG4gICAgbS5jbGlwRXh0ZW50ID0gZnVuY3Rpb24oXykge1xuICAgICAgdmFyIHYgPSBjbGlwRXh0ZW50LmFwcGx5KG0sIGFyZ3VtZW50cyk7XG4gICAgICBpZiAodiA9PT0gbSkge1xuICAgICAgICBpZiAoY2xpcEF1dG8gPSBfID09IG51bGwpIHtcbiAgICAgICAgICB2YXIgayA9IM+AICogc2NhbGUoKSwgdCA9IHRyYW5zbGF0ZSgpO1xuICAgICAgICAgIGNsaXBFeHRlbnQoWyBbIHRbMF0gLSBrLCB0WzFdIC0gayBdLCBbIHRbMF0gKyBrLCB0WzFdICsgayBdIF0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGNsaXBBdXRvKSB7XG4gICAgICAgIHYgPSBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHY7XG4gICAgfTtcbiAgICByZXR1cm4gbS5jbGlwRXh0ZW50KG51bGwpO1xuICB9XG4gIChkMy5nZW8ubWVyY2F0b3IgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZDNfZ2VvX21lcmNhdG9yUHJvamVjdGlvbihkM19nZW9fbWVyY2F0b3IpO1xuICB9KS5yYXcgPSBkM19nZW9fbWVyY2F0b3I7XG4gIHZhciBkM19nZW9fb3J0aG9ncmFwaGljID0gZDNfZ2VvX2F6aW11dGhhbChmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gMTtcbiAgfSwgTWF0aC5hc2luKTtcbiAgKGQzLmdlby5vcnRob2dyYXBoaWMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZDNfZ2VvX3Byb2plY3Rpb24oZDNfZ2VvX29ydGhvZ3JhcGhpYyk7XG4gIH0pLnJhdyA9IGQzX2dlb19vcnRob2dyYXBoaWM7XG4gIHZhciBkM19nZW9fc3RlcmVvZ3JhcGhpYyA9IGQzX2dlb19hemltdXRoYWwoZnVuY3Rpb24oY29zzrtjb3PPhikge1xuICAgIHJldHVybiAxIC8gKDEgKyBjb3POu2Nvc8+GKTtcbiAgfSwgZnVuY3Rpb24oz4EpIHtcbiAgICByZXR1cm4gMiAqIE1hdGguYXRhbijPgSk7XG4gIH0pO1xuICAoZDMuZ2VvLnN0ZXJlb2dyYXBoaWMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZDNfZ2VvX3Byb2plY3Rpb24oZDNfZ2VvX3N0ZXJlb2dyYXBoaWMpO1xuICB9KS5yYXcgPSBkM19nZW9fc3RlcmVvZ3JhcGhpYztcbiAgZnVuY3Rpb24gZDNfZ2VvX3RyYW5zdmVyc2VNZXJjYXRvcijOuywgz4YpIHtcbiAgICByZXR1cm4gWyBNYXRoLmxvZyhNYXRoLnRhbijPgCAvIDQgKyDPhiAvIDIpKSwgLc67IF07XG4gIH1cbiAgZDNfZ2VvX3RyYW5zdmVyc2VNZXJjYXRvci5pbnZlcnQgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgcmV0dXJuIFsgLXksIDIgKiBNYXRoLmF0YW4oTWF0aC5leHAoeCkpIC0gaGFsZs+AIF07XG4gIH07XG4gIChkMy5nZW8udHJhbnN2ZXJzZU1lcmNhdG9yID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHByb2plY3Rpb24gPSBkM19nZW9fbWVyY2F0b3JQcm9qZWN0aW9uKGQzX2dlb190cmFuc3ZlcnNlTWVyY2F0b3IpLCBjZW50ZXIgPSBwcm9qZWN0aW9uLmNlbnRlciwgcm90YXRlID0gcHJvamVjdGlvbi5yb3RhdGU7XG4gICAgcHJvamVjdGlvbi5jZW50ZXIgPSBmdW5jdGlvbihfKSB7XG4gICAgICByZXR1cm4gXyA/IGNlbnRlcihbIC1fWzFdLCBfWzBdIF0pIDogKF8gPSBjZW50ZXIoKSwgWyBfWzFdLCAtX1swXSBdKTtcbiAgICB9O1xuICAgIHByb2plY3Rpb24ucm90YXRlID0gZnVuY3Rpb24oXykge1xuICAgICAgcmV0dXJuIF8gPyByb3RhdGUoWyBfWzBdLCBfWzFdLCBfLmxlbmd0aCA+IDIgPyBfWzJdICsgOTAgOiA5MCBdKSA6IChfID0gcm90YXRlKCksIFxuICAgICAgWyBfWzBdLCBfWzFdLCBfWzJdIC0gOTAgXSk7XG4gICAgfTtcbiAgICByZXR1cm4gcm90YXRlKFsgMCwgMCwgOTAgXSk7XG4gIH0pLnJhdyA9IGQzX2dlb190cmFuc3ZlcnNlTWVyY2F0b3I7XG4gIGQzLmdlb20gPSB7fTtcbiAgZnVuY3Rpb24gZDNfZ2VvbV9wb2ludFgoZCkge1xuICAgIHJldHVybiBkWzBdO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb21fcG9pbnRZKGQpIHtcbiAgICByZXR1cm4gZFsxXTtcbiAgfVxuICBkMy5nZW9tLmh1bGwgPSBmdW5jdGlvbih2ZXJ0aWNlcykge1xuICAgIHZhciB4ID0gZDNfZ2VvbV9wb2ludFgsIHkgPSBkM19nZW9tX3BvaW50WTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGh1bGwodmVydGljZXMpO1xuICAgIGZ1bmN0aW9uIGh1bGwoZGF0YSkge1xuICAgICAgaWYgKGRhdGEubGVuZ3RoIDwgMykgcmV0dXJuIFtdO1xuICAgICAgdmFyIGZ4ID0gZDNfZnVuY3Rvcih4KSwgZnkgPSBkM19mdW5jdG9yKHkpLCBpLCBuID0gZGF0YS5sZW5ndGgsIHBvaW50cyA9IFtdLCBmbGlwcGVkUG9pbnRzID0gW107XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIHBvaW50cy5wdXNoKFsgK2Z4LmNhbGwodGhpcywgZGF0YVtpXSwgaSksICtmeS5jYWxsKHRoaXMsIGRhdGFbaV0sIGkpLCBpIF0pO1xuICAgICAgfVxuICAgICAgcG9pbnRzLnNvcnQoZDNfZ2VvbV9odWxsT3JkZXIpO1xuICAgICAgZm9yIChpID0gMDsgaSA8IG47IGkrKykgZmxpcHBlZFBvaW50cy5wdXNoKFsgcG9pbnRzW2ldWzBdLCAtcG9pbnRzW2ldWzFdIF0pO1xuICAgICAgdmFyIHVwcGVyID0gZDNfZ2VvbV9odWxsVXBwZXIocG9pbnRzKSwgbG93ZXIgPSBkM19nZW9tX2h1bGxVcHBlcihmbGlwcGVkUG9pbnRzKTtcbiAgICAgIHZhciBza2lwTGVmdCA9IGxvd2VyWzBdID09PSB1cHBlclswXSwgc2tpcFJpZ2h0ID0gbG93ZXJbbG93ZXIubGVuZ3RoIC0gMV0gPT09IHVwcGVyW3VwcGVyLmxlbmd0aCAtIDFdLCBwb2x5Z29uID0gW107XG4gICAgICBmb3IgKGkgPSB1cHBlci5sZW5ndGggLSAxOyBpID49IDA7IC0taSkgcG9seWdvbi5wdXNoKGRhdGFbcG9pbnRzW3VwcGVyW2ldXVsyXV0pO1xuICAgICAgZm9yIChpID0gK3NraXBMZWZ0OyBpIDwgbG93ZXIubGVuZ3RoIC0gc2tpcFJpZ2h0OyArK2kpIHBvbHlnb24ucHVzaChkYXRhW3BvaW50c1tsb3dlcltpXV1bMl1dKTtcbiAgICAgIHJldHVybiBwb2x5Z29uO1xuICAgIH1cbiAgICBodWxsLnggPSBmdW5jdGlvbihfKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh4ID0gXywgaHVsbCkgOiB4O1xuICAgIH07XG4gICAgaHVsbC55ID0gZnVuY3Rpb24oXykge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeSA9IF8sIGh1bGwpIDogeTtcbiAgICB9O1xuICAgIHJldHVybiBodWxsO1xuICB9O1xuICBmdW5jdGlvbiBkM19nZW9tX2h1bGxVcHBlcihwb2ludHMpIHtcbiAgICB2YXIgbiA9IHBvaW50cy5sZW5ndGgsIGh1bGwgPSBbIDAsIDEgXSwgaHMgPSAyO1xuICAgIGZvciAodmFyIGkgPSAyOyBpIDwgbjsgaSsrKSB7XG4gICAgICB3aGlsZSAoaHMgPiAxICYmIGQzX2Nyb3NzMmQocG9pbnRzW2h1bGxbaHMgLSAyXV0sIHBvaW50c1todWxsW2hzIC0gMV1dLCBwb2ludHNbaV0pIDw9IDApIC0taHM7XG4gICAgICBodWxsW2hzKytdID0gaTtcbiAgICB9XG4gICAgcmV0dXJuIGh1bGwuc2xpY2UoMCwgaHMpO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb21faHVsbE9yZGVyKGEsIGIpIHtcbiAgICByZXR1cm4gYVswXSAtIGJbMF0gfHwgYVsxXSAtIGJbMV07XG4gIH1cbiAgZDMuZ2VvbS5wb2x5Z29uID0gZnVuY3Rpb24oY29vcmRpbmF0ZXMpIHtcbiAgICBkM19zdWJjbGFzcyhjb29yZGluYXRlcywgZDNfZ2VvbV9wb2x5Z29uUHJvdG90eXBlKTtcbiAgICByZXR1cm4gY29vcmRpbmF0ZXM7XG4gIH07XG4gIHZhciBkM19nZW9tX3BvbHlnb25Qcm90b3R5cGUgPSBkMy5nZW9tLnBvbHlnb24ucHJvdG90eXBlID0gW107XG4gIGQzX2dlb21fcG9seWdvblByb3RvdHlwZS5hcmVhID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGkgPSAtMSwgbiA9IHRoaXMubGVuZ3RoLCBhLCBiID0gdGhpc1tuIC0gMV0sIGFyZWEgPSAwO1xuICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICBhID0gYjtcbiAgICAgIGIgPSB0aGlzW2ldO1xuICAgICAgYXJlYSArPSBhWzFdICogYlswXSAtIGFbMF0gKiBiWzFdO1xuICAgIH1cbiAgICByZXR1cm4gYXJlYSAqIC41O1xuICB9O1xuICBkM19nZW9tX3BvbHlnb25Qcm90b3R5cGUuY2VudHJvaWQgPSBmdW5jdGlvbihrKSB7XG4gICAgdmFyIGkgPSAtMSwgbiA9IHRoaXMubGVuZ3RoLCB4ID0gMCwgeSA9IDAsIGEsIGIgPSB0aGlzW24gLSAxXSwgYztcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIGsgPSAtMSAvICg2ICogdGhpcy5hcmVhKCkpO1xuICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICBhID0gYjtcbiAgICAgIGIgPSB0aGlzW2ldO1xuICAgICAgYyA9IGFbMF0gKiBiWzFdIC0gYlswXSAqIGFbMV07XG4gICAgICB4ICs9IChhWzBdICsgYlswXSkgKiBjO1xuICAgICAgeSArPSAoYVsxXSArIGJbMV0pICogYztcbiAgICB9XG4gICAgcmV0dXJuIFsgeCAqIGssIHkgKiBrIF07XG4gIH07XG4gIGQzX2dlb21fcG9seWdvblByb3RvdHlwZS5jbGlwID0gZnVuY3Rpb24oc3ViamVjdCkge1xuICAgIHZhciBpbnB1dCwgY2xvc2VkID0gZDNfZ2VvbV9wb2x5Z29uQ2xvc2VkKHN1YmplY3QpLCBpID0gLTEsIG4gPSB0aGlzLmxlbmd0aCAtIGQzX2dlb21fcG9seWdvbkNsb3NlZCh0aGlzKSwgaiwgbSwgYSA9IHRoaXNbbiAtIDFdLCBiLCBjLCBkO1xuICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICBpbnB1dCA9IHN1YmplY3Quc2xpY2UoKTtcbiAgICAgIHN1YmplY3QubGVuZ3RoID0gMDtcbiAgICAgIGIgPSB0aGlzW2ldO1xuICAgICAgYyA9IGlucHV0WyhtID0gaW5wdXQubGVuZ3RoIC0gY2xvc2VkKSAtIDFdO1xuICAgICAgaiA9IC0xO1xuICAgICAgd2hpbGUgKCsraiA8IG0pIHtcbiAgICAgICAgZCA9IGlucHV0W2pdO1xuICAgICAgICBpZiAoZDNfZ2VvbV9wb2x5Z29uSW5zaWRlKGQsIGEsIGIpKSB7XG4gICAgICAgICAgaWYgKCFkM19nZW9tX3BvbHlnb25JbnNpZGUoYywgYSwgYikpIHtcbiAgICAgICAgICAgIHN1YmplY3QucHVzaChkM19nZW9tX3BvbHlnb25JbnRlcnNlY3QoYywgZCwgYSwgYikpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzdWJqZWN0LnB1c2goZCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZDNfZ2VvbV9wb2x5Z29uSW5zaWRlKGMsIGEsIGIpKSB7XG4gICAgICAgICAgc3ViamVjdC5wdXNoKGQzX2dlb21fcG9seWdvbkludGVyc2VjdChjLCBkLCBhLCBiKSk7XG4gICAgICAgIH1cbiAgICAgICAgYyA9IGQ7XG4gICAgICB9XG4gICAgICBpZiAoY2xvc2VkKSBzdWJqZWN0LnB1c2goc3ViamVjdFswXSk7XG4gICAgICBhID0gYjtcbiAgICB9XG4gICAgcmV0dXJuIHN1YmplY3Q7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX2dlb21fcG9seWdvbkluc2lkZShwLCBhLCBiKSB7XG4gICAgcmV0dXJuIChiWzBdIC0gYVswXSkgKiAocFsxXSAtIGFbMV0pIDwgKGJbMV0gLSBhWzFdKSAqIChwWzBdIC0gYVswXSk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvbV9wb2x5Z29uSW50ZXJzZWN0KGMsIGQsIGEsIGIpIHtcbiAgICB2YXIgeDEgPSBjWzBdLCB4MyA9IGFbMF0sIHgyMSA9IGRbMF0gLSB4MSwgeDQzID0gYlswXSAtIHgzLCB5MSA9IGNbMV0sIHkzID0gYVsxXSwgeTIxID0gZFsxXSAtIHkxLCB5NDMgPSBiWzFdIC0geTMsIHVhID0gKHg0MyAqICh5MSAtIHkzKSAtIHk0MyAqICh4MSAtIHgzKSkgLyAoeTQzICogeDIxIC0geDQzICogeTIxKTtcbiAgICByZXR1cm4gWyB4MSArIHVhICogeDIxLCB5MSArIHVhICogeTIxIF07XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvbV9wb2x5Z29uQ2xvc2VkKGNvb3JkaW5hdGVzKSB7XG4gICAgdmFyIGEgPSBjb29yZGluYXRlc1swXSwgYiA9IGNvb3JkaW5hdGVzW2Nvb3JkaW5hdGVzLmxlbmd0aCAtIDFdO1xuICAgIHJldHVybiAhKGFbMF0gLSBiWzBdIHx8IGFbMV0gLSBiWzFdKTtcbiAgfVxuICB2YXIgZDNfZ2VvbV92b3Jvbm9pRWRnZXMsIGQzX2dlb21fdm9yb25vaUNlbGxzLCBkM19nZW9tX3Zvcm9ub2lCZWFjaGVzLCBkM19nZW9tX3Zvcm9ub2lCZWFjaFBvb2wgPSBbXSwgZDNfZ2VvbV92b3Jvbm9pRmlyc3RDaXJjbGUsIGQzX2dlb21fdm9yb25vaUNpcmNsZXMsIGQzX2dlb21fdm9yb25vaUNpcmNsZVBvb2wgPSBbXTtcbiAgZnVuY3Rpb24gZDNfZ2VvbV92b3Jvbm9pQmVhY2goKSB7XG4gICAgZDNfZ2VvbV92b3Jvbm9pUmVkQmxhY2tOb2RlKHRoaXMpO1xuICAgIHRoaXMuZWRnZSA9IHRoaXMuc2l0ZSA9IHRoaXMuY2lyY2xlID0gbnVsbDtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9tX3Zvcm9ub2lDcmVhdGVCZWFjaChzaXRlKSB7XG4gICAgdmFyIGJlYWNoID0gZDNfZ2VvbV92b3Jvbm9pQmVhY2hQb29sLnBvcCgpIHx8IG5ldyBkM19nZW9tX3Zvcm9ub2lCZWFjaCgpO1xuICAgIGJlYWNoLnNpdGUgPSBzaXRlO1xuICAgIHJldHVybiBiZWFjaDtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9tX3Zvcm9ub2lEZXRhY2hCZWFjaChiZWFjaCkge1xuICAgIGQzX2dlb21fdm9yb25vaURldGFjaENpcmNsZShiZWFjaCk7XG4gICAgZDNfZ2VvbV92b3Jvbm9pQmVhY2hlcy5yZW1vdmUoYmVhY2gpO1xuICAgIGQzX2dlb21fdm9yb25vaUJlYWNoUG9vbC5wdXNoKGJlYWNoKTtcbiAgICBkM19nZW9tX3Zvcm9ub2lSZWRCbGFja05vZGUoYmVhY2gpO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb21fdm9yb25vaVJlbW92ZUJlYWNoKGJlYWNoKSB7XG4gICAgdmFyIGNpcmNsZSA9IGJlYWNoLmNpcmNsZSwgeCA9IGNpcmNsZS54LCB5ID0gY2lyY2xlLmN5LCB2ZXJ0ZXggPSB7XG4gICAgICB4OiB4LFxuICAgICAgeTogeVxuICAgIH0sIHByZXZpb3VzID0gYmVhY2guUCwgbmV4dCA9IGJlYWNoLk4sIGRpc2FwcGVhcmluZyA9IFsgYmVhY2ggXTtcbiAgICBkM19nZW9tX3Zvcm9ub2lEZXRhY2hCZWFjaChiZWFjaCk7XG4gICAgdmFyIGxBcmMgPSBwcmV2aW91cztcbiAgICB3aGlsZSAobEFyYy5jaXJjbGUgJiYgYWJzKHggLSBsQXJjLmNpcmNsZS54KSA8IM61ICYmIGFicyh5IC0gbEFyYy5jaXJjbGUuY3kpIDwgzrUpIHtcbiAgICAgIHByZXZpb3VzID0gbEFyYy5QO1xuICAgICAgZGlzYXBwZWFyaW5nLnVuc2hpZnQobEFyYyk7XG4gICAgICBkM19nZW9tX3Zvcm9ub2lEZXRhY2hCZWFjaChsQXJjKTtcbiAgICAgIGxBcmMgPSBwcmV2aW91cztcbiAgICB9XG4gICAgZGlzYXBwZWFyaW5nLnVuc2hpZnQobEFyYyk7XG4gICAgZDNfZ2VvbV92b3Jvbm9pRGV0YWNoQ2lyY2xlKGxBcmMpO1xuICAgIHZhciByQXJjID0gbmV4dDtcbiAgICB3aGlsZSAockFyYy5jaXJjbGUgJiYgYWJzKHggLSByQXJjLmNpcmNsZS54KSA8IM61ICYmIGFicyh5IC0gckFyYy5jaXJjbGUuY3kpIDwgzrUpIHtcbiAgICAgIG5leHQgPSByQXJjLk47XG4gICAgICBkaXNhcHBlYXJpbmcucHVzaChyQXJjKTtcbiAgICAgIGQzX2dlb21fdm9yb25vaURldGFjaEJlYWNoKHJBcmMpO1xuICAgICAgckFyYyA9IG5leHQ7XG4gICAgfVxuICAgIGRpc2FwcGVhcmluZy5wdXNoKHJBcmMpO1xuICAgIGQzX2dlb21fdm9yb25vaURldGFjaENpcmNsZShyQXJjKTtcbiAgICB2YXIgbkFyY3MgPSBkaXNhcHBlYXJpbmcubGVuZ3RoLCBpQXJjO1xuICAgIGZvciAoaUFyYyA9IDE7IGlBcmMgPCBuQXJjczsgKytpQXJjKSB7XG4gICAgICByQXJjID0gZGlzYXBwZWFyaW5nW2lBcmNdO1xuICAgICAgbEFyYyA9IGRpc2FwcGVhcmluZ1tpQXJjIC0gMV07XG4gICAgICBkM19nZW9tX3Zvcm9ub2lTZXRFZGdlRW5kKHJBcmMuZWRnZSwgbEFyYy5zaXRlLCByQXJjLnNpdGUsIHZlcnRleCk7XG4gICAgfVxuICAgIGxBcmMgPSBkaXNhcHBlYXJpbmdbMF07XG4gICAgckFyYyA9IGRpc2FwcGVhcmluZ1tuQXJjcyAtIDFdO1xuICAgIHJBcmMuZWRnZSA9IGQzX2dlb21fdm9yb25vaUNyZWF0ZUVkZ2UobEFyYy5zaXRlLCByQXJjLnNpdGUsIG51bGwsIHZlcnRleCk7XG4gICAgZDNfZ2VvbV92b3Jvbm9pQXR0YWNoQ2lyY2xlKGxBcmMpO1xuICAgIGQzX2dlb21fdm9yb25vaUF0dGFjaENpcmNsZShyQXJjKTtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9tX3Zvcm9ub2lBZGRCZWFjaChzaXRlKSB7XG4gICAgdmFyIHggPSBzaXRlLngsIGRpcmVjdHJpeCA9IHNpdGUueSwgbEFyYywgckFyYywgZHhsLCBkeHIsIG5vZGUgPSBkM19nZW9tX3Zvcm9ub2lCZWFjaGVzLl87XG4gICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgIGR4bCA9IGQzX2dlb21fdm9yb25vaUxlZnRCcmVha1BvaW50KG5vZGUsIGRpcmVjdHJpeCkgLSB4O1xuICAgICAgaWYgKGR4bCA+IM61KSBub2RlID0gbm9kZS5MOyBlbHNlIHtcbiAgICAgICAgZHhyID0geCAtIGQzX2dlb21fdm9yb25vaVJpZ2h0QnJlYWtQb2ludChub2RlLCBkaXJlY3RyaXgpO1xuICAgICAgICBpZiAoZHhyID4gzrUpIHtcbiAgICAgICAgICBpZiAoIW5vZGUuUikge1xuICAgICAgICAgICAgbEFyYyA9IG5vZGU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgbm9kZSA9IG5vZGUuUjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoZHhsID4gLc61KSB7XG4gICAgICAgICAgICBsQXJjID0gbm9kZS5QO1xuICAgICAgICAgICAgckFyYyA9IG5vZGU7XG4gICAgICAgICAgfSBlbHNlIGlmIChkeHIgPiAtzrUpIHtcbiAgICAgICAgICAgIGxBcmMgPSBub2RlO1xuICAgICAgICAgICAgckFyYyA9IG5vZGUuTjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbEFyYyA9IHJBcmMgPSBub2RlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB2YXIgbmV3QXJjID0gZDNfZ2VvbV92b3Jvbm9pQ3JlYXRlQmVhY2goc2l0ZSk7XG4gICAgZDNfZ2VvbV92b3Jvbm9pQmVhY2hlcy5pbnNlcnQobEFyYywgbmV3QXJjKTtcbiAgICBpZiAoIWxBcmMgJiYgIXJBcmMpIHJldHVybjtcbiAgICBpZiAobEFyYyA9PT0gckFyYykge1xuICAgICAgZDNfZ2VvbV92b3Jvbm9pRGV0YWNoQ2lyY2xlKGxBcmMpO1xuICAgICAgckFyYyA9IGQzX2dlb21fdm9yb25vaUNyZWF0ZUJlYWNoKGxBcmMuc2l0ZSk7XG4gICAgICBkM19nZW9tX3Zvcm9ub2lCZWFjaGVzLmluc2VydChuZXdBcmMsIHJBcmMpO1xuICAgICAgbmV3QXJjLmVkZ2UgPSByQXJjLmVkZ2UgPSBkM19nZW9tX3Zvcm9ub2lDcmVhdGVFZGdlKGxBcmMuc2l0ZSwgbmV3QXJjLnNpdGUpO1xuICAgICAgZDNfZ2VvbV92b3Jvbm9pQXR0YWNoQ2lyY2xlKGxBcmMpO1xuICAgICAgZDNfZ2VvbV92b3Jvbm9pQXR0YWNoQ2lyY2xlKHJBcmMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXJBcmMpIHtcbiAgICAgIG5ld0FyYy5lZGdlID0gZDNfZ2VvbV92b3Jvbm9pQ3JlYXRlRWRnZShsQXJjLnNpdGUsIG5ld0FyYy5zaXRlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZDNfZ2VvbV92b3Jvbm9pRGV0YWNoQ2lyY2xlKGxBcmMpO1xuICAgIGQzX2dlb21fdm9yb25vaURldGFjaENpcmNsZShyQXJjKTtcbiAgICB2YXIgbFNpdGUgPSBsQXJjLnNpdGUsIGF4ID0gbFNpdGUueCwgYXkgPSBsU2l0ZS55LCBieCA9IHNpdGUueCAtIGF4LCBieSA9IHNpdGUueSAtIGF5LCByU2l0ZSA9IHJBcmMuc2l0ZSwgY3ggPSByU2l0ZS54IC0gYXgsIGN5ID0gclNpdGUueSAtIGF5LCBkID0gMiAqIChieCAqIGN5IC0gYnkgKiBjeCksIGhiID0gYnggKiBieCArIGJ5ICogYnksIGhjID0gY3ggKiBjeCArIGN5ICogY3ksIHZlcnRleCA9IHtcbiAgICAgIHg6IChjeSAqIGhiIC0gYnkgKiBoYykgLyBkICsgYXgsXG4gICAgICB5OiAoYnggKiBoYyAtIGN4ICogaGIpIC8gZCArIGF5XG4gICAgfTtcbiAgICBkM19nZW9tX3Zvcm9ub2lTZXRFZGdlRW5kKHJBcmMuZWRnZSwgbFNpdGUsIHJTaXRlLCB2ZXJ0ZXgpO1xuICAgIG5ld0FyYy5lZGdlID0gZDNfZ2VvbV92b3Jvbm9pQ3JlYXRlRWRnZShsU2l0ZSwgc2l0ZSwgbnVsbCwgdmVydGV4KTtcbiAgICByQXJjLmVkZ2UgPSBkM19nZW9tX3Zvcm9ub2lDcmVhdGVFZGdlKHNpdGUsIHJTaXRlLCBudWxsLCB2ZXJ0ZXgpO1xuICAgIGQzX2dlb21fdm9yb25vaUF0dGFjaENpcmNsZShsQXJjKTtcbiAgICBkM19nZW9tX3Zvcm9ub2lBdHRhY2hDaXJjbGUockFyYyk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvbV92b3Jvbm9pTGVmdEJyZWFrUG9pbnQoYXJjLCBkaXJlY3RyaXgpIHtcbiAgICB2YXIgc2l0ZSA9IGFyYy5zaXRlLCByZm9jeCA9IHNpdGUueCwgcmZvY3kgPSBzaXRlLnksIHBieTIgPSByZm9jeSAtIGRpcmVjdHJpeDtcbiAgICBpZiAoIXBieTIpIHJldHVybiByZm9jeDtcbiAgICB2YXIgbEFyYyA9IGFyYy5QO1xuICAgIGlmICghbEFyYykgcmV0dXJuIC1JbmZpbml0eTtcbiAgICBzaXRlID0gbEFyYy5zaXRlO1xuICAgIHZhciBsZm9jeCA9IHNpdGUueCwgbGZvY3kgPSBzaXRlLnksIHBsYnkyID0gbGZvY3kgLSBkaXJlY3RyaXg7XG4gICAgaWYgKCFwbGJ5MikgcmV0dXJuIGxmb2N4O1xuICAgIHZhciBobCA9IGxmb2N4IC0gcmZvY3gsIGFieTIgPSAxIC8gcGJ5MiAtIDEgLyBwbGJ5MiwgYiA9IGhsIC8gcGxieTI7XG4gICAgaWYgKGFieTIpIHJldHVybiAoLWIgKyBNYXRoLnNxcnQoYiAqIGIgLSAyICogYWJ5MiAqIChobCAqIGhsIC8gKC0yICogcGxieTIpIC0gbGZvY3kgKyBwbGJ5MiAvIDIgKyByZm9jeSAtIHBieTIgLyAyKSkpIC8gYWJ5MiArIHJmb2N4O1xuICAgIHJldHVybiAocmZvY3ggKyBsZm9jeCkgLyAyO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb21fdm9yb25vaVJpZ2h0QnJlYWtQb2ludChhcmMsIGRpcmVjdHJpeCkge1xuICAgIHZhciByQXJjID0gYXJjLk47XG4gICAgaWYgKHJBcmMpIHJldHVybiBkM19nZW9tX3Zvcm9ub2lMZWZ0QnJlYWtQb2ludChyQXJjLCBkaXJlY3RyaXgpO1xuICAgIHZhciBzaXRlID0gYXJjLnNpdGU7XG4gICAgcmV0dXJuIHNpdGUueSA9PT0gZGlyZWN0cml4ID8gc2l0ZS54IDogSW5maW5pdHk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvbV92b3Jvbm9pQ2VsbChzaXRlKSB7XG4gICAgdGhpcy5zaXRlID0gc2l0ZTtcbiAgICB0aGlzLmVkZ2VzID0gW107XG4gIH1cbiAgZDNfZ2VvbV92b3Jvbm9pQ2VsbC5wcm90b3R5cGUucHJlcGFyZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBoYWxmRWRnZXMgPSB0aGlzLmVkZ2VzLCBpSGFsZkVkZ2UgPSBoYWxmRWRnZXMubGVuZ3RoLCBlZGdlO1xuICAgIHdoaWxlIChpSGFsZkVkZ2UtLSkge1xuICAgICAgZWRnZSA9IGhhbGZFZGdlc1tpSGFsZkVkZ2VdLmVkZ2U7XG4gICAgICBpZiAoIWVkZ2UuYiB8fCAhZWRnZS5hKSBoYWxmRWRnZXMuc3BsaWNlKGlIYWxmRWRnZSwgMSk7XG4gICAgfVxuICAgIGhhbGZFZGdlcy5zb3J0KGQzX2dlb21fdm9yb25vaUhhbGZFZGdlT3JkZXIpO1xuICAgIHJldHVybiBoYWxmRWRnZXMubGVuZ3RoO1xuICB9O1xuICBmdW5jdGlvbiBkM19nZW9tX3Zvcm9ub2lDbG9zZUNlbGxzKGV4dGVudCkge1xuICAgIHZhciB4MCA9IGV4dGVudFswXVswXSwgeDEgPSBleHRlbnRbMV1bMF0sIHkwID0gZXh0ZW50WzBdWzFdLCB5MSA9IGV4dGVudFsxXVsxXSwgeDIsIHkyLCB4MywgeTMsIGNlbGxzID0gZDNfZ2VvbV92b3Jvbm9pQ2VsbHMsIGlDZWxsID0gY2VsbHMubGVuZ3RoLCBjZWxsLCBpSGFsZkVkZ2UsIGhhbGZFZGdlcywgbkhhbGZFZGdlcywgc3RhcnQsIGVuZDtcbiAgICB3aGlsZSAoaUNlbGwtLSkge1xuICAgICAgY2VsbCA9IGNlbGxzW2lDZWxsXTtcbiAgICAgIGlmICghY2VsbCB8fCAhY2VsbC5wcmVwYXJlKCkpIGNvbnRpbnVlO1xuICAgICAgaGFsZkVkZ2VzID0gY2VsbC5lZGdlcztcbiAgICAgIG5IYWxmRWRnZXMgPSBoYWxmRWRnZXMubGVuZ3RoO1xuICAgICAgaUhhbGZFZGdlID0gMDtcbiAgICAgIHdoaWxlIChpSGFsZkVkZ2UgPCBuSGFsZkVkZ2VzKSB7XG4gICAgICAgIGVuZCA9IGhhbGZFZGdlc1tpSGFsZkVkZ2VdLmVuZCgpLCB4MyA9IGVuZC54LCB5MyA9IGVuZC55O1xuICAgICAgICBzdGFydCA9IGhhbGZFZGdlc1srK2lIYWxmRWRnZSAlIG5IYWxmRWRnZXNdLnN0YXJ0KCksIHgyID0gc3RhcnQueCwgeTIgPSBzdGFydC55O1xuICAgICAgICBpZiAoYWJzKHgzIC0geDIpID4gzrUgfHwgYWJzKHkzIC0geTIpID4gzrUpIHtcbiAgICAgICAgICBoYWxmRWRnZXMuc3BsaWNlKGlIYWxmRWRnZSwgMCwgbmV3IGQzX2dlb21fdm9yb25vaUhhbGZFZGdlKGQzX2dlb21fdm9yb25vaUNyZWF0ZUJvcmRlckVkZ2UoY2VsbC5zaXRlLCBlbmQsIGFicyh4MyAtIHgwKSA8IM61ICYmIHkxIC0geTMgPiDOtSA/IHtcbiAgICAgICAgICAgIHg6IHgwLFxuICAgICAgICAgICAgeTogYWJzKHgyIC0geDApIDwgzrUgPyB5MiA6IHkxXG4gICAgICAgICAgfSA6IGFicyh5MyAtIHkxKSA8IM61ICYmIHgxIC0geDMgPiDOtSA/IHtcbiAgICAgICAgICAgIHg6IGFicyh5MiAtIHkxKSA8IM61ID8geDIgOiB4MSxcbiAgICAgICAgICAgIHk6IHkxXG4gICAgICAgICAgfSA6IGFicyh4MyAtIHgxKSA8IM61ICYmIHkzIC0geTAgPiDOtSA/IHtcbiAgICAgICAgICAgIHg6IHgxLFxuICAgICAgICAgICAgeTogYWJzKHgyIC0geDEpIDwgzrUgPyB5MiA6IHkwXG4gICAgICAgICAgfSA6IGFicyh5MyAtIHkwKSA8IM61ICYmIHgzIC0geDAgPiDOtSA/IHtcbiAgICAgICAgICAgIHg6IGFicyh5MiAtIHkwKSA8IM61ID8geDIgOiB4MCxcbiAgICAgICAgICAgIHk6IHkwXG4gICAgICAgICAgfSA6IG51bGwpLCBjZWxsLnNpdGUsIG51bGwpKTtcbiAgICAgICAgICArK25IYWxmRWRnZXM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvbV92b3Jvbm9pSGFsZkVkZ2VPcmRlcihhLCBiKSB7XG4gICAgcmV0dXJuIGIuYW5nbGUgLSBhLmFuZ2xlO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb21fdm9yb25vaUNpcmNsZSgpIHtcbiAgICBkM19nZW9tX3Zvcm9ub2lSZWRCbGFja05vZGUodGhpcyk7XG4gICAgdGhpcy54ID0gdGhpcy55ID0gdGhpcy5hcmMgPSB0aGlzLnNpdGUgPSB0aGlzLmN5ID0gbnVsbDtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9tX3Zvcm9ub2lBdHRhY2hDaXJjbGUoYXJjKSB7XG4gICAgdmFyIGxBcmMgPSBhcmMuUCwgckFyYyA9IGFyYy5OO1xuICAgIGlmICghbEFyYyB8fCAhckFyYykgcmV0dXJuO1xuICAgIHZhciBsU2l0ZSA9IGxBcmMuc2l0ZSwgY1NpdGUgPSBhcmMuc2l0ZSwgclNpdGUgPSByQXJjLnNpdGU7XG4gICAgaWYgKGxTaXRlID09PSByU2l0ZSkgcmV0dXJuO1xuICAgIHZhciBieCA9IGNTaXRlLngsIGJ5ID0gY1NpdGUueSwgYXggPSBsU2l0ZS54IC0gYngsIGF5ID0gbFNpdGUueSAtIGJ5LCBjeCA9IHJTaXRlLnggLSBieCwgY3kgPSByU2l0ZS55IC0gYnk7XG4gICAgdmFyIGQgPSAyICogKGF4ICogY3kgLSBheSAqIGN4KTtcbiAgICBpZiAoZCA+PSAtzrUyKSByZXR1cm47XG4gICAgdmFyIGhhID0gYXggKiBheCArIGF5ICogYXksIGhjID0gY3ggKiBjeCArIGN5ICogY3ksIHggPSAoY3kgKiBoYSAtIGF5ICogaGMpIC8gZCwgeSA9IChheCAqIGhjIC0gY3ggKiBoYSkgLyBkLCBjeSA9IHkgKyBieTtcbiAgICB2YXIgY2lyY2xlID0gZDNfZ2VvbV92b3Jvbm9pQ2lyY2xlUG9vbC5wb3AoKSB8fCBuZXcgZDNfZ2VvbV92b3Jvbm9pQ2lyY2xlKCk7XG4gICAgY2lyY2xlLmFyYyA9IGFyYztcbiAgICBjaXJjbGUuc2l0ZSA9IGNTaXRlO1xuICAgIGNpcmNsZS54ID0geCArIGJ4O1xuICAgIGNpcmNsZS55ID0gY3kgKyBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSk7XG4gICAgY2lyY2xlLmN5ID0gY3k7XG4gICAgYXJjLmNpcmNsZSA9IGNpcmNsZTtcbiAgICB2YXIgYmVmb3JlID0gbnVsbCwgbm9kZSA9IGQzX2dlb21fdm9yb25vaUNpcmNsZXMuXztcbiAgICB3aGlsZSAobm9kZSkge1xuICAgICAgaWYgKGNpcmNsZS55IDwgbm9kZS55IHx8IGNpcmNsZS55ID09PSBub2RlLnkgJiYgY2lyY2xlLnggPD0gbm9kZS54KSB7XG4gICAgICAgIGlmIChub2RlLkwpIG5vZGUgPSBub2RlLkw7IGVsc2Uge1xuICAgICAgICAgIGJlZm9yZSA9IG5vZGUuUDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKG5vZGUuUikgbm9kZSA9IG5vZGUuUjsgZWxzZSB7XG4gICAgICAgICAgYmVmb3JlID0gbm9kZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBkM19nZW9tX3Zvcm9ub2lDaXJjbGVzLmluc2VydChiZWZvcmUsIGNpcmNsZSk7XG4gICAgaWYgKCFiZWZvcmUpIGQzX2dlb21fdm9yb25vaUZpcnN0Q2lyY2xlID0gY2lyY2xlO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb21fdm9yb25vaURldGFjaENpcmNsZShhcmMpIHtcbiAgICB2YXIgY2lyY2xlID0gYXJjLmNpcmNsZTtcbiAgICBpZiAoY2lyY2xlKSB7XG4gICAgICBpZiAoIWNpcmNsZS5QKSBkM19nZW9tX3Zvcm9ub2lGaXJzdENpcmNsZSA9IGNpcmNsZS5OO1xuICAgICAgZDNfZ2VvbV92b3Jvbm9pQ2lyY2xlcy5yZW1vdmUoY2lyY2xlKTtcbiAgICAgIGQzX2dlb21fdm9yb25vaUNpcmNsZVBvb2wucHVzaChjaXJjbGUpO1xuICAgICAgZDNfZ2VvbV92b3Jvbm9pUmVkQmxhY2tOb2RlKGNpcmNsZSk7XG4gICAgICBhcmMuY2lyY2xlID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvbV92b3Jvbm9pQ2xpcEVkZ2VzKGV4dGVudCkge1xuICAgIHZhciBlZGdlcyA9IGQzX2dlb21fdm9yb25vaUVkZ2VzLCBjbGlwID0gZDNfZ2VvbV9jbGlwTGluZShleHRlbnRbMF1bMF0sIGV4dGVudFswXVsxXSwgZXh0ZW50WzFdWzBdLCBleHRlbnRbMV1bMV0pLCBpID0gZWRnZXMubGVuZ3RoLCBlO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGUgPSBlZGdlc1tpXTtcbiAgICAgIGlmICghZDNfZ2VvbV92b3Jvbm9pQ29ubmVjdEVkZ2UoZSwgZXh0ZW50KSB8fCAhY2xpcChlKSB8fCBhYnMoZS5hLnggLSBlLmIueCkgPCDOtSAmJiBhYnMoZS5hLnkgLSBlLmIueSkgPCDOtSkge1xuICAgICAgICBlLmEgPSBlLmIgPSBudWxsO1xuICAgICAgICBlZGdlcy5zcGxpY2UoaSwgMSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb21fdm9yb25vaUNvbm5lY3RFZGdlKGVkZ2UsIGV4dGVudCkge1xuICAgIHZhciB2YiA9IGVkZ2UuYjtcbiAgICBpZiAodmIpIHJldHVybiB0cnVlO1xuICAgIHZhciB2YSA9IGVkZ2UuYSwgeDAgPSBleHRlbnRbMF1bMF0sIHgxID0gZXh0ZW50WzFdWzBdLCB5MCA9IGV4dGVudFswXVsxXSwgeTEgPSBleHRlbnRbMV1bMV0sIGxTaXRlID0gZWRnZS5sLCByU2l0ZSA9IGVkZ2UuciwgbHggPSBsU2l0ZS54LCBseSA9IGxTaXRlLnksIHJ4ID0gclNpdGUueCwgcnkgPSByU2l0ZS55LCBmeCA9IChseCArIHJ4KSAvIDIsIGZ5ID0gKGx5ICsgcnkpIC8gMiwgZm0sIGZiO1xuICAgIGlmIChyeSA9PT0gbHkpIHtcbiAgICAgIGlmIChmeCA8IHgwIHx8IGZ4ID49IHgxKSByZXR1cm47XG4gICAgICBpZiAobHggPiByeCkge1xuICAgICAgICBpZiAoIXZhKSB2YSA9IHtcbiAgICAgICAgICB4OiBmeCxcbiAgICAgICAgICB5OiB5MFxuICAgICAgICB9OyBlbHNlIGlmICh2YS55ID49IHkxKSByZXR1cm47XG4gICAgICAgIHZiID0ge1xuICAgICAgICAgIHg6IGZ4LFxuICAgICAgICAgIHk6IHkxXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIXZhKSB2YSA9IHtcbiAgICAgICAgICB4OiBmeCxcbiAgICAgICAgICB5OiB5MVxuICAgICAgICB9OyBlbHNlIGlmICh2YS55IDwgeTApIHJldHVybjtcbiAgICAgICAgdmIgPSB7XG4gICAgICAgICAgeDogZngsXG4gICAgICAgICAgeTogeTBcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm0gPSAobHggLSByeCkgLyAocnkgLSBseSk7XG4gICAgICBmYiA9IGZ5IC0gZm0gKiBmeDtcbiAgICAgIGlmIChmbSA8IC0xIHx8IGZtID4gMSkge1xuICAgICAgICBpZiAobHggPiByeCkge1xuICAgICAgICAgIGlmICghdmEpIHZhID0ge1xuICAgICAgICAgICAgeDogKHkwIC0gZmIpIC8gZm0sXG4gICAgICAgICAgICB5OiB5MFxuICAgICAgICAgIH07IGVsc2UgaWYgKHZhLnkgPj0geTEpIHJldHVybjtcbiAgICAgICAgICB2YiA9IHtcbiAgICAgICAgICAgIHg6ICh5MSAtIGZiKSAvIGZtLFxuICAgICAgICAgICAgeTogeTFcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICghdmEpIHZhID0ge1xuICAgICAgICAgICAgeDogKHkxIC0gZmIpIC8gZm0sXG4gICAgICAgICAgICB5OiB5MVxuICAgICAgICAgIH07IGVsc2UgaWYgKHZhLnkgPCB5MCkgcmV0dXJuO1xuICAgICAgICAgIHZiID0ge1xuICAgICAgICAgICAgeDogKHkwIC0gZmIpIC8gZm0sXG4gICAgICAgICAgICB5OiB5MFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChseSA8IHJ5KSB7XG4gICAgICAgICAgaWYgKCF2YSkgdmEgPSB7XG4gICAgICAgICAgICB4OiB4MCxcbiAgICAgICAgICAgIHk6IGZtICogeDAgKyBmYlxuICAgICAgICAgIH07IGVsc2UgaWYgKHZhLnggPj0geDEpIHJldHVybjtcbiAgICAgICAgICB2YiA9IHtcbiAgICAgICAgICAgIHg6IHgxLFxuICAgICAgICAgICAgeTogZm0gKiB4MSArIGZiXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoIXZhKSB2YSA9IHtcbiAgICAgICAgICAgIHg6IHgxLFxuICAgICAgICAgICAgeTogZm0gKiB4MSArIGZiXG4gICAgICAgICAgfTsgZWxzZSBpZiAodmEueCA8IHgwKSByZXR1cm47XG4gICAgICAgICAgdmIgPSB7XG4gICAgICAgICAgICB4OiB4MCxcbiAgICAgICAgICAgIHk6IGZtICogeDAgKyBmYlxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZWRnZS5hID0gdmE7XG4gICAgZWRnZS5iID0gdmI7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvbV92b3Jvbm9pRWRnZShsU2l0ZSwgclNpdGUpIHtcbiAgICB0aGlzLmwgPSBsU2l0ZTtcbiAgICB0aGlzLnIgPSByU2l0ZTtcbiAgICB0aGlzLmEgPSB0aGlzLmIgPSBudWxsO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb21fdm9yb25vaUNyZWF0ZUVkZ2UobFNpdGUsIHJTaXRlLCB2YSwgdmIpIHtcbiAgICB2YXIgZWRnZSA9IG5ldyBkM19nZW9tX3Zvcm9ub2lFZGdlKGxTaXRlLCByU2l0ZSk7XG4gICAgZDNfZ2VvbV92b3Jvbm9pRWRnZXMucHVzaChlZGdlKTtcbiAgICBpZiAodmEpIGQzX2dlb21fdm9yb25vaVNldEVkZ2VFbmQoZWRnZSwgbFNpdGUsIHJTaXRlLCB2YSk7XG4gICAgaWYgKHZiKSBkM19nZW9tX3Zvcm9ub2lTZXRFZGdlRW5kKGVkZ2UsIHJTaXRlLCBsU2l0ZSwgdmIpO1xuICAgIGQzX2dlb21fdm9yb25vaUNlbGxzW2xTaXRlLmldLmVkZ2VzLnB1c2gobmV3IGQzX2dlb21fdm9yb25vaUhhbGZFZGdlKGVkZ2UsIGxTaXRlLCByU2l0ZSkpO1xuICAgIGQzX2dlb21fdm9yb25vaUNlbGxzW3JTaXRlLmldLmVkZ2VzLnB1c2gobmV3IGQzX2dlb21fdm9yb25vaUhhbGZFZGdlKGVkZ2UsIHJTaXRlLCBsU2l0ZSkpO1xuICAgIHJldHVybiBlZGdlO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb21fdm9yb25vaUNyZWF0ZUJvcmRlckVkZ2UobFNpdGUsIHZhLCB2Yikge1xuICAgIHZhciBlZGdlID0gbmV3IGQzX2dlb21fdm9yb25vaUVkZ2UobFNpdGUsIG51bGwpO1xuICAgIGVkZ2UuYSA9IHZhO1xuICAgIGVkZ2UuYiA9IHZiO1xuICAgIGQzX2dlb21fdm9yb25vaUVkZ2VzLnB1c2goZWRnZSk7XG4gICAgcmV0dXJuIGVkZ2U7XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvbV92b3Jvbm9pU2V0RWRnZUVuZChlZGdlLCBsU2l0ZSwgclNpdGUsIHZlcnRleCkge1xuICAgIGlmICghZWRnZS5hICYmICFlZGdlLmIpIHtcbiAgICAgIGVkZ2UuYSA9IHZlcnRleDtcbiAgICAgIGVkZ2UubCA9IGxTaXRlO1xuICAgICAgZWRnZS5yID0gclNpdGU7XG4gICAgfSBlbHNlIGlmIChlZGdlLmwgPT09IHJTaXRlKSB7XG4gICAgICBlZGdlLmIgPSB2ZXJ0ZXg7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVkZ2UuYSA9IHZlcnRleDtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvbV92b3Jvbm9pSGFsZkVkZ2UoZWRnZSwgbFNpdGUsIHJTaXRlKSB7XG4gICAgdmFyIHZhID0gZWRnZS5hLCB2YiA9IGVkZ2UuYjtcbiAgICB0aGlzLmVkZ2UgPSBlZGdlO1xuICAgIHRoaXMuc2l0ZSA9IGxTaXRlO1xuICAgIHRoaXMuYW5nbGUgPSByU2l0ZSA/IE1hdGguYXRhbjIoclNpdGUueSAtIGxTaXRlLnksIHJTaXRlLnggLSBsU2l0ZS54KSA6IGVkZ2UubCA9PT0gbFNpdGUgPyBNYXRoLmF0YW4yKHZiLnggLSB2YS54LCB2YS55IC0gdmIueSkgOiBNYXRoLmF0YW4yKHZhLnggLSB2Yi54LCB2Yi55IC0gdmEueSk7XG4gIH1cbiAgZDNfZ2VvbV92b3Jvbm9pSGFsZkVkZ2UucHJvdG90eXBlID0ge1xuICAgIHN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmVkZ2UubCA9PT0gdGhpcy5zaXRlID8gdGhpcy5lZGdlLmEgOiB0aGlzLmVkZ2UuYjtcbiAgICB9LFxuICAgIGVuZDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5lZGdlLmwgPT09IHRoaXMuc2l0ZSA/IHRoaXMuZWRnZS5iIDogdGhpcy5lZGdlLmE7XG4gICAgfVxuICB9O1xuICBmdW5jdGlvbiBkM19nZW9tX3Zvcm9ub2lSZWRCbGFja1RyZWUoKSB7XG4gICAgdGhpcy5fID0gbnVsbDtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9tX3Zvcm9ub2lSZWRCbGFja05vZGUobm9kZSkge1xuICAgIG5vZGUuVSA9IG5vZGUuQyA9IG5vZGUuTCA9IG5vZGUuUiA9IG5vZGUuUCA9IG5vZGUuTiA9IG51bGw7XG4gIH1cbiAgZDNfZ2VvbV92b3Jvbm9pUmVkQmxhY2tUcmVlLnByb3RvdHlwZSA9IHtcbiAgICBpbnNlcnQ6IGZ1bmN0aW9uKGFmdGVyLCBub2RlKSB7XG4gICAgICB2YXIgcGFyZW50LCBncmFuZHBhLCB1bmNsZTtcbiAgICAgIGlmIChhZnRlcikge1xuICAgICAgICBub2RlLlAgPSBhZnRlcjtcbiAgICAgICAgbm9kZS5OID0gYWZ0ZXIuTjtcbiAgICAgICAgaWYgKGFmdGVyLk4pIGFmdGVyLk4uUCA9IG5vZGU7XG4gICAgICAgIGFmdGVyLk4gPSBub2RlO1xuICAgICAgICBpZiAoYWZ0ZXIuUikge1xuICAgICAgICAgIGFmdGVyID0gYWZ0ZXIuUjtcbiAgICAgICAgICB3aGlsZSAoYWZ0ZXIuTCkgYWZ0ZXIgPSBhZnRlci5MO1xuICAgICAgICAgIGFmdGVyLkwgPSBub2RlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFmdGVyLlIgPSBub2RlO1xuICAgICAgICB9XG4gICAgICAgIHBhcmVudCA9IGFmdGVyO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLl8pIHtcbiAgICAgICAgYWZ0ZXIgPSBkM19nZW9tX3Zvcm9ub2lSZWRCbGFja0ZpcnN0KHRoaXMuXyk7XG4gICAgICAgIG5vZGUuUCA9IG51bGw7XG4gICAgICAgIG5vZGUuTiA9IGFmdGVyO1xuICAgICAgICBhZnRlci5QID0gYWZ0ZXIuTCA9IG5vZGU7XG4gICAgICAgIHBhcmVudCA9IGFmdGVyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZS5QID0gbm9kZS5OID0gbnVsbDtcbiAgICAgICAgdGhpcy5fID0gbm9kZTtcbiAgICAgICAgcGFyZW50ID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIG5vZGUuTCA9IG5vZGUuUiA9IG51bGw7XG4gICAgICBub2RlLlUgPSBwYXJlbnQ7XG4gICAgICBub2RlLkMgPSB0cnVlO1xuICAgICAgYWZ0ZXIgPSBub2RlO1xuICAgICAgd2hpbGUgKHBhcmVudCAmJiBwYXJlbnQuQykge1xuICAgICAgICBncmFuZHBhID0gcGFyZW50LlU7XG4gICAgICAgIGlmIChwYXJlbnQgPT09IGdyYW5kcGEuTCkge1xuICAgICAgICAgIHVuY2xlID0gZ3JhbmRwYS5SO1xuICAgICAgICAgIGlmICh1bmNsZSAmJiB1bmNsZS5DKSB7XG4gICAgICAgICAgICBwYXJlbnQuQyA9IHVuY2xlLkMgPSBmYWxzZTtcbiAgICAgICAgICAgIGdyYW5kcGEuQyA9IHRydWU7XG4gICAgICAgICAgICBhZnRlciA9IGdyYW5kcGE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChhZnRlciA9PT0gcGFyZW50LlIpIHtcbiAgICAgICAgICAgICAgZDNfZ2VvbV92b3Jvbm9pUmVkQmxhY2tSb3RhdGVMZWZ0KHRoaXMsIHBhcmVudCk7XG4gICAgICAgICAgICAgIGFmdGVyID0gcGFyZW50O1xuICAgICAgICAgICAgICBwYXJlbnQgPSBhZnRlci5VO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFyZW50LkMgPSBmYWxzZTtcbiAgICAgICAgICAgIGdyYW5kcGEuQyA9IHRydWU7XG4gICAgICAgICAgICBkM19nZW9tX3Zvcm9ub2lSZWRCbGFja1JvdGF0ZVJpZ2h0KHRoaXMsIGdyYW5kcGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB1bmNsZSA9IGdyYW5kcGEuTDtcbiAgICAgICAgICBpZiAodW5jbGUgJiYgdW5jbGUuQykge1xuICAgICAgICAgICAgcGFyZW50LkMgPSB1bmNsZS5DID0gZmFsc2U7XG4gICAgICAgICAgICBncmFuZHBhLkMgPSB0cnVlO1xuICAgICAgICAgICAgYWZ0ZXIgPSBncmFuZHBhO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoYWZ0ZXIgPT09IHBhcmVudC5MKSB7XG4gICAgICAgICAgICAgIGQzX2dlb21fdm9yb25vaVJlZEJsYWNrUm90YXRlUmlnaHQodGhpcywgcGFyZW50KTtcbiAgICAgICAgICAgICAgYWZ0ZXIgPSBwYXJlbnQ7XG4gICAgICAgICAgICAgIHBhcmVudCA9IGFmdGVyLlU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJlbnQuQyA9IGZhbHNlO1xuICAgICAgICAgICAgZ3JhbmRwYS5DID0gdHJ1ZTtcbiAgICAgICAgICAgIGQzX2dlb21fdm9yb25vaVJlZEJsYWNrUm90YXRlTGVmdCh0aGlzLCBncmFuZHBhKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcGFyZW50ID0gYWZ0ZXIuVTtcbiAgICAgIH1cbiAgICAgIHRoaXMuXy5DID0gZmFsc2U7XG4gICAgfSxcbiAgICByZW1vdmU6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIGlmIChub2RlLk4pIG5vZGUuTi5QID0gbm9kZS5QO1xuICAgICAgaWYgKG5vZGUuUCkgbm9kZS5QLk4gPSBub2RlLk47XG4gICAgICBub2RlLk4gPSBub2RlLlAgPSBudWxsO1xuICAgICAgdmFyIHBhcmVudCA9IG5vZGUuVSwgc2libGluZywgbGVmdCA9IG5vZGUuTCwgcmlnaHQgPSBub2RlLlIsIG5leHQsIHJlZDtcbiAgICAgIGlmICghbGVmdCkgbmV4dCA9IHJpZ2h0OyBlbHNlIGlmICghcmlnaHQpIG5leHQgPSBsZWZ0OyBlbHNlIG5leHQgPSBkM19nZW9tX3Zvcm9ub2lSZWRCbGFja0ZpcnN0KHJpZ2h0KTtcbiAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgaWYgKHBhcmVudC5MID09PSBub2RlKSBwYXJlbnQuTCA9IG5leHQ7IGVsc2UgcGFyZW50LlIgPSBuZXh0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fID0gbmV4dDtcbiAgICAgIH1cbiAgICAgIGlmIChsZWZ0ICYmIHJpZ2h0KSB7XG4gICAgICAgIHJlZCA9IG5leHQuQztcbiAgICAgICAgbmV4dC5DID0gbm9kZS5DO1xuICAgICAgICBuZXh0LkwgPSBsZWZ0O1xuICAgICAgICBsZWZ0LlUgPSBuZXh0O1xuICAgICAgICBpZiAobmV4dCAhPT0gcmlnaHQpIHtcbiAgICAgICAgICBwYXJlbnQgPSBuZXh0LlU7XG4gICAgICAgICAgbmV4dC5VID0gbm9kZS5VO1xuICAgICAgICAgIG5vZGUgPSBuZXh0LlI7XG4gICAgICAgICAgcGFyZW50LkwgPSBub2RlO1xuICAgICAgICAgIG5leHQuUiA9IHJpZ2h0O1xuICAgICAgICAgIHJpZ2h0LlUgPSBuZXh0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5leHQuVSA9IHBhcmVudDtcbiAgICAgICAgICBwYXJlbnQgPSBuZXh0O1xuICAgICAgICAgIG5vZGUgPSBuZXh0LlI7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlZCA9IG5vZGUuQztcbiAgICAgICAgbm9kZSA9IG5leHQ7XG4gICAgICB9XG4gICAgICBpZiAobm9kZSkgbm9kZS5VID0gcGFyZW50O1xuICAgICAgaWYgKHJlZCkgcmV0dXJuO1xuICAgICAgaWYgKG5vZGUgJiYgbm9kZS5DKSB7XG4gICAgICAgIG5vZGUuQyA9IGZhbHNlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBkbyB7XG4gICAgICAgIGlmIChub2RlID09PSB0aGlzLl8pIGJyZWFrO1xuICAgICAgICBpZiAobm9kZSA9PT0gcGFyZW50LkwpIHtcbiAgICAgICAgICBzaWJsaW5nID0gcGFyZW50LlI7XG4gICAgICAgICAgaWYgKHNpYmxpbmcuQykge1xuICAgICAgICAgICAgc2libGluZy5DID0gZmFsc2U7XG4gICAgICAgICAgICBwYXJlbnQuQyA9IHRydWU7XG4gICAgICAgICAgICBkM19nZW9tX3Zvcm9ub2lSZWRCbGFja1JvdGF0ZUxlZnQodGhpcywgcGFyZW50KTtcbiAgICAgICAgICAgIHNpYmxpbmcgPSBwYXJlbnQuUjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNpYmxpbmcuTCAmJiBzaWJsaW5nLkwuQyB8fCBzaWJsaW5nLlIgJiYgc2libGluZy5SLkMpIHtcbiAgICAgICAgICAgIGlmICghc2libGluZy5SIHx8ICFzaWJsaW5nLlIuQykge1xuICAgICAgICAgICAgICBzaWJsaW5nLkwuQyA9IGZhbHNlO1xuICAgICAgICAgICAgICBzaWJsaW5nLkMgPSB0cnVlO1xuICAgICAgICAgICAgICBkM19nZW9tX3Zvcm9ub2lSZWRCbGFja1JvdGF0ZVJpZ2h0KHRoaXMsIHNpYmxpbmcpO1xuICAgICAgICAgICAgICBzaWJsaW5nID0gcGFyZW50LlI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzaWJsaW5nLkMgPSBwYXJlbnQuQztcbiAgICAgICAgICAgIHBhcmVudC5DID0gc2libGluZy5SLkMgPSBmYWxzZTtcbiAgICAgICAgICAgIGQzX2dlb21fdm9yb25vaVJlZEJsYWNrUm90YXRlTGVmdCh0aGlzLCBwYXJlbnQpO1xuICAgICAgICAgICAgbm9kZSA9IHRoaXMuXztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzaWJsaW5nID0gcGFyZW50Lkw7XG4gICAgICAgICAgaWYgKHNpYmxpbmcuQykge1xuICAgICAgICAgICAgc2libGluZy5DID0gZmFsc2U7XG4gICAgICAgICAgICBwYXJlbnQuQyA9IHRydWU7XG4gICAgICAgICAgICBkM19nZW9tX3Zvcm9ub2lSZWRCbGFja1JvdGF0ZVJpZ2h0KHRoaXMsIHBhcmVudCk7XG4gICAgICAgICAgICBzaWJsaW5nID0gcGFyZW50Lkw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzaWJsaW5nLkwgJiYgc2libGluZy5MLkMgfHwgc2libGluZy5SICYmIHNpYmxpbmcuUi5DKSB7XG4gICAgICAgICAgICBpZiAoIXNpYmxpbmcuTCB8fCAhc2libGluZy5MLkMpIHtcbiAgICAgICAgICAgICAgc2libGluZy5SLkMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgc2libGluZy5DID0gdHJ1ZTtcbiAgICAgICAgICAgICAgZDNfZ2VvbV92b3Jvbm9pUmVkQmxhY2tSb3RhdGVMZWZ0KHRoaXMsIHNpYmxpbmcpO1xuICAgICAgICAgICAgICBzaWJsaW5nID0gcGFyZW50Lkw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzaWJsaW5nLkMgPSBwYXJlbnQuQztcbiAgICAgICAgICAgIHBhcmVudC5DID0gc2libGluZy5MLkMgPSBmYWxzZTtcbiAgICAgICAgICAgIGQzX2dlb21fdm9yb25vaVJlZEJsYWNrUm90YXRlUmlnaHQodGhpcywgcGFyZW50KTtcbiAgICAgICAgICAgIG5vZGUgPSB0aGlzLl87XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc2libGluZy5DID0gdHJ1ZTtcbiAgICAgICAgbm9kZSA9IHBhcmVudDtcbiAgICAgICAgcGFyZW50ID0gcGFyZW50LlU7XG4gICAgICB9IHdoaWxlICghbm9kZS5DKTtcbiAgICAgIGlmIChub2RlKSBub2RlLkMgPSBmYWxzZTtcbiAgICB9XG4gIH07XG4gIGZ1bmN0aW9uIGQzX2dlb21fdm9yb25vaVJlZEJsYWNrUm90YXRlTGVmdCh0cmVlLCBub2RlKSB7XG4gICAgdmFyIHAgPSBub2RlLCBxID0gbm9kZS5SLCBwYXJlbnQgPSBwLlU7XG4gICAgaWYgKHBhcmVudCkge1xuICAgICAgaWYgKHBhcmVudC5MID09PSBwKSBwYXJlbnQuTCA9IHE7IGVsc2UgcGFyZW50LlIgPSBxO1xuICAgIH0gZWxzZSB7XG4gICAgICB0cmVlLl8gPSBxO1xuICAgIH1cbiAgICBxLlUgPSBwYXJlbnQ7XG4gICAgcC5VID0gcTtcbiAgICBwLlIgPSBxLkw7XG4gICAgaWYgKHAuUikgcC5SLlUgPSBwO1xuICAgIHEuTCA9IHA7XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvbV92b3Jvbm9pUmVkQmxhY2tSb3RhdGVSaWdodCh0cmVlLCBub2RlKSB7XG4gICAgdmFyIHAgPSBub2RlLCBxID0gbm9kZS5MLCBwYXJlbnQgPSBwLlU7XG4gICAgaWYgKHBhcmVudCkge1xuICAgICAgaWYgKHBhcmVudC5MID09PSBwKSBwYXJlbnQuTCA9IHE7IGVsc2UgcGFyZW50LlIgPSBxO1xuICAgIH0gZWxzZSB7XG4gICAgICB0cmVlLl8gPSBxO1xuICAgIH1cbiAgICBxLlUgPSBwYXJlbnQ7XG4gICAgcC5VID0gcTtcbiAgICBwLkwgPSBxLlI7XG4gICAgaWYgKHAuTCkgcC5MLlUgPSBwO1xuICAgIHEuUiA9IHA7XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvbV92b3Jvbm9pUmVkQmxhY2tGaXJzdChub2RlKSB7XG4gICAgd2hpbGUgKG5vZGUuTCkgbm9kZSA9IG5vZGUuTDtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9tX3Zvcm9ub2koc2l0ZXMsIGJib3gpIHtcbiAgICB2YXIgc2l0ZSA9IHNpdGVzLnNvcnQoZDNfZ2VvbV92b3Jvbm9pVmVydGV4T3JkZXIpLnBvcCgpLCB4MCwgeTAsIGNpcmNsZTtcbiAgICBkM19nZW9tX3Zvcm9ub2lFZGdlcyA9IFtdO1xuICAgIGQzX2dlb21fdm9yb25vaUNlbGxzID0gbmV3IEFycmF5KHNpdGVzLmxlbmd0aCk7XG4gICAgZDNfZ2VvbV92b3Jvbm9pQmVhY2hlcyA9IG5ldyBkM19nZW9tX3Zvcm9ub2lSZWRCbGFja1RyZWUoKTtcbiAgICBkM19nZW9tX3Zvcm9ub2lDaXJjbGVzID0gbmV3IGQzX2dlb21fdm9yb25vaVJlZEJsYWNrVHJlZSgpO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBjaXJjbGUgPSBkM19nZW9tX3Zvcm9ub2lGaXJzdENpcmNsZTtcbiAgICAgIGlmIChzaXRlICYmICghY2lyY2xlIHx8IHNpdGUueSA8IGNpcmNsZS55IHx8IHNpdGUueSA9PT0gY2lyY2xlLnkgJiYgc2l0ZS54IDwgY2lyY2xlLngpKSB7XG4gICAgICAgIGlmIChzaXRlLnggIT09IHgwIHx8IHNpdGUueSAhPT0geTApIHtcbiAgICAgICAgICBkM19nZW9tX3Zvcm9ub2lDZWxsc1tzaXRlLmldID0gbmV3IGQzX2dlb21fdm9yb25vaUNlbGwoc2l0ZSk7XG4gICAgICAgICAgZDNfZ2VvbV92b3Jvbm9pQWRkQmVhY2goc2l0ZSk7XG4gICAgICAgICAgeDAgPSBzaXRlLngsIHkwID0gc2l0ZS55O1xuICAgICAgICB9XG4gICAgICAgIHNpdGUgPSBzaXRlcy5wb3AoKTtcbiAgICAgIH0gZWxzZSBpZiAoY2lyY2xlKSB7XG4gICAgICAgIGQzX2dlb21fdm9yb25vaVJlbW92ZUJlYWNoKGNpcmNsZS5hcmMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChiYm94KSBkM19nZW9tX3Zvcm9ub2lDbGlwRWRnZXMoYmJveCksIGQzX2dlb21fdm9yb25vaUNsb3NlQ2VsbHMoYmJveCk7XG4gICAgdmFyIGRpYWdyYW0gPSB7XG4gICAgICBjZWxsczogZDNfZ2VvbV92b3Jvbm9pQ2VsbHMsXG4gICAgICBlZGdlczogZDNfZ2VvbV92b3Jvbm9pRWRnZXNcbiAgICB9O1xuICAgIGQzX2dlb21fdm9yb25vaUJlYWNoZXMgPSBkM19nZW9tX3Zvcm9ub2lDaXJjbGVzID0gZDNfZ2VvbV92b3Jvbm9pRWRnZXMgPSBkM19nZW9tX3Zvcm9ub2lDZWxscyA9IG51bGw7XG4gICAgcmV0dXJuIGRpYWdyYW07XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvbV92b3Jvbm9pVmVydGV4T3JkZXIoYSwgYikge1xuICAgIHJldHVybiBiLnkgLSBhLnkgfHwgYi54IC0gYS54O1xuICB9XG4gIGQzLmdlb20udm9yb25vaSA9IGZ1bmN0aW9uKHBvaW50cykge1xuICAgIHZhciB4ID0gZDNfZ2VvbV9wb2ludFgsIHkgPSBkM19nZW9tX3BvaW50WSwgZnggPSB4LCBmeSA9IHksIGNsaXBFeHRlbnQgPSBkM19nZW9tX3Zvcm9ub2lDbGlwRXh0ZW50O1xuICAgIGlmIChwb2ludHMpIHJldHVybiB2b3Jvbm9pKHBvaW50cyk7XG4gICAgZnVuY3Rpb24gdm9yb25vaShkYXRhKSB7XG4gICAgICB2YXIgcG9seWdvbnMgPSBuZXcgQXJyYXkoZGF0YS5sZW5ndGgpLCB4MCA9IGNsaXBFeHRlbnRbMF1bMF0sIHkwID0gY2xpcEV4dGVudFswXVsxXSwgeDEgPSBjbGlwRXh0ZW50WzFdWzBdLCB5MSA9IGNsaXBFeHRlbnRbMV1bMV07XG4gICAgICBkM19nZW9tX3Zvcm9ub2koc2l0ZXMoZGF0YSksIGNsaXBFeHRlbnQpLmNlbGxzLmZvckVhY2goZnVuY3Rpb24oY2VsbCwgaSkge1xuICAgICAgICB2YXIgZWRnZXMgPSBjZWxsLmVkZ2VzLCBzaXRlID0gY2VsbC5zaXRlLCBwb2x5Z29uID0gcG9seWdvbnNbaV0gPSBlZGdlcy5sZW5ndGggPyBlZGdlcy5tYXAoZnVuY3Rpb24oZSkge1xuICAgICAgICAgIHZhciBzID0gZS5zdGFydCgpO1xuICAgICAgICAgIHJldHVybiBbIHMueCwgcy55IF07XG4gICAgICAgIH0pIDogc2l0ZS54ID49IHgwICYmIHNpdGUueCA8PSB4MSAmJiBzaXRlLnkgPj0geTAgJiYgc2l0ZS55IDw9IHkxID8gWyBbIHgwLCB5MSBdLCBbIHgxLCB5MSBdLCBbIHgxLCB5MCBdLCBbIHgwLCB5MCBdIF0gOiBbXTtcbiAgICAgICAgcG9seWdvbi5wb2ludCA9IGRhdGFbaV07XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBwb2x5Z29ucztcbiAgICB9XG4gICAgZnVuY3Rpb24gc2l0ZXMoZGF0YSkge1xuICAgICAgcmV0dXJuIGRhdGEubWFwKGZ1bmN0aW9uKGQsIGkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB4OiBNYXRoLnJvdW5kKGZ4KGQsIGkpIC8gzrUpICogzrUsXG4gICAgICAgICAgeTogTWF0aC5yb3VuZChmeShkLCBpKSAvIM61KSAqIM61LFxuICAgICAgICAgIGk6IGlcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICB2b3Jvbm9pLmxpbmtzID0gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgcmV0dXJuIGQzX2dlb21fdm9yb25vaShzaXRlcyhkYXRhKSkuZWRnZXMuZmlsdGVyKGZ1bmN0aW9uKGVkZ2UpIHtcbiAgICAgICAgcmV0dXJuIGVkZ2UubCAmJiBlZGdlLnI7XG4gICAgICB9KS5tYXAoZnVuY3Rpb24oZWRnZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHNvdXJjZTogZGF0YVtlZGdlLmwuaV0sXG4gICAgICAgICAgdGFyZ2V0OiBkYXRhW2VkZ2Uuci5pXVxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfTtcbiAgICB2b3Jvbm9pLnRyaWFuZ2xlcyA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgIHZhciB0cmlhbmdsZXMgPSBbXTtcbiAgICAgIGQzX2dlb21fdm9yb25vaShzaXRlcyhkYXRhKSkuY2VsbHMuZm9yRWFjaChmdW5jdGlvbihjZWxsLCBpKSB7XG4gICAgICAgIHZhciBzaXRlID0gY2VsbC5zaXRlLCBlZGdlcyA9IGNlbGwuZWRnZXMuc29ydChkM19nZW9tX3Zvcm9ub2lIYWxmRWRnZU9yZGVyKSwgaiA9IC0xLCBtID0gZWRnZXMubGVuZ3RoLCBlMCwgczAsIGUxID0gZWRnZXNbbSAtIDFdLmVkZ2UsIHMxID0gZTEubCA9PT0gc2l0ZSA/IGUxLnIgOiBlMS5sO1xuICAgICAgICB3aGlsZSAoKytqIDwgbSkge1xuICAgICAgICAgIGUwID0gZTE7XG4gICAgICAgICAgczAgPSBzMTtcbiAgICAgICAgICBlMSA9IGVkZ2VzW2pdLmVkZ2U7XG4gICAgICAgICAgczEgPSBlMS5sID09PSBzaXRlID8gZTEuciA6IGUxLmw7XG4gICAgICAgICAgaWYgKGkgPCBzMC5pICYmIGkgPCBzMS5pICYmIGQzX2dlb21fdm9yb25vaVRyaWFuZ2xlQXJlYShzaXRlLCBzMCwgczEpIDwgMCkge1xuICAgICAgICAgICAgdHJpYW5nbGVzLnB1c2goWyBkYXRhW2ldLCBkYXRhW3MwLmldLCBkYXRhW3MxLmldIF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdHJpYW5nbGVzO1xuICAgIH07XG4gICAgdm9yb25vaS54ID0gZnVuY3Rpb24oXykge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZnggPSBkM19mdW5jdG9yKHggPSBfKSwgdm9yb25vaSkgOiB4O1xuICAgIH07XG4gICAgdm9yb25vaS55ID0gZnVuY3Rpb24oXykge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZnkgPSBkM19mdW5jdG9yKHkgPSBfKSwgdm9yb25vaSkgOiB5O1xuICAgIH07XG4gICAgdm9yb25vaS5jbGlwRXh0ZW50ID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gY2xpcEV4dGVudCA9PT0gZDNfZ2VvbV92b3Jvbm9pQ2xpcEV4dGVudCA/IG51bGwgOiBjbGlwRXh0ZW50O1xuICAgICAgY2xpcEV4dGVudCA9IF8gPT0gbnVsbCA/IGQzX2dlb21fdm9yb25vaUNsaXBFeHRlbnQgOiBfO1xuICAgICAgcmV0dXJuIHZvcm9ub2k7XG4gICAgfTtcbiAgICB2b3Jvbm9pLnNpemUgPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBjbGlwRXh0ZW50ID09PSBkM19nZW9tX3Zvcm9ub2lDbGlwRXh0ZW50ID8gbnVsbCA6IGNsaXBFeHRlbnQgJiYgY2xpcEV4dGVudFsxXTtcbiAgICAgIHJldHVybiB2b3Jvbm9pLmNsaXBFeHRlbnQoXyAmJiBbIFsgMCwgMCBdLCBfIF0pO1xuICAgIH07XG4gICAgcmV0dXJuIHZvcm9ub2k7XG4gIH07XG4gIHZhciBkM19nZW9tX3Zvcm9ub2lDbGlwRXh0ZW50ID0gWyBbIC0xZTYsIC0xZTYgXSwgWyAxZTYsIDFlNiBdIF07XG4gIGZ1bmN0aW9uIGQzX2dlb21fdm9yb25vaVRyaWFuZ2xlQXJlYShhLCBiLCBjKSB7XG4gICAgcmV0dXJuIChhLnggLSBjLngpICogKGIueSAtIGEueSkgLSAoYS54IC0gYi54KSAqIChjLnkgLSBhLnkpO1xuICB9XG4gIGQzLmdlb20uZGVsYXVuYXkgPSBmdW5jdGlvbih2ZXJ0aWNlcykge1xuICAgIHJldHVybiBkMy5nZW9tLnZvcm9ub2koKS50cmlhbmdsZXModmVydGljZXMpO1xuICB9O1xuICBkMy5nZW9tLnF1YWR0cmVlID0gZnVuY3Rpb24ocG9pbnRzLCB4MSwgeTEsIHgyLCB5Mikge1xuICAgIHZhciB4ID0gZDNfZ2VvbV9wb2ludFgsIHkgPSBkM19nZW9tX3BvaW50WSwgY29tcGF0O1xuICAgIGlmIChjb21wYXQgPSBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICB4ID0gZDNfZ2VvbV9xdWFkdHJlZUNvbXBhdFg7XG4gICAgICB5ID0gZDNfZ2VvbV9xdWFkdHJlZUNvbXBhdFk7XG4gICAgICBpZiAoY29tcGF0ID09PSAzKSB7XG4gICAgICAgIHkyID0geTE7XG4gICAgICAgIHgyID0geDE7XG4gICAgICAgIHkxID0geDEgPSAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHF1YWR0cmVlKHBvaW50cyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHF1YWR0cmVlKGRhdGEpIHtcbiAgICAgIHZhciBkLCBmeCA9IGQzX2Z1bmN0b3IoeCksIGZ5ID0gZDNfZnVuY3Rvcih5KSwgeHMsIHlzLCBpLCBuLCB4MV8sIHkxXywgeDJfLCB5Ml87XG4gICAgICBpZiAoeDEgIT0gbnVsbCkge1xuICAgICAgICB4MV8gPSB4MSwgeTFfID0geTEsIHgyXyA9IHgyLCB5Ml8gPSB5MjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHgyXyA9IHkyXyA9IC0oeDFfID0geTFfID0gSW5maW5pdHkpO1xuICAgICAgICB4cyA9IFtdLCB5cyA9IFtdO1xuICAgICAgICBuID0gZGF0YS5sZW5ndGg7XG4gICAgICAgIGlmIChjb21wYXQpIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICBkID0gZGF0YVtpXTtcbiAgICAgICAgICBpZiAoZC54IDwgeDFfKSB4MV8gPSBkLng7XG4gICAgICAgICAgaWYgKGQueSA8IHkxXykgeTFfID0gZC55O1xuICAgICAgICAgIGlmIChkLnggPiB4Ml8pIHgyXyA9IGQueDtcbiAgICAgICAgICBpZiAoZC55ID4geTJfKSB5Ml8gPSBkLnk7XG4gICAgICAgICAgeHMucHVzaChkLngpO1xuICAgICAgICAgIHlzLnB1c2goZC55KTtcbiAgICAgICAgfSBlbHNlIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICB2YXIgeF8gPSArZngoZCA9IGRhdGFbaV0sIGkpLCB5XyA9ICtmeShkLCBpKTtcbiAgICAgICAgICBpZiAoeF8gPCB4MV8pIHgxXyA9IHhfO1xuICAgICAgICAgIGlmICh5XyA8IHkxXykgeTFfID0geV87XG4gICAgICAgICAgaWYgKHhfID4geDJfKSB4Ml8gPSB4XztcbiAgICAgICAgICBpZiAoeV8gPiB5Ml8pIHkyXyA9IHlfO1xuICAgICAgICAgIHhzLnB1c2goeF8pO1xuICAgICAgICAgIHlzLnB1c2goeV8pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgZHggPSB4Ml8gLSB4MV8sIGR5ID0geTJfIC0geTFfO1xuICAgICAgaWYgKGR4ID4gZHkpIHkyXyA9IHkxXyArIGR4OyBlbHNlIHgyXyA9IHgxXyArIGR5O1xuICAgICAgZnVuY3Rpb24gaW5zZXJ0KG4sIGQsIHgsIHksIHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgICAgIGlmIChpc05hTih4KSB8fCBpc05hTih5KSkgcmV0dXJuO1xuICAgICAgICBpZiAobi5sZWFmKSB7XG4gICAgICAgICAgdmFyIG54ID0gbi54LCBueSA9IG4ueTtcbiAgICAgICAgICBpZiAobnggIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGFicyhueCAtIHgpICsgYWJzKG55IC0geSkgPCAuMDEpIHtcbiAgICAgICAgICAgICAgaW5zZXJ0Q2hpbGQobiwgZCwgeCwgeSwgeDEsIHkxLCB4MiwgeTIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIG5Qb2ludCA9IG4ucG9pbnQ7XG4gICAgICAgICAgICAgIG4ueCA9IG4ueSA9IG4ucG9pbnQgPSBudWxsO1xuICAgICAgICAgICAgICBpbnNlcnRDaGlsZChuLCBuUG9pbnQsIG54LCBueSwgeDEsIHkxLCB4MiwgeTIpO1xuICAgICAgICAgICAgICBpbnNlcnRDaGlsZChuLCBkLCB4LCB5LCB4MSwgeTEsIHgyLCB5Mik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG4ueCA9IHgsIG4ueSA9IHksIG4ucG9pbnQgPSBkO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbnNlcnRDaGlsZChuLCBkLCB4LCB5LCB4MSwgeTEsIHgyLCB5Mik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGluc2VydENoaWxkKG4sIGQsIHgsIHksIHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgICAgIHZhciB4bSA9ICh4MSArIHgyKSAqIC41LCB5bSA9ICh5MSArIHkyKSAqIC41LCByaWdodCA9IHggPj0geG0sIGJlbG93ID0geSA+PSB5bSwgaSA9IGJlbG93IDw8IDEgfCByaWdodDtcbiAgICAgICAgbi5sZWFmID0gZmFsc2U7XG4gICAgICAgIG4gPSBuLm5vZGVzW2ldIHx8IChuLm5vZGVzW2ldID0gZDNfZ2VvbV9xdWFkdHJlZU5vZGUoKSk7XG4gICAgICAgIGlmIChyaWdodCkgeDEgPSB4bTsgZWxzZSB4MiA9IHhtO1xuICAgICAgICBpZiAoYmVsb3cpIHkxID0geW07IGVsc2UgeTIgPSB5bTtcbiAgICAgICAgaW5zZXJ0KG4sIGQsIHgsIHksIHgxLCB5MSwgeDIsIHkyKTtcbiAgICAgIH1cbiAgICAgIHZhciByb290ID0gZDNfZ2VvbV9xdWFkdHJlZU5vZGUoKTtcbiAgICAgIHJvb3QuYWRkID0gZnVuY3Rpb24oZCkge1xuICAgICAgICBpbnNlcnQocm9vdCwgZCwgK2Z4KGQsICsraSksICtmeShkLCBpKSwgeDFfLCB5MV8sIHgyXywgeTJfKTtcbiAgICAgIH07XG4gICAgICByb290LnZpc2l0ID0gZnVuY3Rpb24oZikge1xuICAgICAgICBkM19nZW9tX3F1YWR0cmVlVmlzaXQoZiwgcm9vdCwgeDFfLCB5MV8sIHgyXywgeTJfKTtcbiAgICAgIH07XG4gICAgICByb290LmZpbmQgPSBmdW5jdGlvbihwb2ludCkge1xuICAgICAgICByZXR1cm4gZDNfZ2VvbV9xdWFkdHJlZUZpbmQocm9vdCwgcG9pbnRbMF0sIHBvaW50WzFdLCB4MV8sIHkxXywgeDJfLCB5Ml8pO1xuICAgICAgfTtcbiAgICAgIGkgPSAtMTtcbiAgICAgIGlmICh4MSA9PSBudWxsKSB7XG4gICAgICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgICAgaW5zZXJ0KHJvb3QsIGRhdGFbaV0sIHhzW2ldLCB5c1tpXSwgeDFfLCB5MV8sIHgyXywgeTJfKTtcbiAgICAgICAgfVxuICAgICAgICAtLWk7XG4gICAgICB9IGVsc2UgZGF0YS5mb3JFYWNoKHJvb3QuYWRkKTtcbiAgICAgIHhzID0geXMgPSBkYXRhID0gZCA9IG51bGw7XG4gICAgICByZXR1cm4gcm9vdDtcbiAgICB9XG4gICAgcXVhZHRyZWUueCA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHggPSBfLCBxdWFkdHJlZSkgOiB4O1xuICAgIH07XG4gICAgcXVhZHRyZWUueSA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHkgPSBfLCBxdWFkdHJlZSkgOiB5O1xuICAgIH07XG4gICAgcXVhZHRyZWUuZXh0ZW50ID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4geDEgPT0gbnVsbCA/IG51bGwgOiBbIFsgeDEsIHkxIF0sIFsgeDIsIHkyIF0gXTtcbiAgICAgIGlmIChfID09IG51bGwpIHgxID0geTEgPSB4MiA9IHkyID0gbnVsbDsgZWxzZSB4MSA9ICtfWzBdWzBdLCB5MSA9ICtfWzBdWzFdLCB4MiA9ICtfWzFdWzBdLCBcbiAgICAgIHkyID0gK19bMV1bMV07XG4gICAgICByZXR1cm4gcXVhZHRyZWU7XG4gICAgfTtcbiAgICBxdWFkdHJlZS5zaXplID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4geDEgPT0gbnVsbCA/IG51bGwgOiBbIHgyIC0geDEsIHkyIC0geTEgXTtcbiAgICAgIGlmIChfID09IG51bGwpIHgxID0geTEgPSB4MiA9IHkyID0gbnVsbDsgZWxzZSB4MSA9IHkxID0gMCwgeDIgPSArX1swXSwgeTIgPSArX1sxXTtcbiAgICAgIHJldHVybiBxdWFkdHJlZTtcbiAgICB9O1xuICAgIHJldHVybiBxdWFkdHJlZTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfZ2VvbV9xdWFkdHJlZUNvbXBhdFgoZCkge1xuICAgIHJldHVybiBkLng7XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvbV9xdWFkdHJlZUNvbXBhdFkoZCkge1xuICAgIHJldHVybiBkLnk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvbV9xdWFkdHJlZU5vZGUoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxlYWY6IHRydWUsXG4gICAgICBub2RlczogW10sXG4gICAgICBwb2ludDogbnVsbCxcbiAgICAgIHg6IG51bGwsXG4gICAgICB5OiBudWxsXG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9tX3F1YWR0cmVlVmlzaXQoZiwgbm9kZSwgeDEsIHkxLCB4MiwgeTIpIHtcbiAgICBpZiAoIWYobm9kZSwgeDEsIHkxLCB4MiwgeTIpKSB7XG4gICAgICB2YXIgc3ggPSAoeDEgKyB4MikgKiAuNSwgc3kgPSAoeTEgKyB5MikgKiAuNSwgY2hpbGRyZW4gPSBub2RlLm5vZGVzO1xuICAgICAgaWYgKGNoaWxkcmVuWzBdKSBkM19nZW9tX3F1YWR0cmVlVmlzaXQoZiwgY2hpbGRyZW5bMF0sIHgxLCB5MSwgc3gsIHN5KTtcbiAgICAgIGlmIChjaGlsZHJlblsxXSkgZDNfZ2VvbV9xdWFkdHJlZVZpc2l0KGYsIGNoaWxkcmVuWzFdLCBzeCwgeTEsIHgyLCBzeSk7XG4gICAgICBpZiAoY2hpbGRyZW5bMl0pIGQzX2dlb21fcXVhZHRyZWVWaXNpdChmLCBjaGlsZHJlblsyXSwgeDEsIHN5LCBzeCwgeTIpO1xuICAgICAgaWYgKGNoaWxkcmVuWzNdKSBkM19nZW9tX3F1YWR0cmVlVmlzaXQoZiwgY2hpbGRyZW5bM10sIHN4LCBzeSwgeDIsIHkyKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvbV9xdWFkdHJlZUZpbmQocm9vdCwgeCwgeSwgeDAsIHkwLCB4MywgeTMpIHtcbiAgICB2YXIgbWluRGlzdGFuY2UyID0gSW5maW5pdHksIGNsb3Nlc3RQb2ludDtcbiAgICAoZnVuY3Rpb24gZmluZChub2RlLCB4MSwgeTEsIHgyLCB5Mikge1xuICAgICAgaWYgKHgxID4geDMgfHwgeTEgPiB5MyB8fCB4MiA8IHgwIHx8IHkyIDwgeTApIHJldHVybjtcbiAgICAgIGlmIChwb2ludCA9IG5vZGUucG9pbnQpIHtcbiAgICAgICAgdmFyIHBvaW50LCBkeCA9IHggLSBub2RlLngsIGR5ID0geSAtIG5vZGUueSwgZGlzdGFuY2UyID0gZHggKiBkeCArIGR5ICogZHk7XG4gICAgICAgIGlmIChkaXN0YW5jZTIgPCBtaW5EaXN0YW5jZTIpIHtcbiAgICAgICAgICB2YXIgZGlzdGFuY2UgPSBNYXRoLnNxcnQobWluRGlzdGFuY2UyID0gZGlzdGFuY2UyKTtcbiAgICAgICAgICB4MCA9IHggLSBkaXN0YW5jZSwgeTAgPSB5IC0gZGlzdGFuY2U7XG4gICAgICAgICAgeDMgPSB4ICsgZGlzdGFuY2UsIHkzID0geSArIGRpc3RhbmNlO1xuICAgICAgICAgIGNsb3Nlc3RQb2ludCA9IHBvaW50O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgY2hpbGRyZW4gPSBub2RlLm5vZGVzLCB4bSA9ICh4MSArIHgyKSAqIC41LCB5bSA9ICh5MSArIHkyKSAqIC41LCByaWdodCA9IHggPj0geG0sIGJlbG93ID0geSA+PSB5bTtcbiAgICAgIGZvciAodmFyIGkgPSBiZWxvdyA8PCAxIHwgcmlnaHQsIGogPSBpICsgNDsgaSA8IGo7ICsraSkge1xuICAgICAgICBpZiAobm9kZSA9IGNoaWxkcmVuW2kgJiAzXSkgc3dpdGNoIChpICYgMykge1xuICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIGZpbmQobm9kZSwgeDEsIHkxLCB4bSwgeW0pO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgZmluZChub2RlLCB4bSwgeTEsIHgyLCB5bSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBmaW5kKG5vZGUsIHgxLCB5bSwgeG0sIHkyKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIGZpbmQobm9kZSwgeG0sIHltLCB4MiwgeTIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSkocm9vdCwgeDAsIHkwLCB4MywgeTMpO1xuICAgIHJldHVybiBjbG9zZXN0UG9pbnQ7XG4gIH1cbiAgZDMuaW50ZXJwb2xhdGVSZ2IgPSBkM19pbnRlcnBvbGF0ZVJnYjtcbiAgZnVuY3Rpb24gZDNfaW50ZXJwb2xhdGVSZ2IoYSwgYikge1xuICAgIGEgPSBkMy5yZ2IoYSk7XG4gICAgYiA9IGQzLnJnYihiKTtcbiAgICB2YXIgYXIgPSBhLnIsIGFnID0gYS5nLCBhYiA9IGEuYiwgYnIgPSBiLnIgLSBhciwgYmcgPSBiLmcgLSBhZywgYmIgPSBiLmIgLSBhYjtcbiAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgcmV0dXJuIFwiI1wiICsgZDNfcmdiX2hleChNYXRoLnJvdW5kKGFyICsgYnIgKiB0KSkgKyBkM19yZ2JfaGV4KE1hdGgucm91bmQoYWcgKyBiZyAqIHQpKSArIGQzX3JnYl9oZXgoTWF0aC5yb3VuZChhYiArIGJiICogdCkpO1xuICAgIH07XG4gIH1cbiAgZDMuaW50ZXJwb2xhdGVPYmplY3QgPSBkM19pbnRlcnBvbGF0ZU9iamVjdDtcbiAgZnVuY3Rpb24gZDNfaW50ZXJwb2xhdGVPYmplY3QoYSwgYikge1xuICAgIHZhciBpID0ge30sIGMgPSB7fSwgaztcbiAgICBmb3IgKGsgaW4gYSkge1xuICAgICAgaWYgKGsgaW4gYikge1xuICAgICAgICBpW2tdID0gZDNfaW50ZXJwb2xhdGUoYVtrXSwgYltrXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjW2tdID0gYVtrXTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChrIGluIGIpIHtcbiAgICAgIGlmICghKGsgaW4gYSkpIHtcbiAgICAgICAgY1trXSA9IGJba107XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICBmb3IgKGsgaW4gaSkgY1trXSA9IGlba10odCk7XG4gICAgICByZXR1cm4gYztcbiAgICB9O1xuICB9XG4gIGQzLmludGVycG9sYXRlTnVtYmVyID0gZDNfaW50ZXJwb2xhdGVOdW1iZXI7XG4gIGZ1bmN0aW9uIGQzX2ludGVycG9sYXRlTnVtYmVyKGEsIGIpIHtcbiAgICBhID0gK2EsIGIgPSArYjtcbiAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgcmV0dXJuIGEgKiAoMSAtIHQpICsgYiAqIHQ7XG4gICAgfTtcbiAgfVxuICBkMy5pbnRlcnBvbGF0ZVN0cmluZyA9IGQzX2ludGVycG9sYXRlU3RyaW5nO1xuICBmdW5jdGlvbiBkM19pbnRlcnBvbGF0ZVN0cmluZyhhLCBiKSB7XG4gICAgdmFyIGJpID0gZDNfaW50ZXJwb2xhdGVfbnVtYmVyQS5sYXN0SW5kZXggPSBkM19pbnRlcnBvbGF0ZV9udW1iZXJCLmxhc3RJbmRleCA9IDAsIGFtLCBibSwgYnMsIGkgPSAtMSwgcyA9IFtdLCBxID0gW107XG4gICAgYSA9IGEgKyBcIlwiLCBiID0gYiArIFwiXCI7XG4gICAgd2hpbGUgKChhbSA9IGQzX2ludGVycG9sYXRlX251bWJlckEuZXhlYyhhKSkgJiYgKGJtID0gZDNfaW50ZXJwb2xhdGVfbnVtYmVyQi5leGVjKGIpKSkge1xuICAgICAgaWYgKChicyA9IGJtLmluZGV4KSA+IGJpKSB7XG4gICAgICAgIGJzID0gYi5zbGljZShiaSwgYnMpO1xuICAgICAgICBpZiAoc1tpXSkgc1tpXSArPSBiczsgZWxzZSBzWysraV0gPSBicztcbiAgICAgIH1cbiAgICAgIGlmICgoYW0gPSBhbVswXSkgPT09IChibSA9IGJtWzBdKSkge1xuICAgICAgICBpZiAoc1tpXSkgc1tpXSArPSBibTsgZWxzZSBzWysraV0gPSBibTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNbKytpXSA9IG51bGw7XG4gICAgICAgIHEucHVzaCh7XG4gICAgICAgICAgaTogaSxcbiAgICAgICAgICB4OiBkM19pbnRlcnBvbGF0ZU51bWJlcihhbSwgYm0pXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgYmkgPSBkM19pbnRlcnBvbGF0ZV9udW1iZXJCLmxhc3RJbmRleDtcbiAgICB9XG4gICAgaWYgKGJpIDwgYi5sZW5ndGgpIHtcbiAgICAgIGJzID0gYi5zbGljZShiaSk7XG4gICAgICBpZiAoc1tpXSkgc1tpXSArPSBiczsgZWxzZSBzWysraV0gPSBicztcbiAgICB9XG4gICAgcmV0dXJuIHMubGVuZ3RoIDwgMiA/IHFbMF0gPyAoYiA9IHFbMF0ueCwgZnVuY3Rpb24odCkge1xuICAgICAgcmV0dXJuIGIodCkgKyBcIlwiO1xuICAgIH0pIDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gYjtcbiAgICB9IDogKGIgPSBxLmxlbmd0aCwgZnVuY3Rpb24odCkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIG87IGkgPCBiOyArK2kpIHNbKG8gPSBxW2ldKS5pXSA9IG8ueCh0KTtcbiAgICAgIHJldHVybiBzLmpvaW4oXCJcIik7XG4gICAgfSk7XG4gIH1cbiAgdmFyIGQzX2ludGVycG9sYXRlX251bWJlckEgPSAvWy0rXT8oPzpcXGQrXFwuP1xcZCp8XFwuP1xcZCspKD86W2VFXVstK10/XFxkKyk/L2csIGQzX2ludGVycG9sYXRlX251bWJlckIgPSBuZXcgUmVnRXhwKGQzX2ludGVycG9sYXRlX251bWJlckEuc291cmNlLCBcImdcIik7XG4gIGQzLmludGVycG9sYXRlID0gZDNfaW50ZXJwb2xhdGU7XG4gIGZ1bmN0aW9uIGQzX2ludGVycG9sYXRlKGEsIGIpIHtcbiAgICB2YXIgaSA9IGQzLmludGVycG9sYXRvcnMubGVuZ3RoLCBmO1xuICAgIHdoaWxlICgtLWkgPj0gMCAmJiAhKGYgPSBkMy5pbnRlcnBvbGF0b3JzW2ldKGEsIGIpKSkgO1xuICAgIHJldHVybiBmO1xuICB9XG4gIGQzLmludGVycG9sYXRvcnMgPSBbIGZ1bmN0aW9uKGEsIGIpIHtcbiAgICB2YXIgdCA9IHR5cGVvZiBiO1xuICAgIHJldHVybiAodCA9PT0gXCJzdHJpbmdcIiA/IGQzX3JnYl9uYW1lcy5oYXMoYi50b0xvd2VyQ2FzZSgpKSB8fCAvXigjfHJnYlxcKHxoc2xcXCgpL2kudGVzdChiKSA/IGQzX2ludGVycG9sYXRlUmdiIDogZDNfaW50ZXJwb2xhdGVTdHJpbmcgOiBiIGluc3RhbmNlb2YgZDNfY29sb3IgPyBkM19pbnRlcnBvbGF0ZVJnYiA6IEFycmF5LmlzQXJyYXkoYikgPyBkM19pbnRlcnBvbGF0ZUFycmF5IDogdCA9PT0gXCJvYmplY3RcIiAmJiBpc05hTihiKSA/IGQzX2ludGVycG9sYXRlT2JqZWN0IDogZDNfaW50ZXJwb2xhdGVOdW1iZXIpKGEsIGIpO1xuICB9IF07XG4gIGQzLmludGVycG9sYXRlQXJyYXkgPSBkM19pbnRlcnBvbGF0ZUFycmF5O1xuICBmdW5jdGlvbiBkM19pbnRlcnBvbGF0ZUFycmF5KGEsIGIpIHtcbiAgICB2YXIgeCA9IFtdLCBjID0gW10sIG5hID0gYS5sZW5ndGgsIG5iID0gYi5sZW5ndGgsIG4wID0gTWF0aC5taW4oYS5sZW5ndGgsIGIubGVuZ3RoKSwgaTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbjA7ICsraSkgeC5wdXNoKGQzX2ludGVycG9sYXRlKGFbaV0sIGJbaV0pKTtcbiAgICBmb3IgKDtpIDwgbmE7ICsraSkgY1tpXSA9IGFbaV07XG4gICAgZm9yICg7aSA8IG5iOyArK2kpIGNbaV0gPSBiW2ldO1xuICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbjA7ICsraSkgY1tpXSA9IHhbaV0odCk7XG4gICAgICByZXR1cm4gYztcbiAgICB9O1xuICB9XG4gIHZhciBkM19lYXNlX2RlZmF1bHQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZDNfaWRlbnRpdHk7XG4gIH07XG4gIHZhciBkM19lYXNlID0gZDMubWFwKHtcbiAgICBsaW5lYXI6IGQzX2Vhc2VfZGVmYXVsdCxcbiAgICBwb2x5OiBkM19lYXNlX3BvbHksXG4gICAgcXVhZDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZDNfZWFzZV9xdWFkO1xuICAgIH0sXG4gICAgY3ViaWM6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGQzX2Vhc2VfY3ViaWM7XG4gICAgfSxcbiAgICBzaW46IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGQzX2Vhc2Vfc2luO1xuICAgIH0sXG4gICAgZXhwOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBkM19lYXNlX2V4cDtcbiAgICB9LFxuICAgIGNpcmNsZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZDNfZWFzZV9jaXJjbGU7XG4gICAgfSxcbiAgICBlbGFzdGljOiBkM19lYXNlX2VsYXN0aWMsXG4gICAgYmFjazogZDNfZWFzZV9iYWNrLFxuICAgIGJvdW5jZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZDNfZWFzZV9ib3VuY2U7XG4gICAgfVxuICB9KTtcbiAgdmFyIGQzX2Vhc2VfbW9kZSA9IGQzLm1hcCh7XG4gICAgXCJpblwiOiBkM19pZGVudGl0eSxcbiAgICBvdXQ6IGQzX2Vhc2VfcmV2ZXJzZSxcbiAgICBcImluLW91dFwiOiBkM19lYXNlX3JlZmxlY3QsXG4gICAgXCJvdXQtaW5cIjogZnVuY3Rpb24oZikge1xuICAgICAgcmV0dXJuIGQzX2Vhc2VfcmVmbGVjdChkM19lYXNlX3JldmVyc2UoZikpO1xuICAgIH1cbiAgfSk7XG4gIGQzLmVhc2UgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgdmFyIGkgPSBuYW1lLmluZGV4T2YoXCItXCIpLCB0ID0gaSA+PSAwID8gbmFtZS5zbGljZSgwLCBpKSA6IG5hbWUsIG0gPSBpID49IDAgPyBuYW1lLnNsaWNlKGkgKyAxKSA6IFwiaW5cIjtcbiAgICB0ID0gZDNfZWFzZS5nZXQodCkgfHwgZDNfZWFzZV9kZWZhdWx0O1xuICAgIG0gPSBkM19lYXNlX21vZGUuZ2V0KG0pIHx8IGQzX2lkZW50aXR5O1xuICAgIHJldHVybiBkM19lYXNlX2NsYW1wKG0odC5hcHBseShudWxsLCBkM19hcnJheVNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSkpKTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfZWFzZV9jbGFtcChmKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgIHJldHVybiB0IDw9IDAgPyAwIDogdCA+PSAxID8gMSA6IGYodCk7XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBkM19lYXNlX3JldmVyc2UoZikge1xuICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICByZXR1cm4gMSAtIGYoMSAtIHQpO1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gZDNfZWFzZV9yZWZsZWN0KGYpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgcmV0dXJuIC41ICogKHQgPCAuNSA/IGYoMiAqIHQpIDogMiAtIGYoMiAtIDIgKiB0KSk7XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBkM19lYXNlX3F1YWQodCkge1xuICAgIHJldHVybiB0ICogdDtcbiAgfVxuICBmdW5jdGlvbiBkM19lYXNlX2N1YmljKHQpIHtcbiAgICByZXR1cm4gdCAqIHQgKiB0O1xuICB9XG4gIGZ1bmN0aW9uIGQzX2Vhc2VfY3ViaWNJbk91dCh0KSB7XG4gICAgaWYgKHQgPD0gMCkgcmV0dXJuIDA7XG4gICAgaWYgKHQgPj0gMSkgcmV0dXJuIDE7XG4gICAgdmFyIHQyID0gdCAqIHQsIHQzID0gdDIgKiB0O1xuICAgIHJldHVybiA0ICogKHQgPCAuNSA/IHQzIDogMyAqICh0IC0gdDIpICsgdDMgLSAuNzUpO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2Vhc2VfcG9seShlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgIHJldHVybiBNYXRoLnBvdyh0LCBlKTtcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGQzX2Vhc2Vfc2luKHQpIHtcbiAgICByZXR1cm4gMSAtIE1hdGguY29zKHQgKiBoYWxmz4ApO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2Vhc2VfZXhwKHQpIHtcbiAgICByZXR1cm4gTWF0aC5wb3coMiwgMTAgKiAodCAtIDEpKTtcbiAgfVxuICBmdW5jdGlvbiBkM19lYXNlX2NpcmNsZSh0KSB7XG4gICAgcmV0dXJuIDEgLSBNYXRoLnNxcnQoMSAtIHQgKiB0KTtcbiAgfVxuICBmdW5jdGlvbiBkM19lYXNlX2VsYXN0aWMoYSwgcCkge1xuICAgIHZhciBzO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikgcCA9IC40NTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkgcyA9IHAgLyDPhCAqIE1hdGguYXNpbigxIC8gYSk7IGVsc2UgYSA9IDEsIHMgPSBwIC8gNDtcbiAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgcmV0dXJuIDEgKyBhICogTWF0aC5wb3coMiwgLTEwICogdCkgKiBNYXRoLnNpbigodCAtIHMpICogz4QgLyBwKTtcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGQzX2Vhc2VfYmFjayhzKSB7XG4gICAgaWYgKCFzKSBzID0gMS43MDE1ODtcbiAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgcmV0dXJuIHQgKiB0ICogKChzICsgMSkgKiB0IC0gcyk7XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBkM19lYXNlX2JvdW5jZSh0KSB7XG4gICAgcmV0dXJuIHQgPCAxIC8gMi43NSA/IDcuNTYyNSAqIHQgKiB0IDogdCA8IDIgLyAyLjc1ID8gNy41NjI1ICogKHQgLT0gMS41IC8gMi43NSkgKiB0ICsgLjc1IDogdCA8IDIuNSAvIDIuNzUgPyA3LjU2MjUgKiAodCAtPSAyLjI1IC8gMi43NSkgKiB0ICsgLjkzNzUgOiA3LjU2MjUgKiAodCAtPSAyLjYyNSAvIDIuNzUpICogdCArIC45ODQzNzU7XG4gIH1cbiAgZDMuaW50ZXJwb2xhdGVIY2wgPSBkM19pbnRlcnBvbGF0ZUhjbDtcbiAgZnVuY3Rpb24gZDNfaW50ZXJwb2xhdGVIY2woYSwgYikge1xuICAgIGEgPSBkMy5oY2woYSk7XG4gICAgYiA9IGQzLmhjbChiKTtcbiAgICB2YXIgYWggPSBhLmgsIGFjID0gYS5jLCBhbCA9IGEubCwgYmggPSBiLmggLSBhaCwgYmMgPSBiLmMgLSBhYywgYmwgPSBiLmwgLSBhbDtcbiAgICBpZiAoaXNOYU4oYmMpKSBiYyA9IDAsIGFjID0gaXNOYU4oYWMpID8gYi5jIDogYWM7XG4gICAgaWYgKGlzTmFOKGJoKSkgYmggPSAwLCBhaCA9IGlzTmFOKGFoKSA/IGIuaCA6IGFoOyBlbHNlIGlmIChiaCA+IDE4MCkgYmggLT0gMzYwOyBlbHNlIGlmIChiaCA8IC0xODApIGJoICs9IDM2MDtcbiAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgcmV0dXJuIGQzX2hjbF9sYWIoYWggKyBiaCAqIHQsIGFjICsgYmMgKiB0LCBhbCArIGJsICogdCkgKyBcIlwiO1xuICAgIH07XG4gIH1cbiAgZDMuaW50ZXJwb2xhdGVIc2wgPSBkM19pbnRlcnBvbGF0ZUhzbDtcbiAgZnVuY3Rpb24gZDNfaW50ZXJwb2xhdGVIc2woYSwgYikge1xuICAgIGEgPSBkMy5oc2woYSk7XG4gICAgYiA9IGQzLmhzbChiKTtcbiAgICB2YXIgYWggPSBhLmgsIGFzID0gYS5zLCBhbCA9IGEubCwgYmggPSBiLmggLSBhaCwgYnMgPSBiLnMgLSBhcywgYmwgPSBiLmwgLSBhbDtcbiAgICBpZiAoaXNOYU4oYnMpKSBicyA9IDAsIGFzID0gaXNOYU4oYXMpID8gYi5zIDogYXM7XG4gICAgaWYgKGlzTmFOKGJoKSkgYmggPSAwLCBhaCA9IGlzTmFOKGFoKSA/IGIuaCA6IGFoOyBlbHNlIGlmIChiaCA+IDE4MCkgYmggLT0gMzYwOyBlbHNlIGlmIChiaCA8IC0xODApIGJoICs9IDM2MDtcbiAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgcmV0dXJuIGQzX2hzbF9yZ2IoYWggKyBiaCAqIHQsIGFzICsgYnMgKiB0LCBhbCArIGJsICogdCkgKyBcIlwiO1xuICAgIH07XG4gIH1cbiAgZDMuaW50ZXJwb2xhdGVMYWIgPSBkM19pbnRlcnBvbGF0ZUxhYjtcbiAgZnVuY3Rpb24gZDNfaW50ZXJwb2xhdGVMYWIoYSwgYikge1xuICAgIGEgPSBkMy5sYWIoYSk7XG4gICAgYiA9IGQzLmxhYihiKTtcbiAgICB2YXIgYWwgPSBhLmwsIGFhID0gYS5hLCBhYiA9IGEuYiwgYmwgPSBiLmwgLSBhbCwgYmEgPSBiLmEgLSBhYSwgYmIgPSBiLmIgLSBhYjtcbiAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgcmV0dXJuIGQzX2xhYl9yZ2IoYWwgKyBibCAqIHQsIGFhICsgYmEgKiB0LCBhYiArIGJiICogdCkgKyBcIlwiO1xuICAgIH07XG4gIH1cbiAgZDMuaW50ZXJwb2xhdGVSb3VuZCA9IGQzX2ludGVycG9sYXRlUm91bmQ7XG4gIGZ1bmN0aW9uIGQzX2ludGVycG9sYXRlUm91bmQoYSwgYikge1xuICAgIGIgLT0gYTtcbiAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgcmV0dXJuIE1hdGgucm91bmQoYSArIGIgKiB0KTtcbiAgICB9O1xuICB9XG4gIGQzLnRyYW5zZm9ybSA9IGZ1bmN0aW9uKHN0cmluZykge1xuICAgIHZhciBnID0gZDNfZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKGQzLm5zLnByZWZpeC5zdmcsIFwiZ1wiKTtcbiAgICByZXR1cm4gKGQzLnRyYW5zZm9ybSA9IGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgaWYgKHN0cmluZyAhPSBudWxsKSB7XG4gICAgICAgIGcuc2V0QXR0cmlidXRlKFwidHJhbnNmb3JtXCIsIHN0cmluZyk7XG4gICAgICAgIHZhciB0ID0gZy50cmFuc2Zvcm0uYmFzZVZhbC5jb25zb2xpZGF0ZSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBkM190cmFuc2Zvcm0odCA/IHQubWF0cml4IDogZDNfdHJhbnNmb3JtSWRlbnRpdHkpO1xuICAgIH0pKHN0cmluZyk7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX3RyYW5zZm9ybShtKSB7XG4gICAgdmFyIHIwID0gWyBtLmEsIG0uYiBdLCByMSA9IFsgbS5jLCBtLmQgXSwga3ggPSBkM190cmFuc2Zvcm1Ob3JtYWxpemUocjApLCBreiA9IGQzX3RyYW5zZm9ybURvdChyMCwgcjEpLCBreSA9IGQzX3RyYW5zZm9ybU5vcm1hbGl6ZShkM190cmFuc2Zvcm1Db21iaW5lKHIxLCByMCwgLWt6KSkgfHwgMDtcbiAgICBpZiAocjBbMF0gKiByMVsxXSA8IHIxWzBdICogcjBbMV0pIHtcbiAgICAgIHIwWzBdICo9IC0xO1xuICAgICAgcjBbMV0gKj0gLTE7XG4gICAgICBreCAqPSAtMTtcbiAgICAgIGt6ICo9IC0xO1xuICAgIH1cbiAgICB0aGlzLnJvdGF0ZSA9IChreCA/IE1hdGguYXRhbjIocjBbMV0sIHIwWzBdKSA6IE1hdGguYXRhbjIoLXIxWzBdLCByMVsxXSkpICogZDNfZGVncmVlcztcbiAgICB0aGlzLnRyYW5zbGF0ZSA9IFsgbS5lLCBtLmYgXTtcbiAgICB0aGlzLnNjYWxlID0gWyBreCwga3kgXTtcbiAgICB0aGlzLnNrZXcgPSBreSA/IE1hdGguYXRhbjIoa3osIGt5KSAqIGQzX2RlZ3JlZXMgOiAwO1xuICB9XG4gIGQzX3RyYW5zZm9ybS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gXCJ0cmFuc2xhdGUoXCIgKyB0aGlzLnRyYW5zbGF0ZSArIFwiKXJvdGF0ZShcIiArIHRoaXMucm90YXRlICsgXCIpc2tld1goXCIgKyB0aGlzLnNrZXcgKyBcIilzY2FsZShcIiArIHRoaXMuc2NhbGUgKyBcIilcIjtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfdHJhbnNmb3JtRG90KGEsIGIpIHtcbiAgICByZXR1cm4gYVswXSAqIGJbMF0gKyBhWzFdICogYlsxXTtcbiAgfVxuICBmdW5jdGlvbiBkM190cmFuc2Zvcm1Ob3JtYWxpemUoYSkge1xuICAgIHZhciBrID0gTWF0aC5zcXJ0KGQzX3RyYW5zZm9ybURvdChhLCBhKSk7XG4gICAgaWYgKGspIHtcbiAgICAgIGFbMF0gLz0gaztcbiAgICAgIGFbMV0gLz0gaztcbiAgICB9XG4gICAgcmV0dXJuIGs7XG4gIH1cbiAgZnVuY3Rpb24gZDNfdHJhbnNmb3JtQ29tYmluZShhLCBiLCBrKSB7XG4gICAgYVswXSArPSBrICogYlswXTtcbiAgICBhWzFdICs9IGsgKiBiWzFdO1xuICAgIHJldHVybiBhO1xuICB9XG4gIHZhciBkM190cmFuc2Zvcm1JZGVudGl0eSA9IHtcbiAgICBhOiAxLFxuICAgIGI6IDAsXG4gICAgYzogMCxcbiAgICBkOiAxLFxuICAgIGU6IDAsXG4gICAgZjogMFxuICB9O1xuICBkMy5pbnRlcnBvbGF0ZVRyYW5zZm9ybSA9IGQzX2ludGVycG9sYXRlVHJhbnNmb3JtO1xuICBmdW5jdGlvbiBkM19pbnRlcnBvbGF0ZVRyYW5zZm9ybVBvcChzKSB7XG4gICAgcmV0dXJuIHMubGVuZ3RoID8gcy5wb3AoKSArIFwiLFwiIDogXCJcIjtcbiAgfVxuICBmdW5jdGlvbiBkM19pbnRlcnBvbGF0ZVRyYW5zbGF0ZSh0YSwgdGIsIHMsIHEpIHtcbiAgICBpZiAodGFbMF0gIT09IHRiWzBdIHx8IHRhWzFdICE9PSB0YlsxXSkge1xuICAgICAgdmFyIGkgPSBzLnB1c2goXCJ0cmFuc2xhdGUoXCIsIG51bGwsIFwiLFwiLCBudWxsLCBcIilcIik7XG4gICAgICBxLnB1c2goe1xuICAgICAgICBpOiBpIC0gNCxcbiAgICAgICAgeDogZDNfaW50ZXJwb2xhdGVOdW1iZXIodGFbMF0sIHRiWzBdKVxuICAgICAgfSwge1xuICAgICAgICBpOiBpIC0gMixcbiAgICAgICAgeDogZDNfaW50ZXJwb2xhdGVOdW1iZXIodGFbMV0sIHRiWzFdKVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICh0YlswXSB8fCB0YlsxXSkge1xuICAgICAgcy5wdXNoKFwidHJhbnNsYXRlKFwiICsgdGIgKyBcIilcIik7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGQzX2ludGVycG9sYXRlUm90YXRlKHJhLCByYiwgcywgcSkge1xuICAgIGlmIChyYSAhPT0gcmIpIHtcbiAgICAgIGlmIChyYSAtIHJiID4gMTgwKSByYiArPSAzNjA7IGVsc2UgaWYgKHJiIC0gcmEgPiAxODApIHJhICs9IDM2MDtcbiAgICAgIHEucHVzaCh7XG4gICAgICAgIGk6IHMucHVzaChkM19pbnRlcnBvbGF0ZVRyYW5zZm9ybVBvcChzKSArIFwicm90YXRlKFwiLCBudWxsLCBcIilcIikgLSAyLFxuICAgICAgICB4OiBkM19pbnRlcnBvbGF0ZU51bWJlcihyYSwgcmIpXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHJiKSB7XG4gICAgICBzLnB1c2goZDNfaW50ZXJwb2xhdGVUcmFuc2Zvcm1Qb3AocykgKyBcInJvdGF0ZShcIiArIHJiICsgXCIpXCIpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBkM19pbnRlcnBvbGF0ZVNrZXcod2EsIHdiLCBzLCBxKSB7XG4gICAgaWYgKHdhICE9PSB3Yikge1xuICAgICAgcS5wdXNoKHtcbiAgICAgICAgaTogcy5wdXNoKGQzX2ludGVycG9sYXRlVHJhbnNmb3JtUG9wKHMpICsgXCJza2V3WChcIiwgbnVsbCwgXCIpXCIpIC0gMixcbiAgICAgICAgeDogZDNfaW50ZXJwb2xhdGVOdW1iZXIod2EsIHdiKVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICh3Yikge1xuICAgICAgcy5wdXNoKGQzX2ludGVycG9sYXRlVHJhbnNmb3JtUG9wKHMpICsgXCJza2V3WChcIiArIHdiICsgXCIpXCIpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBkM19pbnRlcnBvbGF0ZVNjYWxlKGthLCBrYiwgcywgcSkge1xuICAgIGlmIChrYVswXSAhPT0ga2JbMF0gfHwga2FbMV0gIT09IGtiWzFdKSB7XG4gICAgICB2YXIgaSA9IHMucHVzaChkM19pbnRlcnBvbGF0ZVRyYW5zZm9ybVBvcChzKSArIFwic2NhbGUoXCIsIG51bGwsIFwiLFwiLCBudWxsLCBcIilcIik7XG4gICAgICBxLnB1c2goe1xuICAgICAgICBpOiBpIC0gNCxcbiAgICAgICAgeDogZDNfaW50ZXJwb2xhdGVOdW1iZXIoa2FbMF0sIGtiWzBdKVxuICAgICAgfSwge1xuICAgICAgICBpOiBpIC0gMixcbiAgICAgICAgeDogZDNfaW50ZXJwb2xhdGVOdW1iZXIoa2FbMV0sIGtiWzFdKVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChrYlswXSAhPT0gMSB8fCBrYlsxXSAhPT0gMSkge1xuICAgICAgcy5wdXNoKGQzX2ludGVycG9sYXRlVHJhbnNmb3JtUG9wKHMpICsgXCJzY2FsZShcIiArIGtiICsgXCIpXCIpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBkM19pbnRlcnBvbGF0ZVRyYW5zZm9ybShhLCBiKSB7XG4gICAgdmFyIHMgPSBbXSwgcSA9IFtdO1xuICAgIGEgPSBkMy50cmFuc2Zvcm0oYSksIGIgPSBkMy50cmFuc2Zvcm0oYik7XG4gICAgZDNfaW50ZXJwb2xhdGVUcmFuc2xhdGUoYS50cmFuc2xhdGUsIGIudHJhbnNsYXRlLCBzLCBxKTtcbiAgICBkM19pbnRlcnBvbGF0ZVJvdGF0ZShhLnJvdGF0ZSwgYi5yb3RhdGUsIHMsIHEpO1xuICAgIGQzX2ludGVycG9sYXRlU2tldyhhLnNrZXcsIGIuc2tldywgcywgcSk7XG4gICAgZDNfaW50ZXJwb2xhdGVTY2FsZShhLnNjYWxlLCBiLnNjYWxlLCBzLCBxKTtcbiAgICBhID0gYiA9IG51bGw7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgIHZhciBpID0gLTEsIG4gPSBxLmxlbmd0aCwgbztcbiAgICAgIHdoaWxlICgrK2kgPCBuKSBzWyhvID0gcVtpXSkuaV0gPSBvLngodCk7XG4gICAgICByZXR1cm4gcy5qb2luKFwiXCIpO1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gZDNfdW5pbnRlcnBvbGF0ZU51bWJlcihhLCBiKSB7XG4gICAgYiA9IChiIC09IGEgPSArYSkgfHwgMSAvIGI7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiAoeCAtIGEpIC8gYjtcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGQzX3VuaW50ZXJwb2xhdGVDbGFtcChhLCBiKSB7XG4gICAgYiA9IChiIC09IGEgPSArYSkgfHwgMSAvIGI7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCAoeCAtIGEpIC8gYikpO1xuICAgIH07XG4gIH1cbiAgZDMubGF5b3V0ID0ge307XG4gIGQzLmxheW91dC5idW5kbGUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24obGlua3MpIHtcbiAgICAgIHZhciBwYXRocyA9IFtdLCBpID0gLTEsIG4gPSBsaW5rcy5sZW5ndGg7XG4gICAgICB3aGlsZSAoKytpIDwgbikgcGF0aHMucHVzaChkM19sYXlvdXRfYnVuZGxlUGF0aChsaW5rc1tpXSkpO1xuICAgICAgcmV0dXJuIHBhdGhzO1xuICAgIH07XG4gIH07XG4gIGZ1bmN0aW9uIGQzX2xheW91dF9idW5kbGVQYXRoKGxpbmspIHtcbiAgICB2YXIgc3RhcnQgPSBsaW5rLnNvdXJjZSwgZW5kID0gbGluay50YXJnZXQsIGxjYSA9IGQzX2xheW91dF9idW5kbGVMZWFzdENvbW1vbkFuY2VzdG9yKHN0YXJ0LCBlbmQpLCBwb2ludHMgPSBbIHN0YXJ0IF07XG4gICAgd2hpbGUgKHN0YXJ0ICE9PSBsY2EpIHtcbiAgICAgIHN0YXJ0ID0gc3RhcnQucGFyZW50O1xuICAgICAgcG9pbnRzLnB1c2goc3RhcnQpO1xuICAgIH1cbiAgICB2YXIgayA9IHBvaW50cy5sZW5ndGg7XG4gICAgd2hpbGUgKGVuZCAhPT0gbGNhKSB7XG4gICAgICBwb2ludHMuc3BsaWNlKGssIDAsIGVuZCk7XG4gICAgICBlbmQgPSBlbmQucGFyZW50O1xuICAgIH1cbiAgICByZXR1cm4gcG9pbnRzO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2xheW91dF9idW5kbGVBbmNlc3RvcnMobm9kZSkge1xuICAgIHZhciBhbmNlc3RvcnMgPSBbXSwgcGFyZW50ID0gbm9kZS5wYXJlbnQ7XG4gICAgd2hpbGUgKHBhcmVudCAhPSBudWxsKSB7XG4gICAgICBhbmNlc3RvcnMucHVzaChub2RlKTtcbiAgICAgIG5vZGUgPSBwYXJlbnQ7XG4gICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICAgIH1cbiAgICBhbmNlc3RvcnMucHVzaChub2RlKTtcbiAgICByZXR1cm4gYW5jZXN0b3JzO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2xheW91dF9idW5kbGVMZWFzdENvbW1vbkFuY2VzdG9yKGEsIGIpIHtcbiAgICBpZiAoYSA9PT0gYikgcmV0dXJuIGE7XG4gICAgdmFyIGFOb2RlcyA9IGQzX2xheW91dF9idW5kbGVBbmNlc3RvcnMoYSksIGJOb2RlcyA9IGQzX2xheW91dF9idW5kbGVBbmNlc3RvcnMoYiksIGFOb2RlID0gYU5vZGVzLnBvcCgpLCBiTm9kZSA9IGJOb2Rlcy5wb3AoKSwgc2hhcmVkTm9kZSA9IG51bGw7XG4gICAgd2hpbGUgKGFOb2RlID09PSBiTm9kZSkge1xuICAgICAgc2hhcmVkTm9kZSA9IGFOb2RlO1xuICAgICAgYU5vZGUgPSBhTm9kZXMucG9wKCk7XG4gICAgICBiTm9kZSA9IGJOb2Rlcy5wb3AoKTtcbiAgICB9XG4gICAgcmV0dXJuIHNoYXJlZE5vZGU7XG4gIH1cbiAgZDMubGF5b3V0LmNob3JkID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGNob3JkID0ge30sIGNob3JkcywgZ3JvdXBzLCBtYXRyaXgsIG4sIHBhZGRpbmcgPSAwLCBzb3J0R3JvdXBzLCBzb3J0U3ViZ3JvdXBzLCBzb3J0Q2hvcmRzO1xuICAgIGZ1bmN0aW9uIHJlbGF5b3V0KCkge1xuICAgICAgdmFyIHN1Ymdyb3VwcyA9IHt9LCBncm91cFN1bXMgPSBbXSwgZ3JvdXBJbmRleCA9IGQzLnJhbmdlKG4pLCBzdWJncm91cEluZGV4ID0gW10sIGssIHgsIHgwLCBpLCBqO1xuICAgICAgY2hvcmRzID0gW107XG4gICAgICBncm91cHMgPSBbXTtcbiAgICAgIGsgPSAwLCBpID0gLTE7XG4gICAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICB4ID0gMCwgaiA9IC0xO1xuICAgICAgICB3aGlsZSAoKytqIDwgbikge1xuICAgICAgICAgIHggKz0gbWF0cml4W2ldW2pdO1xuICAgICAgICB9XG4gICAgICAgIGdyb3VwU3Vtcy5wdXNoKHgpO1xuICAgICAgICBzdWJncm91cEluZGV4LnB1c2goZDMucmFuZ2UobikpO1xuICAgICAgICBrICs9IHg7XG4gICAgICB9XG4gICAgICBpZiAoc29ydEdyb3Vwcykge1xuICAgICAgICBncm91cEluZGV4LnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgICAgIHJldHVybiBzb3J0R3JvdXBzKGdyb3VwU3Vtc1thXSwgZ3JvdXBTdW1zW2JdKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoc29ydFN1Ymdyb3Vwcykge1xuICAgICAgICBzdWJncm91cEluZGV4LmZvckVhY2goZnVuY3Rpb24oZCwgaSkge1xuICAgICAgICAgIGQuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gc29ydFN1Ymdyb3VwcyhtYXRyaXhbaV1bYV0sIG1hdHJpeFtpXVtiXSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgayA9ICjPhCAtIHBhZGRpbmcgKiBuKSAvIGs7XG4gICAgICB4ID0gMCwgaSA9IC0xO1xuICAgICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgeDAgPSB4LCBqID0gLTE7XG4gICAgICAgIHdoaWxlICgrK2ogPCBuKSB7XG4gICAgICAgICAgdmFyIGRpID0gZ3JvdXBJbmRleFtpXSwgZGogPSBzdWJncm91cEluZGV4W2RpXVtqXSwgdiA9IG1hdHJpeFtkaV1bZGpdLCBhMCA9IHgsIGExID0geCArPSB2ICogaztcbiAgICAgICAgICBzdWJncm91cHNbZGkgKyBcIi1cIiArIGRqXSA9IHtcbiAgICAgICAgICAgIGluZGV4OiBkaSxcbiAgICAgICAgICAgIHN1YmluZGV4OiBkaixcbiAgICAgICAgICAgIHN0YXJ0QW5nbGU6IGEwLFxuICAgICAgICAgICAgZW5kQW5nbGU6IGExLFxuICAgICAgICAgICAgdmFsdWU6IHZcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGdyb3Vwc1tkaV0gPSB7XG4gICAgICAgICAgaW5kZXg6IGRpLFxuICAgICAgICAgIHN0YXJ0QW5nbGU6IHgwLFxuICAgICAgICAgIGVuZEFuZ2xlOiB4LFxuICAgICAgICAgIHZhbHVlOiBncm91cFN1bXNbZGldXG4gICAgICAgIH07XG4gICAgICAgIHggKz0gcGFkZGluZztcbiAgICAgIH1cbiAgICAgIGkgPSAtMTtcbiAgICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgIGogPSBpIC0gMTtcbiAgICAgICAgd2hpbGUgKCsraiA8IG4pIHtcbiAgICAgICAgICB2YXIgc291cmNlID0gc3ViZ3JvdXBzW2kgKyBcIi1cIiArIGpdLCB0YXJnZXQgPSBzdWJncm91cHNbaiArIFwiLVwiICsgaV07XG4gICAgICAgICAgaWYgKHNvdXJjZS52YWx1ZSB8fCB0YXJnZXQudmFsdWUpIHtcbiAgICAgICAgICAgIGNob3Jkcy5wdXNoKHNvdXJjZS52YWx1ZSA8IHRhcmdldC52YWx1ZSA/IHtcbiAgICAgICAgICAgICAgc291cmNlOiB0YXJnZXQsXG4gICAgICAgICAgICAgIHRhcmdldDogc291cmNlXG4gICAgICAgICAgICB9IDoge1xuICAgICAgICAgICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgICAgICAgICAgdGFyZ2V0OiB0YXJnZXRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHNvcnRDaG9yZHMpIHJlc29ydCgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXNvcnQoKSB7XG4gICAgICBjaG9yZHMuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgIHJldHVybiBzb3J0Q2hvcmRzKChhLnNvdXJjZS52YWx1ZSArIGEudGFyZ2V0LnZhbHVlKSAvIDIsIChiLnNvdXJjZS52YWx1ZSArIGIudGFyZ2V0LnZhbHVlKSAvIDIpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGNob3JkLm1hdHJpeCA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG1hdHJpeDtcbiAgICAgIG4gPSAobWF0cml4ID0geCkgJiYgbWF0cml4Lmxlbmd0aDtcbiAgICAgIGNob3JkcyA9IGdyb3VwcyA9IG51bGw7XG4gICAgICByZXR1cm4gY2hvcmQ7XG4gICAgfTtcbiAgICBjaG9yZC5wYWRkaW5nID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gcGFkZGluZztcbiAgICAgIHBhZGRpbmcgPSB4O1xuICAgICAgY2hvcmRzID0gZ3JvdXBzID0gbnVsbDtcbiAgICAgIHJldHVybiBjaG9yZDtcbiAgICB9O1xuICAgIGNob3JkLnNvcnRHcm91cHMgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBzb3J0R3JvdXBzO1xuICAgICAgc29ydEdyb3VwcyA9IHg7XG4gICAgICBjaG9yZHMgPSBncm91cHMgPSBudWxsO1xuICAgICAgcmV0dXJuIGNob3JkO1xuICAgIH07XG4gICAgY2hvcmQuc29ydFN1Ymdyb3VwcyA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHNvcnRTdWJncm91cHM7XG4gICAgICBzb3J0U3ViZ3JvdXBzID0geDtcbiAgICAgIGNob3JkcyA9IG51bGw7XG4gICAgICByZXR1cm4gY2hvcmQ7XG4gICAgfTtcbiAgICBjaG9yZC5zb3J0Q2hvcmRzID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc29ydENob3JkcztcbiAgICAgIHNvcnRDaG9yZHMgPSB4O1xuICAgICAgaWYgKGNob3JkcykgcmVzb3J0KCk7XG4gICAgICByZXR1cm4gY2hvcmQ7XG4gICAgfTtcbiAgICBjaG9yZC5jaG9yZHMgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghY2hvcmRzKSByZWxheW91dCgpO1xuICAgICAgcmV0dXJuIGNob3JkcztcbiAgICB9O1xuICAgIGNob3JkLmdyb3VwcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCFncm91cHMpIHJlbGF5b3V0KCk7XG4gICAgICByZXR1cm4gZ3JvdXBzO1xuICAgIH07XG4gICAgcmV0dXJuIGNob3JkO1xuICB9O1xuICBkMy5sYXlvdXQuZm9yY2UgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZm9yY2UgPSB7fSwgZXZlbnQgPSBkMy5kaXNwYXRjaChcInN0YXJ0XCIsIFwidGlja1wiLCBcImVuZFwiKSwgdGltZXIsIHNpemUgPSBbIDEsIDEgXSwgZHJhZywgYWxwaGEsIGZyaWN0aW9uID0gLjksIGxpbmtEaXN0YW5jZSA9IGQzX2xheW91dF9mb3JjZUxpbmtEaXN0YW5jZSwgbGlua1N0cmVuZ3RoID0gZDNfbGF5b3V0X2ZvcmNlTGlua1N0cmVuZ3RoLCBjaGFyZ2UgPSAtMzAsIGNoYXJnZURpc3RhbmNlMiA9IGQzX2xheW91dF9mb3JjZUNoYXJnZURpc3RhbmNlMiwgZ3Jhdml0eSA9IC4xLCB0aGV0YTIgPSAuNjQsIG5vZGVzID0gW10sIGxpbmtzID0gW10sIGRpc3RhbmNlcywgc3RyZW5ndGhzLCBjaGFyZ2VzO1xuICAgIGZ1bmN0aW9uIHJlcHVsc2Uobm9kZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHF1YWQsIHgxLCBfLCB4Mikge1xuICAgICAgICBpZiAocXVhZC5wb2ludCAhPT0gbm9kZSkge1xuICAgICAgICAgIHZhciBkeCA9IHF1YWQuY3ggLSBub2RlLngsIGR5ID0gcXVhZC5jeSAtIG5vZGUueSwgZHcgPSB4MiAtIHgxLCBkbiA9IGR4ICogZHggKyBkeSAqIGR5O1xuICAgICAgICAgIGlmIChkdyAqIGR3IC8gdGhldGEyIDwgZG4pIHtcbiAgICAgICAgICAgIGlmIChkbiA8IGNoYXJnZURpc3RhbmNlMikge1xuICAgICAgICAgICAgICB2YXIgayA9IHF1YWQuY2hhcmdlIC8gZG47XG4gICAgICAgICAgICAgIG5vZGUucHggLT0gZHggKiBrO1xuICAgICAgICAgICAgICBub2RlLnB5IC09IGR5ICogaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocXVhZC5wb2ludCAmJiBkbiAmJiBkbiA8IGNoYXJnZURpc3RhbmNlMikge1xuICAgICAgICAgICAgdmFyIGsgPSBxdWFkLnBvaW50Q2hhcmdlIC8gZG47XG4gICAgICAgICAgICBub2RlLnB4IC09IGR4ICogaztcbiAgICAgICAgICAgIG5vZGUucHkgLT0gZHkgKiBrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gIXF1YWQuY2hhcmdlO1xuICAgICAgfTtcbiAgICB9XG4gICAgZm9yY2UudGljayA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKChhbHBoYSAqPSAuOTkpIDwgLjAwNSkge1xuICAgICAgICB0aW1lciA9IG51bGw7XG4gICAgICAgIGV2ZW50LmVuZCh7XG4gICAgICAgICAgdHlwZTogXCJlbmRcIixcbiAgICAgICAgICBhbHBoYTogYWxwaGEgPSAwXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHZhciBuID0gbm9kZXMubGVuZ3RoLCBtID0gbGlua3MubGVuZ3RoLCBxLCBpLCBvLCBzLCB0LCBsLCBrLCB4LCB5O1xuICAgICAgZm9yIChpID0gMDsgaSA8IG07ICsraSkge1xuICAgICAgICBvID0gbGlua3NbaV07XG4gICAgICAgIHMgPSBvLnNvdXJjZTtcbiAgICAgICAgdCA9IG8udGFyZ2V0O1xuICAgICAgICB4ID0gdC54IC0gcy54O1xuICAgICAgICB5ID0gdC55IC0gcy55O1xuICAgICAgICBpZiAobCA9IHggKiB4ICsgeSAqIHkpIHtcbiAgICAgICAgICBsID0gYWxwaGEgKiBzdHJlbmd0aHNbaV0gKiAoKGwgPSBNYXRoLnNxcnQobCkpIC0gZGlzdGFuY2VzW2ldKSAvIGw7XG4gICAgICAgICAgeCAqPSBsO1xuICAgICAgICAgIHkgKj0gbDtcbiAgICAgICAgICB0LnggLT0geCAqIChrID0gcy53ZWlnaHQgKyB0LndlaWdodCA/IHMud2VpZ2h0IC8gKHMud2VpZ2h0ICsgdC53ZWlnaHQpIDogLjUpO1xuICAgICAgICAgIHQueSAtPSB5ICogaztcbiAgICAgICAgICBzLnggKz0geCAqIChrID0gMSAtIGspO1xuICAgICAgICAgIHMueSArPSB5ICogaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGsgPSBhbHBoYSAqIGdyYXZpdHkpIHtcbiAgICAgICAgeCA9IHNpemVbMF0gLyAyO1xuICAgICAgICB5ID0gc2l6ZVsxXSAvIDI7XG4gICAgICAgIGkgPSAtMTtcbiAgICAgICAgaWYgKGspIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgICAgbyA9IG5vZGVzW2ldO1xuICAgICAgICAgIG8ueCArPSAoeCAtIG8ueCkgKiBrO1xuICAgICAgICAgIG8ueSArPSAoeSAtIG8ueSkgKiBrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoY2hhcmdlKSB7XG4gICAgICAgIGQzX2xheW91dF9mb3JjZUFjY3VtdWxhdGUocSA9IGQzLmdlb20ucXVhZHRyZWUobm9kZXMpLCBhbHBoYSwgY2hhcmdlcyk7XG4gICAgICAgIGkgPSAtMTtcbiAgICAgICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgICBpZiAoIShvID0gbm9kZXNbaV0pLmZpeGVkKSB7XG4gICAgICAgICAgICBxLnZpc2l0KHJlcHVsc2UobykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaSA9IC0xO1xuICAgICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgbyA9IG5vZGVzW2ldO1xuICAgICAgICBpZiAoby5maXhlZCkge1xuICAgICAgICAgIG8ueCA9IG8ucHg7XG4gICAgICAgICAgby55ID0gby5weTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvLnggLT0gKG8ucHggLSAoby5weCA9IG8ueCkpICogZnJpY3Rpb247XG4gICAgICAgICAgby55IC09IChvLnB5IC0gKG8ucHkgPSBvLnkpKSAqIGZyaWN0aW9uO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBldmVudC50aWNrKHtcbiAgICAgICAgdHlwZTogXCJ0aWNrXCIsXG4gICAgICAgIGFscGhhOiBhbHBoYVxuICAgICAgfSk7XG4gICAgfTtcbiAgICBmb3JjZS5ub2RlcyA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG5vZGVzO1xuICAgICAgbm9kZXMgPSB4O1xuICAgICAgcmV0dXJuIGZvcmNlO1xuICAgIH07XG4gICAgZm9yY2UubGlua3MgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBsaW5rcztcbiAgICAgIGxpbmtzID0geDtcbiAgICAgIHJldHVybiBmb3JjZTtcbiAgICB9O1xuICAgIGZvcmNlLnNpemUgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBzaXplO1xuICAgICAgc2l6ZSA9IHg7XG4gICAgICByZXR1cm4gZm9yY2U7XG4gICAgfTtcbiAgICBmb3JjZS5saW5rRGlzdGFuY2UgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBsaW5rRGlzdGFuY2U7XG4gICAgICBsaW5rRGlzdGFuY2UgPSB0eXBlb2YgeCA9PT0gXCJmdW5jdGlvblwiID8geCA6ICt4O1xuICAgICAgcmV0dXJuIGZvcmNlO1xuICAgIH07XG4gICAgZm9yY2UuZGlzdGFuY2UgPSBmb3JjZS5saW5rRGlzdGFuY2U7XG4gICAgZm9yY2UubGlua1N0cmVuZ3RoID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gbGlua1N0cmVuZ3RoO1xuICAgICAgbGlua1N0cmVuZ3RoID0gdHlwZW9mIHggPT09IFwiZnVuY3Rpb25cIiA/IHggOiAreDtcbiAgICAgIHJldHVybiBmb3JjZTtcbiAgICB9O1xuICAgIGZvcmNlLmZyaWN0aW9uID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZnJpY3Rpb247XG4gICAgICBmcmljdGlvbiA9ICt4O1xuICAgICAgcmV0dXJuIGZvcmNlO1xuICAgIH07XG4gICAgZm9yY2UuY2hhcmdlID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gY2hhcmdlO1xuICAgICAgY2hhcmdlID0gdHlwZW9mIHggPT09IFwiZnVuY3Rpb25cIiA/IHggOiAreDtcbiAgICAgIHJldHVybiBmb3JjZTtcbiAgICB9O1xuICAgIGZvcmNlLmNoYXJnZURpc3RhbmNlID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gTWF0aC5zcXJ0KGNoYXJnZURpc3RhbmNlMik7XG4gICAgICBjaGFyZ2VEaXN0YW5jZTIgPSB4ICogeDtcbiAgICAgIHJldHVybiBmb3JjZTtcbiAgICB9O1xuICAgIGZvcmNlLmdyYXZpdHkgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBncmF2aXR5O1xuICAgICAgZ3Jhdml0eSA9ICt4O1xuICAgICAgcmV0dXJuIGZvcmNlO1xuICAgIH07XG4gICAgZm9yY2UudGhldGEgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBNYXRoLnNxcnQodGhldGEyKTtcbiAgICAgIHRoZXRhMiA9IHggKiB4O1xuICAgICAgcmV0dXJuIGZvcmNlO1xuICAgIH07XG4gICAgZm9yY2UuYWxwaGEgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBhbHBoYTtcbiAgICAgIHggPSAreDtcbiAgICAgIGlmIChhbHBoYSkge1xuICAgICAgICBpZiAoeCA+IDApIHtcbiAgICAgICAgICBhbHBoYSA9IHg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGltZXIuYyA9IG51bGwsIHRpbWVyLnQgPSBOYU4sIHRpbWVyID0gbnVsbDtcbiAgICAgICAgICBldmVudC5lbmQoe1xuICAgICAgICAgICAgdHlwZTogXCJlbmRcIixcbiAgICAgICAgICAgIGFscGhhOiBhbHBoYSA9IDBcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh4ID4gMCkge1xuICAgICAgICBldmVudC5zdGFydCh7XG4gICAgICAgICAgdHlwZTogXCJzdGFydFwiLFxuICAgICAgICAgIGFscGhhOiBhbHBoYSA9IHhcbiAgICAgICAgfSk7XG4gICAgICAgIHRpbWVyID0gZDNfdGltZXIoZm9yY2UudGljayk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZm9yY2U7XG4gICAgfTtcbiAgICBmb3JjZS5zdGFydCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGksIG4gPSBub2Rlcy5sZW5ndGgsIG0gPSBsaW5rcy5sZW5ndGgsIHcgPSBzaXplWzBdLCBoID0gc2l6ZVsxXSwgbmVpZ2hib3JzLCBvO1xuICAgICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICAobyA9IG5vZGVzW2ldKS5pbmRleCA9IGk7XG4gICAgICAgIG8ud2VpZ2h0ID0gMDtcbiAgICAgIH1cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBtOyArK2kpIHtcbiAgICAgICAgbyA9IGxpbmtzW2ldO1xuICAgICAgICBpZiAodHlwZW9mIG8uc291cmNlID09IFwibnVtYmVyXCIpIG8uc291cmNlID0gbm9kZXNbby5zb3VyY2VdO1xuICAgICAgICBpZiAodHlwZW9mIG8udGFyZ2V0ID09IFwibnVtYmVyXCIpIG8udGFyZ2V0ID0gbm9kZXNbby50YXJnZXRdO1xuICAgICAgICArK28uc291cmNlLndlaWdodDtcbiAgICAgICAgKytvLnRhcmdldC53ZWlnaHQ7XG4gICAgICB9XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIG8gPSBub2Rlc1tpXTtcbiAgICAgICAgaWYgKGlzTmFOKG8ueCkpIG8ueCA9IHBvc2l0aW9uKFwieFwiLCB3KTtcbiAgICAgICAgaWYgKGlzTmFOKG8ueSkpIG8ueSA9IHBvc2l0aW9uKFwieVwiLCBoKTtcbiAgICAgICAgaWYgKGlzTmFOKG8ucHgpKSBvLnB4ID0gby54O1xuICAgICAgICBpZiAoaXNOYU4oby5weSkpIG8ucHkgPSBvLnk7XG4gICAgICB9XG4gICAgICBkaXN0YW5jZXMgPSBbXTtcbiAgICAgIGlmICh0eXBlb2YgbGlua0Rpc3RhbmNlID09PSBcImZ1bmN0aW9uXCIpIGZvciAoaSA9IDA7IGkgPCBtOyArK2kpIGRpc3RhbmNlc1tpXSA9ICtsaW5rRGlzdGFuY2UuY2FsbCh0aGlzLCBsaW5rc1tpXSwgaSk7IGVsc2UgZm9yIChpID0gMDsgaSA8IG07ICsraSkgZGlzdGFuY2VzW2ldID0gbGlua0Rpc3RhbmNlO1xuICAgICAgc3RyZW5ndGhzID0gW107XG4gICAgICBpZiAodHlwZW9mIGxpbmtTdHJlbmd0aCA9PT0gXCJmdW5jdGlvblwiKSBmb3IgKGkgPSAwOyBpIDwgbTsgKytpKSBzdHJlbmd0aHNbaV0gPSArbGlua1N0cmVuZ3RoLmNhbGwodGhpcywgbGlua3NbaV0sIGkpOyBlbHNlIGZvciAoaSA9IDA7IGkgPCBtOyArK2kpIHN0cmVuZ3Roc1tpXSA9IGxpbmtTdHJlbmd0aDtcbiAgICAgIGNoYXJnZXMgPSBbXTtcbiAgICAgIGlmICh0eXBlb2YgY2hhcmdlID09PSBcImZ1bmN0aW9uXCIpIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIGNoYXJnZXNbaV0gPSArY2hhcmdlLmNhbGwodGhpcywgbm9kZXNbaV0sIGkpOyBlbHNlIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIGNoYXJnZXNbaV0gPSBjaGFyZ2U7XG4gICAgICBmdW5jdGlvbiBwb3NpdGlvbihkaW1lbnNpb24sIHNpemUpIHtcbiAgICAgICAgaWYgKCFuZWlnaGJvcnMpIHtcbiAgICAgICAgICBuZWlnaGJvcnMgPSBuZXcgQXJyYXkobik7XG4gICAgICAgICAgZm9yIChqID0gMDsgaiA8IG47ICsraikge1xuICAgICAgICAgICAgbmVpZ2hib3JzW2pdID0gW107XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICAgICAgICAgIHZhciBvID0gbGlua3Nbal07XG4gICAgICAgICAgICBuZWlnaGJvcnNbby5zb3VyY2UuaW5kZXhdLnB1c2goby50YXJnZXQpO1xuICAgICAgICAgICAgbmVpZ2hib3JzW28udGFyZ2V0LmluZGV4XS5wdXNoKG8uc291cmNlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNhbmRpZGF0ZXMgPSBuZWlnaGJvcnNbaV0sIGogPSAtMSwgbCA9IGNhbmRpZGF0ZXMubGVuZ3RoLCB4O1xuICAgICAgICB3aGlsZSAoKytqIDwgbCkgaWYgKCFpc05hTih4ID0gY2FuZGlkYXRlc1tqXVtkaW1lbnNpb25dKSkgcmV0dXJuIHg7XG4gICAgICAgIHJldHVybiBNYXRoLnJhbmRvbSgpICogc2l6ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmb3JjZS5yZXN1bWUoKTtcbiAgICB9O1xuICAgIGZvcmNlLnJlc3VtZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGZvcmNlLmFscGhhKC4xKTtcbiAgICB9O1xuICAgIGZvcmNlLnN0b3AgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBmb3JjZS5hbHBoYSgwKTtcbiAgICB9O1xuICAgIGZvcmNlLmRyYWcgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghZHJhZykgZHJhZyA9IGQzLmJlaGF2aW9yLmRyYWcoKS5vcmlnaW4oZDNfaWRlbnRpdHkpLm9uKFwiZHJhZ3N0YXJ0LmZvcmNlXCIsIGQzX2xheW91dF9mb3JjZURyYWdzdGFydCkub24oXCJkcmFnLmZvcmNlXCIsIGRyYWdtb3ZlKS5vbihcImRyYWdlbmQuZm9yY2VcIiwgZDNfbGF5b3V0X2ZvcmNlRHJhZ2VuZCk7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBkcmFnO1xuICAgICAgdGhpcy5vbihcIm1vdXNlb3Zlci5mb3JjZVwiLCBkM19sYXlvdXRfZm9yY2VNb3VzZW92ZXIpLm9uKFwibW91c2VvdXQuZm9yY2VcIiwgZDNfbGF5b3V0X2ZvcmNlTW91c2VvdXQpLmNhbGwoZHJhZyk7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBkcmFnbW92ZShkKSB7XG4gICAgICBkLnB4ID0gZDMuZXZlbnQueCwgZC5weSA9IGQzLmV2ZW50Lnk7XG4gICAgICBmb3JjZS5yZXN1bWUoKTtcbiAgICB9XG4gICAgcmV0dXJuIGQzLnJlYmluZChmb3JjZSwgZXZlbnQsIFwib25cIik7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX2xheW91dF9mb3JjZURyYWdzdGFydChkKSB7XG4gICAgZC5maXhlZCB8PSAyO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2xheW91dF9mb3JjZURyYWdlbmQoZCkge1xuICAgIGQuZml4ZWQgJj0gfjY7XG4gIH1cbiAgZnVuY3Rpb24gZDNfbGF5b3V0X2ZvcmNlTW91c2VvdmVyKGQpIHtcbiAgICBkLmZpeGVkIHw9IDQ7XG4gICAgZC5weCA9IGQueCwgZC5weSA9IGQueTtcbiAgfVxuICBmdW5jdGlvbiBkM19sYXlvdXRfZm9yY2VNb3VzZW91dChkKSB7XG4gICAgZC5maXhlZCAmPSB+NDtcbiAgfVxuICBmdW5jdGlvbiBkM19sYXlvdXRfZm9yY2VBY2N1bXVsYXRlKHF1YWQsIGFscGhhLCBjaGFyZ2VzKSB7XG4gICAgdmFyIGN4ID0gMCwgY3kgPSAwO1xuICAgIHF1YWQuY2hhcmdlID0gMDtcbiAgICBpZiAoIXF1YWQubGVhZikge1xuICAgICAgdmFyIG5vZGVzID0gcXVhZC5ub2RlcywgbiA9IG5vZGVzLmxlbmd0aCwgaSA9IC0xLCBjO1xuICAgICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgYyA9IG5vZGVzW2ldO1xuICAgICAgICBpZiAoYyA9PSBudWxsKSBjb250aW51ZTtcbiAgICAgICAgZDNfbGF5b3V0X2ZvcmNlQWNjdW11bGF0ZShjLCBhbHBoYSwgY2hhcmdlcyk7XG4gICAgICAgIHF1YWQuY2hhcmdlICs9IGMuY2hhcmdlO1xuICAgICAgICBjeCArPSBjLmNoYXJnZSAqIGMuY3g7XG4gICAgICAgIGN5ICs9IGMuY2hhcmdlICogYy5jeTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHF1YWQucG9pbnQpIHtcbiAgICAgIGlmICghcXVhZC5sZWFmKSB7XG4gICAgICAgIHF1YWQucG9pbnQueCArPSBNYXRoLnJhbmRvbSgpIC0gLjU7XG4gICAgICAgIHF1YWQucG9pbnQueSArPSBNYXRoLnJhbmRvbSgpIC0gLjU7XG4gICAgICB9XG4gICAgICB2YXIgayA9IGFscGhhICogY2hhcmdlc1txdWFkLnBvaW50LmluZGV4XTtcbiAgICAgIHF1YWQuY2hhcmdlICs9IHF1YWQucG9pbnRDaGFyZ2UgPSBrO1xuICAgICAgY3ggKz0gayAqIHF1YWQucG9pbnQueDtcbiAgICAgIGN5ICs9IGsgKiBxdWFkLnBvaW50Lnk7XG4gICAgfVxuICAgIHF1YWQuY3ggPSBjeCAvIHF1YWQuY2hhcmdlO1xuICAgIHF1YWQuY3kgPSBjeSAvIHF1YWQuY2hhcmdlO1xuICB9XG4gIHZhciBkM19sYXlvdXRfZm9yY2VMaW5rRGlzdGFuY2UgPSAyMCwgZDNfbGF5b3V0X2ZvcmNlTGlua1N0cmVuZ3RoID0gMSwgZDNfbGF5b3V0X2ZvcmNlQ2hhcmdlRGlzdGFuY2UyID0gSW5maW5pdHk7XG4gIGQzLmxheW91dC5oaWVyYXJjaHkgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgc29ydCA9IGQzX2xheW91dF9oaWVyYXJjaHlTb3J0LCBjaGlsZHJlbiA9IGQzX2xheW91dF9oaWVyYXJjaHlDaGlsZHJlbiwgdmFsdWUgPSBkM19sYXlvdXRfaGllcmFyY2h5VmFsdWU7XG4gICAgZnVuY3Rpb24gaGllcmFyY2h5KHJvb3QpIHtcbiAgICAgIHZhciBzdGFjayA9IFsgcm9vdCBdLCBub2RlcyA9IFtdLCBub2RlO1xuICAgICAgcm9vdC5kZXB0aCA9IDA7XG4gICAgICB3aGlsZSAoKG5vZGUgPSBzdGFjay5wb3AoKSkgIT0gbnVsbCkge1xuICAgICAgICBub2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgICBpZiAoKGNoaWxkcyA9IGNoaWxkcmVuLmNhbGwoaGllcmFyY2h5LCBub2RlLCBub2RlLmRlcHRoKSkgJiYgKG4gPSBjaGlsZHMubGVuZ3RoKSkge1xuICAgICAgICAgIHZhciBuLCBjaGlsZHMsIGNoaWxkO1xuICAgICAgICAgIHdoaWxlICgtLW4gPj0gMCkge1xuICAgICAgICAgICAgc3RhY2sucHVzaChjaGlsZCA9IGNoaWxkc1tuXSk7XG4gICAgICAgICAgICBjaGlsZC5wYXJlbnQgPSBub2RlO1xuICAgICAgICAgICAgY2hpbGQuZGVwdGggPSBub2RlLmRlcHRoICsgMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHZhbHVlKSBub2RlLnZhbHVlID0gMDtcbiAgICAgICAgICBub2RlLmNoaWxkcmVuID0gY2hpbGRzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh2YWx1ZSkgbm9kZS52YWx1ZSA9ICt2YWx1ZS5jYWxsKGhpZXJhcmNoeSwgbm9kZSwgbm9kZS5kZXB0aCkgfHwgMDtcbiAgICAgICAgICBkZWxldGUgbm9kZS5jaGlsZHJlbjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZDNfbGF5b3V0X2hpZXJhcmNoeVZpc2l0QWZ0ZXIocm9vdCwgZnVuY3Rpb24obm9kZSkge1xuICAgICAgICB2YXIgY2hpbGRzLCBwYXJlbnQ7XG4gICAgICAgIGlmIChzb3J0ICYmIChjaGlsZHMgPSBub2RlLmNoaWxkcmVuKSkgY2hpbGRzLnNvcnQoc29ydCk7XG4gICAgICAgIGlmICh2YWx1ZSAmJiAocGFyZW50ID0gbm9kZS5wYXJlbnQpKSBwYXJlbnQudmFsdWUgKz0gbm9kZS52YWx1ZTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG5vZGVzO1xuICAgIH1cbiAgICBoaWVyYXJjaHkuc29ydCA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHNvcnQ7XG4gICAgICBzb3J0ID0geDtcbiAgICAgIHJldHVybiBoaWVyYXJjaHk7XG4gICAgfTtcbiAgICBoaWVyYXJjaHkuY2hpbGRyZW4gPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBjaGlsZHJlbjtcbiAgICAgIGNoaWxkcmVuID0geDtcbiAgICAgIHJldHVybiBoaWVyYXJjaHk7XG4gICAgfTtcbiAgICBoaWVyYXJjaHkudmFsdWUgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB2YWx1ZTtcbiAgICAgIHZhbHVlID0geDtcbiAgICAgIHJldHVybiBoaWVyYXJjaHk7XG4gICAgfTtcbiAgICBoaWVyYXJjaHkucmV2YWx1ZSA9IGZ1bmN0aW9uKHJvb3QpIHtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICBkM19sYXlvdXRfaGllcmFyY2h5VmlzaXRCZWZvcmUocm9vdCwgZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgIGlmIChub2RlLmNoaWxkcmVuKSBub2RlLnZhbHVlID0gMDtcbiAgICAgICAgfSk7XG4gICAgICAgIGQzX2xheW91dF9oaWVyYXJjaHlWaXNpdEFmdGVyKHJvb3QsIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICB2YXIgcGFyZW50O1xuICAgICAgICAgIGlmICghbm9kZS5jaGlsZHJlbikgbm9kZS52YWx1ZSA9ICt2YWx1ZS5jYWxsKGhpZXJhcmNoeSwgbm9kZSwgbm9kZS5kZXB0aCkgfHwgMDtcbiAgICAgICAgICBpZiAocGFyZW50ID0gbm9kZS5wYXJlbnQpIHBhcmVudC52YWx1ZSArPSBub2RlLnZhbHVlO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByb290O1xuICAgIH07XG4gICAgcmV0dXJuIGhpZXJhcmNoeTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfbGF5b3V0X2hpZXJhcmNoeVJlYmluZChvYmplY3QsIGhpZXJhcmNoeSkge1xuICAgIGQzLnJlYmluZChvYmplY3QsIGhpZXJhcmNoeSwgXCJzb3J0XCIsIFwiY2hpbGRyZW5cIiwgXCJ2YWx1ZVwiKTtcbiAgICBvYmplY3Qubm9kZXMgPSBvYmplY3Q7XG4gICAgb2JqZWN0LmxpbmtzID0gZDNfbGF5b3V0X2hpZXJhcmNoeUxpbmtzO1xuICAgIHJldHVybiBvYmplY3Q7XG4gIH1cbiAgZnVuY3Rpb24gZDNfbGF5b3V0X2hpZXJhcmNoeVZpc2l0QmVmb3JlKG5vZGUsIGNhbGxiYWNrKSB7XG4gICAgdmFyIG5vZGVzID0gWyBub2RlIF07XG4gICAgd2hpbGUgKChub2RlID0gbm9kZXMucG9wKCkpICE9IG51bGwpIHtcbiAgICAgIGNhbGxiYWNrKG5vZGUpO1xuICAgICAgaWYgKChjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW4pICYmIChuID0gY2hpbGRyZW4ubGVuZ3RoKSkge1xuICAgICAgICB2YXIgbiwgY2hpbGRyZW47XG4gICAgICAgIHdoaWxlICgtLW4gPj0gMCkgbm9kZXMucHVzaChjaGlsZHJlbltuXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGQzX2xheW91dF9oaWVyYXJjaHlWaXNpdEFmdGVyKG5vZGUsIGNhbGxiYWNrKSB7XG4gICAgdmFyIG5vZGVzID0gWyBub2RlIF0sIG5vZGVzMiA9IFtdO1xuICAgIHdoaWxlICgobm9kZSA9IG5vZGVzLnBvcCgpKSAhPSBudWxsKSB7XG4gICAgICBub2RlczIucHVzaChub2RlKTtcbiAgICAgIGlmICgoY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuKSAmJiAobiA9IGNoaWxkcmVuLmxlbmd0aCkpIHtcbiAgICAgICAgdmFyIGkgPSAtMSwgbiwgY2hpbGRyZW47XG4gICAgICAgIHdoaWxlICgrK2kgPCBuKSBub2Rlcy5wdXNoKGNoaWxkcmVuW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgd2hpbGUgKChub2RlID0gbm9kZXMyLnBvcCgpKSAhPSBudWxsKSB7XG4gICAgICBjYWxsYmFjayhub2RlKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZDNfbGF5b3V0X2hpZXJhcmNoeUNoaWxkcmVuKGQpIHtcbiAgICByZXR1cm4gZC5jaGlsZHJlbjtcbiAgfVxuICBmdW5jdGlvbiBkM19sYXlvdXRfaGllcmFyY2h5VmFsdWUoZCkge1xuICAgIHJldHVybiBkLnZhbHVlO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2xheW91dF9oaWVyYXJjaHlTb3J0KGEsIGIpIHtcbiAgICByZXR1cm4gYi52YWx1ZSAtIGEudmFsdWU7XG4gIH1cbiAgZnVuY3Rpb24gZDNfbGF5b3V0X2hpZXJhcmNoeUxpbmtzKG5vZGVzKSB7XG4gICAgcmV0dXJuIGQzLm1lcmdlKG5vZGVzLm1hcChmdW5jdGlvbihwYXJlbnQpIHtcbiAgICAgIHJldHVybiAocGFyZW50LmNoaWxkcmVuIHx8IFtdKS5tYXAoZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzb3VyY2U6IHBhcmVudCxcbiAgICAgICAgICB0YXJnZXQ6IGNoaWxkXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9KSk7XG4gIH1cbiAgZDMubGF5b3V0LnBhcnRpdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBoaWVyYXJjaHkgPSBkMy5sYXlvdXQuaGllcmFyY2h5KCksIHNpemUgPSBbIDEsIDEgXTtcbiAgICBmdW5jdGlvbiBwb3NpdGlvbihub2RlLCB4LCBkeCwgZHkpIHtcbiAgICAgIHZhciBjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW47XG4gICAgICBub2RlLnggPSB4O1xuICAgICAgbm9kZS55ID0gbm9kZS5kZXB0aCAqIGR5O1xuICAgICAgbm9kZS5keCA9IGR4O1xuICAgICAgbm9kZS5keSA9IGR5O1xuICAgICAgaWYgKGNoaWxkcmVuICYmIChuID0gY2hpbGRyZW4ubGVuZ3RoKSkge1xuICAgICAgICB2YXIgaSA9IC0xLCBuLCBjLCBkO1xuICAgICAgICBkeCA9IG5vZGUudmFsdWUgPyBkeCAvIG5vZGUudmFsdWUgOiAwO1xuICAgICAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICAgIHBvc2l0aW9uKGMgPSBjaGlsZHJlbltpXSwgeCwgZCA9IGMudmFsdWUgKiBkeCwgZHkpO1xuICAgICAgICAgIHggKz0gZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBkZXB0aChub2RlKSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuLCBkID0gMDtcbiAgICAgIGlmIChjaGlsZHJlbiAmJiAobiA9IGNoaWxkcmVuLmxlbmd0aCkpIHtcbiAgICAgICAgdmFyIGkgPSAtMSwgbjtcbiAgICAgICAgd2hpbGUgKCsraSA8IG4pIGQgPSBNYXRoLm1heChkLCBkZXB0aChjaGlsZHJlbltpXSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIDEgKyBkO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwYXJ0aXRpb24oZCwgaSkge1xuICAgICAgdmFyIG5vZGVzID0gaGllcmFyY2h5LmNhbGwodGhpcywgZCwgaSk7XG4gICAgICBwb3NpdGlvbihub2Rlc1swXSwgMCwgc2l6ZVswXSwgc2l6ZVsxXSAvIGRlcHRoKG5vZGVzWzBdKSk7XG4gICAgICByZXR1cm4gbm9kZXM7XG4gICAgfVxuICAgIHBhcnRpdGlvbi5zaXplID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc2l6ZTtcbiAgICAgIHNpemUgPSB4O1xuICAgICAgcmV0dXJuIHBhcnRpdGlvbjtcbiAgICB9O1xuICAgIHJldHVybiBkM19sYXlvdXRfaGllcmFyY2h5UmViaW5kKHBhcnRpdGlvbiwgaGllcmFyY2h5KTtcbiAgfTtcbiAgZDMubGF5b3V0LnBpZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB2YWx1ZSA9IE51bWJlciwgc29ydCA9IGQzX2xheW91dF9waWVTb3J0QnlWYWx1ZSwgc3RhcnRBbmdsZSA9IDAsIGVuZEFuZ2xlID0gz4QsIHBhZEFuZ2xlID0gMDtcbiAgICBmdW5jdGlvbiBwaWUoZGF0YSkge1xuICAgICAgdmFyIG4gPSBkYXRhLmxlbmd0aCwgdmFsdWVzID0gZGF0YS5tYXAoZnVuY3Rpb24oZCwgaSkge1xuICAgICAgICByZXR1cm4gK3ZhbHVlLmNhbGwocGllLCBkLCBpKTtcbiAgICAgIH0pLCBhID0gKyh0eXBlb2Ygc3RhcnRBbmdsZSA9PT0gXCJmdW5jdGlvblwiID8gc3RhcnRBbmdsZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDogc3RhcnRBbmdsZSksIGRhID0gKHR5cGVvZiBlbmRBbmdsZSA9PT0gXCJmdW5jdGlvblwiID8gZW5kQW5nbGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSA6IGVuZEFuZ2xlKSAtIGEsIHAgPSBNYXRoLm1pbihNYXRoLmFicyhkYSkgLyBuLCArKHR5cGVvZiBwYWRBbmdsZSA9PT0gXCJmdW5jdGlvblwiID8gcGFkQW5nbGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSA6IHBhZEFuZ2xlKSksIHBhID0gcCAqIChkYSA8IDAgPyAtMSA6IDEpLCBzdW0gPSBkMy5zdW0odmFsdWVzKSwgayA9IHN1bSA/IChkYSAtIG4gKiBwYSkgLyBzdW0gOiAwLCBpbmRleCA9IGQzLnJhbmdlKG4pLCBhcmNzID0gW10sIHY7XG4gICAgICBpZiAoc29ydCAhPSBudWxsKSBpbmRleC5zb3J0KHNvcnQgPT09IGQzX2xheW91dF9waWVTb3J0QnlWYWx1ZSA/IGZ1bmN0aW9uKGksIGopIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlc1tqXSAtIHZhbHVlc1tpXTtcbiAgICAgIH0gOiBmdW5jdGlvbihpLCBqKSB7XG4gICAgICAgIHJldHVybiBzb3J0KGRhdGFbaV0sIGRhdGFbal0pO1xuICAgICAgfSk7XG4gICAgICBpbmRleC5mb3JFYWNoKGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgYXJjc1tpXSA9IHtcbiAgICAgICAgICBkYXRhOiBkYXRhW2ldLFxuICAgICAgICAgIHZhbHVlOiB2ID0gdmFsdWVzW2ldLFxuICAgICAgICAgIHN0YXJ0QW5nbGU6IGEsXG4gICAgICAgICAgZW5kQW5nbGU6IGEgKz0gdiAqIGsgKyBwYSxcbiAgICAgICAgICBwYWRBbmdsZTogcFxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gYXJjcztcbiAgICB9XG4gICAgcGllLnZhbHVlID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdmFsdWU7XG4gICAgICB2YWx1ZSA9IF87XG4gICAgICByZXR1cm4gcGllO1xuICAgIH07XG4gICAgcGllLnNvcnQgPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBzb3J0O1xuICAgICAgc29ydCA9IF87XG4gICAgICByZXR1cm4gcGllO1xuICAgIH07XG4gICAgcGllLnN0YXJ0QW5nbGUgPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBzdGFydEFuZ2xlO1xuICAgICAgc3RhcnRBbmdsZSA9IF87XG4gICAgICByZXR1cm4gcGllO1xuICAgIH07XG4gICAgcGllLmVuZEFuZ2xlID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZW5kQW5nbGU7XG4gICAgICBlbmRBbmdsZSA9IF87XG4gICAgICByZXR1cm4gcGllO1xuICAgIH07XG4gICAgcGllLnBhZEFuZ2xlID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gcGFkQW5nbGU7XG4gICAgICBwYWRBbmdsZSA9IF87XG4gICAgICByZXR1cm4gcGllO1xuICAgIH07XG4gICAgcmV0dXJuIHBpZTtcbiAgfTtcbiAgdmFyIGQzX2xheW91dF9waWVTb3J0QnlWYWx1ZSA9IHt9O1xuICBkMy5sYXlvdXQuc3RhY2sgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdmFsdWVzID0gZDNfaWRlbnRpdHksIG9yZGVyID0gZDNfbGF5b3V0X3N0YWNrT3JkZXJEZWZhdWx0LCBvZmZzZXQgPSBkM19sYXlvdXRfc3RhY2tPZmZzZXRaZXJvLCBvdXQgPSBkM19sYXlvdXRfc3RhY2tPdXQsIHggPSBkM19sYXlvdXRfc3RhY2tYLCB5ID0gZDNfbGF5b3V0X3N0YWNrWTtcbiAgICBmdW5jdGlvbiBzdGFjayhkYXRhLCBpbmRleCkge1xuICAgICAgaWYgKCEobiA9IGRhdGEubGVuZ3RoKSkgcmV0dXJuIGRhdGE7XG4gICAgICB2YXIgc2VyaWVzID0gZGF0YS5tYXAoZnVuY3Rpb24oZCwgaSkge1xuICAgICAgICByZXR1cm4gdmFsdWVzLmNhbGwoc3RhY2ssIGQsIGkpO1xuICAgICAgfSk7XG4gICAgICB2YXIgcG9pbnRzID0gc2VyaWVzLm1hcChmdW5jdGlvbihkKSB7XG4gICAgICAgIHJldHVybiBkLm1hcChmdW5jdGlvbih2LCBpKSB7XG4gICAgICAgICAgcmV0dXJuIFsgeC5jYWxsKHN0YWNrLCB2LCBpKSwgeS5jYWxsKHN0YWNrLCB2LCBpKSBdO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgdmFyIG9yZGVycyA9IG9yZGVyLmNhbGwoc3RhY2ssIHBvaW50cywgaW5kZXgpO1xuICAgICAgc2VyaWVzID0gZDMucGVybXV0ZShzZXJpZXMsIG9yZGVycyk7XG4gICAgICBwb2ludHMgPSBkMy5wZXJtdXRlKHBvaW50cywgb3JkZXJzKTtcbiAgICAgIHZhciBvZmZzZXRzID0gb2Zmc2V0LmNhbGwoc3RhY2ssIHBvaW50cywgaW5kZXgpO1xuICAgICAgdmFyIG0gPSBzZXJpZXNbMF0ubGVuZ3RoLCBuLCBpLCBqLCBvO1xuICAgICAgZm9yIChqID0gMDsgaiA8IG07ICsraikge1xuICAgICAgICBvdXQuY2FsbChzdGFjaywgc2VyaWVzWzBdW2pdLCBvID0gb2Zmc2V0c1tqXSwgcG9pbnRzWzBdW2pdWzFdKTtcbiAgICAgICAgZm9yIChpID0gMTsgaSA8IG47ICsraSkge1xuICAgICAgICAgIG91dC5jYWxsKHN0YWNrLCBzZXJpZXNbaV1bal0sIG8gKz0gcG9pbnRzW2kgLSAxXVtqXVsxXSwgcG9pbnRzW2ldW2pdWzFdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIHN0YWNrLnZhbHVlcyA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHZhbHVlcztcbiAgICAgIHZhbHVlcyA9IHg7XG4gICAgICByZXR1cm4gc3RhY2s7XG4gICAgfTtcbiAgICBzdGFjay5vcmRlciA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG9yZGVyO1xuICAgICAgb3JkZXIgPSB0eXBlb2YgeCA9PT0gXCJmdW5jdGlvblwiID8geCA6IGQzX2xheW91dF9zdGFja09yZGVycy5nZXQoeCkgfHwgZDNfbGF5b3V0X3N0YWNrT3JkZXJEZWZhdWx0O1xuICAgICAgcmV0dXJuIHN0YWNrO1xuICAgIH07XG4gICAgc3RhY2sub2Zmc2V0ID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gb2Zmc2V0O1xuICAgICAgb2Zmc2V0ID0gdHlwZW9mIHggPT09IFwiZnVuY3Rpb25cIiA/IHggOiBkM19sYXlvdXRfc3RhY2tPZmZzZXRzLmdldCh4KSB8fCBkM19sYXlvdXRfc3RhY2tPZmZzZXRaZXJvO1xuICAgICAgcmV0dXJuIHN0YWNrO1xuICAgIH07XG4gICAgc3RhY2sueCA9IGZ1bmN0aW9uKHopIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHg7XG4gICAgICB4ID0gejtcbiAgICAgIHJldHVybiBzdGFjaztcbiAgICB9O1xuICAgIHN0YWNrLnkgPSBmdW5jdGlvbih6KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB5O1xuICAgICAgeSA9IHo7XG4gICAgICByZXR1cm4gc3RhY2s7XG4gICAgfTtcbiAgICBzdGFjay5vdXQgPSBmdW5jdGlvbih6KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBvdXQ7XG4gICAgICBvdXQgPSB6O1xuICAgICAgcmV0dXJuIHN0YWNrO1xuICAgIH07XG4gICAgcmV0dXJuIHN0YWNrO1xuICB9O1xuICBmdW5jdGlvbiBkM19sYXlvdXRfc3RhY2tYKGQpIHtcbiAgICByZXR1cm4gZC54O1xuICB9XG4gIGZ1bmN0aW9uIGQzX2xheW91dF9zdGFja1koZCkge1xuICAgIHJldHVybiBkLnk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfbGF5b3V0X3N0YWNrT3V0KGQsIHkwLCB5KSB7XG4gICAgZC55MCA9IHkwO1xuICAgIGQueSA9IHk7XG4gIH1cbiAgdmFyIGQzX2xheW91dF9zdGFja09yZGVycyA9IGQzLm1hcCh7XG4gICAgXCJpbnNpZGUtb3V0XCI6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgIHZhciBuID0gZGF0YS5sZW5ndGgsIGksIGosIG1heCA9IGRhdGEubWFwKGQzX2xheW91dF9zdGFja01heEluZGV4KSwgc3VtcyA9IGRhdGEubWFwKGQzX2xheW91dF9zdGFja1JlZHVjZVN1bSksIGluZGV4ID0gZDMucmFuZ2Uobikuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgIHJldHVybiBtYXhbYV0gLSBtYXhbYl07XG4gICAgICB9KSwgdG9wID0gMCwgYm90dG9tID0gMCwgdG9wcyA9IFtdLCBib3R0b21zID0gW107XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIGogPSBpbmRleFtpXTtcbiAgICAgICAgaWYgKHRvcCA8IGJvdHRvbSkge1xuICAgICAgICAgIHRvcCArPSBzdW1zW2pdO1xuICAgICAgICAgIHRvcHMucHVzaChqKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBib3R0b20gKz0gc3Vtc1tqXTtcbiAgICAgICAgICBib3R0b21zLnB1c2goaik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBib3R0b21zLnJldmVyc2UoKS5jb25jYXQodG9wcyk7XG4gICAgfSxcbiAgICByZXZlcnNlOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICByZXR1cm4gZDMucmFuZ2UoZGF0YS5sZW5ndGgpLnJldmVyc2UoKTtcbiAgICB9LFxuICAgIFwiZGVmYXVsdFwiOiBkM19sYXlvdXRfc3RhY2tPcmRlckRlZmF1bHRcbiAgfSk7XG4gIHZhciBkM19sYXlvdXRfc3RhY2tPZmZzZXRzID0gZDMubWFwKHtcbiAgICBzaWxob3VldHRlOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICB2YXIgbiA9IGRhdGEubGVuZ3RoLCBtID0gZGF0YVswXS5sZW5ndGgsIHN1bXMgPSBbXSwgbWF4ID0gMCwgaSwgaiwgbywgeTAgPSBbXTtcbiAgICAgIGZvciAoaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICAgICAgZm9yIChpID0gMCwgbyA9IDA7IGkgPCBuOyBpKyspIG8gKz0gZGF0YVtpXVtqXVsxXTtcbiAgICAgICAgaWYgKG8gPiBtYXgpIG1heCA9IG87XG4gICAgICAgIHN1bXMucHVzaChvKTtcbiAgICAgIH1cbiAgICAgIGZvciAoaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICAgICAgeTBbal0gPSAobWF4IC0gc3Vtc1tqXSkgLyAyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHkwO1xuICAgIH0sXG4gICAgd2lnZ2xlOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICB2YXIgbiA9IGRhdGEubGVuZ3RoLCB4ID0gZGF0YVswXSwgbSA9IHgubGVuZ3RoLCBpLCBqLCBrLCBzMSwgczIsIHMzLCBkeCwgbywgbzAsIHkwID0gW107XG4gICAgICB5MFswXSA9IG8gPSBvMCA9IDA7XG4gICAgICBmb3IgKGogPSAxOyBqIDwgbTsgKytqKSB7XG4gICAgICAgIGZvciAoaSA9IDAsIHMxID0gMDsgaSA8IG47ICsraSkgczEgKz0gZGF0YVtpXVtqXVsxXTtcbiAgICAgICAgZm9yIChpID0gMCwgczIgPSAwLCBkeCA9IHhbal1bMF0gLSB4W2ogLSAxXVswXTsgaSA8IG47ICsraSkge1xuICAgICAgICAgIGZvciAoayA9IDAsIHMzID0gKGRhdGFbaV1bal1bMV0gLSBkYXRhW2ldW2ogLSAxXVsxXSkgLyAoMiAqIGR4KTsgayA8IGk7ICsraykge1xuICAgICAgICAgICAgczMgKz0gKGRhdGFba11bal1bMV0gLSBkYXRhW2tdW2ogLSAxXVsxXSkgLyBkeDtcbiAgICAgICAgICB9XG4gICAgICAgICAgczIgKz0gczMgKiBkYXRhW2ldW2pdWzFdO1xuICAgICAgICB9XG4gICAgICAgIHkwW2pdID0gbyAtPSBzMSA/IHMyIC8gczEgKiBkeCA6IDA7XG4gICAgICAgIGlmIChvIDwgbzApIG8wID0gbztcbiAgICAgIH1cbiAgICAgIGZvciAoaiA9IDA7IGogPCBtOyArK2opIHkwW2pdIC09IG8wO1xuICAgICAgcmV0dXJuIHkwO1xuICAgIH0sXG4gICAgZXhwYW5kOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICB2YXIgbiA9IGRhdGEubGVuZ3RoLCBtID0gZGF0YVswXS5sZW5ndGgsIGsgPSAxIC8gbiwgaSwgaiwgbywgeTAgPSBbXTtcbiAgICAgIGZvciAoaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICAgICAgZm9yIChpID0gMCwgbyA9IDA7IGkgPCBuOyBpKyspIG8gKz0gZGF0YVtpXVtqXVsxXTtcbiAgICAgICAgaWYgKG8pIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIGRhdGFbaV1bal1bMV0gLz0gbzsgZWxzZSBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSBkYXRhW2ldW2pdWzFdID0gaztcbiAgICAgIH1cbiAgICAgIGZvciAoaiA9IDA7IGogPCBtOyArK2opIHkwW2pdID0gMDtcbiAgICAgIHJldHVybiB5MDtcbiAgICB9LFxuICAgIHplcm86IGQzX2xheW91dF9zdGFja09mZnNldFplcm9cbiAgfSk7XG4gIGZ1bmN0aW9uIGQzX2xheW91dF9zdGFja09yZGVyRGVmYXVsdChkYXRhKSB7XG4gICAgcmV0dXJuIGQzLnJhbmdlKGRhdGEubGVuZ3RoKTtcbiAgfVxuICBmdW5jdGlvbiBkM19sYXlvdXRfc3RhY2tPZmZzZXRaZXJvKGRhdGEpIHtcbiAgICB2YXIgaiA9IC0xLCBtID0gZGF0YVswXS5sZW5ndGgsIHkwID0gW107XG4gICAgd2hpbGUgKCsraiA8IG0pIHkwW2pdID0gMDtcbiAgICByZXR1cm4geTA7XG4gIH1cbiAgZnVuY3Rpb24gZDNfbGF5b3V0X3N0YWNrTWF4SW5kZXgoYXJyYXkpIHtcbiAgICB2YXIgaSA9IDEsIGogPSAwLCB2ID0gYXJyYXlbMF1bMV0sIGssIG4gPSBhcnJheS5sZW5ndGg7XG4gICAgZm9yICg7aSA8IG47ICsraSkge1xuICAgICAgaWYgKChrID0gYXJyYXlbaV1bMV0pID4gdikge1xuICAgICAgICBqID0gaTtcbiAgICAgICAgdiA9IGs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBqO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2xheW91dF9zdGFja1JlZHVjZVN1bShkKSB7XG4gICAgcmV0dXJuIGQucmVkdWNlKGQzX2xheW91dF9zdGFja1N1bSwgMCk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfbGF5b3V0X3N0YWNrU3VtKHAsIGQpIHtcbiAgICByZXR1cm4gcCArIGRbMV07XG4gIH1cbiAgZDMubGF5b3V0Lmhpc3RvZ3JhbSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBmcmVxdWVuY3kgPSB0cnVlLCB2YWx1ZXIgPSBOdW1iZXIsIHJhbmdlciA9IGQzX2xheW91dF9oaXN0b2dyYW1SYW5nZSwgYmlubmVyID0gZDNfbGF5b3V0X2hpc3RvZ3JhbUJpblN0dXJnZXM7XG4gICAgZnVuY3Rpb24gaGlzdG9ncmFtKGRhdGEsIGkpIHtcbiAgICAgIHZhciBiaW5zID0gW10sIHZhbHVlcyA9IGRhdGEubWFwKHZhbHVlciwgdGhpcyksIHJhbmdlID0gcmFuZ2VyLmNhbGwodGhpcywgdmFsdWVzLCBpKSwgdGhyZXNob2xkcyA9IGJpbm5lci5jYWxsKHRoaXMsIHJhbmdlLCB2YWx1ZXMsIGkpLCBiaW4sIGkgPSAtMSwgbiA9IHZhbHVlcy5sZW5ndGgsIG0gPSB0aHJlc2hvbGRzLmxlbmd0aCAtIDEsIGsgPSBmcmVxdWVuY3kgPyAxIDogMSAvIG4sIHg7XG4gICAgICB3aGlsZSAoKytpIDwgbSkge1xuICAgICAgICBiaW4gPSBiaW5zW2ldID0gW107XG4gICAgICAgIGJpbi5keCA9IHRocmVzaG9sZHNbaSArIDFdIC0gKGJpbi54ID0gdGhyZXNob2xkc1tpXSk7XG4gICAgICAgIGJpbi55ID0gMDtcbiAgICAgIH1cbiAgICAgIGlmIChtID4gMCkge1xuICAgICAgICBpID0gLTE7XG4gICAgICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgICAgeCA9IHZhbHVlc1tpXTtcbiAgICAgICAgICBpZiAoeCA+PSByYW5nZVswXSAmJiB4IDw9IHJhbmdlWzFdKSB7XG4gICAgICAgICAgICBiaW4gPSBiaW5zW2QzLmJpc2VjdCh0aHJlc2hvbGRzLCB4LCAxLCBtKSAtIDFdO1xuICAgICAgICAgICAgYmluLnkgKz0gaztcbiAgICAgICAgICAgIGJpbi5wdXNoKGRhdGFbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGJpbnM7XG4gICAgfVxuICAgIGhpc3RvZ3JhbS52YWx1ZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHZhbHVlcjtcbiAgICAgIHZhbHVlciA9IHg7XG4gICAgICByZXR1cm4gaGlzdG9ncmFtO1xuICAgIH07XG4gICAgaGlzdG9ncmFtLnJhbmdlID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gcmFuZ2VyO1xuICAgICAgcmFuZ2VyID0gZDNfZnVuY3Rvcih4KTtcbiAgICAgIHJldHVybiBoaXN0b2dyYW07XG4gICAgfTtcbiAgICBoaXN0b2dyYW0uYmlucyA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGJpbm5lcjtcbiAgICAgIGJpbm5lciA9IHR5cGVvZiB4ID09PSBcIm51bWJlclwiID8gZnVuY3Rpb24ocmFuZ2UpIHtcbiAgICAgICAgcmV0dXJuIGQzX2xheW91dF9oaXN0b2dyYW1CaW5GaXhlZChyYW5nZSwgeCk7XG4gICAgICB9IDogZDNfZnVuY3Rvcih4KTtcbiAgICAgIHJldHVybiBoaXN0b2dyYW07XG4gICAgfTtcbiAgICBoaXN0b2dyYW0uZnJlcXVlbmN5ID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZnJlcXVlbmN5O1xuICAgICAgZnJlcXVlbmN5ID0gISF4O1xuICAgICAgcmV0dXJuIGhpc3RvZ3JhbTtcbiAgICB9O1xuICAgIHJldHVybiBoaXN0b2dyYW07XG4gIH07XG4gIGZ1bmN0aW9uIGQzX2xheW91dF9oaXN0b2dyYW1CaW5TdHVyZ2VzKHJhbmdlLCB2YWx1ZXMpIHtcbiAgICByZXR1cm4gZDNfbGF5b3V0X2hpc3RvZ3JhbUJpbkZpeGVkKHJhbmdlLCBNYXRoLmNlaWwoTWF0aC5sb2codmFsdWVzLmxlbmd0aCkgLyBNYXRoLkxOMiArIDEpKTtcbiAgfVxuICBmdW5jdGlvbiBkM19sYXlvdXRfaGlzdG9ncmFtQmluRml4ZWQocmFuZ2UsIG4pIHtcbiAgICB2YXIgeCA9IC0xLCBiID0gK3JhbmdlWzBdLCBtID0gKHJhbmdlWzFdIC0gYikgLyBuLCBmID0gW107XG4gICAgd2hpbGUgKCsreCA8PSBuKSBmW3hdID0gbSAqIHggKyBiO1xuICAgIHJldHVybiBmO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2xheW91dF9oaXN0b2dyYW1SYW5nZSh2YWx1ZXMpIHtcbiAgICByZXR1cm4gWyBkMy5taW4odmFsdWVzKSwgZDMubWF4KHZhbHVlcykgXTtcbiAgfVxuICBkMy5sYXlvdXQucGFjayA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBoaWVyYXJjaHkgPSBkMy5sYXlvdXQuaGllcmFyY2h5KCkuc29ydChkM19sYXlvdXRfcGFja1NvcnQpLCBwYWRkaW5nID0gMCwgc2l6ZSA9IFsgMSwgMSBdLCByYWRpdXM7XG4gICAgZnVuY3Rpb24gcGFjayhkLCBpKSB7XG4gICAgICB2YXIgbm9kZXMgPSBoaWVyYXJjaHkuY2FsbCh0aGlzLCBkLCBpKSwgcm9vdCA9IG5vZGVzWzBdLCB3ID0gc2l6ZVswXSwgaCA9IHNpemVbMV0sIHIgPSByYWRpdXMgPT0gbnVsbCA/IE1hdGguc3FydCA6IHR5cGVvZiByYWRpdXMgPT09IFwiZnVuY3Rpb25cIiA/IHJhZGl1cyA6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gcmFkaXVzO1xuICAgICAgfTtcbiAgICAgIHJvb3QueCA9IHJvb3QueSA9IDA7XG4gICAgICBkM19sYXlvdXRfaGllcmFyY2h5VmlzaXRBZnRlcihyb290LCBmdW5jdGlvbihkKSB7XG4gICAgICAgIGQuciA9ICtyKGQudmFsdWUpO1xuICAgICAgfSk7XG4gICAgICBkM19sYXlvdXRfaGllcmFyY2h5VmlzaXRBZnRlcihyb290LCBkM19sYXlvdXRfcGFja1NpYmxpbmdzKTtcbiAgICAgIGlmIChwYWRkaW5nKSB7XG4gICAgICAgIHZhciBkciA9IHBhZGRpbmcgKiAocmFkaXVzID8gMSA6IE1hdGgubWF4KDIgKiByb290LnIgLyB3LCAyICogcm9vdC5yIC8gaCkpIC8gMjtcbiAgICAgICAgZDNfbGF5b3V0X2hpZXJhcmNoeVZpc2l0QWZ0ZXIocm9vdCwgZnVuY3Rpb24oZCkge1xuICAgICAgICAgIGQuciArPSBkcjtcbiAgICAgICAgfSk7XG4gICAgICAgIGQzX2xheW91dF9oaWVyYXJjaHlWaXNpdEFmdGVyKHJvb3QsIGQzX2xheW91dF9wYWNrU2libGluZ3MpO1xuICAgICAgICBkM19sYXlvdXRfaGllcmFyY2h5VmlzaXRBZnRlcihyb290LCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgZC5yIC09IGRyO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGQzX2xheW91dF9wYWNrVHJhbnNmb3JtKHJvb3QsIHcgLyAyLCBoIC8gMiwgcmFkaXVzID8gMSA6IDEgLyBNYXRoLm1heCgyICogcm9vdC5yIC8gdywgMiAqIHJvb3QuciAvIGgpKTtcbiAgICAgIHJldHVybiBub2RlcztcbiAgICB9XG4gICAgcGFjay5zaXplID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc2l6ZTtcbiAgICAgIHNpemUgPSBfO1xuICAgICAgcmV0dXJuIHBhY2s7XG4gICAgfTtcbiAgICBwYWNrLnJhZGl1cyA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHJhZGl1cztcbiAgICAgIHJhZGl1cyA9IF8gPT0gbnVsbCB8fCB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6ICtfO1xuICAgICAgcmV0dXJuIHBhY2s7XG4gICAgfTtcbiAgICBwYWNrLnBhZGRpbmcgPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBwYWRkaW5nO1xuICAgICAgcGFkZGluZyA9ICtfO1xuICAgICAgcmV0dXJuIHBhY2s7XG4gICAgfTtcbiAgICByZXR1cm4gZDNfbGF5b3V0X2hpZXJhcmNoeVJlYmluZChwYWNrLCBoaWVyYXJjaHkpO1xuICB9O1xuICBmdW5jdGlvbiBkM19sYXlvdXRfcGFja1NvcnQoYSwgYikge1xuICAgIHJldHVybiBhLnZhbHVlIC0gYi52YWx1ZTtcbiAgfVxuICBmdW5jdGlvbiBkM19sYXlvdXRfcGFja0luc2VydChhLCBiKSB7XG4gICAgdmFyIGMgPSBhLl9wYWNrX25leHQ7XG4gICAgYS5fcGFja19uZXh0ID0gYjtcbiAgICBiLl9wYWNrX3ByZXYgPSBhO1xuICAgIGIuX3BhY2tfbmV4dCA9IGM7XG4gICAgYy5fcGFja19wcmV2ID0gYjtcbiAgfVxuICBmdW5jdGlvbiBkM19sYXlvdXRfcGFja1NwbGljZShhLCBiKSB7XG4gICAgYS5fcGFja19uZXh0ID0gYjtcbiAgICBiLl9wYWNrX3ByZXYgPSBhO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2xheW91dF9wYWNrSW50ZXJzZWN0cyhhLCBiKSB7XG4gICAgdmFyIGR4ID0gYi54IC0gYS54LCBkeSA9IGIueSAtIGEueSwgZHIgPSBhLnIgKyBiLnI7XG4gICAgcmV0dXJuIC45OTkgKiBkciAqIGRyID4gZHggKiBkeCArIGR5ICogZHk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfbGF5b3V0X3BhY2tTaWJsaW5ncyhub2RlKSB7XG4gICAgaWYgKCEobm9kZXMgPSBub2RlLmNoaWxkcmVuKSB8fCAhKG4gPSBub2Rlcy5sZW5ndGgpKSByZXR1cm47XG4gICAgdmFyIG5vZGVzLCB4TWluID0gSW5maW5pdHksIHhNYXggPSAtSW5maW5pdHksIHlNaW4gPSBJbmZpbml0eSwgeU1heCA9IC1JbmZpbml0eSwgYSwgYiwgYywgaSwgaiwgaywgbjtcbiAgICBmdW5jdGlvbiBib3VuZChub2RlKSB7XG4gICAgICB4TWluID0gTWF0aC5taW4obm9kZS54IC0gbm9kZS5yLCB4TWluKTtcbiAgICAgIHhNYXggPSBNYXRoLm1heChub2RlLnggKyBub2RlLnIsIHhNYXgpO1xuICAgICAgeU1pbiA9IE1hdGgubWluKG5vZGUueSAtIG5vZGUuciwgeU1pbik7XG4gICAgICB5TWF4ID0gTWF0aC5tYXgobm9kZS55ICsgbm9kZS5yLCB5TWF4KTtcbiAgICB9XG4gICAgbm9kZXMuZm9yRWFjaChkM19sYXlvdXRfcGFja0xpbmspO1xuICAgIGEgPSBub2Rlc1swXTtcbiAgICBhLnggPSAtYS5yO1xuICAgIGEueSA9IDA7XG4gICAgYm91bmQoYSk7XG4gICAgaWYgKG4gPiAxKSB7XG4gICAgICBiID0gbm9kZXNbMV07XG4gICAgICBiLnggPSBiLnI7XG4gICAgICBiLnkgPSAwO1xuICAgICAgYm91bmQoYik7XG4gICAgICBpZiAobiA+IDIpIHtcbiAgICAgICAgYyA9IG5vZGVzWzJdO1xuICAgICAgICBkM19sYXlvdXRfcGFja1BsYWNlKGEsIGIsIGMpO1xuICAgICAgICBib3VuZChjKTtcbiAgICAgICAgZDNfbGF5b3V0X3BhY2tJbnNlcnQoYSwgYyk7XG4gICAgICAgIGEuX3BhY2tfcHJldiA9IGM7XG4gICAgICAgIGQzX2xheW91dF9wYWNrSW5zZXJ0KGMsIGIpO1xuICAgICAgICBiID0gYS5fcGFja19uZXh0O1xuICAgICAgICBmb3IgKGkgPSAzOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgZDNfbGF5b3V0X3BhY2tQbGFjZShhLCBiLCBjID0gbm9kZXNbaV0pO1xuICAgICAgICAgIHZhciBpc2VjdCA9IDAsIHMxID0gMSwgczIgPSAxO1xuICAgICAgICAgIGZvciAoaiA9IGIuX3BhY2tfbmV4dDsgaiAhPT0gYjsgaiA9IGouX3BhY2tfbmV4dCwgczErKykge1xuICAgICAgICAgICAgaWYgKGQzX2xheW91dF9wYWNrSW50ZXJzZWN0cyhqLCBjKSkge1xuICAgICAgICAgICAgICBpc2VjdCA9IDE7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNlY3QgPT0gMSkge1xuICAgICAgICAgICAgZm9yIChrID0gYS5fcGFja19wcmV2OyBrICE9PSBqLl9wYWNrX3ByZXY7IGsgPSBrLl9wYWNrX3ByZXYsIHMyKyspIHtcbiAgICAgICAgICAgICAgaWYgKGQzX2xheW91dF9wYWNrSW50ZXJzZWN0cyhrLCBjKSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc2VjdCkge1xuICAgICAgICAgICAgaWYgKHMxIDwgczIgfHwgczEgPT0gczIgJiYgYi5yIDwgYS5yKSBkM19sYXlvdXRfcGFja1NwbGljZShhLCBiID0gaik7IGVsc2UgZDNfbGF5b3V0X3BhY2tTcGxpY2UoYSA9IGssIGIpO1xuICAgICAgICAgICAgaS0tO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkM19sYXlvdXRfcGFja0luc2VydChhLCBjKTtcbiAgICAgICAgICAgIGIgPSBjO1xuICAgICAgICAgICAgYm91bmQoYyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBjeCA9ICh4TWluICsgeE1heCkgLyAyLCBjeSA9ICh5TWluICsgeU1heCkgLyAyLCBjciA9IDA7XG4gICAgZm9yIChpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgYyA9IG5vZGVzW2ldO1xuICAgICAgYy54IC09IGN4O1xuICAgICAgYy55IC09IGN5O1xuICAgICAgY3IgPSBNYXRoLm1heChjciwgYy5yICsgTWF0aC5zcXJ0KGMueCAqIGMueCArIGMueSAqIGMueSkpO1xuICAgIH1cbiAgICBub2RlLnIgPSBjcjtcbiAgICBub2Rlcy5mb3JFYWNoKGQzX2xheW91dF9wYWNrVW5saW5rKTtcbiAgfVxuICBmdW5jdGlvbiBkM19sYXlvdXRfcGFja0xpbmsobm9kZSkge1xuICAgIG5vZGUuX3BhY2tfbmV4dCA9IG5vZGUuX3BhY2tfcHJldiA9IG5vZGU7XG4gIH1cbiAgZnVuY3Rpb24gZDNfbGF5b3V0X3BhY2tVbmxpbmsobm9kZSkge1xuICAgIGRlbGV0ZSBub2RlLl9wYWNrX25leHQ7XG4gICAgZGVsZXRlIG5vZGUuX3BhY2tfcHJldjtcbiAgfVxuICBmdW5jdGlvbiBkM19sYXlvdXRfcGFja1RyYW5zZm9ybShub2RlLCB4LCB5LCBrKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbjtcbiAgICBub2RlLnggPSB4ICs9IGsgKiBub2RlLng7XG4gICAgbm9kZS55ID0geSArPSBrICogbm9kZS55O1xuICAgIG5vZGUuciAqPSBrO1xuICAgIGlmIChjaGlsZHJlbikge1xuICAgICAgdmFyIGkgPSAtMSwgbiA9IGNoaWxkcmVuLmxlbmd0aDtcbiAgICAgIHdoaWxlICgrK2kgPCBuKSBkM19sYXlvdXRfcGFja1RyYW5zZm9ybShjaGlsZHJlbltpXSwgeCwgeSwgayk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGQzX2xheW91dF9wYWNrUGxhY2UoYSwgYiwgYykge1xuICAgIHZhciBkYiA9IGEuciArIGMuciwgZHggPSBiLnggLSBhLngsIGR5ID0gYi55IC0gYS55O1xuICAgIGlmIChkYiAmJiAoZHggfHwgZHkpKSB7XG4gICAgICB2YXIgZGEgPSBiLnIgKyBjLnIsIGRjID0gZHggKiBkeCArIGR5ICogZHk7XG4gICAgICBkYSAqPSBkYTtcbiAgICAgIGRiICo9IGRiO1xuICAgICAgdmFyIHggPSAuNSArIChkYiAtIGRhKSAvICgyICogZGMpLCB5ID0gTWF0aC5zcXJ0KE1hdGgubWF4KDAsIDIgKiBkYSAqIChkYiArIGRjKSAtIChkYiAtPSBkYykgKiBkYiAtIGRhICogZGEpKSAvICgyICogZGMpO1xuICAgICAgYy54ID0gYS54ICsgeCAqIGR4ICsgeSAqIGR5O1xuICAgICAgYy55ID0gYS55ICsgeCAqIGR5IC0geSAqIGR4O1xuICAgIH0gZWxzZSB7XG4gICAgICBjLnggPSBhLnggKyBkYjtcbiAgICAgIGMueSA9IGEueTtcbiAgICB9XG4gIH1cbiAgZDMubGF5b3V0LnRyZWUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaGllcmFyY2h5ID0gZDMubGF5b3V0LmhpZXJhcmNoeSgpLnNvcnQobnVsbCkudmFsdWUobnVsbCksIHNlcGFyYXRpb24gPSBkM19sYXlvdXRfdHJlZVNlcGFyYXRpb24sIHNpemUgPSBbIDEsIDEgXSwgbm9kZVNpemUgPSBudWxsO1xuICAgIGZ1bmN0aW9uIHRyZWUoZCwgaSkge1xuICAgICAgdmFyIG5vZGVzID0gaGllcmFyY2h5LmNhbGwodGhpcywgZCwgaSksIHJvb3QwID0gbm9kZXNbMF0sIHJvb3QxID0gd3JhcFRyZWUocm9vdDApO1xuICAgICAgZDNfbGF5b3V0X2hpZXJhcmNoeVZpc2l0QWZ0ZXIocm9vdDEsIGZpcnN0V2FsayksIHJvb3QxLnBhcmVudC5tID0gLXJvb3QxLno7XG4gICAgICBkM19sYXlvdXRfaGllcmFyY2h5VmlzaXRCZWZvcmUocm9vdDEsIHNlY29uZFdhbGspO1xuICAgICAgaWYgKG5vZGVTaXplKSBkM19sYXlvdXRfaGllcmFyY2h5VmlzaXRCZWZvcmUocm9vdDAsIHNpemVOb2RlKTsgZWxzZSB7XG4gICAgICAgIHZhciBsZWZ0ID0gcm9vdDAsIHJpZ2h0ID0gcm9vdDAsIGJvdHRvbSA9IHJvb3QwO1xuICAgICAgICBkM19sYXlvdXRfaGllcmFyY2h5VmlzaXRCZWZvcmUocm9vdDAsIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICBpZiAobm9kZS54IDwgbGVmdC54KSBsZWZ0ID0gbm9kZTtcbiAgICAgICAgICBpZiAobm9kZS54ID4gcmlnaHQueCkgcmlnaHQgPSBub2RlO1xuICAgICAgICAgIGlmIChub2RlLmRlcHRoID4gYm90dG9tLmRlcHRoKSBib3R0b20gPSBub2RlO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHR4ID0gc2VwYXJhdGlvbihsZWZ0LCByaWdodCkgLyAyIC0gbGVmdC54LCBreCA9IHNpemVbMF0gLyAocmlnaHQueCArIHNlcGFyYXRpb24ocmlnaHQsIGxlZnQpIC8gMiArIHR4KSwga3kgPSBzaXplWzFdIC8gKGJvdHRvbS5kZXB0aCB8fCAxKTtcbiAgICAgICAgZDNfbGF5b3V0X2hpZXJhcmNoeVZpc2l0QmVmb3JlKHJvb3QwLCBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgbm9kZS54ID0gKG5vZGUueCArIHR4KSAqIGt4O1xuICAgICAgICAgIG5vZGUueSA9IG5vZGUuZGVwdGggKiBreTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbm9kZXM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdyYXBUcmVlKHJvb3QwKSB7XG4gICAgICB2YXIgcm9vdDEgPSB7XG4gICAgICAgIEE6IG51bGwsXG4gICAgICAgIGNoaWxkcmVuOiBbIHJvb3QwIF1cbiAgICAgIH0sIHF1ZXVlID0gWyByb290MSBdLCBub2RlMTtcbiAgICAgIHdoaWxlICgobm9kZTEgPSBxdWV1ZS5wb3AoKSkgIT0gbnVsbCkge1xuICAgICAgICBmb3IgKHZhciBjaGlsZHJlbiA9IG5vZGUxLmNoaWxkcmVuLCBjaGlsZCwgaSA9IDAsIG4gPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICBxdWV1ZS5wdXNoKChjaGlsZHJlbltpXSA9IGNoaWxkID0ge1xuICAgICAgICAgICAgXzogY2hpbGRyZW5baV0sXG4gICAgICAgICAgICBwYXJlbnQ6IG5vZGUxLFxuICAgICAgICAgICAgY2hpbGRyZW46IChjaGlsZCA9IGNoaWxkcmVuW2ldLmNoaWxkcmVuKSAmJiBjaGlsZC5zbGljZSgpIHx8IFtdLFxuICAgICAgICAgICAgQTogbnVsbCxcbiAgICAgICAgICAgIGE6IG51bGwsXG4gICAgICAgICAgICB6OiAwLFxuICAgICAgICAgICAgbTogMCxcbiAgICAgICAgICAgIGM6IDAsXG4gICAgICAgICAgICBzOiAwLFxuICAgICAgICAgICAgdDogbnVsbCxcbiAgICAgICAgICAgIGk6IGlcbiAgICAgICAgICB9KS5hID0gY2hpbGQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcm9vdDEuY2hpbGRyZW5bMF07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZpcnN0V2Fsayh2KSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSB2LmNoaWxkcmVuLCBzaWJsaW5ncyA9IHYucGFyZW50LmNoaWxkcmVuLCB3ID0gdi5pID8gc2libGluZ3Nbdi5pIC0gMV0gOiBudWxsO1xuICAgICAgaWYgKGNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICBkM19sYXlvdXRfdHJlZVNoaWZ0KHYpO1xuICAgICAgICB2YXIgbWlkcG9pbnQgPSAoY2hpbGRyZW5bMF0ueiArIGNoaWxkcmVuW2NoaWxkcmVuLmxlbmd0aCAtIDFdLnopIC8gMjtcbiAgICAgICAgaWYgKHcpIHtcbiAgICAgICAgICB2LnogPSB3LnogKyBzZXBhcmF0aW9uKHYuXywgdy5fKTtcbiAgICAgICAgICB2Lm0gPSB2LnogLSBtaWRwb2ludDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2LnogPSBtaWRwb2ludDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh3KSB7XG4gICAgICAgIHYueiA9IHcueiArIHNlcGFyYXRpb24odi5fLCB3Ll8pO1xuICAgICAgfVxuICAgICAgdi5wYXJlbnQuQSA9IGFwcG9ydGlvbih2LCB3LCB2LnBhcmVudC5BIHx8IHNpYmxpbmdzWzBdKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2Vjb25kV2Fsayh2KSB7XG4gICAgICB2Ll8ueCA9IHYueiArIHYucGFyZW50Lm07XG4gICAgICB2Lm0gKz0gdi5wYXJlbnQubTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYXBwb3J0aW9uKHYsIHcsIGFuY2VzdG9yKSB7XG4gICAgICBpZiAodykge1xuICAgICAgICB2YXIgdmlwID0gdiwgdm9wID0gdiwgdmltID0gdywgdm9tID0gdmlwLnBhcmVudC5jaGlsZHJlblswXSwgc2lwID0gdmlwLm0sIHNvcCA9IHZvcC5tLCBzaW0gPSB2aW0ubSwgc29tID0gdm9tLm0sIHNoaWZ0O1xuICAgICAgICB3aGlsZSAodmltID0gZDNfbGF5b3V0X3RyZWVSaWdodCh2aW0pLCB2aXAgPSBkM19sYXlvdXRfdHJlZUxlZnQodmlwKSwgdmltICYmIHZpcCkge1xuICAgICAgICAgIHZvbSA9IGQzX2xheW91dF90cmVlTGVmdCh2b20pO1xuICAgICAgICAgIHZvcCA9IGQzX2xheW91dF90cmVlUmlnaHQodm9wKTtcbiAgICAgICAgICB2b3AuYSA9IHY7XG4gICAgICAgICAgc2hpZnQgPSB2aW0ueiArIHNpbSAtIHZpcC56IC0gc2lwICsgc2VwYXJhdGlvbih2aW0uXywgdmlwLl8pO1xuICAgICAgICAgIGlmIChzaGlmdCA+IDApIHtcbiAgICAgICAgICAgIGQzX2xheW91dF90cmVlTW92ZShkM19sYXlvdXRfdHJlZUFuY2VzdG9yKHZpbSwgdiwgYW5jZXN0b3IpLCB2LCBzaGlmdCk7XG4gICAgICAgICAgICBzaXAgKz0gc2hpZnQ7XG4gICAgICAgICAgICBzb3AgKz0gc2hpZnQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNpbSArPSB2aW0ubTtcbiAgICAgICAgICBzaXAgKz0gdmlwLm07XG4gICAgICAgICAgc29tICs9IHZvbS5tO1xuICAgICAgICAgIHNvcCArPSB2b3AubTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmltICYmICFkM19sYXlvdXRfdHJlZVJpZ2h0KHZvcCkpIHtcbiAgICAgICAgICB2b3AudCA9IHZpbTtcbiAgICAgICAgICB2b3AubSArPSBzaW0gLSBzb3A7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZpcCAmJiAhZDNfbGF5b3V0X3RyZWVMZWZ0KHZvbSkpIHtcbiAgICAgICAgICB2b20udCA9IHZpcDtcbiAgICAgICAgICB2b20ubSArPSBzaXAgLSBzb207XG4gICAgICAgICAgYW5jZXN0b3IgPSB2O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYW5jZXN0b3I7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNpemVOb2RlKG5vZGUpIHtcbiAgICAgIG5vZGUueCAqPSBzaXplWzBdO1xuICAgICAgbm9kZS55ID0gbm9kZS5kZXB0aCAqIHNpemVbMV07XG4gICAgfVxuICAgIHRyZWUuc2VwYXJhdGlvbiA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHNlcGFyYXRpb247XG4gICAgICBzZXBhcmF0aW9uID0geDtcbiAgICAgIHJldHVybiB0cmVlO1xuICAgIH07XG4gICAgdHJlZS5zaXplID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gbm9kZVNpemUgPyBudWxsIDogc2l6ZTtcbiAgICAgIG5vZGVTaXplID0gKHNpemUgPSB4KSA9PSBudWxsID8gc2l6ZU5vZGUgOiBudWxsO1xuICAgICAgcmV0dXJuIHRyZWU7XG4gICAgfTtcbiAgICB0cmVlLm5vZGVTaXplID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gbm9kZVNpemUgPyBzaXplIDogbnVsbDtcbiAgICAgIG5vZGVTaXplID0gKHNpemUgPSB4KSA9PSBudWxsID8gbnVsbCA6IHNpemVOb2RlO1xuICAgICAgcmV0dXJuIHRyZWU7XG4gICAgfTtcbiAgICByZXR1cm4gZDNfbGF5b3V0X2hpZXJhcmNoeVJlYmluZCh0cmVlLCBoaWVyYXJjaHkpO1xuICB9O1xuICBmdW5jdGlvbiBkM19sYXlvdXRfdHJlZVNlcGFyYXRpb24oYSwgYikge1xuICAgIHJldHVybiBhLnBhcmVudCA9PSBiLnBhcmVudCA/IDEgOiAyO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2xheW91dF90cmVlTGVmdCh2KSB7XG4gICAgdmFyIGNoaWxkcmVuID0gdi5jaGlsZHJlbjtcbiAgICByZXR1cm4gY2hpbGRyZW4ubGVuZ3RoID8gY2hpbGRyZW5bMF0gOiB2LnQ7XG4gIH1cbiAgZnVuY3Rpb24gZDNfbGF5b3V0X3RyZWVSaWdodCh2KSB7XG4gICAgdmFyIGNoaWxkcmVuID0gdi5jaGlsZHJlbiwgbjtcbiAgICByZXR1cm4gKG4gPSBjaGlsZHJlbi5sZW5ndGgpID8gY2hpbGRyZW5bbiAtIDFdIDogdi50O1xuICB9XG4gIGZ1bmN0aW9uIGQzX2xheW91dF90cmVlTW92ZSh3bSwgd3AsIHNoaWZ0KSB7XG4gICAgdmFyIGNoYW5nZSA9IHNoaWZ0IC8gKHdwLmkgLSB3bS5pKTtcbiAgICB3cC5jIC09IGNoYW5nZTtcbiAgICB3cC5zICs9IHNoaWZ0O1xuICAgIHdtLmMgKz0gY2hhbmdlO1xuICAgIHdwLnogKz0gc2hpZnQ7XG4gICAgd3AubSArPSBzaGlmdDtcbiAgfVxuICBmdW5jdGlvbiBkM19sYXlvdXRfdHJlZVNoaWZ0KHYpIHtcbiAgICB2YXIgc2hpZnQgPSAwLCBjaGFuZ2UgPSAwLCBjaGlsZHJlbiA9IHYuY2hpbGRyZW4sIGkgPSBjaGlsZHJlbi5sZW5ndGgsIHc7XG4gICAgd2hpbGUgKC0taSA+PSAwKSB7XG4gICAgICB3ID0gY2hpbGRyZW5baV07XG4gICAgICB3LnogKz0gc2hpZnQ7XG4gICAgICB3Lm0gKz0gc2hpZnQ7XG4gICAgICBzaGlmdCArPSB3LnMgKyAoY2hhbmdlICs9IHcuYyk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGQzX2xheW91dF90cmVlQW5jZXN0b3IodmltLCB2LCBhbmNlc3Rvcikge1xuICAgIHJldHVybiB2aW0uYS5wYXJlbnQgPT09IHYucGFyZW50ID8gdmltLmEgOiBhbmNlc3RvcjtcbiAgfVxuICBkMy5sYXlvdXQuY2x1c3RlciA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBoaWVyYXJjaHkgPSBkMy5sYXlvdXQuaGllcmFyY2h5KCkuc29ydChudWxsKS52YWx1ZShudWxsKSwgc2VwYXJhdGlvbiA9IGQzX2xheW91dF90cmVlU2VwYXJhdGlvbiwgc2l6ZSA9IFsgMSwgMSBdLCBub2RlU2l6ZSA9IGZhbHNlO1xuICAgIGZ1bmN0aW9uIGNsdXN0ZXIoZCwgaSkge1xuICAgICAgdmFyIG5vZGVzID0gaGllcmFyY2h5LmNhbGwodGhpcywgZCwgaSksIHJvb3QgPSBub2Rlc1swXSwgcHJldmlvdXNOb2RlLCB4ID0gMDtcbiAgICAgIGQzX2xheW91dF9oaWVyYXJjaHlWaXNpdEFmdGVyKHJvb3QsIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbjtcbiAgICAgICAgaWYgKGNoaWxkcmVuICYmIGNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgIG5vZGUueCA9IGQzX2xheW91dF9jbHVzdGVyWChjaGlsZHJlbik7XG4gICAgICAgICAgbm9kZS55ID0gZDNfbGF5b3V0X2NsdXN0ZXJZKGNoaWxkcmVuKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBub2RlLnggPSBwcmV2aW91c05vZGUgPyB4ICs9IHNlcGFyYXRpb24obm9kZSwgcHJldmlvdXNOb2RlKSA6IDA7XG4gICAgICAgICAgbm9kZS55ID0gMDtcbiAgICAgICAgICBwcmV2aW91c05vZGUgPSBub2RlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHZhciBsZWZ0ID0gZDNfbGF5b3V0X2NsdXN0ZXJMZWZ0KHJvb3QpLCByaWdodCA9IGQzX2xheW91dF9jbHVzdGVyUmlnaHQocm9vdCksIHgwID0gbGVmdC54IC0gc2VwYXJhdGlvbihsZWZ0LCByaWdodCkgLyAyLCB4MSA9IHJpZ2h0LnggKyBzZXBhcmF0aW9uKHJpZ2h0LCBsZWZ0KSAvIDI7XG4gICAgICBkM19sYXlvdXRfaGllcmFyY2h5VmlzaXRBZnRlcihyb290LCBub2RlU2l6ZSA/IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgbm9kZS54ID0gKG5vZGUueCAtIHJvb3QueCkgKiBzaXplWzBdO1xuICAgICAgICBub2RlLnkgPSAocm9vdC55IC0gbm9kZS55KSAqIHNpemVbMV07XG4gICAgICB9IDogZnVuY3Rpb24obm9kZSkge1xuICAgICAgICBub2RlLnggPSAobm9kZS54IC0geDApIC8gKHgxIC0geDApICogc2l6ZVswXTtcbiAgICAgICAgbm9kZS55ID0gKDEgLSAocm9vdC55ID8gbm9kZS55IC8gcm9vdC55IDogMSkpICogc2l6ZVsxXTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG5vZGVzO1xuICAgIH1cbiAgICBjbHVzdGVyLnNlcGFyYXRpb24gPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBzZXBhcmF0aW9uO1xuICAgICAgc2VwYXJhdGlvbiA9IHg7XG4gICAgICByZXR1cm4gY2x1c3RlcjtcbiAgICB9O1xuICAgIGNsdXN0ZXIuc2l6ZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG5vZGVTaXplID8gbnVsbCA6IHNpemU7XG4gICAgICBub2RlU2l6ZSA9IChzaXplID0geCkgPT0gbnVsbDtcbiAgICAgIHJldHVybiBjbHVzdGVyO1xuICAgIH07XG4gICAgY2x1c3Rlci5ub2RlU2l6ZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG5vZGVTaXplID8gc2l6ZSA6IG51bGw7XG4gICAgICBub2RlU2l6ZSA9IChzaXplID0geCkgIT0gbnVsbDtcbiAgICAgIHJldHVybiBjbHVzdGVyO1xuICAgIH07XG4gICAgcmV0dXJuIGQzX2xheW91dF9oaWVyYXJjaHlSZWJpbmQoY2x1c3RlciwgaGllcmFyY2h5KTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfbGF5b3V0X2NsdXN0ZXJZKGNoaWxkcmVuKSB7XG4gICAgcmV0dXJuIDEgKyBkMy5tYXgoY2hpbGRyZW4sIGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICByZXR1cm4gY2hpbGQueTtcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBkM19sYXlvdXRfY2x1c3RlclgoY2hpbGRyZW4pIHtcbiAgICByZXR1cm4gY2hpbGRyZW4ucmVkdWNlKGZ1bmN0aW9uKHgsIGNoaWxkKSB7XG4gICAgICByZXR1cm4geCArIGNoaWxkLng7XG4gICAgfSwgMCkgLyBjaGlsZHJlbi5sZW5ndGg7XG4gIH1cbiAgZnVuY3Rpb24gZDNfbGF5b3V0X2NsdXN0ZXJMZWZ0KG5vZGUpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuO1xuICAgIHJldHVybiBjaGlsZHJlbiAmJiBjaGlsZHJlbi5sZW5ndGggPyBkM19sYXlvdXRfY2x1c3RlckxlZnQoY2hpbGRyZW5bMF0pIDogbm9kZTtcbiAgfVxuICBmdW5jdGlvbiBkM19sYXlvdXRfY2x1c3RlclJpZ2h0KG5vZGUpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuLCBuO1xuICAgIHJldHVybiBjaGlsZHJlbiAmJiAobiA9IGNoaWxkcmVuLmxlbmd0aCkgPyBkM19sYXlvdXRfY2x1c3RlclJpZ2h0KGNoaWxkcmVuW24gLSAxXSkgOiBub2RlO1xuICB9XG4gIGQzLmxheW91dC50cmVlbWFwID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGhpZXJhcmNoeSA9IGQzLmxheW91dC5oaWVyYXJjaHkoKSwgcm91bmQgPSBNYXRoLnJvdW5kLCBzaXplID0gWyAxLCAxIF0sIHBhZGRpbmcgPSBudWxsLCBwYWQgPSBkM19sYXlvdXRfdHJlZW1hcFBhZE51bGwsIHN0aWNreSA9IGZhbHNlLCBzdGlja2llcywgbW9kZSA9IFwic3F1YXJpZnlcIiwgcmF0aW8gPSAuNSAqICgxICsgTWF0aC5zcXJ0KDUpKTtcbiAgICBmdW5jdGlvbiBzY2FsZShjaGlsZHJlbiwgaykge1xuICAgICAgdmFyIGkgPSAtMSwgbiA9IGNoaWxkcmVuLmxlbmd0aCwgY2hpbGQsIGFyZWE7XG4gICAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICBhcmVhID0gKGNoaWxkID0gY2hpbGRyZW5baV0pLnZhbHVlICogKGsgPCAwID8gMCA6IGspO1xuICAgICAgICBjaGlsZC5hcmVhID0gaXNOYU4oYXJlYSkgfHwgYXJlYSA8PSAwID8gMCA6IGFyZWE7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNxdWFyaWZ5KG5vZGUpIHtcbiAgICAgIHZhciBjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW47XG4gICAgICBpZiAoY2hpbGRyZW4gJiYgY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgIHZhciByZWN0ID0gcGFkKG5vZGUpLCByb3cgPSBbXSwgcmVtYWluaW5nID0gY2hpbGRyZW4uc2xpY2UoKSwgY2hpbGQsIGJlc3QgPSBJbmZpbml0eSwgc2NvcmUsIHUgPSBtb2RlID09PSBcInNsaWNlXCIgPyByZWN0LmR4IDogbW9kZSA9PT0gXCJkaWNlXCIgPyByZWN0LmR5IDogbW9kZSA9PT0gXCJzbGljZS1kaWNlXCIgPyBub2RlLmRlcHRoICYgMSA/IHJlY3QuZHkgOiByZWN0LmR4IDogTWF0aC5taW4ocmVjdC5keCwgcmVjdC5keSksIG47XG4gICAgICAgIHNjYWxlKHJlbWFpbmluZywgcmVjdC5keCAqIHJlY3QuZHkgLyBub2RlLnZhbHVlKTtcbiAgICAgICAgcm93LmFyZWEgPSAwO1xuICAgICAgICB3aGlsZSAoKG4gPSByZW1haW5pbmcubGVuZ3RoKSA+IDApIHtcbiAgICAgICAgICByb3cucHVzaChjaGlsZCA9IHJlbWFpbmluZ1tuIC0gMV0pO1xuICAgICAgICAgIHJvdy5hcmVhICs9IGNoaWxkLmFyZWE7XG4gICAgICAgICAgaWYgKG1vZGUgIT09IFwic3F1YXJpZnlcIiB8fCAoc2NvcmUgPSB3b3JzdChyb3csIHUpKSA8PSBiZXN0KSB7XG4gICAgICAgICAgICByZW1haW5pbmcucG9wKCk7XG4gICAgICAgICAgICBiZXN0ID0gc2NvcmU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJvdy5hcmVhIC09IHJvdy5wb3AoKS5hcmVhO1xuICAgICAgICAgICAgcG9zaXRpb24ocm93LCB1LCByZWN0LCBmYWxzZSk7XG4gICAgICAgICAgICB1ID0gTWF0aC5taW4ocmVjdC5keCwgcmVjdC5keSk7XG4gICAgICAgICAgICByb3cubGVuZ3RoID0gcm93LmFyZWEgPSAwO1xuICAgICAgICAgICAgYmVzdCA9IEluZmluaXR5O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocm93Lmxlbmd0aCkge1xuICAgICAgICAgIHBvc2l0aW9uKHJvdywgdSwgcmVjdCwgdHJ1ZSk7XG4gICAgICAgICAgcm93Lmxlbmd0aCA9IHJvdy5hcmVhID0gMDtcbiAgICAgICAgfVxuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKHNxdWFyaWZ5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gc3RpY2tpZnkobm9kZSkge1xuICAgICAgdmFyIGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbjtcbiAgICAgIGlmIChjaGlsZHJlbiAmJiBjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgdmFyIHJlY3QgPSBwYWQobm9kZSksIHJlbWFpbmluZyA9IGNoaWxkcmVuLnNsaWNlKCksIGNoaWxkLCByb3cgPSBbXTtcbiAgICAgICAgc2NhbGUocmVtYWluaW5nLCByZWN0LmR4ICogcmVjdC5keSAvIG5vZGUudmFsdWUpO1xuICAgICAgICByb3cuYXJlYSA9IDA7XG4gICAgICAgIHdoaWxlIChjaGlsZCA9IHJlbWFpbmluZy5wb3AoKSkge1xuICAgICAgICAgIHJvdy5wdXNoKGNoaWxkKTtcbiAgICAgICAgICByb3cuYXJlYSArPSBjaGlsZC5hcmVhO1xuICAgICAgICAgIGlmIChjaGlsZC56ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHBvc2l0aW9uKHJvdywgY2hpbGQueiA/IHJlY3QuZHggOiByZWN0LmR5LCByZWN0LCAhcmVtYWluaW5nLmxlbmd0aCk7XG4gICAgICAgICAgICByb3cubGVuZ3RoID0gcm93LmFyZWEgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKHN0aWNraWZ5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gd29yc3Qocm93LCB1KSB7XG4gICAgICB2YXIgcyA9IHJvdy5hcmVhLCByLCBybWF4ID0gMCwgcm1pbiA9IEluZmluaXR5LCBpID0gLTEsIG4gPSByb3cubGVuZ3RoO1xuICAgICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgaWYgKCEociA9IHJvd1tpXS5hcmVhKSkgY29udGludWU7XG4gICAgICAgIGlmIChyIDwgcm1pbikgcm1pbiA9IHI7XG4gICAgICAgIGlmIChyID4gcm1heCkgcm1heCA9IHI7XG4gICAgICB9XG4gICAgICBzICo9IHM7XG4gICAgICB1ICo9IHU7XG4gICAgICByZXR1cm4gcyA/IE1hdGgubWF4KHUgKiBybWF4ICogcmF0aW8gLyBzLCBzIC8gKHUgKiBybWluICogcmF0aW8pKSA6IEluZmluaXR5O1xuICAgIH1cbiAgICBmdW5jdGlvbiBwb3NpdGlvbihyb3csIHUsIHJlY3QsIGZsdXNoKSB7XG4gICAgICB2YXIgaSA9IC0xLCBuID0gcm93Lmxlbmd0aCwgeCA9IHJlY3QueCwgeSA9IHJlY3QueSwgdiA9IHUgPyByb3VuZChyb3cuYXJlYSAvIHUpIDogMCwgbztcbiAgICAgIGlmICh1ID09IHJlY3QuZHgpIHtcbiAgICAgICAgaWYgKGZsdXNoIHx8IHYgPiByZWN0LmR5KSB2ID0gcmVjdC5keTtcbiAgICAgICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgICBvID0gcm93W2ldO1xuICAgICAgICAgIG8ueCA9IHg7XG4gICAgICAgICAgby55ID0geTtcbiAgICAgICAgICBvLmR5ID0gdjtcbiAgICAgICAgICB4ICs9IG8uZHggPSBNYXRoLm1pbihyZWN0LnggKyByZWN0LmR4IC0geCwgdiA/IHJvdW5kKG8uYXJlYSAvIHYpIDogMCk7XG4gICAgICAgIH1cbiAgICAgICAgby56ID0gdHJ1ZTtcbiAgICAgICAgby5keCArPSByZWN0LnggKyByZWN0LmR4IC0geDtcbiAgICAgICAgcmVjdC55ICs9IHY7XG4gICAgICAgIHJlY3QuZHkgLT0gdjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChmbHVzaCB8fCB2ID4gcmVjdC5keCkgdiA9IHJlY3QuZHg7XG4gICAgICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgICAgbyA9IHJvd1tpXTtcbiAgICAgICAgICBvLnggPSB4O1xuICAgICAgICAgIG8ueSA9IHk7XG4gICAgICAgICAgby5keCA9IHY7XG4gICAgICAgICAgeSArPSBvLmR5ID0gTWF0aC5taW4ocmVjdC55ICsgcmVjdC5keSAtIHksIHYgPyByb3VuZChvLmFyZWEgLyB2KSA6IDApO1xuICAgICAgICB9XG4gICAgICAgIG8ueiA9IGZhbHNlO1xuICAgICAgICBvLmR5ICs9IHJlY3QueSArIHJlY3QuZHkgLSB5O1xuICAgICAgICByZWN0LnggKz0gdjtcbiAgICAgICAgcmVjdC5keCAtPSB2O1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB0cmVlbWFwKGQpIHtcbiAgICAgIHZhciBub2RlcyA9IHN0aWNraWVzIHx8IGhpZXJhcmNoeShkKSwgcm9vdCA9IG5vZGVzWzBdO1xuICAgICAgcm9vdC54ID0gcm9vdC55ID0gMDtcbiAgICAgIGlmIChyb290LnZhbHVlKSByb290LmR4ID0gc2l6ZVswXSwgcm9vdC5keSA9IHNpemVbMV07IGVsc2Ugcm9vdC5keCA9IHJvb3QuZHkgPSAwO1xuICAgICAgaWYgKHN0aWNraWVzKSBoaWVyYXJjaHkucmV2YWx1ZShyb290KTtcbiAgICAgIHNjYWxlKFsgcm9vdCBdLCByb290LmR4ICogcm9vdC5keSAvIHJvb3QudmFsdWUpO1xuICAgICAgKHN0aWNraWVzID8gc3RpY2tpZnkgOiBzcXVhcmlmeSkocm9vdCk7XG4gICAgICBpZiAoc3RpY2t5KSBzdGlja2llcyA9IG5vZGVzO1xuICAgICAgcmV0dXJuIG5vZGVzO1xuICAgIH1cbiAgICB0cmVlbWFwLnNpemUgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBzaXplO1xuICAgICAgc2l6ZSA9IHg7XG4gICAgICByZXR1cm4gdHJlZW1hcDtcbiAgICB9O1xuICAgIHRyZWVtYXAucGFkZGluZyA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHBhZGRpbmc7XG4gICAgICBmdW5jdGlvbiBwYWRGdW5jdGlvbihub2RlKSB7XG4gICAgICAgIHZhciBwID0geC5jYWxsKHRyZWVtYXAsIG5vZGUsIG5vZGUuZGVwdGgpO1xuICAgICAgICByZXR1cm4gcCA9PSBudWxsID8gZDNfbGF5b3V0X3RyZWVtYXBQYWROdWxsKG5vZGUpIDogZDNfbGF5b3V0X3RyZWVtYXBQYWQobm9kZSwgdHlwZW9mIHAgPT09IFwibnVtYmVyXCIgPyBbIHAsIHAsIHAsIHAgXSA6IHApO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcGFkQ29uc3RhbnQobm9kZSkge1xuICAgICAgICByZXR1cm4gZDNfbGF5b3V0X3RyZWVtYXBQYWQobm9kZSwgeCk7XG4gICAgICB9XG4gICAgICB2YXIgdHlwZTtcbiAgICAgIHBhZCA9IChwYWRkaW5nID0geCkgPT0gbnVsbCA/IGQzX2xheW91dF90cmVlbWFwUGFkTnVsbCA6ICh0eXBlID0gdHlwZW9mIHgpID09PSBcImZ1bmN0aW9uXCIgPyBwYWRGdW5jdGlvbiA6IHR5cGUgPT09IFwibnVtYmVyXCIgPyAoeCA9IFsgeCwgeCwgeCwgeCBdLCBcbiAgICAgIHBhZENvbnN0YW50KSA6IHBhZENvbnN0YW50O1xuICAgICAgcmV0dXJuIHRyZWVtYXA7XG4gICAgfTtcbiAgICB0cmVlbWFwLnJvdW5kID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gcm91bmQgIT0gTnVtYmVyO1xuICAgICAgcm91bmQgPSB4ID8gTWF0aC5yb3VuZCA6IE51bWJlcjtcbiAgICAgIHJldHVybiB0cmVlbWFwO1xuICAgIH07XG4gICAgdHJlZW1hcC5zdGlja3kgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBzdGlja3k7XG4gICAgICBzdGlja3kgPSB4O1xuICAgICAgc3RpY2tpZXMgPSBudWxsO1xuICAgICAgcmV0dXJuIHRyZWVtYXA7XG4gICAgfTtcbiAgICB0cmVlbWFwLnJhdGlvID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gcmF0aW87XG4gICAgICByYXRpbyA9IHg7XG4gICAgICByZXR1cm4gdHJlZW1hcDtcbiAgICB9O1xuICAgIHRyZWVtYXAubW9kZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG1vZGU7XG4gICAgICBtb2RlID0geCArIFwiXCI7XG4gICAgICByZXR1cm4gdHJlZW1hcDtcbiAgICB9O1xuICAgIHJldHVybiBkM19sYXlvdXRfaGllcmFyY2h5UmViaW5kKHRyZWVtYXAsIGhpZXJhcmNoeSk7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX2xheW91dF90cmVlbWFwUGFkTnVsbChub2RlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IG5vZGUueCxcbiAgICAgIHk6IG5vZGUueSxcbiAgICAgIGR4OiBub2RlLmR4LFxuICAgICAgZHk6IG5vZGUuZHlcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGQzX2xheW91dF90cmVlbWFwUGFkKG5vZGUsIHBhZGRpbmcpIHtcbiAgICB2YXIgeCA9IG5vZGUueCArIHBhZGRpbmdbM10sIHkgPSBub2RlLnkgKyBwYWRkaW5nWzBdLCBkeCA9IG5vZGUuZHggLSBwYWRkaW5nWzFdIC0gcGFkZGluZ1szXSwgZHkgPSBub2RlLmR5IC0gcGFkZGluZ1swXSAtIHBhZGRpbmdbMl07XG4gICAgaWYgKGR4IDwgMCkge1xuICAgICAgeCArPSBkeCAvIDI7XG4gICAgICBkeCA9IDA7XG4gICAgfVxuICAgIGlmIChkeSA8IDApIHtcbiAgICAgIHkgKz0gZHkgLyAyO1xuICAgICAgZHkgPSAwO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgeDogeCxcbiAgICAgIHk6IHksXG4gICAgICBkeDogZHgsXG4gICAgICBkeTogZHlcbiAgICB9O1xuICB9XG4gIGQzLnJhbmRvbSA9IHtcbiAgICBub3JtYWw6IGZ1bmN0aW9uKMK1LCDPgykge1xuICAgICAgdmFyIG4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgaWYgKG4gPCAyKSDPgyA9IDE7XG4gICAgICBpZiAobiA8IDEpIMK1ID0gMDtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHgsIHksIHI7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICB4ID0gTWF0aC5yYW5kb20oKSAqIDIgLSAxO1xuICAgICAgICAgIHkgPSBNYXRoLnJhbmRvbSgpICogMiAtIDE7XG4gICAgICAgICAgciA9IHggKiB4ICsgeSAqIHk7XG4gICAgICAgIH0gd2hpbGUgKCFyIHx8IHIgPiAxKTtcbiAgICAgICAgcmV0dXJuIMK1ICsgz4MgKiB4ICogTWF0aC5zcXJ0KC0yICogTWF0aC5sb2cocikgLyByKTtcbiAgICAgIH07XG4gICAgfSxcbiAgICBsb2dOb3JtYWw6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHJhbmRvbSA9IGQzLnJhbmRvbS5ub3JtYWwuYXBwbHkoZDMsIGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmV4cChyYW5kb20oKSk7XG4gICAgICB9O1xuICAgIH0sXG4gICAgYmF0ZXM6IGZ1bmN0aW9uKG0pIHtcbiAgICAgIHZhciByYW5kb20gPSBkMy5yYW5kb20uaXJ3aW5IYWxsKG0pO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gcmFuZG9tKCkgLyBtO1xuICAgICAgfTtcbiAgICB9LFxuICAgIGlyd2luSGFsbDogZnVuY3Rpb24obSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICBmb3IgKHZhciBzID0gMCwgaiA9IDA7IGogPCBtOyBqKyspIHMgKz0gTWF0aC5yYW5kb20oKTtcbiAgICAgICAgcmV0dXJuIHM7XG4gICAgICB9O1xuICAgIH1cbiAgfTtcbiAgZDMuc2NhbGUgPSB7fTtcbiAgZnVuY3Rpb24gZDNfc2NhbGVFeHRlbnQoZG9tYWluKSB7XG4gICAgdmFyIHN0YXJ0ID0gZG9tYWluWzBdLCBzdG9wID0gZG9tYWluW2RvbWFpbi5sZW5ndGggLSAxXTtcbiAgICByZXR1cm4gc3RhcnQgPCBzdG9wID8gWyBzdGFydCwgc3RvcCBdIDogWyBzdG9wLCBzdGFydCBdO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3NjYWxlUmFuZ2Uoc2NhbGUpIHtcbiAgICByZXR1cm4gc2NhbGUucmFuZ2VFeHRlbnQgPyBzY2FsZS5yYW5nZUV4dGVudCgpIDogZDNfc2NhbGVFeHRlbnQoc2NhbGUucmFuZ2UoKSk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfc2NhbGVfYmlsaW5lYXIoZG9tYWluLCByYW5nZSwgdW5pbnRlcnBvbGF0ZSwgaW50ZXJwb2xhdGUpIHtcbiAgICB2YXIgdSA9IHVuaW50ZXJwb2xhdGUoZG9tYWluWzBdLCBkb21haW5bMV0pLCBpID0gaW50ZXJwb2xhdGUocmFuZ2VbMF0sIHJhbmdlWzFdKTtcbiAgICByZXR1cm4gZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIGkodSh4KSk7XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBkM19zY2FsZV9uaWNlKGRvbWFpbiwgbmljZSkge1xuICAgIHZhciBpMCA9IDAsIGkxID0gZG9tYWluLmxlbmd0aCAtIDEsIHgwID0gZG9tYWluW2kwXSwgeDEgPSBkb21haW5baTFdLCBkeDtcbiAgICBpZiAoeDEgPCB4MCkge1xuICAgICAgZHggPSBpMCwgaTAgPSBpMSwgaTEgPSBkeDtcbiAgICAgIGR4ID0geDAsIHgwID0geDEsIHgxID0gZHg7XG4gICAgfVxuICAgIGRvbWFpbltpMF0gPSBuaWNlLmZsb29yKHgwKTtcbiAgICBkb21haW5baTFdID0gbmljZS5jZWlsKHgxKTtcbiAgICByZXR1cm4gZG9tYWluO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3NjYWxlX25pY2VTdGVwKHN0ZXApIHtcbiAgICByZXR1cm4gc3RlcCA/IHtcbiAgICAgIGZsb29yOiBmdW5jdGlvbih4KSB7XG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKHggLyBzdGVwKSAqIHN0ZXA7XG4gICAgICB9LFxuICAgICAgY2VpbDogZnVuY3Rpb24oeCkge1xuICAgICAgICByZXR1cm4gTWF0aC5jZWlsKHggLyBzdGVwKSAqIHN0ZXA7XG4gICAgICB9XG4gICAgfSA6IGQzX3NjYWxlX25pY2VJZGVudGl0eTtcbiAgfVxuICB2YXIgZDNfc2NhbGVfbmljZUlkZW50aXR5ID0ge1xuICAgIGZsb29yOiBkM19pZGVudGl0eSxcbiAgICBjZWlsOiBkM19pZGVudGl0eVxuICB9O1xuICBmdW5jdGlvbiBkM19zY2FsZV9wb2x5bGluZWFyKGRvbWFpbiwgcmFuZ2UsIHVuaW50ZXJwb2xhdGUsIGludGVycG9sYXRlKSB7XG4gICAgdmFyIHUgPSBbXSwgaSA9IFtdLCBqID0gMCwgayA9IE1hdGgubWluKGRvbWFpbi5sZW5ndGgsIHJhbmdlLmxlbmd0aCkgLSAxO1xuICAgIGlmIChkb21haW5ba10gPCBkb21haW5bMF0pIHtcbiAgICAgIGRvbWFpbiA9IGRvbWFpbi5zbGljZSgpLnJldmVyc2UoKTtcbiAgICAgIHJhbmdlID0gcmFuZ2Uuc2xpY2UoKS5yZXZlcnNlKCk7XG4gICAgfVxuICAgIHdoaWxlICgrK2ogPD0gaykge1xuICAgICAgdS5wdXNoKHVuaW50ZXJwb2xhdGUoZG9tYWluW2ogLSAxXSwgZG9tYWluW2pdKSk7XG4gICAgICBpLnB1c2goaW50ZXJwb2xhdGUocmFuZ2VbaiAtIDFdLCByYW5nZVtqXSkpO1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24oeCkge1xuICAgICAgdmFyIGogPSBkMy5iaXNlY3QoZG9tYWluLCB4LCAxLCBrKSAtIDE7XG4gICAgICByZXR1cm4gaVtqXSh1W2pdKHgpKTtcbiAgICB9O1xuICB9XG4gIGQzLnNjYWxlLmxpbmVhciA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkM19zY2FsZV9saW5lYXIoWyAwLCAxIF0sIFsgMCwgMSBdLCBkM19pbnRlcnBvbGF0ZSwgZmFsc2UpO1xuICB9O1xuICBmdW5jdGlvbiBkM19zY2FsZV9saW5lYXIoZG9tYWluLCByYW5nZSwgaW50ZXJwb2xhdGUsIGNsYW1wKSB7XG4gICAgdmFyIG91dHB1dCwgaW5wdXQ7XG4gICAgZnVuY3Rpb24gcmVzY2FsZSgpIHtcbiAgICAgIHZhciBsaW5lYXIgPSBNYXRoLm1pbihkb21haW4ubGVuZ3RoLCByYW5nZS5sZW5ndGgpID4gMiA/IGQzX3NjYWxlX3BvbHlsaW5lYXIgOiBkM19zY2FsZV9iaWxpbmVhciwgdW5pbnRlcnBvbGF0ZSA9IGNsYW1wID8gZDNfdW5pbnRlcnBvbGF0ZUNsYW1wIDogZDNfdW5pbnRlcnBvbGF0ZU51bWJlcjtcbiAgICAgIG91dHB1dCA9IGxpbmVhcihkb21haW4sIHJhbmdlLCB1bmludGVycG9sYXRlLCBpbnRlcnBvbGF0ZSk7XG4gICAgICBpbnB1dCA9IGxpbmVhcihyYW5nZSwgZG9tYWluLCB1bmludGVycG9sYXRlLCBkM19pbnRlcnBvbGF0ZSk7XG4gICAgICByZXR1cm4gc2NhbGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNjYWxlKHgpIHtcbiAgICAgIHJldHVybiBvdXRwdXQoeCk7XG4gICAgfVxuICAgIHNjYWxlLmludmVydCA9IGZ1bmN0aW9uKHkpIHtcbiAgICAgIHJldHVybiBpbnB1dCh5KTtcbiAgICB9O1xuICAgIHNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGRvbWFpbjtcbiAgICAgIGRvbWFpbiA9IHgubWFwKE51bWJlcik7XG4gICAgICByZXR1cm4gcmVzY2FsZSgpO1xuICAgIH07XG4gICAgc2NhbGUucmFuZ2UgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiByYW5nZTtcbiAgICAgIHJhbmdlID0geDtcbiAgICAgIHJldHVybiByZXNjYWxlKCk7XG4gICAgfTtcbiAgICBzY2FsZS5yYW5nZVJvdW5kID0gZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIHNjYWxlLnJhbmdlKHgpLmludGVycG9sYXRlKGQzX2ludGVycG9sYXRlUm91bmQpO1xuICAgIH07XG4gICAgc2NhbGUuY2xhbXAgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBjbGFtcDtcbiAgICAgIGNsYW1wID0geDtcbiAgICAgIHJldHVybiByZXNjYWxlKCk7XG4gICAgfTtcbiAgICBzY2FsZS5pbnRlcnBvbGF0ZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGludGVycG9sYXRlO1xuICAgICAgaW50ZXJwb2xhdGUgPSB4O1xuICAgICAgcmV0dXJuIHJlc2NhbGUoKTtcbiAgICB9O1xuICAgIHNjYWxlLnRpY2tzID0gZnVuY3Rpb24obSkge1xuICAgICAgcmV0dXJuIGQzX3NjYWxlX2xpbmVhclRpY2tzKGRvbWFpbiwgbSk7XG4gICAgfTtcbiAgICBzY2FsZS50aWNrRm9ybWF0ID0gZnVuY3Rpb24obSwgZm9ybWF0KSB7XG4gICAgICByZXR1cm4gZDNfc2NhbGVfbGluZWFyVGlja0Zvcm1hdChkb21haW4sIG0sIGZvcm1hdCk7XG4gICAgfTtcbiAgICBzY2FsZS5uaWNlID0gZnVuY3Rpb24obSkge1xuICAgICAgZDNfc2NhbGVfbGluZWFyTmljZShkb21haW4sIG0pO1xuICAgICAgcmV0dXJuIHJlc2NhbGUoKTtcbiAgICB9O1xuICAgIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBkM19zY2FsZV9saW5lYXIoZG9tYWluLCByYW5nZSwgaW50ZXJwb2xhdGUsIGNsYW1wKTtcbiAgICB9O1xuICAgIHJldHVybiByZXNjYWxlKCk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfc2NhbGVfbGluZWFyUmViaW5kKHNjYWxlLCBsaW5lYXIpIHtcbiAgICByZXR1cm4gZDMucmViaW5kKHNjYWxlLCBsaW5lYXIsIFwicmFuZ2VcIiwgXCJyYW5nZVJvdW5kXCIsIFwiaW50ZXJwb2xhdGVcIiwgXCJjbGFtcFwiKTtcbiAgfVxuICBmdW5jdGlvbiBkM19zY2FsZV9saW5lYXJOaWNlKGRvbWFpbiwgbSkge1xuICAgIGQzX3NjYWxlX25pY2UoZG9tYWluLCBkM19zY2FsZV9uaWNlU3RlcChkM19zY2FsZV9saW5lYXJUaWNrUmFuZ2UoZG9tYWluLCBtKVsyXSkpO1xuICAgIGQzX3NjYWxlX25pY2UoZG9tYWluLCBkM19zY2FsZV9uaWNlU3RlcChkM19zY2FsZV9saW5lYXJUaWNrUmFuZ2UoZG9tYWluLCBtKVsyXSkpO1xuICAgIHJldHVybiBkb21haW47XG4gIH1cbiAgZnVuY3Rpb24gZDNfc2NhbGVfbGluZWFyVGlja1JhbmdlKGRvbWFpbiwgbSkge1xuICAgIGlmIChtID09IG51bGwpIG0gPSAxMDtcbiAgICB2YXIgZXh0ZW50ID0gZDNfc2NhbGVFeHRlbnQoZG9tYWluKSwgc3BhbiA9IGV4dGVudFsxXSAtIGV4dGVudFswXSwgc3RlcCA9IE1hdGgucG93KDEwLCBNYXRoLmZsb29yKE1hdGgubG9nKHNwYW4gLyBtKSAvIE1hdGguTE4xMCkpLCBlcnIgPSBtIC8gc3BhbiAqIHN0ZXA7XG4gICAgaWYgKGVyciA8PSAuMTUpIHN0ZXAgKj0gMTA7IGVsc2UgaWYgKGVyciA8PSAuMzUpIHN0ZXAgKj0gNTsgZWxzZSBpZiAoZXJyIDw9IC43NSkgc3RlcCAqPSAyO1xuICAgIGV4dGVudFswXSA9IE1hdGguY2VpbChleHRlbnRbMF0gLyBzdGVwKSAqIHN0ZXA7XG4gICAgZXh0ZW50WzFdID0gTWF0aC5mbG9vcihleHRlbnRbMV0gLyBzdGVwKSAqIHN0ZXAgKyBzdGVwICogLjU7XG4gICAgZXh0ZW50WzJdID0gc3RlcDtcbiAgICByZXR1cm4gZXh0ZW50O1xuICB9XG4gIGZ1bmN0aW9uIGQzX3NjYWxlX2xpbmVhclRpY2tzKGRvbWFpbiwgbSkge1xuICAgIHJldHVybiBkMy5yYW5nZS5hcHBseShkMywgZDNfc2NhbGVfbGluZWFyVGlja1JhbmdlKGRvbWFpbiwgbSkpO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3NjYWxlX2xpbmVhclRpY2tGb3JtYXQoZG9tYWluLCBtLCBmb3JtYXQpIHtcbiAgICB2YXIgcmFuZ2UgPSBkM19zY2FsZV9saW5lYXJUaWNrUmFuZ2UoZG9tYWluLCBtKTtcbiAgICBpZiAoZm9ybWF0KSB7XG4gICAgICB2YXIgbWF0Y2ggPSBkM19mb3JtYXRfcmUuZXhlYyhmb3JtYXQpO1xuICAgICAgbWF0Y2guc2hpZnQoKTtcbiAgICAgIGlmIChtYXRjaFs4XSA9PT0gXCJzXCIpIHtcbiAgICAgICAgdmFyIHByZWZpeCA9IGQzLmZvcm1hdFByZWZpeChNYXRoLm1heChhYnMocmFuZ2VbMF0pLCBhYnMocmFuZ2VbMV0pKSk7XG4gICAgICAgIGlmICghbWF0Y2hbN10pIG1hdGNoWzddID0gXCIuXCIgKyBkM19zY2FsZV9saW5lYXJQcmVjaXNpb24ocHJlZml4LnNjYWxlKHJhbmdlWzJdKSk7XG4gICAgICAgIG1hdGNoWzhdID0gXCJmXCI7XG4gICAgICAgIGZvcm1hdCA9IGQzLmZvcm1hdChtYXRjaC5qb2luKFwiXCIpKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICByZXR1cm4gZm9ybWF0KHByZWZpeC5zY2FsZShkKSkgKyBwcmVmaXguc3ltYm9sO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgaWYgKCFtYXRjaFs3XSkgbWF0Y2hbN10gPSBcIi5cIiArIGQzX3NjYWxlX2xpbmVhckZvcm1hdFByZWNpc2lvbihtYXRjaFs4XSwgcmFuZ2UpO1xuICAgICAgZm9ybWF0ID0gbWF0Y2guam9pbihcIlwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9ybWF0ID0gXCIsLlwiICsgZDNfc2NhbGVfbGluZWFyUHJlY2lzaW9uKHJhbmdlWzJdKSArIFwiZlwiO1xuICAgIH1cbiAgICByZXR1cm4gZDMuZm9ybWF0KGZvcm1hdCk7XG4gIH1cbiAgdmFyIGQzX3NjYWxlX2xpbmVhckZvcm1hdFNpZ25pZmljYW50ID0ge1xuICAgIHM6IDEsXG4gICAgZzogMSxcbiAgICBwOiAxLFxuICAgIHI6IDEsXG4gICAgZTogMVxuICB9O1xuICBmdW5jdGlvbiBkM19zY2FsZV9saW5lYXJQcmVjaXNpb24odmFsdWUpIHtcbiAgICByZXR1cm4gLU1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjEwICsgLjAxKTtcbiAgfVxuICBmdW5jdGlvbiBkM19zY2FsZV9saW5lYXJGb3JtYXRQcmVjaXNpb24odHlwZSwgcmFuZ2UpIHtcbiAgICB2YXIgcCA9IGQzX3NjYWxlX2xpbmVhclByZWNpc2lvbihyYW5nZVsyXSk7XG4gICAgcmV0dXJuIHR5cGUgaW4gZDNfc2NhbGVfbGluZWFyRm9ybWF0U2lnbmlmaWNhbnQgPyBNYXRoLmFicyhwIC0gZDNfc2NhbGVfbGluZWFyUHJlY2lzaW9uKE1hdGgubWF4KGFicyhyYW5nZVswXSksIGFicyhyYW5nZVsxXSkpKSkgKyArKHR5cGUgIT09IFwiZVwiKSA6IHAgLSAodHlwZSA9PT0gXCIlXCIpICogMjtcbiAgfVxuICBkMy5zY2FsZS5sb2cgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZDNfc2NhbGVfbG9nKGQzLnNjYWxlLmxpbmVhcigpLmRvbWFpbihbIDAsIDEgXSksIDEwLCB0cnVlLCBbIDEsIDEwIF0pO1xuICB9O1xuICBmdW5jdGlvbiBkM19zY2FsZV9sb2cobGluZWFyLCBiYXNlLCBwb3NpdGl2ZSwgZG9tYWluKSB7XG4gICAgZnVuY3Rpb24gbG9nKHgpIHtcbiAgICAgIHJldHVybiAocG9zaXRpdmUgPyBNYXRoLmxvZyh4IDwgMCA/IDAgOiB4KSA6IC1NYXRoLmxvZyh4ID4gMCA/IDAgOiAteCkpIC8gTWF0aC5sb2coYmFzZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBvdyh4KSB7XG4gICAgICByZXR1cm4gcG9zaXRpdmUgPyBNYXRoLnBvdyhiYXNlLCB4KSA6IC1NYXRoLnBvdyhiYXNlLCAteCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNjYWxlKHgpIHtcbiAgICAgIHJldHVybiBsaW5lYXIobG9nKHgpKTtcbiAgICB9XG4gICAgc2NhbGUuaW52ZXJ0ID0gZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIHBvdyhsaW5lYXIuaW52ZXJ0KHgpKTtcbiAgICB9O1xuICAgIHNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGRvbWFpbjtcbiAgICAgIHBvc2l0aXZlID0geFswXSA+PSAwO1xuICAgICAgbGluZWFyLmRvbWFpbigoZG9tYWluID0geC5tYXAoTnVtYmVyKSkubWFwKGxvZykpO1xuICAgICAgcmV0dXJuIHNjYWxlO1xuICAgIH07XG4gICAgc2NhbGUuYmFzZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGJhc2U7XG4gICAgICBiYXNlID0gK187XG4gICAgICBsaW5lYXIuZG9tYWluKGRvbWFpbi5tYXAobG9nKSk7XG4gICAgICByZXR1cm4gc2NhbGU7XG4gICAgfTtcbiAgICBzY2FsZS5uaWNlID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbmljZWQgPSBkM19zY2FsZV9uaWNlKGRvbWFpbi5tYXAobG9nKSwgcG9zaXRpdmUgPyBNYXRoIDogZDNfc2NhbGVfbG9nTmljZU5lZ2F0aXZlKTtcbiAgICAgIGxpbmVhci5kb21haW4obmljZWQpO1xuICAgICAgZG9tYWluID0gbmljZWQubWFwKHBvdyk7XG4gICAgICByZXR1cm4gc2NhbGU7XG4gICAgfTtcbiAgICBzY2FsZS50aWNrcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGV4dGVudCA9IGQzX3NjYWxlRXh0ZW50KGRvbWFpbiksIHRpY2tzID0gW10sIHUgPSBleHRlbnRbMF0sIHYgPSBleHRlbnRbMV0sIGkgPSBNYXRoLmZsb29yKGxvZyh1KSksIGogPSBNYXRoLmNlaWwobG9nKHYpKSwgbiA9IGJhc2UgJSAxID8gMiA6IGJhc2U7XG4gICAgICBpZiAoaXNGaW5pdGUoaiAtIGkpKSB7XG4gICAgICAgIGlmIChwb3NpdGl2ZSkge1xuICAgICAgICAgIGZvciAoO2kgPCBqOyBpKyspIGZvciAodmFyIGsgPSAxOyBrIDwgbjsgaysrKSB0aWNrcy5wdXNoKHBvdyhpKSAqIGspO1xuICAgICAgICAgIHRpY2tzLnB1c2gocG93KGkpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aWNrcy5wdXNoKHBvdyhpKSk7XG4gICAgICAgICAgZm9yICg7aSsrIDwgajsgKSBmb3IgKHZhciBrID0gbiAtIDE7IGsgPiAwOyBrLS0pIHRpY2tzLnB1c2gocG93KGkpICogayk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gMDsgdGlja3NbaV0gPCB1OyBpKyspIHt9XG4gICAgICAgIGZvciAoaiA9IHRpY2tzLmxlbmd0aDsgdGlja3NbaiAtIDFdID4gdjsgai0tKSB7fVxuICAgICAgICB0aWNrcyA9IHRpY2tzLnNsaWNlKGksIGopO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRpY2tzO1xuICAgIH07XG4gICAgc2NhbGUudGlja0Zvcm1hdCA9IGZ1bmN0aW9uKG4sIGZvcm1hdCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZDNfc2NhbGVfbG9nRm9ybWF0O1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSBmb3JtYXQgPSBkM19zY2FsZV9sb2dGb3JtYXQ7IGVsc2UgaWYgKHR5cGVvZiBmb3JtYXQgIT09IFwiZnVuY3Rpb25cIikgZm9ybWF0ID0gZDMuZm9ybWF0KGZvcm1hdCk7XG4gICAgICB2YXIgayA9IE1hdGgubWF4KDEsIGJhc2UgKiBuIC8gc2NhbGUudGlja3MoKS5sZW5ndGgpO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgdmFyIGkgPSBkIC8gcG93KE1hdGgucm91bmQobG9nKGQpKSk7XG4gICAgICAgIGlmIChpICogYmFzZSA8IGJhc2UgLSAuNSkgaSAqPSBiYXNlO1xuICAgICAgICByZXR1cm4gaSA8PSBrID8gZm9ybWF0KGQpIDogXCJcIjtcbiAgICAgIH07XG4gICAgfTtcbiAgICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZDNfc2NhbGVfbG9nKGxpbmVhci5jb3B5KCksIGJhc2UsIHBvc2l0aXZlLCBkb21haW4pO1xuICAgIH07XG4gICAgcmV0dXJuIGQzX3NjYWxlX2xpbmVhclJlYmluZChzY2FsZSwgbGluZWFyKTtcbiAgfVxuICB2YXIgZDNfc2NhbGVfbG9nRm9ybWF0ID0gZDMuZm9ybWF0KFwiLjBlXCIpLCBkM19zY2FsZV9sb2dOaWNlTmVnYXRpdmUgPSB7XG4gICAgZmxvb3I6IGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiAtTWF0aC5jZWlsKC14KTtcbiAgICB9LFxuICAgIGNlaWw6IGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiAtTWF0aC5mbG9vcigteCk7XG4gICAgfVxuICB9O1xuICBkMy5zY2FsZS5wb3cgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZDNfc2NhbGVfcG93KGQzLnNjYWxlLmxpbmVhcigpLCAxLCBbIDAsIDEgXSk7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX3NjYWxlX3BvdyhsaW5lYXIsIGV4cG9uZW50LCBkb21haW4pIHtcbiAgICB2YXIgcG93cCA9IGQzX3NjYWxlX3Bvd1BvdyhleHBvbmVudCksIHBvd2IgPSBkM19zY2FsZV9wb3dQb3coMSAvIGV4cG9uZW50KTtcbiAgICBmdW5jdGlvbiBzY2FsZSh4KSB7XG4gICAgICByZXR1cm4gbGluZWFyKHBvd3AoeCkpO1xuICAgIH1cbiAgICBzY2FsZS5pbnZlcnQgPSBmdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4gcG93YihsaW5lYXIuaW52ZXJ0KHgpKTtcbiAgICB9O1xuICAgIHNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGRvbWFpbjtcbiAgICAgIGxpbmVhci5kb21haW4oKGRvbWFpbiA9IHgubWFwKE51bWJlcikpLm1hcChwb3dwKSk7XG4gICAgICByZXR1cm4gc2NhbGU7XG4gICAgfTtcbiAgICBzY2FsZS50aWNrcyA9IGZ1bmN0aW9uKG0pIHtcbiAgICAgIHJldHVybiBkM19zY2FsZV9saW5lYXJUaWNrcyhkb21haW4sIG0pO1xuICAgIH07XG4gICAgc2NhbGUudGlja0Zvcm1hdCA9IGZ1bmN0aW9uKG0sIGZvcm1hdCkge1xuICAgICAgcmV0dXJuIGQzX3NjYWxlX2xpbmVhclRpY2tGb3JtYXQoZG9tYWluLCBtLCBmb3JtYXQpO1xuICAgIH07XG4gICAgc2NhbGUubmljZSA9IGZ1bmN0aW9uKG0pIHtcbiAgICAgIHJldHVybiBzY2FsZS5kb21haW4oZDNfc2NhbGVfbGluZWFyTmljZShkb21haW4sIG0pKTtcbiAgICB9O1xuICAgIHNjYWxlLmV4cG9uZW50ID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZXhwb25lbnQ7XG4gICAgICBwb3dwID0gZDNfc2NhbGVfcG93UG93KGV4cG9uZW50ID0geCk7XG4gICAgICBwb3diID0gZDNfc2NhbGVfcG93UG93KDEgLyBleHBvbmVudCk7XG4gICAgICBsaW5lYXIuZG9tYWluKGRvbWFpbi5tYXAocG93cCkpO1xuICAgICAgcmV0dXJuIHNjYWxlO1xuICAgIH07XG4gICAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGQzX3NjYWxlX3BvdyhsaW5lYXIuY29weSgpLCBleHBvbmVudCwgZG9tYWluKTtcbiAgICB9O1xuICAgIHJldHVybiBkM19zY2FsZV9saW5lYXJSZWJpbmQoc2NhbGUsIGxpbmVhcik7XG4gIH1cbiAgZnVuY3Rpb24gZDNfc2NhbGVfcG93UG93KGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIHggPCAwID8gLU1hdGgucG93KC14LCBlKSA6IE1hdGgucG93KHgsIGUpO1xuICAgIH07XG4gIH1cbiAgZDMuc2NhbGUuc3FydCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkMy5zY2FsZS5wb3coKS5leHBvbmVudCguNSk7XG4gIH07XG4gIGQzLnNjYWxlLm9yZGluYWwgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZDNfc2NhbGVfb3JkaW5hbChbXSwge1xuICAgICAgdDogXCJyYW5nZVwiLFxuICAgICAgYTogWyBbXSBdXG4gICAgfSk7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX3NjYWxlX29yZGluYWwoZG9tYWluLCByYW5nZXIpIHtcbiAgICB2YXIgaW5kZXgsIHJhbmdlLCByYW5nZUJhbmQ7XG4gICAgZnVuY3Rpb24gc2NhbGUoeCkge1xuICAgICAgcmV0dXJuIHJhbmdlWygoaW5kZXguZ2V0KHgpIHx8IChyYW5nZXIudCA9PT0gXCJyYW5nZVwiID8gaW5kZXguc2V0KHgsIGRvbWFpbi5wdXNoKHgpKSA6IE5hTikpIC0gMSkgJSByYW5nZS5sZW5ndGhdO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzdGVwcyhzdGFydCwgc3RlcCkge1xuICAgICAgcmV0dXJuIGQzLnJhbmdlKGRvbWFpbi5sZW5ndGgpLm1hcChmdW5jdGlvbihpKSB7XG4gICAgICAgIHJldHVybiBzdGFydCArIHN0ZXAgKiBpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGRvbWFpbjtcbiAgICAgIGRvbWFpbiA9IFtdO1xuICAgICAgaW5kZXggPSBuZXcgZDNfTWFwKCk7XG4gICAgICB2YXIgaSA9IC0xLCBuID0geC5sZW5ndGgsIHhpO1xuICAgICAgd2hpbGUgKCsraSA8IG4pIGlmICghaW5kZXguaGFzKHhpID0geFtpXSkpIGluZGV4LnNldCh4aSwgZG9tYWluLnB1c2goeGkpKTtcbiAgICAgIHJldHVybiBzY2FsZVtyYW5nZXIudF0uYXBwbHkoc2NhbGUsIHJhbmdlci5hKTtcbiAgICB9O1xuICAgIHNjYWxlLnJhbmdlID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gcmFuZ2U7XG4gICAgICByYW5nZSA9IHg7XG4gICAgICByYW5nZUJhbmQgPSAwO1xuICAgICAgcmFuZ2VyID0ge1xuICAgICAgICB0OiBcInJhbmdlXCIsXG4gICAgICAgIGE6IGFyZ3VtZW50c1xuICAgICAgfTtcbiAgICAgIHJldHVybiBzY2FsZTtcbiAgICB9O1xuICAgIHNjYWxlLnJhbmdlUG9pbnRzID0gZnVuY3Rpb24oeCwgcGFkZGluZykge1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSBwYWRkaW5nID0gMDtcbiAgICAgIHZhciBzdGFydCA9IHhbMF0sIHN0b3AgPSB4WzFdLCBzdGVwID0gZG9tYWluLmxlbmd0aCA8IDIgPyAoc3RhcnQgPSAoc3RhcnQgKyBzdG9wKSAvIDIsIFxuICAgICAgMCkgOiAoc3RvcCAtIHN0YXJ0KSAvIChkb21haW4ubGVuZ3RoIC0gMSArIHBhZGRpbmcpO1xuICAgICAgcmFuZ2UgPSBzdGVwcyhzdGFydCArIHN0ZXAgKiBwYWRkaW5nIC8gMiwgc3RlcCk7XG4gICAgICByYW5nZUJhbmQgPSAwO1xuICAgICAgcmFuZ2VyID0ge1xuICAgICAgICB0OiBcInJhbmdlUG9pbnRzXCIsXG4gICAgICAgIGE6IGFyZ3VtZW50c1xuICAgICAgfTtcbiAgICAgIHJldHVybiBzY2FsZTtcbiAgICB9O1xuICAgIHNjYWxlLnJhbmdlUm91bmRQb2ludHMgPSBmdW5jdGlvbih4LCBwYWRkaW5nKSB7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHBhZGRpbmcgPSAwO1xuICAgICAgdmFyIHN0YXJ0ID0geFswXSwgc3RvcCA9IHhbMV0sIHN0ZXAgPSBkb21haW4ubGVuZ3RoIDwgMiA/IChzdGFydCA9IHN0b3AgPSBNYXRoLnJvdW5kKChzdGFydCArIHN0b3ApIC8gMiksIFxuICAgICAgMCkgOiAoc3RvcCAtIHN0YXJ0KSAvIChkb21haW4ubGVuZ3RoIC0gMSArIHBhZGRpbmcpIHwgMDtcbiAgICAgIHJhbmdlID0gc3RlcHMoc3RhcnQgKyBNYXRoLnJvdW5kKHN0ZXAgKiBwYWRkaW5nIC8gMiArIChzdG9wIC0gc3RhcnQgLSAoZG9tYWluLmxlbmd0aCAtIDEgKyBwYWRkaW5nKSAqIHN0ZXApIC8gMiksIHN0ZXApO1xuICAgICAgcmFuZ2VCYW5kID0gMDtcbiAgICAgIHJhbmdlciA9IHtcbiAgICAgICAgdDogXCJyYW5nZVJvdW5kUG9pbnRzXCIsXG4gICAgICAgIGE6IGFyZ3VtZW50c1xuICAgICAgfTtcbiAgICAgIHJldHVybiBzY2FsZTtcbiAgICB9O1xuICAgIHNjYWxlLnJhbmdlQmFuZHMgPSBmdW5jdGlvbih4LCBwYWRkaW5nLCBvdXRlclBhZGRpbmcpIHtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikgcGFkZGluZyA9IDA7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDMpIG91dGVyUGFkZGluZyA9IHBhZGRpbmc7XG4gICAgICB2YXIgcmV2ZXJzZSA9IHhbMV0gPCB4WzBdLCBzdGFydCA9IHhbcmV2ZXJzZSAtIDBdLCBzdG9wID0geFsxIC0gcmV2ZXJzZV0sIHN0ZXAgPSAoc3RvcCAtIHN0YXJ0KSAvIChkb21haW4ubGVuZ3RoIC0gcGFkZGluZyArIDIgKiBvdXRlclBhZGRpbmcpO1xuICAgICAgcmFuZ2UgPSBzdGVwcyhzdGFydCArIHN0ZXAgKiBvdXRlclBhZGRpbmcsIHN0ZXApO1xuICAgICAgaWYgKHJldmVyc2UpIHJhbmdlLnJldmVyc2UoKTtcbiAgICAgIHJhbmdlQmFuZCA9IHN0ZXAgKiAoMSAtIHBhZGRpbmcpO1xuICAgICAgcmFuZ2VyID0ge1xuICAgICAgICB0OiBcInJhbmdlQmFuZHNcIixcbiAgICAgICAgYTogYXJndW1lbnRzXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHNjYWxlO1xuICAgIH07XG4gICAgc2NhbGUucmFuZ2VSb3VuZEJhbmRzID0gZnVuY3Rpb24oeCwgcGFkZGluZywgb3V0ZXJQYWRkaW5nKSB7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHBhZGRpbmcgPSAwO1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAzKSBvdXRlclBhZGRpbmcgPSBwYWRkaW5nO1xuICAgICAgdmFyIHJldmVyc2UgPSB4WzFdIDwgeFswXSwgc3RhcnQgPSB4W3JldmVyc2UgLSAwXSwgc3RvcCA9IHhbMSAtIHJldmVyc2VdLCBzdGVwID0gTWF0aC5mbG9vcigoc3RvcCAtIHN0YXJ0KSAvIChkb21haW4ubGVuZ3RoIC0gcGFkZGluZyArIDIgKiBvdXRlclBhZGRpbmcpKTtcbiAgICAgIHJhbmdlID0gc3RlcHMoc3RhcnQgKyBNYXRoLnJvdW5kKChzdG9wIC0gc3RhcnQgLSAoZG9tYWluLmxlbmd0aCAtIHBhZGRpbmcpICogc3RlcCkgLyAyKSwgc3RlcCk7XG4gICAgICBpZiAocmV2ZXJzZSkgcmFuZ2UucmV2ZXJzZSgpO1xuICAgICAgcmFuZ2VCYW5kID0gTWF0aC5yb3VuZChzdGVwICogKDEgLSBwYWRkaW5nKSk7XG4gICAgICByYW5nZXIgPSB7XG4gICAgICAgIHQ6IFwicmFuZ2VSb3VuZEJhbmRzXCIsXG4gICAgICAgIGE6IGFyZ3VtZW50c1xuICAgICAgfTtcbiAgICAgIHJldHVybiBzY2FsZTtcbiAgICB9O1xuICAgIHNjYWxlLnJhbmdlQmFuZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHJhbmdlQmFuZDtcbiAgICB9O1xuICAgIHNjYWxlLnJhbmdlRXh0ZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZDNfc2NhbGVFeHRlbnQocmFuZ2VyLmFbMF0pO1xuICAgIH07XG4gICAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGQzX3NjYWxlX29yZGluYWwoZG9tYWluLCByYW5nZXIpO1xuICAgIH07XG4gICAgcmV0dXJuIHNjYWxlLmRvbWFpbihkb21haW4pO1xuICB9XG4gIGQzLnNjYWxlLmNhdGVnb3J5MTAgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZDMuc2NhbGUub3JkaW5hbCgpLnJhbmdlKGQzX2NhdGVnb3J5MTApO1xuICB9O1xuICBkMy5zY2FsZS5jYXRlZ29yeTIwID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGQzLnNjYWxlLm9yZGluYWwoKS5yYW5nZShkM19jYXRlZ29yeTIwKTtcbiAgfTtcbiAgZDMuc2NhbGUuY2F0ZWdvcnkyMGIgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZDMuc2NhbGUub3JkaW5hbCgpLnJhbmdlKGQzX2NhdGVnb3J5MjBiKTtcbiAgfTtcbiAgZDMuc2NhbGUuY2F0ZWdvcnkyMGMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZDMuc2NhbGUub3JkaW5hbCgpLnJhbmdlKGQzX2NhdGVnb3J5MjBjKTtcbiAgfTtcbiAgdmFyIGQzX2NhdGVnb3J5MTAgPSBbIDIwNjIyNjAsIDE2NzQ0MjA2LCAyOTI0NTg4LCAxNDAzNDcyOCwgOTcyNTg4NSwgOTE5NzEzMSwgMTQ5MDczMzAsIDgzNTU3MTEsIDEyMzY5MTg2LCAxNTU2MTc1IF0ubWFwKGQzX3JnYlN0cmluZyk7XG4gIHZhciBkM19jYXRlZ29yeTIwID0gWyAyMDYyMjYwLCAxMTQ1NDQ0MCwgMTY3NDQyMDYsIDE2NzU5NjcyLCAyOTI0NTg4LCAxMDAxODY5OCwgMTQwMzQ3MjgsIDE2NzUwNzQyLCA5NzI1ODg1LCAxMjk1NTg2MSwgOTE5NzEzMSwgMTI4ODUxNDAsIDE0OTA3MzMwLCAxNjIzNDE5NCwgODM1NTcxMSwgMTMwOTI4MDcsIDEyMzY5MTg2LCAxNDQwODU4OSwgMTU1NjE3NSwgMTA0MTA3MjUgXS5tYXAoZDNfcmdiU3RyaW5nKTtcbiAgdmFyIGQzX2NhdGVnb3J5MjBiID0gWyAzNzUwNzc3LCA1Mzk1NjE5LCA3MDQwNzE5LCAxMDI2NDI4NiwgNjUxOTA5NywgOTIxNjU5NCwgMTE5MTUxMTUsIDEzNTU2NjM2LCA5MjAyOTkzLCAxMjQyNjgwOSwgMTUxODY1MTQsIDE1MTkwOTMyLCA4NjY2MTY5LCAxMTM1NjQ5MCwgMTQwNDk2NDMsIDE1MTc3MzcyLCA4MDc3NjgzLCAxMDgzNDMyNCwgMTM1Mjg1MDksIDE0NTg5NjU0IF0ubWFwKGQzX3JnYlN0cmluZyk7XG4gIHZhciBkM19jYXRlZ29yeTIwYyA9IFsgMzI0NDczMywgNzA1NzExMCwgMTA0MDY2MjUsIDEzMDMyNDMxLCAxNTA5NTA1MywgMTY2MTY3NjQsIDE2NjI1MjU5LCAxNjYzNDAxOCwgMzI1MzA3NiwgNzY1MjQ3MCwgMTA2MDcwMDMsIDEzMTAxNTA0LCA3Njk1MjgxLCAxMDM5NDMxMiwgMTIzNjkzNzIsIDE0MzQyODkxLCA2NTEzNTA3LCA5ODY4OTUwLCAxMjQzNDg3NywgMTQyNzcwODEgXS5tYXAoZDNfcmdiU3RyaW5nKTtcbiAgZDMuc2NhbGUucXVhbnRpbGUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZDNfc2NhbGVfcXVhbnRpbGUoW10sIFtdKTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfc2NhbGVfcXVhbnRpbGUoZG9tYWluLCByYW5nZSkge1xuICAgIHZhciB0aHJlc2hvbGRzO1xuICAgIGZ1bmN0aW9uIHJlc2NhbGUoKSB7XG4gICAgICB2YXIgayA9IDAsIHEgPSByYW5nZS5sZW5ndGg7XG4gICAgICB0aHJlc2hvbGRzID0gW107XG4gICAgICB3aGlsZSAoKytrIDwgcSkgdGhyZXNob2xkc1trIC0gMV0gPSBkMy5xdWFudGlsZShkb21haW4sIGsgLyBxKTtcbiAgICAgIHJldHVybiBzY2FsZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2NhbGUoeCkge1xuICAgICAgaWYgKCFpc05hTih4ID0gK3gpKSByZXR1cm4gcmFuZ2VbZDMuYmlzZWN0KHRocmVzaG9sZHMsIHgpXTtcbiAgICB9XG4gICAgc2NhbGUuZG9tYWluID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZG9tYWluO1xuICAgICAgZG9tYWluID0geC5tYXAoZDNfbnVtYmVyKS5maWx0ZXIoZDNfbnVtZXJpYykuc29ydChkM19hc2NlbmRpbmcpO1xuICAgICAgcmV0dXJuIHJlc2NhbGUoKTtcbiAgICB9O1xuICAgIHNjYWxlLnJhbmdlID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gcmFuZ2U7XG4gICAgICByYW5nZSA9IHg7XG4gICAgICByZXR1cm4gcmVzY2FsZSgpO1xuICAgIH07XG4gICAgc2NhbGUucXVhbnRpbGVzID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhyZXNob2xkcztcbiAgICB9O1xuICAgIHNjYWxlLmludmVydEV4dGVudCA9IGZ1bmN0aW9uKHkpIHtcbiAgICAgIHkgPSByYW5nZS5pbmRleE9mKHkpO1xuICAgICAgcmV0dXJuIHkgPCAwID8gWyBOYU4sIE5hTiBdIDogWyB5ID4gMCA/IHRocmVzaG9sZHNbeSAtIDFdIDogZG9tYWluWzBdLCB5IDwgdGhyZXNob2xkcy5sZW5ndGggPyB0aHJlc2hvbGRzW3ldIDogZG9tYWluW2RvbWFpbi5sZW5ndGggLSAxXSBdO1xuICAgIH07XG4gICAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGQzX3NjYWxlX3F1YW50aWxlKGRvbWFpbiwgcmFuZ2UpO1xuICAgIH07XG4gICAgcmV0dXJuIHJlc2NhbGUoKTtcbiAgfVxuICBkMy5zY2FsZS5xdWFudGl6ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkM19zY2FsZV9xdWFudGl6ZSgwLCAxLCBbIDAsIDEgXSk7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX3NjYWxlX3F1YW50aXplKHgwLCB4MSwgcmFuZ2UpIHtcbiAgICB2YXIga3gsIGk7XG4gICAgZnVuY3Rpb24gc2NhbGUoeCkge1xuICAgICAgcmV0dXJuIHJhbmdlW01hdGgubWF4KDAsIE1hdGgubWluKGksIE1hdGguZmxvb3Ioa3ggKiAoeCAtIHgwKSkpKV07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc2NhbGUoKSB7XG4gICAgICBreCA9IHJhbmdlLmxlbmd0aCAvICh4MSAtIHgwKTtcbiAgICAgIGkgPSByYW5nZS5sZW5ndGggLSAxO1xuICAgICAgcmV0dXJuIHNjYWxlO1xuICAgIH1cbiAgICBzY2FsZS5kb21haW4gPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBbIHgwLCB4MSBdO1xuICAgICAgeDAgPSAreFswXTtcbiAgICAgIHgxID0gK3hbeC5sZW5ndGggLSAxXTtcbiAgICAgIHJldHVybiByZXNjYWxlKCk7XG4gICAgfTtcbiAgICBzY2FsZS5yYW5nZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHJhbmdlO1xuICAgICAgcmFuZ2UgPSB4O1xuICAgICAgcmV0dXJuIHJlc2NhbGUoKTtcbiAgICB9O1xuICAgIHNjYWxlLmludmVydEV4dGVudCA9IGZ1bmN0aW9uKHkpIHtcbiAgICAgIHkgPSByYW5nZS5pbmRleE9mKHkpO1xuICAgICAgeSA9IHkgPCAwID8gTmFOIDogeSAvIGt4ICsgeDA7XG4gICAgICByZXR1cm4gWyB5LCB5ICsgMSAvIGt4IF07XG4gICAgfTtcbiAgICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZDNfc2NhbGVfcXVhbnRpemUoeDAsIHgxLCByYW5nZSk7XG4gICAgfTtcbiAgICByZXR1cm4gcmVzY2FsZSgpO1xuICB9XG4gIGQzLnNjYWxlLnRocmVzaG9sZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkM19zY2FsZV90aHJlc2hvbGQoWyAuNSBdLCBbIDAsIDEgXSk7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX3NjYWxlX3RocmVzaG9sZChkb21haW4sIHJhbmdlKSB7XG4gICAgZnVuY3Rpb24gc2NhbGUoeCkge1xuICAgICAgaWYgKHggPD0geCkgcmV0dXJuIHJhbmdlW2QzLmJpc2VjdChkb21haW4sIHgpXTtcbiAgICB9XG4gICAgc2NhbGUuZG9tYWluID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZG9tYWluO1xuICAgICAgZG9tYWluID0gXztcbiAgICAgIHJldHVybiBzY2FsZTtcbiAgICB9O1xuICAgIHNjYWxlLnJhbmdlID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gcmFuZ2U7XG4gICAgICByYW5nZSA9IF87XG4gICAgICByZXR1cm4gc2NhbGU7XG4gICAgfTtcbiAgICBzY2FsZS5pbnZlcnRFeHRlbnQgPSBmdW5jdGlvbih5KSB7XG4gICAgICB5ID0gcmFuZ2UuaW5kZXhPZih5KTtcbiAgICAgIHJldHVybiBbIGRvbWFpblt5IC0gMV0sIGRvbWFpblt5XSBdO1xuICAgIH07XG4gICAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGQzX3NjYWxlX3RocmVzaG9sZChkb21haW4sIHJhbmdlKTtcbiAgICB9O1xuICAgIHJldHVybiBzY2FsZTtcbiAgfVxuICBkMy5zY2FsZS5pZGVudGl0eSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkM19zY2FsZV9pZGVudGl0eShbIDAsIDEgXSk7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX3NjYWxlX2lkZW50aXR5KGRvbWFpbikge1xuICAgIGZ1bmN0aW9uIGlkZW50aXR5KHgpIHtcbiAgICAgIHJldHVybiAreDtcbiAgICB9XG4gICAgaWRlbnRpdHkuaW52ZXJ0ID0gaWRlbnRpdHk7XG4gICAgaWRlbnRpdHkuZG9tYWluID0gaWRlbnRpdHkucmFuZ2UgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBkb21haW47XG4gICAgICBkb21haW4gPSB4Lm1hcChpZGVudGl0eSk7XG4gICAgICByZXR1cm4gaWRlbnRpdHk7XG4gICAgfTtcbiAgICBpZGVudGl0eS50aWNrcyA9IGZ1bmN0aW9uKG0pIHtcbiAgICAgIHJldHVybiBkM19zY2FsZV9saW5lYXJUaWNrcyhkb21haW4sIG0pO1xuICAgIH07XG4gICAgaWRlbnRpdHkudGlja0Zvcm1hdCA9IGZ1bmN0aW9uKG0sIGZvcm1hdCkge1xuICAgICAgcmV0dXJuIGQzX3NjYWxlX2xpbmVhclRpY2tGb3JtYXQoZG9tYWluLCBtLCBmb3JtYXQpO1xuICAgIH07XG4gICAgaWRlbnRpdHkuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGQzX3NjYWxlX2lkZW50aXR5KGRvbWFpbik7XG4gICAgfTtcbiAgICByZXR1cm4gaWRlbnRpdHk7XG4gIH1cbiAgZDMuc3ZnID0ge307XG4gIGZ1bmN0aW9uIGQzX3plcm8oKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgZDMuc3ZnLmFyYyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpbm5lclJhZGl1cyA9IGQzX3N2Z19hcmNJbm5lclJhZGl1cywgb3V0ZXJSYWRpdXMgPSBkM19zdmdfYXJjT3V0ZXJSYWRpdXMsIGNvcm5lclJhZGl1cyA9IGQzX3plcm8sIHBhZFJhZGl1cyA9IGQzX3N2Z19hcmNBdXRvLCBzdGFydEFuZ2xlID0gZDNfc3ZnX2FyY1N0YXJ0QW5nbGUsIGVuZEFuZ2xlID0gZDNfc3ZnX2FyY0VuZEFuZ2xlLCBwYWRBbmdsZSA9IGQzX3N2Z19hcmNQYWRBbmdsZTtcbiAgICBmdW5jdGlvbiBhcmMoKSB7XG4gICAgICB2YXIgcjAgPSBNYXRoLm1heCgwLCAraW5uZXJSYWRpdXMuYXBwbHkodGhpcywgYXJndW1lbnRzKSksIHIxID0gTWF0aC5tYXgoMCwgK291dGVyUmFkaXVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpLCBhMCA9IHN0YXJ0QW5nbGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSAtIGhhbGbPgCwgYTEgPSBlbmRBbmdsZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIC0gaGFsZs+ALCBkYSA9IE1hdGguYWJzKGExIC0gYTApLCBjdyA9IGEwID4gYTEgPyAwIDogMTtcbiAgICAgIGlmIChyMSA8IHIwKSByYyA9IHIxLCByMSA9IHIwLCByMCA9IHJjO1xuICAgICAgaWYgKGRhID49IM+EzrUpIHJldHVybiBjaXJjbGVTZWdtZW50KHIxLCBjdykgKyAocjAgPyBjaXJjbGVTZWdtZW50KHIwLCAxIC0gY3cpIDogXCJcIikgKyBcIlpcIjtcbiAgICAgIHZhciByYywgY3IsIHJwLCBhcCwgcDAgPSAwLCBwMSA9IDAsIHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgcGF0aCA9IFtdO1xuICAgICAgaWYgKGFwID0gKCtwYWRBbmdsZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IDApIC8gMikge1xuICAgICAgICBycCA9IHBhZFJhZGl1cyA9PT0gZDNfc3ZnX2FyY0F1dG8gPyBNYXRoLnNxcnQocjAgKiByMCArIHIxICogcjEpIDogK3BhZFJhZGl1cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICBpZiAoIWN3KSBwMSAqPSAtMTtcbiAgICAgICAgaWYgKHIxKSBwMSA9IGQzX2FzaW4ocnAgLyByMSAqIE1hdGguc2luKGFwKSk7XG4gICAgICAgIGlmIChyMCkgcDAgPSBkM19hc2luKHJwIC8gcjAgKiBNYXRoLnNpbihhcCkpO1xuICAgICAgfVxuICAgICAgaWYgKHIxKSB7XG4gICAgICAgIHgwID0gcjEgKiBNYXRoLmNvcyhhMCArIHAxKTtcbiAgICAgICAgeTAgPSByMSAqIE1hdGguc2luKGEwICsgcDEpO1xuICAgICAgICB4MSA9IHIxICogTWF0aC5jb3MoYTEgLSBwMSk7XG4gICAgICAgIHkxID0gcjEgKiBNYXRoLnNpbihhMSAtIHAxKTtcbiAgICAgICAgdmFyIGwxID0gTWF0aC5hYnMoYTEgLSBhMCAtIDIgKiBwMSkgPD0gz4AgPyAwIDogMTtcbiAgICAgICAgaWYgKHAxICYmIGQzX3N2Z19hcmNTd2VlcCh4MCwgeTAsIHgxLCB5MSkgPT09IGN3IF4gbDEpIHtcbiAgICAgICAgICB2YXIgaDEgPSAoYTAgKyBhMSkgLyAyO1xuICAgICAgICAgIHgwID0gcjEgKiBNYXRoLmNvcyhoMSk7XG4gICAgICAgICAgeTAgPSByMSAqIE1hdGguc2luKGgxKTtcbiAgICAgICAgICB4MSA9IHkxID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeDAgPSB5MCA9IDA7XG4gICAgICB9XG4gICAgICBpZiAocjApIHtcbiAgICAgICAgeDIgPSByMCAqIE1hdGguY29zKGExIC0gcDApO1xuICAgICAgICB5MiA9IHIwICogTWF0aC5zaW4oYTEgLSBwMCk7XG4gICAgICAgIHgzID0gcjAgKiBNYXRoLmNvcyhhMCArIHAwKTtcbiAgICAgICAgeTMgPSByMCAqIE1hdGguc2luKGEwICsgcDApO1xuICAgICAgICB2YXIgbDAgPSBNYXRoLmFicyhhMCAtIGExICsgMiAqIHAwKSA8PSDPgCA/IDAgOiAxO1xuICAgICAgICBpZiAocDAgJiYgZDNfc3ZnX2FyY1N3ZWVwKHgyLCB5MiwgeDMsIHkzKSA9PT0gMSAtIGN3IF4gbDApIHtcbiAgICAgICAgICB2YXIgaDAgPSAoYTAgKyBhMSkgLyAyO1xuICAgICAgICAgIHgyID0gcjAgKiBNYXRoLmNvcyhoMCk7XG4gICAgICAgICAgeTIgPSByMCAqIE1hdGguc2luKGgwKTtcbiAgICAgICAgICB4MyA9IHkzID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeDIgPSB5MiA9IDA7XG4gICAgICB9XG4gICAgICBpZiAoZGEgPiDOtSAmJiAocmMgPSBNYXRoLm1pbihNYXRoLmFicyhyMSAtIHIwKSAvIDIsICtjb3JuZXJSYWRpdXMuYXBwbHkodGhpcywgYXJndW1lbnRzKSkpID4gLjAwMSkge1xuICAgICAgICBjciA9IHIwIDwgcjEgXiBjdyA/IDAgOiAxO1xuICAgICAgICB2YXIgcmMxID0gcmMsIHJjMCA9IHJjO1xuICAgICAgICBpZiAoZGEgPCDPgCkge1xuICAgICAgICAgIHZhciBvYyA9IHgzID09IG51bGwgPyBbIHgyLCB5MiBdIDogeDEgPT0gbnVsbCA/IFsgeDAsIHkwIF0gOiBkM19nZW9tX3BvbHlnb25JbnRlcnNlY3QoWyB4MCwgeTAgXSwgWyB4MywgeTMgXSwgWyB4MSwgeTEgXSwgWyB4MiwgeTIgXSksIGF4ID0geDAgLSBvY1swXSwgYXkgPSB5MCAtIG9jWzFdLCBieCA9IHgxIC0gb2NbMF0sIGJ5ID0geTEgLSBvY1sxXSwga2MgPSAxIC8gTWF0aC5zaW4oTWF0aC5hY29zKChheCAqIGJ4ICsgYXkgKiBieSkgLyAoTWF0aC5zcXJ0KGF4ICogYXggKyBheSAqIGF5KSAqIE1hdGguc3FydChieCAqIGJ4ICsgYnkgKiBieSkpKSAvIDIpLCBsYyA9IE1hdGguc3FydChvY1swXSAqIG9jWzBdICsgb2NbMV0gKiBvY1sxXSk7XG4gICAgICAgICAgcmMwID0gTWF0aC5taW4ocmMsIChyMCAtIGxjKSAvIChrYyAtIDEpKTtcbiAgICAgICAgICByYzEgPSBNYXRoLm1pbihyYywgKHIxIC0gbGMpIC8gKGtjICsgMSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh4MSAhPSBudWxsKSB7XG4gICAgICAgICAgdmFyIHQzMCA9IGQzX3N2Z19hcmNDb3JuZXJUYW5nZW50cyh4MyA9PSBudWxsID8gWyB4MiwgeTIgXSA6IFsgeDMsIHkzIF0sIFsgeDAsIHkwIF0sIHIxLCByYzEsIGN3KSwgdDEyID0gZDNfc3ZnX2FyY0Nvcm5lclRhbmdlbnRzKFsgeDEsIHkxIF0sIFsgeDIsIHkyIF0sIHIxLCByYzEsIGN3KTtcbiAgICAgICAgICBpZiAocmMgPT09IHJjMSkge1xuICAgICAgICAgICAgcGF0aC5wdXNoKFwiTVwiLCB0MzBbMF0sIFwiQVwiLCByYzEsIFwiLFwiLCByYzEsIFwiIDAgMCxcIiwgY3IsIFwiIFwiLCB0MzBbMV0sIFwiQVwiLCByMSwgXCIsXCIsIHIxLCBcIiAwIFwiLCAxIC0gY3cgXiBkM19zdmdfYXJjU3dlZXAodDMwWzFdWzBdLCB0MzBbMV1bMV0sIHQxMlsxXVswXSwgdDEyWzFdWzFdKSwgXCIsXCIsIGN3LCBcIiBcIiwgdDEyWzFdLCBcIkFcIiwgcmMxLCBcIixcIiwgcmMxLCBcIiAwIDAsXCIsIGNyLCBcIiBcIiwgdDEyWzBdKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGF0aC5wdXNoKFwiTVwiLCB0MzBbMF0sIFwiQVwiLCByYzEsIFwiLFwiLCByYzEsIFwiIDAgMSxcIiwgY3IsIFwiIFwiLCB0MTJbMF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXRoLnB1c2goXCJNXCIsIHgwLCBcIixcIiwgeTApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh4MyAhPSBudWxsKSB7XG4gICAgICAgICAgdmFyIHQwMyA9IGQzX3N2Z19hcmNDb3JuZXJUYW5nZW50cyhbIHgwLCB5MCBdLCBbIHgzLCB5MyBdLCByMCwgLXJjMCwgY3cpLCB0MjEgPSBkM19zdmdfYXJjQ29ybmVyVGFuZ2VudHMoWyB4MiwgeTIgXSwgeDEgPT0gbnVsbCA/IFsgeDAsIHkwIF0gOiBbIHgxLCB5MSBdLCByMCwgLXJjMCwgY3cpO1xuICAgICAgICAgIGlmIChyYyA9PT0gcmMwKSB7XG4gICAgICAgICAgICBwYXRoLnB1c2goXCJMXCIsIHQyMVswXSwgXCJBXCIsIHJjMCwgXCIsXCIsIHJjMCwgXCIgMCAwLFwiLCBjciwgXCIgXCIsIHQyMVsxXSwgXCJBXCIsIHIwLCBcIixcIiwgcjAsIFwiIDAgXCIsIGN3IF4gZDNfc3ZnX2FyY1N3ZWVwKHQyMVsxXVswXSwgdDIxWzFdWzFdLCB0MDNbMV1bMF0sIHQwM1sxXVsxXSksIFwiLFwiLCAxIC0gY3csIFwiIFwiLCB0MDNbMV0sIFwiQVwiLCByYzAsIFwiLFwiLCByYzAsIFwiIDAgMCxcIiwgY3IsIFwiIFwiLCB0MDNbMF0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXRoLnB1c2goXCJMXCIsIHQyMVswXSwgXCJBXCIsIHJjMCwgXCIsXCIsIHJjMCwgXCIgMCAwLFwiLCBjciwgXCIgXCIsIHQwM1swXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhdGgucHVzaChcIkxcIiwgeDIsIFwiLFwiLCB5Mik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhdGgucHVzaChcIk1cIiwgeDAsIFwiLFwiLCB5MCk7XG4gICAgICAgIGlmICh4MSAhPSBudWxsKSBwYXRoLnB1c2goXCJBXCIsIHIxLCBcIixcIiwgcjEsIFwiIDAgXCIsIGwxLCBcIixcIiwgY3csIFwiIFwiLCB4MSwgXCIsXCIsIHkxKTtcbiAgICAgICAgcGF0aC5wdXNoKFwiTFwiLCB4MiwgXCIsXCIsIHkyKTtcbiAgICAgICAgaWYgKHgzICE9IG51bGwpIHBhdGgucHVzaChcIkFcIiwgcjAsIFwiLFwiLCByMCwgXCIgMCBcIiwgbDAsIFwiLFwiLCAxIC0gY3csIFwiIFwiLCB4MywgXCIsXCIsIHkzKTtcbiAgICAgIH1cbiAgICAgIHBhdGgucHVzaChcIlpcIik7XG4gICAgICByZXR1cm4gcGF0aC5qb2luKFwiXCIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjaXJjbGVTZWdtZW50KHIxLCBjdykge1xuICAgICAgcmV0dXJuIFwiTTAsXCIgKyByMSArIFwiQVwiICsgcjEgKyBcIixcIiArIHIxICsgXCIgMCAxLFwiICsgY3cgKyBcIiAwLFwiICsgLXIxICsgXCJBXCIgKyByMSArIFwiLFwiICsgcjEgKyBcIiAwIDEsXCIgKyBjdyArIFwiIDAsXCIgKyByMTtcbiAgICB9XG4gICAgYXJjLmlubmVyUmFkaXVzID0gZnVuY3Rpb24odikge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gaW5uZXJSYWRpdXM7XG4gICAgICBpbm5lclJhZGl1cyA9IGQzX2Z1bmN0b3Iodik7XG4gICAgICByZXR1cm4gYXJjO1xuICAgIH07XG4gICAgYXJjLm91dGVyUmFkaXVzID0gZnVuY3Rpb24odikge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gb3V0ZXJSYWRpdXM7XG4gICAgICBvdXRlclJhZGl1cyA9IGQzX2Z1bmN0b3Iodik7XG4gICAgICByZXR1cm4gYXJjO1xuICAgIH07XG4gICAgYXJjLmNvcm5lclJhZGl1cyA9IGZ1bmN0aW9uKHYpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGNvcm5lclJhZGl1cztcbiAgICAgIGNvcm5lclJhZGl1cyA9IGQzX2Z1bmN0b3Iodik7XG4gICAgICByZXR1cm4gYXJjO1xuICAgIH07XG4gICAgYXJjLnBhZFJhZGl1cyA9IGZ1bmN0aW9uKHYpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHBhZFJhZGl1cztcbiAgICAgIHBhZFJhZGl1cyA9IHYgPT0gZDNfc3ZnX2FyY0F1dG8gPyBkM19zdmdfYXJjQXV0byA6IGQzX2Z1bmN0b3Iodik7XG4gICAgICByZXR1cm4gYXJjO1xuICAgIH07XG4gICAgYXJjLnN0YXJ0QW5nbGUgPSBmdW5jdGlvbih2KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBzdGFydEFuZ2xlO1xuICAgICAgc3RhcnRBbmdsZSA9IGQzX2Z1bmN0b3Iodik7XG4gICAgICByZXR1cm4gYXJjO1xuICAgIH07XG4gICAgYXJjLmVuZEFuZ2xlID0gZnVuY3Rpb24odikge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZW5kQW5nbGU7XG4gICAgICBlbmRBbmdsZSA9IGQzX2Z1bmN0b3Iodik7XG4gICAgICByZXR1cm4gYXJjO1xuICAgIH07XG4gICAgYXJjLnBhZEFuZ2xlID0gZnVuY3Rpb24odikge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gcGFkQW5nbGU7XG4gICAgICBwYWRBbmdsZSA9IGQzX2Z1bmN0b3Iodik7XG4gICAgICByZXR1cm4gYXJjO1xuICAgIH07XG4gICAgYXJjLmNlbnRyb2lkID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgciA9ICgraW5uZXJSYWRpdXMuYXBwbHkodGhpcywgYXJndW1lbnRzKSArICtvdXRlclJhZGl1cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpKSAvIDIsIGEgPSAoK3N0YXJ0QW5nbGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSArICtlbmRBbmdsZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKSAvIDIgLSBoYWxmz4A7XG4gICAgICByZXR1cm4gWyBNYXRoLmNvcyhhKSAqIHIsIE1hdGguc2luKGEpICogciBdO1xuICAgIH07XG4gICAgcmV0dXJuIGFyYztcbiAgfTtcbiAgdmFyIGQzX3N2Z19hcmNBdXRvID0gXCJhdXRvXCI7XG4gIGZ1bmN0aW9uIGQzX3N2Z19hcmNJbm5lclJhZGl1cyhkKSB7XG4gICAgcmV0dXJuIGQuaW5uZXJSYWRpdXM7XG4gIH1cbiAgZnVuY3Rpb24gZDNfc3ZnX2FyY091dGVyUmFkaXVzKGQpIHtcbiAgICByZXR1cm4gZC5vdXRlclJhZGl1cztcbiAgfVxuICBmdW5jdGlvbiBkM19zdmdfYXJjU3RhcnRBbmdsZShkKSB7XG4gICAgcmV0dXJuIGQuc3RhcnRBbmdsZTtcbiAgfVxuICBmdW5jdGlvbiBkM19zdmdfYXJjRW5kQW5nbGUoZCkge1xuICAgIHJldHVybiBkLmVuZEFuZ2xlO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3N2Z19hcmNQYWRBbmdsZShkKSB7XG4gICAgcmV0dXJuIGQgJiYgZC5wYWRBbmdsZTtcbiAgfVxuICBmdW5jdGlvbiBkM19zdmdfYXJjU3dlZXAoeDAsIHkwLCB4MSwgeTEpIHtcbiAgICByZXR1cm4gKHgwIC0geDEpICogeTAgLSAoeTAgLSB5MSkgKiB4MCA+IDAgPyAwIDogMTtcbiAgfVxuICBmdW5jdGlvbiBkM19zdmdfYXJjQ29ybmVyVGFuZ2VudHMocDAsIHAxLCByMSwgcmMsIGN3KSB7XG4gICAgdmFyIHgwMSA9IHAwWzBdIC0gcDFbMF0sIHkwMSA9IHAwWzFdIC0gcDFbMV0sIGxvID0gKGN3ID8gcmMgOiAtcmMpIC8gTWF0aC5zcXJ0KHgwMSAqIHgwMSArIHkwMSAqIHkwMSksIG94ID0gbG8gKiB5MDEsIG95ID0gLWxvICogeDAxLCB4MSA9IHAwWzBdICsgb3gsIHkxID0gcDBbMV0gKyBveSwgeDIgPSBwMVswXSArIG94LCB5MiA9IHAxWzFdICsgb3ksIHgzID0gKHgxICsgeDIpIC8gMiwgeTMgPSAoeTEgKyB5MikgLyAyLCBkeCA9IHgyIC0geDEsIGR5ID0geTIgLSB5MSwgZDIgPSBkeCAqIGR4ICsgZHkgKiBkeSwgciA9IHIxIC0gcmMsIEQgPSB4MSAqIHkyIC0geDIgKiB5MSwgZCA9IChkeSA8IDAgPyAtMSA6IDEpICogTWF0aC5zcXJ0KE1hdGgubWF4KDAsIHIgKiByICogZDIgLSBEICogRCkpLCBjeDAgPSAoRCAqIGR5IC0gZHggKiBkKSAvIGQyLCBjeTAgPSAoLUQgKiBkeCAtIGR5ICogZCkgLyBkMiwgY3gxID0gKEQgKiBkeSArIGR4ICogZCkgLyBkMiwgY3kxID0gKC1EICogZHggKyBkeSAqIGQpIC8gZDIsIGR4MCA9IGN4MCAtIHgzLCBkeTAgPSBjeTAgLSB5MywgZHgxID0gY3gxIC0geDMsIGR5MSA9IGN5MSAtIHkzO1xuICAgIGlmIChkeDAgKiBkeDAgKyBkeTAgKiBkeTAgPiBkeDEgKiBkeDEgKyBkeTEgKiBkeTEpIGN4MCA9IGN4MSwgY3kwID0gY3kxO1xuICAgIHJldHVybiBbIFsgY3gwIC0gb3gsIGN5MCAtIG95IF0sIFsgY3gwICogcjEgLyByLCBjeTAgKiByMSAvIHIgXSBdO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3N2Z19saW5lKHByb2plY3Rpb24pIHtcbiAgICB2YXIgeCA9IGQzX2dlb21fcG9pbnRYLCB5ID0gZDNfZ2VvbV9wb2ludFksIGRlZmluZWQgPSBkM190cnVlLCBpbnRlcnBvbGF0ZSA9IGQzX3N2Z19saW5lTGluZWFyLCBpbnRlcnBvbGF0ZUtleSA9IGludGVycG9sYXRlLmtleSwgdGVuc2lvbiA9IC43O1xuICAgIGZ1bmN0aW9uIGxpbmUoZGF0YSkge1xuICAgICAgdmFyIHNlZ21lbnRzID0gW10sIHBvaW50cyA9IFtdLCBpID0gLTEsIG4gPSBkYXRhLmxlbmd0aCwgZCwgZnggPSBkM19mdW5jdG9yKHgpLCBmeSA9IGQzX2Z1bmN0b3IoeSk7XG4gICAgICBmdW5jdGlvbiBzZWdtZW50KCkge1xuICAgICAgICBzZWdtZW50cy5wdXNoKFwiTVwiLCBpbnRlcnBvbGF0ZShwcm9qZWN0aW9uKHBvaW50cyksIHRlbnNpb24pKTtcbiAgICAgIH1cbiAgICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgIGlmIChkZWZpbmVkLmNhbGwodGhpcywgZCA9IGRhdGFbaV0sIGkpKSB7XG4gICAgICAgICAgcG9pbnRzLnB1c2goWyArZnguY2FsbCh0aGlzLCBkLCBpKSwgK2Z5LmNhbGwodGhpcywgZCwgaSkgXSk7XG4gICAgICAgIH0gZWxzZSBpZiAocG9pbnRzLmxlbmd0aCkge1xuICAgICAgICAgIHNlZ21lbnQoKTtcbiAgICAgICAgICBwb2ludHMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHBvaW50cy5sZW5ndGgpIHNlZ21lbnQoKTtcbiAgICAgIHJldHVybiBzZWdtZW50cy5sZW5ndGggPyBzZWdtZW50cy5qb2luKFwiXCIpIDogbnVsbDtcbiAgICB9XG4gICAgbGluZS54ID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4geDtcbiAgICAgIHggPSBfO1xuICAgICAgcmV0dXJuIGxpbmU7XG4gICAgfTtcbiAgICBsaW5lLnkgPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB5O1xuICAgICAgeSA9IF87XG4gICAgICByZXR1cm4gbGluZTtcbiAgICB9O1xuICAgIGxpbmUuZGVmaW5lZCA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGRlZmluZWQ7XG4gICAgICBkZWZpbmVkID0gXztcbiAgICAgIHJldHVybiBsaW5lO1xuICAgIH07XG4gICAgbGluZS5pbnRlcnBvbGF0ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGludGVycG9sYXRlS2V5O1xuICAgICAgaWYgKHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIpIGludGVycG9sYXRlS2V5ID0gaW50ZXJwb2xhdGUgPSBfOyBlbHNlIGludGVycG9sYXRlS2V5ID0gKGludGVycG9sYXRlID0gZDNfc3ZnX2xpbmVJbnRlcnBvbGF0b3JzLmdldChfKSB8fCBkM19zdmdfbGluZUxpbmVhcikua2V5O1xuICAgICAgcmV0dXJuIGxpbmU7XG4gICAgfTtcbiAgICBsaW5lLnRlbnNpb24gPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0ZW5zaW9uO1xuICAgICAgdGVuc2lvbiA9IF87XG4gICAgICByZXR1cm4gbGluZTtcbiAgICB9O1xuICAgIHJldHVybiBsaW5lO1xuICB9XG4gIGQzLnN2Zy5saW5lID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGQzX3N2Z19saW5lKGQzX2lkZW50aXR5KTtcbiAgfTtcbiAgdmFyIGQzX3N2Z19saW5lSW50ZXJwb2xhdG9ycyA9IGQzLm1hcCh7XG4gICAgbGluZWFyOiBkM19zdmdfbGluZUxpbmVhcixcbiAgICBcImxpbmVhci1jbG9zZWRcIjogZDNfc3ZnX2xpbmVMaW5lYXJDbG9zZWQsXG4gICAgc3RlcDogZDNfc3ZnX2xpbmVTdGVwLFxuICAgIFwic3RlcC1iZWZvcmVcIjogZDNfc3ZnX2xpbmVTdGVwQmVmb3JlLFxuICAgIFwic3RlcC1hZnRlclwiOiBkM19zdmdfbGluZVN0ZXBBZnRlcixcbiAgICBiYXNpczogZDNfc3ZnX2xpbmVCYXNpcyxcbiAgICBcImJhc2lzLW9wZW5cIjogZDNfc3ZnX2xpbmVCYXNpc09wZW4sXG4gICAgXCJiYXNpcy1jbG9zZWRcIjogZDNfc3ZnX2xpbmVCYXNpc0Nsb3NlZCxcbiAgICBidW5kbGU6IGQzX3N2Z19saW5lQnVuZGxlLFxuICAgIGNhcmRpbmFsOiBkM19zdmdfbGluZUNhcmRpbmFsLFxuICAgIFwiY2FyZGluYWwtb3BlblwiOiBkM19zdmdfbGluZUNhcmRpbmFsT3BlbixcbiAgICBcImNhcmRpbmFsLWNsb3NlZFwiOiBkM19zdmdfbGluZUNhcmRpbmFsQ2xvc2VkLFxuICAgIG1vbm90b25lOiBkM19zdmdfbGluZU1vbm90b25lXG4gIH0pO1xuICBkM19zdmdfbGluZUludGVycG9sYXRvcnMuZm9yRWFjaChmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgdmFsdWUua2V5ID0ga2V5O1xuICAgIHZhbHVlLmNsb3NlZCA9IC8tY2xvc2VkJC8udGVzdChrZXkpO1xuICB9KTtcbiAgZnVuY3Rpb24gZDNfc3ZnX2xpbmVMaW5lYXIocG9pbnRzKSB7XG4gICAgcmV0dXJuIHBvaW50cy5sZW5ndGggPiAxID8gcG9pbnRzLmpvaW4oXCJMXCIpIDogcG9pbnRzICsgXCJaXCI7XG4gIH1cbiAgZnVuY3Rpb24gZDNfc3ZnX2xpbmVMaW5lYXJDbG9zZWQocG9pbnRzKSB7XG4gICAgcmV0dXJuIHBvaW50cy5qb2luKFwiTFwiKSArIFwiWlwiO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3N2Z19saW5lU3RlcChwb2ludHMpIHtcbiAgICB2YXIgaSA9IDAsIG4gPSBwb2ludHMubGVuZ3RoLCBwID0gcG9pbnRzWzBdLCBwYXRoID0gWyBwWzBdLCBcIixcIiwgcFsxXSBdO1xuICAgIHdoaWxlICgrK2kgPCBuKSBwYXRoLnB1c2goXCJIXCIsIChwWzBdICsgKHAgPSBwb2ludHNbaV0pWzBdKSAvIDIsIFwiVlwiLCBwWzFdKTtcbiAgICBpZiAobiA+IDEpIHBhdGgucHVzaChcIkhcIiwgcFswXSk7XG4gICAgcmV0dXJuIHBhdGguam9pbihcIlwiKTtcbiAgfVxuICBmdW5jdGlvbiBkM19zdmdfbGluZVN0ZXBCZWZvcmUocG9pbnRzKSB7XG4gICAgdmFyIGkgPSAwLCBuID0gcG9pbnRzLmxlbmd0aCwgcCA9IHBvaW50c1swXSwgcGF0aCA9IFsgcFswXSwgXCIsXCIsIHBbMV0gXTtcbiAgICB3aGlsZSAoKytpIDwgbikgcGF0aC5wdXNoKFwiVlwiLCAocCA9IHBvaW50c1tpXSlbMV0sIFwiSFwiLCBwWzBdKTtcbiAgICByZXR1cm4gcGF0aC5qb2luKFwiXCIpO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3N2Z19saW5lU3RlcEFmdGVyKHBvaW50cykge1xuICAgIHZhciBpID0gMCwgbiA9IHBvaW50cy5sZW5ndGgsIHAgPSBwb2ludHNbMF0sIHBhdGggPSBbIHBbMF0sIFwiLFwiLCBwWzFdIF07XG4gICAgd2hpbGUgKCsraSA8IG4pIHBhdGgucHVzaChcIkhcIiwgKHAgPSBwb2ludHNbaV0pWzBdLCBcIlZcIiwgcFsxXSk7XG4gICAgcmV0dXJuIHBhdGguam9pbihcIlwiKTtcbiAgfVxuICBmdW5jdGlvbiBkM19zdmdfbGluZUNhcmRpbmFsT3Blbihwb2ludHMsIHRlbnNpb24pIHtcbiAgICByZXR1cm4gcG9pbnRzLmxlbmd0aCA8IDQgPyBkM19zdmdfbGluZUxpbmVhcihwb2ludHMpIDogcG9pbnRzWzFdICsgZDNfc3ZnX2xpbmVIZXJtaXRlKHBvaW50cy5zbGljZSgxLCAtMSksIGQzX3N2Z19saW5lQ2FyZGluYWxUYW5nZW50cyhwb2ludHMsIHRlbnNpb24pKTtcbiAgfVxuICBmdW5jdGlvbiBkM19zdmdfbGluZUNhcmRpbmFsQ2xvc2VkKHBvaW50cywgdGVuc2lvbikge1xuICAgIHJldHVybiBwb2ludHMubGVuZ3RoIDwgMyA/IGQzX3N2Z19saW5lTGluZWFyQ2xvc2VkKHBvaW50cykgOiBwb2ludHNbMF0gKyBkM19zdmdfbGluZUhlcm1pdGUoKHBvaW50cy5wdXNoKHBvaW50c1swXSksIFxuICAgIHBvaW50cyksIGQzX3N2Z19saW5lQ2FyZGluYWxUYW5nZW50cyhbIHBvaW50c1twb2ludHMubGVuZ3RoIC0gMl0gXS5jb25jYXQocG9pbnRzLCBbIHBvaW50c1sxXSBdKSwgdGVuc2lvbikpO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3N2Z19saW5lQ2FyZGluYWwocG9pbnRzLCB0ZW5zaW9uKSB7XG4gICAgcmV0dXJuIHBvaW50cy5sZW5ndGggPCAzID8gZDNfc3ZnX2xpbmVMaW5lYXIocG9pbnRzKSA6IHBvaW50c1swXSArIGQzX3N2Z19saW5lSGVybWl0ZShwb2ludHMsIGQzX3N2Z19saW5lQ2FyZGluYWxUYW5nZW50cyhwb2ludHMsIHRlbnNpb24pKTtcbiAgfVxuICBmdW5jdGlvbiBkM19zdmdfbGluZUhlcm1pdGUocG9pbnRzLCB0YW5nZW50cykge1xuICAgIGlmICh0YW5nZW50cy5sZW5ndGggPCAxIHx8IHBvaW50cy5sZW5ndGggIT0gdGFuZ2VudHMubGVuZ3RoICYmIHBvaW50cy5sZW5ndGggIT0gdGFuZ2VudHMubGVuZ3RoICsgMikge1xuICAgICAgcmV0dXJuIGQzX3N2Z19saW5lTGluZWFyKHBvaW50cyk7XG4gICAgfVxuICAgIHZhciBxdWFkID0gcG9pbnRzLmxlbmd0aCAhPSB0YW5nZW50cy5sZW5ndGgsIHBhdGggPSBcIlwiLCBwMCA9IHBvaW50c1swXSwgcCA9IHBvaW50c1sxXSwgdDAgPSB0YW5nZW50c1swXSwgdCA9IHQwLCBwaSA9IDE7XG4gICAgaWYgKHF1YWQpIHtcbiAgICAgIHBhdGggKz0gXCJRXCIgKyAocFswXSAtIHQwWzBdICogMiAvIDMpICsgXCIsXCIgKyAocFsxXSAtIHQwWzFdICogMiAvIDMpICsgXCIsXCIgKyBwWzBdICsgXCIsXCIgKyBwWzFdO1xuICAgICAgcDAgPSBwb2ludHNbMV07XG4gICAgICBwaSA9IDI7XG4gICAgfVxuICAgIGlmICh0YW5nZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICB0ID0gdGFuZ2VudHNbMV07XG4gICAgICBwID0gcG9pbnRzW3BpXTtcbiAgICAgIHBpKys7XG4gICAgICBwYXRoICs9IFwiQ1wiICsgKHAwWzBdICsgdDBbMF0pICsgXCIsXCIgKyAocDBbMV0gKyB0MFsxXSkgKyBcIixcIiArIChwWzBdIC0gdFswXSkgKyBcIixcIiArIChwWzFdIC0gdFsxXSkgKyBcIixcIiArIHBbMF0gKyBcIixcIiArIHBbMV07XG4gICAgICBmb3IgKHZhciBpID0gMjsgaSA8IHRhbmdlbnRzLmxlbmd0aDsgaSsrLCBwaSsrKSB7XG4gICAgICAgIHAgPSBwb2ludHNbcGldO1xuICAgICAgICB0ID0gdGFuZ2VudHNbaV07XG4gICAgICAgIHBhdGggKz0gXCJTXCIgKyAocFswXSAtIHRbMF0pICsgXCIsXCIgKyAocFsxXSAtIHRbMV0pICsgXCIsXCIgKyBwWzBdICsgXCIsXCIgKyBwWzFdO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocXVhZCkge1xuICAgICAgdmFyIGxwID0gcG9pbnRzW3BpXTtcbiAgICAgIHBhdGggKz0gXCJRXCIgKyAocFswXSArIHRbMF0gKiAyIC8gMykgKyBcIixcIiArIChwWzFdICsgdFsxXSAqIDIgLyAzKSArIFwiLFwiICsgbHBbMF0gKyBcIixcIiArIGxwWzFdO1xuICAgIH1cbiAgICByZXR1cm4gcGF0aDtcbiAgfVxuICBmdW5jdGlvbiBkM19zdmdfbGluZUNhcmRpbmFsVGFuZ2VudHMocG9pbnRzLCB0ZW5zaW9uKSB7XG4gICAgdmFyIHRhbmdlbnRzID0gW10sIGEgPSAoMSAtIHRlbnNpb24pIC8gMiwgcDAsIHAxID0gcG9pbnRzWzBdLCBwMiA9IHBvaW50c1sxXSwgaSA9IDEsIG4gPSBwb2ludHMubGVuZ3RoO1xuICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICBwMCA9IHAxO1xuICAgICAgcDEgPSBwMjtcbiAgICAgIHAyID0gcG9pbnRzW2ldO1xuICAgICAgdGFuZ2VudHMucHVzaChbIGEgKiAocDJbMF0gLSBwMFswXSksIGEgKiAocDJbMV0gLSBwMFsxXSkgXSk7XG4gICAgfVxuICAgIHJldHVybiB0YW5nZW50cztcbiAgfVxuICBmdW5jdGlvbiBkM19zdmdfbGluZUJhc2lzKHBvaW50cykge1xuICAgIGlmIChwb2ludHMubGVuZ3RoIDwgMykgcmV0dXJuIGQzX3N2Z19saW5lTGluZWFyKHBvaW50cyk7XG4gICAgdmFyIGkgPSAxLCBuID0gcG9pbnRzLmxlbmd0aCwgcGkgPSBwb2ludHNbMF0sIHgwID0gcGlbMF0sIHkwID0gcGlbMV0sIHB4ID0gWyB4MCwgeDAsIHgwLCAocGkgPSBwb2ludHNbMV0pWzBdIF0sIHB5ID0gWyB5MCwgeTAsIHkwLCBwaVsxXSBdLCBwYXRoID0gWyB4MCwgXCIsXCIsIHkwLCBcIkxcIiwgZDNfc3ZnX2xpbmVEb3Q0KGQzX3N2Z19saW5lQmFzaXNCZXppZXIzLCBweCksIFwiLFwiLCBkM19zdmdfbGluZURvdDQoZDNfc3ZnX2xpbmVCYXNpc0JlemllcjMsIHB5KSBdO1xuICAgIHBvaW50cy5wdXNoKHBvaW50c1tuIC0gMV0pO1xuICAgIHdoaWxlICgrK2kgPD0gbikge1xuICAgICAgcGkgPSBwb2ludHNbaV07XG4gICAgICBweC5zaGlmdCgpO1xuICAgICAgcHgucHVzaChwaVswXSk7XG4gICAgICBweS5zaGlmdCgpO1xuICAgICAgcHkucHVzaChwaVsxXSk7XG4gICAgICBkM19zdmdfbGluZUJhc2lzQmV6aWVyKHBhdGgsIHB4LCBweSk7XG4gICAgfVxuICAgIHBvaW50cy5wb3AoKTtcbiAgICBwYXRoLnB1c2goXCJMXCIsIHBpKTtcbiAgICByZXR1cm4gcGF0aC5qb2luKFwiXCIpO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3N2Z19saW5lQmFzaXNPcGVuKHBvaW50cykge1xuICAgIGlmIChwb2ludHMubGVuZ3RoIDwgNCkgcmV0dXJuIGQzX3N2Z19saW5lTGluZWFyKHBvaW50cyk7XG4gICAgdmFyIHBhdGggPSBbXSwgaSA9IC0xLCBuID0gcG9pbnRzLmxlbmd0aCwgcGksIHB4ID0gWyAwIF0sIHB5ID0gWyAwIF07XG4gICAgd2hpbGUgKCsraSA8IDMpIHtcbiAgICAgIHBpID0gcG9pbnRzW2ldO1xuICAgICAgcHgucHVzaChwaVswXSk7XG4gICAgICBweS5wdXNoKHBpWzFdKTtcbiAgICB9XG4gICAgcGF0aC5wdXNoKGQzX3N2Z19saW5lRG90NChkM19zdmdfbGluZUJhc2lzQmV6aWVyMywgcHgpICsgXCIsXCIgKyBkM19zdmdfbGluZURvdDQoZDNfc3ZnX2xpbmVCYXNpc0JlemllcjMsIHB5KSk7XG4gICAgLS1pO1xuICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICBwaSA9IHBvaW50c1tpXTtcbiAgICAgIHB4LnNoaWZ0KCk7XG4gICAgICBweC5wdXNoKHBpWzBdKTtcbiAgICAgIHB5LnNoaWZ0KCk7XG4gICAgICBweS5wdXNoKHBpWzFdKTtcbiAgICAgIGQzX3N2Z19saW5lQmFzaXNCZXppZXIocGF0aCwgcHgsIHB5KTtcbiAgICB9XG4gICAgcmV0dXJuIHBhdGguam9pbihcIlwiKTtcbiAgfVxuICBmdW5jdGlvbiBkM19zdmdfbGluZUJhc2lzQ2xvc2VkKHBvaW50cykge1xuICAgIHZhciBwYXRoLCBpID0gLTEsIG4gPSBwb2ludHMubGVuZ3RoLCBtID0gbiArIDQsIHBpLCBweCA9IFtdLCBweSA9IFtdO1xuICAgIHdoaWxlICgrK2kgPCA0KSB7XG4gICAgICBwaSA9IHBvaW50c1tpICUgbl07XG4gICAgICBweC5wdXNoKHBpWzBdKTtcbiAgICAgIHB5LnB1c2gocGlbMV0pO1xuICAgIH1cbiAgICBwYXRoID0gWyBkM19zdmdfbGluZURvdDQoZDNfc3ZnX2xpbmVCYXNpc0JlemllcjMsIHB4KSwgXCIsXCIsIGQzX3N2Z19saW5lRG90NChkM19zdmdfbGluZUJhc2lzQmV6aWVyMywgcHkpIF07XG4gICAgLS1pO1xuICAgIHdoaWxlICgrK2kgPCBtKSB7XG4gICAgICBwaSA9IHBvaW50c1tpICUgbl07XG4gICAgICBweC5zaGlmdCgpO1xuICAgICAgcHgucHVzaChwaVswXSk7XG4gICAgICBweS5zaGlmdCgpO1xuICAgICAgcHkucHVzaChwaVsxXSk7XG4gICAgICBkM19zdmdfbGluZUJhc2lzQmV6aWVyKHBhdGgsIHB4LCBweSk7XG4gICAgfVxuICAgIHJldHVybiBwYXRoLmpvaW4oXCJcIik7XG4gIH1cbiAgZnVuY3Rpb24gZDNfc3ZnX2xpbmVCdW5kbGUocG9pbnRzLCB0ZW5zaW9uKSB7XG4gICAgdmFyIG4gPSBwb2ludHMubGVuZ3RoIC0gMTtcbiAgICBpZiAobikge1xuICAgICAgdmFyIHgwID0gcG9pbnRzWzBdWzBdLCB5MCA9IHBvaW50c1swXVsxXSwgZHggPSBwb2ludHNbbl1bMF0gLSB4MCwgZHkgPSBwb2ludHNbbl1bMV0gLSB5MCwgaSA9IC0xLCBwLCB0O1xuICAgICAgd2hpbGUgKCsraSA8PSBuKSB7XG4gICAgICAgIHAgPSBwb2ludHNbaV07XG4gICAgICAgIHQgPSBpIC8gbjtcbiAgICAgICAgcFswXSA9IHRlbnNpb24gKiBwWzBdICsgKDEgLSB0ZW5zaW9uKSAqICh4MCArIHQgKiBkeCk7XG4gICAgICAgIHBbMV0gPSB0ZW5zaW9uICogcFsxXSArICgxIC0gdGVuc2lvbikgKiAoeTAgKyB0ICogZHkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZDNfc3ZnX2xpbmVCYXNpcyhwb2ludHMpO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3N2Z19saW5lRG90NChhLCBiKSB7XG4gICAgcmV0dXJuIGFbMF0gKiBiWzBdICsgYVsxXSAqIGJbMV0gKyBhWzJdICogYlsyXSArIGFbM10gKiBiWzNdO1xuICB9XG4gIHZhciBkM19zdmdfbGluZUJhc2lzQmV6aWVyMSA9IFsgMCwgMiAvIDMsIDEgLyAzLCAwIF0sIGQzX3N2Z19saW5lQmFzaXNCZXppZXIyID0gWyAwLCAxIC8gMywgMiAvIDMsIDAgXSwgZDNfc3ZnX2xpbmVCYXNpc0JlemllcjMgPSBbIDAsIDEgLyA2LCAyIC8gMywgMSAvIDYgXTtcbiAgZnVuY3Rpb24gZDNfc3ZnX2xpbmVCYXNpc0JlemllcihwYXRoLCB4LCB5KSB7XG4gICAgcGF0aC5wdXNoKFwiQ1wiLCBkM19zdmdfbGluZURvdDQoZDNfc3ZnX2xpbmVCYXNpc0JlemllcjEsIHgpLCBcIixcIiwgZDNfc3ZnX2xpbmVEb3Q0KGQzX3N2Z19saW5lQmFzaXNCZXppZXIxLCB5KSwgXCIsXCIsIGQzX3N2Z19saW5lRG90NChkM19zdmdfbGluZUJhc2lzQmV6aWVyMiwgeCksIFwiLFwiLCBkM19zdmdfbGluZURvdDQoZDNfc3ZnX2xpbmVCYXNpc0JlemllcjIsIHkpLCBcIixcIiwgZDNfc3ZnX2xpbmVEb3Q0KGQzX3N2Z19saW5lQmFzaXNCZXppZXIzLCB4KSwgXCIsXCIsIGQzX3N2Z19saW5lRG90NChkM19zdmdfbGluZUJhc2lzQmV6aWVyMywgeSkpO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3N2Z19saW5lU2xvcGUocDAsIHAxKSB7XG4gICAgcmV0dXJuIChwMVsxXSAtIHAwWzFdKSAvIChwMVswXSAtIHAwWzBdKTtcbiAgfVxuICBmdW5jdGlvbiBkM19zdmdfbGluZUZpbml0ZURpZmZlcmVuY2VzKHBvaW50cykge1xuICAgIHZhciBpID0gMCwgaiA9IHBvaW50cy5sZW5ndGggLSAxLCBtID0gW10sIHAwID0gcG9pbnRzWzBdLCBwMSA9IHBvaW50c1sxXSwgZCA9IG1bMF0gPSBkM19zdmdfbGluZVNsb3BlKHAwLCBwMSk7XG4gICAgd2hpbGUgKCsraSA8IGopIHtcbiAgICAgIG1baV0gPSAoZCArIChkID0gZDNfc3ZnX2xpbmVTbG9wZShwMCA9IHAxLCBwMSA9IHBvaW50c1tpICsgMV0pKSkgLyAyO1xuICAgIH1cbiAgICBtW2ldID0gZDtcbiAgICByZXR1cm4gbTtcbiAgfVxuICBmdW5jdGlvbiBkM19zdmdfbGluZU1vbm90b25lVGFuZ2VudHMocG9pbnRzKSB7XG4gICAgdmFyIHRhbmdlbnRzID0gW10sIGQsIGEsIGIsIHMsIG0gPSBkM19zdmdfbGluZUZpbml0ZURpZmZlcmVuY2VzKHBvaW50cyksIGkgPSAtMSwgaiA9IHBvaW50cy5sZW5ndGggLSAxO1xuICAgIHdoaWxlICgrK2kgPCBqKSB7XG4gICAgICBkID0gZDNfc3ZnX2xpbmVTbG9wZShwb2ludHNbaV0sIHBvaW50c1tpICsgMV0pO1xuICAgICAgaWYgKGFicyhkKSA8IM61KSB7XG4gICAgICAgIG1baV0gPSBtW2kgKyAxXSA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhID0gbVtpXSAvIGQ7XG4gICAgICAgIGIgPSBtW2kgKyAxXSAvIGQ7XG4gICAgICAgIHMgPSBhICogYSArIGIgKiBiO1xuICAgICAgICBpZiAocyA+IDkpIHtcbiAgICAgICAgICBzID0gZCAqIDMgLyBNYXRoLnNxcnQocyk7XG4gICAgICAgICAgbVtpXSA9IHMgKiBhO1xuICAgICAgICAgIG1baSArIDFdID0gcyAqIGI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaSA9IC0xO1xuICAgIHdoaWxlICgrK2kgPD0gaikge1xuICAgICAgcyA9IChwb2ludHNbTWF0aC5taW4oaiwgaSArIDEpXVswXSAtIHBvaW50c1tNYXRoLm1heCgwLCBpIC0gMSldWzBdKSAvICg2ICogKDEgKyBtW2ldICogbVtpXSkpO1xuICAgICAgdGFuZ2VudHMucHVzaChbIHMgfHwgMCwgbVtpXSAqIHMgfHwgMCBdKTtcbiAgICB9XG4gICAgcmV0dXJuIHRhbmdlbnRzO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3N2Z19saW5lTW9ub3RvbmUocG9pbnRzKSB7XG4gICAgcmV0dXJuIHBvaW50cy5sZW5ndGggPCAzID8gZDNfc3ZnX2xpbmVMaW5lYXIocG9pbnRzKSA6IHBvaW50c1swXSArIGQzX3N2Z19saW5lSGVybWl0ZShwb2ludHMsIGQzX3N2Z19saW5lTW9ub3RvbmVUYW5nZW50cyhwb2ludHMpKTtcbiAgfVxuICBkMy5zdmcubGluZS5yYWRpYWwgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgbGluZSA9IGQzX3N2Z19saW5lKGQzX3N2Z19saW5lUmFkaWFsKTtcbiAgICBsaW5lLnJhZGl1cyA9IGxpbmUueCwgZGVsZXRlIGxpbmUueDtcbiAgICBsaW5lLmFuZ2xlID0gbGluZS55LCBkZWxldGUgbGluZS55O1xuICAgIHJldHVybiBsaW5lO1xuICB9O1xuICBmdW5jdGlvbiBkM19zdmdfbGluZVJhZGlhbChwb2ludHMpIHtcbiAgICB2YXIgcG9pbnQsIGkgPSAtMSwgbiA9IHBvaW50cy5sZW5ndGgsIHIsIGE7XG4gICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgIHBvaW50ID0gcG9pbnRzW2ldO1xuICAgICAgciA9IHBvaW50WzBdO1xuICAgICAgYSA9IHBvaW50WzFdIC0gaGFsZs+AO1xuICAgICAgcG9pbnRbMF0gPSByICogTWF0aC5jb3MoYSk7XG4gICAgICBwb2ludFsxXSA9IHIgKiBNYXRoLnNpbihhKTtcbiAgICB9XG4gICAgcmV0dXJuIHBvaW50cztcbiAgfVxuICBmdW5jdGlvbiBkM19zdmdfYXJlYShwcm9qZWN0aW9uKSB7XG4gICAgdmFyIHgwID0gZDNfZ2VvbV9wb2ludFgsIHgxID0gZDNfZ2VvbV9wb2ludFgsIHkwID0gMCwgeTEgPSBkM19nZW9tX3BvaW50WSwgZGVmaW5lZCA9IGQzX3RydWUsIGludGVycG9sYXRlID0gZDNfc3ZnX2xpbmVMaW5lYXIsIGludGVycG9sYXRlS2V5ID0gaW50ZXJwb2xhdGUua2V5LCBpbnRlcnBvbGF0ZVJldmVyc2UgPSBpbnRlcnBvbGF0ZSwgTCA9IFwiTFwiLCB0ZW5zaW9uID0gLjc7XG4gICAgZnVuY3Rpb24gYXJlYShkYXRhKSB7XG4gICAgICB2YXIgc2VnbWVudHMgPSBbXSwgcG9pbnRzMCA9IFtdLCBwb2ludHMxID0gW10sIGkgPSAtMSwgbiA9IGRhdGEubGVuZ3RoLCBkLCBmeDAgPSBkM19mdW5jdG9yKHgwKSwgZnkwID0gZDNfZnVuY3Rvcih5MCksIGZ4MSA9IHgwID09PSB4MSA/IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4geDtcbiAgICAgIH0gOiBkM19mdW5jdG9yKHgxKSwgZnkxID0geTAgPT09IHkxID8gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB5O1xuICAgICAgfSA6IGQzX2Z1bmN0b3IoeTEpLCB4LCB5O1xuICAgICAgZnVuY3Rpb24gc2VnbWVudCgpIHtcbiAgICAgICAgc2VnbWVudHMucHVzaChcIk1cIiwgaW50ZXJwb2xhdGUocHJvamVjdGlvbihwb2ludHMxKSwgdGVuc2lvbiksIEwsIGludGVycG9sYXRlUmV2ZXJzZShwcm9qZWN0aW9uKHBvaW50czAucmV2ZXJzZSgpKSwgdGVuc2lvbiksIFwiWlwiKTtcbiAgICAgIH1cbiAgICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgIGlmIChkZWZpbmVkLmNhbGwodGhpcywgZCA9IGRhdGFbaV0sIGkpKSB7XG4gICAgICAgICAgcG9pbnRzMC5wdXNoKFsgeCA9ICtmeDAuY2FsbCh0aGlzLCBkLCBpKSwgeSA9ICtmeTAuY2FsbCh0aGlzLCBkLCBpKSBdKTtcbiAgICAgICAgICBwb2ludHMxLnB1c2goWyArZngxLmNhbGwodGhpcywgZCwgaSksICtmeTEuY2FsbCh0aGlzLCBkLCBpKSBdKTtcbiAgICAgICAgfSBlbHNlIGlmIChwb2ludHMwLmxlbmd0aCkge1xuICAgICAgICAgIHNlZ21lbnQoKTtcbiAgICAgICAgICBwb2ludHMwID0gW107XG4gICAgICAgICAgcG9pbnRzMSA9IFtdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocG9pbnRzMC5sZW5ndGgpIHNlZ21lbnQoKTtcbiAgICAgIHJldHVybiBzZWdtZW50cy5sZW5ndGggPyBzZWdtZW50cy5qb2luKFwiXCIpIDogbnVsbDtcbiAgICB9XG4gICAgYXJlYS54ID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4geDE7XG4gICAgICB4MCA9IHgxID0gXztcbiAgICAgIHJldHVybiBhcmVhO1xuICAgIH07XG4gICAgYXJlYS54MCA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHgwO1xuICAgICAgeDAgPSBfO1xuICAgICAgcmV0dXJuIGFyZWE7XG4gICAgfTtcbiAgICBhcmVhLngxID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4geDE7XG4gICAgICB4MSA9IF87XG4gICAgICByZXR1cm4gYXJlYTtcbiAgICB9O1xuICAgIGFyZWEueSA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHkxO1xuICAgICAgeTAgPSB5MSA9IF87XG4gICAgICByZXR1cm4gYXJlYTtcbiAgICB9O1xuICAgIGFyZWEueTAgPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB5MDtcbiAgICAgIHkwID0gXztcbiAgICAgIHJldHVybiBhcmVhO1xuICAgIH07XG4gICAgYXJlYS55MSA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHkxO1xuICAgICAgeTEgPSBfO1xuICAgICAgcmV0dXJuIGFyZWE7XG4gICAgfTtcbiAgICBhcmVhLmRlZmluZWQgPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBkZWZpbmVkO1xuICAgICAgZGVmaW5lZCA9IF87XG4gICAgICByZXR1cm4gYXJlYTtcbiAgICB9O1xuICAgIGFyZWEuaW50ZXJwb2xhdGUgPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBpbnRlcnBvbGF0ZUtleTtcbiAgICAgIGlmICh0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiKSBpbnRlcnBvbGF0ZUtleSA9IGludGVycG9sYXRlID0gXzsgZWxzZSBpbnRlcnBvbGF0ZUtleSA9IChpbnRlcnBvbGF0ZSA9IGQzX3N2Z19saW5lSW50ZXJwb2xhdG9ycy5nZXQoXykgfHwgZDNfc3ZnX2xpbmVMaW5lYXIpLmtleTtcbiAgICAgIGludGVycG9sYXRlUmV2ZXJzZSA9IGludGVycG9sYXRlLnJldmVyc2UgfHwgaW50ZXJwb2xhdGU7XG4gICAgICBMID0gaW50ZXJwb2xhdGUuY2xvc2VkID8gXCJNXCIgOiBcIkxcIjtcbiAgICAgIHJldHVybiBhcmVhO1xuICAgIH07XG4gICAgYXJlYS50ZW5zaW9uID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGVuc2lvbjtcbiAgICAgIHRlbnNpb24gPSBfO1xuICAgICAgcmV0dXJuIGFyZWE7XG4gICAgfTtcbiAgICByZXR1cm4gYXJlYTtcbiAgfVxuICBkM19zdmdfbGluZVN0ZXBCZWZvcmUucmV2ZXJzZSA9IGQzX3N2Z19saW5lU3RlcEFmdGVyO1xuICBkM19zdmdfbGluZVN0ZXBBZnRlci5yZXZlcnNlID0gZDNfc3ZnX2xpbmVTdGVwQmVmb3JlO1xuICBkMy5zdmcuYXJlYSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkM19zdmdfYXJlYShkM19pZGVudGl0eSk7XG4gIH07XG4gIGQzLnN2Zy5hcmVhLnJhZGlhbCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmVhID0gZDNfc3ZnX2FyZWEoZDNfc3ZnX2xpbmVSYWRpYWwpO1xuICAgIGFyZWEucmFkaXVzID0gYXJlYS54LCBkZWxldGUgYXJlYS54O1xuICAgIGFyZWEuaW5uZXJSYWRpdXMgPSBhcmVhLngwLCBkZWxldGUgYXJlYS54MDtcbiAgICBhcmVhLm91dGVyUmFkaXVzID0gYXJlYS54MSwgZGVsZXRlIGFyZWEueDE7XG4gICAgYXJlYS5hbmdsZSA9IGFyZWEueSwgZGVsZXRlIGFyZWEueTtcbiAgICBhcmVhLnN0YXJ0QW5nbGUgPSBhcmVhLnkwLCBkZWxldGUgYXJlYS55MDtcbiAgICBhcmVhLmVuZEFuZ2xlID0gYXJlYS55MSwgZGVsZXRlIGFyZWEueTE7XG4gICAgcmV0dXJuIGFyZWE7XG4gIH07XG4gIGQzLnN2Zy5jaG9yZCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzb3VyY2UgPSBkM19zb3VyY2UsIHRhcmdldCA9IGQzX3RhcmdldCwgcmFkaXVzID0gZDNfc3ZnX2Nob3JkUmFkaXVzLCBzdGFydEFuZ2xlID0gZDNfc3ZnX2FyY1N0YXJ0QW5nbGUsIGVuZEFuZ2xlID0gZDNfc3ZnX2FyY0VuZEFuZ2xlO1xuICAgIGZ1bmN0aW9uIGNob3JkKGQsIGkpIHtcbiAgICAgIHZhciBzID0gc3ViZ3JvdXAodGhpcywgc291cmNlLCBkLCBpKSwgdCA9IHN1Ymdyb3VwKHRoaXMsIHRhcmdldCwgZCwgaSk7XG4gICAgICByZXR1cm4gXCJNXCIgKyBzLnAwICsgYXJjKHMuciwgcy5wMSwgcy5hMSAtIHMuYTApICsgKGVxdWFscyhzLCB0KSA/IGN1cnZlKHMuciwgcy5wMSwgcy5yLCBzLnAwKSA6IGN1cnZlKHMuciwgcy5wMSwgdC5yLCB0LnAwKSArIGFyYyh0LnIsIHQucDEsIHQuYTEgLSB0LmEwKSArIGN1cnZlKHQuciwgdC5wMSwgcy5yLCBzLnAwKSkgKyBcIlpcIjtcbiAgICB9XG4gICAgZnVuY3Rpb24gc3ViZ3JvdXAoc2VsZiwgZiwgZCwgaSkge1xuICAgICAgdmFyIHN1Ymdyb3VwID0gZi5jYWxsKHNlbGYsIGQsIGkpLCByID0gcmFkaXVzLmNhbGwoc2VsZiwgc3ViZ3JvdXAsIGkpLCBhMCA9IHN0YXJ0QW5nbGUuY2FsbChzZWxmLCBzdWJncm91cCwgaSkgLSBoYWxmz4AsIGExID0gZW5kQW5nbGUuY2FsbChzZWxmLCBzdWJncm91cCwgaSkgLSBoYWxmz4A7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByOiByLFxuICAgICAgICBhMDogYTAsXG4gICAgICAgIGExOiBhMSxcbiAgICAgICAgcDA6IFsgciAqIE1hdGguY29zKGEwKSwgciAqIE1hdGguc2luKGEwKSBdLFxuICAgICAgICBwMTogWyByICogTWF0aC5jb3MoYTEpLCByICogTWF0aC5zaW4oYTEpIF1cbiAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVxdWFscyhhLCBiKSB7XG4gICAgICByZXR1cm4gYS5hMCA9PSBiLmEwICYmIGEuYTEgPT0gYi5hMTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYXJjKHIsIHAsIGEpIHtcbiAgICAgIHJldHVybiBcIkFcIiArIHIgKyBcIixcIiArIHIgKyBcIiAwIFwiICsgKyhhID4gz4ApICsgXCIsMSBcIiArIHA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGN1cnZlKHIwLCBwMCwgcjEsIHAxKSB7XG4gICAgICByZXR1cm4gXCJRIDAsMCBcIiArIHAxO1xuICAgIH1cbiAgICBjaG9yZC5yYWRpdXMgPSBmdW5jdGlvbih2KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiByYWRpdXM7XG4gICAgICByYWRpdXMgPSBkM19mdW5jdG9yKHYpO1xuICAgICAgcmV0dXJuIGNob3JkO1xuICAgIH07XG4gICAgY2hvcmQuc291cmNlID0gZnVuY3Rpb24odikge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc291cmNlO1xuICAgICAgc291cmNlID0gZDNfZnVuY3Rvcih2KTtcbiAgICAgIHJldHVybiBjaG9yZDtcbiAgICB9O1xuICAgIGNob3JkLnRhcmdldCA9IGZ1bmN0aW9uKHYpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRhcmdldDtcbiAgICAgIHRhcmdldCA9IGQzX2Z1bmN0b3Iodik7XG4gICAgICByZXR1cm4gY2hvcmQ7XG4gICAgfTtcbiAgICBjaG9yZC5zdGFydEFuZ2xlID0gZnVuY3Rpb24odikge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc3RhcnRBbmdsZTtcbiAgICAgIHN0YXJ0QW5nbGUgPSBkM19mdW5jdG9yKHYpO1xuICAgICAgcmV0dXJuIGNob3JkO1xuICAgIH07XG4gICAgY2hvcmQuZW5kQW5nbGUgPSBmdW5jdGlvbih2KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBlbmRBbmdsZTtcbiAgICAgIGVuZEFuZ2xlID0gZDNfZnVuY3Rvcih2KTtcbiAgICAgIHJldHVybiBjaG9yZDtcbiAgICB9O1xuICAgIHJldHVybiBjaG9yZDtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfc3ZnX2Nob3JkUmFkaXVzKGQpIHtcbiAgICByZXR1cm4gZC5yYWRpdXM7XG4gIH1cbiAgZDMuc3ZnLmRpYWdvbmFsID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNvdXJjZSA9IGQzX3NvdXJjZSwgdGFyZ2V0ID0gZDNfdGFyZ2V0LCBwcm9qZWN0aW9uID0gZDNfc3ZnX2RpYWdvbmFsUHJvamVjdGlvbjtcbiAgICBmdW5jdGlvbiBkaWFnb25hbChkLCBpKSB7XG4gICAgICB2YXIgcDAgPSBzb3VyY2UuY2FsbCh0aGlzLCBkLCBpKSwgcDMgPSB0YXJnZXQuY2FsbCh0aGlzLCBkLCBpKSwgbSA9IChwMC55ICsgcDMueSkgLyAyLCBwID0gWyBwMCwge1xuICAgICAgICB4OiBwMC54LFxuICAgICAgICB5OiBtXG4gICAgICB9LCB7XG4gICAgICAgIHg6IHAzLngsXG4gICAgICAgIHk6IG1cbiAgICAgIH0sIHAzIF07XG4gICAgICBwID0gcC5tYXAocHJvamVjdGlvbik7XG4gICAgICByZXR1cm4gXCJNXCIgKyBwWzBdICsgXCJDXCIgKyBwWzFdICsgXCIgXCIgKyBwWzJdICsgXCIgXCIgKyBwWzNdO1xuICAgIH1cbiAgICBkaWFnb25hbC5zb3VyY2UgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBzb3VyY2U7XG4gICAgICBzb3VyY2UgPSBkM19mdW5jdG9yKHgpO1xuICAgICAgcmV0dXJuIGRpYWdvbmFsO1xuICAgIH07XG4gICAgZGlhZ29uYWwudGFyZ2V0ID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGFyZ2V0O1xuICAgICAgdGFyZ2V0ID0gZDNfZnVuY3Rvcih4KTtcbiAgICAgIHJldHVybiBkaWFnb25hbDtcbiAgICB9O1xuICAgIGRpYWdvbmFsLnByb2plY3Rpb24gPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBwcm9qZWN0aW9uO1xuICAgICAgcHJvamVjdGlvbiA9IHg7XG4gICAgICByZXR1cm4gZGlhZ29uYWw7XG4gICAgfTtcbiAgICByZXR1cm4gZGlhZ29uYWw7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX3N2Z19kaWFnb25hbFByb2plY3Rpb24oZCkge1xuICAgIHJldHVybiBbIGQueCwgZC55IF07XG4gIH1cbiAgZDMuc3ZnLmRpYWdvbmFsLnJhZGlhbCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBkaWFnb25hbCA9IGQzLnN2Zy5kaWFnb25hbCgpLCBwcm9qZWN0aW9uID0gZDNfc3ZnX2RpYWdvbmFsUHJvamVjdGlvbiwgcHJvamVjdGlvbl8gPSBkaWFnb25hbC5wcm9qZWN0aW9uO1xuICAgIGRpYWdvbmFsLnByb2plY3Rpb24gPSBmdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IHByb2plY3Rpb25fKGQzX3N2Z19kaWFnb25hbFJhZGlhbFByb2plY3Rpb24ocHJvamVjdGlvbiA9IHgpKSA6IHByb2plY3Rpb247XG4gICAgfTtcbiAgICByZXR1cm4gZGlhZ29uYWw7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX3N2Z19kaWFnb25hbFJhZGlhbFByb2plY3Rpb24ocHJvamVjdGlvbikge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBkID0gcHJvamVjdGlvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpLCByID0gZFswXSwgYSA9IGRbMV0gLSBoYWxmz4A7XG4gICAgICByZXR1cm4gWyByICogTWF0aC5jb3MoYSksIHIgKiBNYXRoLnNpbihhKSBdO1xuICAgIH07XG4gIH1cbiAgZDMuc3ZnLnN5bWJvbCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0eXBlID0gZDNfc3ZnX3N5bWJvbFR5cGUsIHNpemUgPSBkM19zdmdfc3ltYm9sU2l6ZTtcbiAgICBmdW5jdGlvbiBzeW1ib2woZCwgaSkge1xuICAgICAgcmV0dXJuIChkM19zdmdfc3ltYm9scy5nZXQodHlwZS5jYWxsKHRoaXMsIGQsIGkpKSB8fCBkM19zdmdfc3ltYm9sQ2lyY2xlKShzaXplLmNhbGwodGhpcywgZCwgaSkpO1xuICAgIH1cbiAgICBzeW1ib2wudHlwZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHR5cGU7XG4gICAgICB0eXBlID0gZDNfZnVuY3Rvcih4KTtcbiAgICAgIHJldHVybiBzeW1ib2w7XG4gICAgfTtcbiAgICBzeW1ib2wuc2l6ZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHNpemU7XG4gICAgICBzaXplID0gZDNfZnVuY3Rvcih4KTtcbiAgICAgIHJldHVybiBzeW1ib2w7XG4gICAgfTtcbiAgICByZXR1cm4gc3ltYm9sO1xuICB9O1xuICBmdW5jdGlvbiBkM19zdmdfc3ltYm9sU2l6ZSgpIHtcbiAgICByZXR1cm4gNjQ7XG4gIH1cbiAgZnVuY3Rpb24gZDNfc3ZnX3N5bWJvbFR5cGUoKSB7XG4gICAgcmV0dXJuIFwiY2lyY2xlXCI7XG4gIH1cbiAgZnVuY3Rpb24gZDNfc3ZnX3N5bWJvbENpcmNsZShzaXplKSB7XG4gICAgdmFyIHIgPSBNYXRoLnNxcnQoc2l6ZSAvIM+AKTtcbiAgICByZXR1cm4gXCJNMCxcIiArIHIgKyBcIkFcIiArIHIgKyBcIixcIiArIHIgKyBcIiAwIDEsMSAwLFwiICsgLXIgKyBcIkFcIiArIHIgKyBcIixcIiArIHIgKyBcIiAwIDEsMSAwLFwiICsgciArIFwiWlwiO1xuICB9XG4gIHZhciBkM19zdmdfc3ltYm9scyA9IGQzLm1hcCh7XG4gICAgY2lyY2xlOiBkM19zdmdfc3ltYm9sQ2lyY2xlLFxuICAgIGNyb3NzOiBmdW5jdGlvbihzaXplKSB7XG4gICAgICB2YXIgciA9IE1hdGguc3FydChzaXplIC8gNSkgLyAyO1xuICAgICAgcmV0dXJuIFwiTVwiICsgLTMgKiByICsgXCIsXCIgKyAtciArIFwiSFwiICsgLXIgKyBcIlZcIiArIC0zICogciArIFwiSFwiICsgciArIFwiVlwiICsgLXIgKyBcIkhcIiArIDMgKiByICsgXCJWXCIgKyByICsgXCJIXCIgKyByICsgXCJWXCIgKyAzICogciArIFwiSFwiICsgLXIgKyBcIlZcIiArIHIgKyBcIkhcIiArIC0zICogciArIFwiWlwiO1xuICAgIH0sXG4gICAgZGlhbW9uZDogZnVuY3Rpb24oc2l6ZSkge1xuICAgICAgdmFyIHJ5ID0gTWF0aC5zcXJ0KHNpemUgLyAoMiAqIGQzX3N2Z19zeW1ib2xUYW4zMCkpLCByeCA9IHJ5ICogZDNfc3ZnX3N5bWJvbFRhbjMwO1xuICAgICAgcmV0dXJuIFwiTTAsXCIgKyAtcnkgKyBcIkxcIiArIHJ4ICsgXCIsMFwiICsgXCIgMCxcIiArIHJ5ICsgXCIgXCIgKyAtcnggKyBcIiwwXCIgKyBcIlpcIjtcbiAgICB9LFxuICAgIHNxdWFyZTogZnVuY3Rpb24oc2l6ZSkge1xuICAgICAgdmFyIHIgPSBNYXRoLnNxcnQoc2l6ZSkgLyAyO1xuICAgICAgcmV0dXJuIFwiTVwiICsgLXIgKyBcIixcIiArIC1yICsgXCJMXCIgKyByICsgXCIsXCIgKyAtciArIFwiIFwiICsgciArIFwiLFwiICsgciArIFwiIFwiICsgLXIgKyBcIixcIiArIHIgKyBcIlpcIjtcbiAgICB9LFxuICAgIFwidHJpYW5nbGUtZG93blwiOiBmdW5jdGlvbihzaXplKSB7XG4gICAgICB2YXIgcnggPSBNYXRoLnNxcnQoc2l6ZSAvIGQzX3N2Z19zeW1ib2xTcXJ0MyksIHJ5ID0gcnggKiBkM19zdmdfc3ltYm9sU3FydDMgLyAyO1xuICAgICAgcmV0dXJuIFwiTTAsXCIgKyByeSArIFwiTFwiICsgcnggKyBcIixcIiArIC1yeSArIFwiIFwiICsgLXJ4ICsgXCIsXCIgKyAtcnkgKyBcIlpcIjtcbiAgICB9LFxuICAgIFwidHJpYW5nbGUtdXBcIjogZnVuY3Rpb24oc2l6ZSkge1xuICAgICAgdmFyIHJ4ID0gTWF0aC5zcXJ0KHNpemUgLyBkM19zdmdfc3ltYm9sU3FydDMpLCByeSA9IHJ4ICogZDNfc3ZnX3N5bWJvbFNxcnQzIC8gMjtcbiAgICAgIHJldHVybiBcIk0wLFwiICsgLXJ5ICsgXCJMXCIgKyByeCArIFwiLFwiICsgcnkgKyBcIiBcIiArIC1yeCArIFwiLFwiICsgcnkgKyBcIlpcIjtcbiAgICB9XG4gIH0pO1xuICBkMy5zdmcuc3ltYm9sVHlwZXMgPSBkM19zdmdfc3ltYm9scy5rZXlzKCk7XG4gIHZhciBkM19zdmdfc3ltYm9sU3FydDMgPSBNYXRoLnNxcnQoMyksIGQzX3N2Z19zeW1ib2xUYW4zMCA9IE1hdGgudGFuKDMwICogZDNfcmFkaWFucyk7XG4gIGQzX3NlbGVjdGlvblByb3RvdHlwZS50cmFuc2l0aW9uID0gZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciBpZCA9IGQzX3RyYW5zaXRpb25Jbmhlcml0SWQgfHwgKytkM190cmFuc2l0aW9uSWQsIG5zID0gZDNfdHJhbnNpdGlvbk5hbWVzcGFjZShuYW1lKSwgc3ViZ3JvdXBzID0gW10sIHN1Ymdyb3VwLCBub2RlLCB0cmFuc2l0aW9uID0gZDNfdHJhbnNpdGlvbkluaGVyaXQgfHwge1xuICAgICAgdGltZTogRGF0ZS5ub3coKSxcbiAgICAgIGVhc2U6IGQzX2Vhc2VfY3ViaWNJbk91dCxcbiAgICAgIGRlbGF5OiAwLFxuICAgICAgZHVyYXRpb246IDI1MFxuICAgIH07XG4gICAgZm9yICh2YXIgaiA9IC0xLCBtID0gdGhpcy5sZW5ndGg7ICsraiA8IG07ICkge1xuICAgICAgc3ViZ3JvdXBzLnB1c2goc3ViZ3JvdXAgPSBbXSk7XG4gICAgICBmb3IgKHZhciBncm91cCA9IHRoaXNbal0sIGkgPSAtMSwgbiA9IGdyb3VwLmxlbmd0aDsgKytpIDwgbjsgKSB7XG4gICAgICAgIGlmIChub2RlID0gZ3JvdXBbaV0pIGQzX3RyYW5zaXRpb25Ob2RlKG5vZGUsIGksIG5zLCBpZCwgdHJhbnNpdGlvbik7XG4gICAgICAgIHN1Ymdyb3VwLnB1c2gobm9kZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkM190cmFuc2l0aW9uKHN1Ymdyb3VwcywgbnMsIGlkKTtcbiAgfTtcbiAgZDNfc2VsZWN0aW9uUHJvdG90eXBlLmludGVycnVwdCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKG5hbWUgPT0gbnVsbCA/IGQzX3NlbGVjdGlvbl9pbnRlcnJ1cHQgOiBkM19zZWxlY3Rpb25faW50ZXJydXB0TlMoZDNfdHJhbnNpdGlvbk5hbWVzcGFjZShuYW1lKSkpO1xuICB9O1xuICB2YXIgZDNfc2VsZWN0aW9uX2ludGVycnVwdCA9IGQzX3NlbGVjdGlvbl9pbnRlcnJ1cHROUyhkM190cmFuc2l0aW9uTmFtZXNwYWNlKCkpO1xuICBmdW5jdGlvbiBkM19zZWxlY3Rpb25faW50ZXJydXB0TlMobnMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbG9jaywgYWN0aXZlSWQsIGFjdGl2ZTtcbiAgICAgIGlmICgobG9jayA9IHRoaXNbbnNdKSAmJiAoYWN0aXZlID0gbG9ja1thY3RpdmVJZCA9IGxvY2suYWN0aXZlXSkpIHtcbiAgICAgICAgYWN0aXZlLnRpbWVyLmMgPSBudWxsO1xuICAgICAgICBhY3RpdmUudGltZXIudCA9IE5hTjtcbiAgICAgICAgaWYgKC0tbG9jay5jb3VudCkgZGVsZXRlIGxvY2tbYWN0aXZlSWRdOyBlbHNlIGRlbGV0ZSB0aGlzW25zXTtcbiAgICAgICAgbG9jay5hY3RpdmUgKz0gLjU7XG4gICAgICAgIGFjdGl2ZS5ldmVudCAmJiBhY3RpdmUuZXZlbnQuaW50ZXJydXB0LmNhbGwodGhpcywgdGhpcy5fX2RhdGFfXywgYWN0aXZlLmluZGV4KTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGQzX3RyYW5zaXRpb24oZ3JvdXBzLCBucywgaWQpIHtcbiAgICBkM19zdWJjbGFzcyhncm91cHMsIGQzX3RyYW5zaXRpb25Qcm90b3R5cGUpO1xuICAgIGdyb3Vwcy5uYW1lc3BhY2UgPSBucztcbiAgICBncm91cHMuaWQgPSBpZDtcbiAgICByZXR1cm4gZ3JvdXBzO1xuICB9XG4gIHZhciBkM190cmFuc2l0aW9uUHJvdG90eXBlID0gW10sIGQzX3RyYW5zaXRpb25JZCA9IDAsIGQzX3RyYW5zaXRpb25Jbmhlcml0SWQsIGQzX3RyYW5zaXRpb25Jbmhlcml0O1xuICBkM190cmFuc2l0aW9uUHJvdG90eXBlLmNhbGwgPSBkM19zZWxlY3Rpb25Qcm90b3R5cGUuY2FsbDtcbiAgZDNfdHJhbnNpdGlvblByb3RvdHlwZS5lbXB0eSA9IGQzX3NlbGVjdGlvblByb3RvdHlwZS5lbXB0eTtcbiAgZDNfdHJhbnNpdGlvblByb3RvdHlwZS5ub2RlID0gZDNfc2VsZWN0aW9uUHJvdG90eXBlLm5vZGU7XG4gIGQzX3RyYW5zaXRpb25Qcm90b3R5cGUuc2l6ZSA9IGQzX3NlbGVjdGlvblByb3RvdHlwZS5zaXplO1xuICBkMy50cmFuc2l0aW9uID0gZnVuY3Rpb24oc2VsZWN0aW9uLCBuYW1lKSB7XG4gICAgcmV0dXJuIHNlbGVjdGlvbiAmJiBzZWxlY3Rpb24udHJhbnNpdGlvbiA/IGQzX3RyYW5zaXRpb25Jbmhlcml0SWQgPyBzZWxlY3Rpb24udHJhbnNpdGlvbihuYW1lKSA6IHNlbGVjdGlvbiA6IGQzLnNlbGVjdGlvbigpLnRyYW5zaXRpb24oc2VsZWN0aW9uKTtcbiAgfTtcbiAgZDMudHJhbnNpdGlvbi5wcm90b3R5cGUgPSBkM190cmFuc2l0aW9uUHJvdG90eXBlO1xuICBkM190cmFuc2l0aW9uUHJvdG90eXBlLnNlbGVjdCA9IGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG4gICAgdmFyIGlkID0gdGhpcy5pZCwgbnMgPSB0aGlzLm5hbWVzcGFjZSwgc3ViZ3JvdXBzID0gW10sIHN1Ymdyb3VwLCBzdWJub2RlLCBub2RlO1xuICAgIHNlbGVjdG9yID0gZDNfc2VsZWN0aW9uX3NlbGVjdG9yKHNlbGVjdG9yKTtcbiAgICBmb3IgKHZhciBqID0gLTEsIG0gPSB0aGlzLmxlbmd0aDsgKytqIDwgbTsgKSB7XG4gICAgICBzdWJncm91cHMucHVzaChzdWJncm91cCA9IFtdKTtcbiAgICAgIGZvciAodmFyIGdyb3VwID0gdGhpc1tqXSwgaSA9IC0xLCBuID0gZ3JvdXAubGVuZ3RoOyArK2kgPCBuOyApIHtcbiAgICAgICAgaWYgKChub2RlID0gZ3JvdXBbaV0pICYmIChzdWJub2RlID0gc2VsZWN0b3IuY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBpLCBqKSkpIHtcbiAgICAgICAgICBpZiAoXCJfX2RhdGFfX1wiIGluIG5vZGUpIHN1Ym5vZGUuX19kYXRhX18gPSBub2RlLl9fZGF0YV9fO1xuICAgICAgICAgIGQzX3RyYW5zaXRpb25Ob2RlKHN1Ym5vZGUsIGksIG5zLCBpZCwgbm9kZVtuc11baWRdKTtcbiAgICAgICAgICBzdWJncm91cC5wdXNoKHN1Ym5vZGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN1Ymdyb3VwLnB1c2gobnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGQzX3RyYW5zaXRpb24oc3ViZ3JvdXBzLCBucywgaWQpO1xuICB9O1xuICBkM190cmFuc2l0aW9uUHJvdG90eXBlLnNlbGVjdEFsbCA9IGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG4gICAgdmFyIGlkID0gdGhpcy5pZCwgbnMgPSB0aGlzLm5hbWVzcGFjZSwgc3ViZ3JvdXBzID0gW10sIHN1Ymdyb3VwLCBzdWJub2Rlcywgbm9kZSwgc3Vibm9kZSwgdHJhbnNpdGlvbjtcbiAgICBzZWxlY3RvciA9IGQzX3NlbGVjdGlvbl9zZWxlY3RvckFsbChzZWxlY3Rvcik7XG4gICAgZm9yICh2YXIgaiA9IC0xLCBtID0gdGhpcy5sZW5ndGg7ICsraiA8IG07ICkge1xuICAgICAgZm9yICh2YXIgZ3JvdXAgPSB0aGlzW2pdLCBpID0gLTEsIG4gPSBncm91cC5sZW5ndGg7ICsraSA8IG47ICkge1xuICAgICAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSB7XG4gICAgICAgICAgdHJhbnNpdGlvbiA9IG5vZGVbbnNdW2lkXTtcbiAgICAgICAgICBzdWJub2RlcyA9IHNlbGVjdG9yLmNhbGwobm9kZSwgbm9kZS5fX2RhdGFfXywgaSwgaik7XG4gICAgICAgICAgc3ViZ3JvdXBzLnB1c2goc3ViZ3JvdXAgPSBbXSk7XG4gICAgICAgICAgZm9yICh2YXIgayA9IC0xLCBvID0gc3Vibm9kZXMubGVuZ3RoOyArK2sgPCBvOyApIHtcbiAgICAgICAgICAgIGlmIChzdWJub2RlID0gc3Vibm9kZXNba10pIGQzX3RyYW5zaXRpb25Ob2RlKHN1Ym5vZGUsIGssIG5zLCBpZCwgdHJhbnNpdGlvbik7XG4gICAgICAgICAgICBzdWJncm91cC5wdXNoKHN1Ym5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZDNfdHJhbnNpdGlvbihzdWJncm91cHMsIG5zLCBpZCk7XG4gIH07XG4gIGQzX3RyYW5zaXRpb25Qcm90b3R5cGUuZmlsdGVyID0gZnVuY3Rpb24oZmlsdGVyKSB7XG4gICAgdmFyIHN1Ymdyb3VwcyA9IFtdLCBzdWJncm91cCwgZ3JvdXAsIG5vZGU7XG4gICAgaWYgKHR5cGVvZiBmaWx0ZXIgIT09IFwiZnVuY3Rpb25cIikgZmlsdGVyID0gZDNfc2VsZWN0aW9uX2ZpbHRlcihmaWx0ZXIpO1xuICAgIGZvciAodmFyIGogPSAwLCBtID0gdGhpcy5sZW5ndGg7IGogPCBtOyBqKyspIHtcbiAgICAgIHN1Ymdyb3Vwcy5wdXNoKHN1Ymdyb3VwID0gW10pO1xuICAgICAgZm9yICh2YXIgZ3JvdXAgPSB0aGlzW2pdLCBpID0gMCwgbiA9IGdyb3VwLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICBpZiAoKG5vZGUgPSBncm91cFtpXSkgJiYgZmlsdGVyLmNhbGwobm9kZSwgbm9kZS5fX2RhdGFfXywgaSwgaikpIHtcbiAgICAgICAgICBzdWJncm91cC5wdXNoKG5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkM190cmFuc2l0aW9uKHN1Ymdyb3VwcywgdGhpcy5uYW1lc3BhY2UsIHRoaXMuaWQpO1xuICB9O1xuICBkM190cmFuc2l0aW9uUHJvdG90eXBlLnR3ZWVuID0gZnVuY3Rpb24obmFtZSwgdHdlZW4pIHtcbiAgICB2YXIgaWQgPSB0aGlzLmlkLCBucyA9IHRoaXMubmFtZXNwYWNlO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikgcmV0dXJuIHRoaXMubm9kZSgpW25zXVtpZF0udHdlZW4uZ2V0KG5hbWUpO1xuICAgIHJldHVybiBkM19zZWxlY3Rpb25fZWFjaCh0aGlzLCB0d2VlbiA9PSBudWxsID8gZnVuY3Rpb24obm9kZSkge1xuICAgICAgbm9kZVtuc11baWRdLnR3ZWVuLnJlbW92ZShuYW1lKTtcbiAgICB9IDogZnVuY3Rpb24obm9kZSkge1xuICAgICAgbm9kZVtuc11baWRdLnR3ZWVuLnNldChuYW1lLCB0d2Vlbik7XG4gICAgfSk7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX3RyYW5zaXRpb25fdHdlZW4oZ3JvdXBzLCBuYW1lLCB2YWx1ZSwgdHdlZW4pIHtcbiAgICB2YXIgaWQgPSBncm91cHMuaWQsIG5zID0gZ3JvdXBzLm5hbWVzcGFjZTtcbiAgICByZXR1cm4gZDNfc2VsZWN0aW9uX2VhY2goZ3JvdXBzLCB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIiA/IGZ1bmN0aW9uKG5vZGUsIGksIGopIHtcbiAgICAgIG5vZGVbbnNdW2lkXS50d2Vlbi5zZXQobmFtZSwgdHdlZW4odmFsdWUuY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBpLCBqKSkpO1xuICAgIH0gOiAodmFsdWUgPSB0d2Vlbih2YWx1ZSksIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIG5vZGVbbnNdW2lkXS50d2Vlbi5zZXQobmFtZSwgdmFsdWUpO1xuICAgIH0pKTtcbiAgfVxuICBkM190cmFuc2l0aW9uUHJvdG90eXBlLmF0dHIgPSBmdW5jdGlvbihuYW1lTlMsIHZhbHVlKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgICBmb3IgKHZhbHVlIGluIG5hbWVOUykgdGhpcy5hdHRyKHZhbHVlLCBuYW1lTlNbdmFsdWVdKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB2YXIgaW50ZXJwb2xhdGUgPSBuYW1lTlMgPT0gXCJ0cmFuc2Zvcm1cIiA/IGQzX2ludGVycG9sYXRlVHJhbnNmb3JtIDogZDNfaW50ZXJwb2xhdGUsIG5hbWUgPSBkMy5ucy5xdWFsaWZ5KG5hbWVOUyk7XG4gICAgZnVuY3Rpb24gYXR0ck51bGwoKSB7XG4gICAgICB0aGlzLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYXR0ck51bGxOUygpIHtcbiAgICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlTlMobmFtZS5zcGFjZSwgbmFtZS5sb2NhbCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGF0dHJUd2VlbihiKSB7XG4gICAgICByZXR1cm4gYiA9PSBudWxsID8gYXR0ck51bGwgOiAoYiArPSBcIlwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGEgPSB0aGlzLmdldEF0dHJpYnV0ZShuYW1lKSwgaTtcbiAgICAgICAgcmV0dXJuIGEgIT09IGIgJiYgKGkgPSBpbnRlcnBvbGF0ZShhLCBiKSwgZnVuY3Rpb24odCkge1xuICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKG5hbWUsIGkodCkpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhdHRyVHdlZW5OUyhiKSB7XG4gICAgICByZXR1cm4gYiA9PSBudWxsID8gYXR0ck51bGxOUyA6IChiICs9IFwiXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYSA9IHRoaXMuZ2V0QXR0cmlidXRlTlMobmFtZS5zcGFjZSwgbmFtZS5sb2NhbCksIGk7XG4gICAgICAgIHJldHVybiBhICE9PSBiICYmIChpID0gaW50ZXJwb2xhdGUoYSwgYiksIGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZU5TKG5hbWUuc3BhY2UsIG5hbWUubG9jYWwsIGkodCkpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZDNfdHJhbnNpdGlvbl90d2Vlbih0aGlzLCBcImF0dHIuXCIgKyBuYW1lTlMsIHZhbHVlLCBuYW1lLmxvY2FsID8gYXR0clR3ZWVuTlMgOiBhdHRyVHdlZW4pO1xuICB9O1xuICBkM190cmFuc2l0aW9uUHJvdG90eXBlLmF0dHJUd2VlbiA9IGZ1bmN0aW9uKG5hbWVOUywgdHdlZW4pIHtcbiAgICB2YXIgbmFtZSA9IGQzLm5zLnF1YWxpZnkobmFtZU5TKTtcbiAgICBmdW5jdGlvbiBhdHRyVHdlZW4oZCwgaSkge1xuICAgICAgdmFyIGYgPSB0d2Vlbi5jYWxsKHRoaXMsIGQsIGksIHRoaXMuZ2V0QXR0cmlidXRlKG5hbWUpKTtcbiAgICAgIHJldHVybiBmICYmIGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUobmFtZSwgZih0KSk7XG4gICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBhdHRyVHdlZW5OUyhkLCBpKSB7XG4gICAgICB2YXIgZiA9IHR3ZWVuLmNhbGwodGhpcywgZCwgaSwgdGhpcy5nZXRBdHRyaWJ1dGVOUyhuYW1lLnNwYWNlLCBuYW1lLmxvY2FsKSk7XG4gICAgICByZXR1cm4gZiAmJiBmdW5jdGlvbih0KSB7XG4gICAgICAgIHRoaXMuc2V0QXR0cmlidXRlTlMobmFtZS5zcGFjZSwgbmFtZS5sb2NhbCwgZih0KSk7XG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy50d2VlbihcImF0dHIuXCIgKyBuYW1lTlMsIG5hbWUubG9jYWwgPyBhdHRyVHdlZW5OUyA6IGF0dHJUd2Vlbik7XG4gIH07XG4gIGQzX3RyYW5zaXRpb25Qcm90b3R5cGUuc3R5bGUgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSwgcHJpb3JpdHkpIHtcbiAgICB2YXIgbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgaWYgKG4gPCAzKSB7XG4gICAgICBpZiAodHlwZW9mIG5hbWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgaWYgKG4gPCAyKSB2YWx1ZSA9IFwiXCI7XG4gICAgICAgIGZvciAocHJpb3JpdHkgaW4gbmFtZSkgdGhpcy5zdHlsZShwcmlvcml0eSwgbmFtZVtwcmlvcml0eV0sIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBwcmlvcml0eSA9IFwiXCI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN0eWxlTnVsbCgpIHtcbiAgICAgIHRoaXMuc3R5bGUucmVtb3ZlUHJvcGVydHkobmFtZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN0eWxlU3RyaW5nKGIpIHtcbiAgICAgIHJldHVybiBiID09IG51bGwgPyBzdHlsZU51bGwgOiAoYiArPSBcIlwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGEgPSBkM193aW5kb3codGhpcykuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLCBudWxsKS5nZXRQcm9wZXJ0eVZhbHVlKG5hbWUpLCBpO1xuICAgICAgICByZXR1cm4gYSAhPT0gYiAmJiAoaSA9IGQzX2ludGVycG9sYXRlKGEsIGIpLCBmdW5jdGlvbih0KSB7XG4gICAgICAgICAgdGhpcy5zdHlsZS5zZXRQcm9wZXJ0eShuYW1lLCBpKHQpLCBwcmlvcml0eSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBkM190cmFuc2l0aW9uX3R3ZWVuKHRoaXMsIFwic3R5bGUuXCIgKyBuYW1lLCB2YWx1ZSwgc3R5bGVTdHJpbmcpO1xuICB9O1xuICBkM190cmFuc2l0aW9uUHJvdG90eXBlLnN0eWxlVHdlZW4gPSBmdW5jdGlvbihuYW1lLCB0d2VlbiwgcHJpb3JpdHkpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDMpIHByaW9yaXR5ID0gXCJcIjtcbiAgICBmdW5jdGlvbiBzdHlsZVR3ZWVuKGQsIGkpIHtcbiAgICAgIHZhciBmID0gdHdlZW4uY2FsbCh0aGlzLCBkLCBpLCBkM193aW5kb3codGhpcykuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLCBudWxsKS5nZXRQcm9wZXJ0eVZhbHVlKG5hbWUpKTtcbiAgICAgIHJldHVybiBmICYmIGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgdGhpcy5zdHlsZS5zZXRQcm9wZXJ0eShuYW1lLCBmKHQpLCBwcmlvcml0eSk7XG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy50d2VlbihcInN0eWxlLlwiICsgbmFtZSwgc3R5bGVUd2Vlbik7XG4gIH07XG4gIGQzX3RyYW5zaXRpb25Qcm90b3R5cGUudGV4dCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIGQzX3RyYW5zaXRpb25fdHdlZW4odGhpcywgXCJ0ZXh0XCIsIHZhbHVlLCBkM190cmFuc2l0aW9uX3RleHQpO1xuICB9O1xuICBmdW5jdGlvbiBkM190cmFuc2l0aW9uX3RleHQoYikge1xuICAgIGlmIChiID09IG51bGwpIGIgPSBcIlwiO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMudGV4dENvbnRlbnQgPSBiO1xuICAgIH07XG4gIH1cbiAgZDNfdHJhbnNpdGlvblByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgbnMgPSB0aGlzLm5hbWVzcGFjZTtcbiAgICByZXR1cm4gdGhpcy5lYWNoKFwiZW5kLnRyYW5zaXRpb25cIiwgZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcDtcbiAgICAgIGlmICh0aGlzW25zXS5jb3VudCA8IDIgJiYgKHAgPSB0aGlzLnBhcmVudE5vZGUpKSBwLnJlbW92ZUNoaWxkKHRoaXMpO1xuICAgIH0pO1xuICB9O1xuICBkM190cmFuc2l0aW9uUHJvdG90eXBlLmVhc2UgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHZhciBpZCA9IHRoaXMuaWQsIG5zID0gdGhpcy5uYW1lc3BhY2U7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAxKSByZXR1cm4gdGhpcy5ub2RlKClbbnNdW2lkXS5lYXNlO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwiZnVuY3Rpb25cIikgdmFsdWUgPSBkMy5lYXNlLmFwcGx5KGQzLCBhcmd1bWVudHMpO1xuICAgIHJldHVybiBkM19zZWxlY3Rpb25fZWFjaCh0aGlzLCBmdW5jdGlvbihub2RlKSB7XG4gICAgICBub2RlW25zXVtpZF0uZWFzZSA9IHZhbHVlO1xuICAgIH0pO1xuICB9O1xuICBkM190cmFuc2l0aW9uUHJvdG90eXBlLmRlbGF5ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICB2YXIgaWQgPSB0aGlzLmlkLCBucyA9IHRoaXMubmFtZXNwYWNlO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMSkgcmV0dXJuIHRoaXMubm9kZSgpW25zXVtpZF0uZGVsYXk7XG4gICAgcmV0dXJuIGQzX3NlbGVjdGlvbl9lYWNoKHRoaXMsIHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiID8gZnVuY3Rpb24obm9kZSwgaSwgaikge1xuICAgICAgbm9kZVtuc11baWRdLmRlbGF5ID0gK3ZhbHVlLmNhbGwobm9kZSwgbm9kZS5fX2RhdGFfXywgaSwgaik7XG4gICAgfSA6ICh2YWx1ZSA9ICt2YWx1ZSwgZnVuY3Rpb24obm9kZSkge1xuICAgICAgbm9kZVtuc11baWRdLmRlbGF5ID0gdmFsdWU7XG4gICAgfSkpO1xuICB9O1xuICBkM190cmFuc2l0aW9uUHJvdG90eXBlLmR1cmF0aW9uID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICB2YXIgaWQgPSB0aGlzLmlkLCBucyA9IHRoaXMubmFtZXNwYWNlO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMSkgcmV0dXJuIHRoaXMubm9kZSgpW25zXVtpZF0uZHVyYXRpb247XG4gICAgcmV0dXJuIGQzX3NlbGVjdGlvbl9lYWNoKHRoaXMsIHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiID8gZnVuY3Rpb24obm9kZSwgaSwgaikge1xuICAgICAgbm9kZVtuc11baWRdLmR1cmF0aW9uID0gTWF0aC5tYXgoMSwgdmFsdWUuY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBpLCBqKSk7XG4gICAgfSA6ICh2YWx1ZSA9IE1hdGgubWF4KDEsIHZhbHVlKSwgZnVuY3Rpb24obm9kZSkge1xuICAgICAgbm9kZVtuc11baWRdLmR1cmF0aW9uID0gdmFsdWU7XG4gICAgfSkpO1xuICB9O1xuICBkM190cmFuc2l0aW9uUHJvdG90eXBlLmVhY2ggPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICAgIHZhciBpZCA9IHRoaXMuaWQsIG5zID0gdGhpcy5uYW1lc3BhY2U7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgICB2YXIgaW5oZXJpdCA9IGQzX3RyYW5zaXRpb25Jbmhlcml0LCBpbmhlcml0SWQgPSBkM190cmFuc2l0aW9uSW5oZXJpdElkO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZDNfdHJhbnNpdGlvbkluaGVyaXRJZCA9IGlkO1xuICAgICAgICBkM19zZWxlY3Rpb25fZWFjaCh0aGlzLCBmdW5jdGlvbihub2RlLCBpLCBqKSB7XG4gICAgICAgICAgZDNfdHJhbnNpdGlvbkluaGVyaXQgPSBub2RlW25zXVtpZF07XG4gICAgICAgICAgdHlwZS5jYWxsKG5vZGUsIG5vZGUuX19kYXRhX18sIGksIGopO1xuICAgICAgICB9KTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGQzX3RyYW5zaXRpb25Jbmhlcml0ID0gaW5oZXJpdDtcbiAgICAgICAgZDNfdHJhbnNpdGlvbkluaGVyaXRJZCA9IGluaGVyaXRJZDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZDNfc2VsZWN0aW9uX2VhY2godGhpcywgZnVuY3Rpb24obm9kZSkge1xuICAgICAgICB2YXIgdHJhbnNpdGlvbiA9IG5vZGVbbnNdW2lkXTtcbiAgICAgICAgKHRyYW5zaXRpb24uZXZlbnQgfHwgKHRyYW5zaXRpb24uZXZlbnQgPSBkMy5kaXNwYXRjaChcInN0YXJ0XCIsIFwiZW5kXCIsIFwiaW50ZXJydXB0XCIpKSkub24odHlwZSwgbGlzdGVuZXIpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBkM190cmFuc2l0aW9uUHJvdG90eXBlLnRyYW5zaXRpb24gPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaWQwID0gdGhpcy5pZCwgaWQxID0gKytkM190cmFuc2l0aW9uSWQsIG5zID0gdGhpcy5uYW1lc3BhY2UsIHN1Ymdyb3VwcyA9IFtdLCBzdWJncm91cCwgZ3JvdXAsIG5vZGUsIHRyYW5zaXRpb247XG4gICAgZm9yICh2YXIgaiA9IDAsIG0gPSB0aGlzLmxlbmd0aDsgaiA8IG07IGorKykge1xuICAgICAgc3ViZ3JvdXBzLnB1c2goc3ViZ3JvdXAgPSBbXSk7XG4gICAgICBmb3IgKHZhciBncm91cCA9IHRoaXNbal0sIGkgPSAwLCBuID0gZ3JvdXAubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIGlmIChub2RlID0gZ3JvdXBbaV0pIHtcbiAgICAgICAgICB0cmFuc2l0aW9uID0gbm9kZVtuc11baWQwXTtcbiAgICAgICAgICBkM190cmFuc2l0aW9uTm9kZShub2RlLCBpLCBucywgaWQxLCB7XG4gICAgICAgICAgICB0aW1lOiB0cmFuc2l0aW9uLnRpbWUsXG4gICAgICAgICAgICBlYXNlOiB0cmFuc2l0aW9uLmVhc2UsXG4gICAgICAgICAgICBkZWxheTogdHJhbnNpdGlvbi5kZWxheSArIHRyYW5zaXRpb24uZHVyYXRpb24sXG4gICAgICAgICAgICBkdXJhdGlvbjogdHJhbnNpdGlvbi5kdXJhdGlvblxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHN1Ymdyb3VwLnB1c2gobm9kZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkM190cmFuc2l0aW9uKHN1Ymdyb3VwcywgbnMsIGlkMSk7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX3RyYW5zaXRpb25OYW1lc3BhY2UobmFtZSkge1xuICAgIHJldHVybiBuYW1lID09IG51bGwgPyBcIl9fdHJhbnNpdGlvbl9fXCIgOiBcIl9fdHJhbnNpdGlvbl9cIiArIG5hbWUgKyBcIl9fXCI7XG4gIH1cbiAgZnVuY3Rpb24gZDNfdHJhbnNpdGlvbk5vZGUobm9kZSwgaSwgbnMsIGlkLCBpbmhlcml0KSB7XG4gICAgdmFyIGxvY2sgPSBub2RlW25zXSB8fCAobm9kZVtuc10gPSB7XG4gICAgICBhY3RpdmU6IDAsXG4gICAgICBjb3VudDogMFxuICAgIH0pLCB0cmFuc2l0aW9uID0gbG9ja1tpZF0sIHRpbWUsIHRpbWVyLCBkdXJhdGlvbiwgZWFzZSwgdHdlZW5zO1xuICAgIGZ1bmN0aW9uIHNjaGVkdWxlKGVsYXBzZWQpIHtcbiAgICAgIHZhciBkZWxheSA9IHRyYW5zaXRpb24uZGVsYXk7XG4gICAgICB0aW1lci50ID0gZGVsYXkgKyB0aW1lO1xuICAgICAgaWYgKGRlbGF5IDw9IGVsYXBzZWQpIHJldHVybiBzdGFydChlbGFwc2VkIC0gZGVsYXkpO1xuICAgICAgdGltZXIuYyA9IHN0YXJ0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBzdGFydChlbGFwc2VkKSB7XG4gICAgICB2YXIgYWN0aXZlSWQgPSBsb2NrLmFjdGl2ZSwgYWN0aXZlID0gbG9ja1thY3RpdmVJZF07XG4gICAgICBpZiAoYWN0aXZlKSB7XG4gICAgICAgIGFjdGl2ZS50aW1lci5jID0gbnVsbDtcbiAgICAgICAgYWN0aXZlLnRpbWVyLnQgPSBOYU47XG4gICAgICAgIC0tbG9jay5jb3VudDtcbiAgICAgICAgZGVsZXRlIGxvY2tbYWN0aXZlSWRdO1xuICAgICAgICBhY3RpdmUuZXZlbnQgJiYgYWN0aXZlLmV2ZW50LmludGVycnVwdC5jYWxsKG5vZGUsIG5vZGUuX19kYXRhX18sIGFjdGl2ZS5pbmRleCk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBjYW5jZWxJZCBpbiBsb2NrKSB7XG4gICAgICAgIGlmICgrY2FuY2VsSWQgPCBpZCkge1xuICAgICAgICAgIHZhciBjYW5jZWwgPSBsb2NrW2NhbmNlbElkXTtcbiAgICAgICAgICBjYW5jZWwudGltZXIuYyA9IG51bGw7XG4gICAgICAgICAgY2FuY2VsLnRpbWVyLnQgPSBOYU47XG4gICAgICAgICAgLS1sb2NrLmNvdW50O1xuICAgICAgICAgIGRlbGV0ZSBsb2NrW2NhbmNlbElkXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGltZXIuYyA9IHRpY2s7XG4gICAgICBkM190aW1lcihmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRpbWVyLmMgJiYgdGljayhlbGFwc2VkIHx8IDEpKSB7XG4gICAgICAgICAgdGltZXIuYyA9IG51bGw7XG4gICAgICAgICAgdGltZXIudCA9IE5hTjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH0sIDAsIHRpbWUpO1xuICAgICAgbG9jay5hY3RpdmUgPSBpZDtcbiAgICAgIHRyYW5zaXRpb24uZXZlbnQgJiYgdHJhbnNpdGlvbi5ldmVudC5zdGFydC5jYWxsKG5vZGUsIG5vZGUuX19kYXRhX18sIGkpO1xuICAgICAgdHdlZW5zID0gW107XG4gICAgICB0cmFuc2l0aW9uLnR3ZWVuLmZvckVhY2goZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPSB2YWx1ZS5jYWxsKG5vZGUsIG5vZGUuX19kYXRhX18sIGkpKSB7XG4gICAgICAgICAgdHdlZW5zLnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGVhc2UgPSB0cmFuc2l0aW9uLmVhc2U7XG4gICAgICBkdXJhdGlvbiA9IHRyYW5zaXRpb24uZHVyYXRpb247XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRpY2soZWxhcHNlZCkge1xuICAgICAgdmFyIHQgPSBlbGFwc2VkIC8gZHVyYXRpb24sIGUgPSBlYXNlKHQpLCBuID0gdHdlZW5zLmxlbmd0aDtcbiAgICAgIHdoaWxlIChuID4gMCkge1xuICAgICAgICB0d2VlbnNbLS1uXS5jYWxsKG5vZGUsIGUpO1xuICAgICAgfVxuICAgICAgaWYgKHQgPj0gMSkge1xuICAgICAgICB0cmFuc2l0aW9uLmV2ZW50ICYmIHRyYW5zaXRpb24uZXZlbnQuZW5kLmNhbGwobm9kZSwgbm9kZS5fX2RhdGFfXywgaSk7XG4gICAgICAgIGlmICgtLWxvY2suY291bnQpIGRlbGV0ZSBsb2NrW2lkXTsgZWxzZSBkZWxldGUgbm9kZVtuc107XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXRyYW5zaXRpb24pIHtcbiAgICAgIHRpbWUgPSBpbmhlcml0LnRpbWU7XG4gICAgICB0aW1lciA9IGQzX3RpbWVyKHNjaGVkdWxlLCAwLCB0aW1lKTtcbiAgICAgIHRyYW5zaXRpb24gPSBsb2NrW2lkXSA9IHtcbiAgICAgICAgdHdlZW46IG5ldyBkM19NYXAoKSxcbiAgICAgICAgdGltZTogdGltZSxcbiAgICAgICAgdGltZXI6IHRpbWVyLFxuICAgICAgICBkZWxheTogaW5oZXJpdC5kZWxheSxcbiAgICAgICAgZHVyYXRpb246IGluaGVyaXQuZHVyYXRpb24sXG4gICAgICAgIGVhc2U6IGluaGVyaXQuZWFzZSxcbiAgICAgICAgaW5kZXg6IGlcbiAgICAgIH07XG4gICAgICBpbmhlcml0ID0gbnVsbDtcbiAgICAgICsrbG9jay5jb3VudDtcbiAgICB9XG4gIH1cbiAgZDMuc3ZnLmF4aXMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgc2NhbGUgPSBkMy5zY2FsZS5saW5lYXIoKSwgb3JpZW50ID0gZDNfc3ZnX2F4aXNEZWZhdWx0T3JpZW50LCBpbm5lclRpY2tTaXplID0gNiwgb3V0ZXJUaWNrU2l6ZSA9IDYsIHRpY2tQYWRkaW5nID0gMywgdGlja0FyZ3VtZW50c18gPSBbIDEwIF0sIHRpY2tWYWx1ZXMgPSBudWxsLCB0aWNrRm9ybWF0XztcbiAgICBmdW5jdGlvbiBheGlzKGcpIHtcbiAgICAgIGcuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGcgPSBkMy5zZWxlY3QodGhpcyk7XG4gICAgICAgIHZhciBzY2FsZTAgPSB0aGlzLl9fY2hhcnRfXyB8fCBzY2FsZSwgc2NhbGUxID0gdGhpcy5fX2NoYXJ0X18gPSBzY2FsZS5jb3B5KCk7XG4gICAgICAgIHZhciB0aWNrcyA9IHRpY2tWYWx1ZXMgPT0gbnVsbCA/IHNjYWxlMS50aWNrcyA/IHNjYWxlMS50aWNrcy5hcHBseShzY2FsZTEsIHRpY2tBcmd1bWVudHNfKSA6IHNjYWxlMS5kb21haW4oKSA6IHRpY2tWYWx1ZXMsIHRpY2tGb3JtYXQgPSB0aWNrRm9ybWF0XyA9PSBudWxsID8gc2NhbGUxLnRpY2tGb3JtYXQgPyBzY2FsZTEudGlja0Zvcm1hdC5hcHBseShzY2FsZTEsIHRpY2tBcmd1bWVudHNfKSA6IGQzX2lkZW50aXR5IDogdGlja0Zvcm1hdF8sIHRpY2sgPSBnLnNlbGVjdEFsbChcIi50aWNrXCIpLmRhdGEodGlja3MsIHNjYWxlMSksIHRpY2tFbnRlciA9IHRpY2suZW50ZXIoKS5pbnNlcnQoXCJnXCIsIFwiLmRvbWFpblwiKS5hdHRyKFwiY2xhc3NcIiwgXCJ0aWNrXCIpLnN0eWxlKFwib3BhY2l0eVwiLCDOtSksIHRpY2tFeGl0ID0gZDMudHJhbnNpdGlvbih0aWNrLmV4aXQoKSkuc3R5bGUoXCJvcGFjaXR5XCIsIM61KS5yZW1vdmUoKSwgdGlja1VwZGF0ZSA9IGQzLnRyYW5zaXRpb24odGljay5vcmRlcigpKS5zdHlsZShcIm9wYWNpdHlcIiwgMSksIHRpY2tTcGFjaW5nID0gTWF0aC5tYXgoaW5uZXJUaWNrU2l6ZSwgMCkgKyB0aWNrUGFkZGluZywgdGlja1RyYW5zZm9ybTtcbiAgICAgICAgdmFyIHJhbmdlID0gZDNfc2NhbGVSYW5nZShzY2FsZTEpLCBwYXRoID0gZy5zZWxlY3RBbGwoXCIuZG9tYWluXCIpLmRhdGEoWyAwIF0pLCBwYXRoVXBkYXRlID0gKHBhdGguZW50ZXIoKS5hcHBlbmQoXCJwYXRoXCIpLmF0dHIoXCJjbGFzc1wiLCBcImRvbWFpblwiKSwgXG4gICAgICAgIGQzLnRyYW5zaXRpb24ocGF0aCkpO1xuICAgICAgICB0aWNrRW50ZXIuYXBwZW5kKFwibGluZVwiKTtcbiAgICAgICAgdGlja0VudGVyLmFwcGVuZChcInRleHRcIik7XG4gICAgICAgIHZhciBsaW5lRW50ZXIgPSB0aWNrRW50ZXIuc2VsZWN0KFwibGluZVwiKSwgbGluZVVwZGF0ZSA9IHRpY2tVcGRhdGUuc2VsZWN0KFwibGluZVwiKSwgdGV4dCA9IHRpY2suc2VsZWN0KFwidGV4dFwiKS50ZXh0KHRpY2tGb3JtYXQpLCB0ZXh0RW50ZXIgPSB0aWNrRW50ZXIuc2VsZWN0KFwidGV4dFwiKSwgdGV4dFVwZGF0ZSA9IHRpY2tVcGRhdGUuc2VsZWN0KFwidGV4dFwiKSwgc2lnbiA9IG9yaWVudCA9PT0gXCJ0b3BcIiB8fCBvcmllbnQgPT09IFwibGVmdFwiID8gLTEgOiAxLCB4MSwgeDIsIHkxLCB5MjtcbiAgICAgICAgaWYgKG9yaWVudCA9PT0gXCJib3R0b21cIiB8fCBvcmllbnQgPT09IFwidG9wXCIpIHtcbiAgICAgICAgICB0aWNrVHJhbnNmb3JtID0gZDNfc3ZnX2F4aXNYLCB4MSA9IFwieFwiLCB5MSA9IFwieVwiLCB4MiA9IFwieDJcIiwgeTIgPSBcInkyXCI7XG4gICAgICAgICAgdGV4dC5hdHRyKFwiZHlcIiwgc2lnbiA8IDAgPyBcIjBlbVwiIDogXCIuNzFlbVwiKS5zdHlsZShcInRleHQtYW5jaG9yXCIsIFwibWlkZGxlXCIpO1xuICAgICAgICAgIHBhdGhVcGRhdGUuYXR0cihcImRcIiwgXCJNXCIgKyByYW5nZVswXSArIFwiLFwiICsgc2lnbiAqIG91dGVyVGlja1NpemUgKyBcIlYwSFwiICsgcmFuZ2VbMV0gKyBcIlZcIiArIHNpZ24gKiBvdXRlclRpY2tTaXplKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aWNrVHJhbnNmb3JtID0gZDNfc3ZnX2F4aXNZLCB4MSA9IFwieVwiLCB5MSA9IFwieFwiLCB4MiA9IFwieTJcIiwgeTIgPSBcIngyXCI7XG4gICAgICAgICAgdGV4dC5hdHRyKFwiZHlcIiwgXCIuMzJlbVwiKS5zdHlsZShcInRleHQtYW5jaG9yXCIsIHNpZ24gPCAwID8gXCJlbmRcIiA6IFwic3RhcnRcIik7XG4gICAgICAgICAgcGF0aFVwZGF0ZS5hdHRyKFwiZFwiLCBcIk1cIiArIHNpZ24gKiBvdXRlclRpY2tTaXplICsgXCIsXCIgKyByYW5nZVswXSArIFwiSDBWXCIgKyByYW5nZVsxXSArIFwiSFwiICsgc2lnbiAqIG91dGVyVGlja1NpemUpO1xuICAgICAgICB9XG4gICAgICAgIGxpbmVFbnRlci5hdHRyKHkyLCBzaWduICogaW5uZXJUaWNrU2l6ZSk7XG4gICAgICAgIHRleHRFbnRlci5hdHRyKHkxLCBzaWduICogdGlja1NwYWNpbmcpO1xuICAgICAgICBsaW5lVXBkYXRlLmF0dHIoeDIsIDApLmF0dHIoeTIsIHNpZ24gKiBpbm5lclRpY2tTaXplKTtcbiAgICAgICAgdGV4dFVwZGF0ZS5hdHRyKHgxLCAwKS5hdHRyKHkxLCBzaWduICogdGlja1NwYWNpbmcpO1xuICAgICAgICBpZiAoc2NhbGUxLnJhbmdlQmFuZCkge1xuICAgICAgICAgIHZhciB4ID0gc2NhbGUxLCBkeCA9IHgucmFuZ2VCYW5kKCkgLyAyO1xuICAgICAgICAgIHNjYWxlMCA9IHNjYWxlMSA9IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIHJldHVybiB4KGQpICsgZHg7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChzY2FsZTAucmFuZ2VCYW5kKSB7XG4gICAgICAgICAgc2NhbGUwID0gc2NhbGUxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRpY2tFeGl0LmNhbGwodGlja1RyYW5zZm9ybSwgc2NhbGUxLCBzY2FsZTApO1xuICAgICAgICB9XG4gICAgICAgIHRpY2tFbnRlci5jYWxsKHRpY2tUcmFuc2Zvcm0sIHNjYWxlMCwgc2NhbGUxKTtcbiAgICAgICAgdGlja1VwZGF0ZS5jYWxsKHRpY2tUcmFuc2Zvcm0sIHNjYWxlMSwgc2NhbGUxKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBheGlzLnNjYWxlID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc2NhbGU7XG4gICAgICBzY2FsZSA9IHg7XG4gICAgICByZXR1cm4gYXhpcztcbiAgICB9O1xuICAgIGF4aXMub3JpZW50ID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gb3JpZW50O1xuICAgICAgb3JpZW50ID0geCBpbiBkM19zdmdfYXhpc09yaWVudHMgPyB4ICsgXCJcIiA6IGQzX3N2Z19heGlzRGVmYXVsdE9yaWVudDtcbiAgICAgIHJldHVybiBheGlzO1xuICAgIH07XG4gICAgYXhpcy50aWNrcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGlja0FyZ3VtZW50c187XG4gICAgICB0aWNrQXJndW1lbnRzXyA9IGQzX2FycmF5KGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gYXhpcztcbiAgICB9O1xuICAgIGF4aXMudGlja1ZhbHVlcyA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRpY2tWYWx1ZXM7XG4gICAgICB0aWNrVmFsdWVzID0geDtcbiAgICAgIHJldHVybiBheGlzO1xuICAgIH07XG4gICAgYXhpcy50aWNrRm9ybWF0ID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGlja0Zvcm1hdF87XG4gICAgICB0aWNrRm9ybWF0XyA9IHg7XG4gICAgICByZXR1cm4gYXhpcztcbiAgICB9O1xuICAgIGF4aXMudGlja1NpemUgPSBmdW5jdGlvbih4KSB7XG4gICAgICB2YXIgbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICBpZiAoIW4pIHJldHVybiBpbm5lclRpY2tTaXplO1xuICAgICAgaW5uZXJUaWNrU2l6ZSA9ICt4O1xuICAgICAgb3V0ZXJUaWNrU2l6ZSA9ICthcmd1bWVudHNbbiAtIDFdO1xuICAgICAgcmV0dXJuIGF4aXM7XG4gICAgfTtcbiAgICBheGlzLmlubmVyVGlja1NpemUgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBpbm5lclRpY2tTaXplO1xuICAgICAgaW5uZXJUaWNrU2l6ZSA9ICt4O1xuICAgICAgcmV0dXJuIGF4aXM7XG4gICAgfTtcbiAgICBheGlzLm91dGVyVGlja1NpemUgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBvdXRlclRpY2tTaXplO1xuICAgICAgb3V0ZXJUaWNrU2l6ZSA9ICt4O1xuICAgICAgcmV0dXJuIGF4aXM7XG4gICAgfTtcbiAgICBheGlzLnRpY2tQYWRkaW5nID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGlja1BhZGRpbmc7XG4gICAgICB0aWNrUGFkZGluZyA9ICt4O1xuICAgICAgcmV0dXJuIGF4aXM7XG4gICAgfTtcbiAgICBheGlzLnRpY2tTdWJkaXZpZGUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoICYmIGF4aXM7XG4gICAgfTtcbiAgICByZXR1cm4gYXhpcztcbiAgfTtcbiAgdmFyIGQzX3N2Z19heGlzRGVmYXVsdE9yaWVudCA9IFwiYm90dG9tXCIsIGQzX3N2Z19heGlzT3JpZW50cyA9IHtcbiAgICB0b3A6IDEsXG4gICAgcmlnaHQ6IDEsXG4gICAgYm90dG9tOiAxLFxuICAgIGxlZnQ6IDFcbiAgfTtcbiAgZnVuY3Rpb24gZDNfc3ZnX2F4aXNYKHNlbGVjdGlvbiwgeDAsIHgxKSB7XG4gICAgc2VsZWN0aW9uLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgZnVuY3Rpb24oZCkge1xuICAgICAgdmFyIHYwID0geDAoZCk7XG4gICAgICByZXR1cm4gXCJ0cmFuc2xhdGUoXCIgKyAoaXNGaW5pdGUodjApID8gdjAgOiB4MShkKSkgKyBcIiwwKVwiO1xuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3N2Z19heGlzWShzZWxlY3Rpb24sIHkwLCB5MSkge1xuICAgIHNlbGVjdGlvbi5hdHRyKFwidHJhbnNmb3JtXCIsIGZ1bmN0aW9uKGQpIHtcbiAgICAgIHZhciB2MCA9IHkwKGQpO1xuICAgICAgcmV0dXJuIFwidHJhbnNsYXRlKDAsXCIgKyAoaXNGaW5pdGUodjApID8gdjAgOiB5MShkKSkgKyBcIilcIjtcbiAgICB9KTtcbiAgfVxuICBkMy5zdmcuYnJ1c2ggPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZXZlbnQgPSBkM19ldmVudERpc3BhdGNoKGJydXNoLCBcImJydXNoc3RhcnRcIiwgXCJicnVzaFwiLCBcImJydXNoZW5kXCIpLCB4ID0gbnVsbCwgeSA9IG51bGwsIHhFeHRlbnQgPSBbIDAsIDAgXSwgeUV4dGVudCA9IFsgMCwgMCBdLCB4RXh0ZW50RG9tYWluLCB5RXh0ZW50RG9tYWluLCB4Q2xhbXAgPSB0cnVlLCB5Q2xhbXAgPSB0cnVlLCByZXNpemVzID0gZDNfc3ZnX2JydXNoUmVzaXplc1swXTtcbiAgICBmdW5jdGlvbiBicnVzaChnKSB7XG4gICAgICBnLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBnID0gZDMuc2VsZWN0KHRoaXMpLnN0eWxlKFwicG9pbnRlci1ldmVudHNcIiwgXCJhbGxcIikuc3R5bGUoXCItd2Via2l0LXRhcC1oaWdobGlnaHQtY29sb3JcIiwgXCJyZ2JhKDAsMCwwLDApXCIpLm9uKFwibW91c2Vkb3duLmJydXNoXCIsIGJydXNoc3RhcnQpLm9uKFwidG91Y2hzdGFydC5icnVzaFwiLCBicnVzaHN0YXJ0KTtcbiAgICAgICAgdmFyIGJhY2tncm91bmQgPSBnLnNlbGVjdEFsbChcIi5iYWNrZ3JvdW5kXCIpLmRhdGEoWyAwIF0pO1xuICAgICAgICBiYWNrZ3JvdW5kLmVudGVyKCkuYXBwZW5kKFwicmVjdFwiKS5hdHRyKFwiY2xhc3NcIiwgXCJiYWNrZ3JvdW5kXCIpLnN0eWxlKFwidmlzaWJpbGl0eVwiLCBcImhpZGRlblwiKS5zdHlsZShcImN1cnNvclwiLCBcImNyb3NzaGFpclwiKTtcbiAgICAgICAgZy5zZWxlY3RBbGwoXCIuZXh0ZW50XCIpLmRhdGEoWyAwIF0pLmVudGVyKCkuYXBwZW5kKFwicmVjdFwiKS5hdHRyKFwiY2xhc3NcIiwgXCJleHRlbnRcIikuc3R5bGUoXCJjdXJzb3JcIiwgXCJtb3ZlXCIpO1xuICAgICAgICB2YXIgcmVzaXplID0gZy5zZWxlY3RBbGwoXCIucmVzaXplXCIpLmRhdGEocmVzaXplcywgZDNfaWRlbnRpdHkpO1xuICAgICAgICByZXNpemUuZXhpdCgpLnJlbW92ZSgpO1xuICAgICAgICByZXNpemUuZW50ZXIoKS5hcHBlbmQoXCJnXCIpLmF0dHIoXCJjbGFzc1wiLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgcmV0dXJuIFwicmVzaXplIFwiICsgZDtcbiAgICAgICAgfSkuc3R5bGUoXCJjdXJzb3JcIiwgZnVuY3Rpb24oZCkge1xuICAgICAgICAgIHJldHVybiBkM19zdmdfYnJ1c2hDdXJzb3JbZF07XG4gICAgICAgIH0pLmFwcGVuZChcInJlY3RcIikuYXR0cihcInhcIiwgZnVuY3Rpb24oZCkge1xuICAgICAgICAgIHJldHVybiAvW2V3XSQvLnRlc3QoZCkgPyAtMyA6IG51bGw7XG4gICAgICAgIH0pLmF0dHIoXCJ5XCIsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICByZXR1cm4gL15bbnNdLy50ZXN0KGQpID8gLTMgOiBudWxsO1xuICAgICAgICB9KS5hdHRyKFwid2lkdGhcIiwgNikuYXR0cihcImhlaWdodFwiLCA2KS5zdHlsZShcInZpc2liaWxpdHlcIiwgXCJoaWRkZW5cIik7XG4gICAgICAgIHJlc2l6ZS5zdHlsZShcImRpc3BsYXlcIiwgYnJ1c2guZW1wdHkoKSA/IFwibm9uZVwiIDogbnVsbCk7XG4gICAgICAgIHZhciBnVXBkYXRlID0gZDMudHJhbnNpdGlvbihnKSwgYmFja2dyb3VuZFVwZGF0ZSA9IGQzLnRyYW5zaXRpb24oYmFja2dyb3VuZCksIHJhbmdlO1xuICAgICAgICBpZiAoeCkge1xuICAgICAgICAgIHJhbmdlID0gZDNfc2NhbGVSYW5nZSh4KTtcbiAgICAgICAgICBiYWNrZ3JvdW5kVXBkYXRlLmF0dHIoXCJ4XCIsIHJhbmdlWzBdKS5hdHRyKFwid2lkdGhcIiwgcmFuZ2VbMV0gLSByYW5nZVswXSk7XG4gICAgICAgICAgcmVkcmF3WChnVXBkYXRlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoeSkge1xuICAgICAgICAgIHJhbmdlID0gZDNfc2NhbGVSYW5nZSh5KTtcbiAgICAgICAgICBiYWNrZ3JvdW5kVXBkYXRlLmF0dHIoXCJ5XCIsIHJhbmdlWzBdKS5hdHRyKFwiaGVpZ2h0XCIsIHJhbmdlWzFdIC0gcmFuZ2VbMF0pO1xuICAgICAgICAgIHJlZHJhd1koZ1VwZGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVkcmF3KGdVcGRhdGUpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGJydXNoLmV2ZW50ID0gZnVuY3Rpb24oZykge1xuICAgICAgZy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZXZlbnRfID0gZXZlbnQub2YodGhpcywgYXJndW1lbnRzKSwgZXh0ZW50MSA9IHtcbiAgICAgICAgICB4OiB4RXh0ZW50LFxuICAgICAgICAgIHk6IHlFeHRlbnQsXG4gICAgICAgICAgaTogeEV4dGVudERvbWFpbixcbiAgICAgICAgICBqOiB5RXh0ZW50RG9tYWluXG4gICAgICAgIH0sIGV4dGVudDAgPSB0aGlzLl9fY2hhcnRfXyB8fCBleHRlbnQxO1xuICAgICAgICB0aGlzLl9fY2hhcnRfXyA9IGV4dGVudDE7XG4gICAgICAgIGlmIChkM190cmFuc2l0aW9uSW5oZXJpdElkKSB7XG4gICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLnRyYW5zaXRpb24oKS5lYWNoKFwic3RhcnQuYnJ1c2hcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB4RXh0ZW50RG9tYWluID0gZXh0ZW50MC5pO1xuICAgICAgICAgICAgeUV4dGVudERvbWFpbiA9IGV4dGVudDAuajtcbiAgICAgICAgICAgIHhFeHRlbnQgPSBleHRlbnQwLng7XG4gICAgICAgICAgICB5RXh0ZW50ID0gZXh0ZW50MC55O1xuICAgICAgICAgICAgZXZlbnRfKHtcbiAgICAgICAgICAgICAgdHlwZTogXCJicnVzaHN0YXJ0XCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pLnR3ZWVuKFwiYnJ1c2g6YnJ1c2hcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgeGkgPSBkM19pbnRlcnBvbGF0ZUFycmF5KHhFeHRlbnQsIGV4dGVudDEueCksIHlpID0gZDNfaW50ZXJwb2xhdGVBcnJheSh5RXh0ZW50LCBleHRlbnQxLnkpO1xuICAgICAgICAgICAgeEV4dGVudERvbWFpbiA9IHlFeHRlbnREb21haW4gPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICAgICAgeEV4dGVudCA9IGV4dGVudDEueCA9IHhpKHQpO1xuICAgICAgICAgICAgICB5RXh0ZW50ID0gZXh0ZW50MS55ID0geWkodCk7XG4gICAgICAgICAgICAgIGV2ZW50Xyh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJicnVzaFwiLFxuICAgICAgICAgICAgICAgIG1vZGU6IFwicmVzaXplXCJcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0pLmVhY2goXCJlbmQuYnJ1c2hcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB4RXh0ZW50RG9tYWluID0gZXh0ZW50MS5pO1xuICAgICAgICAgICAgeUV4dGVudERvbWFpbiA9IGV4dGVudDEuajtcbiAgICAgICAgICAgIGV2ZW50Xyh7XG4gICAgICAgICAgICAgIHR5cGU6IFwiYnJ1c2hcIixcbiAgICAgICAgICAgICAgbW9kZTogXCJyZXNpemVcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBldmVudF8oe1xuICAgICAgICAgICAgICB0eXBlOiBcImJydXNoZW5kXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGV2ZW50Xyh7XG4gICAgICAgICAgICB0eXBlOiBcImJydXNoc3RhcnRcIlxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGV2ZW50Xyh7XG4gICAgICAgICAgICB0eXBlOiBcImJydXNoXCIsXG4gICAgICAgICAgICBtb2RlOiBcInJlc2l6ZVwiXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZXZlbnRfKHtcbiAgICAgICAgICAgIHR5cGU6IFwiYnJ1c2hlbmRcIlxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIHJlZHJhdyhnKSB7XG4gICAgICBnLnNlbGVjdEFsbChcIi5yZXNpemVcIikuYXR0cihcInRyYW5zZm9ybVwiLCBmdW5jdGlvbihkKSB7XG4gICAgICAgIHJldHVybiBcInRyYW5zbGF0ZShcIiArIHhFeHRlbnRbKy9lJC8udGVzdChkKV0gKyBcIixcIiArIHlFeHRlbnRbKy9ecy8udGVzdChkKV0gKyBcIilcIjtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZWRyYXdYKGcpIHtcbiAgICAgIGcuc2VsZWN0KFwiLmV4dGVudFwiKS5hdHRyKFwieFwiLCB4RXh0ZW50WzBdKTtcbiAgICAgIGcuc2VsZWN0QWxsKFwiLmV4dGVudCwubj5yZWN0LC5zPnJlY3RcIikuYXR0cihcIndpZHRoXCIsIHhFeHRlbnRbMV0gLSB4RXh0ZW50WzBdKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVkcmF3WShnKSB7XG4gICAgICBnLnNlbGVjdChcIi5leHRlbnRcIikuYXR0cihcInlcIiwgeUV4dGVudFswXSk7XG4gICAgICBnLnNlbGVjdEFsbChcIi5leHRlbnQsLmU+cmVjdCwudz5yZWN0XCIpLmF0dHIoXCJoZWlnaHRcIiwgeUV4dGVudFsxXSAtIHlFeHRlbnRbMF0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBicnVzaHN0YXJ0KCkge1xuICAgICAgdmFyIHRhcmdldCA9IHRoaXMsIGV2ZW50VGFyZ2V0ID0gZDMuc2VsZWN0KGQzLmV2ZW50LnRhcmdldCksIGV2ZW50XyA9IGV2ZW50Lm9mKHRhcmdldCwgYXJndW1lbnRzKSwgZyA9IGQzLnNlbGVjdCh0YXJnZXQpLCByZXNpemluZyA9IGV2ZW50VGFyZ2V0LmRhdHVtKCksIHJlc2l6aW5nWCA9ICEvXihufHMpJC8udGVzdChyZXNpemluZykgJiYgeCwgcmVzaXppbmdZID0gIS9eKGV8dykkLy50ZXN0KHJlc2l6aW5nKSAmJiB5LCBkcmFnZ2luZyA9IGV2ZW50VGFyZ2V0LmNsYXNzZWQoXCJleHRlbnRcIiksIGRyYWdSZXN0b3JlID0gZDNfZXZlbnRfZHJhZ1N1cHByZXNzKHRhcmdldCksIGNlbnRlciwgb3JpZ2luID0gZDMubW91c2UodGFyZ2V0KSwgb2Zmc2V0O1xuICAgICAgdmFyIHcgPSBkMy5zZWxlY3QoZDNfd2luZG93KHRhcmdldCkpLm9uKFwia2V5ZG93bi5icnVzaFwiLCBrZXlkb3duKS5vbihcImtleXVwLmJydXNoXCIsIGtleXVwKTtcbiAgICAgIGlmIChkMy5ldmVudC5jaGFuZ2VkVG91Y2hlcykge1xuICAgICAgICB3Lm9uKFwidG91Y2htb3ZlLmJydXNoXCIsIGJydXNobW92ZSkub24oXCJ0b3VjaGVuZC5icnVzaFwiLCBicnVzaGVuZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3Lm9uKFwibW91c2Vtb3ZlLmJydXNoXCIsIGJydXNobW92ZSkub24oXCJtb3VzZXVwLmJydXNoXCIsIGJydXNoZW5kKTtcbiAgICAgIH1cbiAgICAgIGcuaW50ZXJydXB0KCkuc2VsZWN0QWxsKFwiKlwiKS5pbnRlcnJ1cHQoKTtcbiAgICAgIGlmIChkcmFnZ2luZykge1xuICAgICAgICBvcmlnaW5bMF0gPSB4RXh0ZW50WzBdIC0gb3JpZ2luWzBdO1xuICAgICAgICBvcmlnaW5bMV0gPSB5RXh0ZW50WzBdIC0gb3JpZ2luWzFdO1xuICAgICAgfSBlbHNlIGlmIChyZXNpemluZykge1xuICAgICAgICB2YXIgZXggPSArL3ckLy50ZXN0KHJlc2l6aW5nKSwgZXkgPSArL15uLy50ZXN0KHJlc2l6aW5nKTtcbiAgICAgICAgb2Zmc2V0ID0gWyB4RXh0ZW50WzEgLSBleF0gLSBvcmlnaW5bMF0sIHlFeHRlbnRbMSAtIGV5XSAtIG9yaWdpblsxXSBdO1xuICAgICAgICBvcmlnaW5bMF0gPSB4RXh0ZW50W2V4XTtcbiAgICAgICAgb3JpZ2luWzFdID0geUV4dGVudFtleV07XG4gICAgICB9IGVsc2UgaWYgKGQzLmV2ZW50LmFsdEtleSkgY2VudGVyID0gb3JpZ2luLnNsaWNlKCk7XG4gICAgICBnLnN0eWxlKFwicG9pbnRlci1ldmVudHNcIiwgXCJub25lXCIpLnNlbGVjdEFsbChcIi5yZXNpemVcIikuc3R5bGUoXCJkaXNwbGF5XCIsIG51bGwpO1xuICAgICAgZDMuc2VsZWN0KFwiYm9keVwiKS5zdHlsZShcImN1cnNvclwiLCBldmVudFRhcmdldC5zdHlsZShcImN1cnNvclwiKSk7XG4gICAgICBldmVudF8oe1xuICAgICAgICB0eXBlOiBcImJydXNoc3RhcnRcIlxuICAgICAgfSk7XG4gICAgICBicnVzaG1vdmUoKTtcbiAgICAgIGZ1bmN0aW9uIGtleWRvd24oKSB7XG4gICAgICAgIGlmIChkMy5ldmVudC5rZXlDb2RlID09IDMyKSB7XG4gICAgICAgICAgaWYgKCFkcmFnZ2luZykge1xuICAgICAgICAgICAgY2VudGVyID0gbnVsbDtcbiAgICAgICAgICAgIG9yaWdpblswXSAtPSB4RXh0ZW50WzFdO1xuICAgICAgICAgICAgb3JpZ2luWzFdIC09IHlFeHRlbnRbMV07XG4gICAgICAgICAgICBkcmFnZ2luZyA9IDI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGQzX2V2ZW50UHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZnVuY3Rpb24ga2V5dXAoKSB7XG4gICAgICAgIGlmIChkMy5ldmVudC5rZXlDb2RlID09IDMyICYmIGRyYWdnaW5nID09IDIpIHtcbiAgICAgICAgICBvcmlnaW5bMF0gKz0geEV4dGVudFsxXTtcbiAgICAgICAgICBvcmlnaW5bMV0gKz0geUV4dGVudFsxXTtcbiAgICAgICAgICBkcmFnZ2luZyA9IDA7XG4gICAgICAgICAgZDNfZXZlbnRQcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBicnVzaG1vdmUoKSB7XG4gICAgICAgIHZhciBwb2ludCA9IGQzLm1vdXNlKHRhcmdldCksIG1vdmVkID0gZmFsc2U7XG4gICAgICAgIGlmIChvZmZzZXQpIHtcbiAgICAgICAgICBwb2ludFswXSArPSBvZmZzZXRbMF07XG4gICAgICAgICAgcG9pbnRbMV0gKz0gb2Zmc2V0WzFdO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZHJhZ2dpbmcpIHtcbiAgICAgICAgICBpZiAoZDMuZXZlbnQuYWx0S2V5KSB7XG4gICAgICAgICAgICBpZiAoIWNlbnRlcikgY2VudGVyID0gWyAoeEV4dGVudFswXSArIHhFeHRlbnRbMV0pIC8gMiwgKHlFeHRlbnRbMF0gKyB5RXh0ZW50WzFdKSAvIDIgXTtcbiAgICAgICAgICAgIG9yaWdpblswXSA9IHhFeHRlbnRbKyhwb2ludFswXSA8IGNlbnRlclswXSldO1xuICAgICAgICAgICAgb3JpZ2luWzFdID0geUV4dGVudFsrKHBvaW50WzFdIDwgY2VudGVyWzFdKV07XG4gICAgICAgICAgfSBlbHNlIGNlbnRlciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc2l6aW5nWCAmJiBtb3ZlMShwb2ludCwgeCwgMCkpIHtcbiAgICAgICAgICByZWRyYXdYKGcpO1xuICAgICAgICAgIG1vdmVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzaXppbmdZICYmIG1vdmUxKHBvaW50LCB5LCAxKSkge1xuICAgICAgICAgIHJlZHJhd1koZyk7XG4gICAgICAgICAgbW92ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtb3ZlZCkge1xuICAgICAgICAgIHJlZHJhdyhnKTtcbiAgICAgICAgICBldmVudF8oe1xuICAgICAgICAgICAgdHlwZTogXCJicnVzaFwiLFxuICAgICAgICAgICAgbW9kZTogZHJhZ2dpbmcgPyBcIm1vdmVcIiA6IFwicmVzaXplXCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZnVuY3Rpb24gbW92ZTEocG9pbnQsIHNjYWxlLCBpKSB7XG4gICAgICAgIHZhciByYW5nZSA9IGQzX3NjYWxlUmFuZ2Uoc2NhbGUpLCByMCA9IHJhbmdlWzBdLCByMSA9IHJhbmdlWzFdLCBwb3NpdGlvbiA9IG9yaWdpbltpXSwgZXh0ZW50ID0gaSA/IHlFeHRlbnQgOiB4RXh0ZW50LCBzaXplID0gZXh0ZW50WzFdIC0gZXh0ZW50WzBdLCBtaW4sIG1heDtcbiAgICAgICAgaWYgKGRyYWdnaW5nKSB7XG4gICAgICAgICAgcjAgLT0gcG9zaXRpb247XG4gICAgICAgICAgcjEgLT0gc2l6ZSArIHBvc2l0aW9uO1xuICAgICAgICB9XG4gICAgICAgIG1pbiA9IChpID8geUNsYW1wIDogeENsYW1wKSA/IE1hdGgubWF4KHIwLCBNYXRoLm1pbihyMSwgcG9pbnRbaV0pKSA6IHBvaW50W2ldO1xuICAgICAgICBpZiAoZHJhZ2dpbmcpIHtcbiAgICAgICAgICBtYXggPSAobWluICs9IHBvc2l0aW9uKSArIHNpemU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGNlbnRlcikgcG9zaXRpb24gPSBNYXRoLm1heChyMCwgTWF0aC5taW4ocjEsIDIgKiBjZW50ZXJbaV0gLSBtaW4pKTtcbiAgICAgICAgICBpZiAocG9zaXRpb24gPCBtaW4pIHtcbiAgICAgICAgICAgIG1heCA9IG1pbjtcbiAgICAgICAgICAgIG1pbiA9IHBvc2l0aW9uO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtYXggPSBwb3NpdGlvbjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV4dGVudFswXSAhPSBtaW4gfHwgZXh0ZW50WzFdICE9IG1heCkge1xuICAgICAgICAgIGlmIChpKSB5RXh0ZW50RG9tYWluID0gbnVsbDsgZWxzZSB4RXh0ZW50RG9tYWluID0gbnVsbDtcbiAgICAgICAgICBleHRlbnRbMF0gPSBtaW47XG4gICAgICAgICAgZXh0ZW50WzFdID0gbWF4O1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBicnVzaGVuZCgpIHtcbiAgICAgICAgYnJ1c2htb3ZlKCk7XG4gICAgICAgIGcuc3R5bGUoXCJwb2ludGVyLWV2ZW50c1wiLCBcImFsbFwiKS5zZWxlY3RBbGwoXCIucmVzaXplXCIpLnN0eWxlKFwiZGlzcGxheVwiLCBicnVzaC5lbXB0eSgpID8gXCJub25lXCIgOiBudWxsKTtcbiAgICAgICAgZDMuc2VsZWN0KFwiYm9keVwiKS5zdHlsZShcImN1cnNvclwiLCBudWxsKTtcbiAgICAgICAgdy5vbihcIm1vdXNlbW92ZS5icnVzaFwiLCBudWxsKS5vbihcIm1vdXNldXAuYnJ1c2hcIiwgbnVsbCkub24oXCJ0b3VjaG1vdmUuYnJ1c2hcIiwgbnVsbCkub24oXCJ0b3VjaGVuZC5icnVzaFwiLCBudWxsKS5vbihcImtleWRvd24uYnJ1c2hcIiwgbnVsbCkub24oXCJrZXl1cC5icnVzaFwiLCBudWxsKTtcbiAgICAgICAgZHJhZ1Jlc3RvcmUoKTtcbiAgICAgICAgZXZlbnRfKHtcbiAgICAgICAgICB0eXBlOiBcImJydXNoZW5kXCJcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGJydXNoLnggPSBmdW5jdGlvbih6KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB4O1xuICAgICAgeCA9IHo7XG4gICAgICByZXNpemVzID0gZDNfc3ZnX2JydXNoUmVzaXplc1sheCA8PCAxIHwgIXldO1xuICAgICAgcmV0dXJuIGJydXNoO1xuICAgIH07XG4gICAgYnJ1c2gueSA9IGZ1bmN0aW9uKHopIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHk7XG4gICAgICB5ID0gejtcbiAgICAgIHJlc2l6ZXMgPSBkM19zdmdfYnJ1c2hSZXNpemVzWyF4IDw8IDEgfCAheV07XG4gICAgICByZXR1cm4gYnJ1c2g7XG4gICAgfTtcbiAgICBicnVzaC5jbGFtcCA9IGZ1bmN0aW9uKHopIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHggJiYgeSA/IFsgeENsYW1wLCB5Q2xhbXAgXSA6IHggPyB4Q2xhbXAgOiB5ID8geUNsYW1wIDogbnVsbDtcbiAgICAgIGlmICh4ICYmIHkpIHhDbGFtcCA9ICEhelswXSwgeUNsYW1wID0gISF6WzFdOyBlbHNlIGlmICh4KSB4Q2xhbXAgPSAhIXo7IGVsc2UgaWYgKHkpIHlDbGFtcCA9ICEhejtcbiAgICAgIHJldHVybiBicnVzaDtcbiAgICB9O1xuICAgIGJydXNoLmV4dGVudCA9IGZ1bmN0aW9uKHopIHtcbiAgICAgIHZhciB4MCwgeDEsIHkwLCB5MSwgdDtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICBpZiAoeCkge1xuICAgICAgICAgIGlmICh4RXh0ZW50RG9tYWluKSB7XG4gICAgICAgICAgICB4MCA9IHhFeHRlbnREb21haW5bMF0sIHgxID0geEV4dGVudERvbWFpblsxXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgeDAgPSB4RXh0ZW50WzBdLCB4MSA9IHhFeHRlbnRbMV07XG4gICAgICAgICAgICBpZiAoeC5pbnZlcnQpIHgwID0geC5pbnZlcnQoeDApLCB4MSA9IHguaW52ZXJ0KHgxKTtcbiAgICAgICAgICAgIGlmICh4MSA8IHgwKSB0ID0geDAsIHgwID0geDEsIHgxID0gdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHkpIHtcbiAgICAgICAgICBpZiAoeUV4dGVudERvbWFpbikge1xuICAgICAgICAgICAgeTAgPSB5RXh0ZW50RG9tYWluWzBdLCB5MSA9IHlFeHRlbnREb21haW5bMV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHkwID0geUV4dGVudFswXSwgeTEgPSB5RXh0ZW50WzFdO1xuICAgICAgICAgICAgaWYgKHkuaW52ZXJ0KSB5MCA9IHkuaW52ZXJ0KHkwKSwgeTEgPSB5LmludmVydCh5MSk7XG4gICAgICAgICAgICBpZiAoeTEgPCB5MCkgdCA9IHkwLCB5MCA9IHkxLCB5MSA9IHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB4ICYmIHkgPyBbIFsgeDAsIHkwIF0sIFsgeDEsIHkxIF0gXSA6IHggPyBbIHgwLCB4MSBdIDogeSAmJiBbIHkwLCB5MSBdO1xuICAgICAgfVxuICAgICAgaWYgKHgpIHtcbiAgICAgICAgeDAgPSB6WzBdLCB4MSA9IHpbMV07XG4gICAgICAgIGlmICh5KSB4MCA9IHgwWzBdLCB4MSA9IHgxWzBdO1xuICAgICAgICB4RXh0ZW50RG9tYWluID0gWyB4MCwgeDEgXTtcbiAgICAgICAgaWYgKHguaW52ZXJ0KSB4MCA9IHgoeDApLCB4MSA9IHgoeDEpO1xuICAgICAgICBpZiAoeDEgPCB4MCkgdCA9IHgwLCB4MCA9IHgxLCB4MSA9IHQ7XG4gICAgICAgIGlmICh4MCAhPSB4RXh0ZW50WzBdIHx8IHgxICE9IHhFeHRlbnRbMV0pIHhFeHRlbnQgPSBbIHgwLCB4MSBdO1xuICAgICAgfVxuICAgICAgaWYgKHkpIHtcbiAgICAgICAgeTAgPSB6WzBdLCB5MSA9IHpbMV07XG4gICAgICAgIGlmICh4KSB5MCA9IHkwWzFdLCB5MSA9IHkxWzFdO1xuICAgICAgICB5RXh0ZW50RG9tYWluID0gWyB5MCwgeTEgXTtcbiAgICAgICAgaWYgKHkuaW52ZXJ0KSB5MCA9IHkoeTApLCB5MSA9IHkoeTEpO1xuICAgICAgICBpZiAoeTEgPCB5MCkgdCA9IHkwLCB5MCA9IHkxLCB5MSA9IHQ7XG4gICAgICAgIGlmICh5MCAhPSB5RXh0ZW50WzBdIHx8IHkxICE9IHlFeHRlbnRbMV0pIHlFeHRlbnQgPSBbIHkwLCB5MSBdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJydXNoO1xuICAgIH07XG4gICAgYnJ1c2guY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghYnJ1c2guZW1wdHkoKSkge1xuICAgICAgICB4RXh0ZW50ID0gWyAwLCAwIF0sIHlFeHRlbnQgPSBbIDAsIDAgXTtcbiAgICAgICAgeEV4dGVudERvbWFpbiA9IHlFeHRlbnREb21haW4gPSBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJydXNoO1xuICAgIH07XG4gICAgYnJ1c2guZW1wdHkgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAhIXggJiYgeEV4dGVudFswXSA9PSB4RXh0ZW50WzFdIHx8ICEheSAmJiB5RXh0ZW50WzBdID09IHlFeHRlbnRbMV07XG4gICAgfTtcbiAgICByZXR1cm4gZDMucmViaW5kKGJydXNoLCBldmVudCwgXCJvblwiKTtcbiAgfTtcbiAgdmFyIGQzX3N2Z19icnVzaEN1cnNvciA9IHtcbiAgICBuOiBcIm5zLXJlc2l6ZVwiLFxuICAgIGU6IFwiZXctcmVzaXplXCIsXG4gICAgczogXCJucy1yZXNpemVcIixcbiAgICB3OiBcImV3LXJlc2l6ZVwiLFxuICAgIG53OiBcIm53c2UtcmVzaXplXCIsXG4gICAgbmU6IFwibmVzdy1yZXNpemVcIixcbiAgICBzZTogXCJud3NlLXJlc2l6ZVwiLFxuICAgIHN3OiBcIm5lc3ctcmVzaXplXCJcbiAgfTtcbiAgdmFyIGQzX3N2Z19icnVzaFJlc2l6ZXMgPSBbIFsgXCJuXCIsIFwiZVwiLCBcInNcIiwgXCJ3XCIsIFwibndcIiwgXCJuZVwiLCBcInNlXCIsIFwic3dcIiBdLCBbIFwiZVwiLCBcIndcIiBdLCBbIFwiblwiLCBcInNcIiBdLCBbXSBdO1xuICB2YXIgZDNfdGltZV9mb3JtYXQgPSBkM190aW1lLmZvcm1hdCA9IGQzX2xvY2FsZV9lblVTLnRpbWVGb3JtYXQ7XG4gIHZhciBkM190aW1lX2Zvcm1hdFV0YyA9IGQzX3RpbWVfZm9ybWF0LnV0YztcbiAgdmFyIGQzX3RpbWVfZm9ybWF0SXNvID0gZDNfdGltZV9mb3JtYXRVdGMoXCIlWS0lbS0lZFQlSDolTTolUy4lTFpcIik7XG4gIGQzX3RpbWVfZm9ybWF0LmlzbyA9IERhdGUucHJvdG90eXBlLnRvSVNPU3RyaW5nICYmICtuZXcgRGF0ZShcIjIwMDAtMDEtMDFUMDA6MDA6MDAuMDAwWlwiKSA/IGQzX3RpbWVfZm9ybWF0SXNvTmF0aXZlIDogZDNfdGltZV9mb3JtYXRJc287XG4gIGZ1bmN0aW9uIGQzX3RpbWVfZm9ybWF0SXNvTmF0aXZlKGRhdGUpIHtcbiAgICByZXR1cm4gZGF0ZS50b0lTT1N0cmluZygpO1xuICB9XG4gIGQzX3RpbWVfZm9ybWF0SXNvTmF0aXZlLnBhcnNlID0gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgdmFyIGRhdGUgPSBuZXcgRGF0ZShzdHJpbmcpO1xuICAgIHJldHVybiBpc05hTihkYXRlKSA/IG51bGwgOiBkYXRlO1xuICB9O1xuICBkM190aW1lX2Zvcm1hdElzb05hdGl2ZS50b1N0cmluZyA9IGQzX3RpbWVfZm9ybWF0SXNvLnRvU3RyaW5nO1xuICBkM190aW1lLnNlY29uZCA9IGQzX3RpbWVfaW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICAgIHJldHVybiBuZXcgZDNfZGF0ZShNYXRoLmZsb29yKGRhdGUgLyAxZTMpICogMWUzKTtcbiAgfSwgZnVuY3Rpb24oZGF0ZSwgb2Zmc2V0KSB7XG4gICAgZGF0ZS5zZXRUaW1lKGRhdGUuZ2V0VGltZSgpICsgTWF0aC5mbG9vcihvZmZzZXQpICogMWUzKTtcbiAgfSwgZnVuY3Rpb24oZGF0ZSkge1xuICAgIHJldHVybiBkYXRlLmdldFNlY29uZHMoKTtcbiAgfSk7XG4gIGQzX3RpbWUuc2Vjb25kcyA9IGQzX3RpbWUuc2Vjb25kLnJhbmdlO1xuICBkM190aW1lLnNlY29uZHMudXRjID0gZDNfdGltZS5zZWNvbmQudXRjLnJhbmdlO1xuICBkM190aW1lLm1pbnV0ZSA9IGQzX3RpbWVfaW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICAgIHJldHVybiBuZXcgZDNfZGF0ZShNYXRoLmZsb29yKGRhdGUgLyA2ZTQpICogNmU0KTtcbiAgfSwgZnVuY3Rpb24oZGF0ZSwgb2Zmc2V0KSB7XG4gICAgZGF0ZS5zZXRUaW1lKGRhdGUuZ2V0VGltZSgpICsgTWF0aC5mbG9vcihvZmZzZXQpICogNmU0KTtcbiAgfSwgZnVuY3Rpb24oZGF0ZSkge1xuICAgIHJldHVybiBkYXRlLmdldE1pbnV0ZXMoKTtcbiAgfSk7XG4gIGQzX3RpbWUubWludXRlcyA9IGQzX3RpbWUubWludXRlLnJhbmdlO1xuICBkM190aW1lLm1pbnV0ZXMudXRjID0gZDNfdGltZS5taW51dGUudXRjLnJhbmdlO1xuICBkM190aW1lLmhvdXIgPSBkM190aW1lX2ludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgICB2YXIgdGltZXpvbmUgPSBkYXRlLmdldFRpbWV6b25lT2Zmc2V0KCkgLyA2MDtcbiAgICByZXR1cm4gbmV3IGQzX2RhdGUoKE1hdGguZmxvb3IoZGF0ZSAvIDM2ZTUgLSB0aW1lem9uZSkgKyB0aW1lem9uZSkgKiAzNmU1KTtcbiAgfSwgZnVuY3Rpb24oZGF0ZSwgb2Zmc2V0KSB7XG4gICAgZGF0ZS5zZXRUaW1lKGRhdGUuZ2V0VGltZSgpICsgTWF0aC5mbG9vcihvZmZzZXQpICogMzZlNSk7XG4gIH0sIGZ1bmN0aW9uKGRhdGUpIHtcbiAgICByZXR1cm4gZGF0ZS5nZXRIb3VycygpO1xuICB9KTtcbiAgZDNfdGltZS5ob3VycyA9IGQzX3RpbWUuaG91ci5yYW5nZTtcbiAgZDNfdGltZS5ob3Vycy51dGMgPSBkM190aW1lLmhvdXIudXRjLnJhbmdlO1xuICBkM190aW1lLm1vbnRoID0gZDNfdGltZV9pbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gICAgZGF0ZSA9IGQzX3RpbWUuZGF5KGRhdGUpO1xuICAgIGRhdGUuc2V0RGF0ZSgxKTtcbiAgICByZXR1cm4gZGF0ZTtcbiAgfSwgZnVuY3Rpb24oZGF0ZSwgb2Zmc2V0KSB7XG4gICAgZGF0ZS5zZXRNb250aChkYXRlLmdldE1vbnRoKCkgKyBvZmZzZXQpO1xuICB9LCBmdW5jdGlvbihkYXRlKSB7XG4gICAgcmV0dXJuIGRhdGUuZ2V0TW9udGgoKTtcbiAgfSk7XG4gIGQzX3RpbWUubW9udGhzID0gZDNfdGltZS5tb250aC5yYW5nZTtcbiAgZDNfdGltZS5tb250aHMudXRjID0gZDNfdGltZS5tb250aC51dGMucmFuZ2U7XG4gIGZ1bmN0aW9uIGQzX3RpbWVfc2NhbGUobGluZWFyLCBtZXRob2RzLCBmb3JtYXQpIHtcbiAgICBmdW5jdGlvbiBzY2FsZSh4KSB7XG4gICAgICByZXR1cm4gbGluZWFyKHgpO1xuICAgIH1cbiAgICBzY2FsZS5pbnZlcnQgPSBmdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4gZDNfdGltZV9zY2FsZURhdGUobGluZWFyLmludmVydCh4KSk7XG4gICAgfTtcbiAgICBzY2FsZS5kb21haW4gPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBsaW5lYXIuZG9tYWluKCkubWFwKGQzX3RpbWVfc2NhbGVEYXRlKTtcbiAgICAgIGxpbmVhci5kb21haW4oeCk7XG4gICAgICByZXR1cm4gc2NhbGU7XG4gICAgfTtcbiAgICBmdW5jdGlvbiB0aWNrTWV0aG9kKGV4dGVudCwgY291bnQpIHtcbiAgICAgIHZhciBzcGFuID0gZXh0ZW50WzFdIC0gZXh0ZW50WzBdLCB0YXJnZXQgPSBzcGFuIC8gY291bnQsIGkgPSBkMy5iaXNlY3QoZDNfdGltZV9zY2FsZVN0ZXBzLCB0YXJnZXQpO1xuICAgICAgcmV0dXJuIGkgPT0gZDNfdGltZV9zY2FsZVN0ZXBzLmxlbmd0aCA/IFsgbWV0aG9kcy55ZWFyLCBkM19zY2FsZV9saW5lYXJUaWNrUmFuZ2UoZXh0ZW50Lm1hcChmdW5jdGlvbihkKSB7XG4gICAgICAgIHJldHVybiBkIC8gMzE1MzZlNjtcbiAgICAgIH0pLCBjb3VudClbMl0gXSA6ICFpID8gWyBkM190aW1lX3NjYWxlTWlsbGlzZWNvbmRzLCBkM19zY2FsZV9saW5lYXJUaWNrUmFuZ2UoZXh0ZW50LCBjb3VudClbMl0gXSA6IG1ldGhvZHNbdGFyZ2V0IC8gZDNfdGltZV9zY2FsZVN0ZXBzW2kgLSAxXSA8IGQzX3RpbWVfc2NhbGVTdGVwc1tpXSAvIHRhcmdldCA/IGkgLSAxIDogaV07XG4gICAgfVxuICAgIHNjYWxlLm5pY2UgPSBmdW5jdGlvbihpbnRlcnZhbCwgc2tpcCkge1xuICAgICAgdmFyIGRvbWFpbiA9IHNjYWxlLmRvbWFpbigpLCBleHRlbnQgPSBkM19zY2FsZUV4dGVudChkb21haW4pLCBtZXRob2QgPSBpbnRlcnZhbCA9PSBudWxsID8gdGlja01ldGhvZChleHRlbnQsIDEwKSA6IHR5cGVvZiBpbnRlcnZhbCA9PT0gXCJudW1iZXJcIiAmJiB0aWNrTWV0aG9kKGV4dGVudCwgaW50ZXJ2YWwpO1xuICAgICAgaWYgKG1ldGhvZCkgaW50ZXJ2YWwgPSBtZXRob2RbMF0sIHNraXAgPSBtZXRob2RbMV07XG4gICAgICBmdW5jdGlvbiBza2lwcGVkKGRhdGUpIHtcbiAgICAgICAgcmV0dXJuICFpc05hTihkYXRlKSAmJiAhaW50ZXJ2YWwucmFuZ2UoZGF0ZSwgZDNfdGltZV9zY2FsZURhdGUoK2RhdGUgKyAxKSwgc2tpcCkubGVuZ3RoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNjYWxlLmRvbWFpbihkM19zY2FsZV9uaWNlKGRvbWFpbiwgc2tpcCA+IDEgPyB7XG4gICAgICAgIGZsb29yOiBmdW5jdGlvbihkYXRlKSB7XG4gICAgICAgICAgd2hpbGUgKHNraXBwZWQoZGF0ZSA9IGludGVydmFsLmZsb29yKGRhdGUpKSkgZGF0ZSA9IGQzX3RpbWVfc2NhbGVEYXRlKGRhdGUgLSAxKTtcbiAgICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICAgICAgfSxcbiAgICAgICAgY2VpbDogZnVuY3Rpb24oZGF0ZSkge1xuICAgICAgICAgIHdoaWxlIChza2lwcGVkKGRhdGUgPSBpbnRlcnZhbC5jZWlsKGRhdGUpKSkgZGF0ZSA9IGQzX3RpbWVfc2NhbGVEYXRlKCtkYXRlICsgMSk7XG4gICAgICAgICAgcmV0dXJuIGRhdGU7XG4gICAgICAgIH1cbiAgICAgIH0gOiBpbnRlcnZhbCkpO1xuICAgIH07XG4gICAgc2NhbGUudGlja3MgPSBmdW5jdGlvbihpbnRlcnZhbCwgc2tpcCkge1xuICAgICAgdmFyIGV4dGVudCA9IGQzX3NjYWxlRXh0ZW50KHNjYWxlLmRvbWFpbigpKSwgbWV0aG9kID0gaW50ZXJ2YWwgPT0gbnVsbCA/IHRpY2tNZXRob2QoZXh0ZW50LCAxMCkgOiB0eXBlb2YgaW50ZXJ2YWwgPT09IFwibnVtYmVyXCIgPyB0aWNrTWV0aG9kKGV4dGVudCwgaW50ZXJ2YWwpIDogIWludGVydmFsLnJhbmdlICYmIFsge1xuICAgICAgICByYW5nZTogaW50ZXJ2YWxcbiAgICAgIH0sIHNraXAgXTtcbiAgICAgIGlmIChtZXRob2QpIGludGVydmFsID0gbWV0aG9kWzBdLCBza2lwID0gbWV0aG9kWzFdO1xuICAgICAgcmV0dXJuIGludGVydmFsLnJhbmdlKGV4dGVudFswXSwgZDNfdGltZV9zY2FsZURhdGUoK2V4dGVudFsxXSArIDEpLCBza2lwIDwgMSA/IDEgOiBza2lwKTtcbiAgICB9O1xuICAgIHNjYWxlLnRpY2tGb3JtYXQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBmb3JtYXQ7XG4gICAgfTtcbiAgICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZDNfdGltZV9zY2FsZShsaW5lYXIuY29weSgpLCBtZXRob2RzLCBmb3JtYXQpO1xuICAgIH07XG4gICAgcmV0dXJuIGQzX3NjYWxlX2xpbmVhclJlYmluZChzY2FsZSwgbGluZWFyKTtcbiAgfVxuICBmdW5jdGlvbiBkM190aW1lX3NjYWxlRGF0ZSh0KSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKHQpO1xuICB9XG4gIHZhciBkM190aW1lX3NjYWxlU3RlcHMgPSBbIDFlMywgNWUzLCAxNWUzLCAzZTQsIDZlNCwgM2U1LCA5ZTUsIDE4ZTUsIDM2ZTUsIDEwOGU1LCAyMTZlNSwgNDMyZTUsIDg2NGU1LCAxNzI4ZTUsIDYwNDhlNSwgMjU5MmU2LCA3Nzc2ZTYsIDMxNTM2ZTYgXTtcbiAgdmFyIGQzX3RpbWVfc2NhbGVMb2NhbE1ldGhvZHMgPSBbIFsgZDNfdGltZS5zZWNvbmQsIDEgXSwgWyBkM190aW1lLnNlY29uZCwgNSBdLCBbIGQzX3RpbWUuc2Vjb25kLCAxNSBdLCBbIGQzX3RpbWUuc2Vjb25kLCAzMCBdLCBbIGQzX3RpbWUubWludXRlLCAxIF0sIFsgZDNfdGltZS5taW51dGUsIDUgXSwgWyBkM190aW1lLm1pbnV0ZSwgMTUgXSwgWyBkM190aW1lLm1pbnV0ZSwgMzAgXSwgWyBkM190aW1lLmhvdXIsIDEgXSwgWyBkM190aW1lLmhvdXIsIDMgXSwgWyBkM190aW1lLmhvdXIsIDYgXSwgWyBkM190aW1lLmhvdXIsIDEyIF0sIFsgZDNfdGltZS5kYXksIDEgXSwgWyBkM190aW1lLmRheSwgMiBdLCBbIGQzX3RpbWUud2VlaywgMSBdLCBbIGQzX3RpbWUubW9udGgsIDEgXSwgWyBkM190aW1lLm1vbnRoLCAzIF0sIFsgZDNfdGltZS55ZWFyLCAxIF0gXTtcbiAgdmFyIGQzX3RpbWVfc2NhbGVMb2NhbEZvcm1hdCA9IGQzX3RpbWVfZm9ybWF0Lm11bHRpKFsgWyBcIi4lTFwiLCBmdW5jdGlvbihkKSB7XG4gICAgcmV0dXJuIGQuZ2V0TWlsbGlzZWNvbmRzKCk7XG4gIH0gXSwgWyBcIjolU1wiLCBmdW5jdGlvbihkKSB7XG4gICAgcmV0dXJuIGQuZ2V0U2Vjb25kcygpO1xuICB9IF0sIFsgXCIlSTolTVwiLCBmdW5jdGlvbihkKSB7XG4gICAgcmV0dXJuIGQuZ2V0TWludXRlcygpO1xuICB9IF0sIFsgXCIlSSAlcFwiLCBmdW5jdGlvbihkKSB7XG4gICAgcmV0dXJuIGQuZ2V0SG91cnMoKTtcbiAgfSBdLCBbIFwiJWEgJWRcIiwgZnVuY3Rpb24oZCkge1xuICAgIHJldHVybiBkLmdldERheSgpICYmIGQuZ2V0RGF0ZSgpICE9IDE7XG4gIH0gXSwgWyBcIiViICVkXCIsIGZ1bmN0aW9uKGQpIHtcbiAgICByZXR1cm4gZC5nZXREYXRlKCkgIT0gMTtcbiAgfSBdLCBbIFwiJUJcIiwgZnVuY3Rpb24oZCkge1xuICAgIHJldHVybiBkLmdldE1vbnRoKCk7XG4gIH0gXSwgWyBcIiVZXCIsIGQzX3RydWUgXSBdKTtcbiAgdmFyIGQzX3RpbWVfc2NhbGVNaWxsaXNlY29uZHMgPSB7XG4gICAgcmFuZ2U6IGZ1bmN0aW9uKHN0YXJ0LCBzdG9wLCBzdGVwKSB7XG4gICAgICByZXR1cm4gZDMucmFuZ2UoTWF0aC5jZWlsKHN0YXJ0IC8gc3RlcCkgKiBzdGVwLCArc3RvcCwgc3RlcCkubWFwKGQzX3RpbWVfc2NhbGVEYXRlKTtcbiAgICB9LFxuICAgIGZsb29yOiBkM19pZGVudGl0eSxcbiAgICBjZWlsOiBkM19pZGVudGl0eVxuICB9O1xuICBkM190aW1lX3NjYWxlTG9jYWxNZXRob2RzLnllYXIgPSBkM190aW1lLnllYXI7XG4gIGQzX3RpbWUuc2NhbGUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZDNfdGltZV9zY2FsZShkMy5zY2FsZS5saW5lYXIoKSwgZDNfdGltZV9zY2FsZUxvY2FsTWV0aG9kcywgZDNfdGltZV9zY2FsZUxvY2FsRm9ybWF0KTtcbiAgfTtcbiAgdmFyIGQzX3RpbWVfc2NhbGVVdGNNZXRob2RzID0gZDNfdGltZV9zY2FsZUxvY2FsTWV0aG9kcy5tYXAoZnVuY3Rpb24obSkge1xuICAgIHJldHVybiBbIG1bMF0udXRjLCBtWzFdIF07XG4gIH0pO1xuICB2YXIgZDNfdGltZV9zY2FsZVV0Y0Zvcm1hdCA9IGQzX3RpbWVfZm9ybWF0VXRjLm11bHRpKFsgWyBcIi4lTFwiLCBmdW5jdGlvbihkKSB7XG4gICAgcmV0dXJuIGQuZ2V0VVRDTWlsbGlzZWNvbmRzKCk7XG4gIH0gXSwgWyBcIjolU1wiLCBmdW5jdGlvbihkKSB7XG4gICAgcmV0dXJuIGQuZ2V0VVRDU2Vjb25kcygpO1xuICB9IF0sIFsgXCIlSTolTVwiLCBmdW5jdGlvbihkKSB7XG4gICAgcmV0dXJuIGQuZ2V0VVRDTWludXRlcygpO1xuICB9IF0sIFsgXCIlSSAlcFwiLCBmdW5jdGlvbihkKSB7XG4gICAgcmV0dXJuIGQuZ2V0VVRDSG91cnMoKTtcbiAgfSBdLCBbIFwiJWEgJWRcIiwgZnVuY3Rpb24oZCkge1xuICAgIHJldHVybiBkLmdldFVUQ0RheSgpICYmIGQuZ2V0VVRDRGF0ZSgpICE9IDE7XG4gIH0gXSwgWyBcIiViICVkXCIsIGZ1bmN0aW9uKGQpIHtcbiAgICByZXR1cm4gZC5nZXRVVENEYXRlKCkgIT0gMTtcbiAgfSBdLCBbIFwiJUJcIiwgZnVuY3Rpb24oZCkge1xuICAgIHJldHVybiBkLmdldFVUQ01vbnRoKCk7XG4gIH0gXSwgWyBcIiVZXCIsIGQzX3RydWUgXSBdKTtcbiAgZDNfdGltZV9zY2FsZVV0Y01ldGhvZHMueWVhciA9IGQzX3RpbWUueWVhci51dGM7XG4gIGQzX3RpbWUuc2NhbGUudXRjID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGQzX3RpbWVfc2NhbGUoZDMuc2NhbGUubGluZWFyKCksIGQzX3RpbWVfc2NhbGVVdGNNZXRob2RzLCBkM190aW1lX3NjYWxlVXRjRm9ybWF0KTtcbiAgfTtcbiAgZDMudGV4dCA9IGQzX3hoclR5cGUoZnVuY3Rpb24ocmVxdWVzdCkge1xuICAgIHJldHVybiByZXF1ZXN0LnJlc3BvbnNlVGV4dDtcbiAgfSk7XG4gIGQzLmpzb24gPSBmdW5jdGlvbih1cmwsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIGQzX3hocih1cmwsIFwiYXBwbGljYXRpb24vanNvblwiLCBkM19qc29uLCBjYWxsYmFjayk7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX2pzb24ocmVxdWVzdCkge1xuICAgIHJldHVybiBKU09OLnBhcnNlKHJlcXVlc3QucmVzcG9uc2VUZXh0KTtcbiAgfVxuICBkMy5odG1sID0gZnVuY3Rpb24odXJsLCBjYWxsYmFjaykge1xuICAgIHJldHVybiBkM194aHIodXJsLCBcInRleHQvaHRtbFwiLCBkM19odG1sLCBjYWxsYmFjayk7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX2h0bWwocmVxdWVzdCkge1xuICAgIHZhciByYW5nZSA9IGQzX2RvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgcmFuZ2Uuc2VsZWN0Tm9kZShkM19kb2N1bWVudC5ib2R5KTtcbiAgICByZXR1cm4gcmFuZ2UuY3JlYXRlQ29udGV4dHVhbEZyYWdtZW50KHJlcXVlc3QucmVzcG9uc2VUZXh0KTtcbiAgfVxuICBkMy54bWwgPSBkM194aHJUeXBlKGZ1bmN0aW9uKHJlcXVlc3QpIHtcbiAgICByZXR1cm4gcmVxdWVzdC5yZXNwb25zZVhNTDtcbiAgfSk7XG4gIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkgdGhpcy5kMyA9IGQzLCBkZWZpbmUoZDMpOyBlbHNlIGlmICh0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIG1vZHVsZS5leHBvcnRzKSBtb2R1bGUuZXhwb3J0cyA9IGQzOyBlbHNlIHRoaXMuZDMgPSBkMztcbn0oKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2dhbGF4eS9zY3JpcHRzL2xpYnMvZDMuanNcbi8vIG1vZHVsZSBpZCA9IDI5NVxuLy8gbW9kdWxlIGNodW5rcyA9IDEiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///295\n");

/***/ }),

/***/ 296:
/*!******************************************!*\
  !*** ./galaxy/scripts/galaxy.library.js ***!
  \******************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(Backbone, $) {\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _utils = __webpack_require__(/*! utils/utils */ 4);\n\nvar _utils2 = _interopRequireDefault(_utils);\n\nvar _toastr = __webpack_require__(/*! libs/toastr */ 7);\n\nvar _toastr2 = _interopRequireDefault(_toastr);\n\nvar _baseMvc = __webpack_require__(/*! mvc/base-mvc */ 5);\n\nvar _baseMvc2 = _interopRequireDefault(_baseMvc);\n\nvar _libraryModel = __webpack_require__(/*! mvc/library/library-model */ 13);\n\nvar _libraryModel2 = _interopRequireDefault(_libraryModel);\n\nvar _libraryFolderlistView = __webpack_require__(/*! mvc/library/library-folderlist-view */ 298);\n\nvar _libraryFolderlistView2 = _interopRequireDefault(_libraryFolderlistView);\n\nvar _libraryLibrarylistView = __webpack_require__(/*! mvc/library/library-librarylist-view */ 300);\n\nvar _libraryLibrarylistView2 = _interopRequireDefault(_libraryLibrarylistView);\n\nvar _libraryLibrarytoolbarView = __webpack_require__(/*! mvc/library/library-librarytoolbar-view */ 302);\n\nvar _libraryLibrarytoolbarView2 = _interopRequireDefault(_libraryLibrarytoolbarView);\n\nvar _libraryFoldertoolbarView = __webpack_require__(/*! mvc/library/library-foldertoolbar-view */ 303);\n\nvar _libraryFoldertoolbarView2 = _interopRequireDefault(_libraryFoldertoolbarView);\n\nvar _libraryDatasetView = __webpack_require__(/*! mvc/library/library-dataset-view */ 127);\n\nvar _libraryDatasetView2 = _interopRequireDefault(_libraryDatasetView);\n\nvar _libraryLibraryView = __webpack_require__(/*! mvc/library/library-library-view */ 304);\n\nvar _libraryLibraryView2 = _interopRequireDefault(_libraryLibraryView);\n\nvar _libraryFolderView = __webpack_require__(/*! mvc/library/library-folder-view */ 305);\n\nvar _libraryFolderView2 = _interopRequireDefault(_libraryFolderView);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// ============================================================================\n/**\n * The Data Libraries router. Takes care about triggering routes\n * and sends users to proper pieces of the application.\n */\nvar LibraryRouter = Backbone.Router.extend({\n    initialize: function initialize() {\n        this.routesHit = 0;\n        // keep count of number of routes handled by the application\n        Backbone.history.on(\"route\", function () {\n            this.routesHit++;\n        }, this);\n\n        this.bind(\"route\", this.trackPageview);\n    },\n\n    routes: {\n        \"\": \"libraries\",\n        \"page/:show_page\": \"libraries_page\",\n        \"library/:library_id/permissions\": \"library_permissions\",\n        \"folders/:folder_id/permissions\": \"folder_permissions\",\n        \"folders/:id\": \"folder_content\",\n        \"folders/:id/page/:show_page\": \"folder_page\",\n        \"folders/:folder_id/datasets/:dataset_id\": \"dataset_detail\",\n        \"folders/:folder_id/datasets/:dataset_id/permissions\": \"dataset_permissions\",\n        \"folders/:folder_id/datasets/:dataset_id/versions/:ldda_id\": \"dataset_version\",\n        \"folders/:folder_id/download/:format\": \"download\",\n        \"folders/:folder_id/import/:source\": \"import_datasets\"\n    },\n\n    /**\n     * If more than one route has been hit the user did not land on current\n     * page directly so we can go back safely. Otherwise go to the home page.\n     * Use replaceState if available so the navigation doesn't create an\n     * extra history entry\n     */\n    back: function back() {\n        if (this.routesHit > 1) {\n            window.history.back();\n        } else {\n            this.navigate(\"#\", { trigger: true, replace: true });\n        }\n    },\n\n    /**\n     * Track every route change as a page view in Google Analytics.\n     */\n    trackPageview: function trackPageview() {\n        var url = Backbone.history.getFragment();\n        //prepend slash\n        if (!/^\\//.test(url) && url != \"\") {\n            url = \"/\" + url;\n        }\n        if (typeof ga !== \"undefined\") {\n            ga(\"send\", \"pageview\", Galaxy.root + \"library/list\" + url);\n        }\n    }\n});\n\n// ============================================================================\n/** session storage for library preferences */\n// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\n// === MAIN GALAXY LIBRARY MODULE ====\n// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\n\nvar LibraryPrefs = _baseMvc2.default.SessionStorageModel.extend({\n    defaults: {\n        with_deleted: false,\n        without_restricted: false,\n        sort_order: \"asc\",\n        sort_by: \"name\",\n        library_page_size: 20,\n        folder_page_size: 15\n    }\n});\n\n// ============================================================================\n/**\n * Main view of the Galaxy Data Libraries. Stores pointers to other subviews\n * and defines what router should do on the route triggers.\n */\nvar GalaxyLibrary = Backbone.View.extend({\n    libraryToolbarView: null,\n    libraryListView: null,\n    library_router: null,\n    libraryView: null,\n    folderToolbarView: null,\n    folderListView: null,\n    datasetView: null,\n\n    initialize: function initialize() {\n        // This should go upstream in the js app once available\n        if (window.Galaxy.config.ga_code) {\n            (function (i, s, o, g, r, a, m) {\n                i[\"GoogleAnalyticsObject\"] = r;\n                i[r] = i[r] || function () {\n                    (i[r].q = i[r].q || []).push(arguments);\n                }, i[r].l = 1 * new Date();\n                a = s.createElement(o), m = s.getElementsByTagName(o)[0];\n                a.async = 1;\n                a.src = g;\n                m.parentNode.insertBefore(a, m);\n            })(window, document, \"script\", \"//www.google-analytics.com/analytics.js\", \"ga\");\n            ga(\"create\", window.Galaxy.config.ga_code, \"auto\");\n            ga(\"send\", \"pageview\");\n        }\n\n        Galaxy.libraries = this;\n\n        this.preferences = new LibraryPrefs({ id: \"global-lib-prefs\" });\n\n        this.library_router = new LibraryRouter();\n\n        this.library_router.on(\"route:libraries\", function () {\n            if (Galaxy.libraries.libraryToolbarView) {\n                Galaxy.libraries.libraryToolbarView.$el.unbind(\"click\");\n            }\n            Galaxy.libraries.libraryToolbarView = new _libraryLibrarytoolbarView2.default.LibraryToolbarView();\n            Galaxy.libraries.libraryListView = new _libraryLibrarylistView2.default.LibraryListView();\n        });\n\n        this.library_router.on(\"route:libraries_page\", function (show_page) {\n            if (Galaxy.libraries.libraryToolbarView === null) {\n                Galaxy.libraries.libraryToolbarView = new _libraryLibrarytoolbarView2.default.LibraryToolbarView();\n                Galaxy.libraries.libraryListView = new _libraryLibrarylistView2.default.LibraryListView({ show_page: show_page });\n            } else {\n                Galaxy.libraries.libraryListView.render({\n                    show_page: show_page\n                });\n            }\n        });\n\n        this.library_router.on(\"route:folder_content\", function (id) {\n            if (Galaxy.libraries.folderToolbarView) {\n                Galaxy.libraries.folderToolbarView.$el.unbind(\"click\");\n            }\n            Galaxy.libraries.folderToolbarView = new _libraryFoldertoolbarView2.default.FolderToolbarView({ id: id });\n            Galaxy.libraries.folderListView = new _libraryFolderlistView2.default.FolderListView({ id: id });\n        });\n\n        this.library_router.on(\"route:folder_page\", function (id, show_page) {\n            if (Galaxy.libraries.folderToolbarView === null) {\n                Galaxy.libraries.folderToolbarView = new _libraryFoldertoolbarView2.default.FolderToolbarView({ id: id });\n                Galaxy.libraries.folderListView = new _libraryFolderlistView2.default.FolderListView({\n                    id: id,\n                    show_page: show_page\n                });\n            } else {\n                Galaxy.libraries.folderListView.render({\n                    id: id,\n                    show_page: parseInt(show_page)\n                });\n            }\n        });\n\n        this.library_router.on(\"route:download\", function (folder_id, format) {\n            if ($(\"#folder_list_body\").find(\":checked\").length === 0) {\n                _toastr2.default.info(\"You must select at least one dataset to download\");\n                Galaxy.libraries.library_router.navigate(\"folders/\" + folder_id, { trigger: true, replace: true });\n            } else {\n                Galaxy.libraries.folderToolbarView.download(folder_id, format);\n                Galaxy.libraries.library_router.navigate(\"folders/\" + folder_id, { trigger: false, replace: true });\n            }\n        });\n\n        this.library_router.on(\"route:dataset_detail\", function (folder_id, dataset_id) {\n            if (Galaxy.libraries.datasetView) {\n                Galaxy.libraries.datasetView.$el.unbind(\"click\");\n            }\n            Galaxy.libraries.datasetView = new _libraryDatasetView2.default.LibraryDatasetView({\n                id: dataset_id,\n                show_version: false,\n                show_permissions: false\n            });\n        });\n\n        this.library_router.on(\"route:dataset_version\", function (folder_id, dataset_id, ldda_id) {\n            if (Galaxy.libraries.datasetView) {\n                Galaxy.libraries.datasetView.$el.unbind(\"click\");\n            }\n            Galaxy.libraries.datasetView = new _libraryDatasetView2.default.LibraryDatasetView({\n                id: dataset_id,\n                ldda_id: ldda_id,\n                show_version: true\n            });\n        });\n\n        this.library_router.on(\"route:dataset_permissions\", function (folder_id, dataset_id) {\n            if (Galaxy.libraries.datasetView) {\n                Galaxy.libraries.datasetView.$el.unbind(\"click\");\n            }\n            Galaxy.libraries.datasetView = new _libraryDatasetView2.default.LibraryDatasetView({\n                id: dataset_id,\n                show_permissions: true\n            });\n        });\n\n        this.library_router.on(\"route:library_permissions\", function (library_id) {\n            if (Galaxy.libraries.libraryView) {\n                Galaxy.libraries.libraryView.$el.unbind(\"click\");\n            }\n            Galaxy.libraries.libraryView = new _libraryLibraryView2.default.LibraryView({\n                id: library_id,\n                show_permissions: true\n            });\n        });\n\n        this.library_router.on(\"route:folder_permissions\", function (folder_id) {\n            if (Galaxy.libraries.folderView) {\n                Galaxy.libraries.folderView.$el.unbind(\"click\");\n            }\n            Galaxy.libraries.folderView = new _libraryFolderView2.default.FolderView({\n                id: folder_id,\n                show_permissions: true\n            });\n        });\n\n        this.library_router.on(\"route:import_datasets\", function (folder_id, source) {\n            if (Galaxy.libraries.folderToolbarView && Galaxy.libraries.folderListView) {\n                Galaxy.libraries.folderToolbarView.showImportModal({\n                    source: source\n                });\n            } else {\n                Galaxy.libraries.folderToolbarView = new _libraryFoldertoolbarView2.default.FolderToolbarView({ id: folder_id });\n                Galaxy.libraries.folderListView = new _libraryFolderlistView2.default.FolderListView({ id: folder_id });\n                Galaxy.libraries.folderToolbarView.showImportModal({\n                    source: source\n                });\n            }\n        });\n\n        Backbone.history.start({ pushState: false });\n    }\n});\n\nexports.default = {\n    GalaxyApp: GalaxyLibrary\n};\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! libs/backbone */ 2), __webpack_require__(/*! jquery */ 0)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjk2LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL2dhbGF4eS9zY3JpcHRzL2dhbGF4eS5saWJyYXJ5LmpzP2UwZjgiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gTU1NTU1NTU1NTU1NTU1NTU1NTU1NTU1NTU1NTU1NTU1NTU1cbi8vID09PSBNQUlOIEdBTEFYWSBMSUJSQVJZIE1PRFVMRSA9PT09XG4vLyBNTU1NTU1NTU1NTU1NTU1NTU1NTU1NTU1NTU1NTU1NTU1NTVxuXG5pbXBvcnQgbW9kX3V0aWxzIGZyb20gXCJ1dGlscy91dGlsc1wiO1xuaW1wb3J0IG1vZF90b2FzdHIgZnJvbSBcImxpYnMvdG9hc3RyXCI7XG5pbXBvcnQgbW9kX2Jhc2VNVkMgZnJvbSBcIm12Yy9iYXNlLW12Y1wiO1xuaW1wb3J0IG1vZF9saWJyYXJ5X21vZGVsIGZyb20gXCJtdmMvbGlicmFyeS9saWJyYXJ5LW1vZGVsXCI7XG5pbXBvcnQgbW9kX2ZvbGRlcmxpc3RfdmlldyBmcm9tIFwibXZjL2xpYnJhcnkvbGlicmFyeS1mb2xkZXJsaXN0LXZpZXdcIjtcbmltcG9ydCBtb2RfbGlicmFyeWxpc3RfdmlldyBmcm9tIFwibXZjL2xpYnJhcnkvbGlicmFyeS1saWJyYXJ5bGlzdC12aWV3XCI7XG5pbXBvcnQgbW9kX2xpYnJhcnl0b29sYmFyX3ZpZXcgZnJvbSBcIm12Yy9saWJyYXJ5L2xpYnJhcnktbGlicmFyeXRvb2xiYXItdmlld1wiO1xuaW1wb3J0IG1vZF9mb2xkZXJ0b29sYmFyX3ZpZXcgZnJvbSBcIm12Yy9saWJyYXJ5L2xpYnJhcnktZm9sZGVydG9vbGJhci12aWV3XCI7XG5pbXBvcnQgbW9kX2xpYnJhcnlfZGF0YXNldF92aWV3IGZyb20gXCJtdmMvbGlicmFyeS9saWJyYXJ5LWRhdGFzZXQtdmlld1wiO1xuaW1wb3J0IG1vZF9saWJyYXJ5X2xpYnJhcnlfdmlldyBmcm9tIFwibXZjL2xpYnJhcnkvbGlicmFyeS1saWJyYXJ5LXZpZXdcIjtcbmltcG9ydCBtb2RfbGlicmFyeV9mb2xkZXJfdmlldyBmcm9tIFwibXZjL2xpYnJhcnkvbGlicmFyeS1mb2xkZXItdmlld1wiO1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLyoqXG4gKiBUaGUgRGF0YSBMaWJyYXJpZXMgcm91dGVyLiBUYWtlcyBjYXJlIGFib3V0IHRyaWdnZXJpbmcgcm91dGVzXG4gKiBhbmQgc2VuZHMgdXNlcnMgdG8gcHJvcGVyIHBpZWNlcyBvZiB0aGUgYXBwbGljYXRpb24uXG4gKi9cbnZhciBMaWJyYXJ5Um91dGVyID0gQmFja2JvbmUuUm91dGVyLmV4dGVuZCh7XG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMucm91dGVzSGl0ID0gMDtcbiAgICAgICAgLy8ga2VlcCBjb3VudCBvZiBudW1iZXIgb2Ygcm91dGVzIGhhbmRsZWQgYnkgdGhlIGFwcGxpY2F0aW9uXG4gICAgICAgIEJhY2tib25lLmhpc3Rvcnkub24oXG4gICAgICAgICAgICBcInJvdXRlXCIsXG4gICAgICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJvdXRlc0hpdCsrO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRoaXNcbiAgICAgICAgKTtcblxuICAgICAgICB0aGlzLmJpbmQoXCJyb3V0ZVwiLCB0aGlzLnRyYWNrUGFnZXZpZXcpO1xuICAgIH0sXG5cbiAgICByb3V0ZXM6IHtcbiAgICAgICAgXCJcIjogXCJsaWJyYXJpZXNcIixcbiAgICAgICAgXCJwYWdlLzpzaG93X3BhZ2VcIjogXCJsaWJyYXJpZXNfcGFnZVwiLFxuICAgICAgICBcImxpYnJhcnkvOmxpYnJhcnlfaWQvcGVybWlzc2lvbnNcIjogXCJsaWJyYXJ5X3Blcm1pc3Npb25zXCIsXG4gICAgICAgIFwiZm9sZGVycy86Zm9sZGVyX2lkL3Blcm1pc3Npb25zXCI6IFwiZm9sZGVyX3Blcm1pc3Npb25zXCIsXG4gICAgICAgIFwiZm9sZGVycy86aWRcIjogXCJmb2xkZXJfY29udGVudFwiLFxuICAgICAgICBcImZvbGRlcnMvOmlkL3BhZ2UvOnNob3dfcGFnZVwiOiBcImZvbGRlcl9wYWdlXCIsXG4gICAgICAgIFwiZm9sZGVycy86Zm9sZGVyX2lkL2RhdGFzZXRzLzpkYXRhc2V0X2lkXCI6IFwiZGF0YXNldF9kZXRhaWxcIixcbiAgICAgICAgXCJmb2xkZXJzLzpmb2xkZXJfaWQvZGF0YXNldHMvOmRhdGFzZXRfaWQvcGVybWlzc2lvbnNcIjogXCJkYXRhc2V0X3Blcm1pc3Npb25zXCIsXG4gICAgICAgIFwiZm9sZGVycy86Zm9sZGVyX2lkL2RhdGFzZXRzLzpkYXRhc2V0X2lkL3ZlcnNpb25zLzpsZGRhX2lkXCI6IFwiZGF0YXNldF92ZXJzaW9uXCIsXG4gICAgICAgIFwiZm9sZGVycy86Zm9sZGVyX2lkL2Rvd25sb2FkLzpmb3JtYXRcIjogXCJkb3dubG9hZFwiLFxuICAgICAgICBcImZvbGRlcnMvOmZvbGRlcl9pZC9pbXBvcnQvOnNvdXJjZVwiOiBcImltcG9ydF9kYXRhc2V0c1wiXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIElmIG1vcmUgdGhhbiBvbmUgcm91dGUgaGFzIGJlZW4gaGl0IHRoZSB1c2VyIGRpZCBub3QgbGFuZCBvbiBjdXJyZW50XG4gICAgICogcGFnZSBkaXJlY3RseSBzbyB3ZSBjYW4gZ28gYmFjayBzYWZlbHkuIE90aGVyd2lzZSBnbyB0byB0aGUgaG9tZSBwYWdlLlxuICAgICAqIFVzZSByZXBsYWNlU3RhdGUgaWYgYXZhaWxhYmxlIHNvIHRoZSBuYXZpZ2F0aW9uIGRvZXNuJ3QgY3JlYXRlIGFuXG4gICAgICogZXh0cmEgaGlzdG9yeSBlbnRyeVxuICAgICAqL1xuICAgIGJhY2s6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5yb3V0ZXNIaXQgPiAxKSB7XG4gICAgICAgICAgICB3aW5kb3cuaGlzdG9yeS5iYWNrKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm5hdmlnYXRlKFwiI1wiLCB7IHRyaWdnZXI6IHRydWUsIHJlcGxhY2U6IHRydWUgfSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVHJhY2sgZXZlcnkgcm91dGUgY2hhbmdlIGFzIGEgcGFnZSB2aWV3IGluIEdvb2dsZSBBbmFseXRpY3MuXG4gICAgICovXG4gICAgdHJhY2tQYWdldmlldzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB1cmwgPSBCYWNrYm9uZS5oaXN0b3J5LmdldEZyYWdtZW50KCk7XG4gICAgICAgIC8vcHJlcGVuZCBzbGFzaFxuICAgICAgICBpZiAoIS9eXFwvLy50ZXN0KHVybCkgJiYgdXJsICE9IFwiXCIpIHtcbiAgICAgICAgICAgIHVybCA9IGAvJHt1cmx9YDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGdhICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICBnYShcInNlbmRcIiwgXCJwYWdldmlld1wiLCBgJHtHYWxheHkucm9vdH1saWJyYXJ5L2xpc3Qke3VybH1gKTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vKiogc2Vzc2lvbiBzdG9yYWdlIGZvciBsaWJyYXJ5IHByZWZlcmVuY2VzICovXG52YXIgTGlicmFyeVByZWZzID0gbW9kX2Jhc2VNVkMuU2Vzc2lvblN0b3JhZ2VNb2RlbC5leHRlbmQoe1xuICAgIGRlZmF1bHRzOiB7XG4gICAgICAgIHdpdGhfZGVsZXRlZDogZmFsc2UsXG4gICAgICAgIHdpdGhvdXRfcmVzdHJpY3RlZDogZmFsc2UsXG4gICAgICAgIHNvcnRfb3JkZXI6IFwiYXNjXCIsXG4gICAgICAgIHNvcnRfYnk6IFwibmFtZVwiLFxuICAgICAgICBsaWJyYXJ5X3BhZ2Vfc2l6ZTogMjAsXG4gICAgICAgIGZvbGRlcl9wYWdlX3NpemU6IDE1XG4gICAgfVxufSk7XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8qKlxuICogTWFpbiB2aWV3IG9mIHRoZSBHYWxheHkgRGF0YSBMaWJyYXJpZXMuIFN0b3JlcyBwb2ludGVycyB0byBvdGhlciBzdWJ2aWV3c1xuICogYW5kIGRlZmluZXMgd2hhdCByb3V0ZXIgc2hvdWxkIGRvIG9uIHRoZSByb3V0ZSB0cmlnZ2Vycy5cbiAqL1xudmFyIEdhbGF4eUxpYnJhcnkgPSBCYWNrYm9uZS5WaWV3LmV4dGVuZCh7XG4gICAgbGlicmFyeVRvb2xiYXJWaWV3OiBudWxsLFxuICAgIGxpYnJhcnlMaXN0VmlldzogbnVsbCxcbiAgICBsaWJyYXJ5X3JvdXRlcjogbnVsbCxcbiAgICBsaWJyYXJ5VmlldzogbnVsbCxcbiAgICBmb2xkZXJUb29sYmFyVmlldzogbnVsbCxcbiAgICBmb2xkZXJMaXN0VmlldzogbnVsbCxcbiAgICBkYXRhc2V0VmlldzogbnVsbCxcblxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBUaGlzIHNob3VsZCBnbyB1cHN0cmVhbSBpbiB0aGUganMgYXBwIG9uY2UgYXZhaWxhYmxlXG4gICAgICAgIGlmICh3aW5kb3cuR2FsYXh5LmNvbmZpZy5nYV9jb2RlKSB7XG4gICAgICAgICAgICAoKGksIHMsIG8sIGcsIHIsIGEsIG0pID0+IHtcbiAgICAgICAgICAgICAgICBpW1wiR29vZ2xlQW5hbHl0aWNzT2JqZWN0XCJdID0gcjtcbiAgICAgICAgICAgICAgICAoaVtyXSA9XG4gICAgICAgICAgICAgICAgICAgIGlbcl0gfHxcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAoaVtyXS5xID0gaVtyXS5xIHx8IFtdKS5wdXNoKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAoaVtyXS5sID0gMSAqIG5ldyBEYXRlKCkpO1xuICAgICAgICAgICAgICAgIChhID0gcy5jcmVhdGVFbGVtZW50KG8pKSwgKG0gPSBzLmdldEVsZW1lbnRzQnlUYWdOYW1lKG8pWzBdKTtcbiAgICAgICAgICAgICAgICBhLmFzeW5jID0gMTtcbiAgICAgICAgICAgICAgICBhLnNyYyA9IGc7XG4gICAgICAgICAgICAgICAgbS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShhLCBtKTtcbiAgICAgICAgICAgIH0pKHdpbmRvdywgZG9jdW1lbnQsIFwic2NyaXB0XCIsIFwiLy93d3cuZ29vZ2xlLWFuYWx5dGljcy5jb20vYW5hbHl0aWNzLmpzXCIsIFwiZ2FcIik7XG4gICAgICAgICAgICBnYShcImNyZWF0ZVwiLCB3aW5kb3cuR2FsYXh5LmNvbmZpZy5nYV9jb2RlLCBcImF1dG9cIik7XG4gICAgICAgICAgICBnYShcInNlbmRcIiwgXCJwYWdldmlld1wiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIEdhbGF4eS5saWJyYXJpZXMgPSB0aGlzO1xuXG4gICAgICAgIHRoaXMucHJlZmVyZW5jZXMgPSBuZXcgTGlicmFyeVByZWZzKHsgaWQ6IFwiZ2xvYmFsLWxpYi1wcmVmc1wiIH0pO1xuXG4gICAgICAgIHRoaXMubGlicmFyeV9yb3V0ZXIgPSBuZXcgTGlicmFyeVJvdXRlcigpO1xuXG4gICAgICAgIHRoaXMubGlicmFyeV9yb3V0ZXIub24oXCJyb3V0ZTpsaWJyYXJpZXNcIiwgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKEdhbGF4eS5saWJyYXJpZXMubGlicmFyeVRvb2xiYXJWaWV3KSB7XG4gICAgICAgICAgICAgICAgR2FsYXh5LmxpYnJhcmllcy5saWJyYXJ5VG9vbGJhclZpZXcuJGVsLnVuYmluZChcImNsaWNrXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgR2FsYXh5LmxpYnJhcmllcy5saWJyYXJ5VG9vbGJhclZpZXcgPSBuZXcgbW9kX2xpYnJhcnl0b29sYmFyX3ZpZXcuTGlicmFyeVRvb2xiYXJWaWV3KCk7XG4gICAgICAgICAgICBHYWxheHkubGlicmFyaWVzLmxpYnJhcnlMaXN0VmlldyA9IG5ldyBtb2RfbGlicmFyeWxpc3Rfdmlldy5MaWJyYXJ5TGlzdFZpZXcoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5saWJyYXJ5X3JvdXRlci5vbihcInJvdXRlOmxpYnJhcmllc19wYWdlXCIsIHNob3dfcGFnZSA9PiB7XG4gICAgICAgICAgICBpZiAoR2FsYXh5LmxpYnJhcmllcy5saWJyYXJ5VG9vbGJhclZpZXcgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBHYWxheHkubGlicmFyaWVzLmxpYnJhcnlUb29sYmFyVmlldyA9IG5ldyBtb2RfbGlicmFyeXRvb2xiYXJfdmlldy5MaWJyYXJ5VG9vbGJhclZpZXcoKTtcbiAgICAgICAgICAgICAgICBHYWxheHkubGlicmFyaWVzLmxpYnJhcnlMaXN0VmlldyA9IG5ldyBtb2RfbGlicmFyeWxpc3Rfdmlldy5MaWJyYXJ5TGlzdFZpZXcoeyBzaG93X3BhZ2U6IHNob3dfcGFnZSB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgR2FsYXh5LmxpYnJhcmllcy5saWJyYXJ5TGlzdFZpZXcucmVuZGVyKHtcbiAgICAgICAgICAgICAgICAgICAgc2hvd19wYWdlOiBzaG93X3BhZ2VcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5saWJyYXJ5X3JvdXRlci5vbihcInJvdXRlOmZvbGRlcl9jb250ZW50XCIsIGlkID0+IHtcbiAgICAgICAgICAgIGlmIChHYWxheHkubGlicmFyaWVzLmZvbGRlclRvb2xiYXJWaWV3KSB7XG4gICAgICAgICAgICAgICAgR2FsYXh5LmxpYnJhcmllcy5mb2xkZXJUb29sYmFyVmlldy4kZWwudW5iaW5kKFwiY2xpY2tcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBHYWxheHkubGlicmFyaWVzLmZvbGRlclRvb2xiYXJWaWV3ID0gbmV3IG1vZF9mb2xkZXJ0b29sYmFyX3ZpZXcuRm9sZGVyVG9vbGJhclZpZXcoeyBpZDogaWQgfSk7XG4gICAgICAgICAgICBHYWxheHkubGlicmFyaWVzLmZvbGRlckxpc3RWaWV3ID0gbmV3IG1vZF9mb2xkZXJsaXN0X3ZpZXcuRm9sZGVyTGlzdFZpZXcoeyBpZDogaWQgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMubGlicmFyeV9yb3V0ZXIub24oXCJyb3V0ZTpmb2xkZXJfcGFnZVwiLCAoaWQsIHNob3dfcGFnZSkgPT4ge1xuICAgICAgICAgICAgaWYgKEdhbGF4eS5saWJyYXJpZXMuZm9sZGVyVG9vbGJhclZpZXcgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBHYWxheHkubGlicmFyaWVzLmZvbGRlclRvb2xiYXJWaWV3ID0gbmV3IG1vZF9mb2xkZXJ0b29sYmFyX3ZpZXcuRm9sZGVyVG9vbGJhclZpZXcoeyBpZDogaWQgfSk7XG4gICAgICAgICAgICAgICAgR2FsYXh5LmxpYnJhcmllcy5mb2xkZXJMaXN0VmlldyA9IG5ldyBtb2RfZm9sZGVybGlzdF92aWV3LkZvbGRlckxpc3RWaWV3KHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgICAgICAgICBzaG93X3BhZ2U6IHNob3dfcGFnZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBHYWxheHkubGlicmFyaWVzLmZvbGRlckxpc3RWaWV3LnJlbmRlcih7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgICAgICAgICAgc2hvd19wYWdlOiBwYXJzZUludChzaG93X3BhZ2UpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMubGlicmFyeV9yb3V0ZXIub24oXCJyb3V0ZTpkb3dubG9hZFwiLCAoZm9sZGVyX2lkLCBmb3JtYXQpID0+IHtcbiAgICAgICAgICAgIGlmICgkKFwiI2ZvbGRlcl9saXN0X2JvZHlcIikuZmluZChcIjpjaGVja2VkXCIpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIG1vZF90b2FzdHIuaW5mbyhcIllvdSBtdXN0IHNlbGVjdCBhdCBsZWFzdCBvbmUgZGF0YXNldCB0byBkb3dubG9hZFwiKTtcbiAgICAgICAgICAgICAgICBHYWxheHkubGlicmFyaWVzLmxpYnJhcnlfcm91dGVyLm5hdmlnYXRlKGBmb2xkZXJzLyR7Zm9sZGVyX2lkfWAsIHsgdHJpZ2dlcjogdHJ1ZSwgcmVwbGFjZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgR2FsYXh5LmxpYnJhcmllcy5mb2xkZXJUb29sYmFyVmlldy5kb3dubG9hZChmb2xkZXJfaWQsIGZvcm1hdCk7XG4gICAgICAgICAgICAgICAgR2FsYXh5LmxpYnJhcmllcy5saWJyYXJ5X3JvdXRlci5uYXZpZ2F0ZShgZm9sZGVycy8ke2ZvbGRlcl9pZH1gLCB7IHRyaWdnZXI6IGZhbHNlLCByZXBsYWNlOiB0cnVlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmxpYnJhcnlfcm91dGVyLm9uKFwicm91dGU6ZGF0YXNldF9kZXRhaWxcIiwgKGZvbGRlcl9pZCwgZGF0YXNldF9pZCkgPT4ge1xuICAgICAgICAgICAgaWYgKEdhbGF4eS5saWJyYXJpZXMuZGF0YXNldFZpZXcpIHtcbiAgICAgICAgICAgICAgICBHYWxheHkubGlicmFyaWVzLmRhdGFzZXRWaWV3LiRlbC51bmJpbmQoXCJjbGlja1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIEdhbGF4eS5saWJyYXJpZXMuZGF0YXNldFZpZXcgPSBuZXcgbW9kX2xpYnJhcnlfZGF0YXNldF92aWV3LkxpYnJhcnlEYXRhc2V0Vmlldyh7XG4gICAgICAgICAgICAgICAgaWQ6IGRhdGFzZXRfaWQsXG4gICAgICAgICAgICAgICAgc2hvd192ZXJzaW9uOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBzaG93X3Blcm1pc3Npb25zOiBmYWxzZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMubGlicmFyeV9yb3V0ZXIub24oXCJyb3V0ZTpkYXRhc2V0X3ZlcnNpb25cIiwgKGZvbGRlcl9pZCwgZGF0YXNldF9pZCwgbGRkYV9pZCkgPT4ge1xuICAgICAgICAgICAgaWYgKEdhbGF4eS5saWJyYXJpZXMuZGF0YXNldFZpZXcpIHtcbiAgICAgICAgICAgICAgICBHYWxheHkubGlicmFyaWVzLmRhdGFzZXRWaWV3LiRlbC51bmJpbmQoXCJjbGlja1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIEdhbGF4eS5saWJyYXJpZXMuZGF0YXNldFZpZXcgPSBuZXcgbW9kX2xpYnJhcnlfZGF0YXNldF92aWV3LkxpYnJhcnlEYXRhc2V0Vmlldyh7XG4gICAgICAgICAgICAgICAgaWQ6IGRhdGFzZXRfaWQsXG4gICAgICAgICAgICAgICAgbGRkYV9pZDogbGRkYV9pZCxcbiAgICAgICAgICAgICAgICBzaG93X3ZlcnNpb246IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmxpYnJhcnlfcm91dGVyLm9uKFwicm91dGU6ZGF0YXNldF9wZXJtaXNzaW9uc1wiLCAoZm9sZGVyX2lkLCBkYXRhc2V0X2lkKSA9PiB7XG4gICAgICAgICAgICBpZiAoR2FsYXh5LmxpYnJhcmllcy5kYXRhc2V0Vmlldykge1xuICAgICAgICAgICAgICAgIEdhbGF4eS5saWJyYXJpZXMuZGF0YXNldFZpZXcuJGVsLnVuYmluZChcImNsaWNrXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgR2FsYXh5LmxpYnJhcmllcy5kYXRhc2V0VmlldyA9IG5ldyBtb2RfbGlicmFyeV9kYXRhc2V0X3ZpZXcuTGlicmFyeURhdGFzZXRWaWV3KHtcbiAgICAgICAgICAgICAgICBpZDogZGF0YXNldF9pZCxcbiAgICAgICAgICAgICAgICBzaG93X3Blcm1pc3Npb25zOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5saWJyYXJ5X3JvdXRlci5vbihcInJvdXRlOmxpYnJhcnlfcGVybWlzc2lvbnNcIiwgbGlicmFyeV9pZCA9PiB7XG4gICAgICAgICAgICBpZiAoR2FsYXh5LmxpYnJhcmllcy5saWJyYXJ5Vmlldykge1xuICAgICAgICAgICAgICAgIEdhbGF4eS5saWJyYXJpZXMubGlicmFyeVZpZXcuJGVsLnVuYmluZChcImNsaWNrXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgR2FsYXh5LmxpYnJhcmllcy5saWJyYXJ5VmlldyA9IG5ldyBtb2RfbGlicmFyeV9saWJyYXJ5X3ZpZXcuTGlicmFyeVZpZXcoe1xuICAgICAgICAgICAgICAgIGlkOiBsaWJyYXJ5X2lkLFxuICAgICAgICAgICAgICAgIHNob3dfcGVybWlzc2lvbnM6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmxpYnJhcnlfcm91dGVyLm9uKFwicm91dGU6Zm9sZGVyX3Blcm1pc3Npb25zXCIsIGZvbGRlcl9pZCA9PiB7XG4gICAgICAgICAgICBpZiAoR2FsYXh5LmxpYnJhcmllcy5mb2xkZXJWaWV3KSB7XG4gICAgICAgICAgICAgICAgR2FsYXh5LmxpYnJhcmllcy5mb2xkZXJWaWV3LiRlbC51bmJpbmQoXCJjbGlja1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIEdhbGF4eS5saWJyYXJpZXMuZm9sZGVyVmlldyA9IG5ldyBtb2RfbGlicmFyeV9mb2xkZXJfdmlldy5Gb2xkZXJWaWV3KHtcbiAgICAgICAgICAgICAgICBpZDogZm9sZGVyX2lkLFxuICAgICAgICAgICAgICAgIHNob3dfcGVybWlzc2lvbnM6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmxpYnJhcnlfcm91dGVyLm9uKFwicm91dGU6aW1wb3J0X2RhdGFzZXRzXCIsIChmb2xkZXJfaWQsIHNvdXJjZSkgPT4ge1xuICAgICAgICAgICAgaWYgKEdhbGF4eS5saWJyYXJpZXMuZm9sZGVyVG9vbGJhclZpZXcgJiYgR2FsYXh5LmxpYnJhcmllcy5mb2xkZXJMaXN0Vmlldykge1xuICAgICAgICAgICAgICAgIEdhbGF4eS5saWJyYXJpZXMuZm9sZGVyVG9vbGJhclZpZXcuc2hvd0ltcG9ydE1vZGFsKHtcbiAgICAgICAgICAgICAgICAgICAgc291cmNlOiBzb3VyY2VcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgR2FsYXh5LmxpYnJhcmllcy5mb2xkZXJUb29sYmFyVmlldyA9IG5ldyBtb2RfZm9sZGVydG9vbGJhcl92aWV3LkZvbGRlclRvb2xiYXJWaWV3KHsgaWQ6IGZvbGRlcl9pZCB9KTtcbiAgICAgICAgICAgICAgICBHYWxheHkubGlicmFyaWVzLmZvbGRlckxpc3RWaWV3ID0gbmV3IG1vZF9mb2xkZXJsaXN0X3ZpZXcuRm9sZGVyTGlzdFZpZXcoeyBpZDogZm9sZGVyX2lkIH0pO1xuICAgICAgICAgICAgICAgIEdhbGF4eS5saWJyYXJpZXMuZm9sZGVyVG9vbGJhclZpZXcuc2hvd0ltcG9ydE1vZGFsKHtcbiAgICAgICAgICAgICAgICAgICAgc291cmNlOiBzb3VyY2VcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgQmFja2JvbmUuaGlzdG9yeS5zdGFydCh7IHB1c2hTdGF0ZTogZmFsc2UgfSk7XG4gICAgfVxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgICBHYWxheHlBcHA6IEdhbGF4eUxpYnJhcnlcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gZ2FsYXh5L3NjcmlwdHMvZ2FsYXh5LmxpYnJhcnkuanMiXSwibWFwcGluZ3MiOiI7Ozs7OztBQUlBO0FBQ0E7OztBQUFBO0FBQ0E7OztBQUFBO0FBQ0E7OztBQUFBO0FBQ0E7OztBQUFBO0FBQ0E7OztBQUFBO0FBQ0E7OztBQUFBO0FBQ0E7OztBQUFBO0FBQ0E7OztBQUFBO0FBQ0E7OztBQUFBO0FBQ0E7OztBQUFBO0FBQ0E7Ozs7O0FBQUE7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFYQTtBQUNBO0FBYUE7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUF2REE7QUFDQTtBQXlEQTtBQUNBO0FBL0VBO0FBQ0E7QUFDQTtBQUNBO0FBNkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQURBO0FBQ0E7QUFVQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQTFKQTtBQUNBO0FBNEpBO0FBQ0E7QUFEQTtBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///296\n");

/***/ }),

/***/ 297:
/*!****************************************************!*\
  !*** ./galaxy/scripts/mvc/library/library-util.js ***!
  \****************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n/**\n * Create alphabetical based two-argument comparator\n * that takes into account that Folder comes before Dataset.\n * If sort_key is not present it is set to ''.\n * @param  {str} sort_key   key to sort by\n * @param  {str} sort_order order to sort by (asc, desc)\n * @return {function} two-argument comparator function\n */\nvar generateFolderComparator = function generateFolderComparator(sort_key, sort_order) {\n    return function (itemA, itemB) {\n        if (itemA.get(\"type\") === itemB.get(\"type\")) {\n            if (!itemA.has(sort_key) && !itemB.has(sort_key)) {\n                return 0;\n            } else if (!itemA.has(sort_key)) {\n                return 1;\n            } else if (!itemB.has(sort_key)) {\n                return -1;\n            }\n            if (itemA.get(sort_key).toLowerCase() > itemB.get(sort_key).toLowerCase()) {\n                return sort_order === \"asc\" ? 1 : -1;\n            }\n            if (itemB.get(sort_key).toLowerCase() > itemA.get(sort_key).toLowerCase()) {\n                return sort_order === \"asc\" ? -1 : 1;\n            }\n            return 0; // equal\n        } else {\n            if (itemA.get(\"type\") === \"folder\") {\n                return -1; // folder is always before dataset\n            }\n            return 1;\n        }\n    };\n};\n/**\n * Create alphabetical based two-argument comparator\n * @param  {str} sort_key   key to sort by\n * @param  {str} sort_order order to sort by (asc, desc)\n * @return {function} two-argument comparator function\n */\nvar generateLibraryComparator = function generateLibraryComparator(sort_key, sort_order) {\n    return function (libraryA, libraryB) {\n        if (libraryA.get(sort_key).toLowerCase() > libraryB.get(sort_key).toLowerCase()) {\n            return sort_order === \"asc\" ? 1 : -1;\n        }\n        if (libraryB.get(sort_key).toLowerCase() > libraryA.get(sort_key).toLowerCase()) {\n            return sort_order === \"asc\" ? -1 : 1;\n        }\n        return 0; // equal\n    };\n};\nexports.default = {\n    generateFolderComparator: generateFolderComparator,\n    generateLibraryComparator: generateLibraryComparator\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjk3LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL2dhbGF4eS9zY3JpcHRzL212Yy9saWJyYXJ5L2xpYnJhcnktdXRpbC5qcz82YTc3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ3JlYXRlIGFscGhhYmV0aWNhbCBiYXNlZCB0d28tYXJndW1lbnQgY29tcGFyYXRvclxuICogdGhhdCB0YWtlcyBpbnRvIGFjY291bnQgdGhhdCBGb2xkZXIgY29tZXMgYmVmb3JlIERhdGFzZXQuXG4gKiBJZiBzb3J0X2tleSBpcyBub3QgcHJlc2VudCBpdCBpcyBzZXQgdG8gJycuXG4gKiBAcGFyYW0gIHtzdHJ9IHNvcnRfa2V5ICAga2V5IHRvIHNvcnQgYnlcbiAqIEBwYXJhbSAge3N0cn0gc29ydF9vcmRlciBvcmRlciB0byBzb3J0IGJ5IChhc2MsIGRlc2MpXG4gKiBAcmV0dXJuIHtmdW5jdGlvbn0gdHdvLWFyZ3VtZW50IGNvbXBhcmF0b3IgZnVuY3Rpb25cbiAqL1xudmFyIGdlbmVyYXRlRm9sZGVyQ29tcGFyYXRvciA9IChzb3J0X2tleSwgc29ydF9vcmRlcikgPT4gKGl0ZW1BLCBpdGVtQikgPT4ge1xuICAgIGlmIChpdGVtQS5nZXQoXCJ0eXBlXCIpID09PSBpdGVtQi5nZXQoXCJ0eXBlXCIpKSB7XG4gICAgICAgIGlmICghaXRlbUEuaGFzKHNvcnRfa2V5KSAmJiAhaXRlbUIuaGFzKHNvcnRfa2V5KSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH0gZWxzZSBpZiAoIWl0ZW1BLmhhcyhzb3J0X2tleSkpIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9IGVsc2UgaWYgKCFpdGVtQi5oYXMoc29ydF9rZXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGl0ZW1BLmdldChzb3J0X2tleSkudG9Mb3dlckNhc2UoKSA+IGl0ZW1CLmdldChzb3J0X2tleSkudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHNvcnRfb3JkZXIgPT09IFwiYXNjXCIgPyAxIDogLTE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGl0ZW1CLmdldChzb3J0X2tleSkudG9Mb3dlckNhc2UoKSA+IGl0ZW1BLmdldChzb3J0X2tleSkudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHNvcnRfb3JkZXIgPT09IFwiYXNjXCIgPyAtMSA6IDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7IC8vIGVxdWFsXG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGl0ZW1BLmdldChcInR5cGVcIikgPT09IFwiZm9sZGVyXCIpIHtcbiAgICAgICAgICAgIHJldHVybiAtMTsgLy8gZm9sZGVyIGlzIGFsd2F5cyBiZWZvcmUgZGF0YXNldFxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cbn07XG4vKipcbiAqIENyZWF0ZSBhbHBoYWJldGljYWwgYmFzZWQgdHdvLWFyZ3VtZW50IGNvbXBhcmF0b3JcbiAqIEBwYXJhbSAge3N0cn0gc29ydF9rZXkgICBrZXkgdG8gc29ydCBieVxuICogQHBhcmFtICB7c3RyfSBzb3J0X29yZGVyIG9yZGVyIHRvIHNvcnQgYnkgKGFzYywgZGVzYylcbiAqIEByZXR1cm4ge2Z1bmN0aW9ufSB0d28tYXJndW1lbnQgY29tcGFyYXRvciBmdW5jdGlvblxuICovXG52YXIgZ2VuZXJhdGVMaWJyYXJ5Q29tcGFyYXRvciA9IChzb3J0X2tleSwgc29ydF9vcmRlcikgPT4gKGxpYnJhcnlBLCBsaWJyYXJ5QikgPT4ge1xuICAgIGlmIChsaWJyYXJ5QS5nZXQoc29ydF9rZXkpLnRvTG93ZXJDYXNlKCkgPiBsaWJyYXJ5Qi5nZXQoc29ydF9rZXkpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgcmV0dXJuIHNvcnRfb3JkZXIgPT09IFwiYXNjXCIgPyAxIDogLTE7XG4gICAgfVxuICAgIGlmIChsaWJyYXJ5Qi5nZXQoc29ydF9rZXkpLnRvTG93ZXJDYXNlKCkgPiBsaWJyYXJ5QS5nZXQoc29ydF9rZXkpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgcmV0dXJuIHNvcnRfb3JkZXIgPT09IFwiYXNjXCIgPyAtMSA6IDE7XG4gICAgfVxuICAgIHJldHVybiAwOyAvLyBlcXVhbFxufTtcbmV4cG9ydCBkZWZhdWx0IHtcbiAgICBnZW5lcmF0ZUZvbGRlckNvbXBhcmF0b3I6IGdlbmVyYXRlRm9sZGVyQ29tcGFyYXRvcixcbiAgICBnZW5lcmF0ZUxpYnJhcnlDb21wYXJhdG9yOiBnZW5lcmF0ZUxpYnJhcnlDb21wYXJhdG9yXG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGdhbGF4eS9zY3JpcHRzL212Yy9saWJyYXJ5L2xpYnJhcnktdXRpbC5qcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTs7Ozs7Ozs7QUFRQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUF0QkE7QUF1QkE7Ozs7OztBQU1BO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUkE7QUFTQTtBQUNBO0FBQ0E7QUFGQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///297\n");

/***/ }),

/***/ 298:
/*!***************************************************************!*\
  !*** ./galaxy/scripts/mvc/library/library-folderlist-view.js ***!
  \***************************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(Backbone, _, $) {\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _toastr = __webpack_require__(/*! libs/toastr */ 7);\n\nvar _toastr2 = _interopRequireDefault(_toastr);\n\nvar _libraryModel = __webpack_require__(/*! mvc/library/library-model */ 13);\n\nvar _libraryModel2 = _interopRequireDefault(_libraryModel);\n\nvar _libraryFolderrowView = __webpack_require__(/*! mvc/library/library-folderrow-view */ 299);\n\nvar _libraryFolderrowView2 = _interopRequireDefault(_libraryFolderrowView);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar FolderListView = Backbone.View.extend({\n    el: \"#folder_items_element\",\n    // progress percentage\n    progress: 0,\n    // progress rate per one item\n    progressStep: 1,\n\n    folderContainer: null,\n\n    current_sort_order: \"asc\",\n\n    current_sort_key: \"name\",\n\n    events: {\n        \"click #select-all-checkboxes\": \"selectAll\",\n        \"click .dataset_row\": \"selectClickedRow\",\n        \"click .folder_row\": \"selectClickedRow\",\n        \"click .sort-folder-name\": \"sortColumnClicked\",\n        \"click .sort-folder-file_ext\": \"sortColumnClicked\",\n        \"click .sort-folder-description\": \"sortColumnClicked\",\n        \"click .sort-folder-state\": \"sortColumnClicked\"\n    },\n\n    collection: null,\n\n    defaults: {\n        include_deleted: false,\n        page_count: null,\n        show_page: null\n    },\n\n    /**\n     * Initialize and fetch the folder from the server.\n     * @param  {object} options an object with options\n     */\n    initialize: function initialize(options) {\n        this.options = _.defaults(this.options || {}, this.defaults, options);\n        this.modal = null;\n        // map of folder item ids to item views = cache\n        this.rowViews = {};\n\n        // create a collection of folder items for this view\n        this.collection = new _libraryModel2.default.Folder();\n\n        // start to listen if someone modifies the collection\n        this.listenTo(this.collection, \"add\", this.renderOne);\n        this.listenTo(this.collection, \"remove\", this.removeOne);\n        this.listenTo(this.collection, \"sort\", this.rePaint);\n        this.listenTo(this.collection, \"reset\", this.rePaint);\n\n        this.fetchFolder();\n    },\n\n    fetchFolder: function fetchFolder(options) {\n        var options = options || {};\n        this.options.include_deleted = options.include_deleted;\n        var self = this;\n\n        this.folderContainer = new _libraryModel2.default.FolderContainer({\n            id: this.options.id\n        });\n        this.folderContainer.url = this.folderContainer.attributes.urlRoot + this.options.id + \"/contents\";\n\n        if (this.options.include_deleted) {\n            this.folderContainer.url = this.folderContainer.url + \"?include_deleted=true\";\n        }\n        this.folderContainer.fetch({\n            success: function success(folder_container) {\n                self.folder_container = folder_container;\n                self.render();\n            },\n            error: function error(model, response) {\n                if (typeof response.responseJSON !== \"undefined\") {\n                    _toastr2.default.error(response.responseJSON.err_msg + \" Click this to go back.\", \"\", {\n                        onclick: function onclick() {\n                            Galaxy.libraries.library_router.back();\n                        }\n                    });\n                } else {\n                    _toastr2.default.error(\"An error occurred. Click this to go back.\", \"\", {\n                        onclick: function onclick() {\n                            Galaxy.libraries.library_router.back();\n                        }\n                    });\n                }\n            }\n        });\n    },\n\n    render: function render(options) {\n        this.options = _.extend(this.options, options);\n        var template = this.templateFolder();\n        $(\".tooltip\").hide();\n\n        // find the upper id in the full path\n        var path = this.folderContainer.attributes.metadata.full_path;\n        var upper_folder_id;\n        if (path.length === 1) {\n            // the library is above us\n            upper_folder_id = 0;\n        } else {\n            upper_folder_id = path[path.length - 2][0];\n        }\n\n        this.$el.html(template({\n            path: this.folderContainer.attributes.metadata.full_path,\n            parent_library_id: this.folderContainer.attributes.metadata.parent_library_id,\n            id: this.options.id,\n            upper_folder_id: upper_folder_id,\n            order: this.current_sort_order\n        }));\n\n        // when dataset_id is present render its details too\n        if (this.options.dataset_id) {\n            var row = _.findWhere(self.rowViews, {\n                id: this.options.dataset_id\n            });\n            if (row) {\n                row.showDatasetDetails();\n            } else {\n                _toastr2.default.error(\"Requested dataset not found. Showing folder instead.\");\n            }\n        } else {\n            if (this.options.show_page === null || this.options.show_page < 1) {\n                this.options.show_page = 1;\n            }\n            this.paginate();\n        }\n        $(\"#center [data-toggle]\").tooltip();\n        $(\"#center\").css(\"overflow\", \"auto\");\n    },\n\n    paginate: function paginate(options) {\n        this.options = _.extend(this.options, options);\n\n        if (this.options.show_page === null || this.options.show_page < 1) {\n            this.options.show_page = 1;\n        }\n        this.options.total_items_count = this.folder_container.get(\"folder\").models.length;\n        this.options.page_count = Math.ceil(this.options.total_items_count / Galaxy.libraries.preferences.get(\"folder_page_size\"));\n        var page_start = Galaxy.libraries.preferences.get(\"folder_page_size\") * (this.options.show_page - 1);\n        var items_to_render = null;\n        items_to_render = this.folder_container.get(\"folder\").models.slice(page_start, page_start + Galaxy.libraries.preferences.get(\"folder_page_size\"));\n        this.options.items_shown = items_to_render.length;\n        // User requests page with no items\n        if (Galaxy.libraries.preferences.get(\"folder_page_size\") * this.options.show_page > this.options.total_items_count + Galaxy.libraries.preferences.get(\"folder_page_size\")) {\n            items_to_render = [];\n        }\n        Galaxy.libraries.folderToolbarView.renderPaginator(this.options);\n        this.collection.reset(items_to_render);\n    },\n\n    rePaint: function rePaint(options) {\n        this.options = _.extend(this.options, options);\n        this.removeAllRows();\n        this.renderAll();\n        this.checkEmptiness();\n    },\n\n    /**\n     * Adds all given models to the collection.\n     * @param {array of Item or FolderAsModel} array of models that should\n     *  be added to the view's collection.\n     */\n    addAll: function addAll(models) {\n        _.each(models, function (model) {\n            Galaxy.libraries.folderListView.collection.add(model, {\n                current_sort_order: false\n            });\n        });\n        $(\"#center [data-toggle]\").tooltip();\n        this.checkEmptiness();\n        this.postRender();\n    },\n\n    /**\n     * Call this after all models are added to the collection\n     * to ensure that the folder toolbar will show proper options\n     * and that event will be bound on all subviews.\n     */\n    postRender: function postRender() {\n        var fetched_metadata = this.folderContainer.attributes.metadata;\n        fetched_metadata.contains_file_or_folder = typeof this.collection.findWhere({ type: \"file\" }) !== \"undefined\" || typeof this.collection.findWhere({ type: \"folder\" }) !== \"undefined\";\n        Galaxy.libraries.folderToolbarView.configureElements(fetched_metadata);\n    },\n\n    /**\n     * Iterates this view's collection and calls the render\n     * function for each. Also binds the hover behavior.\n     */\n    renderAll: function renderAll() {\n        var self = this;\n        _.each(this.collection.models.reverse(), function (model) {\n            self.renderOne(model);\n        });\n        this.postRender();\n    },\n\n    /**\n     * Creates a view for the given model and adds it to the folder view.\n     * @param {Item or FolderAsModel} model of the view that will be rendered\n     */\n    renderOne: function renderOne(model) {\n        this.options.contains_file_or_folder = true;\n        //if (model.get('type') !== 'folder'){\n        // model.set('readable_size', this.size_to_string(model.get('file_size')));\n        //}\n        model.set(\"folder_id\", this.id);\n        var rowView = new _libraryFolderrowView2.default.FolderRowView({\n            model: model\n        });\n\n        // save new rowView to cache\n        this.rowViews[model.get(\"id\")] = rowView;\n\n        this.$el.find(\"#first_folder_item\").after(rowView.el);\n    },\n\n    /**\n     * Remove the view of the given model from the DOM.\n     * @param {Item or FolderAsModel} model of the view that will be removed\n     */\n    removeOne: function removeOne(model) {\n        this.$el.find(\"tr\").filter(function () {\n            return $(this).data(\"id\") && $(this).data(\"id\") === model.id;\n        }).remove();\n    },\n\n    /**\n     * Remove all dataset and folder row elements from the DOM.\n     */\n    removeAllRows: function removeAllRows() {\n        $(\".library-row\").remove();\n    },\n\n    /** Checks whether the list is empty and adds/removes the message */\n    checkEmptiness: function checkEmptiness() {\n        if (this.$el.find(\".dataset_row\").length === 0 && this.$el.find(\".folder_row\").length === 0) {\n            this.$el.find(\".empty-folder-message\").show();\n        } else {\n            this.$el.find(\".empty-folder-message\").hide();\n        }\n    },\n\n    sortColumnClicked: function sortColumnClicked(event) {\n        event.preventDefault();\n        this.current_sort_order = this.current_sort_order === \"asc\" ? \"desc\" : \"asc\";\n        this.current_sort_key = event.currentTarget.className.replace(\"sort-folder-\", \"\");\n        this.collection.sortFolder(this.current_sort_key, this.current_sort_order);\n        this.renderSortIcon();\n    },\n\n    /**\n     * User clicked the checkbox in the table heading\n     * @param  {context} event\n     */\n    selectAll: function selectAll(event) {\n        var selected = event.target.checked;\n        var self = this;\n        // Iterate each checkbox\n        $(\":checkbox\", \"#folder_list_body\").each(function () {\n            this.checked = selected;\n            var $row = $(this).closest(\"tr\");\n            // Change color of selected/unselected\n            if (selected) {\n                self.makeDarkRow($row);\n            } else {\n                self.makeWhiteRow($row);\n            }\n        });\n    },\n\n    /**\n     * Check checkbox if user clicks on the whole row or\n     *  on the checkbox itself\n     */\n    selectClickedRow: function selectClickedRow(event) {\n        var checkbox = \"\";\n        var $row;\n        var source;\n        $row = $(event.target).closest(\"tr\");\n        if (event.target.localName === \"input\") {\n            checkbox = event.target;\n            source = \"input\";\n        } else if (event.target.localName === \"td\") {\n            checkbox = $row.find(\":checkbox\")[0];\n            source = \"td\";\n        }\n        if (checkbox.checked) {\n            if (source === \"td\") {\n                checkbox.checked = \"\";\n                this.makeWhiteRow($row);\n            } else if (source === \"input\") {\n                this.makeDarkRow($row);\n            }\n        } else {\n            if (source === \"td\") {\n                checkbox.checked = \"selected\";\n                this.makeDarkRow($row);\n            } else if (source === \"input\") {\n                this.makeWhiteRow($row);\n            }\n        }\n    },\n\n    makeDarkRow: function makeDarkRow($row) {\n        $row.removeClass(\"light\").addClass(\"dark\");\n        $row.find(\"a\").removeClass(\"light\").addClass(\"dark\");\n        $row.find(\".fa-file-o\").removeClass(\"fa-file-o\").addClass(\"fa-file\");\n        $row.find(\".fa-folder-o\").removeClass(\"fa-folder-o\").addClass(\"fa-folder\");\n    },\n\n    makeWhiteRow: function makeWhiteRow($row) {\n        $row.removeClass(\"dark\").addClass(\"light\");\n        $row.find(\"a\").removeClass(\"dark\").addClass(\"light\");\n        $row.find(\".fa-file\").removeClass(\"fa-file\").addClass(\"fa-file-o\");\n        $row.find(\".fa-folder\").removeClass(\"fa-folder\").addClass(\"fa-folder-o\");\n    },\n\n    renderSortIcon: function renderSortIcon() {\n        if (this.current_sort_order === \"asc\") {\n            $('[class*=\"sort-icon\"]').removeClass(\"fa-sort-alpha-desc\").removeClass(\"fa-sort-alpha-asc\");\n            $(\".sort-icon-\" + this.current_sort_key).addClass(\"fa-sort-alpha-asc\");\n        } else {\n            $(\".sort-icon-\" + this.current_sort_key).addClass(\"fa-sort-alpha-desc\");\n        }\n    },\n\n    templateFolder: function templateFolder() {\n        return _.template([\n        // BREADCRUMBS\n        '<ol class=\"breadcrumb\">', '<li><a title=\"Return to the list of libraries\" href=\"#\">Libraries</a></li>', \"<% _.each(path, function(path_item) { %>\", \"<% if (path_item[0] != id) { %>\", '<li><a title=\"Return to this folder\" href=\"#/folders/<%- path_item[0] %>\"><%- path_item[1] %></a> </li> ', \"<% } else { %>\", '<li class=\"active\"><span title=\"You are in this folder\"><%- path_item[1] %></span></li>', \"<% } %>\", \"<% }); %>\", \"</ol>\",\n\n        // FOLDER CONTENT\n        '<table data-library-id=\"<%- parent_library_id  %>\" class=\"grid table table-condensed\">', \"<thead>\", '<th class=\"button_heading\"></th>', '<th style=\"text-align: center; width: 20px; \" title=\"Check to select all datasets\"><input id=\"select-all-checkboxes\" style=\"margin: 0;\" type=\"checkbox\"></th>', '<th><a class=\"sort-folder-name\" title=\"Click to reverse order\" href=\"#\">name</a> <span title=\"Sorted alphabetically\" class=\"sort-icon-name fa fa-sort-alpha-<%- order %>\"></span></th>', '<th style=\"width:20%;\"><a class=\"sort-folder-description\" title=\"Click to reverse order\" href=\"#\">description</a> <span title=\"Sorted alphabetically\" class=\"sort-icon-description fa\"></span></th>', '<th style=\"width:5%;\"><a class=\"sort-folder-file_ext\" title=\"Click to reverse order\" href=\"#\">data type</a> <span title=\"Sorted alphabetically\" class=\"sort-icon-file_ext fa\"></span></th>', '<th style=\"width:10%;\">size</th>', '<th style=\"width:160px;\">time updated (UTC)</th>', '<th style=\"width:5%;\"><a class=\"sort-folder-state\" title=\"Click to reverse order\" href=\"#\">state</a> <span title=\"Sorted alphabetically\" class=\"sort-icon-state fa\"></span></th>', '<th style=\"width:150px;\"></th> ', \"</thead>\", '<tbody id=\"folder_list_body\">', '<tr id=\"first_folder_item\">', \"<td>\", '<a href=\"#<% if (upper_folder_id !== 0){ print(\"folders/\" + upper_folder_id)} %>\" title=\"Go to parent folder\" class=\"btn_open_folder btn btn-default btn-xs\">..<a>', \"</td>\", \"<td></td>\", \"<td></td>\", \"<td></td>\", \"<td></td>\", \"<td></td>\", \"<td></td>\", \"<td></td>\", \"<td></td>\", \"</tr>\", \"</tbody>\", \"</table>\", '<div class=\"empty-folder-message\" style=\"display:none;\">', \"This folder is either empty or you do not have proper access permissions to see the contents. If you expected something to show up\", ' please consult the <a href=\"https://galaxyproject.org/data-libraries/#permissions\" target=\"_blank\">library security wikipage</a>', ' or visit the <a href=\"https://biostar.usegalaxy.org/\" target=\"_blank\">Galaxy support site</a>.', \"</div>\"].join(\"\"));\n    }\n});\n\nexports.default = {\n    FolderListView: FolderListView\n};\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! libs/backbone */ 2), __webpack_require__(/*! underscore */ 1), __webpack_require__(/*! jquery */ 0)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjk4LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL2dhbGF4eS9zY3JpcHRzL212Yy9saWJyYXJ5L2xpYnJhcnktZm9sZGVybGlzdC12aWV3LmpzPzNlNTQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IG1vZF90b2FzdHIgZnJvbSBcImxpYnMvdG9hc3RyXCI7XG5pbXBvcnQgbW9kX2xpYnJhcnlfbW9kZWwgZnJvbSBcIm12Yy9saWJyYXJ5L2xpYnJhcnktbW9kZWxcIjtcbmltcG9ydCBtb2RfbGlicmFyeV9mb2xkZXJyb3dfdmlldyBmcm9tIFwibXZjL2xpYnJhcnkvbGlicmFyeS1mb2xkZXJyb3ctdmlld1wiO1xuXG52YXIgRm9sZGVyTGlzdFZpZXcgPSBCYWNrYm9uZS5WaWV3LmV4dGVuZCh7XG4gICAgZWw6IFwiI2ZvbGRlcl9pdGVtc19lbGVtZW50XCIsXG4gICAgLy8gcHJvZ3Jlc3MgcGVyY2VudGFnZVxuICAgIHByb2dyZXNzOiAwLFxuICAgIC8vIHByb2dyZXNzIHJhdGUgcGVyIG9uZSBpdGVtXG4gICAgcHJvZ3Jlc3NTdGVwOiAxLFxuXG4gICAgZm9sZGVyQ29udGFpbmVyOiBudWxsLFxuXG4gICAgY3VycmVudF9zb3J0X29yZGVyOiBcImFzY1wiLFxuXG4gICAgY3VycmVudF9zb3J0X2tleTogXCJuYW1lXCIsXG5cbiAgICBldmVudHM6IHtcbiAgICAgICAgXCJjbGljayAjc2VsZWN0LWFsbC1jaGVja2JveGVzXCI6IFwic2VsZWN0QWxsXCIsXG4gICAgICAgIFwiY2xpY2sgLmRhdGFzZXRfcm93XCI6IFwic2VsZWN0Q2xpY2tlZFJvd1wiLFxuICAgICAgICBcImNsaWNrIC5mb2xkZXJfcm93XCI6IFwic2VsZWN0Q2xpY2tlZFJvd1wiLFxuICAgICAgICBcImNsaWNrIC5zb3J0LWZvbGRlci1uYW1lXCI6IFwic29ydENvbHVtbkNsaWNrZWRcIixcbiAgICAgICAgXCJjbGljayAuc29ydC1mb2xkZXItZmlsZV9leHRcIjogXCJzb3J0Q29sdW1uQ2xpY2tlZFwiLFxuICAgICAgICBcImNsaWNrIC5zb3J0LWZvbGRlci1kZXNjcmlwdGlvblwiOiBcInNvcnRDb2x1bW5DbGlja2VkXCIsXG4gICAgICAgIFwiY2xpY2sgLnNvcnQtZm9sZGVyLXN0YXRlXCI6IFwic29ydENvbHVtbkNsaWNrZWRcIlxuICAgIH0sXG5cbiAgICBjb2xsZWN0aW9uOiBudWxsLFxuXG4gICAgZGVmYXVsdHM6IHtcbiAgICAgICAgaW5jbHVkZV9kZWxldGVkOiBmYWxzZSxcbiAgICAgICAgcGFnZV9jb3VudDogbnVsbCxcbiAgICAgICAgc2hvd19wYWdlOiBudWxsXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgYW5kIGZldGNoIHRoZSBmb2xkZXIgZnJvbSB0aGUgc2VydmVyLlxuICAgICAqIEBwYXJhbSAge29iamVjdH0gb3B0aW9ucyBhbiBvYmplY3Qgd2l0aCBvcHRpb25zXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBfLmRlZmF1bHRzKHRoaXMub3B0aW9ucyB8fCB7fSwgdGhpcy5kZWZhdWx0cywgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMubW9kYWwgPSBudWxsO1xuICAgICAgICAvLyBtYXAgb2YgZm9sZGVyIGl0ZW0gaWRzIHRvIGl0ZW0gdmlld3MgPSBjYWNoZVxuICAgICAgICB0aGlzLnJvd1ZpZXdzID0ge307XG5cbiAgICAgICAgLy8gY3JlYXRlIGEgY29sbGVjdGlvbiBvZiBmb2xkZXIgaXRlbXMgZm9yIHRoaXMgdmlld1xuICAgICAgICB0aGlzLmNvbGxlY3Rpb24gPSBuZXcgbW9kX2xpYnJhcnlfbW9kZWwuRm9sZGVyKCk7XG5cbiAgICAgICAgLy8gc3RhcnQgdG8gbGlzdGVuIGlmIHNvbWVvbmUgbW9kaWZpZXMgdGhlIGNvbGxlY3Rpb25cbiAgICAgICAgdGhpcy5saXN0ZW5Ubyh0aGlzLmNvbGxlY3Rpb24sIFwiYWRkXCIsIHRoaXMucmVuZGVyT25lKTtcbiAgICAgICAgdGhpcy5saXN0ZW5Ubyh0aGlzLmNvbGxlY3Rpb24sIFwicmVtb3ZlXCIsIHRoaXMucmVtb3ZlT25lKTtcbiAgICAgICAgdGhpcy5saXN0ZW5Ubyh0aGlzLmNvbGxlY3Rpb24sIFwic29ydFwiLCB0aGlzLnJlUGFpbnQpO1xuICAgICAgICB0aGlzLmxpc3RlblRvKHRoaXMuY29sbGVjdGlvbiwgXCJyZXNldFwiLCB0aGlzLnJlUGFpbnQpO1xuXG4gICAgICAgIHRoaXMuZmV0Y2hGb2xkZXIoKTtcbiAgICB9LFxuXG4gICAgZmV0Y2hGb2xkZXI6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICB0aGlzLm9wdGlvbnMuaW5jbHVkZV9kZWxldGVkID0gb3B0aW9ucy5pbmNsdWRlX2RlbGV0ZWQ7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICB0aGlzLmZvbGRlckNvbnRhaW5lciA9IG5ldyBtb2RfbGlicmFyeV9tb2RlbC5Gb2xkZXJDb250YWluZXIoe1xuICAgICAgICAgICAgaWQ6IHRoaXMub3B0aW9ucy5pZFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5mb2xkZXJDb250YWluZXIudXJsID0gYCR7dGhpcy5mb2xkZXJDb250YWluZXIuYXR0cmlidXRlcy51cmxSb290ICsgdGhpcy5vcHRpb25zLmlkfS9jb250ZW50c2A7XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5pbmNsdWRlX2RlbGV0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZm9sZGVyQ29udGFpbmVyLnVybCA9IGAke3RoaXMuZm9sZGVyQ29udGFpbmVyLnVybH0/aW5jbHVkZV9kZWxldGVkPXRydWVgO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZm9sZGVyQ29udGFpbmVyLmZldGNoKHtcbiAgICAgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uKGZvbGRlcl9jb250YWluZXIpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmZvbGRlcl9jb250YWluZXIgPSBmb2xkZXJfY29udGFpbmVyO1xuICAgICAgICAgICAgICAgIHNlbGYucmVuZGVyKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZXJyb3I6IGZ1bmN0aW9uKG1vZGVsLCByZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcmVzcG9uc2UucmVzcG9uc2VKU09OICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIG1vZF90b2FzdHIuZXJyb3IoYCR7cmVzcG9uc2UucmVzcG9uc2VKU09OLmVycl9tc2d9IENsaWNrIHRoaXMgdG8gZ28gYmFjay5gLCBcIlwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbmNsaWNrOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBHYWxheHkubGlicmFyaWVzLmxpYnJhcnlfcm91dGVyLmJhY2soKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbW9kX3RvYXN0ci5lcnJvcihcIkFuIGVycm9yIG9jY3VycmVkLiBDbGljayB0aGlzIHRvIGdvIGJhY2suXCIsIFwiXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uY2xpY2s6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEdhbGF4eS5saWJyYXJpZXMubGlicmFyeV9yb3V0ZXIuYmFjaygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICByZW5kZXI6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gXy5leHRlbmQodGhpcy5vcHRpb25zLCBvcHRpb25zKTtcbiAgICAgICAgdmFyIHRlbXBsYXRlID0gdGhpcy50ZW1wbGF0ZUZvbGRlcigpO1xuICAgICAgICAkKFwiLnRvb2x0aXBcIikuaGlkZSgpO1xuXG4gICAgICAgIC8vIGZpbmQgdGhlIHVwcGVyIGlkIGluIHRoZSBmdWxsIHBhdGhcbiAgICAgICAgdmFyIHBhdGggPSB0aGlzLmZvbGRlckNvbnRhaW5lci5hdHRyaWJ1dGVzLm1ldGFkYXRhLmZ1bGxfcGF0aDtcbiAgICAgICAgdmFyIHVwcGVyX2ZvbGRlcl9pZDtcbiAgICAgICAgaWYgKHBhdGgubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAvLyB0aGUgbGlicmFyeSBpcyBhYm92ZSB1c1xuICAgICAgICAgICAgdXBwZXJfZm9sZGVyX2lkID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHVwcGVyX2ZvbGRlcl9pZCA9IHBhdGhbcGF0aC5sZW5ndGggLSAyXVswXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuJGVsLmh0bWwoXG4gICAgICAgICAgICB0ZW1wbGF0ZSh7XG4gICAgICAgICAgICAgICAgcGF0aDogdGhpcy5mb2xkZXJDb250YWluZXIuYXR0cmlidXRlcy5tZXRhZGF0YS5mdWxsX3BhdGgsXG4gICAgICAgICAgICAgICAgcGFyZW50X2xpYnJhcnlfaWQ6IHRoaXMuZm9sZGVyQ29udGFpbmVyLmF0dHJpYnV0ZXMubWV0YWRhdGEucGFyZW50X2xpYnJhcnlfaWQsXG4gICAgICAgICAgICAgICAgaWQ6IHRoaXMub3B0aW9ucy5pZCxcbiAgICAgICAgICAgICAgICB1cHBlcl9mb2xkZXJfaWQ6IHVwcGVyX2ZvbGRlcl9pZCxcbiAgICAgICAgICAgICAgICBvcmRlcjogdGhpcy5jdXJyZW50X3NvcnRfb3JkZXJcbiAgICAgICAgICAgIH0pXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gd2hlbiBkYXRhc2V0X2lkIGlzIHByZXNlbnQgcmVuZGVyIGl0cyBkZXRhaWxzIHRvb1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmRhdGFzZXRfaWQpIHtcbiAgICAgICAgICAgIHZhciByb3cgPSBfLmZpbmRXaGVyZShzZWxmLnJvd1ZpZXdzLCB7XG4gICAgICAgICAgICAgICAgaWQ6IHRoaXMub3B0aW9ucy5kYXRhc2V0X2lkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChyb3cpIHtcbiAgICAgICAgICAgICAgICByb3cuc2hvd0RhdGFzZXREZXRhaWxzKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG1vZF90b2FzdHIuZXJyb3IoXCJSZXF1ZXN0ZWQgZGF0YXNldCBub3QgZm91bmQuIFNob3dpbmcgZm9sZGVyIGluc3RlYWQuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zaG93X3BhZ2UgPT09IG51bGwgfHwgdGhpcy5vcHRpb25zLnNob3dfcGFnZSA8IDEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuc2hvd19wYWdlID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucGFnaW5hdGUoKTtcbiAgICAgICAgfVxuICAgICAgICAkKFwiI2NlbnRlciBbZGF0YS10b2dnbGVdXCIpLnRvb2x0aXAoKTtcbiAgICAgICAgJChcIiNjZW50ZXJcIikuY3NzKFwib3ZlcmZsb3dcIiwgXCJhdXRvXCIpO1xuICAgIH0sXG5cbiAgICBwYWdpbmF0ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBfLmV4dGVuZCh0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2hvd19wYWdlID09PSBudWxsIHx8IHRoaXMub3B0aW9ucy5zaG93X3BhZ2UgPCAxKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuc2hvd19wYWdlID0gMTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9wdGlvbnMudG90YWxfaXRlbXNfY291bnQgPSB0aGlzLmZvbGRlcl9jb250YWluZXIuZ2V0KFwiZm9sZGVyXCIpLm1vZGVscy5sZW5ndGg7XG4gICAgICAgIHRoaXMub3B0aW9ucy5wYWdlX2NvdW50ID0gTWF0aC5jZWlsKFxuICAgICAgICAgICAgdGhpcy5vcHRpb25zLnRvdGFsX2l0ZW1zX2NvdW50IC8gR2FsYXh5LmxpYnJhcmllcy5wcmVmZXJlbmNlcy5nZXQoXCJmb2xkZXJfcGFnZV9zaXplXCIpXG4gICAgICAgICk7XG4gICAgICAgIHZhciBwYWdlX3N0YXJ0ID0gR2FsYXh5LmxpYnJhcmllcy5wcmVmZXJlbmNlcy5nZXQoXCJmb2xkZXJfcGFnZV9zaXplXCIpICogKHRoaXMub3B0aW9ucy5zaG93X3BhZ2UgLSAxKTtcbiAgICAgICAgdmFyIGl0ZW1zX3RvX3JlbmRlciA9IG51bGw7XG4gICAgICAgIGl0ZW1zX3RvX3JlbmRlciA9IHRoaXMuZm9sZGVyX2NvbnRhaW5lclxuICAgICAgICAgICAgLmdldChcImZvbGRlclwiKVxuICAgICAgICAgICAgLm1vZGVscy5zbGljZShwYWdlX3N0YXJ0LCBwYWdlX3N0YXJ0ICsgR2FsYXh5LmxpYnJhcmllcy5wcmVmZXJlbmNlcy5nZXQoXCJmb2xkZXJfcGFnZV9zaXplXCIpKTtcbiAgICAgICAgdGhpcy5vcHRpb25zLml0ZW1zX3Nob3duID0gaXRlbXNfdG9fcmVuZGVyLmxlbmd0aDtcbiAgICAgICAgLy8gVXNlciByZXF1ZXN0cyBwYWdlIHdpdGggbm8gaXRlbXNcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgR2FsYXh5LmxpYnJhcmllcy5wcmVmZXJlbmNlcy5nZXQoXCJmb2xkZXJfcGFnZV9zaXplXCIpICogdGhpcy5vcHRpb25zLnNob3dfcGFnZSA+XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMudG90YWxfaXRlbXNfY291bnQgKyBHYWxheHkubGlicmFyaWVzLnByZWZlcmVuY2VzLmdldChcImZvbGRlcl9wYWdlX3NpemVcIilcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBpdGVtc190b19yZW5kZXIgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBHYWxheHkubGlicmFyaWVzLmZvbGRlclRvb2xiYXJWaWV3LnJlbmRlclBhZ2luYXRvcih0aGlzLm9wdGlvbnMpO1xuICAgICAgICB0aGlzLmNvbGxlY3Rpb24ucmVzZXQoaXRlbXNfdG9fcmVuZGVyKTtcbiAgICB9LFxuXG4gICAgcmVQYWludDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBfLmV4dGVuZCh0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLnJlbW92ZUFsbFJvd3MoKTtcbiAgICAgICAgdGhpcy5yZW5kZXJBbGwoKTtcbiAgICAgICAgdGhpcy5jaGVja0VtcHRpbmVzcygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGFsbCBnaXZlbiBtb2RlbHMgdG8gdGhlIGNvbGxlY3Rpb24uXG4gICAgICogQHBhcmFtIHthcnJheSBvZiBJdGVtIG9yIEZvbGRlckFzTW9kZWx9IGFycmF5IG9mIG1vZGVscyB0aGF0IHNob3VsZFxuICAgICAqICBiZSBhZGRlZCB0byB0aGUgdmlldydzIGNvbGxlY3Rpb24uXG4gICAgICovXG4gICAgYWRkQWxsOiBmdW5jdGlvbihtb2RlbHMpIHtcbiAgICAgICAgXy5lYWNoKG1vZGVscywgbW9kZWwgPT4ge1xuICAgICAgICAgICAgR2FsYXh5LmxpYnJhcmllcy5mb2xkZXJMaXN0Vmlldy5jb2xsZWN0aW9uLmFkZChtb2RlbCwge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRfc29ydF9vcmRlcjogZmFsc2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgJChcIiNjZW50ZXIgW2RhdGEtdG9nZ2xlXVwiKS50b29sdGlwKCk7XG4gICAgICAgIHRoaXMuY2hlY2tFbXB0aW5lc3MoKTtcbiAgICAgICAgdGhpcy5wb3N0UmVuZGVyKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbGwgdGhpcyBhZnRlciBhbGwgbW9kZWxzIGFyZSBhZGRlZCB0byB0aGUgY29sbGVjdGlvblxuICAgICAqIHRvIGVuc3VyZSB0aGF0IHRoZSBmb2xkZXIgdG9vbGJhciB3aWxsIHNob3cgcHJvcGVyIG9wdGlvbnNcbiAgICAgKiBhbmQgdGhhdCBldmVudCB3aWxsIGJlIGJvdW5kIG9uIGFsbCBzdWJ2aWV3cy5cbiAgICAgKi9cbiAgICBwb3N0UmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGZldGNoZWRfbWV0YWRhdGEgPSB0aGlzLmZvbGRlckNvbnRhaW5lci5hdHRyaWJ1dGVzLm1ldGFkYXRhO1xuICAgICAgICBmZXRjaGVkX21ldGFkYXRhLmNvbnRhaW5zX2ZpbGVfb3JfZm9sZGVyID1cbiAgICAgICAgICAgIHR5cGVvZiB0aGlzLmNvbGxlY3Rpb24uZmluZFdoZXJlKHsgdHlwZTogXCJmaWxlXCIgfSkgIT09IFwidW5kZWZpbmVkXCIgfHxcbiAgICAgICAgICAgIHR5cGVvZiB0aGlzLmNvbGxlY3Rpb24uZmluZFdoZXJlKHsgdHlwZTogXCJmb2xkZXJcIiB9KSAhPT0gXCJ1bmRlZmluZWRcIjtcbiAgICAgICAgR2FsYXh5LmxpYnJhcmllcy5mb2xkZXJUb29sYmFyVmlldy5jb25maWd1cmVFbGVtZW50cyhmZXRjaGVkX21ldGFkYXRhKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSXRlcmF0ZXMgdGhpcyB2aWV3J3MgY29sbGVjdGlvbiBhbmQgY2FsbHMgdGhlIHJlbmRlclxuICAgICAqIGZ1bmN0aW9uIGZvciBlYWNoLiBBbHNvIGJpbmRzIHRoZSBob3ZlciBiZWhhdmlvci5cbiAgICAgKi9cbiAgICByZW5kZXJBbGw6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIF8uZWFjaCh0aGlzLmNvbGxlY3Rpb24ubW9kZWxzLnJldmVyc2UoKSwgbW9kZWwgPT4ge1xuICAgICAgICAgICAgc2VsZi5yZW5kZXJPbmUobW9kZWwpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5wb3N0UmVuZGVyKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSB2aWV3IGZvciB0aGUgZ2l2ZW4gbW9kZWwgYW5kIGFkZHMgaXQgdG8gdGhlIGZvbGRlciB2aWV3LlxuICAgICAqIEBwYXJhbSB7SXRlbSBvciBGb2xkZXJBc01vZGVsfSBtb2RlbCBvZiB0aGUgdmlldyB0aGF0IHdpbGwgYmUgcmVuZGVyZWRcbiAgICAgKi9cbiAgICByZW5kZXJPbmU6IGZ1bmN0aW9uKG1vZGVsKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5jb250YWluc19maWxlX29yX2ZvbGRlciA9IHRydWU7XG4gICAgICAgIC8vaWYgKG1vZGVsLmdldCgndHlwZScpICE9PSAnZm9sZGVyJyl7XG4gICAgICAgIC8vIG1vZGVsLnNldCgncmVhZGFibGVfc2l6ZScsIHRoaXMuc2l6ZV90b19zdHJpbmcobW9kZWwuZ2V0KCdmaWxlX3NpemUnKSkpO1xuICAgICAgICAvL31cbiAgICAgICAgbW9kZWwuc2V0KFwiZm9sZGVyX2lkXCIsIHRoaXMuaWQpO1xuICAgICAgICB2YXIgcm93VmlldyA9IG5ldyBtb2RfbGlicmFyeV9mb2xkZXJyb3dfdmlldy5Gb2xkZXJSb3dWaWV3KHtcbiAgICAgICAgICAgIG1vZGVsOiBtb2RlbFxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBzYXZlIG5ldyByb3dWaWV3IHRvIGNhY2hlXG4gICAgICAgIHRoaXMucm93Vmlld3NbbW9kZWwuZ2V0KFwiaWRcIildID0gcm93VmlldztcblxuICAgICAgICB0aGlzLiRlbC5maW5kKFwiI2ZpcnN0X2ZvbGRlcl9pdGVtXCIpLmFmdGVyKHJvd1ZpZXcuZWwpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgdGhlIHZpZXcgb2YgdGhlIGdpdmVuIG1vZGVsIGZyb20gdGhlIERPTS5cbiAgICAgKiBAcGFyYW0ge0l0ZW0gb3IgRm9sZGVyQXNNb2RlbH0gbW9kZWwgb2YgdGhlIHZpZXcgdGhhdCB3aWxsIGJlIHJlbW92ZWRcbiAgICAgKi9cbiAgICByZW1vdmVPbmU6IGZ1bmN0aW9uKG1vZGVsKSB7XG4gICAgICAgIHRoaXMuJGVsXG4gICAgICAgICAgICAuZmluZChcInRyXCIpXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAkKHRoaXMpLmRhdGEoXCJpZFwiKSAmJiAkKHRoaXMpLmRhdGEoXCJpZFwiKSA9PT0gbW9kZWwuaWQ7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnJlbW92ZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYWxsIGRhdGFzZXQgYW5kIGZvbGRlciByb3cgZWxlbWVudHMgZnJvbSB0aGUgRE9NLlxuICAgICAqL1xuICAgIHJlbW92ZUFsbFJvd3M6IGZ1bmN0aW9uKCkge1xuICAgICAgICAkKFwiLmxpYnJhcnktcm93XCIpLnJlbW92ZSgpO1xuICAgIH0sXG5cbiAgICAvKiogQ2hlY2tzIHdoZXRoZXIgdGhlIGxpc3QgaXMgZW1wdHkgYW5kIGFkZHMvcmVtb3ZlcyB0aGUgbWVzc2FnZSAqL1xuICAgIGNoZWNrRW1wdGluZXNzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuJGVsLmZpbmQoXCIuZGF0YXNldF9yb3dcIikubGVuZ3RoID09PSAwICYmIHRoaXMuJGVsLmZpbmQoXCIuZm9sZGVyX3Jvd1wiKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuJGVsLmZpbmQoXCIuZW1wdHktZm9sZGVyLW1lc3NhZ2VcIikuc2hvdygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy4kZWwuZmluZChcIi5lbXB0eS1mb2xkZXItbWVzc2FnZVwiKS5oaWRlKCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgc29ydENvbHVtbkNsaWNrZWQ6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHRoaXMuY3VycmVudF9zb3J0X29yZGVyID0gdGhpcy5jdXJyZW50X3NvcnRfb3JkZXIgPT09IFwiYXNjXCIgPyBcImRlc2NcIiA6IFwiYXNjXCI7XG4gICAgICAgIHRoaXMuY3VycmVudF9zb3J0X2tleSA9IGV2ZW50LmN1cnJlbnRUYXJnZXQuY2xhc3NOYW1lLnJlcGxhY2UoXCJzb3J0LWZvbGRlci1cIiwgXCJcIik7XG4gICAgICAgIHRoaXMuY29sbGVjdGlvbi5zb3J0Rm9sZGVyKHRoaXMuY3VycmVudF9zb3J0X2tleSwgdGhpcy5jdXJyZW50X3NvcnRfb3JkZXIpO1xuICAgICAgICB0aGlzLnJlbmRlclNvcnRJY29uKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFVzZXIgY2xpY2tlZCB0aGUgY2hlY2tib3ggaW4gdGhlIHRhYmxlIGhlYWRpbmdcbiAgICAgKiBAcGFyYW0gIHtjb250ZXh0fSBldmVudFxuICAgICAqL1xuICAgIHNlbGVjdEFsbDogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgdmFyIHNlbGVjdGVkID0gZXZlbnQudGFyZ2V0LmNoZWNrZWQ7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgLy8gSXRlcmF0ZSBlYWNoIGNoZWNrYm94XG4gICAgICAgICQoXCI6Y2hlY2tib3hcIiwgXCIjZm9sZGVyX2xpc3RfYm9keVwiKS5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5jaGVja2VkID0gc2VsZWN0ZWQ7XG4gICAgICAgICAgICB2YXIgJHJvdyA9ICQodGhpcykuY2xvc2VzdChcInRyXCIpO1xuICAgICAgICAgICAgLy8gQ2hhbmdlIGNvbG9yIG9mIHNlbGVjdGVkL3Vuc2VsZWN0ZWRcbiAgICAgICAgICAgIGlmIChzZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgIHNlbGYubWFrZURhcmtSb3coJHJvdyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNlbGYubWFrZVdoaXRlUm93KCRyb3cpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgY2hlY2tib3ggaWYgdXNlciBjbGlja3Mgb24gdGhlIHdob2xlIHJvdyBvclxuICAgICAqICBvbiB0aGUgY2hlY2tib3ggaXRzZWxmXG4gICAgICovXG4gICAgc2VsZWN0Q2xpY2tlZFJvdzogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgdmFyIGNoZWNrYm94ID0gXCJcIjtcbiAgICAgICAgdmFyICRyb3c7XG4gICAgICAgIHZhciBzb3VyY2U7XG4gICAgICAgICRyb3cgPSAkKGV2ZW50LnRhcmdldCkuY2xvc2VzdChcInRyXCIpO1xuICAgICAgICBpZiAoZXZlbnQudGFyZ2V0LmxvY2FsTmFtZSA9PT0gXCJpbnB1dFwiKSB7XG4gICAgICAgICAgICBjaGVja2JveCA9IGV2ZW50LnRhcmdldDtcbiAgICAgICAgICAgIHNvdXJjZSA9IFwiaW5wdXRcIjtcbiAgICAgICAgfSBlbHNlIGlmIChldmVudC50YXJnZXQubG9jYWxOYW1lID09PSBcInRkXCIpIHtcbiAgICAgICAgICAgIGNoZWNrYm94ID0gJHJvdy5maW5kKFwiOmNoZWNrYm94XCIpWzBdO1xuICAgICAgICAgICAgc291cmNlID0gXCJ0ZFwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGVja2JveC5jaGVja2VkKSB7XG4gICAgICAgICAgICBpZiAoc291cmNlID09PSBcInRkXCIpIHtcbiAgICAgICAgICAgICAgICBjaGVja2JveC5jaGVja2VkID0gXCJcIjtcbiAgICAgICAgICAgICAgICB0aGlzLm1ha2VXaGl0ZVJvdygkcm93KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc291cmNlID09PSBcImlucHV0XCIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1ha2VEYXJrUm93KCRyb3cpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHNvdXJjZSA9PT0gXCJ0ZFwiKSB7XG4gICAgICAgICAgICAgICAgY2hlY2tib3guY2hlY2tlZCA9IFwic2VsZWN0ZWRcIjtcbiAgICAgICAgICAgICAgICB0aGlzLm1ha2VEYXJrUm93KCRyb3cpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzb3VyY2UgPT09IFwiaW5wdXRcIikge1xuICAgICAgICAgICAgICAgIHRoaXMubWFrZVdoaXRlUm93KCRyb3cpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIG1ha2VEYXJrUm93OiBmdW5jdGlvbigkcm93KSB7XG4gICAgICAgICRyb3cucmVtb3ZlQ2xhc3MoXCJsaWdodFwiKS5hZGRDbGFzcyhcImRhcmtcIik7XG4gICAgICAgICRyb3dcbiAgICAgICAgICAgIC5maW5kKFwiYVwiKVxuICAgICAgICAgICAgLnJlbW92ZUNsYXNzKFwibGlnaHRcIilcbiAgICAgICAgICAgIC5hZGRDbGFzcyhcImRhcmtcIik7XG4gICAgICAgICRyb3dcbiAgICAgICAgICAgIC5maW5kKFwiLmZhLWZpbGUtb1wiKVxuICAgICAgICAgICAgLnJlbW92ZUNsYXNzKFwiZmEtZmlsZS1vXCIpXG4gICAgICAgICAgICAuYWRkQ2xhc3MoXCJmYS1maWxlXCIpO1xuICAgICAgICAkcm93XG4gICAgICAgICAgICAuZmluZChcIi5mYS1mb2xkZXItb1wiKVxuICAgICAgICAgICAgLnJlbW92ZUNsYXNzKFwiZmEtZm9sZGVyLW9cIilcbiAgICAgICAgICAgIC5hZGRDbGFzcyhcImZhLWZvbGRlclwiKTtcbiAgICB9LFxuXG4gICAgbWFrZVdoaXRlUm93OiBmdW5jdGlvbigkcm93KSB7XG4gICAgICAgICRyb3cucmVtb3ZlQ2xhc3MoXCJkYXJrXCIpLmFkZENsYXNzKFwibGlnaHRcIik7XG4gICAgICAgICRyb3dcbiAgICAgICAgICAgIC5maW5kKFwiYVwiKVxuICAgICAgICAgICAgLnJlbW92ZUNsYXNzKFwiZGFya1wiKVxuICAgICAgICAgICAgLmFkZENsYXNzKFwibGlnaHRcIik7XG4gICAgICAgICRyb3dcbiAgICAgICAgICAgIC5maW5kKFwiLmZhLWZpbGVcIilcbiAgICAgICAgICAgIC5yZW1vdmVDbGFzcyhcImZhLWZpbGVcIilcbiAgICAgICAgICAgIC5hZGRDbGFzcyhcImZhLWZpbGUtb1wiKTtcbiAgICAgICAgJHJvd1xuICAgICAgICAgICAgLmZpbmQoXCIuZmEtZm9sZGVyXCIpXG4gICAgICAgICAgICAucmVtb3ZlQ2xhc3MoXCJmYS1mb2xkZXJcIilcbiAgICAgICAgICAgIC5hZGRDbGFzcyhcImZhLWZvbGRlci1vXCIpO1xuICAgIH0sXG5cbiAgICByZW5kZXJTb3J0SWNvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRfc29ydF9vcmRlciA9PT0gXCJhc2NcIikge1xuICAgICAgICAgICAgJCgnW2NsYXNzKj1cInNvcnQtaWNvblwiXScpXG4gICAgICAgICAgICAgICAgLnJlbW92ZUNsYXNzKFwiZmEtc29ydC1hbHBoYS1kZXNjXCIpXG4gICAgICAgICAgICAgICAgLnJlbW92ZUNsYXNzKFwiZmEtc29ydC1hbHBoYS1hc2NcIik7XG4gICAgICAgICAgICAkKGAuc29ydC1pY29uLSR7dGhpcy5jdXJyZW50X3NvcnRfa2V5fWApLmFkZENsYXNzKFwiZmEtc29ydC1hbHBoYS1hc2NcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAkKGAuc29ydC1pY29uLSR7dGhpcy5jdXJyZW50X3NvcnRfa2V5fWApLmFkZENsYXNzKFwiZmEtc29ydC1hbHBoYS1kZXNjXCIpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHRlbXBsYXRlRm9sZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF8udGVtcGxhdGUoXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgLy8gQlJFQURDUlVNQlNcbiAgICAgICAgICAgICAgICAnPG9sIGNsYXNzPVwiYnJlYWRjcnVtYlwiPicsXG4gICAgICAgICAgICAgICAgJzxsaT48YSB0aXRsZT1cIlJldHVybiB0byB0aGUgbGlzdCBvZiBsaWJyYXJpZXNcIiBocmVmPVwiI1wiPkxpYnJhcmllczwvYT48L2xpPicsXG4gICAgICAgICAgICAgICAgXCI8JSBfLmVhY2gocGF0aCwgZnVuY3Rpb24ocGF0aF9pdGVtKSB7ICU+XCIsXG4gICAgICAgICAgICAgICAgXCI8JSBpZiAocGF0aF9pdGVtWzBdICE9IGlkKSB7ICU+XCIsXG4gICAgICAgICAgICAgICAgJzxsaT48YSB0aXRsZT1cIlJldHVybiB0byB0aGlzIGZvbGRlclwiIGhyZWY9XCIjL2ZvbGRlcnMvPCUtIHBhdGhfaXRlbVswXSAlPlwiPjwlLSBwYXRoX2l0ZW1bMV0gJT48L2E+IDwvbGk+ICcsXG4gICAgICAgICAgICAgICAgXCI8JSB9IGVsc2UgeyAlPlwiLFxuICAgICAgICAgICAgICAgICc8bGkgY2xhc3M9XCJhY3RpdmVcIj48c3BhbiB0aXRsZT1cIllvdSBhcmUgaW4gdGhpcyBmb2xkZXJcIj48JS0gcGF0aF9pdGVtWzFdICU+PC9zcGFuPjwvbGk+JyxcbiAgICAgICAgICAgICAgICBcIjwlIH0gJT5cIixcbiAgICAgICAgICAgICAgICBcIjwlIH0pOyAlPlwiLFxuICAgICAgICAgICAgICAgIFwiPC9vbD5cIixcblxuICAgICAgICAgICAgICAgIC8vIEZPTERFUiBDT05URU5UXG4gICAgICAgICAgICAgICAgJzx0YWJsZSBkYXRhLWxpYnJhcnktaWQ9XCI8JS0gcGFyZW50X2xpYnJhcnlfaWQgICU+XCIgY2xhc3M9XCJncmlkIHRhYmxlIHRhYmxlLWNvbmRlbnNlZFwiPicsXG4gICAgICAgICAgICAgICAgXCI8dGhlYWQ+XCIsXG4gICAgICAgICAgICAgICAgJzx0aCBjbGFzcz1cImJ1dHRvbl9oZWFkaW5nXCI+PC90aD4nLFxuICAgICAgICAgICAgICAgICc8dGggc3R5bGU9XCJ0ZXh0LWFsaWduOiBjZW50ZXI7IHdpZHRoOiAyMHB4OyBcIiB0aXRsZT1cIkNoZWNrIHRvIHNlbGVjdCBhbGwgZGF0YXNldHNcIj48aW5wdXQgaWQ9XCJzZWxlY3QtYWxsLWNoZWNrYm94ZXNcIiBzdHlsZT1cIm1hcmdpbjogMDtcIiB0eXBlPVwiY2hlY2tib3hcIj48L3RoPicsXG4gICAgICAgICAgICAgICAgJzx0aD48YSBjbGFzcz1cInNvcnQtZm9sZGVyLW5hbWVcIiB0aXRsZT1cIkNsaWNrIHRvIHJldmVyc2Ugb3JkZXJcIiBocmVmPVwiI1wiPm5hbWU8L2E+IDxzcGFuIHRpdGxlPVwiU29ydGVkIGFscGhhYmV0aWNhbGx5XCIgY2xhc3M9XCJzb3J0LWljb24tbmFtZSBmYSBmYS1zb3J0LWFscGhhLTwlLSBvcmRlciAlPlwiPjwvc3Bhbj48L3RoPicsXG4gICAgICAgICAgICAgICAgJzx0aCBzdHlsZT1cIndpZHRoOjIwJTtcIj48YSBjbGFzcz1cInNvcnQtZm9sZGVyLWRlc2NyaXB0aW9uXCIgdGl0bGU9XCJDbGljayB0byByZXZlcnNlIG9yZGVyXCIgaHJlZj1cIiNcIj5kZXNjcmlwdGlvbjwvYT4gPHNwYW4gdGl0bGU9XCJTb3J0ZWQgYWxwaGFiZXRpY2FsbHlcIiBjbGFzcz1cInNvcnQtaWNvbi1kZXNjcmlwdGlvbiBmYVwiPjwvc3Bhbj48L3RoPicsXG4gICAgICAgICAgICAgICAgJzx0aCBzdHlsZT1cIndpZHRoOjUlO1wiPjxhIGNsYXNzPVwic29ydC1mb2xkZXItZmlsZV9leHRcIiB0aXRsZT1cIkNsaWNrIHRvIHJldmVyc2Ugb3JkZXJcIiBocmVmPVwiI1wiPmRhdGEgdHlwZTwvYT4gPHNwYW4gdGl0bGU9XCJTb3J0ZWQgYWxwaGFiZXRpY2FsbHlcIiBjbGFzcz1cInNvcnQtaWNvbi1maWxlX2V4dCBmYVwiPjwvc3Bhbj48L3RoPicsXG4gICAgICAgICAgICAgICAgJzx0aCBzdHlsZT1cIndpZHRoOjEwJTtcIj5zaXplPC90aD4nLFxuICAgICAgICAgICAgICAgICc8dGggc3R5bGU9XCJ3aWR0aDoxNjBweDtcIj50aW1lIHVwZGF0ZWQgKFVUQyk8L3RoPicsXG4gICAgICAgICAgICAgICAgJzx0aCBzdHlsZT1cIndpZHRoOjUlO1wiPjxhIGNsYXNzPVwic29ydC1mb2xkZXItc3RhdGVcIiB0aXRsZT1cIkNsaWNrIHRvIHJldmVyc2Ugb3JkZXJcIiBocmVmPVwiI1wiPnN0YXRlPC9hPiA8c3BhbiB0aXRsZT1cIlNvcnRlZCBhbHBoYWJldGljYWxseVwiIGNsYXNzPVwic29ydC1pY29uLXN0YXRlIGZhXCI+PC9zcGFuPjwvdGg+JyxcbiAgICAgICAgICAgICAgICAnPHRoIHN0eWxlPVwid2lkdGg6MTUwcHg7XCI+PC90aD4gJyxcbiAgICAgICAgICAgICAgICBcIjwvdGhlYWQ+XCIsXG4gICAgICAgICAgICAgICAgJzx0Ym9keSBpZD1cImZvbGRlcl9saXN0X2JvZHlcIj4nLFxuICAgICAgICAgICAgICAgICc8dHIgaWQ9XCJmaXJzdF9mb2xkZXJfaXRlbVwiPicsXG4gICAgICAgICAgICAgICAgXCI8dGQ+XCIsXG4gICAgICAgICAgICAgICAgJzxhIGhyZWY9XCIjPCUgaWYgKHVwcGVyX2ZvbGRlcl9pZCAhPT0gMCl7IHByaW50KFwiZm9sZGVycy9cIiArIHVwcGVyX2ZvbGRlcl9pZCl9ICU+XCIgdGl0bGU9XCJHbyB0byBwYXJlbnQgZm9sZGVyXCIgY2xhc3M9XCJidG5fb3Blbl9mb2xkZXIgYnRuIGJ0bi1kZWZhdWx0IGJ0bi14c1wiPi4uPGE+JyxcbiAgICAgICAgICAgICAgICBcIjwvdGQ+XCIsXG4gICAgICAgICAgICAgICAgXCI8dGQ+PC90ZD5cIixcbiAgICAgICAgICAgICAgICBcIjx0ZD48L3RkPlwiLFxuICAgICAgICAgICAgICAgIFwiPHRkPjwvdGQ+XCIsXG4gICAgICAgICAgICAgICAgXCI8dGQ+PC90ZD5cIixcbiAgICAgICAgICAgICAgICBcIjx0ZD48L3RkPlwiLFxuICAgICAgICAgICAgICAgIFwiPHRkPjwvdGQ+XCIsXG4gICAgICAgICAgICAgICAgXCI8dGQ+PC90ZD5cIixcbiAgICAgICAgICAgICAgICBcIjx0ZD48L3RkPlwiLFxuICAgICAgICAgICAgICAgIFwiPC90cj5cIixcbiAgICAgICAgICAgICAgICBcIjwvdGJvZHk+XCIsXG4gICAgICAgICAgICAgICAgXCI8L3RhYmxlPlwiLFxuICAgICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiZW1wdHktZm9sZGVyLW1lc3NhZ2VcIiBzdHlsZT1cImRpc3BsYXk6bm9uZTtcIj4nLFxuICAgICAgICAgICAgICAgIFwiVGhpcyBmb2xkZXIgaXMgZWl0aGVyIGVtcHR5IG9yIHlvdSBkbyBub3QgaGF2ZSBwcm9wZXIgYWNjZXNzIHBlcm1pc3Npb25zIHRvIHNlZSB0aGUgY29udGVudHMuIElmIHlvdSBleHBlY3RlZCBzb21ldGhpbmcgdG8gc2hvdyB1cFwiLFxuICAgICAgICAgICAgICAgICcgcGxlYXNlIGNvbnN1bHQgdGhlIDxhIGhyZWY9XCJodHRwczovL2dhbGF4eXByb2plY3Qub3JnL2RhdGEtbGlicmFyaWVzLyNwZXJtaXNzaW9uc1wiIHRhcmdldD1cIl9ibGFua1wiPmxpYnJhcnkgc2VjdXJpdHkgd2lraXBhZ2U8L2E+JyxcbiAgICAgICAgICAgICAgICAnIG9yIHZpc2l0IHRoZSA8YSBocmVmPVwiaHR0cHM6Ly9iaW9zdGFyLnVzZWdhbGF4eS5vcmcvXCIgdGFyZ2V0PVwiX2JsYW5rXCI+R2FsYXh5IHN1cHBvcnQgc2l0ZTwvYT4uJyxcbiAgICAgICAgICAgICAgICBcIjwvZGl2PlwiXG4gICAgICAgICAgICBdLmpvaW4oXCJcIilcbiAgICAgICAgKTtcbiAgICB9XG59KTtcblxuZXhwb3J0IGRlZmF1bHQge1xuICAgIEZvbGRlckxpc3RWaWV3OiBGb2xkZXJMaXN0Vmlld1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBnYWxheHkvc2NyaXB0cy9tdmMvbGlicmFyeS9saWJyYXJ5LWZvbGRlcmxpc3Qtdmlldy5qcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTs7O0FBQUE7QUFDQTs7O0FBQUE7QUFDQTs7Ozs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQUNBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFDQTtBQUtBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBbkJBO0FBcUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQUNBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBR0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBSUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFJQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBVUE7QUFDQTtBQW1DQTtBQTdaQTtBQUNBO0FBK1pBO0FBQ0E7QUFEQTtBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///298\n");

/***/ }),

/***/ 299:
/*!**************************************************************!*\
  !*** ./galaxy/scripts/mvc/library/library-folderrow-view.js ***!
  \**************************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(Backbone, _, $) {\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _toastr = __webpack_require__(/*! libs/toastr */ 7);\n\nvar _toastr2 = _interopRequireDefault(_toastr);\n\nvar _libraryModel = __webpack_require__(/*! mvc/library/library-model */ 13);\n\nvar _libraryModel2 = _interopRequireDefault(_libraryModel);\n\nvar _libraryDatasetView = __webpack_require__(/*! mvc/library/library-dataset-view */ 127);\n\nvar _libraryDatasetView2 = _interopRequireDefault(_libraryDatasetView);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar FolderRowView = Backbone.View.extend({\n    events: {\n        \"click .undelete_dataset_btn\": \"undeleteDataset\",\n        \"click .undelete_folder_btn\": \"undeleteFolder\",\n        \"click .edit_folder_btn\": \"startModifications\",\n        \"click .cancel_folder_btn\": \"cancelModifications\",\n        \"click .save_folder_btn\": \"saveModifications\"\n    },\n\n    defaults: {\n        type: null,\n        visibility_config: {\n            edit_folder_btn: false,\n            save_folder_btn: false,\n            cancel_folder_btn: false,\n            permission_folder_btn: false\n        },\n        edit_mode: false\n    },\n\n    initialize: function initialize(options) {\n        this.options = _.defaults(options || {}, this.defaults);\n        this.render(this.options);\n    },\n\n    render: function render(options) {\n        this.options = _.extend(this.options, options);\n        var folder_item = this.options.model;\n        var template = null;\n\n        if (folder_item.get(\"type\") === \"folder\" || folder_item.get(\"model_class\") === \"LibraryFolder\") {\n            this.options.type = \"folder\";\n            this.prepareButtons(folder_item);\n            if (folder_item.get(\"deleted\")) {\n                template = this.templateRowDeletedFolder();\n            } else {\n                template = this.templateRowFolder();\n            }\n        } else if (folder_item.get(\"type\") === \"file\" || folder_item.get(\"model_class\") === \"LibraryDatasetDatasetAssociation\" || folder_item.get(\"model_class\") === \"LibraryDataset\") {\n            this.options.type = \"file\";\n            if (folder_item.get(\"deleted\")) {\n                template = this.templateRowDeletedFile();\n            } else {\n                template = this.templateRowFile();\n            }\n        } else {\n            Galaxy.emit.error(\"Unknown library item type found.\");\n            Galaxy.emit.error(folder_item.get(\"type\") || folder_item.get(\"model_class\"));\n        }\n        this.setElement(template({\n            content_item: folder_item,\n            edit_mode: this.options.edit_mode,\n            button_config: this.options.visibility_config\n        }));\n        this.$el.show();\n        return this;\n    },\n\n    /**\n     * Modify the visibility of buttons for\n     * the filling of the row template of a given folder.\n     */\n    prepareButtons: function prepareButtons(folder) {\n        var vis_config = this.options.visibility_config;\n        if (this.options.edit_mode === false) {\n            vis_config.save_folder_btn = false;\n            vis_config.cancel_folder_btn = false;\n            if (folder.get(\"deleted\") === true) {\n                vis_config.edit_folder_btn = false;\n                vis_config.permission_folder_btn = false;\n            } else if (folder.get(\"deleted\") === false) {\n                vis_config.save_folder_btn = false;\n                vis_config.cancel_folder_btn = false;\n                if (folder.get(\"can_modify\") === true) {\n                    vis_config.edit_folder_btn = true;\n                }\n                if (folder.get(\"can_manage\") === true) {\n                    vis_config.permission_folder_btn = true;\n                }\n            }\n        } else if (this.options.edit_mode === true) {\n            vis_config.edit_folder_btn = false;\n            vis_config.permission_folder_btn = false;\n            vis_config.save_folder_btn = true;\n            vis_config.cancel_folder_btn = true;\n        }\n        this.options.visibility_config = vis_config;\n    },\n\n    /* Show the page with dataset details. */\n    showDatasetDetails: function showDatasetDetails() {\n        Galaxy.libraries.datasetView = new _libraryDatasetView2.default.LibraryDatasetView({ id: this.id });\n    },\n\n    /* Undelete the dataset on server and render the row again. */\n    undeleteDataset: function undeleteDataset(event) {\n        $(\".tooltip\").hide();\n        var that = this;\n        var dataset_id = $(event.target).closest(\"tr\").data(\"id\");\n        var dataset = Galaxy.libraries.folderListView.collection.get(dataset_id);\n        dataset.url = dataset.urlRoot + dataset.id + \"?undelete=true\";\n        dataset.destroy({\n            success: function success(model, response) {\n                Galaxy.libraries.folderListView.collection.remove(dataset_id);\n                var updated_dataset = new _libraryModel2.default.Item(response);\n                Galaxy.libraries.folderListView.collection.add(updated_dataset);\n                Galaxy.libraries.folderListView.collection.sortFolder(\"name\", \"asc\");\n                _toastr2.default.success(\"Dataset undeleted. Click this to see it.\", \"\", {\n                    onclick: function onclick() {\n                        var folder_id = that.model.get(\"folder_id\");\n                        window.location = Galaxy.root + \"library/list#folders/\" + folder_id + \"/datasets/\" + that.id;\n                    }\n                });\n            },\n            error: function error(model, response) {\n                if (typeof response.responseJSON !== \"undefined\") {\n                    _toastr2.default.error(\"Dataset was not undeleted. \" + response.responseJSON.err_msg);\n                } else {\n                    _toastr2.default.error(\"An error occured! Dataset was not undeleted. Please try again.\");\n                }\n            }\n        });\n    },\n\n    /* Undelete the folder on server and render the row again. */\n    undeleteFolder: function undeleteFolder(event) {\n        $(\".tooltip\").hide();\n        var that = this;\n        var folder_id = $(event.target).closest(\"tr\").data(\"id\");\n        var folder = Galaxy.libraries.folderListView.collection.get(folder_id);\n        folder.url = folder.urlRoot + folder.id + \"?undelete=true\";\n        folder.destroy({\n            success: function success(model, response) {\n                Galaxy.libraries.folderListView.collection.remove(folder_id);\n                var updated_folder = new _libraryModel2.default.FolderAsModel(response);\n                Galaxy.libraries.folderListView.collection.add(updated_folder);\n                Galaxy.libraries.folderListView.collection.sortFolder(\"name\", \"asc\");\n                _toastr2.default.success(\"Folder undeleted.\");\n            },\n            error: function error(model, response) {\n                if (typeof response.responseJSON !== \"undefined\") {\n                    _toastr2.default.error(\"Folder was not undeleted. \" + response.responseJSON.err_msg);\n                } else {\n                    _toastr2.default.error(\"An error occured! Folder was not undeleted. Please try again.\");\n                }\n            }\n        });\n    },\n\n    /* User clicked the 'edit' button on row so render the row as editable. */\n    startModifications: function startModifications() {\n        this.options.edit_mode = true;\n        this.repaint();\n    },\n\n    /* User clicked the 'cancel' button so render normal row */\n    cancelModifications: function cancelModifications() {\n        this.options.edit_mode = false;\n        this.repaint();\n    },\n\n    saveModifications: function saveModifications() {\n        var folder = Galaxy.libraries.folderListView.collection.get(this.$el.data(\"id\"));\n        var is_changed = false;\n        var new_name = this.$el.find(\".input_folder_name\").val();\n        if (typeof new_name !== \"undefined\" && new_name !== folder.get(\"name\")) {\n            if (new_name.length > 2) {\n                folder.set(\"name\", new_name);\n                is_changed = true;\n            } else {\n                _toastr2.default.warning(\"Folder name has to be at least 3 characters long.\");\n                return;\n            }\n        }\n        var new_description = this.$el.find(\".input_folder_description\").val();\n        if (typeof new_description !== \"undefined\" && new_description !== folder.get(\"description\")) {\n            folder.set(\"description\", new_description);\n            is_changed = true;\n        }\n        if (is_changed) {\n            var row_view = this;\n            folder.save(null, {\n                patch: true,\n                success: function success(folder) {\n                    row_view.options.edit_mode = false;\n                    row_view.repaint(folder);\n                    _toastr2.default.success(\"Changes to folder saved.\");\n                },\n                error: function error(model, response) {\n                    if (typeof response.responseJSON !== \"undefined\") {\n                        _toastr2.default.error(response.responseJSON.err_msg);\n                    } else {\n                        _toastr2.default.error(\"An error occured while attempting to update the folder.\");\n                    }\n                }\n            });\n        } else {\n            this.options.edit_mode = false;\n            this.repaint(folder);\n            _toastr2.default.info(\"Nothing has changed.\");\n        }\n    },\n\n    repaint: function repaint() {\n        /* need to hide manually because of the element removal in setElement\n        invoked in render() */\n        $(\".tooltip\").hide();\n        /* we need to store the old element to be able to replace it with\n        new one */\n        var old_element = this.$el;\n        /* if user canceled the folder param is undefined,\n        if user saved and succeeded the updated folder is rendered */\n        this.render();\n        old_element.replaceWith(this.$el);\n        /* now we attach new tooltips to the newly created row element */\n        this.$el.find(\"[data-toggle]\").tooltip();\n    },\n\n    templateRowFolder: function templateRowFolder() {\n        return _.template(['<tr class=\"folder_row light library-row\" data-id=\"<%- content_item.id %>\">', \"<td>\", '<span title=\"Folder\" class=\"fa fa-folder-o\"/>', \"</td>\", '<td style=\"text-align: center; \"><input style=\"margin: 0;\" type=\"checkbox\"></td>', \"<% if(!edit_mode) { %>\", \"<td>\", '<a href=\"#folders/<%- content_item.id %>\"><%- content_item.get(\"name\") %></a>', \"</td>\", \"<td>\", '<%- content_item.get(\"description\") %>', \"</td>\", \"<% } else if(edit_mode){ %>\", '<td><textarea rows=\"4\" class=\"form-control input_folder_name\" placeholder=\"name\" ><%- content_item.get(\"name\") %></textarea></td>', '<td><textarea rows=\"4\" class=\"form-control input_folder_description\" placeholder=\"description\" ><%- content_item.get(\"description\") %></textarea></td>', \"<% } %>\", \"<td>folder</td>\", \"<td></td>\", \"<td>\", '<%= _.escape(content_item.get(\"update_time\")) %>', \"</td>\", \"<td></td>\", \"<td>\", \"<% if(edit_mode) { %>\", // start edit mode\n        '<button data-toggle=\"tooltip\" data-placement=\"top\" title=\"Save changes\" class=\"primary-button btn-xs save_folder_btn\" type=\"button\" style=\"<% if(button_config.save_folder_btn === false) { print(\"display:none;\") } %>\">', '<span class=\"fa fa-floppy-o\"/> Save', \"</button>\", '<button data-toggle=\"tooltip\" data-placement=\"top\" title=\"Discard changes\" class=\"primary-button btn-xs cancel_folder_btn\" type=\"button\" style=\"<% if(button_config.cancel_folder_btn === false) { print(\"display:none;\") } %>\">', '<span class=\"fa fa-times\"/> Cancel', \"</button>\", \"<% } else if (!edit_mode){%>\", // start no edit mode\n        '<button data-toggle=\"tooltip\" data-placement=\"top\" title=\"Modify \\'<%- content_item.get(\"name\") %>\\'\" class=\"primary-button btn-xs edit_folder_btn\" type=\"button\" style=\"<% if(button_config.edit_folder_btn === false) { print(\"display:none;\") } %>\">', '<span class=\"fa fa-pencil\"/> Edit', \"</button>\", '<a href=\"#/folders/<%- content_item.id %>/permissions\">', '<button data-toggle=\"tooltip\" data-placement=\"top\" class=\"primary-button btn-xs permission_folder_btn\" title=\"Permissions of \\'<%- content_item.get(\"name\") %>\\'\" style=\"<% if(button_config.permission_folder_btn === false) { print(\"display:none;\") } %>\">', '<span class=\"fa fa-group\"/> Manage', \"</button>\", \"</a>\", \"<% } %>\", //end no edit mode\n        \"</td>\", \"</tr>\"].join(\"\"));\n    },\n\n    templateRowFile: function templateRowFile() {\n        return _.template(['<tr class=\"dataset_row light library-row\" data-id=\"<%- content_item.id %>\">', \"<td>\", '<span title=\"Dataset\" class=\"fa fa-file-o\"/>', \"</td>\", '<td style=\"text-align: center; \">', '<input style=\"margin: 0;\" type=\"checkbox\">', \"</td>\", \"<td>\", '<a href=\"#folders/<%- content_item.get(\"folder_id\") %>/datasets/<%- content_item.id %>\" class=\"library-dataset\">', '<%- content_item.get(\"name\") %>', \"<a>\", \"</td>\", '<td><%- content_item.get(\"message\") %></td>', '<td><%= _.escape(content_item.get(\"file_ext\")) %></td>', '<td><%= _.escape(content_item.get(\"file_size\")) %></td>', '<td><%= _.escape(content_item.get(\"update_time\")) %></td>', \"<td>\", '<% if ( content_item.get(\"state\") !== \"ok\" ) { %>', '<%= _.escape(content_item.get(\"state\")) %>', \"<% } %>\", \"</td>\", \"<td>\", '<% if (content_item.get(\"is_unrestricted\")) { %>', '<span data-toggle=\"tooltip\" data-placement=\"top\" title=\"Unrestricted dataset\" style=\"color:grey;\" class=\"fa fa-globe fa-lg\"/>', \"<% } %>\", '<% if (content_item.get(\"is_private\")) { %>', '<span data-toggle=\"tooltip\" data-placement=\"top\" title=\"Private dataset\" style=\"color:grey;\" class=\"fa fa-key fa-lg\"/>', \"<% } %>\", '<% if ((content_item.get(\"is_unrestricted\") === false) && (content_item.get(\"is_private\") === false)) { %>', '<span data-toggle=\"tooltip\" data-placement=\"top\" title=\"Restricted dataset\" style=\"color:grey;\" class=\"fa fa-shield fa-lg\"/>', \"<% } %>\", '<% if (content_item.get(\"can_manage\")) { %>', '<a href=\"#folders/<%- content_item.get(\"folder_id\") %>/datasets/<%- content_item.id %>/permissions\">', '<button data-toggle=\"tooltip\" data-placement=\"top\" class=\"primary-button btn-xs permissions-dataset-btn\" title=\"Permissions of \\'<%- content_item.get(\"name\") %>\\'\">', '<span class=\"fa fa-group\"/> Manage', \"</button>\", \"</a>\", \"<% } %>\", \"</td>\", \"</tr>\"].join(\"\"));\n    },\n\n    templateRowDeletedFile: function templateRowDeletedFile() {\n        return _.template(['<tr class=\"active deleted_dataset library-row\" data-id=\"<%- content_item.id %>\">', \"<td>\", '<span title=\"Dataset\" class=\"fa fa-file-o\"/>', \"</td>\", \"<td></td>\", '<td style=\"color:grey;\">', '<%- content_item.get(\"name\") %>', \"</td>\", \"<td>\", '<%- content_item.get(\"message\") %>', \"</td>\", \"<td>\", '<%= _.escape(content_item.get(\"file_ext\")) %>', \"</td>\", \"<td>\", '<%= _.escape(content_item.get(\"file_size\")) %>', \"</td>\", \"<td>\", '<%= _.escape(content_item.get(\"update_time\")) %>', \"</td>\", \"<td>\", '<% if ( content_item.get(\"state\") !== \"ok\" ) { %>', '<%= _.escape(content_item.get(\"state\")) %>', \"<% } %>\", \"</td>\", \"<td>\", '<span data-toggle=\"tooltip\" data-placement=\"top\" title=\"Marked deleted\" style=\"color:grey;\" class=\"fa fa-ban fa-lg\"/>', '<button data-toggle=\"tooltip\" data-placement=\"top\" title=\"Undelete \\'<%- content_item.get(\"name\") %>\\'\" class=\"primary-button btn-xs undelete_dataset_btn\" type=\"button\" style=\"margin-left:1em;\">', '<span class=\"fa fa-unlock\"/> Undelete', \"</button>\", \"</td>\", \"</tr>\"].join(\"\"));\n    },\n\n    templateRowDeletedFolder: function templateRowDeletedFolder() {\n        return _.template(['<tr class=\"active deleted_folder light library-row\" data-id=\"<%- content_item.id %>\">', \"<td>\", '<span title=\"Folder\" class=\"fa fa-folder-o\"/>', \"</td>\", \"<td></td>\", '<td style=\"color:grey;\">', '<%- content_item.get(\"name\") %>', \"</td>\", \"<td>\", '<%- content_item.get(\"description\") %>', \"</td>\", \"<td>\", \"folder\", \"</td>\", \"<td></td>\", \"<td>\", '<%= _.escape(content_item.get(\"update_time\")) %>', \"</td>\", \"<td></td>\", \"<td>\", '<span data-toggle=\"tooltip\" data-placement=\"top\" title=\"Marked deleted\" style=\"color:grey;\" class=\"fa fa-ban fa-lg\"/>', '<button data-toggle=\"tooltip\" data-placement=\"top\" title=\"Undelete \\'<%- content_item.get(\"name\") %>\\'\" class=\"primary-button btn-xs undelete_folder_btn\" type=\"button\" style=\"margin-left:1em;\">', '<span class=\"fa fa-unlock\"/> Undelete', \"</button>\", \"</td>\", \"</tr>\"].join(\"\"));\n    }\n});\n\nexports.default = {\n    FolderRowView: FolderRowView\n};\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! libs/backbone */ 2), __webpack_require__(/*! underscore */ 1), __webpack_require__(/*! jquery */ 0)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjk5LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL2dhbGF4eS9zY3JpcHRzL212Yy9saWJyYXJ5L2xpYnJhcnktZm9sZGVycm93LXZpZXcuanM/NmE1ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgbW9kX3RvYXN0ciBmcm9tIFwibGlicy90b2FzdHJcIjtcbmltcG9ydCBtb2RfbGlicmFyeV9tb2RlbCBmcm9tIFwibXZjL2xpYnJhcnkvbGlicmFyeS1tb2RlbFwiO1xuaW1wb3J0IG1vZF9saWJyYXJ5X2RhdGFzZXRfdmlldyBmcm9tIFwibXZjL2xpYnJhcnkvbGlicmFyeS1kYXRhc2V0LXZpZXdcIjtcbnZhciBGb2xkZXJSb3dWaWV3ID0gQmFja2JvbmUuVmlldy5leHRlbmQoe1xuICAgIGV2ZW50czoge1xuICAgICAgICBcImNsaWNrIC51bmRlbGV0ZV9kYXRhc2V0X2J0blwiOiBcInVuZGVsZXRlRGF0YXNldFwiLFxuICAgICAgICBcImNsaWNrIC51bmRlbGV0ZV9mb2xkZXJfYnRuXCI6IFwidW5kZWxldGVGb2xkZXJcIixcbiAgICAgICAgXCJjbGljayAuZWRpdF9mb2xkZXJfYnRuXCI6IFwic3RhcnRNb2RpZmljYXRpb25zXCIsXG4gICAgICAgIFwiY2xpY2sgLmNhbmNlbF9mb2xkZXJfYnRuXCI6IFwiY2FuY2VsTW9kaWZpY2F0aW9uc1wiLFxuICAgICAgICBcImNsaWNrIC5zYXZlX2ZvbGRlcl9idG5cIjogXCJzYXZlTW9kaWZpY2F0aW9uc1wiXG4gICAgfSxcblxuICAgIGRlZmF1bHRzOiB7XG4gICAgICAgIHR5cGU6IG51bGwsXG4gICAgICAgIHZpc2liaWxpdHlfY29uZmlnOiB7XG4gICAgICAgICAgICBlZGl0X2ZvbGRlcl9idG46IGZhbHNlLFxuICAgICAgICAgICAgc2F2ZV9mb2xkZXJfYnRuOiBmYWxzZSxcbiAgICAgICAgICAgIGNhbmNlbF9mb2xkZXJfYnRuOiBmYWxzZSxcbiAgICAgICAgICAgIHBlcm1pc3Npb25fZm9sZGVyX2J0bjogZmFsc2VcbiAgICAgICAgfSxcbiAgICAgICAgZWRpdF9tb2RlOiBmYWxzZVxuICAgIH0sXG5cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IF8uZGVmYXVsdHMob3B0aW9ucyB8fCB7fSwgdGhpcy5kZWZhdWx0cyk7XG4gICAgICAgIHRoaXMucmVuZGVyKHRoaXMub3B0aW9ucyk7XG4gICAgfSxcblxuICAgIHJlbmRlcjogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBfLmV4dGVuZCh0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuICAgICAgICB2YXIgZm9sZGVyX2l0ZW0gPSB0aGlzLm9wdGlvbnMubW9kZWw7XG4gICAgICAgIHZhciB0ZW1wbGF0ZSA9IG51bGw7XG5cbiAgICAgICAgaWYgKGZvbGRlcl9pdGVtLmdldChcInR5cGVcIikgPT09IFwiZm9sZGVyXCIgfHwgZm9sZGVyX2l0ZW0uZ2V0KFwibW9kZWxfY2xhc3NcIikgPT09IFwiTGlicmFyeUZvbGRlclwiKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMudHlwZSA9IFwiZm9sZGVyXCI7XG4gICAgICAgICAgICB0aGlzLnByZXBhcmVCdXR0b25zKGZvbGRlcl9pdGVtKTtcbiAgICAgICAgICAgIGlmIChmb2xkZXJfaXRlbS5nZXQoXCJkZWxldGVkXCIpKSB7XG4gICAgICAgICAgICAgICAgdGVtcGxhdGUgPSB0aGlzLnRlbXBsYXRlUm93RGVsZXRlZEZvbGRlcigpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZSA9IHRoaXMudGVtcGxhdGVSb3dGb2xkZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgIGZvbGRlcl9pdGVtLmdldChcInR5cGVcIikgPT09IFwiZmlsZVwiIHx8XG4gICAgICAgICAgICBmb2xkZXJfaXRlbS5nZXQoXCJtb2RlbF9jbGFzc1wiKSA9PT0gXCJMaWJyYXJ5RGF0YXNldERhdGFzZXRBc3NvY2lhdGlvblwiIHx8XG4gICAgICAgICAgICBmb2xkZXJfaXRlbS5nZXQoXCJtb2RlbF9jbGFzc1wiKSA9PT0gXCJMaWJyYXJ5RGF0YXNldFwiXG4gICAgICAgICkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLnR5cGUgPSBcImZpbGVcIjtcbiAgICAgICAgICAgIGlmIChmb2xkZXJfaXRlbS5nZXQoXCJkZWxldGVkXCIpKSB7XG4gICAgICAgICAgICAgICAgdGVtcGxhdGUgPSB0aGlzLnRlbXBsYXRlUm93RGVsZXRlZEZpbGUoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGVtcGxhdGUgPSB0aGlzLnRlbXBsYXRlUm93RmlsZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgR2FsYXh5LmVtaXQuZXJyb3IoXCJVbmtub3duIGxpYnJhcnkgaXRlbSB0eXBlIGZvdW5kLlwiKTtcbiAgICAgICAgICAgIEdhbGF4eS5lbWl0LmVycm9yKGZvbGRlcl9pdGVtLmdldChcInR5cGVcIikgfHwgZm9sZGVyX2l0ZW0uZ2V0KFwibW9kZWxfY2xhc3NcIikpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0RWxlbWVudChcbiAgICAgICAgICAgIHRlbXBsYXRlKHtcbiAgICAgICAgICAgICAgICBjb250ZW50X2l0ZW06IGZvbGRlcl9pdGVtLFxuICAgICAgICAgICAgICAgIGVkaXRfbW9kZTogdGhpcy5vcHRpb25zLmVkaXRfbW9kZSxcbiAgICAgICAgICAgICAgICBidXR0b25fY29uZmlnOiB0aGlzLm9wdGlvbnMudmlzaWJpbGl0eV9jb25maWdcbiAgICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuJGVsLnNob3coKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1vZGlmeSB0aGUgdmlzaWJpbGl0eSBvZiBidXR0b25zIGZvclxuICAgICAqIHRoZSBmaWxsaW5nIG9mIHRoZSByb3cgdGVtcGxhdGUgb2YgYSBnaXZlbiBmb2xkZXIuXG4gICAgICovXG4gICAgcHJlcGFyZUJ1dHRvbnM6IGZ1bmN0aW9uKGZvbGRlcikge1xuICAgICAgICB2YXIgdmlzX2NvbmZpZyA9IHRoaXMub3B0aW9ucy52aXNpYmlsaXR5X2NvbmZpZztcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5lZGl0X21vZGUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB2aXNfY29uZmlnLnNhdmVfZm9sZGVyX2J0biA9IGZhbHNlO1xuICAgICAgICAgICAgdmlzX2NvbmZpZy5jYW5jZWxfZm9sZGVyX2J0biA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKGZvbGRlci5nZXQoXCJkZWxldGVkXCIpID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgdmlzX2NvbmZpZy5lZGl0X2ZvbGRlcl9idG4gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB2aXNfY29uZmlnLnBlcm1pc3Npb25fZm9sZGVyX2J0biA9IGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChmb2xkZXIuZ2V0KFwiZGVsZXRlZFwiKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICB2aXNfY29uZmlnLnNhdmVfZm9sZGVyX2J0biA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHZpc19jb25maWcuY2FuY2VsX2ZvbGRlcl9idG4gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAoZm9sZGVyLmdldChcImNhbl9tb2RpZnlcIikgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmlzX2NvbmZpZy5lZGl0X2ZvbGRlcl9idG4gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZm9sZGVyLmdldChcImNhbl9tYW5hZ2VcIikgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmlzX2NvbmZpZy5wZXJtaXNzaW9uX2ZvbGRlcl9idG4gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMuZWRpdF9tb2RlID09PSB0cnVlKSB7XG4gICAgICAgICAgICB2aXNfY29uZmlnLmVkaXRfZm9sZGVyX2J0biA9IGZhbHNlO1xuICAgICAgICAgICAgdmlzX2NvbmZpZy5wZXJtaXNzaW9uX2ZvbGRlcl9idG4gPSBmYWxzZTtcbiAgICAgICAgICAgIHZpc19jb25maWcuc2F2ZV9mb2xkZXJfYnRuID0gdHJ1ZTtcbiAgICAgICAgICAgIHZpc19jb25maWcuY2FuY2VsX2ZvbGRlcl9idG4gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3B0aW9ucy52aXNpYmlsaXR5X2NvbmZpZyA9IHZpc19jb25maWc7XG4gICAgfSxcblxuICAgIC8qIFNob3cgdGhlIHBhZ2Ugd2l0aCBkYXRhc2V0IGRldGFpbHMuICovXG4gICAgc2hvd0RhdGFzZXREZXRhaWxzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgR2FsYXh5LmxpYnJhcmllcy5kYXRhc2V0VmlldyA9IG5ldyBtb2RfbGlicmFyeV9kYXRhc2V0X3ZpZXcuTGlicmFyeURhdGFzZXRWaWV3KHsgaWQ6IHRoaXMuaWQgfSk7XG4gICAgfSxcblxuICAgIC8qIFVuZGVsZXRlIHRoZSBkYXRhc2V0IG9uIHNlcnZlciBhbmQgcmVuZGVyIHRoZSByb3cgYWdhaW4uICovXG4gICAgdW5kZWxldGVEYXRhc2V0OiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAkKFwiLnRvb2x0aXBcIikuaGlkZSgpO1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgIHZhciBkYXRhc2V0X2lkID0gJChldmVudC50YXJnZXQpXG4gICAgICAgICAgICAuY2xvc2VzdChcInRyXCIpXG4gICAgICAgICAgICAuZGF0YShcImlkXCIpO1xuICAgICAgICB2YXIgZGF0YXNldCA9IEdhbGF4eS5saWJyYXJpZXMuZm9sZGVyTGlzdFZpZXcuY29sbGVjdGlvbi5nZXQoZGF0YXNldF9pZCk7XG4gICAgICAgIGRhdGFzZXQudXJsID0gYCR7ZGF0YXNldC51cmxSb290ICsgZGF0YXNldC5pZH0/dW5kZWxldGU9dHJ1ZWA7XG4gICAgICAgIGRhdGFzZXQuZGVzdHJveSh7XG4gICAgICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbihtb2RlbCwgcmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICBHYWxheHkubGlicmFyaWVzLmZvbGRlckxpc3RWaWV3LmNvbGxlY3Rpb24ucmVtb3ZlKGRhdGFzZXRfaWQpO1xuICAgICAgICAgICAgICAgIHZhciB1cGRhdGVkX2RhdGFzZXQgPSBuZXcgbW9kX2xpYnJhcnlfbW9kZWwuSXRlbShyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgR2FsYXh5LmxpYnJhcmllcy5mb2xkZXJMaXN0Vmlldy5jb2xsZWN0aW9uLmFkZCh1cGRhdGVkX2RhdGFzZXQpO1xuICAgICAgICAgICAgICAgIEdhbGF4eS5saWJyYXJpZXMuZm9sZGVyTGlzdFZpZXcuY29sbGVjdGlvbi5zb3J0Rm9sZGVyKFwibmFtZVwiLCBcImFzY1wiKTtcbiAgICAgICAgICAgICAgICBtb2RfdG9hc3RyLnN1Y2Nlc3MoXCJEYXRhc2V0IHVuZGVsZXRlZC4gQ2xpY2sgdGhpcyB0byBzZWUgaXQuXCIsIFwiXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgb25jbGljazogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZm9sZGVyX2lkID0gdGhhdC5tb2RlbC5nZXQoXCJmb2xkZXJfaWRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cubG9jYXRpb24gPSBgJHtHYWxheHkucm9vdH1saWJyYXJ5L2xpc3QjZm9sZGVycy8ke2ZvbGRlcl9pZH0vZGF0YXNldHMvJHt0aGF0LmlkfWA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlcnJvcjogZnVuY3Rpb24obW9kZWwsIHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByZXNwb25zZS5yZXNwb25zZUpTT04gIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgbW9kX3RvYXN0ci5lcnJvcihgRGF0YXNldCB3YXMgbm90IHVuZGVsZXRlZC4gJHtyZXNwb25zZS5yZXNwb25zZUpTT04uZXJyX21zZ31gKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtb2RfdG9hc3RyLmVycm9yKFwiQW4gZXJyb3Igb2NjdXJlZCEgRGF0YXNldCB3YXMgbm90IHVuZGVsZXRlZC4gUGxlYXNlIHRyeSBhZ2Fpbi5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyogVW5kZWxldGUgdGhlIGZvbGRlciBvbiBzZXJ2ZXIgYW5kIHJlbmRlciB0aGUgcm93IGFnYWluLiAqL1xuICAgIHVuZGVsZXRlRm9sZGVyOiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAkKFwiLnRvb2x0aXBcIikuaGlkZSgpO1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgIHZhciBmb2xkZXJfaWQgPSAkKGV2ZW50LnRhcmdldClcbiAgICAgICAgICAgIC5jbG9zZXN0KFwidHJcIilcbiAgICAgICAgICAgIC5kYXRhKFwiaWRcIik7XG4gICAgICAgIHZhciBmb2xkZXIgPSBHYWxheHkubGlicmFyaWVzLmZvbGRlckxpc3RWaWV3LmNvbGxlY3Rpb24uZ2V0KGZvbGRlcl9pZCk7XG4gICAgICAgIGZvbGRlci51cmwgPSBgJHtmb2xkZXIudXJsUm9vdCArIGZvbGRlci5pZH0/dW5kZWxldGU9dHJ1ZWA7XG4gICAgICAgIGZvbGRlci5kZXN0cm95KHtcbiAgICAgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uKG1vZGVsLCByZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIEdhbGF4eS5saWJyYXJpZXMuZm9sZGVyTGlzdFZpZXcuY29sbGVjdGlvbi5yZW1vdmUoZm9sZGVyX2lkKTtcbiAgICAgICAgICAgICAgICB2YXIgdXBkYXRlZF9mb2xkZXIgPSBuZXcgbW9kX2xpYnJhcnlfbW9kZWwuRm9sZGVyQXNNb2RlbChyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgR2FsYXh5LmxpYnJhcmllcy5mb2xkZXJMaXN0Vmlldy5jb2xsZWN0aW9uLmFkZCh1cGRhdGVkX2ZvbGRlcik7XG4gICAgICAgICAgICAgICAgR2FsYXh5LmxpYnJhcmllcy5mb2xkZXJMaXN0Vmlldy5jb2xsZWN0aW9uLnNvcnRGb2xkZXIoXCJuYW1lXCIsIFwiYXNjXCIpO1xuICAgICAgICAgICAgICAgIG1vZF90b2FzdHIuc3VjY2VzcyhcIkZvbGRlciB1bmRlbGV0ZWQuXCIpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVycm9yOiBmdW5jdGlvbihtb2RlbCwgcmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJlc3BvbnNlLnJlc3BvbnNlSlNPTiAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgICAgICBtb2RfdG9hc3RyLmVycm9yKGBGb2xkZXIgd2FzIG5vdCB1bmRlbGV0ZWQuICR7cmVzcG9uc2UucmVzcG9uc2VKU09OLmVycl9tc2d9YCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbW9kX3RvYXN0ci5lcnJvcihcIkFuIGVycm9yIG9jY3VyZWQhIEZvbGRlciB3YXMgbm90IHVuZGVsZXRlZC4gUGxlYXNlIHRyeSBhZ2Fpbi5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyogVXNlciBjbGlja2VkIHRoZSAnZWRpdCcgYnV0dG9uIG9uIHJvdyBzbyByZW5kZXIgdGhlIHJvdyBhcyBlZGl0YWJsZS4gKi9cbiAgICBzdGFydE1vZGlmaWNhdGlvbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLm9wdGlvbnMuZWRpdF9tb2RlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5yZXBhaW50KCk7XG4gICAgfSxcblxuICAgIC8qIFVzZXIgY2xpY2tlZCB0aGUgJ2NhbmNlbCcgYnV0dG9uIHNvIHJlbmRlciBub3JtYWwgcm93ICovXG4gICAgY2FuY2VsTW9kaWZpY2F0aW9uczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5lZGl0X21vZGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5yZXBhaW50KCk7XG4gICAgfSxcblxuICAgIHNhdmVNb2RpZmljYXRpb25zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGZvbGRlciA9IEdhbGF4eS5saWJyYXJpZXMuZm9sZGVyTGlzdFZpZXcuY29sbGVjdGlvbi5nZXQodGhpcy4kZWwuZGF0YShcImlkXCIpKTtcbiAgICAgICAgdmFyIGlzX2NoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgdmFyIG5ld19uYW1lID0gdGhpcy4kZWwuZmluZChcIi5pbnB1dF9mb2xkZXJfbmFtZVwiKS52YWwoKTtcbiAgICAgICAgaWYgKHR5cGVvZiBuZXdfbmFtZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBuZXdfbmFtZSAhPT0gZm9sZGVyLmdldChcIm5hbWVcIikpIHtcbiAgICAgICAgICAgIGlmIChuZXdfbmFtZS5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICAgICAgZm9sZGVyLnNldChcIm5hbWVcIiwgbmV3X25hbWUpO1xuICAgICAgICAgICAgICAgIGlzX2NoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtb2RfdG9hc3RyLndhcm5pbmcoXCJGb2xkZXIgbmFtZSBoYXMgdG8gYmUgYXQgbGVhc3QgMyBjaGFyYWN0ZXJzIGxvbmcuXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgbmV3X2Rlc2NyaXB0aW9uID0gdGhpcy4kZWwuZmluZChcIi5pbnB1dF9mb2xkZXJfZGVzY3JpcHRpb25cIikudmFsKCk7XG4gICAgICAgIGlmICh0eXBlb2YgbmV3X2Rlc2NyaXB0aW9uICE9PSBcInVuZGVmaW5lZFwiICYmIG5ld19kZXNjcmlwdGlvbiAhPT0gZm9sZGVyLmdldChcImRlc2NyaXB0aW9uXCIpKSB7XG4gICAgICAgICAgICBmb2xkZXIuc2V0KFwiZGVzY3JpcHRpb25cIiwgbmV3X2Rlc2NyaXB0aW9uKTtcbiAgICAgICAgICAgIGlzX2NoYW5nZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc19jaGFuZ2VkKSB7XG4gICAgICAgICAgICB2YXIgcm93X3ZpZXcgPSB0aGlzO1xuICAgICAgICAgICAgZm9sZGVyLnNhdmUobnVsbCwge1xuICAgICAgICAgICAgICAgIHBhdGNoOiB0cnVlLFxuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uKGZvbGRlcikge1xuICAgICAgICAgICAgICAgICAgICByb3dfdmlldy5vcHRpb25zLmVkaXRfbW9kZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICByb3dfdmlldy5yZXBhaW50KGZvbGRlcik7XG4gICAgICAgICAgICAgICAgICAgIG1vZF90b2FzdHIuc3VjY2VzcyhcIkNoYW5nZXMgdG8gZm9sZGVyIHNhdmVkLlwiKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGVycm9yOiBmdW5jdGlvbihtb2RlbCwgcmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByZXNwb25zZS5yZXNwb25zZUpTT04gIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZF90b2FzdHIuZXJyb3IocmVzcG9uc2UucmVzcG9uc2VKU09OLmVycl9tc2cpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9kX3RvYXN0ci5lcnJvcihcIkFuIGVycm9yIG9jY3VyZWQgd2hpbGUgYXR0ZW1wdGluZyB0byB1cGRhdGUgdGhlIGZvbGRlci5cIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5lZGl0X21vZGUgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMucmVwYWludChmb2xkZXIpO1xuICAgICAgICAgICAgbW9kX3RvYXN0ci5pbmZvKFwiTm90aGluZyBoYXMgY2hhbmdlZC5cIik7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgcmVwYWludDogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8qIG5lZWQgdG8gaGlkZSBtYW51YWxseSBiZWNhdXNlIG9mIHRoZSBlbGVtZW50IHJlbW92YWwgaW4gc2V0RWxlbWVudFxuICAgIGludm9rZWQgaW4gcmVuZGVyKCkgKi9cbiAgICAgICAgJChcIi50b29sdGlwXCIpLmhpZGUoKTtcbiAgICAgICAgLyogd2UgbmVlZCB0byBzdG9yZSB0aGUgb2xkIGVsZW1lbnQgdG8gYmUgYWJsZSB0byByZXBsYWNlIGl0IHdpdGhcbiAgICBuZXcgb25lICovXG4gICAgICAgIHZhciBvbGRfZWxlbWVudCA9IHRoaXMuJGVsO1xuICAgICAgICAvKiBpZiB1c2VyIGNhbmNlbGVkIHRoZSBmb2xkZXIgcGFyYW0gaXMgdW5kZWZpbmVkLFxuICAgICAgaWYgdXNlciBzYXZlZCBhbmQgc3VjY2VlZGVkIHRoZSB1cGRhdGVkIGZvbGRlciBpcyByZW5kZXJlZCAqL1xuICAgICAgICB0aGlzLnJlbmRlcigpO1xuICAgICAgICBvbGRfZWxlbWVudC5yZXBsYWNlV2l0aCh0aGlzLiRlbCk7XG4gICAgICAgIC8qIG5vdyB3ZSBhdHRhY2ggbmV3IHRvb2x0aXBzIHRvIHRoZSBuZXdseSBjcmVhdGVkIHJvdyBlbGVtZW50ICovXG4gICAgICAgIHRoaXMuJGVsLmZpbmQoXCJbZGF0YS10b2dnbGVdXCIpLnRvb2x0aXAoKTtcbiAgICB9LFxuXG4gICAgdGVtcGxhdGVSb3dGb2xkZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gXy50ZW1wbGF0ZShcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnPHRyIGNsYXNzPVwiZm9sZGVyX3JvdyBsaWdodCBsaWJyYXJ5LXJvd1wiIGRhdGEtaWQ9XCI8JS0gY29udGVudF9pdGVtLmlkICU+XCI+JyxcbiAgICAgICAgICAgICAgICBcIjx0ZD5cIixcbiAgICAgICAgICAgICAgICAnPHNwYW4gdGl0bGU9XCJGb2xkZXJcIiBjbGFzcz1cImZhIGZhLWZvbGRlci1vXCIvPicsXG4gICAgICAgICAgICAgICAgXCI8L3RkPlwiLFxuICAgICAgICAgICAgICAgICc8dGQgc3R5bGU9XCJ0ZXh0LWFsaWduOiBjZW50ZXI7IFwiPjxpbnB1dCBzdHlsZT1cIm1hcmdpbjogMDtcIiB0eXBlPVwiY2hlY2tib3hcIj48L3RkPicsXG4gICAgICAgICAgICAgICAgXCI8JSBpZighZWRpdF9tb2RlKSB7ICU+XCIsXG4gICAgICAgICAgICAgICAgXCI8dGQ+XCIsXG4gICAgICAgICAgICAgICAgJzxhIGhyZWY9XCIjZm9sZGVycy88JS0gY29udGVudF9pdGVtLmlkICU+XCI+PCUtIGNvbnRlbnRfaXRlbS5nZXQoXCJuYW1lXCIpICU+PC9hPicsXG4gICAgICAgICAgICAgICAgXCI8L3RkPlwiLFxuICAgICAgICAgICAgICAgIFwiPHRkPlwiLFxuICAgICAgICAgICAgICAgICc8JS0gY29udGVudF9pdGVtLmdldChcImRlc2NyaXB0aW9uXCIpICU+JyxcbiAgICAgICAgICAgICAgICBcIjwvdGQ+XCIsXG4gICAgICAgICAgICAgICAgXCI8JSB9IGVsc2UgaWYoZWRpdF9tb2RlKXsgJT5cIixcbiAgICAgICAgICAgICAgICAnPHRkPjx0ZXh0YXJlYSByb3dzPVwiNFwiIGNsYXNzPVwiZm9ybS1jb250cm9sIGlucHV0X2ZvbGRlcl9uYW1lXCIgcGxhY2Vob2xkZXI9XCJuYW1lXCIgPjwlLSBjb250ZW50X2l0ZW0uZ2V0KFwibmFtZVwiKSAlPjwvdGV4dGFyZWE+PC90ZD4nLFxuICAgICAgICAgICAgICAgICc8dGQ+PHRleHRhcmVhIHJvd3M9XCI0XCIgY2xhc3M9XCJmb3JtLWNvbnRyb2wgaW5wdXRfZm9sZGVyX2Rlc2NyaXB0aW9uXCIgcGxhY2Vob2xkZXI9XCJkZXNjcmlwdGlvblwiID48JS0gY29udGVudF9pdGVtLmdldChcImRlc2NyaXB0aW9uXCIpICU+PC90ZXh0YXJlYT48L3RkPicsXG4gICAgICAgICAgICAgICAgXCI8JSB9ICU+XCIsXG4gICAgICAgICAgICAgICAgXCI8dGQ+Zm9sZGVyPC90ZD5cIixcbiAgICAgICAgICAgICAgICBcIjx0ZD48L3RkPlwiLFxuICAgICAgICAgICAgICAgIFwiPHRkPlwiLFxuICAgICAgICAgICAgICAgICc8JT0gXy5lc2NhcGUoY29udGVudF9pdGVtLmdldChcInVwZGF0ZV90aW1lXCIpKSAlPicsXG4gICAgICAgICAgICAgICAgXCI8L3RkPlwiLFxuICAgICAgICAgICAgICAgIFwiPHRkPjwvdGQ+XCIsXG4gICAgICAgICAgICAgICAgXCI8dGQ+XCIsXG4gICAgICAgICAgICAgICAgXCI8JSBpZihlZGl0X21vZGUpIHsgJT5cIiwgLy8gc3RhcnQgZWRpdCBtb2RlXG4gICAgICAgICAgICAgICAgJzxidXR0b24gZGF0YS10b2dnbGU9XCJ0b29sdGlwXCIgZGF0YS1wbGFjZW1lbnQ9XCJ0b3BcIiB0aXRsZT1cIlNhdmUgY2hhbmdlc1wiIGNsYXNzPVwicHJpbWFyeS1idXR0b24gYnRuLXhzIHNhdmVfZm9sZGVyX2J0blwiIHR5cGU9XCJidXR0b25cIiBzdHlsZT1cIjwlIGlmKGJ1dHRvbl9jb25maWcuc2F2ZV9mb2xkZXJfYnRuID09PSBmYWxzZSkgeyBwcmludChcImRpc3BsYXk6bm9uZTtcIikgfSAlPlwiPicsXG4gICAgICAgICAgICAgICAgJzxzcGFuIGNsYXNzPVwiZmEgZmEtZmxvcHB5LW9cIi8+IFNhdmUnLFxuICAgICAgICAgICAgICAgIFwiPC9idXR0b24+XCIsXG4gICAgICAgICAgICAgICAgJzxidXR0b24gZGF0YS10b2dnbGU9XCJ0b29sdGlwXCIgZGF0YS1wbGFjZW1lbnQ9XCJ0b3BcIiB0aXRsZT1cIkRpc2NhcmQgY2hhbmdlc1wiIGNsYXNzPVwicHJpbWFyeS1idXR0b24gYnRuLXhzIGNhbmNlbF9mb2xkZXJfYnRuXCIgdHlwZT1cImJ1dHRvblwiIHN0eWxlPVwiPCUgaWYoYnV0dG9uX2NvbmZpZy5jYW5jZWxfZm9sZGVyX2J0biA9PT0gZmFsc2UpIHsgcHJpbnQoXCJkaXNwbGF5Om5vbmU7XCIpIH0gJT5cIj4nLFxuICAgICAgICAgICAgICAgICc8c3BhbiBjbGFzcz1cImZhIGZhLXRpbWVzXCIvPiBDYW5jZWwnLFxuICAgICAgICAgICAgICAgIFwiPC9idXR0b24+XCIsXG4gICAgICAgICAgICAgICAgXCI8JSB9IGVsc2UgaWYgKCFlZGl0X21vZGUpeyU+XCIsIC8vIHN0YXJ0IG5vIGVkaXQgbW9kZVxuICAgICAgICAgICAgICAgICc8YnV0dG9uIGRhdGEtdG9nZ2xlPVwidG9vbHRpcFwiIGRhdGEtcGxhY2VtZW50PVwidG9wXCIgdGl0bGU9XCJNb2RpZnkgXFwnPCUtIGNvbnRlbnRfaXRlbS5nZXQoXCJuYW1lXCIpICU+XFwnXCIgY2xhc3M9XCJwcmltYXJ5LWJ1dHRvbiBidG4teHMgZWRpdF9mb2xkZXJfYnRuXCIgdHlwZT1cImJ1dHRvblwiIHN0eWxlPVwiPCUgaWYoYnV0dG9uX2NvbmZpZy5lZGl0X2ZvbGRlcl9idG4gPT09IGZhbHNlKSB7IHByaW50KFwiZGlzcGxheTpub25lO1wiKSB9ICU+XCI+JyxcbiAgICAgICAgICAgICAgICAnPHNwYW4gY2xhc3M9XCJmYSBmYS1wZW5jaWxcIi8+IEVkaXQnLFxuICAgICAgICAgICAgICAgIFwiPC9idXR0b24+XCIsXG4gICAgICAgICAgICAgICAgJzxhIGhyZWY9XCIjL2ZvbGRlcnMvPCUtIGNvbnRlbnRfaXRlbS5pZCAlPi9wZXJtaXNzaW9uc1wiPicsXG4gICAgICAgICAgICAgICAgJzxidXR0b24gZGF0YS10b2dnbGU9XCJ0b29sdGlwXCIgZGF0YS1wbGFjZW1lbnQ9XCJ0b3BcIiBjbGFzcz1cInByaW1hcnktYnV0dG9uIGJ0bi14cyBwZXJtaXNzaW9uX2ZvbGRlcl9idG5cIiB0aXRsZT1cIlBlcm1pc3Npb25zIG9mIFxcJzwlLSBjb250ZW50X2l0ZW0uZ2V0KFwibmFtZVwiKSAlPlxcJ1wiIHN0eWxlPVwiPCUgaWYoYnV0dG9uX2NvbmZpZy5wZXJtaXNzaW9uX2ZvbGRlcl9idG4gPT09IGZhbHNlKSB7IHByaW50KFwiZGlzcGxheTpub25lO1wiKSB9ICU+XCI+JyxcbiAgICAgICAgICAgICAgICAnPHNwYW4gY2xhc3M9XCJmYSBmYS1ncm91cFwiLz4gTWFuYWdlJyxcbiAgICAgICAgICAgICAgICBcIjwvYnV0dG9uPlwiLFxuICAgICAgICAgICAgICAgIFwiPC9hPlwiLFxuICAgICAgICAgICAgICAgIFwiPCUgfSAlPlwiLCAvL2VuZCBubyBlZGl0IG1vZGVcbiAgICAgICAgICAgICAgICBcIjwvdGQ+XCIsXG4gICAgICAgICAgICAgICAgXCI8L3RyPlwiXG4gICAgICAgICAgICBdLmpvaW4oXCJcIilcbiAgICAgICAgKTtcbiAgICB9LFxuXG4gICAgdGVtcGxhdGVSb3dGaWxlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF8udGVtcGxhdGUoXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJzx0ciBjbGFzcz1cImRhdGFzZXRfcm93IGxpZ2h0IGxpYnJhcnktcm93XCIgZGF0YS1pZD1cIjwlLSBjb250ZW50X2l0ZW0uaWQgJT5cIj4nLFxuICAgICAgICAgICAgICAgIFwiPHRkPlwiLFxuICAgICAgICAgICAgICAgICc8c3BhbiB0aXRsZT1cIkRhdGFzZXRcIiBjbGFzcz1cImZhIGZhLWZpbGUtb1wiLz4nLFxuICAgICAgICAgICAgICAgIFwiPC90ZD5cIixcbiAgICAgICAgICAgICAgICAnPHRkIHN0eWxlPVwidGV4dC1hbGlnbjogY2VudGVyOyBcIj4nLFxuICAgICAgICAgICAgICAgICc8aW5wdXQgc3R5bGU9XCJtYXJnaW46IDA7XCIgdHlwZT1cImNoZWNrYm94XCI+JyxcbiAgICAgICAgICAgICAgICBcIjwvdGQ+XCIsXG4gICAgICAgICAgICAgICAgXCI8dGQ+XCIsXG4gICAgICAgICAgICAgICAgJzxhIGhyZWY9XCIjZm9sZGVycy88JS0gY29udGVudF9pdGVtLmdldChcImZvbGRlcl9pZFwiKSAlPi9kYXRhc2V0cy88JS0gY29udGVudF9pdGVtLmlkICU+XCIgY2xhc3M9XCJsaWJyYXJ5LWRhdGFzZXRcIj4nLFxuICAgICAgICAgICAgICAgICc8JS0gY29udGVudF9pdGVtLmdldChcIm5hbWVcIikgJT4nLFxuICAgICAgICAgICAgICAgIFwiPGE+XCIsXG4gICAgICAgICAgICAgICAgXCI8L3RkPlwiLFxuICAgICAgICAgICAgICAgICc8dGQ+PCUtIGNvbnRlbnRfaXRlbS5nZXQoXCJtZXNzYWdlXCIpICU+PC90ZD4nLFxuICAgICAgICAgICAgICAgICc8dGQ+PCU9IF8uZXNjYXBlKGNvbnRlbnRfaXRlbS5nZXQoXCJmaWxlX2V4dFwiKSkgJT48L3RkPicsXG4gICAgICAgICAgICAgICAgJzx0ZD48JT0gXy5lc2NhcGUoY29udGVudF9pdGVtLmdldChcImZpbGVfc2l6ZVwiKSkgJT48L3RkPicsXG4gICAgICAgICAgICAgICAgJzx0ZD48JT0gXy5lc2NhcGUoY29udGVudF9pdGVtLmdldChcInVwZGF0ZV90aW1lXCIpKSAlPjwvdGQ+JyxcbiAgICAgICAgICAgICAgICBcIjx0ZD5cIixcbiAgICAgICAgICAgICAgICAnPCUgaWYgKCBjb250ZW50X2l0ZW0uZ2V0KFwic3RhdGVcIikgIT09IFwib2tcIiApIHsgJT4nLFxuICAgICAgICAgICAgICAgICc8JT0gXy5lc2NhcGUoY29udGVudF9pdGVtLmdldChcInN0YXRlXCIpKSAlPicsXG4gICAgICAgICAgICAgICAgXCI8JSB9ICU+XCIsXG4gICAgICAgICAgICAgICAgXCI8L3RkPlwiLFxuICAgICAgICAgICAgICAgIFwiPHRkPlwiLFxuICAgICAgICAgICAgICAgICc8JSBpZiAoY29udGVudF9pdGVtLmdldChcImlzX3VucmVzdHJpY3RlZFwiKSkgeyAlPicsXG4gICAgICAgICAgICAgICAgJzxzcGFuIGRhdGEtdG9nZ2xlPVwidG9vbHRpcFwiIGRhdGEtcGxhY2VtZW50PVwidG9wXCIgdGl0bGU9XCJVbnJlc3RyaWN0ZWQgZGF0YXNldFwiIHN0eWxlPVwiY29sb3I6Z3JleTtcIiBjbGFzcz1cImZhIGZhLWdsb2JlIGZhLWxnXCIvPicsXG4gICAgICAgICAgICAgICAgXCI8JSB9ICU+XCIsXG4gICAgICAgICAgICAgICAgJzwlIGlmIChjb250ZW50X2l0ZW0uZ2V0KFwiaXNfcHJpdmF0ZVwiKSkgeyAlPicsXG4gICAgICAgICAgICAgICAgJzxzcGFuIGRhdGEtdG9nZ2xlPVwidG9vbHRpcFwiIGRhdGEtcGxhY2VtZW50PVwidG9wXCIgdGl0bGU9XCJQcml2YXRlIGRhdGFzZXRcIiBzdHlsZT1cImNvbG9yOmdyZXk7XCIgY2xhc3M9XCJmYSBmYS1rZXkgZmEtbGdcIi8+JyxcbiAgICAgICAgICAgICAgICBcIjwlIH0gJT5cIixcbiAgICAgICAgICAgICAgICAnPCUgaWYgKChjb250ZW50X2l0ZW0uZ2V0KFwiaXNfdW5yZXN0cmljdGVkXCIpID09PSBmYWxzZSkgJiYgKGNvbnRlbnRfaXRlbS5nZXQoXCJpc19wcml2YXRlXCIpID09PSBmYWxzZSkpIHsgJT4nLFxuICAgICAgICAgICAgICAgICc8c3BhbiBkYXRhLXRvZ2dsZT1cInRvb2x0aXBcIiBkYXRhLXBsYWNlbWVudD1cInRvcFwiIHRpdGxlPVwiUmVzdHJpY3RlZCBkYXRhc2V0XCIgc3R5bGU9XCJjb2xvcjpncmV5O1wiIGNsYXNzPVwiZmEgZmEtc2hpZWxkIGZhLWxnXCIvPicsXG4gICAgICAgICAgICAgICAgXCI8JSB9ICU+XCIsXG4gICAgICAgICAgICAgICAgJzwlIGlmIChjb250ZW50X2l0ZW0uZ2V0KFwiY2FuX21hbmFnZVwiKSkgeyAlPicsXG4gICAgICAgICAgICAgICAgJzxhIGhyZWY9XCIjZm9sZGVycy88JS0gY29udGVudF9pdGVtLmdldChcImZvbGRlcl9pZFwiKSAlPi9kYXRhc2V0cy88JS0gY29udGVudF9pdGVtLmlkICU+L3Blcm1pc3Npb25zXCI+JyxcbiAgICAgICAgICAgICAgICAnPGJ1dHRvbiBkYXRhLXRvZ2dsZT1cInRvb2x0aXBcIiBkYXRhLXBsYWNlbWVudD1cInRvcFwiIGNsYXNzPVwicHJpbWFyeS1idXR0b24gYnRuLXhzIHBlcm1pc3Npb25zLWRhdGFzZXQtYnRuXCIgdGl0bGU9XCJQZXJtaXNzaW9ucyBvZiBcXCc8JS0gY29udGVudF9pdGVtLmdldChcIm5hbWVcIikgJT5cXCdcIj4nLFxuICAgICAgICAgICAgICAgICc8c3BhbiBjbGFzcz1cImZhIGZhLWdyb3VwXCIvPiBNYW5hZ2UnLFxuICAgICAgICAgICAgICAgIFwiPC9idXR0b24+XCIsXG4gICAgICAgICAgICAgICAgXCI8L2E+XCIsXG4gICAgICAgICAgICAgICAgXCI8JSB9ICU+XCIsXG4gICAgICAgICAgICAgICAgXCI8L3RkPlwiLFxuICAgICAgICAgICAgICAgIFwiPC90cj5cIlxuICAgICAgICAgICAgXS5qb2luKFwiXCIpXG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIHRlbXBsYXRlUm93RGVsZXRlZEZpbGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gXy50ZW1wbGF0ZShcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnPHRyIGNsYXNzPVwiYWN0aXZlIGRlbGV0ZWRfZGF0YXNldCBsaWJyYXJ5LXJvd1wiIGRhdGEtaWQ9XCI8JS0gY29udGVudF9pdGVtLmlkICU+XCI+JyxcbiAgICAgICAgICAgICAgICBcIjx0ZD5cIixcbiAgICAgICAgICAgICAgICAnPHNwYW4gdGl0bGU9XCJEYXRhc2V0XCIgY2xhc3M9XCJmYSBmYS1maWxlLW9cIi8+JyxcbiAgICAgICAgICAgICAgICBcIjwvdGQ+XCIsXG4gICAgICAgICAgICAgICAgXCI8dGQ+PC90ZD5cIixcbiAgICAgICAgICAgICAgICAnPHRkIHN0eWxlPVwiY29sb3I6Z3JleTtcIj4nLFxuICAgICAgICAgICAgICAgICc8JS0gY29udGVudF9pdGVtLmdldChcIm5hbWVcIikgJT4nLFxuICAgICAgICAgICAgICAgIFwiPC90ZD5cIixcbiAgICAgICAgICAgICAgICBcIjx0ZD5cIixcbiAgICAgICAgICAgICAgICAnPCUtIGNvbnRlbnRfaXRlbS5nZXQoXCJtZXNzYWdlXCIpICU+JyxcbiAgICAgICAgICAgICAgICBcIjwvdGQ+XCIsXG4gICAgICAgICAgICAgICAgXCI8dGQ+XCIsXG4gICAgICAgICAgICAgICAgJzwlPSBfLmVzY2FwZShjb250ZW50X2l0ZW0uZ2V0KFwiZmlsZV9leHRcIikpICU+JyxcbiAgICAgICAgICAgICAgICBcIjwvdGQ+XCIsXG4gICAgICAgICAgICAgICAgXCI8dGQ+XCIsXG4gICAgICAgICAgICAgICAgJzwlPSBfLmVzY2FwZShjb250ZW50X2l0ZW0uZ2V0KFwiZmlsZV9zaXplXCIpKSAlPicsXG4gICAgICAgICAgICAgICAgXCI8L3RkPlwiLFxuICAgICAgICAgICAgICAgIFwiPHRkPlwiLFxuICAgICAgICAgICAgICAgICc8JT0gXy5lc2NhcGUoY29udGVudF9pdGVtLmdldChcInVwZGF0ZV90aW1lXCIpKSAlPicsXG4gICAgICAgICAgICAgICAgXCI8L3RkPlwiLFxuICAgICAgICAgICAgICAgIFwiPHRkPlwiLFxuICAgICAgICAgICAgICAgICc8JSBpZiAoIGNvbnRlbnRfaXRlbS5nZXQoXCJzdGF0ZVwiKSAhPT0gXCJva1wiICkgeyAlPicsXG4gICAgICAgICAgICAgICAgJzwlPSBfLmVzY2FwZShjb250ZW50X2l0ZW0uZ2V0KFwic3RhdGVcIikpICU+JyxcbiAgICAgICAgICAgICAgICBcIjwlIH0gJT5cIixcbiAgICAgICAgICAgICAgICBcIjwvdGQ+XCIsXG4gICAgICAgICAgICAgICAgXCI8dGQ+XCIsXG4gICAgICAgICAgICAgICAgJzxzcGFuIGRhdGEtdG9nZ2xlPVwidG9vbHRpcFwiIGRhdGEtcGxhY2VtZW50PVwidG9wXCIgdGl0bGU9XCJNYXJrZWQgZGVsZXRlZFwiIHN0eWxlPVwiY29sb3I6Z3JleTtcIiBjbGFzcz1cImZhIGZhLWJhbiBmYS1sZ1wiLz4nLFxuICAgICAgICAgICAgICAgICc8YnV0dG9uIGRhdGEtdG9nZ2xlPVwidG9vbHRpcFwiIGRhdGEtcGxhY2VtZW50PVwidG9wXCIgdGl0bGU9XCJVbmRlbGV0ZSBcXCc8JS0gY29udGVudF9pdGVtLmdldChcIm5hbWVcIikgJT5cXCdcIiBjbGFzcz1cInByaW1hcnktYnV0dG9uIGJ0bi14cyB1bmRlbGV0ZV9kYXRhc2V0X2J0blwiIHR5cGU9XCJidXR0b25cIiBzdHlsZT1cIm1hcmdpbi1sZWZ0OjFlbTtcIj4nLFxuICAgICAgICAgICAgICAgICc8c3BhbiBjbGFzcz1cImZhIGZhLXVubG9ja1wiLz4gVW5kZWxldGUnLFxuICAgICAgICAgICAgICAgIFwiPC9idXR0b24+XCIsXG4gICAgICAgICAgICAgICAgXCI8L3RkPlwiLFxuICAgICAgICAgICAgICAgIFwiPC90cj5cIlxuICAgICAgICAgICAgXS5qb2luKFwiXCIpXG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIHRlbXBsYXRlUm93RGVsZXRlZEZvbGRlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfLnRlbXBsYXRlKFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICc8dHIgY2xhc3M9XCJhY3RpdmUgZGVsZXRlZF9mb2xkZXIgbGlnaHQgbGlicmFyeS1yb3dcIiBkYXRhLWlkPVwiPCUtIGNvbnRlbnRfaXRlbS5pZCAlPlwiPicsXG4gICAgICAgICAgICAgICAgXCI8dGQ+XCIsXG4gICAgICAgICAgICAgICAgJzxzcGFuIHRpdGxlPVwiRm9sZGVyXCIgY2xhc3M9XCJmYSBmYS1mb2xkZXItb1wiLz4nLFxuICAgICAgICAgICAgICAgIFwiPC90ZD5cIixcbiAgICAgICAgICAgICAgICBcIjx0ZD48L3RkPlwiLFxuICAgICAgICAgICAgICAgICc8dGQgc3R5bGU9XCJjb2xvcjpncmV5O1wiPicsXG4gICAgICAgICAgICAgICAgJzwlLSBjb250ZW50X2l0ZW0uZ2V0KFwibmFtZVwiKSAlPicsXG4gICAgICAgICAgICAgICAgXCI8L3RkPlwiLFxuICAgICAgICAgICAgICAgIFwiPHRkPlwiLFxuICAgICAgICAgICAgICAgICc8JS0gY29udGVudF9pdGVtLmdldChcImRlc2NyaXB0aW9uXCIpICU+JyxcbiAgICAgICAgICAgICAgICBcIjwvdGQ+XCIsXG4gICAgICAgICAgICAgICAgXCI8dGQ+XCIsXG4gICAgICAgICAgICAgICAgXCJmb2xkZXJcIixcbiAgICAgICAgICAgICAgICBcIjwvdGQ+XCIsXG4gICAgICAgICAgICAgICAgXCI8dGQ+PC90ZD5cIixcbiAgICAgICAgICAgICAgICBcIjx0ZD5cIixcbiAgICAgICAgICAgICAgICAnPCU9IF8uZXNjYXBlKGNvbnRlbnRfaXRlbS5nZXQoXCJ1cGRhdGVfdGltZVwiKSkgJT4nLFxuICAgICAgICAgICAgICAgIFwiPC90ZD5cIixcbiAgICAgICAgICAgICAgICBcIjx0ZD48L3RkPlwiLFxuICAgICAgICAgICAgICAgIFwiPHRkPlwiLFxuICAgICAgICAgICAgICAgICc8c3BhbiBkYXRhLXRvZ2dsZT1cInRvb2x0aXBcIiBkYXRhLXBsYWNlbWVudD1cInRvcFwiIHRpdGxlPVwiTWFya2VkIGRlbGV0ZWRcIiBzdHlsZT1cImNvbG9yOmdyZXk7XCIgY2xhc3M9XCJmYSBmYS1iYW4gZmEtbGdcIi8+JyxcbiAgICAgICAgICAgICAgICAnPGJ1dHRvbiBkYXRhLXRvZ2dsZT1cInRvb2x0aXBcIiBkYXRhLXBsYWNlbWVudD1cInRvcFwiIHRpdGxlPVwiVW5kZWxldGUgXFwnPCUtIGNvbnRlbnRfaXRlbS5nZXQoXCJuYW1lXCIpICU+XFwnXCIgY2xhc3M9XCJwcmltYXJ5LWJ1dHRvbiBidG4teHMgdW5kZWxldGVfZm9sZGVyX2J0blwiIHR5cGU9XCJidXR0b25cIiBzdHlsZT1cIm1hcmdpbi1sZWZ0OjFlbTtcIj4nLFxuICAgICAgICAgICAgICAgICc8c3BhbiBjbGFzcz1cImZhIGZhLXVubG9ja1wiLz4gVW5kZWxldGUnLFxuICAgICAgICAgICAgICAgIFwiPC9idXR0b24+XCIsXG4gICAgICAgICAgICAgICAgXCI8L3RkPlwiLFxuICAgICAgICAgICAgICAgIFwiPC90cj5cIlxuICAgICAgICAgICAgXS5qb2luKFwiXCIpXG4gICAgICAgICk7XG4gICAgfVxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgICBGb2xkZXJSb3dWaWV3OiBGb2xkZXJSb3dWaWV3XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGdhbGF4eS9zY3JpcHRzL212Yy9saWJyYXJ5L2xpYnJhcnktZm9sZGVycm93LXZpZXcuanMiXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7OztBQUFBO0FBQ0E7OztBQUFBO0FBQ0E7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBUkE7QUFDQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUhBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFuQkE7QUFxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBZEE7QUFnQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBYkE7QUFlQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUEwQkE7QUFPQTtBQVNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUE0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFvQ0E7QUFDQTtBQUNBO0FBQ0E7QUE4QkE7QUExWUE7QUFDQTtBQTRZQTtBQUNBO0FBREE7QSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///299\n");

/***/ }),

/***/ 300:
/*!****************************************************************!*\
  !*** ./galaxy/scripts/mvc/library/library-librarylist-view.js ***!
  \****************************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(Backbone, $) {\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _toastr = __webpack_require__(/*! libs/toastr */ 7);\n\nvar _toastr2 = _interopRequireDefault(_toastr);\n\nvar _libraryModel = __webpack_require__(/*! mvc/library/library-model */ 13);\n\nvar _libraryModel2 = _interopRequireDefault(_libraryModel);\n\nvar _libraryLibraryrowView = __webpack_require__(/*! mvc/library/library-libraryrow-view */ 301);\n\nvar _libraryLibraryrowView2 = _interopRequireDefault(_libraryLibraryrowView);\n\nvar _underscore = __webpack_require__(/*! libs/underscore */ 1);\n\nvar _underscore2 = _interopRequireDefault(_underscore);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar LibraryListView = Backbone.View.extend({\n    el: \"#libraries_element\",\n\n    events: {\n        \"click .sort-libraries-link\": \"sort_clicked\"\n    },\n\n    defaults: {\n        page_count: null,\n        show_page: null,\n        all_fetched: false\n    },\n\n    /**\n     * Initialize and fetch the libraries from server.\n     * Async render afterwards.\n     * @param  {object} options an object with options\n     */\n    initialize: function initialize(options) {\n        this.options = _underscore2.default.defaults(this.options || {}, options, this.defaults);\n        var that = this;\n        this.modal = null;\n        // collection of {Item}s\n        this.collection = new _libraryModel2.default.Libraries();\n        this.collection.url = this.collection.urlRoot + \"?deleted=false\";\n        this.collection.fetch({\n            success: function success() {\n                that.render();\n            },\n            error: function error(model, response) {\n                if (typeof response.responseJSON !== \"undefined\") {\n                    _toastr2.default.error(response.responseJSON.err_msg);\n                } else {\n                    _toastr2.default.error(\"An error occurred.\");\n                }\n            }\n        });\n    },\n\n    /**\n     * Render the libraries table either from the object's own collection,\n     * or from a given array of library models,\n     * or render an empty list in case no data is given.\n     */\n    render: function render(options) {\n        this.options = _underscore2.default.extend(this.options, options);\n        this.setElement(\"#libraries_element\");\n        var template = this.templateLibraryList();\n        var libraries_to_render = null;\n        var models = null;\n        var is_public = function is_public(model) {\n            return model.get(\"public\") === true;\n        };\n        $(\".tooltip\").hide();\n        if (typeof options !== \"undefined\") {\n            models = typeof options.models !== \"undefined\" ? options.models : null;\n        }\n        if (this.collection !== null && models === null) {\n            this.sortLibraries();\n            if (Galaxy.libraries.preferences.get(\"with_deleted\")) {\n                libraries_to_render = this.collection.models;\n            } else {\n                libraries_to_render = this.collection.where({\n                    deleted: false\n                });\n            }\n            if (Galaxy.libraries.preferences.get(\"without_restricted\")) {\n                libraries_to_render = _underscore2.default.filter(libraries_to_render, is_public);\n            }\n        } else if (models !== null) {\n            if (Galaxy.libraries.preferences.get(\"with_deleted\")) {\n                libraries_to_render = models;\n            } else {\n                var is_deleted = function is_deleted(model) {\n                    return model.get(\"deleted\") === false;\n                };\n                libraries_to_render = _underscore2.default.filter(models, is_deleted);\n            }\n            if (Galaxy.libraries.preferences.get(\"without_restricted\")) {\n                libraries_to_render = _underscore2.default.filter(libraries_to_render, is_public);\n            }\n        } else {\n            libraries_to_render = [];\n        }\n\n        // pagination\n        if (this.options.show_page === null || this.options.show_page < 1) {\n            this.options.show_page = 1;\n        }\n        this.options.total_libraries_count = libraries_to_render.length;\n        var page_start = Galaxy.libraries.preferences.get(\"library_page_size\") * (this.options.show_page - 1);\n        this.options.page_count = Math.ceil(this.options.total_libraries_count / Galaxy.libraries.preferences.get(\"library_page_size\"));\n        if (this.options.total_libraries_count > 0 && page_start < this.options.total_libraries_count) {\n            libraries_to_render = libraries_to_render.slice(page_start, page_start + Galaxy.libraries.preferences.get(\"library_page_size\"));\n            this.options.libraries_shown = libraries_to_render.length;\n            // User requests page with no libraries\n            if (Galaxy.libraries.preferences.get(\"library_page_size\") * this.options.show_page > this.options.total_libraries_count + Galaxy.libraries.preferences.get(\"library_page_size\")) {\n                libraries_to_render = [];\n            }\n            this.$el.html(template({\n                length: 1,\n                order: Galaxy.libraries.preferences.get(\"sort_order\"),\n                search_term: Galaxy.libraries.libraryToolbarView.options.search_term\n            }));\n            Galaxy.libraries.libraryToolbarView.renderPaginator(this.options);\n            this.renderRows(libraries_to_render);\n        } else {\n            this.$el.html(template({\n                length: 0,\n                order: Galaxy.libraries.preferences.get(\"sort_order\"),\n                search_term: Galaxy.libraries.libraryToolbarView.options.search_term\n            }));\n            Galaxy.libraries.libraryToolbarView.renderPaginator(this.options);\n        }\n        $(\"#center [data-toggle]\").tooltip();\n        $(\"#center\").css(\"overflow\", \"auto\");\n    },\n\n    fetchDeleted: function fetchDeleted() {\n        if (this.options.all_fetched) {\n            this.render();\n        } else {\n            var that = this;\n            this.collection.url = this.collection.urlRoot + \"?deleted=true\";\n            this.collection.fetch({\n                remove: false,\n                success: function success() {\n                    that.options.all_fetched = true;\n                    that.render();\n                },\n                error: function error(model, response) {\n                    if (typeof response.responseJSON !== \"undefined\") {\n                        _toastr2.default.error(response.responseJSON.err_msg);\n                    } else {\n                        _toastr2.default.error(\"An error occurred.\");\n                    }\n                }\n            });\n        }\n    },\n\n    /**\n     * Render all given models as rows in the library list\n     * @param  {array} libraries_to_render array of library models to render\n     */\n    renderRows: function renderRows(libraries_to_render) {\n        for (var i = 0; i < libraries_to_render.length; i++) {\n            var library = libraries_to_render[i];\n            this.renderOne({ library: library });\n        }\n    },\n\n    /**\n     * Create a view for the given model and add it to the libraries view.\n     * @param {Library} model of the view that will be rendered\n     */\n    renderOne: function renderOne(options) {\n        var library = options.library;\n        var rowView = new _libraryLibraryrowView2.default.LibraryRowView(library);\n        this.$el.find(\"#library_list_body\").append(rowView.el);\n    },\n\n    /**\n     * Table heading was clicked, update sorting preferences and re-render.\n     * @return {[type]} [description]\n     */\n    sort_clicked: function sort_clicked() {\n        if (Galaxy.libraries.preferences.get(\"sort_order\") === \"asc\") {\n            Galaxy.libraries.preferences.set({ sort_order: \"desc\" });\n        } else {\n            Galaxy.libraries.preferences.set({ sort_order: \"asc\" });\n        }\n        this.render();\n    },\n\n    /**\n     * Sort the underlying collection according to the parameters received.\n     * Currently supports only sorting by name.\n     */\n    sortLibraries: function sortLibraries() {\n        if (Galaxy.libraries.preferences.get(\"sort_by\") === \"name\") {\n            if (Galaxy.libraries.preferences.get(\"sort_order\") === \"asc\") {\n                this.collection.sortLibraries(\"name\", \"asc\");\n            } else if (Galaxy.libraries.preferences.get(\"sort_order\") === \"desc\") {\n                this.collection.sortLibraries(\"name\", \"desc\");\n            }\n        }\n    },\n\n    /**\n     * In case the search_term is not empty perform the search and render\n     * the result. Render all visible libraries otherwise.\n     * @param  {string} search_term string to search for\n     */\n    searchLibraries: function searchLibraries(search_term) {\n        var trimmed_term = $.trim(search_term);\n        if (trimmed_term !== \"\") {\n            var results = null;\n            results = this.collection.search(search_term);\n            this.options.searching = true;\n            this.render({ models: results, show_page: 1 });\n        } else {\n            this.options.searching = false;\n            this.render();\n        }\n    },\n\n    // MMMMMMMMMMMMMMMMMM\n    // === TEMPLATES ====\n    // MMMMMMMMMMMMMMMMMM\n\n    templateLibraryList: function templateLibraryList() {\n        return _underscore2.default.template(['<div class=\"library_container table-responsive\">', \"<% if(length === 0) { %>\", \"<% if(search_term.length > 0) { %>\", \"<div>\", \"There are no libraries matching your search. Try different keyword.\", \"</div>\", \"<% } else{ %>\", \"<div>\", \"There are no libraries visible to you here. If you expected some to show up please consult the\", ' <a href=\"https://galaxyproject.org/data-libraries/#permissions\" target=\"_blank\">library security wikipage</a>', ' or visit the <a href=\"https://biostar.usegalaxy.org/\" target=\"_blank\">Galaxy support site</a>.', \"</div>\", \"<% }%>\", \"<% } else{ %>\", '<table class=\"grid table table-condensed\">', \"<thead>\", '<th style=\"width:30%;\">', '<a class=\"sort-libraries-link\" title=\"Click to reverse order\" href=\"#\">', \"name\", \"</a>\", '<span title=\"Sorted alphabetically\" class=\"fa fa-sort-alpha-<%- order %>\"/>', \"</th>\", '<th style=\"width:22%;\">description</th>', '<th style=\"width:22%;\">synopsis</th> ', '<th style=\"width:26%;\"></th>', \"</thead>\", '<tbody id=\"library_list_body\">',\n        // library item views will attach here\n        \"</tbody>\", \"</table>\", \"<% }%>\", \"</div>\"].join(\"\"));\n    }\n});\n\nexports.default = {\n    LibraryListView: LibraryListView\n};\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! libs/backbone */ 2), __webpack_require__(/*! jquery */ 0)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzAwLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL2dhbGF4eS9zY3JpcHRzL212Yy9saWJyYXJ5L2xpYnJhcnktbGlicmFyeWxpc3Qtdmlldy5qcz8wOWFiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBtb2RfdG9hc3RyIGZyb20gXCJsaWJzL3RvYXN0clwiO1xuaW1wb3J0IG1vZF9saWJyYXJ5X21vZGVsIGZyb20gXCJtdmMvbGlicmFyeS9saWJyYXJ5LW1vZGVsXCI7XG5pbXBvcnQgbW9kX2xpYnJhcnlfbGlicmFyeXJvd192aWV3IGZyb20gXCJtdmMvbGlicmFyeS9saWJyYXJ5LWxpYnJhcnlyb3ctdmlld1wiO1xuaW1wb3J0IF8gZnJvbSBcImxpYnMvdW5kZXJzY29yZVwiO1xudmFyIExpYnJhcnlMaXN0VmlldyA9IEJhY2tib25lLlZpZXcuZXh0ZW5kKHtcbiAgICBlbDogXCIjbGlicmFyaWVzX2VsZW1lbnRcIixcblxuICAgIGV2ZW50czoge1xuICAgICAgICBcImNsaWNrIC5zb3J0LWxpYnJhcmllcy1saW5rXCI6IFwic29ydF9jbGlja2VkXCJcbiAgICB9LFxuXG4gICAgZGVmYXVsdHM6IHtcbiAgICAgICAgcGFnZV9jb3VudDogbnVsbCxcbiAgICAgICAgc2hvd19wYWdlOiBudWxsLFxuICAgICAgICBhbGxfZmV0Y2hlZDogZmFsc2VcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSBhbmQgZmV0Y2ggdGhlIGxpYnJhcmllcyBmcm9tIHNlcnZlci5cbiAgICAgKiBBc3luYyByZW5kZXIgYWZ0ZXJ3YXJkcy5cbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9IG9wdGlvbnMgYW4gb2JqZWN0IHdpdGggb3B0aW9uc1xuICAgICAqL1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gXy5kZWZhdWx0cyh0aGlzLm9wdGlvbnMgfHwge30sIG9wdGlvbnMsIHRoaXMuZGVmYXVsdHMpO1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgIHRoaXMubW9kYWwgPSBudWxsO1xuICAgICAgICAvLyBjb2xsZWN0aW9uIG9mIHtJdGVtfXNcbiAgICAgICAgdGhpcy5jb2xsZWN0aW9uID0gbmV3IG1vZF9saWJyYXJ5X21vZGVsLkxpYnJhcmllcygpO1xuICAgICAgICB0aGlzLmNvbGxlY3Rpb24udXJsID0gYCR7dGhpcy5jb2xsZWN0aW9uLnVybFJvb3R9P2RlbGV0ZWQ9ZmFsc2VgO1xuICAgICAgICB0aGlzLmNvbGxlY3Rpb24uZmV0Y2goe1xuICAgICAgICAgICAgc3VjY2VzczogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdGhhdC5yZW5kZXIoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlcnJvcjogZnVuY3Rpb24obW9kZWwsIHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByZXNwb25zZS5yZXNwb25zZUpTT04gIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgbW9kX3RvYXN0ci5lcnJvcihyZXNwb25zZS5yZXNwb25zZUpTT04uZXJyX21zZyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbW9kX3RvYXN0ci5lcnJvcihcIkFuIGVycm9yIG9jY3VycmVkLlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgdGhlIGxpYnJhcmllcyB0YWJsZSBlaXRoZXIgZnJvbSB0aGUgb2JqZWN0J3Mgb3duIGNvbGxlY3Rpb24sXG4gICAgICogb3IgZnJvbSBhIGdpdmVuIGFycmF5IG9mIGxpYnJhcnkgbW9kZWxzLFxuICAgICAqIG9yIHJlbmRlciBhbiBlbXB0eSBsaXN0IGluIGNhc2Ugbm8gZGF0YSBpcyBnaXZlbi5cbiAgICAgKi9cbiAgICByZW5kZXI6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gXy5leHRlbmQodGhpcy5vcHRpb25zLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5zZXRFbGVtZW50KFwiI2xpYnJhcmllc19lbGVtZW50XCIpO1xuICAgICAgICB2YXIgdGVtcGxhdGUgPSB0aGlzLnRlbXBsYXRlTGlicmFyeUxpc3QoKTtcbiAgICAgICAgdmFyIGxpYnJhcmllc190b19yZW5kZXIgPSBudWxsO1xuICAgICAgICB2YXIgbW9kZWxzID0gbnVsbDtcbiAgICAgICAgdmFyIGlzX3B1YmxpYyA9IG1vZGVsID0+IG1vZGVsLmdldChcInB1YmxpY1wiKSA9PT0gdHJ1ZTtcbiAgICAgICAgJChcIi50b29sdGlwXCIpLmhpZGUoKTtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICBtb2RlbHMgPSB0eXBlb2Ygb3B0aW9ucy5tb2RlbHMgIT09IFwidW5kZWZpbmVkXCIgPyBvcHRpb25zLm1vZGVscyA6IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY29sbGVjdGlvbiAhPT0gbnVsbCAmJiBtb2RlbHMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuc29ydExpYnJhcmllcygpO1xuICAgICAgICAgICAgaWYgKEdhbGF4eS5saWJyYXJpZXMucHJlZmVyZW5jZXMuZ2V0KFwid2l0aF9kZWxldGVkXCIpKSB7XG4gICAgICAgICAgICAgICAgbGlicmFyaWVzX3RvX3JlbmRlciA9IHRoaXMuY29sbGVjdGlvbi5tb2RlbHM7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxpYnJhcmllc190b19yZW5kZXIgPSB0aGlzLmNvbGxlY3Rpb24ud2hlcmUoe1xuICAgICAgICAgICAgICAgICAgICBkZWxldGVkOiBmYWxzZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKEdhbGF4eS5saWJyYXJpZXMucHJlZmVyZW5jZXMuZ2V0KFwid2l0aG91dF9yZXN0cmljdGVkXCIpKSB7XG4gICAgICAgICAgICAgICAgbGlicmFyaWVzX3RvX3JlbmRlciA9IF8uZmlsdGVyKGxpYnJhcmllc190b19yZW5kZXIsIGlzX3B1YmxpYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobW9kZWxzICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoR2FsYXh5LmxpYnJhcmllcy5wcmVmZXJlbmNlcy5nZXQoXCJ3aXRoX2RlbGV0ZWRcIikpIHtcbiAgICAgICAgICAgICAgICBsaWJyYXJpZXNfdG9fcmVuZGVyID0gbW9kZWxzO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgaXNfZGVsZXRlZCA9IG1vZGVsID0+IG1vZGVsLmdldChcImRlbGV0ZWRcIikgPT09IGZhbHNlO1xuICAgICAgICAgICAgICAgIGxpYnJhcmllc190b19yZW5kZXIgPSBfLmZpbHRlcihtb2RlbHMsIGlzX2RlbGV0ZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKEdhbGF4eS5saWJyYXJpZXMucHJlZmVyZW5jZXMuZ2V0KFwid2l0aG91dF9yZXN0cmljdGVkXCIpKSB7XG4gICAgICAgICAgICAgICAgbGlicmFyaWVzX3RvX3JlbmRlciA9IF8uZmlsdGVyKGxpYnJhcmllc190b19yZW5kZXIsIGlzX3B1YmxpYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsaWJyYXJpZXNfdG9fcmVuZGVyID0gW107XG4gICAgICAgIH1cblxuICAgICAgICAvLyBwYWdpbmF0aW9uXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2hvd19wYWdlID09PSBudWxsIHx8IHRoaXMub3B0aW9ucy5zaG93X3BhZ2UgPCAxKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuc2hvd19wYWdlID0gMTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9wdGlvbnMudG90YWxfbGlicmFyaWVzX2NvdW50ID0gbGlicmFyaWVzX3RvX3JlbmRlci5sZW5ndGg7XG4gICAgICAgIHZhciBwYWdlX3N0YXJ0ID0gR2FsYXh5LmxpYnJhcmllcy5wcmVmZXJlbmNlcy5nZXQoXCJsaWJyYXJ5X3BhZ2Vfc2l6ZVwiKSAqICh0aGlzLm9wdGlvbnMuc2hvd19wYWdlIC0gMSk7XG4gICAgICAgIHRoaXMub3B0aW9ucy5wYWdlX2NvdW50ID0gTWF0aC5jZWlsKFxuICAgICAgICAgICAgdGhpcy5vcHRpb25zLnRvdGFsX2xpYnJhcmllc19jb3VudCAvIEdhbGF4eS5saWJyYXJpZXMucHJlZmVyZW5jZXMuZ2V0KFwibGlicmFyeV9wYWdlX3NpemVcIilcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy50b3RhbF9saWJyYXJpZXNfY291bnQgPiAwICYmIHBhZ2Vfc3RhcnQgPCB0aGlzLm9wdGlvbnMudG90YWxfbGlicmFyaWVzX2NvdW50KSB7XG4gICAgICAgICAgICBsaWJyYXJpZXNfdG9fcmVuZGVyID0gbGlicmFyaWVzX3RvX3JlbmRlci5zbGljZShcbiAgICAgICAgICAgICAgICBwYWdlX3N0YXJ0LFxuICAgICAgICAgICAgICAgIHBhZ2Vfc3RhcnQgKyBHYWxheHkubGlicmFyaWVzLnByZWZlcmVuY2VzLmdldChcImxpYnJhcnlfcGFnZV9zaXplXCIpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLmxpYnJhcmllc19zaG93biA9IGxpYnJhcmllc190b19yZW5kZXIubGVuZ3RoO1xuICAgICAgICAgICAgLy8gVXNlciByZXF1ZXN0cyBwYWdlIHdpdGggbm8gbGlicmFyaWVzXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgR2FsYXh5LmxpYnJhcmllcy5wcmVmZXJlbmNlcy5nZXQoXCJsaWJyYXJ5X3BhZ2Vfc2l6ZVwiKSAqIHRoaXMub3B0aW9ucy5zaG93X3BhZ2UgPlxuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy50b3RhbF9saWJyYXJpZXNfY291bnQgKyBHYWxheHkubGlicmFyaWVzLnByZWZlcmVuY2VzLmdldChcImxpYnJhcnlfcGFnZV9zaXplXCIpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBsaWJyYXJpZXNfdG9fcmVuZGVyID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLiRlbC5odG1sKFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlKHtcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoOiAxLFxuICAgICAgICAgICAgICAgICAgICBvcmRlcjogR2FsYXh5LmxpYnJhcmllcy5wcmVmZXJlbmNlcy5nZXQoXCJzb3J0X29yZGVyXCIpLFxuICAgICAgICAgICAgICAgICAgICBzZWFyY2hfdGVybTogR2FsYXh5LmxpYnJhcmllcy5saWJyYXJ5VG9vbGJhclZpZXcub3B0aW9ucy5zZWFyY2hfdGVybVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgR2FsYXh5LmxpYnJhcmllcy5saWJyYXJ5VG9vbGJhclZpZXcucmVuZGVyUGFnaW5hdG9yKHRoaXMub3B0aW9ucyk7XG4gICAgICAgICAgICB0aGlzLnJlbmRlclJvd3MobGlicmFyaWVzX3RvX3JlbmRlcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLiRlbC5odG1sKFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlKHtcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoOiAwLFxuICAgICAgICAgICAgICAgICAgICBvcmRlcjogR2FsYXh5LmxpYnJhcmllcy5wcmVmZXJlbmNlcy5nZXQoXCJzb3J0X29yZGVyXCIpLFxuICAgICAgICAgICAgICAgICAgICBzZWFyY2hfdGVybTogR2FsYXh5LmxpYnJhcmllcy5saWJyYXJ5VG9vbGJhclZpZXcub3B0aW9ucy5zZWFyY2hfdGVybVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgR2FsYXh5LmxpYnJhcmllcy5saWJyYXJ5VG9vbGJhclZpZXcucmVuZGVyUGFnaW5hdG9yKHRoaXMub3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgJChcIiNjZW50ZXIgW2RhdGEtdG9nZ2xlXVwiKS50b29sdGlwKCk7XG4gICAgICAgICQoXCIjY2VudGVyXCIpLmNzcyhcIm92ZXJmbG93XCIsIFwiYXV0b1wiKTtcbiAgICB9LFxuXG4gICAgZmV0Y2hEZWxldGVkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5hbGxfZmV0Y2hlZCkge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuY29sbGVjdGlvbi51cmwgPSBgJHt0aGlzLmNvbGxlY3Rpb24udXJsUm9vdH0/ZGVsZXRlZD10cnVlYDtcbiAgICAgICAgICAgIHRoaXMuY29sbGVjdGlvbi5mZXRjaCh7XG4gICAgICAgICAgICAgICAgcmVtb3ZlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5vcHRpb25zLmFsbF9mZXRjaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5yZW5kZXIoKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGVycm9yOiBmdW5jdGlvbihtb2RlbCwgcmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByZXNwb25zZS5yZXNwb25zZUpTT04gIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZF90b2FzdHIuZXJyb3IocmVzcG9uc2UucmVzcG9uc2VKU09OLmVycl9tc2cpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9kX3RvYXN0ci5lcnJvcihcIkFuIGVycm9yIG9jY3VycmVkLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlciBhbGwgZ2l2ZW4gbW9kZWxzIGFzIHJvd3MgaW4gdGhlIGxpYnJhcnkgbGlzdFxuICAgICAqIEBwYXJhbSAge2FycmF5fSBsaWJyYXJpZXNfdG9fcmVuZGVyIGFycmF5IG9mIGxpYnJhcnkgbW9kZWxzIHRvIHJlbmRlclxuICAgICAqL1xuICAgIHJlbmRlclJvd3M6IGZ1bmN0aW9uKGxpYnJhcmllc190b19yZW5kZXIpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaWJyYXJpZXNfdG9fcmVuZGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbGlicmFyeSA9IGxpYnJhcmllc190b19yZW5kZXJbaV07XG4gICAgICAgICAgICB0aGlzLnJlbmRlck9uZSh7IGxpYnJhcnk6IGxpYnJhcnkgfSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgdmlldyBmb3IgdGhlIGdpdmVuIG1vZGVsIGFuZCBhZGQgaXQgdG8gdGhlIGxpYnJhcmllcyB2aWV3LlxuICAgICAqIEBwYXJhbSB7TGlicmFyeX0gbW9kZWwgb2YgdGhlIHZpZXcgdGhhdCB3aWxsIGJlIHJlbmRlcmVkXG4gICAgICovXG4gICAgcmVuZGVyT25lOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHZhciBsaWJyYXJ5ID0gb3B0aW9ucy5saWJyYXJ5O1xuICAgICAgICB2YXIgcm93VmlldyA9IG5ldyBtb2RfbGlicmFyeV9saWJyYXJ5cm93X3ZpZXcuTGlicmFyeVJvd1ZpZXcobGlicmFyeSk7XG4gICAgICAgIHRoaXMuJGVsLmZpbmQoXCIjbGlicmFyeV9saXN0X2JvZHlcIikuYXBwZW5kKHJvd1ZpZXcuZWwpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUYWJsZSBoZWFkaW5nIHdhcyBjbGlja2VkLCB1cGRhdGUgc29ydGluZyBwcmVmZXJlbmNlcyBhbmQgcmUtcmVuZGVyLlxuICAgICAqIEByZXR1cm4ge1t0eXBlXX0gW2Rlc2NyaXB0aW9uXVxuICAgICAqL1xuICAgIHNvcnRfY2xpY2tlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChHYWxheHkubGlicmFyaWVzLnByZWZlcmVuY2VzLmdldChcInNvcnRfb3JkZXJcIikgPT09IFwiYXNjXCIpIHtcbiAgICAgICAgICAgIEdhbGF4eS5saWJyYXJpZXMucHJlZmVyZW5jZXMuc2V0KHsgc29ydF9vcmRlcjogXCJkZXNjXCIgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBHYWxheHkubGlicmFyaWVzLnByZWZlcmVuY2VzLnNldCh7IHNvcnRfb3JkZXI6IFwiYXNjXCIgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU29ydCB0aGUgdW5kZXJseWluZyBjb2xsZWN0aW9uIGFjY29yZGluZyB0byB0aGUgcGFyYW1ldGVycyByZWNlaXZlZC5cbiAgICAgKiBDdXJyZW50bHkgc3VwcG9ydHMgb25seSBzb3J0aW5nIGJ5IG5hbWUuXG4gICAgICovXG4gICAgc29ydExpYnJhcmllczogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChHYWxheHkubGlicmFyaWVzLnByZWZlcmVuY2VzLmdldChcInNvcnRfYnlcIikgPT09IFwibmFtZVwiKSB7XG4gICAgICAgICAgICBpZiAoR2FsYXh5LmxpYnJhcmllcy5wcmVmZXJlbmNlcy5nZXQoXCJzb3J0X29yZGVyXCIpID09PSBcImFzY1wiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb2xsZWN0aW9uLnNvcnRMaWJyYXJpZXMoXCJuYW1lXCIsIFwiYXNjXCIpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChHYWxheHkubGlicmFyaWVzLnByZWZlcmVuY2VzLmdldChcInNvcnRfb3JkZXJcIikgPT09IFwiZGVzY1wiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb2xsZWN0aW9uLnNvcnRMaWJyYXJpZXMoXCJuYW1lXCIsIFwiZGVzY1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJbiBjYXNlIHRoZSBzZWFyY2hfdGVybSBpcyBub3QgZW1wdHkgcGVyZm9ybSB0aGUgc2VhcmNoIGFuZCByZW5kZXJcbiAgICAgKiB0aGUgcmVzdWx0LiBSZW5kZXIgYWxsIHZpc2libGUgbGlicmFyaWVzIG90aGVyd2lzZS5cbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IHNlYXJjaF90ZXJtIHN0cmluZyB0byBzZWFyY2ggZm9yXG4gICAgICovXG4gICAgc2VhcmNoTGlicmFyaWVzOiBmdW5jdGlvbihzZWFyY2hfdGVybSkge1xuICAgICAgICB2YXIgdHJpbW1lZF90ZXJtID0gJC50cmltKHNlYXJjaF90ZXJtKTtcbiAgICAgICAgaWYgKHRyaW1tZWRfdGVybSAhPT0gXCJcIikge1xuICAgICAgICAgICAgdmFyIHJlc3VsdHMgPSBudWxsO1xuICAgICAgICAgICAgcmVzdWx0cyA9IHRoaXMuY29sbGVjdGlvbi5zZWFyY2goc2VhcmNoX3Rlcm0pO1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLnNlYXJjaGluZyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcih7IG1vZGVsczogcmVzdWx0cywgc2hvd19wYWdlOiAxIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLnNlYXJjaGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyBNTU1NTU1NTU1NTU1NTU1NTU1cbiAgICAvLyA9PT0gVEVNUExBVEVTID09PT1cbiAgICAvLyBNTU1NTU1NTU1NTU1NTU1NTU1cblxuICAgIHRlbXBsYXRlTGlicmFyeUxpc3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gXy50ZW1wbGF0ZShcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnPGRpdiBjbGFzcz1cImxpYnJhcnlfY29udGFpbmVyIHRhYmxlLXJlc3BvbnNpdmVcIj4nLFxuICAgICAgICAgICAgICAgIFwiPCUgaWYobGVuZ3RoID09PSAwKSB7ICU+XCIsXG4gICAgICAgICAgICAgICAgXCI8JSBpZihzZWFyY2hfdGVybS5sZW5ndGggPiAwKSB7ICU+XCIsXG4gICAgICAgICAgICAgICAgXCI8ZGl2PlwiLFxuICAgICAgICAgICAgICAgIFwiVGhlcmUgYXJlIG5vIGxpYnJhcmllcyBtYXRjaGluZyB5b3VyIHNlYXJjaC4gVHJ5IGRpZmZlcmVudCBrZXl3b3JkLlwiLFxuICAgICAgICAgICAgICAgIFwiPC9kaXY+XCIsXG4gICAgICAgICAgICAgICAgXCI8JSB9IGVsc2V7ICU+XCIsXG4gICAgICAgICAgICAgICAgXCI8ZGl2PlwiLFxuICAgICAgICAgICAgICAgIFwiVGhlcmUgYXJlIG5vIGxpYnJhcmllcyB2aXNpYmxlIHRvIHlvdSBoZXJlLiBJZiB5b3UgZXhwZWN0ZWQgc29tZSB0byBzaG93IHVwIHBsZWFzZSBjb25zdWx0IHRoZVwiLFxuICAgICAgICAgICAgICAgICcgPGEgaHJlZj1cImh0dHBzOi8vZ2FsYXh5cHJvamVjdC5vcmcvZGF0YS1saWJyYXJpZXMvI3Blcm1pc3Npb25zXCIgdGFyZ2V0PVwiX2JsYW5rXCI+bGlicmFyeSBzZWN1cml0eSB3aWtpcGFnZTwvYT4nLFxuICAgICAgICAgICAgICAgICcgb3IgdmlzaXQgdGhlIDxhIGhyZWY9XCJodHRwczovL2Jpb3N0YXIudXNlZ2FsYXh5Lm9yZy9cIiB0YXJnZXQ9XCJfYmxhbmtcIj5HYWxheHkgc3VwcG9ydCBzaXRlPC9hPi4nLFxuICAgICAgICAgICAgICAgIFwiPC9kaXY+XCIsXG4gICAgICAgICAgICAgICAgXCI8JSB9JT5cIixcbiAgICAgICAgICAgICAgICBcIjwlIH0gZWxzZXsgJT5cIixcbiAgICAgICAgICAgICAgICAnPHRhYmxlIGNsYXNzPVwiZ3JpZCB0YWJsZSB0YWJsZS1jb25kZW5zZWRcIj4nLFxuICAgICAgICAgICAgICAgIFwiPHRoZWFkPlwiLFxuICAgICAgICAgICAgICAgICc8dGggc3R5bGU9XCJ3aWR0aDozMCU7XCI+JyxcbiAgICAgICAgICAgICAgICAnPGEgY2xhc3M9XCJzb3J0LWxpYnJhcmllcy1saW5rXCIgdGl0bGU9XCJDbGljayB0byByZXZlcnNlIG9yZGVyXCIgaHJlZj1cIiNcIj4nLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiLFxuICAgICAgICAgICAgICAgIFwiPC9hPlwiLFxuICAgICAgICAgICAgICAgICc8c3BhbiB0aXRsZT1cIlNvcnRlZCBhbHBoYWJldGljYWxseVwiIGNsYXNzPVwiZmEgZmEtc29ydC1hbHBoYS08JS0gb3JkZXIgJT5cIi8+JyxcbiAgICAgICAgICAgICAgICBcIjwvdGg+XCIsXG4gICAgICAgICAgICAgICAgJzx0aCBzdHlsZT1cIndpZHRoOjIyJTtcIj5kZXNjcmlwdGlvbjwvdGg+JyxcbiAgICAgICAgICAgICAgICAnPHRoIHN0eWxlPVwid2lkdGg6MjIlO1wiPnN5bm9wc2lzPC90aD4gJyxcbiAgICAgICAgICAgICAgICAnPHRoIHN0eWxlPVwid2lkdGg6MjYlO1wiPjwvdGg+JyxcbiAgICAgICAgICAgICAgICBcIjwvdGhlYWQ+XCIsXG4gICAgICAgICAgICAgICAgJzx0Ym9keSBpZD1cImxpYnJhcnlfbGlzdF9ib2R5XCI+JyxcbiAgICAgICAgICAgICAgICAvLyBsaWJyYXJ5IGl0ZW0gdmlld3Mgd2lsbCBhdHRhY2ggaGVyZVxuICAgICAgICAgICAgICAgIFwiPC90Ym9keT5cIixcbiAgICAgICAgICAgICAgICBcIjwvdGFibGU+XCIsXG4gICAgICAgICAgICAgICAgXCI8JSB9JT5cIixcbiAgICAgICAgICAgICAgICBcIjwvZGl2PlwiXG4gICAgICAgICAgICBdLmpvaW4oXCJcIilcbiAgICAgICAgKTtcbiAgICB9XG59KTtcblxuZXhwb3J0IGRlZmF1bHQge1xuICAgIExpYnJhcnlMaXN0VmlldzogTGlicmFyeUxpc3RWaWV3XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGdhbGF4eS9zY3JpcHRzL212Yy9saWJyYXJ5L2xpYnJhcnktbGlicmFyeWxpc3Qtdmlldy5qcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTs7O0FBQUE7QUFDQTs7O0FBQUE7QUFDQTs7O0FBQUE7QUFDQTs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFDQTtBQUtBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVZBO0FBWUE7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFIQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBSEE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVpBO0FBY0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUE2QkE7QUFDQTtBQU1BO0FBaFFBO0FBQ0E7QUFrUUE7QUFDQTtBQURBO0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///300\n");

/***/ }),

/***/ 301:
/*!***************************************************************!*\
  !*** ./galaxy/scripts/mvc/library/library-libraryrow-view.js ***!
  \***************************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(Backbone, $, _) {\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _toastr = __webpack_require__(/*! libs/toastr */ 7);\n\nvar _toastr2 = _interopRequireDefault(_toastr);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// galaxy library row view\nvar LibraryRowView = Backbone.View.extend({\n    events: {\n        \"click .edit_library_btn\": \"edit_button_clicked\",\n        \"click .cancel_library_btn\": \"cancel_library_modification\",\n        \"click .save_library_btn\": \"save_library_modification\",\n        \"click .delete_library_btn\": \"delete_library\",\n        \"click .undelete_library_btn\": \"undelete_library\"\n    },\n\n    edit_mode: false,\n\n    element_visibility_config: {\n        upload_library_btn: false,\n        edit_library_btn: false,\n        permission_library_btn: false,\n        save_library_btn: false,\n        cancel_library_btn: false,\n        delete_library_btn: false,\n        undelete_library_btn: false\n    },\n\n    initialize: function initialize(library) {\n        this.render(library);\n    },\n\n    render: function render(library) {\n        if (typeof library === \"undefined\") {\n            library = Galaxy.libraries.libraryListView.collection.get(this.$el.data(\"id\"));\n        }\n        this.prepareButtons(library);\n        var tmpl = this.templateRow();\n        this.setElement(tmpl({\n            library: library,\n            button_config: this.element_visibility_config,\n            edit_mode: this.edit_mode\n        }));\n        this.$el.show();\n        return this;\n    },\n\n    repaint: function repaint(library) {\n        /* need to hide manually because of the element removal in setElement\n        invoked in render() */\n        $(\".tooltip\").hide();\n        /* we need to store the old element to be able to replace it with\n        new one */\n        var old_element = this.$el;\n        /* if user canceled the library param is undefined,\n        if user saved and succeeded the updated library is rendered */\n        this.render();\n        old_element.replaceWith(this.$el);\n        /* now we attach new tooltips to the newly created row element */\n        this.$el.find(\"[data-toggle]\").tooltip();\n    },\n\n    /**\n     * Function modifies the visibility of buttons for\n     * the filling of the row template of given library.\n     */\n    prepareButtons: function prepareButtons(library) {\n        var vis_config = this.element_visibility_config;\n\n        if (this.edit_mode === false) {\n            vis_config.save_library_btn = false;\n            vis_config.cancel_library_btn = false;\n            vis_config.delete_library_btn = false;\n            if (library.get(\"deleted\") === true) {\n                vis_config.undelete_library_btn = true;\n                vis_config.upload_library_btn = false;\n                vis_config.edit_library_btn = false;\n                vis_config.permission_library_btn = false;\n            } else if (library.get(\"deleted\") === false) {\n                vis_config.save_library_btn = false;\n                vis_config.cancel_library_btn = false;\n                vis_config.undelete_library_btn = false;\n                if (library.get(\"can_user_add\") === true) {\n                    vis_config.upload_library_btn = true;\n                }\n                if (library.get(\"can_user_modify\") === true) {\n                    vis_config.edit_library_btn = true;\n                }\n                if (library.get(\"can_user_manage\") === true) {\n                    vis_config.permission_library_btn = true;\n                }\n            }\n        } else if (this.edit_mode === true) {\n            vis_config.upload_library_btn = false;\n            vis_config.edit_library_btn = false;\n            vis_config.permission_library_btn = false;\n            vis_config.save_library_btn = true;\n            vis_config.cancel_library_btn = true;\n            vis_config.delete_library_btn = true;\n            vis_config.undelete_library_btn = false;\n        }\n\n        this.element_visibility_config = vis_config;\n    },\n\n    /* User clicked the 'edit' button on row so we render a new row\n    that allows editing */\n    edit_button_clicked: function edit_button_clicked() {\n        this.edit_mode = true;\n        this.repaint();\n    },\n\n    /* User clicked the 'cancel' button so we render normal rowView */\n    cancel_library_modification: function cancel_library_modification() {\n        // mod_toastr.info('Modifications canceled');\n        this.edit_mode = false;\n        this.repaint();\n    },\n\n    save_library_modification: function save_library_modification() {\n        var library = Galaxy.libraries.libraryListView.collection.get(this.$el.data(\"id\"));\n        var is_changed = false;\n\n        var new_name = this.$el.find(\".input_library_name\").val();\n        if (typeof new_name !== \"undefined\" && new_name !== library.get(\"name\")) {\n            if (new_name.length > 2) {\n                library.set(\"name\", new_name);\n                is_changed = true;\n            } else {\n                _toastr2.default.warning(\"Library name has to be at least 3 characters long.\");\n                return;\n            }\n        }\n\n        var new_description = this.$el.find(\".input_library_description\").val();\n        if (typeof new_description !== \"undefined\" && new_description !== library.get(\"description\")) {\n            library.set(\"description\", new_description);\n            is_changed = true;\n        }\n\n        var new_synopsis = this.$el.find(\".input_library_synopsis\").val();\n        if (typeof new_synopsis !== \"undefined\" && new_synopsis !== library.get(\"synopsis\")) {\n            library.set(\"synopsis\", new_synopsis);\n            is_changed = true;\n        }\n\n        if (is_changed) {\n            var row_view = this;\n            library.save(null, {\n                patch: true,\n                success: function success(library) {\n                    row_view.edit_mode = false;\n                    row_view.repaint(library);\n                    _toastr2.default.success(\"Changes to library saved.\");\n                },\n                error: function error(model, response) {\n                    if (typeof response.responseJSON !== \"undefined\") {\n                        _toastr2.default.error(response.responseJSON.err_msg);\n                    } else {\n                        _toastr2.default.error(\"An error occured while attempting to update the library.\");\n                    }\n                }\n            });\n        } else {\n            this.edit_mode = false;\n            this.repaint(library);\n            _toastr2.default.info(\"Nothing has changed.\");\n        }\n    },\n\n    delete_library: function delete_library() {\n        var library = Galaxy.libraries.libraryListView.collection.get(this.$el.data(\"id\"));\n        var row_view = this;\n        // mark the library deleted\n        library.destroy({\n            success: function success(library) {\n                library.set(\"deleted\", true);\n                // add the new deleted library back to the collection (Galaxy specialty)\n                Galaxy.libraries.libraryListView.collection.add(library);\n                row_view.edit_mode = false;\n                if (Galaxy.libraries.preferences.get(\"with_deleted\") === false) {\n                    $(\".tooltip\").hide();\n                    row_view.repaint(library);\n                    row_view.$el.remove();\n                } else if (Galaxy.libraries.preferences.get(\"with_deleted\") === true) {\n                    row_view.repaint(library);\n                }\n                _toastr2.default.success(\"Library has been marked deleted.\");\n            },\n            error: function error(model, response) {\n                if (typeof response.responseJSON !== \"undefined\") {\n                    _toastr2.default.error(response.responseJSON.err_msg);\n                } else {\n                    _toastr2.default.error(\"An error occured during deleting the library.\");\n                }\n            }\n        });\n    },\n\n    undelete_library: function undelete_library() {\n        var library = Galaxy.libraries.libraryListView.collection.get(this.$el.data(\"id\"));\n        var row_view = this;\n\n        // mark the library undeleted\n        library.url = library.urlRoot + library.id + \"?undelete=true\";\n        library.destroy({\n            success: function success(library) {\n                // add the newly undeleted library back to the collection\n                // backbone does not accept changes through destroy, so update it too\n                library.set(\"deleted\", false);\n                Galaxy.libraries.libraryListView.collection.add(library);\n                row_view.edit_mode = false;\n                row_view.repaint(library);\n                _toastr2.default.success(\"Library has been undeleted.\");\n            },\n            error: function error(model, response) {\n                if (typeof response.responseJSON !== \"undefined\") {\n                    _toastr2.default.error(response.responseJSON.err_msg);\n                } else {\n                    _toastr2.default.error(\"An error occured while undeleting the library.\");\n                }\n            }\n        });\n    },\n\n    templateRow: function templateRow() {\n        return _.template(['<tr class=\"<% if(library.get(\"deleted\") === true) { print(\"active\") } %>\" style=\"display:none;\" data-id=\"<%- library.get(\"id\") %>\">', \"<% if(!edit_mode) { %>\", '<% if(library.get(\"deleted\")) { %>', '<td style=\"color:grey;\"><%- library.get(\"name\") %></td>', \"<% } else { %>\", '<td><a href=\"#folders/<%- library.get(\"root_folder_id\") %>\"><%- library.get(\"name\") %></a></td>', \"<% } %>\", '<% if(library.get(\"description\")) { %>', '<% if( (library.get(\"description\")).length> 80 ) { %>', '<td data-toggle=\"tooltip\" data-placement=\"bottom\" title=\"<%= _.escape(library.get(\"description\")) %>\"><%= _.escape(library.get(\"description\")).substring(0, 80) + \"...\" %></td>', \"<% } else { %>\", '<td><%= _.escape(library.get(\"description\"))%></td>', \"<% } %>\", \"<% } else { %>\", \"<td></td>\", \"<% } %>\", '<% if(library.get(\"synopsis\")) { %>', '<% if( (library.get(\"synopsis\")).length> 120 ) { %>', '<td data-toggle=\"tooltip\" data-placement=\"bottom\" title=\"<%= _.escape(library.get(\"synopsis\")) %>\"><%= _.escape(library.get(\"synopsis\")).substring(0, 120) + \"...\" %></td>', \"<% } else { %>\", '<td><%= _.escape(library.get(\"synopsis\"))%></td>', \"<% } %>\", \"<% } else { %>\", \"<td></td>\", \"<% } %>\", \"<% } else if(edit_mode){ %>\", '<td><textarea rows=\"4\" class=\"form-control input_library_name\" placeholder=\"name\" ><%- library.get(\"name\") %></textarea></td>', '<td><textarea rows=\"4\" class=\"form-control input_library_description\" placeholder=\"description\" ><%- library.get(\"description\") %></textarea></td>', '<td><textarea rows=\"4\" class=\"form-control input_library_synopsis\" placeholder=\"synopsis\" ><%- library.get(\"synopsis\") %></textarea></td>', \"<% } %>\", '<td class=\"right-center\">', '<% if( (library.get(\"public\")) && (library.get(\"deleted\") === false) ) { %>', '<span data-toggle=\"tooltip\" data-placement=\"top\" title=\"Unrestricted library\" style=\"color:grey;\" class=\"fa fa-globe fa-lg\"> </span>', \"<% }%>\", '<button data-toggle=\"tooltip\" data-placement=\"top\" title=\"Modify \\'<%- library.get(\"name\") %>\\'\" class=\"primary-button btn-xs edit_library_btn\" type=\"button\" style=\"<% if(button_config.edit_library_btn === false) { print(\"display:none;\") } %>\"><span class=\"fa fa-pencil\"></span> Edit</button>', '<a href=\"#library/<%- library.get(\"id\") %>/permissions\"><button data-toggle=\"tooltip\" data-placement=\"top\" title=\"Permissions of \\'<%- library.get(\"name\") %>\\'\" class=\"primary-button btn-xs permission_library_btn\" type=\"button\" style=\"<% if(button_config.permission_library_btn === false) { print(\"display:none;\") } %>\"><span class=\"fa fa-group\"></span> Manage</button></a>', '<button data-toggle=\"tooltip\" data-placement=\"top\" title=\"Save changes\" class=\"primary-button btn-xs save_library_btn\" type=\"button\" style=\"<% if(button_config.save_library_btn === false) { print(\"display:none;\") } %>\"><span class=\"fa fa-floppy-o\"></span> Save</button>', '<button data-toggle=\"tooltip\" data-placement=\"top\" title=\"Discard changes\" class=\"primary-button btn-xs cancel_library_btn\" type=\"button\" style=\"<% if(button_config.cancel_library_btn === false) { print(\"display:none;\") } %>\"><span class=\"fa fa-times\"></span> Cancel</button>', '<button data-toggle=\"tooltip\" data-placement=\"top\" title=\"Delete \\'<%- library.get(\"name\") %>\\'\" class=\"primary-button btn-xs delete_library_btn\" type=\"button\" style=\"<% if(button_config.delete_library_btn === false) { print(\"display:none;\") } %>\"><span class=\"fa fa-trash-o\"></span> Delete</button>',\n        // For deleted libraries\n        '<span data-toggle=\"tooltip\" data-placement=\"top\" title=\"Marked deleted\" style=\"color:grey; <% if(button_config.undelete_library_btn === false) { print(\"display:none;\") } %>\" class=\"fa fa-ban fa-lg\"></span>', '<button data-toggle=\"tooltip\" data-placement=\"top\" title=\"Undelete \\'<%- library.get(\"name\") %>\\' \" class=\"primary-button btn-xs undelete_library_btn\" type=\"button\" style=\"<% if(button_config.undelete_library_btn === false) { print(\"display:none;\") } %>\"><span class=\"fa fa-unlock\"></span> Undelete</button>', \"</td>\", \"</tr>\"].join(\"\"));\n    }\n}); // dependencies\nexports.default = {\n    LibraryRowView: LibraryRowView\n};\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! libs/backbone */ 2), __webpack_require__(/*! jquery */ 0), __webpack_require__(/*! underscore */ 1)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzAxLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL2dhbGF4eS9zY3JpcHRzL212Yy9saWJyYXJ5L2xpYnJhcnktbGlicmFyeXJvdy12aWV3LmpzPzA1MTIiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gZGVwZW5kZW5jaWVzXG5pbXBvcnQgbW9kX3RvYXN0ciBmcm9tIFwibGlicy90b2FzdHJcIjtcbi8vIGdhbGF4eSBsaWJyYXJ5IHJvdyB2aWV3XG52YXIgTGlicmFyeVJvd1ZpZXcgPSBCYWNrYm9uZS5WaWV3LmV4dGVuZCh7XG4gICAgZXZlbnRzOiB7XG4gICAgICAgIFwiY2xpY2sgLmVkaXRfbGlicmFyeV9idG5cIjogXCJlZGl0X2J1dHRvbl9jbGlja2VkXCIsXG4gICAgICAgIFwiY2xpY2sgLmNhbmNlbF9saWJyYXJ5X2J0blwiOiBcImNhbmNlbF9saWJyYXJ5X21vZGlmaWNhdGlvblwiLFxuICAgICAgICBcImNsaWNrIC5zYXZlX2xpYnJhcnlfYnRuXCI6IFwic2F2ZV9saWJyYXJ5X21vZGlmaWNhdGlvblwiLFxuICAgICAgICBcImNsaWNrIC5kZWxldGVfbGlicmFyeV9idG5cIjogXCJkZWxldGVfbGlicmFyeVwiLFxuICAgICAgICBcImNsaWNrIC51bmRlbGV0ZV9saWJyYXJ5X2J0blwiOiBcInVuZGVsZXRlX2xpYnJhcnlcIlxuICAgIH0sXG5cbiAgICBlZGl0X21vZGU6IGZhbHNlLFxuXG4gICAgZWxlbWVudF92aXNpYmlsaXR5X2NvbmZpZzoge1xuICAgICAgICB1cGxvYWRfbGlicmFyeV9idG46IGZhbHNlLFxuICAgICAgICBlZGl0X2xpYnJhcnlfYnRuOiBmYWxzZSxcbiAgICAgICAgcGVybWlzc2lvbl9saWJyYXJ5X2J0bjogZmFsc2UsXG4gICAgICAgIHNhdmVfbGlicmFyeV9idG46IGZhbHNlLFxuICAgICAgICBjYW5jZWxfbGlicmFyeV9idG46IGZhbHNlLFxuICAgICAgICBkZWxldGVfbGlicmFyeV9idG46IGZhbHNlLFxuICAgICAgICB1bmRlbGV0ZV9saWJyYXJ5X2J0bjogZmFsc2VcbiAgICB9LFxuXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24obGlicmFyeSkge1xuICAgICAgICB0aGlzLnJlbmRlcihsaWJyYXJ5KTtcbiAgICB9LFxuXG4gICAgcmVuZGVyOiBmdW5jdGlvbihsaWJyYXJ5KSB7XG4gICAgICAgIGlmICh0eXBlb2YgbGlicmFyeSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgbGlicmFyeSA9IEdhbGF4eS5saWJyYXJpZXMubGlicmFyeUxpc3RWaWV3LmNvbGxlY3Rpb24uZ2V0KHRoaXMuJGVsLmRhdGEoXCJpZFwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcmVwYXJlQnV0dG9ucyhsaWJyYXJ5KTtcbiAgICAgICAgdmFyIHRtcGwgPSB0aGlzLnRlbXBsYXRlUm93KCk7XG4gICAgICAgIHRoaXMuc2V0RWxlbWVudChcbiAgICAgICAgICAgIHRtcGwoe1xuICAgICAgICAgICAgICAgIGxpYnJhcnk6IGxpYnJhcnksXG4gICAgICAgICAgICAgICAgYnV0dG9uX2NvbmZpZzogdGhpcy5lbGVtZW50X3Zpc2liaWxpdHlfY29uZmlnLFxuICAgICAgICAgICAgICAgIGVkaXRfbW9kZTogdGhpcy5lZGl0X21vZGVcbiAgICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuJGVsLnNob3coKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHJlcGFpbnQ6IGZ1bmN0aW9uKGxpYnJhcnkpIHtcbiAgICAgICAgLyogbmVlZCB0byBoaWRlIG1hbnVhbGx5IGJlY2F1c2Ugb2YgdGhlIGVsZW1lbnQgcmVtb3ZhbCBpbiBzZXRFbGVtZW50XG4gICAgaW52b2tlZCBpbiByZW5kZXIoKSAqL1xuICAgICAgICAkKFwiLnRvb2x0aXBcIikuaGlkZSgpO1xuICAgICAgICAvKiB3ZSBuZWVkIHRvIHN0b3JlIHRoZSBvbGQgZWxlbWVudCB0byBiZSBhYmxlIHRvIHJlcGxhY2UgaXQgd2l0aFxuICAgIG5ldyBvbmUgKi9cbiAgICAgICAgdmFyIG9sZF9lbGVtZW50ID0gdGhpcy4kZWw7XG4gICAgICAgIC8qIGlmIHVzZXIgY2FuY2VsZWQgdGhlIGxpYnJhcnkgcGFyYW0gaXMgdW5kZWZpbmVkLFxuICAgICAgaWYgdXNlciBzYXZlZCBhbmQgc3VjY2VlZGVkIHRoZSB1cGRhdGVkIGxpYnJhcnkgaXMgcmVuZGVyZWQgKi9cbiAgICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICAgICAgb2xkX2VsZW1lbnQucmVwbGFjZVdpdGgodGhpcy4kZWwpO1xuICAgICAgICAvKiBub3cgd2UgYXR0YWNoIG5ldyB0b29sdGlwcyB0byB0aGUgbmV3bHkgY3JlYXRlZCByb3cgZWxlbWVudCAqL1xuICAgICAgICB0aGlzLiRlbC5maW5kKFwiW2RhdGEtdG9nZ2xlXVwiKS50b29sdGlwKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIG1vZGlmaWVzIHRoZSB2aXNpYmlsaXR5IG9mIGJ1dHRvbnMgZm9yXG4gICAgICogdGhlIGZpbGxpbmcgb2YgdGhlIHJvdyB0ZW1wbGF0ZSBvZiBnaXZlbiBsaWJyYXJ5LlxuICAgICAqL1xuICAgIHByZXBhcmVCdXR0b25zOiBmdW5jdGlvbihsaWJyYXJ5KSB7XG4gICAgICAgIHZhciB2aXNfY29uZmlnID0gdGhpcy5lbGVtZW50X3Zpc2liaWxpdHlfY29uZmlnO1xuXG4gICAgICAgIGlmICh0aGlzLmVkaXRfbW9kZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHZpc19jb25maWcuc2F2ZV9saWJyYXJ5X2J0biA9IGZhbHNlO1xuICAgICAgICAgICAgdmlzX2NvbmZpZy5jYW5jZWxfbGlicmFyeV9idG4gPSBmYWxzZTtcbiAgICAgICAgICAgIHZpc19jb25maWcuZGVsZXRlX2xpYnJhcnlfYnRuID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAobGlicmFyeS5nZXQoXCJkZWxldGVkXCIpID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgdmlzX2NvbmZpZy51bmRlbGV0ZV9saWJyYXJ5X2J0biA9IHRydWU7XG4gICAgICAgICAgICAgICAgdmlzX2NvbmZpZy51cGxvYWRfbGlicmFyeV9idG4gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB2aXNfY29uZmlnLmVkaXRfbGlicmFyeV9idG4gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB2aXNfY29uZmlnLnBlcm1pc3Npb25fbGlicmFyeV9idG4gPSBmYWxzZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobGlicmFyeS5nZXQoXCJkZWxldGVkXCIpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHZpc19jb25maWcuc2F2ZV9saWJyYXJ5X2J0biA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHZpc19jb25maWcuY2FuY2VsX2xpYnJhcnlfYnRuID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdmlzX2NvbmZpZy51bmRlbGV0ZV9saWJyYXJ5X2J0biA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmIChsaWJyYXJ5LmdldChcImNhbl91c2VyX2FkZFwiKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICB2aXNfY29uZmlnLnVwbG9hZF9saWJyYXJ5X2J0biA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChsaWJyYXJ5LmdldChcImNhbl91c2VyX21vZGlmeVwiKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICB2aXNfY29uZmlnLmVkaXRfbGlicmFyeV9idG4gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobGlicmFyeS5nZXQoXCJjYW5fdXNlcl9tYW5hZ2VcIikgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmlzX2NvbmZpZy5wZXJtaXNzaW9uX2xpYnJhcnlfYnRuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5lZGl0X21vZGUgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHZpc19jb25maWcudXBsb2FkX2xpYnJhcnlfYnRuID0gZmFsc2U7XG4gICAgICAgICAgICB2aXNfY29uZmlnLmVkaXRfbGlicmFyeV9idG4gPSBmYWxzZTtcbiAgICAgICAgICAgIHZpc19jb25maWcucGVybWlzc2lvbl9saWJyYXJ5X2J0biA9IGZhbHNlO1xuICAgICAgICAgICAgdmlzX2NvbmZpZy5zYXZlX2xpYnJhcnlfYnRuID0gdHJ1ZTtcbiAgICAgICAgICAgIHZpc19jb25maWcuY2FuY2VsX2xpYnJhcnlfYnRuID0gdHJ1ZTtcbiAgICAgICAgICAgIHZpc19jb25maWcuZGVsZXRlX2xpYnJhcnlfYnRuID0gdHJ1ZTtcbiAgICAgICAgICAgIHZpc19jb25maWcudW5kZWxldGVfbGlicmFyeV9idG4gPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZWxlbWVudF92aXNpYmlsaXR5X2NvbmZpZyA9IHZpc19jb25maWc7XG4gICAgfSxcblxuICAgIC8qIFVzZXIgY2xpY2tlZCB0aGUgJ2VkaXQnIGJ1dHRvbiBvbiByb3cgc28gd2UgcmVuZGVyIGEgbmV3IHJvd1xuICAgIHRoYXQgYWxsb3dzIGVkaXRpbmcgKi9cbiAgICBlZGl0X2J1dHRvbl9jbGlja2VkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5lZGl0X21vZGUgPSB0cnVlO1xuICAgICAgICB0aGlzLnJlcGFpbnQoKTtcbiAgICB9LFxuXG4gICAgLyogVXNlciBjbGlja2VkIHRoZSAnY2FuY2VsJyBidXR0b24gc28gd2UgcmVuZGVyIG5vcm1hbCByb3dWaWV3ICovXG4gICAgY2FuY2VsX2xpYnJhcnlfbW9kaWZpY2F0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gbW9kX3RvYXN0ci5pbmZvKCdNb2RpZmljYXRpb25zIGNhbmNlbGVkJyk7XG4gICAgICAgIHRoaXMuZWRpdF9tb2RlID0gZmFsc2U7XG4gICAgICAgIHRoaXMucmVwYWludCgpO1xuICAgIH0sXG5cbiAgICBzYXZlX2xpYnJhcnlfbW9kaWZpY2F0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGxpYnJhcnkgPSBHYWxheHkubGlicmFyaWVzLmxpYnJhcnlMaXN0Vmlldy5jb2xsZWN0aW9uLmdldCh0aGlzLiRlbC5kYXRhKFwiaWRcIikpO1xuICAgICAgICB2YXIgaXNfY2hhbmdlZCA9IGZhbHNlO1xuXG4gICAgICAgIHZhciBuZXdfbmFtZSA9IHRoaXMuJGVsLmZpbmQoXCIuaW5wdXRfbGlicmFyeV9uYW1lXCIpLnZhbCgpO1xuICAgICAgICBpZiAodHlwZW9mIG5ld19uYW1lICE9PSBcInVuZGVmaW5lZFwiICYmIG5ld19uYW1lICE9PSBsaWJyYXJ5LmdldChcIm5hbWVcIikpIHtcbiAgICAgICAgICAgIGlmIChuZXdfbmFtZS5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICAgICAgbGlicmFyeS5zZXQoXCJuYW1lXCIsIG5ld19uYW1lKTtcbiAgICAgICAgICAgICAgICBpc19jaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbW9kX3RvYXN0ci53YXJuaW5nKFwiTGlicmFyeSBuYW1lIGhhcyB0byBiZSBhdCBsZWFzdCAzIGNoYXJhY3RlcnMgbG9uZy5cIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG5ld19kZXNjcmlwdGlvbiA9IHRoaXMuJGVsLmZpbmQoXCIuaW5wdXRfbGlicmFyeV9kZXNjcmlwdGlvblwiKS52YWwoKTtcbiAgICAgICAgaWYgKHR5cGVvZiBuZXdfZGVzY3JpcHRpb24gIT09IFwidW5kZWZpbmVkXCIgJiYgbmV3X2Rlc2NyaXB0aW9uICE9PSBsaWJyYXJ5LmdldChcImRlc2NyaXB0aW9uXCIpKSB7XG4gICAgICAgICAgICBsaWJyYXJ5LnNldChcImRlc2NyaXB0aW9uXCIsIG5ld19kZXNjcmlwdGlvbik7XG4gICAgICAgICAgICBpc19jaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBuZXdfc3lub3BzaXMgPSB0aGlzLiRlbC5maW5kKFwiLmlucHV0X2xpYnJhcnlfc3lub3BzaXNcIikudmFsKCk7XG4gICAgICAgIGlmICh0eXBlb2YgbmV3X3N5bm9wc2lzICE9PSBcInVuZGVmaW5lZFwiICYmIG5ld19zeW5vcHNpcyAhPT0gbGlicmFyeS5nZXQoXCJzeW5vcHNpc1wiKSkge1xuICAgICAgICAgICAgbGlicmFyeS5zZXQoXCJzeW5vcHNpc1wiLCBuZXdfc3lub3BzaXMpO1xuICAgICAgICAgICAgaXNfY2hhbmdlZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNfY2hhbmdlZCkge1xuICAgICAgICAgICAgdmFyIHJvd192aWV3ID0gdGhpcztcbiAgICAgICAgICAgIGxpYnJhcnkuc2F2ZShudWxsLCB7XG4gICAgICAgICAgICAgICAgcGF0Y2g6IHRydWUsXG4gICAgICAgICAgICAgICAgc3VjY2VzczogZnVuY3Rpb24obGlicmFyeSkge1xuICAgICAgICAgICAgICAgICAgICByb3dfdmlldy5lZGl0X21vZGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgcm93X3ZpZXcucmVwYWludChsaWJyYXJ5KTtcbiAgICAgICAgICAgICAgICAgICAgbW9kX3RvYXN0ci5zdWNjZXNzKFwiQ2hhbmdlcyB0byBsaWJyYXJ5IHNhdmVkLlwiKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGVycm9yOiBmdW5jdGlvbihtb2RlbCwgcmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByZXNwb25zZS5yZXNwb25zZUpTT04gIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZF90b2FzdHIuZXJyb3IocmVzcG9uc2UucmVzcG9uc2VKU09OLmVycl9tc2cpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9kX3RvYXN0ci5lcnJvcihcIkFuIGVycm9yIG9jY3VyZWQgd2hpbGUgYXR0ZW1wdGluZyB0byB1cGRhdGUgdGhlIGxpYnJhcnkuXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmVkaXRfbW9kZSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5yZXBhaW50KGxpYnJhcnkpO1xuICAgICAgICAgICAgbW9kX3RvYXN0ci5pbmZvKFwiTm90aGluZyBoYXMgY2hhbmdlZC5cIik7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZGVsZXRlX2xpYnJhcnk6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbGlicmFyeSA9IEdhbGF4eS5saWJyYXJpZXMubGlicmFyeUxpc3RWaWV3LmNvbGxlY3Rpb24uZ2V0KHRoaXMuJGVsLmRhdGEoXCJpZFwiKSk7XG4gICAgICAgIHZhciByb3dfdmlldyA9IHRoaXM7XG4gICAgICAgIC8vIG1hcmsgdGhlIGxpYnJhcnkgZGVsZXRlZFxuICAgICAgICBsaWJyYXJ5LmRlc3Ryb3koe1xuICAgICAgICAgICAgc3VjY2VzczogZnVuY3Rpb24obGlicmFyeSkge1xuICAgICAgICAgICAgICAgIGxpYnJhcnkuc2V0KFwiZGVsZXRlZFwiLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAvLyBhZGQgdGhlIG5ldyBkZWxldGVkIGxpYnJhcnkgYmFjayB0byB0aGUgY29sbGVjdGlvbiAoR2FsYXh5IHNwZWNpYWx0eSlcbiAgICAgICAgICAgICAgICBHYWxheHkubGlicmFyaWVzLmxpYnJhcnlMaXN0Vmlldy5jb2xsZWN0aW9uLmFkZChsaWJyYXJ5KTtcbiAgICAgICAgICAgICAgICByb3dfdmlldy5lZGl0X21vZGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAoR2FsYXh5LmxpYnJhcmllcy5wcmVmZXJlbmNlcy5nZXQoXCJ3aXRoX2RlbGV0ZWRcIikgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICQoXCIudG9vbHRpcFwiKS5oaWRlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJvd192aWV3LnJlcGFpbnQobGlicmFyeSk7XG4gICAgICAgICAgICAgICAgICAgIHJvd192aWV3LiRlbC5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKEdhbGF4eS5saWJyYXJpZXMucHJlZmVyZW5jZXMuZ2V0KFwid2l0aF9kZWxldGVkXCIpID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvd192aWV3LnJlcGFpbnQobGlicmFyeSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1vZF90b2FzdHIuc3VjY2VzcyhcIkxpYnJhcnkgaGFzIGJlZW4gbWFya2VkIGRlbGV0ZWQuXCIpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVycm9yOiBmdW5jdGlvbihtb2RlbCwgcmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJlc3BvbnNlLnJlc3BvbnNlSlNPTiAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgICAgICBtb2RfdG9hc3RyLmVycm9yKHJlc3BvbnNlLnJlc3BvbnNlSlNPTi5lcnJfbXNnKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtb2RfdG9hc3RyLmVycm9yKFwiQW4gZXJyb3Igb2NjdXJlZCBkdXJpbmcgZGVsZXRpbmcgdGhlIGxpYnJhcnkuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIHVuZGVsZXRlX2xpYnJhcnk6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbGlicmFyeSA9IEdhbGF4eS5saWJyYXJpZXMubGlicmFyeUxpc3RWaWV3LmNvbGxlY3Rpb24uZ2V0KHRoaXMuJGVsLmRhdGEoXCJpZFwiKSk7XG4gICAgICAgIHZhciByb3dfdmlldyA9IHRoaXM7XG5cbiAgICAgICAgLy8gbWFyayB0aGUgbGlicmFyeSB1bmRlbGV0ZWRcbiAgICAgICAgbGlicmFyeS51cmwgPSBgJHtsaWJyYXJ5LnVybFJvb3QgKyBsaWJyYXJ5LmlkfT91bmRlbGV0ZT10cnVlYDtcbiAgICAgICAgbGlicmFyeS5kZXN0cm95KHtcbiAgICAgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uKGxpYnJhcnkpIHtcbiAgICAgICAgICAgICAgICAvLyBhZGQgdGhlIG5ld2x5IHVuZGVsZXRlZCBsaWJyYXJ5IGJhY2sgdG8gdGhlIGNvbGxlY3Rpb25cbiAgICAgICAgICAgICAgICAvLyBiYWNrYm9uZSBkb2VzIG5vdCBhY2NlcHQgY2hhbmdlcyB0aHJvdWdoIGRlc3Ryb3ksIHNvIHVwZGF0ZSBpdCB0b29cbiAgICAgICAgICAgICAgICBsaWJyYXJ5LnNldChcImRlbGV0ZWRcIiwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIEdhbGF4eS5saWJyYXJpZXMubGlicmFyeUxpc3RWaWV3LmNvbGxlY3Rpb24uYWRkKGxpYnJhcnkpO1xuICAgICAgICAgICAgICAgIHJvd192aWV3LmVkaXRfbW9kZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJvd192aWV3LnJlcGFpbnQobGlicmFyeSk7XG4gICAgICAgICAgICAgICAgbW9kX3RvYXN0ci5zdWNjZXNzKFwiTGlicmFyeSBoYXMgYmVlbiB1bmRlbGV0ZWQuXCIpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVycm9yOiBmdW5jdGlvbihtb2RlbCwgcmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJlc3BvbnNlLnJlc3BvbnNlSlNPTiAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgICAgICBtb2RfdG9hc3RyLmVycm9yKHJlc3BvbnNlLnJlc3BvbnNlSlNPTi5lcnJfbXNnKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtb2RfdG9hc3RyLmVycm9yKFwiQW4gZXJyb3Igb2NjdXJlZCB3aGlsZSB1bmRlbGV0aW5nIHRoZSBsaWJyYXJ5LlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICB0ZW1wbGF0ZVJvdzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfLnRlbXBsYXRlKFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICc8dHIgY2xhc3M9XCI8JSBpZihsaWJyYXJ5LmdldChcImRlbGV0ZWRcIikgPT09IHRydWUpIHsgcHJpbnQoXCJhY3RpdmVcIikgfSAlPlwiIHN0eWxlPVwiZGlzcGxheTpub25lO1wiIGRhdGEtaWQ9XCI8JS0gbGlicmFyeS5nZXQoXCJpZFwiKSAlPlwiPicsXG4gICAgICAgICAgICAgICAgXCI8JSBpZighZWRpdF9tb2RlKSB7ICU+XCIsXG4gICAgICAgICAgICAgICAgJzwlIGlmKGxpYnJhcnkuZ2V0KFwiZGVsZXRlZFwiKSkgeyAlPicsXG4gICAgICAgICAgICAgICAgJzx0ZCBzdHlsZT1cImNvbG9yOmdyZXk7XCI+PCUtIGxpYnJhcnkuZ2V0KFwibmFtZVwiKSAlPjwvdGQ+JyxcbiAgICAgICAgICAgICAgICBcIjwlIH0gZWxzZSB7ICU+XCIsXG4gICAgICAgICAgICAgICAgJzx0ZD48YSBocmVmPVwiI2ZvbGRlcnMvPCUtIGxpYnJhcnkuZ2V0KFwicm9vdF9mb2xkZXJfaWRcIikgJT5cIj48JS0gbGlicmFyeS5nZXQoXCJuYW1lXCIpICU+PC9hPjwvdGQ+JyxcbiAgICAgICAgICAgICAgICBcIjwlIH0gJT5cIixcbiAgICAgICAgICAgICAgICAnPCUgaWYobGlicmFyeS5nZXQoXCJkZXNjcmlwdGlvblwiKSkgeyAlPicsXG4gICAgICAgICAgICAgICAgJzwlIGlmKCAobGlicmFyeS5nZXQoXCJkZXNjcmlwdGlvblwiKSkubGVuZ3RoPiA4MCApIHsgJT4nLFxuICAgICAgICAgICAgICAgICc8dGQgZGF0YS10b2dnbGU9XCJ0b29sdGlwXCIgZGF0YS1wbGFjZW1lbnQ9XCJib3R0b21cIiB0aXRsZT1cIjwlPSBfLmVzY2FwZShsaWJyYXJ5LmdldChcImRlc2NyaXB0aW9uXCIpKSAlPlwiPjwlPSBfLmVzY2FwZShsaWJyYXJ5LmdldChcImRlc2NyaXB0aW9uXCIpKS5zdWJzdHJpbmcoMCwgODApICsgXCIuLi5cIiAlPjwvdGQ+JyxcbiAgICAgICAgICAgICAgICBcIjwlIH0gZWxzZSB7ICU+XCIsXG4gICAgICAgICAgICAgICAgJzx0ZD48JT0gXy5lc2NhcGUobGlicmFyeS5nZXQoXCJkZXNjcmlwdGlvblwiKSklPjwvdGQ+JyxcbiAgICAgICAgICAgICAgICBcIjwlIH0gJT5cIixcbiAgICAgICAgICAgICAgICBcIjwlIH0gZWxzZSB7ICU+XCIsXG4gICAgICAgICAgICAgICAgXCI8dGQ+PC90ZD5cIixcbiAgICAgICAgICAgICAgICBcIjwlIH0gJT5cIixcbiAgICAgICAgICAgICAgICAnPCUgaWYobGlicmFyeS5nZXQoXCJzeW5vcHNpc1wiKSkgeyAlPicsXG4gICAgICAgICAgICAgICAgJzwlIGlmKCAobGlicmFyeS5nZXQoXCJzeW5vcHNpc1wiKSkubGVuZ3RoPiAxMjAgKSB7ICU+JyxcbiAgICAgICAgICAgICAgICAnPHRkIGRhdGEtdG9nZ2xlPVwidG9vbHRpcFwiIGRhdGEtcGxhY2VtZW50PVwiYm90dG9tXCIgdGl0bGU9XCI8JT0gXy5lc2NhcGUobGlicmFyeS5nZXQoXCJzeW5vcHNpc1wiKSkgJT5cIj48JT0gXy5lc2NhcGUobGlicmFyeS5nZXQoXCJzeW5vcHNpc1wiKSkuc3Vic3RyaW5nKDAsIDEyMCkgKyBcIi4uLlwiICU+PC90ZD4nLFxuICAgICAgICAgICAgICAgIFwiPCUgfSBlbHNlIHsgJT5cIixcbiAgICAgICAgICAgICAgICAnPHRkPjwlPSBfLmVzY2FwZShsaWJyYXJ5LmdldChcInN5bm9wc2lzXCIpKSU+PC90ZD4nLFxuICAgICAgICAgICAgICAgIFwiPCUgfSAlPlwiLFxuICAgICAgICAgICAgICAgIFwiPCUgfSBlbHNlIHsgJT5cIixcbiAgICAgICAgICAgICAgICBcIjx0ZD48L3RkPlwiLFxuICAgICAgICAgICAgICAgIFwiPCUgfSAlPlwiLFxuICAgICAgICAgICAgICAgIFwiPCUgfSBlbHNlIGlmKGVkaXRfbW9kZSl7ICU+XCIsXG4gICAgICAgICAgICAgICAgJzx0ZD48dGV4dGFyZWEgcm93cz1cIjRcIiBjbGFzcz1cImZvcm0tY29udHJvbCBpbnB1dF9saWJyYXJ5X25hbWVcIiBwbGFjZWhvbGRlcj1cIm5hbWVcIiA+PCUtIGxpYnJhcnkuZ2V0KFwibmFtZVwiKSAlPjwvdGV4dGFyZWE+PC90ZD4nLFxuICAgICAgICAgICAgICAgICc8dGQ+PHRleHRhcmVhIHJvd3M9XCI0XCIgY2xhc3M9XCJmb3JtLWNvbnRyb2wgaW5wdXRfbGlicmFyeV9kZXNjcmlwdGlvblwiIHBsYWNlaG9sZGVyPVwiZGVzY3JpcHRpb25cIiA+PCUtIGxpYnJhcnkuZ2V0KFwiZGVzY3JpcHRpb25cIikgJT48L3RleHRhcmVhPjwvdGQ+JyxcbiAgICAgICAgICAgICAgICAnPHRkPjx0ZXh0YXJlYSByb3dzPVwiNFwiIGNsYXNzPVwiZm9ybS1jb250cm9sIGlucHV0X2xpYnJhcnlfc3lub3BzaXNcIiBwbGFjZWhvbGRlcj1cInN5bm9wc2lzXCIgPjwlLSBsaWJyYXJ5LmdldChcInN5bm9wc2lzXCIpICU+PC90ZXh0YXJlYT48L3RkPicsXG4gICAgICAgICAgICAgICAgXCI8JSB9ICU+XCIsXG4gICAgICAgICAgICAgICAgJzx0ZCBjbGFzcz1cInJpZ2h0LWNlbnRlclwiPicsXG4gICAgICAgICAgICAgICAgJzwlIGlmKCAobGlicmFyeS5nZXQoXCJwdWJsaWNcIikpICYmIChsaWJyYXJ5LmdldChcImRlbGV0ZWRcIikgPT09IGZhbHNlKSApIHsgJT4nLFxuICAgICAgICAgICAgICAgICc8c3BhbiBkYXRhLXRvZ2dsZT1cInRvb2x0aXBcIiBkYXRhLXBsYWNlbWVudD1cInRvcFwiIHRpdGxlPVwiVW5yZXN0cmljdGVkIGxpYnJhcnlcIiBzdHlsZT1cImNvbG9yOmdyZXk7XCIgY2xhc3M9XCJmYSBmYS1nbG9iZSBmYS1sZ1wiPiA8L3NwYW4+JyxcbiAgICAgICAgICAgICAgICBcIjwlIH0lPlwiLFxuICAgICAgICAgICAgICAgICc8YnV0dG9uIGRhdGEtdG9nZ2xlPVwidG9vbHRpcFwiIGRhdGEtcGxhY2VtZW50PVwidG9wXCIgdGl0bGU9XCJNb2RpZnkgXFwnPCUtIGxpYnJhcnkuZ2V0KFwibmFtZVwiKSAlPlxcJ1wiIGNsYXNzPVwicHJpbWFyeS1idXR0b24gYnRuLXhzIGVkaXRfbGlicmFyeV9idG5cIiB0eXBlPVwiYnV0dG9uXCIgc3R5bGU9XCI8JSBpZihidXR0b25fY29uZmlnLmVkaXRfbGlicmFyeV9idG4gPT09IGZhbHNlKSB7IHByaW50KFwiZGlzcGxheTpub25lO1wiKSB9ICU+XCI+PHNwYW4gY2xhc3M9XCJmYSBmYS1wZW5jaWxcIj48L3NwYW4+IEVkaXQ8L2J1dHRvbj4nLFxuICAgICAgICAgICAgICAgICc8YSBocmVmPVwiI2xpYnJhcnkvPCUtIGxpYnJhcnkuZ2V0KFwiaWRcIikgJT4vcGVybWlzc2lvbnNcIj48YnV0dG9uIGRhdGEtdG9nZ2xlPVwidG9vbHRpcFwiIGRhdGEtcGxhY2VtZW50PVwidG9wXCIgdGl0bGU9XCJQZXJtaXNzaW9ucyBvZiBcXCc8JS0gbGlicmFyeS5nZXQoXCJuYW1lXCIpICU+XFwnXCIgY2xhc3M9XCJwcmltYXJ5LWJ1dHRvbiBidG4teHMgcGVybWlzc2lvbl9saWJyYXJ5X2J0blwiIHR5cGU9XCJidXR0b25cIiBzdHlsZT1cIjwlIGlmKGJ1dHRvbl9jb25maWcucGVybWlzc2lvbl9saWJyYXJ5X2J0biA9PT0gZmFsc2UpIHsgcHJpbnQoXCJkaXNwbGF5Om5vbmU7XCIpIH0gJT5cIj48c3BhbiBjbGFzcz1cImZhIGZhLWdyb3VwXCI+PC9zcGFuPiBNYW5hZ2U8L2J1dHRvbj48L2E+JyxcbiAgICAgICAgICAgICAgICAnPGJ1dHRvbiBkYXRhLXRvZ2dsZT1cInRvb2x0aXBcIiBkYXRhLXBsYWNlbWVudD1cInRvcFwiIHRpdGxlPVwiU2F2ZSBjaGFuZ2VzXCIgY2xhc3M9XCJwcmltYXJ5LWJ1dHRvbiBidG4teHMgc2F2ZV9saWJyYXJ5X2J0blwiIHR5cGU9XCJidXR0b25cIiBzdHlsZT1cIjwlIGlmKGJ1dHRvbl9jb25maWcuc2F2ZV9saWJyYXJ5X2J0biA9PT0gZmFsc2UpIHsgcHJpbnQoXCJkaXNwbGF5Om5vbmU7XCIpIH0gJT5cIj48c3BhbiBjbGFzcz1cImZhIGZhLWZsb3BweS1vXCI+PC9zcGFuPiBTYXZlPC9idXR0b24+JyxcbiAgICAgICAgICAgICAgICAnPGJ1dHRvbiBkYXRhLXRvZ2dsZT1cInRvb2x0aXBcIiBkYXRhLXBsYWNlbWVudD1cInRvcFwiIHRpdGxlPVwiRGlzY2FyZCBjaGFuZ2VzXCIgY2xhc3M9XCJwcmltYXJ5LWJ1dHRvbiBidG4teHMgY2FuY2VsX2xpYnJhcnlfYnRuXCIgdHlwZT1cImJ1dHRvblwiIHN0eWxlPVwiPCUgaWYoYnV0dG9uX2NvbmZpZy5jYW5jZWxfbGlicmFyeV9idG4gPT09IGZhbHNlKSB7IHByaW50KFwiZGlzcGxheTpub25lO1wiKSB9ICU+XCI+PHNwYW4gY2xhc3M9XCJmYSBmYS10aW1lc1wiPjwvc3Bhbj4gQ2FuY2VsPC9idXR0b24+JyxcbiAgICAgICAgICAgICAgICAnPGJ1dHRvbiBkYXRhLXRvZ2dsZT1cInRvb2x0aXBcIiBkYXRhLXBsYWNlbWVudD1cInRvcFwiIHRpdGxlPVwiRGVsZXRlIFxcJzwlLSBsaWJyYXJ5LmdldChcIm5hbWVcIikgJT5cXCdcIiBjbGFzcz1cInByaW1hcnktYnV0dG9uIGJ0bi14cyBkZWxldGVfbGlicmFyeV9idG5cIiB0eXBlPVwiYnV0dG9uXCIgc3R5bGU9XCI8JSBpZihidXR0b25fY29uZmlnLmRlbGV0ZV9saWJyYXJ5X2J0biA9PT0gZmFsc2UpIHsgcHJpbnQoXCJkaXNwbGF5Om5vbmU7XCIpIH0gJT5cIj48c3BhbiBjbGFzcz1cImZhIGZhLXRyYXNoLW9cIj48L3NwYW4+IERlbGV0ZTwvYnV0dG9uPicsXG4gICAgICAgICAgICAgICAgLy8gRm9yIGRlbGV0ZWQgbGlicmFyaWVzXG4gICAgICAgICAgICAgICAgJzxzcGFuIGRhdGEtdG9nZ2xlPVwidG9vbHRpcFwiIGRhdGEtcGxhY2VtZW50PVwidG9wXCIgdGl0bGU9XCJNYXJrZWQgZGVsZXRlZFwiIHN0eWxlPVwiY29sb3I6Z3JleTsgPCUgaWYoYnV0dG9uX2NvbmZpZy51bmRlbGV0ZV9saWJyYXJ5X2J0biA9PT0gZmFsc2UpIHsgcHJpbnQoXCJkaXNwbGF5Om5vbmU7XCIpIH0gJT5cIiBjbGFzcz1cImZhIGZhLWJhbiBmYS1sZ1wiPjwvc3Bhbj4nLFxuICAgICAgICAgICAgICAgICc8YnV0dG9uIGRhdGEtdG9nZ2xlPVwidG9vbHRpcFwiIGRhdGEtcGxhY2VtZW50PVwidG9wXCIgdGl0bGU9XCJVbmRlbGV0ZSBcXCc8JS0gbGlicmFyeS5nZXQoXCJuYW1lXCIpICU+XFwnIFwiIGNsYXNzPVwicHJpbWFyeS1idXR0b24gYnRuLXhzIHVuZGVsZXRlX2xpYnJhcnlfYnRuXCIgdHlwZT1cImJ1dHRvblwiIHN0eWxlPVwiPCUgaWYoYnV0dG9uX2NvbmZpZy51bmRlbGV0ZV9saWJyYXJ5X2J0biA9PT0gZmFsc2UpIHsgcHJpbnQoXCJkaXNwbGF5Om5vbmU7XCIpIH0gJT5cIj48c3BhbiBjbGFzcz1cImZhIGZhLXVubG9ja1wiPjwvc3Bhbj4gVW5kZWxldGU8L2J1dHRvbj4nLFxuICAgICAgICAgICAgICAgIFwiPC90ZD5cIixcbiAgICAgICAgICAgICAgICBcIjwvdHI+XCJcbiAgICAgICAgICAgIF0uam9pbihcIlwiKVxuICAgICAgICApO1xuICAgIH1cbn0pO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gICAgTGlicmFyeVJvd1ZpZXc6IExpYnJhcnlSb3dWaWV3XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGdhbGF4eS9zY3JpcHRzL212Yy9saWJyYXJ5L2xpYnJhcnktbGlicmFyeXJvdy12aWV3LmpzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFDQTtBQUNBOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQUNBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUhBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBYkE7QUFlQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFyQkE7QUF1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFoQkE7QUFrQkE7QUFDQTtBQUNBO0FBQ0E7QUF5Q0E7QUFDQTtBQU1BO0FBN1FBO0FBZ1JBO0FBQ0E7QUFEQTtBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///301\n");

/***/ }),

/***/ 302:
/*!*******************************************************************!*\
  !*** ./galaxy/scripts/mvc/library/library-librarytoolbar-view.js ***!
  \*******************************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(Backbone, _, $) {\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _localization = __webpack_require__(/*! utils/localization */ 3);\n\nvar _localization2 = _interopRequireDefault(_localization);\n\nvar _toastr = __webpack_require__(/*! libs/toastr */ 7);\n\nvar _toastr2 = _interopRequireDefault(_toastr);\n\nvar _libraryModel = __webpack_require__(/*! mvc/library/library-model */ 13);\n\nvar _libraryModel2 = _interopRequireDefault(_libraryModel);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * This view represents the top part of the library page.\n * It contains the tool bar with controls.\n */\nvar LibraryToolbarView = Backbone.View.extend({\n    el: \"#center\",\n\n    defaults: {\n        search_term: \"\"\n    },\n\n    events: {\n        \"click #create_new_library_btn\": \"createLibraryFromModal\",\n        \"click #include_deleted_chk\": \"includeDeletedChecked\",\n        \"click #exclude_restricted_chk\": \"excludeRestrictedChecked\",\n        \"click .page_size_prompt\": \"showPageSizePrompt\",\n        \"keyup .library-search-input\": \"searchLibraries\"\n    },\n\n    initialize: function initialize(options) {\n        this.options = _.defaults(this.options || {}, options, this.defaults);\n        this.render();\n    },\n\n    render: function render() {\n        var toolbar_template = this.templateToolBar();\n        var is_admin = false;\n        var is_anonym = true;\n        if (Galaxy.user) {\n            is_admin = Galaxy.user.isAdmin();\n            is_anonym = Galaxy.user.isAnonymous();\n        }\n        this.$el.html(toolbar_template({ admin_user: is_admin, anon_user: is_anonym }));\n        if (is_admin) {\n            this.$el.find(\"#include_deleted_chk\")[0].checked = Galaxy.libraries.preferences.get(\"with_deleted\");\n            this.$el.find(\"#exclude_restricted_chk\")[0].checked = Galaxy.libraries.preferences.get(\"without_restricted\");\n        }\n    },\n\n    /**\n     * Renders the element that shows pages into its div within the toolbar.\n     */\n    renderPaginator: function renderPaginator(options) {\n        this.options = _.extend(this.options, options);\n        var paginator_template = this.templatePaginator();\n        this.$el.find(\"#library_paginator\").html(paginator_template({\n            show_page: parseInt(this.options.show_page),\n            page_count: parseInt(this.options.page_count),\n            total_libraries_count: this.options.total_libraries_count,\n            libraries_shown: this.options.libraries_shown,\n            library_page_size: Galaxy.libraries.preferences.get(\"library_page_size\")\n        }));\n    },\n\n    /**\n     * User clicked on 'New library' button. Show modal to\n     * satisfy the wish.\n     */\n    createLibraryFromModal: function createLibraryFromModal(event) {\n        event.preventDefault();\n        event.stopPropagation();\n        var self = this;\n        this.modal = Galaxy.modal;\n        this.modal.show({\n            closing_events: true,\n            title: (0, _localization2.default)(\"Create New Library\"),\n            body: this.templateNewLibraryInModal(),\n            buttons: {\n                Create: function Create() {\n                    self.createNewLibrary();\n                },\n                Close: function Close() {\n                    self.modal.hide();\n                }\n            }\n        });\n    },\n\n    /**\n     * Create the new library using the API asynchronously.\n     */\n    createNewLibrary: function createNewLibrary() {\n        var libraryDetails = this.serializeNewLibrary();\n        if (this.validateNewLibrary(libraryDetails)) {\n            var library = new _libraryModel2.default.Library();\n            var self = this;\n            library.save(libraryDetails, {\n                success: function success(library) {\n                    Galaxy.libraries.libraryListView.collection.add(library);\n                    self.modal.hide();\n                    self.clearLibraryModal();\n                    Galaxy.libraries.libraryListView.render();\n                    _toastr2.default.success(\"Library created.\");\n                },\n                error: function error(model, response) {\n                    if (typeof response.responseJSON !== \"undefined\") {\n                        _toastr2.default.error(response.responseJSON.err_msg);\n                    } else {\n                        _toastr2.default.error(\"An error occured.\");\n                    }\n                }\n            });\n        } else {\n            _toastr2.default.error(\"Library's name is missing.\");\n        }\n        return false;\n    },\n\n    /**\n     * Show user the propmpt to change the number of libs shown on page.\n     */\n    showPageSizePrompt: function showPageSizePrompt(e) {\n        e.preventDefault();\n        var library_page_size = prompt(\"How many libraries per page do you want to see?\", Galaxy.libraries.preferences.get(\"library_page_size\"));\n        if (library_page_size != null && library_page_size == parseInt(library_page_size)) {\n            Galaxy.libraries.preferences.set({\n                library_page_size: parseInt(library_page_size)\n            });\n            Galaxy.libraries.libraryListView.render({ show_page: 1 });\n        }\n    },\n\n    /**\n     * Clear the library modal once it is saved.\n     */\n    clearLibraryModal: function clearLibraryModal() {\n        $(\"input[name='Name']\").val(\"\");\n        $(\"input[name='Description']\").val(\"\");\n        $(\"input[name='Synopsis']\").val(\"\");\n    },\n\n    /**\n     * Prepare new library variables to be submitted to API.\n     */\n    serializeNewLibrary: function serializeNewLibrary() {\n        return {\n            name: $(\"input[name='Name']\").val(),\n            description: $(\"input[name='Description']\").val(),\n            synopsis: $(\"input[name='Synopsis']\").val()\n        };\n    },\n\n    /**\n     * Check whether entered values are valid.\n     */\n    validateNewLibrary: function validateNewLibrary(libraryDetails) {\n        return libraryDetails.name !== \"\";\n    },\n\n    /**\n     * Include or exclude deleted libraries in the view.\n     */\n    includeDeletedChecked: function includeDeletedChecked(event) {\n        if (event.target.checked) {\n            Galaxy.libraries.preferences.set({ with_deleted: true });\n            Galaxy.libraries.libraryListView.fetchDeleted();\n        } else {\n            Galaxy.libraries.preferences.set({ with_deleted: false });\n            Galaxy.libraries.libraryListView.render();\n        }\n    },\n\n    /**\n     * Include or exclude restricted libraries in the view.\n     */\n    excludeRestrictedChecked: function excludeRestrictedChecked(event) {\n        if (event.target.checked) {\n            Galaxy.libraries.preferences.set({ without_restricted: true });\n        } else {\n            Galaxy.libraries.preferences.set({ without_restricted: false });\n        }\n        Galaxy.libraries.libraryListView.render();\n    },\n\n    /**\n     * Take the contents of the search field and send it to the list view\n     * to query the collection of libraries.\n     */\n    searchLibraries: function searchLibraries(event) {\n        var search_term = $(\".library-search-input\").val();\n        this.options.search_term = search_term;\n        Galaxy.libraries.libraryListView.searchLibraries(search_term);\n    },\n\n    templateToolBar: function templateToolBar() {\n        return _.template(['<div class=\"library_style_container\">', '<div id=\"toolbar_form\">', '<div id=\"library_toolbar\">', '<form class=\"form-inline\" role=\"form\">', '<span><strong><a href=\"#\" title=\"Go to first page\">DATA LIBRARIES</a></strong></span>', '<span id=\"library_paginator\" class=\"library-paginator\">',\n        // paginator will append here\n        \"</span>\", '<div class=\"form-group toolbar-item\">', '<input type=\"text\" class=\"form-control library-search-input\" placeholder=\"Search\" size=\"30\">', \"</div>\",\n        // only admins see the following\n        \"<% if(admin_user === true) { %>\", '<div class=\"checkbox toolbar-item\" style=\"height: 20px;\">', \"<label>\", '<input id=\"include_deleted_chk\" type=\"checkbox\">', \"include deleted \", \"</input>\", \"</label>\", \"<label>\", '<input id=\"exclude_restricted_chk\" type=\"checkbox\">', \"exclude restricted\", \"</input>\", \"</label>\", \"</div>\", '<span class=\"toolbar-item\" data-toggle=\"tooltip\" data-placement=\"top\" title=\"Create New Library\">', '<button id=\"create_new_library_btn\" class=\"primary-button btn-xs\" type=\"button\"><span class=\"fa fa-plus\"></span> New Library</button>', \"</span>\", \"<% } %>\", '<span class=\"help-button\" data-toggle=\"tooltip\" data-placement=\"top\" title=\"See this screen annotated\">', '<a href=\"https://galaxyproject.org/data-libraries/screen/list-of-libraries/\" target=\"_blank\">', '<button class=\"primary-button\" type=\"button\"><span class=\"fa fa-question-circle\"></span> Help</button>', \"</a>\", \"</span>\", \"</form>\", \"</div>\", \"</div>\", '<div id=\"libraries_element\">',\n        // table with libraries will append here\n        \"</div>\", \"</div>\"].join(\"\"));\n    },\n\n    templatePaginator: function templatePaginator() {\n        return _.template(['<ul class=\"pagination pagination-sm\">', \"<% if ( ( show_page - 1 ) > 0 ) { %>\", \"<% if ( ( show_page - 1 ) > page_count ) { %>\", // we are on higher page than total page count\n        '<li><a href=\"#page/1\"><span class=\"fa fa-angle-double-left\"></span></a></li>', '<li class=\"disabled\"><a href=\"#page/<% print( show_page ) %>\"><% print( show_page - 1 ) %></a></li>', \"<% } else { %>\", '<li><a href=\"#page/1\"><span class=\"fa fa-angle-double-left\"></span></a></li>', '<li><a href=\"#page/<% print( show_page - 1 ) %>\"><% print( show_page - 1 ) %></a></li>', \"<% } %>\", \"<% } else { %>\", // we are on the first page\n        '<li class=\"disabled\"><a href=\"#page/1\"><span class=\"fa fa-angle-double-left\"></span></a></li>', '<li class=\"disabled\"><a href=\"#page/<% print( show_page ) %>\"><% print( show_page - 1 ) %></a></li>', \"<% } %>\", '<li class=\"active\">', '<a href=\"#page/<% print( show_page ) %>\"><% print( show_page ) %></a>', \"</li>\", \"<% if ( ( show_page ) < page_count ) { %>\", '<li><a href=\"#page/<% print( show_page + 1 ) %>\"><% print( show_page + 1 ) %></a></li>', '<li><a href=\"#page/<% print( page_count ) %>\"><span class=\"fa fa-angle-double-right\"></span></a></li>', \"<% } else { %>\", '<li class=\"disabled\"><a href=\"#page/<% print( show_page  ) %>\"><% print( show_page + 1 ) %></a></li>', '<li class=\"disabled\"><a href=\"#page/<% print( page_count ) %>\"><span class=\"fa fa-angle-double-right\"></span></a></li>', \"<% } %>\", \"</ul>\", \"<span>\", ' <%- libraries_shown %> libraries shown <a href=\"\" data-toggle=\"tooltip\" data-placement=\"top\" title=\"currently <%- library_page_size %> per page\" class=\"page_size_prompt\">(change)</a>', \"</span>\", \"<span>\", \" <%- total_libraries_count %> total\", \"</span>\"].join(\"\"));\n    },\n\n    templateNewLibraryInModal: function templateNewLibraryInModal() {\n        return _.template(['<div id=\"new_library_modal\">', \"<form>\", '<input type=\"text\" name=\"Name\" value=\"\" placeholder=\"Name\" autofocus>', '<input type=\"text\" name=\"Description\" value=\"\" placeholder=\"Description\">', '<input type=\"text\" name=\"Synopsis\" value=\"\" placeholder=\"Synopsis\">', \"</form>\", \"</div>\"].join(\"\"));\n    }\n});\n\nexports.default = {\n    LibraryToolbarView: LibraryToolbarView\n};\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! libs/backbone */ 2), __webpack_require__(/*! underscore */ 1), __webpack_require__(/*! jquery */ 0)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzAyLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL2dhbGF4eS9zY3JpcHRzL212Yy9saWJyYXJ5L2xpYnJhcnktbGlicmFyeXRvb2xiYXItdmlldy5qcz8yN2YxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBfbCBmcm9tIFwidXRpbHMvbG9jYWxpemF0aW9uXCI7XG5pbXBvcnQgbW9kX3RvYXN0ciBmcm9tIFwibGlicy90b2FzdHJcIjtcbmltcG9ydCBtb2RfbGlicmFyeV9tb2RlbCBmcm9tIFwibXZjL2xpYnJhcnkvbGlicmFyeS1tb2RlbFwiO1xuLyoqXG4gKiBUaGlzIHZpZXcgcmVwcmVzZW50cyB0aGUgdG9wIHBhcnQgb2YgdGhlIGxpYnJhcnkgcGFnZS5cbiAqIEl0IGNvbnRhaW5zIHRoZSB0b29sIGJhciB3aXRoIGNvbnRyb2xzLlxuICovXG52YXIgTGlicmFyeVRvb2xiYXJWaWV3ID0gQmFja2JvbmUuVmlldy5leHRlbmQoe1xuICAgIGVsOiBcIiNjZW50ZXJcIixcblxuICAgIGRlZmF1bHRzOiB7XG4gICAgICAgIHNlYXJjaF90ZXJtOiBcIlwiXG4gICAgfSxcblxuICAgIGV2ZW50czoge1xuICAgICAgICBcImNsaWNrICNjcmVhdGVfbmV3X2xpYnJhcnlfYnRuXCI6IFwiY3JlYXRlTGlicmFyeUZyb21Nb2RhbFwiLFxuICAgICAgICBcImNsaWNrICNpbmNsdWRlX2RlbGV0ZWRfY2hrXCI6IFwiaW5jbHVkZURlbGV0ZWRDaGVja2VkXCIsXG4gICAgICAgIFwiY2xpY2sgI2V4Y2x1ZGVfcmVzdHJpY3RlZF9jaGtcIjogXCJleGNsdWRlUmVzdHJpY3RlZENoZWNrZWRcIixcbiAgICAgICAgXCJjbGljayAucGFnZV9zaXplX3Byb21wdFwiOiBcInNob3dQYWdlU2l6ZVByb21wdFwiLFxuICAgICAgICBcImtleXVwIC5saWJyYXJ5LXNlYXJjaC1pbnB1dFwiOiBcInNlYXJjaExpYnJhcmllc1wiXG4gICAgfSxcblxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gXy5kZWZhdWx0cyh0aGlzLm9wdGlvbnMgfHwge30sIG9wdGlvbnMsIHRoaXMuZGVmYXVsdHMpO1xuICAgICAgICB0aGlzLnJlbmRlcigpO1xuICAgIH0sXG5cbiAgICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdG9vbGJhcl90ZW1wbGF0ZSA9IHRoaXMudGVtcGxhdGVUb29sQmFyKCk7XG4gICAgICAgIHZhciBpc19hZG1pbiA9IGZhbHNlO1xuICAgICAgICB2YXIgaXNfYW5vbnltID0gdHJ1ZTtcbiAgICAgICAgaWYgKEdhbGF4eS51c2VyKSB7XG4gICAgICAgICAgICBpc19hZG1pbiA9IEdhbGF4eS51c2VyLmlzQWRtaW4oKTtcbiAgICAgICAgICAgIGlzX2Fub255bSA9IEdhbGF4eS51c2VyLmlzQW5vbnltb3VzKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4kZWwuaHRtbCh0b29sYmFyX3RlbXBsYXRlKHsgYWRtaW5fdXNlcjogaXNfYWRtaW4sIGFub25fdXNlcjogaXNfYW5vbnltIH0pKTtcbiAgICAgICAgaWYgKGlzX2FkbWluKSB7XG4gICAgICAgICAgICB0aGlzLiRlbC5maW5kKFwiI2luY2x1ZGVfZGVsZXRlZF9jaGtcIilbMF0uY2hlY2tlZCA9IEdhbGF4eS5saWJyYXJpZXMucHJlZmVyZW5jZXMuZ2V0KFwid2l0aF9kZWxldGVkXCIpO1xuICAgICAgICAgICAgdGhpcy4kZWwuZmluZChcIiNleGNsdWRlX3Jlc3RyaWN0ZWRfY2hrXCIpWzBdLmNoZWNrZWQgPSBHYWxheHkubGlicmFyaWVzLnByZWZlcmVuY2VzLmdldChcbiAgICAgICAgICAgICAgICBcIndpdGhvdXRfcmVzdHJpY3RlZFwiXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgdGhlIGVsZW1lbnQgdGhhdCBzaG93cyBwYWdlcyBpbnRvIGl0cyBkaXYgd2l0aGluIHRoZSB0b29sYmFyLlxuICAgICAqL1xuICAgIHJlbmRlclBhZ2luYXRvcjogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBfLmV4dGVuZCh0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuICAgICAgICB2YXIgcGFnaW5hdG9yX3RlbXBsYXRlID0gdGhpcy50ZW1wbGF0ZVBhZ2luYXRvcigpO1xuICAgICAgICB0aGlzLiRlbC5maW5kKFwiI2xpYnJhcnlfcGFnaW5hdG9yXCIpLmh0bWwoXG4gICAgICAgICAgICBwYWdpbmF0b3JfdGVtcGxhdGUoe1xuICAgICAgICAgICAgICAgIHNob3dfcGFnZTogcGFyc2VJbnQodGhpcy5vcHRpb25zLnNob3dfcGFnZSksXG4gICAgICAgICAgICAgICAgcGFnZV9jb3VudDogcGFyc2VJbnQodGhpcy5vcHRpb25zLnBhZ2VfY291bnQpLFxuICAgICAgICAgICAgICAgIHRvdGFsX2xpYnJhcmllc19jb3VudDogdGhpcy5vcHRpb25zLnRvdGFsX2xpYnJhcmllc19jb3VudCxcbiAgICAgICAgICAgICAgICBsaWJyYXJpZXNfc2hvd246IHRoaXMub3B0aW9ucy5saWJyYXJpZXNfc2hvd24sXG4gICAgICAgICAgICAgICAgbGlicmFyeV9wYWdlX3NpemU6IEdhbGF4eS5saWJyYXJpZXMucHJlZmVyZW5jZXMuZ2V0KFwibGlicmFyeV9wYWdlX3NpemVcIilcbiAgICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFVzZXIgY2xpY2tlZCBvbiAnTmV3IGxpYnJhcnknIGJ1dHRvbi4gU2hvdyBtb2RhbCB0b1xuICAgICAqIHNhdGlzZnkgdGhlIHdpc2guXG4gICAgICovXG4gICAgY3JlYXRlTGlicmFyeUZyb21Nb2RhbDogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdGhpcy5tb2RhbCA9IEdhbGF4eS5tb2RhbDtcbiAgICAgICAgdGhpcy5tb2RhbC5zaG93KHtcbiAgICAgICAgICAgIGNsb3NpbmdfZXZlbnRzOiB0cnVlLFxuICAgICAgICAgICAgdGl0bGU6IF9sKFwiQ3JlYXRlIE5ldyBMaWJyYXJ5XCIpLFxuICAgICAgICAgICAgYm9keTogdGhpcy50ZW1wbGF0ZU5ld0xpYnJhcnlJbk1vZGFsKCksXG4gICAgICAgICAgICBidXR0b25zOiB7XG4gICAgICAgICAgICAgICAgQ3JlYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jcmVhdGVOZXdMaWJyYXJ5KCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBDbG9zZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYubW9kYWwuaGlkZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSB0aGUgbmV3IGxpYnJhcnkgdXNpbmcgdGhlIEFQSSBhc3luY2hyb25vdXNseS5cbiAgICAgKi9cbiAgICBjcmVhdGVOZXdMaWJyYXJ5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGxpYnJhcnlEZXRhaWxzID0gdGhpcy5zZXJpYWxpemVOZXdMaWJyYXJ5KCk7XG4gICAgICAgIGlmICh0aGlzLnZhbGlkYXRlTmV3TGlicmFyeShsaWJyYXJ5RGV0YWlscykpIHtcbiAgICAgICAgICAgIHZhciBsaWJyYXJ5ID0gbmV3IG1vZF9saWJyYXJ5X21vZGVsLkxpYnJhcnkoKTtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIGxpYnJhcnkuc2F2ZShsaWJyYXJ5RGV0YWlscywge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uKGxpYnJhcnkpIHtcbiAgICAgICAgICAgICAgICAgICAgR2FsYXh5LmxpYnJhcmllcy5saWJyYXJ5TGlzdFZpZXcuY29sbGVjdGlvbi5hZGQobGlicmFyeSk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYubW9kYWwuaGlkZSgpO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmNsZWFyTGlicmFyeU1vZGFsKCk7XG4gICAgICAgICAgICAgICAgICAgIEdhbGF4eS5saWJyYXJpZXMubGlicmFyeUxpc3RWaWV3LnJlbmRlcigpO1xuICAgICAgICAgICAgICAgICAgICBtb2RfdG9hc3RyLnN1Y2Nlc3MoXCJMaWJyYXJ5IGNyZWF0ZWQuXCIpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZXJyb3I6IGZ1bmN0aW9uKG1vZGVsLCByZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJlc3BvbnNlLnJlc3BvbnNlSlNPTiAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9kX3RvYXN0ci5lcnJvcihyZXNwb25zZS5yZXNwb25zZUpTT04uZXJyX21zZyk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RfdG9hc3RyLmVycm9yKFwiQW4gZXJyb3Igb2NjdXJlZC5cIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1vZF90b2FzdHIuZXJyb3IoXCJMaWJyYXJ5J3MgbmFtZSBpcyBtaXNzaW5nLlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNob3cgdXNlciB0aGUgcHJvcG1wdCB0byBjaGFuZ2UgdGhlIG51bWJlciBvZiBsaWJzIHNob3duIG9uIHBhZ2UuXG4gICAgICovXG4gICAgc2hvd1BhZ2VTaXplUHJvbXB0OiBmdW5jdGlvbihlKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdmFyIGxpYnJhcnlfcGFnZV9zaXplID0gcHJvbXB0KFxuICAgICAgICAgICAgXCJIb3cgbWFueSBsaWJyYXJpZXMgcGVyIHBhZ2UgZG8geW91IHdhbnQgdG8gc2VlP1wiLFxuICAgICAgICAgICAgR2FsYXh5LmxpYnJhcmllcy5wcmVmZXJlbmNlcy5nZXQoXCJsaWJyYXJ5X3BhZ2Vfc2l6ZVwiKVxuICAgICAgICApO1xuICAgICAgICBpZiAobGlicmFyeV9wYWdlX3NpemUgIT0gbnVsbCAmJiBsaWJyYXJ5X3BhZ2Vfc2l6ZSA9PSBwYXJzZUludChsaWJyYXJ5X3BhZ2Vfc2l6ZSkpIHtcbiAgICAgICAgICAgIEdhbGF4eS5saWJyYXJpZXMucHJlZmVyZW5jZXMuc2V0KHtcbiAgICAgICAgICAgICAgICBsaWJyYXJ5X3BhZ2Vfc2l6ZTogcGFyc2VJbnQobGlicmFyeV9wYWdlX3NpemUpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIEdhbGF4eS5saWJyYXJpZXMubGlicmFyeUxpc3RWaWV3LnJlbmRlcih7IHNob3dfcGFnZTogMSB9KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDbGVhciB0aGUgbGlicmFyeSBtb2RhbCBvbmNlIGl0IGlzIHNhdmVkLlxuICAgICAqL1xuICAgIGNsZWFyTGlicmFyeU1vZGFsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgJChcImlucHV0W25hbWU9J05hbWUnXVwiKS52YWwoXCJcIik7XG4gICAgICAgICQoXCJpbnB1dFtuYW1lPSdEZXNjcmlwdGlvbiddXCIpLnZhbChcIlwiKTtcbiAgICAgICAgJChcImlucHV0W25hbWU9J1N5bm9wc2lzJ11cIikudmFsKFwiXCIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQcmVwYXJlIG5ldyBsaWJyYXJ5IHZhcmlhYmxlcyB0byBiZSBzdWJtaXR0ZWQgdG8gQVBJLlxuICAgICAqL1xuICAgIHNlcmlhbGl6ZU5ld0xpYnJhcnk6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmFtZTogJChcImlucHV0W25hbWU9J05hbWUnXVwiKS52YWwoKSxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiAkKFwiaW5wdXRbbmFtZT0nRGVzY3JpcHRpb24nXVwiKS52YWwoKSxcbiAgICAgICAgICAgIHN5bm9wc2lzOiAkKFwiaW5wdXRbbmFtZT0nU3lub3BzaXMnXVwiKS52YWwoKVxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVjayB3aGV0aGVyIGVudGVyZWQgdmFsdWVzIGFyZSB2YWxpZC5cbiAgICAgKi9cbiAgICB2YWxpZGF0ZU5ld0xpYnJhcnk6IGZ1bmN0aW9uKGxpYnJhcnlEZXRhaWxzKSB7XG4gICAgICAgIHJldHVybiBsaWJyYXJ5RGV0YWlscy5uYW1lICE9PSBcIlwiO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJbmNsdWRlIG9yIGV4Y2x1ZGUgZGVsZXRlZCBsaWJyYXJpZXMgaW4gdGhlIHZpZXcuXG4gICAgICovXG4gICAgaW5jbHVkZURlbGV0ZWRDaGVja2VkOiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQudGFyZ2V0LmNoZWNrZWQpIHtcbiAgICAgICAgICAgIEdhbGF4eS5saWJyYXJpZXMucHJlZmVyZW5jZXMuc2V0KHsgd2l0aF9kZWxldGVkOiB0cnVlIH0pO1xuICAgICAgICAgICAgR2FsYXh5LmxpYnJhcmllcy5saWJyYXJ5TGlzdFZpZXcuZmV0Y2hEZWxldGVkKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBHYWxheHkubGlicmFyaWVzLnByZWZlcmVuY2VzLnNldCh7IHdpdGhfZGVsZXRlZDogZmFsc2UgfSk7XG4gICAgICAgICAgICBHYWxheHkubGlicmFyaWVzLmxpYnJhcnlMaXN0Vmlldy5yZW5kZXIoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJbmNsdWRlIG9yIGV4Y2x1ZGUgcmVzdHJpY3RlZCBsaWJyYXJpZXMgaW4gdGhlIHZpZXcuXG4gICAgICovXG4gICAgZXhjbHVkZVJlc3RyaWN0ZWRDaGVja2VkOiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQudGFyZ2V0LmNoZWNrZWQpIHtcbiAgICAgICAgICAgIEdhbGF4eS5saWJyYXJpZXMucHJlZmVyZW5jZXMuc2V0KHsgd2l0aG91dF9yZXN0cmljdGVkOiB0cnVlIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgR2FsYXh5LmxpYnJhcmllcy5wcmVmZXJlbmNlcy5zZXQoeyB3aXRob3V0X3Jlc3RyaWN0ZWQ6IGZhbHNlIH0pO1xuICAgICAgICB9XG4gICAgICAgIEdhbGF4eS5saWJyYXJpZXMubGlicmFyeUxpc3RWaWV3LnJlbmRlcigpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUYWtlIHRoZSBjb250ZW50cyBvZiB0aGUgc2VhcmNoIGZpZWxkIGFuZCBzZW5kIGl0IHRvIHRoZSBsaXN0IHZpZXdcbiAgICAgKiB0byBxdWVyeSB0aGUgY29sbGVjdGlvbiBvZiBsaWJyYXJpZXMuXG4gICAgICovXG4gICAgc2VhcmNoTGlicmFyaWVzOiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICB2YXIgc2VhcmNoX3Rlcm0gPSAkKFwiLmxpYnJhcnktc2VhcmNoLWlucHV0XCIpLnZhbCgpO1xuICAgICAgICB0aGlzLm9wdGlvbnMuc2VhcmNoX3Rlcm0gPSBzZWFyY2hfdGVybTtcbiAgICAgICAgR2FsYXh5LmxpYnJhcmllcy5saWJyYXJ5TGlzdFZpZXcuc2VhcmNoTGlicmFyaWVzKHNlYXJjaF90ZXJtKTtcbiAgICB9LFxuXG4gICAgdGVtcGxhdGVUb29sQmFyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF8udGVtcGxhdGUoXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJsaWJyYXJ5X3N0eWxlX2NvbnRhaW5lclwiPicsXG4gICAgICAgICAgICAgICAgJzxkaXYgaWQ9XCJ0b29sYmFyX2Zvcm1cIj4nLFxuICAgICAgICAgICAgICAgICc8ZGl2IGlkPVwibGlicmFyeV90b29sYmFyXCI+JyxcbiAgICAgICAgICAgICAgICAnPGZvcm0gY2xhc3M9XCJmb3JtLWlubGluZVwiIHJvbGU9XCJmb3JtXCI+JyxcbiAgICAgICAgICAgICAgICAnPHNwYW4+PHN0cm9uZz48YSBocmVmPVwiI1wiIHRpdGxlPVwiR28gdG8gZmlyc3QgcGFnZVwiPkRBVEEgTElCUkFSSUVTPC9hPjwvc3Ryb25nPjwvc3Bhbj4nLFxuICAgICAgICAgICAgICAgICc8c3BhbiBpZD1cImxpYnJhcnlfcGFnaW5hdG9yXCIgY2xhc3M9XCJsaWJyYXJ5LXBhZ2luYXRvclwiPicsXG4gICAgICAgICAgICAgICAgLy8gcGFnaW5hdG9yIHdpbGwgYXBwZW5kIGhlcmVcbiAgICAgICAgICAgICAgICBcIjwvc3Bhbj5cIixcbiAgICAgICAgICAgICAgICAnPGRpdiBjbGFzcz1cImZvcm0tZ3JvdXAgdG9vbGJhci1pdGVtXCI+JyxcbiAgICAgICAgICAgICAgICAnPGlucHV0IHR5cGU9XCJ0ZXh0XCIgY2xhc3M9XCJmb3JtLWNvbnRyb2wgbGlicmFyeS1zZWFyY2gtaW5wdXRcIiBwbGFjZWhvbGRlcj1cIlNlYXJjaFwiIHNpemU9XCIzMFwiPicsXG4gICAgICAgICAgICAgICAgXCI8L2Rpdj5cIixcbiAgICAgICAgICAgICAgICAvLyBvbmx5IGFkbWlucyBzZWUgdGhlIGZvbGxvd2luZ1xuICAgICAgICAgICAgICAgIFwiPCUgaWYoYWRtaW5fdXNlciA9PT0gdHJ1ZSkgeyAlPlwiLFxuICAgICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiY2hlY2tib3ggdG9vbGJhci1pdGVtXCIgc3R5bGU9XCJoZWlnaHQ6IDIwcHg7XCI+JyxcbiAgICAgICAgICAgICAgICBcIjxsYWJlbD5cIixcbiAgICAgICAgICAgICAgICAnPGlucHV0IGlkPVwiaW5jbHVkZV9kZWxldGVkX2Noa1wiIHR5cGU9XCJjaGVja2JveFwiPicsXG4gICAgICAgICAgICAgICAgXCJpbmNsdWRlIGRlbGV0ZWQgXCIsXG4gICAgICAgICAgICAgICAgXCI8L2lucHV0PlwiLFxuICAgICAgICAgICAgICAgIFwiPC9sYWJlbD5cIixcbiAgICAgICAgICAgICAgICBcIjxsYWJlbD5cIixcbiAgICAgICAgICAgICAgICAnPGlucHV0IGlkPVwiZXhjbHVkZV9yZXN0cmljdGVkX2Noa1wiIHR5cGU9XCJjaGVja2JveFwiPicsXG4gICAgICAgICAgICAgICAgXCJleGNsdWRlIHJlc3RyaWN0ZWRcIixcbiAgICAgICAgICAgICAgICBcIjwvaW5wdXQ+XCIsXG4gICAgICAgICAgICAgICAgXCI8L2xhYmVsPlwiLFxuICAgICAgICAgICAgICAgIFwiPC9kaXY+XCIsXG4gICAgICAgICAgICAgICAgJzxzcGFuIGNsYXNzPVwidG9vbGJhci1pdGVtXCIgZGF0YS10b2dnbGU9XCJ0b29sdGlwXCIgZGF0YS1wbGFjZW1lbnQ9XCJ0b3BcIiB0aXRsZT1cIkNyZWF0ZSBOZXcgTGlicmFyeVwiPicsXG4gICAgICAgICAgICAgICAgJzxidXR0b24gaWQ9XCJjcmVhdGVfbmV3X2xpYnJhcnlfYnRuXCIgY2xhc3M9XCJwcmltYXJ5LWJ1dHRvbiBidG4teHNcIiB0eXBlPVwiYnV0dG9uXCI+PHNwYW4gY2xhc3M9XCJmYSBmYS1wbHVzXCI+PC9zcGFuPiBOZXcgTGlicmFyeTwvYnV0dG9uPicsXG4gICAgICAgICAgICAgICAgXCI8L3NwYW4+XCIsXG4gICAgICAgICAgICAgICAgXCI8JSB9ICU+XCIsXG4gICAgICAgICAgICAgICAgJzxzcGFuIGNsYXNzPVwiaGVscC1idXR0b25cIiBkYXRhLXRvZ2dsZT1cInRvb2x0aXBcIiBkYXRhLXBsYWNlbWVudD1cInRvcFwiIHRpdGxlPVwiU2VlIHRoaXMgc2NyZWVuIGFubm90YXRlZFwiPicsXG4gICAgICAgICAgICAgICAgJzxhIGhyZWY9XCJodHRwczovL2dhbGF4eXByb2plY3Qub3JnL2RhdGEtbGlicmFyaWVzL3NjcmVlbi9saXN0LW9mLWxpYnJhcmllcy9cIiB0YXJnZXQ9XCJfYmxhbmtcIj4nLFxuICAgICAgICAgICAgICAgICc8YnV0dG9uIGNsYXNzPVwicHJpbWFyeS1idXR0b25cIiB0eXBlPVwiYnV0dG9uXCI+PHNwYW4gY2xhc3M9XCJmYSBmYS1xdWVzdGlvbi1jaXJjbGVcIj48L3NwYW4+IEhlbHA8L2J1dHRvbj4nLFxuICAgICAgICAgICAgICAgIFwiPC9hPlwiLFxuICAgICAgICAgICAgICAgIFwiPC9zcGFuPlwiLFxuICAgICAgICAgICAgICAgIFwiPC9mb3JtPlwiLFxuICAgICAgICAgICAgICAgIFwiPC9kaXY+XCIsXG4gICAgICAgICAgICAgICAgXCI8L2Rpdj5cIixcbiAgICAgICAgICAgICAgICAnPGRpdiBpZD1cImxpYnJhcmllc19lbGVtZW50XCI+JyxcbiAgICAgICAgICAgICAgICAvLyB0YWJsZSB3aXRoIGxpYnJhcmllcyB3aWxsIGFwcGVuZCBoZXJlXG4gICAgICAgICAgICAgICAgXCI8L2Rpdj5cIixcbiAgICAgICAgICAgICAgICBcIjwvZGl2PlwiXG4gICAgICAgICAgICBdLmpvaW4oXCJcIilcbiAgICAgICAgKTtcbiAgICB9LFxuXG4gICAgdGVtcGxhdGVQYWdpbmF0b3I6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gXy50ZW1wbGF0ZShcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnPHVsIGNsYXNzPVwicGFnaW5hdGlvbiBwYWdpbmF0aW9uLXNtXCI+JyxcbiAgICAgICAgICAgICAgICBcIjwlIGlmICggKCBzaG93X3BhZ2UgLSAxICkgPiAwICkgeyAlPlwiLFxuICAgICAgICAgICAgICAgIFwiPCUgaWYgKCAoIHNob3dfcGFnZSAtIDEgKSA+IHBhZ2VfY291bnQgKSB7ICU+XCIsIC8vIHdlIGFyZSBvbiBoaWdoZXIgcGFnZSB0aGFuIHRvdGFsIHBhZ2UgY291bnRcbiAgICAgICAgICAgICAgICAnPGxpPjxhIGhyZWY9XCIjcGFnZS8xXCI+PHNwYW4gY2xhc3M9XCJmYSBmYS1hbmdsZS1kb3VibGUtbGVmdFwiPjwvc3Bhbj48L2E+PC9saT4nLFxuICAgICAgICAgICAgICAgICc8bGkgY2xhc3M9XCJkaXNhYmxlZFwiPjxhIGhyZWY9XCIjcGFnZS88JSBwcmludCggc2hvd19wYWdlICkgJT5cIj48JSBwcmludCggc2hvd19wYWdlIC0gMSApICU+PC9hPjwvbGk+JyxcbiAgICAgICAgICAgICAgICBcIjwlIH0gZWxzZSB7ICU+XCIsXG4gICAgICAgICAgICAgICAgJzxsaT48YSBocmVmPVwiI3BhZ2UvMVwiPjxzcGFuIGNsYXNzPVwiZmEgZmEtYW5nbGUtZG91YmxlLWxlZnRcIj48L3NwYW4+PC9hPjwvbGk+JyxcbiAgICAgICAgICAgICAgICAnPGxpPjxhIGhyZWY9XCIjcGFnZS88JSBwcmludCggc2hvd19wYWdlIC0gMSApICU+XCI+PCUgcHJpbnQoIHNob3dfcGFnZSAtIDEgKSAlPjwvYT48L2xpPicsXG4gICAgICAgICAgICAgICAgXCI8JSB9ICU+XCIsXG4gICAgICAgICAgICAgICAgXCI8JSB9IGVsc2UgeyAlPlwiLCAvLyB3ZSBhcmUgb24gdGhlIGZpcnN0IHBhZ2VcbiAgICAgICAgICAgICAgICAnPGxpIGNsYXNzPVwiZGlzYWJsZWRcIj48YSBocmVmPVwiI3BhZ2UvMVwiPjxzcGFuIGNsYXNzPVwiZmEgZmEtYW5nbGUtZG91YmxlLWxlZnRcIj48L3NwYW4+PC9hPjwvbGk+JyxcbiAgICAgICAgICAgICAgICAnPGxpIGNsYXNzPVwiZGlzYWJsZWRcIj48YSBocmVmPVwiI3BhZ2UvPCUgcHJpbnQoIHNob3dfcGFnZSApICU+XCI+PCUgcHJpbnQoIHNob3dfcGFnZSAtIDEgKSAlPjwvYT48L2xpPicsXG4gICAgICAgICAgICAgICAgXCI8JSB9ICU+XCIsXG4gICAgICAgICAgICAgICAgJzxsaSBjbGFzcz1cImFjdGl2ZVwiPicsXG4gICAgICAgICAgICAgICAgJzxhIGhyZWY9XCIjcGFnZS88JSBwcmludCggc2hvd19wYWdlICkgJT5cIj48JSBwcmludCggc2hvd19wYWdlICkgJT48L2E+JyxcbiAgICAgICAgICAgICAgICBcIjwvbGk+XCIsXG4gICAgICAgICAgICAgICAgXCI8JSBpZiAoICggc2hvd19wYWdlICkgPCBwYWdlX2NvdW50ICkgeyAlPlwiLFxuICAgICAgICAgICAgICAgICc8bGk+PGEgaHJlZj1cIiNwYWdlLzwlIHByaW50KCBzaG93X3BhZ2UgKyAxICkgJT5cIj48JSBwcmludCggc2hvd19wYWdlICsgMSApICU+PC9hPjwvbGk+JyxcbiAgICAgICAgICAgICAgICAnPGxpPjxhIGhyZWY9XCIjcGFnZS88JSBwcmludCggcGFnZV9jb3VudCApICU+XCI+PHNwYW4gY2xhc3M9XCJmYSBmYS1hbmdsZS1kb3VibGUtcmlnaHRcIj48L3NwYW4+PC9hPjwvbGk+JyxcbiAgICAgICAgICAgICAgICBcIjwlIH0gZWxzZSB7ICU+XCIsXG4gICAgICAgICAgICAgICAgJzxsaSBjbGFzcz1cImRpc2FibGVkXCI+PGEgaHJlZj1cIiNwYWdlLzwlIHByaW50KCBzaG93X3BhZ2UgICkgJT5cIj48JSBwcmludCggc2hvd19wYWdlICsgMSApICU+PC9hPjwvbGk+JyxcbiAgICAgICAgICAgICAgICAnPGxpIGNsYXNzPVwiZGlzYWJsZWRcIj48YSBocmVmPVwiI3BhZ2UvPCUgcHJpbnQoIHBhZ2VfY291bnQgKSAlPlwiPjxzcGFuIGNsYXNzPVwiZmEgZmEtYW5nbGUtZG91YmxlLXJpZ2h0XCI+PC9zcGFuPjwvYT48L2xpPicsXG4gICAgICAgICAgICAgICAgXCI8JSB9ICU+XCIsXG4gICAgICAgICAgICAgICAgXCI8L3VsPlwiLFxuICAgICAgICAgICAgICAgIFwiPHNwYW4+XCIsXG4gICAgICAgICAgICAgICAgJyA8JS0gbGlicmFyaWVzX3Nob3duICU+IGxpYnJhcmllcyBzaG93biA8YSBocmVmPVwiXCIgZGF0YS10b2dnbGU9XCJ0b29sdGlwXCIgZGF0YS1wbGFjZW1lbnQ9XCJ0b3BcIiB0aXRsZT1cImN1cnJlbnRseSA8JS0gbGlicmFyeV9wYWdlX3NpemUgJT4gcGVyIHBhZ2VcIiBjbGFzcz1cInBhZ2Vfc2l6ZV9wcm9tcHRcIj4oY2hhbmdlKTwvYT4nLFxuICAgICAgICAgICAgICAgIFwiPC9zcGFuPlwiLFxuICAgICAgICAgICAgICAgIFwiPHNwYW4+XCIsXG4gICAgICAgICAgICAgICAgXCIgPCUtIHRvdGFsX2xpYnJhcmllc19jb3VudCAlPiB0b3RhbFwiLFxuICAgICAgICAgICAgICAgIFwiPC9zcGFuPlwiXG4gICAgICAgICAgICBdLmpvaW4oXCJcIilcbiAgICAgICAgKTtcbiAgICB9LFxuXG4gICAgdGVtcGxhdGVOZXdMaWJyYXJ5SW5Nb2RhbDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfLnRlbXBsYXRlKFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICc8ZGl2IGlkPVwibmV3X2xpYnJhcnlfbW9kYWxcIj4nLFxuICAgICAgICAgICAgICAgIFwiPGZvcm0+XCIsXG4gICAgICAgICAgICAgICAgJzxpbnB1dCB0eXBlPVwidGV4dFwiIG5hbWU9XCJOYW1lXCIgdmFsdWU9XCJcIiBwbGFjZWhvbGRlcj1cIk5hbWVcIiBhdXRvZm9jdXM+JyxcbiAgICAgICAgICAgICAgICAnPGlucHV0IHR5cGU9XCJ0ZXh0XCIgbmFtZT1cIkRlc2NyaXB0aW9uXCIgdmFsdWU9XCJcIiBwbGFjZWhvbGRlcj1cIkRlc2NyaXB0aW9uXCI+JyxcbiAgICAgICAgICAgICAgICAnPGlucHV0IHR5cGU9XCJ0ZXh0XCIgbmFtZT1cIlN5bm9wc2lzXCIgdmFsdWU9XCJcIiBwbGFjZWhvbGRlcj1cIlN5bm9wc2lzXCI+JyxcbiAgICAgICAgICAgICAgICBcIjwvZm9ybT5cIixcbiAgICAgICAgICAgICAgICBcIjwvZGl2PlwiXG4gICAgICAgICAgICBdLmpvaW4oXCJcIilcbiAgICAgICAgKTtcbiAgICB9XG59KTtcblxuZXhwb3J0IGRlZmF1bHQge1xuICAgIExpYnJhcnlUb29sYmFyVmlldzogTGlicmFyeVRvb2xiYXJWaWV3XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGdhbGF4eS9zY3JpcHRzL212Yy9saWJyYXJ5L2xpYnJhcnktbGlicmFyeXRvb2xiYXItdmlldy5qcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTs7O0FBQUE7QUFDQTs7O0FBQUE7QUFDQTs7Ozs7QUFBQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFRQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBSkE7QUFhQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFkQTtBQWdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFRQTtBQUNBO0FBSUE7QUFDQTtBQTBCQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQU9BO0FBc0JBO0FBQ0E7QUFDQTtBQUNBO0FBV0E7QUE1UkE7QUFDQTtBQThSQTtBQUNBO0FBREE7QSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///302\n");

/***/ }),

/***/ 303:
/*!******************************************************************!*\
  !*** ./galaxy/scripts/mvc/library/library-foldertoolbar-view.js ***!
  \******************************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(Backbone, _, $, jQuery) {\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _localization = __webpack_require__(/*! utils/localization */ 3);\n\nvar _localization2 = _interopRequireDefault(_localization);\n\nvar _utils = __webpack_require__(/*! utils/utils */ 4);\n\nvar _utils2 = _interopRequireDefault(_utils);\n\nvar _toastr = __webpack_require__(/*! libs/toastr */ 7);\n\nvar _toastr2 = _interopRequireDefault(_toastr);\n\nvar _libraryModel = __webpack_require__(/*! mvc/library/library-model */ 13);\n\nvar _libraryModel2 = _interopRequireDefault(_libraryModel);\n\nvar _uiSelect = __webpack_require__(/*! mvc/ui/ui-select */ 10);\n\nvar _uiSelect2 = _interopRequireDefault(_uiSelect);\n\n__webpack_require__(/*! libs/jquery/jstree */ 128);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar FolderToolbarView = Backbone.View.extend({\n    el: \"#center\",\n\n    events: {\n        \"click #toolbtn_create_folder\": \"createFolderFromModal\",\n        \"click #toolbtn_bulk_import\": \"modalBulkImport\",\n        \"click #include_deleted_datasets_chk\": \"checkIncludeDeleted\",\n        \"click #toolbtn_bulk_delete\": \"deleteSelectedItems\",\n        \"click .toolbtn-show-locinfo\": \"showLocInfo\",\n        \"click .page_size_prompt\": \"showPageSizePrompt\"\n    },\n\n    defaults: {\n        can_add_library_item: false,\n        contains_file_or_folder: false,\n        chain_call_control: {\n            total_number: 0,\n            failed_number: 0\n        },\n        disabled_jstree_element: \"folders\"\n    },\n\n    modal: null,\n\n    // directory browsing object\n    jstree: null,\n\n    // user's histories\n    histories: null,\n\n    // genome select\n    select_genome: null,\n\n    // extension select\n    select_extension: null,\n\n    // extension types\n    list_extensions: [],\n\n    // datatype placeholder for extension auto-detection\n    auto: {\n        id: \"auto\",\n        text: \"Auto-detect\",\n        description: \"This system will try to detect the file type automatically.\" + \" If your file is not detected properly as one of the known formats,\" + \" it most likely means that it has some format problems (e.g., different\" + \" number of columns on different rows). You can still coerce the system\" + \" to set your data to the format you think it should be.\" + \" You can also upload compressed files, which will automatically be decompressed.\"\n    },\n\n    // genomes\n    list_genomes: [],\n\n    initialize: function initialize(options) {\n        this.options = _.defaults(options || {}, this.defaults);\n        this.fetchExtAndGenomes();\n        this.render();\n    },\n\n    render: function render(options) {\n        this.options = _.extend(this.options, options);\n        var toolbar_template = this.templateToolBar();\n        var template_defaults = {\n            id: this.options.id,\n            is_admin: false,\n            is_anonym: true,\n            mutiple_add_dataset_options: false\n        };\n        if (Galaxy.user) {\n            template_defaults.is_admin = Galaxy.user.isAdmin();\n            template_defaults.is_anonym = Galaxy.user.isAnonymous();\n            if (Galaxy.config.user_library_import_dir !== null || Galaxy.config.allow_library_path_paste !== false || Galaxy.config.library_import_dir !== null) {\n                template_defaults.mutiple_add_dataset_options = true;\n            }\n        }\n        this.$el.html(toolbar_template(template_defaults));\n    },\n\n    /**\n     * Called from FolderListView when needed.\n     * @param  {object} options common options\n     */\n    renderPaginator: function renderPaginator(options) {\n        this.options = _.extend(this.options, options);\n        var paginator_template = this.templatePaginator();\n        $(\"body\").find(\".folder-paginator\").html(paginator_template({\n            id: this.options.id,\n            show_page: parseInt(this.options.show_page),\n            page_count: parseInt(this.options.page_count),\n            total_items_count: this.options.total_items_count,\n            items_shown: this.options.items_shown,\n            folder_page_size: Galaxy.libraries.preferences.get(\"folder_page_size\")\n        }));\n    },\n\n    configureElements: function configureElements(options) {\n        this.options = _.extend(this.options, options);\n\n        if (this.options.can_add_library_item === true) {\n            $(\".add-library-items\").show();\n        } else {\n            $(\".add-library-items\").hide();\n        }\n        if (this.options.contains_file_or_folder === true) {\n            if (Galaxy.user) {\n                if (!Galaxy.user.isAnonymous()) {\n                    $(\".logged-dataset-manipulation\").show();\n                    $(\".dataset-manipulation\").show();\n                } else {\n                    $(\".dataset-manipulation\").show();\n                    $(\".logged-dataset-manipulation\").hide();\n                }\n            } else {\n                $(\".logged-dataset-manipulation\").hide();\n                $(\".dataset-manipulation\").hide();\n            }\n        } else {\n            $(\".logged-dataset-manipulation\").hide();\n            $(\".dataset-manipulation\").hide();\n        }\n        this.$el.find(\"[data-toggle]\").tooltip();\n    },\n\n    // shows modal for creating folder\n    createFolderFromModal: function createFolderFromModal(event) {\n        event.preventDefault();\n        event.stopPropagation();\n\n        // create modal\n        var self = this;\n        var template = this.templateNewFolderInModal();\n        this.modal = Galaxy.modal;\n        this.modal.show({\n            closing_events: true,\n            title: (0, _localization2.default)(\"Create New Folder\"),\n            body: template(),\n            buttons: {\n                Create: function Create() {\n                    self.create_new_folder_event();\n                },\n                Close: function Close() {\n                    Galaxy.modal.hide();\n                }\n            }\n        });\n    },\n\n    // create the new folder from modal\n    create_new_folder_event: function create_new_folder_event() {\n        var folderDetails = this.serialize_new_folder();\n        if (this.validate_new_folder(folderDetails)) {\n            var folder = new _libraryModel2.default.FolderAsModel();\n            var url_items = Backbone.history.fragment.split(\"/\");\n            var current_folder_id;\n            if (url_items.indexOf(\"page\") > -1) {\n                current_folder_id = url_items[url_items.length - 3];\n            } else {\n                current_folder_id = url_items[url_items.length - 1];\n            }\n            folder.url = folder.urlRoot + current_folder_id;\n\n            folder.save(folderDetails, {\n                success: function success(folder) {\n                    Galaxy.modal.hide();\n                    _toastr2.default.success(\"Folder created.\");\n                    folder.set({ type: \"folder\" });\n                    Galaxy.libraries.folderListView.collection.add(folder);\n                },\n                error: function error(model, response) {\n                    Galaxy.modal.hide();\n                    if (typeof response.responseJSON !== \"undefined\") {\n                        _toastr2.default.error(response.responseJSON.err_msg);\n                    } else {\n                        _toastr2.default.error(\"An error occurred.\");\n                    }\n                }\n            });\n        } else {\n            _toastr2.default.error(\"Folder's name is missing.\");\n        }\n        return false;\n    },\n\n    // serialize data from the modal\n    serialize_new_folder: function serialize_new_folder() {\n        return {\n            name: $(\"input[name='Name']\").val(),\n            description: $(\"input[name='Description']\").val()\n        };\n    },\n\n    // validate new folder info\n    validate_new_folder: function validate_new_folder(folderDetails) {\n        return folderDetails.name !== \"\";\n    },\n\n    // show bulk import modal\n    modalBulkImport: function modalBulkImport() {\n        var $checkedValues = this.findCheckedRows();\n        if ($checkedValues.length === 0) {\n            _toastr2.default.info(\"You must select some datasets first.\");\n        } else {\n            var that = this;\n            this.histories = new _libraryModel2.default.GalaxyHistories();\n            this.histories.fetch().done(function () {\n                var template = that.templateBulkImportInModal();\n                that.modal = Galaxy.modal;\n                that.modal.show({\n                    closing_events: true,\n                    title: (0, _localization2.default)(\"Import into History\"),\n                    body: template({\n                        histories: that.histories.models\n                    }),\n                    buttons: {\n                        Import: function Import() {\n                            that.importAllIntoHistory();\n                        },\n                        Close: function Close() {\n                            Galaxy.modal.hide();\n                        }\n                    }\n                });\n            }).fail(function (model, response) {\n                if (typeof response.responseJSON !== \"undefined\") {\n                    _toastr2.default.error(response.responseJSON.err_msg);\n                } else {\n                    _toastr2.default.error(\"An error occurred.\");\n                }\n            });\n        }\n    },\n\n    /**\n     * Import all selected datasets into history.\n     */\n    importAllIntoHistory: function importAllIntoHistory() {\n        this.modal.disableButton(\"Import\");\n        var new_history_name = this.modal.$(\"input[name=history_name]\").val();\n        var that = this;\n        if (new_history_name !== \"\") {\n            $.post(Galaxy.root + \"api/histories\", {\n                name: new_history_name\n            }).done(function (new_history) {\n                that.options.last_used_history_id = new_history.id;\n                that.processImportToHistory(new_history.id, new_history.name);\n            }).fail(function (xhr, status, error) {\n                _toastr2.default.error(\"An error occurred.\");\n            }).always(function () {\n                that.modal.enableButton(\"Import\");\n            });\n        } else {\n            var history_id = $(\"select[name=dataset_import_bulk] option:selected\").val();\n            this.options.last_used_history_id = history_id;\n            var history_name = $(\"select[name=dataset_import_bulk] option:selected\").text();\n            this.processImportToHistory(history_id, history_name);\n            this.modal.enableButton(\"Import\");\n        }\n    },\n\n    processImportToHistory: function processImportToHistory(history_id, history_name) {\n        var dataset_ids = [];\n        var folder_ids = [];\n        this.findCheckedRows().each(function () {\n            var row_id = $(this).closest(\"tr\").data(\"id\");\n            if (row_id.substring(0, 1) == \"F\") {\n                folder_ids.push(row_id);\n            } else {\n                dataset_ids.push(row_id);\n            }\n        });\n        // prepare the dataset objects to be imported\n        var datasets_to_import = [];\n        for (var i = dataset_ids.length - 1; i >= 0; i--) {\n            var library_dataset_id = dataset_ids[i];\n            var historyItem = new _libraryModel2.default.HistoryItem();\n            historyItem.url = historyItem.urlRoot + history_id + \"/contents\";\n            historyItem.content = library_dataset_id;\n            historyItem.source = \"library\";\n            datasets_to_import.push(historyItem);\n        }\n\n        // prepare the folder objects to be imported\n        var folders_to_import = [];\n        for (var i = folder_ids.length - 1; i >= 0; i--) {\n            var library_folder_id = folder_ids[i];\n            var historyItem = new _libraryModel2.default.HistoryItem();\n            historyItem.url = historyItem.urlRoot + history_id + \"/contents\";\n            historyItem.content = library_folder_id;\n            historyItem.source = \"library_folder\";\n            datasets_to_import.push(historyItem);\n        }\n\n        this.initChainCallControl({\n            length: datasets_to_import.length,\n            action: \"to_history\",\n            history_name: history_name\n        });\n        // set the used history as current so user will see the last one\n        // that he imported into in the history panel on the 'analysis' page\n        jQuery.getJSON(Galaxy.root + \"history/set_as_current?id=\" + history_id);\n        this.chainCallImportingIntoHistory(datasets_to_import, history_name);\n    },\n\n    /**\n     * Update the progress bar in modal window.\n     */\n    updateProgress: function updateProgress() {\n        this.progress += this.progressStep;\n        $(\".progress-bar-import\").width(Math.round(this.progress) + \"%\");\n        var txt_representation = Math.round(this.progress) + \"% Complete\";\n        $(\".completion_span\").text(txt_representation);\n    },\n\n    /**\n     * download selected datasets\n     * @param  {str} folder_id id of the current folder\n     * @param  {str} format    requested archive format\n     */\n    download: function download(folder_id, format) {\n        var dataset_ids = [];\n        var folder_ids = [];\n        this.findCheckedRows().each(function () {\n            var row_id = $(this).closest(\"tr\").data(\"id\");\n            if (row_id.substring(0, 1) == \"F\") {\n                folder_ids.push(row_id);\n            } else {\n                dataset_ids.push(row_id);\n            }\n        });\n        var url = Galaxy.root + \"api/libraries/datasets/download/\" + format;\n        var data = { ld_ids: dataset_ids, folder_ids: folder_ids };\n        this.processDownload(url, data, \"get\");\n    },\n\n    /**\n     * Create hidden form and submit it through POST\n     * to initialize the download.\n     * @param  {str} url    url to call\n     * @param  {obj} data   data to include in the request\n     * @param  {str} method method of the request\n     */\n    processDownload: function processDownload(url, data, method) {\n        if (url && data) {\n            // data can be string of parameters or array/object\n            data = typeof data === \"string\" ? data : $.param(data);\n            // split params into form inputs\n            var inputs = \"\";\n            $.each(data.split(\"&\"), function () {\n                var pair = this.split(\"=\");\n                inputs += \"<input type=\\\"hidden\\\" name=\\\"\" + pair[0] + \"\\\" value=\\\"\" + pair[1] + \"\\\" />\";\n            });\n            // send request\n            $(\"<form action=\\\"\" + url + \"\\\" method=\\\"\" + (method || \"post\") + \"\\\">\" + inputs + \"</form>\").appendTo(\"body\").submit().remove();\n            _toastr2.default.info(\"Your download will begin soon.\");\n        } else {\n            _toastr2.default.error(\"An error occurred.\");\n        }\n    },\n\n    addFilesFromHistoryModal: function addFilesFromHistoryModal() {\n        this.histories = new _libraryModel2.default.GalaxyHistories();\n        var self = this;\n        this.histories.fetch().done(function () {\n            self.modal = Galaxy.modal;\n            var template_modal = self.templateAddFilesFromHistory();\n            self.modal.show({\n                closing_events: true,\n                title: (0, _localization2.default)(\"Adding datasets from your history\"),\n                body: template_modal({\n                    histories: self.histories.models\n                }),\n                buttons: {\n                    Add: function Add() {\n                        self.addAllDatasetsFromHistory();\n                    },\n                    Close: function Close() {\n                        Galaxy.modal.hide();\n                    }\n                },\n                closing_callback: function closing_callback() {\n                    Galaxy.libraries.library_router.navigate(\"folders/\" + self.id, { trigger: true });\n                }\n            });\n            self.fetchAndDisplayHistoryContents(self.histories.models[0].id);\n            $(\"#dataset_add_bulk\").change(function (event) {\n                self.fetchAndDisplayHistoryContents(event.target.value);\n            });\n        }).fail(function (model, response) {\n            if (typeof response.responseJSON !== \"undefined\") {\n                _toastr2.default.error(response.responseJSON.err_msg);\n            } else {\n                _toastr2.default.error(\"An error occurred.\");\n            }\n        });\n    },\n\n    /**\n     * Create modal for importing from Galaxy path.\n     * This feature is admin-only.\n     */\n    importFilesFromPathModal: function importFilesFromPathModal() {\n        var that = this;\n        this.modal = Galaxy.modal;\n        var template_modal = this.templateImportPathModal();\n        this.modal.show({\n            closing_events: true,\n            title: (0, _localization2.default)(\"Please enter paths to import\"),\n            body: template_modal({}),\n            buttons: {\n                Import: function Import() {\n                    that.importFromPathsClicked(that);\n                },\n                Close: function Close() {\n                    Galaxy.modal.hide();\n                }\n            },\n            closing_callback: function closing_callback() {\n                //  TODO: should not trigger routes outside of the router\n                Galaxy.libraries.library_router.navigate(\"folders/\" + that.id, {\n                    trigger: true\n                });\n            }\n        });\n        this.renderSelectBoxes();\n    },\n\n    /**\n     * Request all extensions and genomes from Galaxy\n     * and save them sorted in arrays.\n     */\n    fetchExtAndGenomes: function fetchExtAndGenomes() {\n        var that = this;\n        _utils2.default.get({\n            url: Galaxy.root + \"api/datatypes?extension_only=False\",\n            success: function success(datatypes) {\n                that.list_extensions = [];\n                for (var key in datatypes) {\n                    that.list_extensions.push({\n                        id: datatypes[key].extension,\n                        text: datatypes[key].extension,\n                        description: datatypes[key].description,\n                        description_url: datatypes[key].description_url\n                    });\n                }\n                that.list_extensions.sort(function (a, b) {\n                    return a.id > b.id ? 1 : a.id < b.id ? -1 : 0;\n                });\n                that.list_extensions.unshift(that.auto);\n            },\n            cache: true\n        });\n        _utils2.default.get({\n            url: Galaxy.root + \"api/genomes\",\n            success: function success(genomes) {\n                that.list_genomes = [];\n                for (var key in genomes) {\n                    that.list_genomes.push({\n                        id: genomes[key][1],\n                        text: genomes[key][0]\n                    });\n                }\n                that.list_genomes.sort(function (a, b) {\n                    return a.id > b.id ? 1 : a.id < b.id ? -1 : 0;\n                });\n            },\n            cache: true\n        });\n    },\n\n    renderSelectBoxes: function renderSelectBoxes() {\n        // This won't work properly unlesss we already have the data fetched.\n        // See this.fetchExtAndGenomes()\n        // TODO switch to common resources:\n        // https://trello.com/c/dIUE9YPl/1933-ui-common-resources-and-data-into-galaxy-object\n        var that = this;\n        this.select_genome = new _uiSelect2.default.View({\n            css: \"library-genome-select\",\n            data: that.list_genomes,\n            container: Galaxy.modal.$el.find(\"#library_genome_select\"),\n            value: \"?\"\n        });\n        this.select_extension = new _uiSelect2.default.View({\n            css: \"library-extension-select\",\n            data: that.list_extensions,\n            container: Galaxy.modal.$el.find(\"#library_extension_select\"),\n            value: \"auto\"\n        });\n    },\n\n    /**\n     * Create modal for importing from given directory\n     * on Galaxy. Bind jQuery events.\n     */\n    importFilesFromGalaxyFolderModal: function importFilesFromGalaxyFolderModal(options) {\n        var that = this;\n        var template_modal = this.templateBrowserModal();\n        this.modal = Galaxy.modal;\n        this.modal.show({\n            closing_events: true,\n            title: (0, _localization2.default)(\"Please select folders or files\"),\n            body: template_modal({}),\n            buttons: {\n                Import: function Import() {\n                    that.importFromJstreePath(that, options);\n                },\n                Close: function Close() {\n                    Galaxy.modal.hide();\n                }\n            },\n            closing_callback: function closing_callback() {\n                //  TODO: should not trigger routes outside of the router\n                Galaxy.libraries.library_router.navigate(\"folders/\" + that.id, {\n                    trigger: true\n                });\n            }\n        });\n\n        $(\".libimport-select-all\").bind(\"click\", function () {\n            $(\"#jstree_browser\").jstree(\"check_all\");\n        });\n        $(\".libimport-select-none\").bind(\"click\", function () {\n            $(\"#jstree_browser\").jstree(\"uncheck_all\");\n        });\n\n        this.renderSelectBoxes();\n        options.disabled_jstree_element = \"folders\";\n        this.renderJstree(options);\n\n        $(\"input[type=radio]\").change(function (event) {\n            if (event.target.value === \"jstree-disable-folders\") {\n                options.disabled_jstree_element = \"folders\";\n                that.renderJstree(options);\n                $(\".jstree-folders-message\").hide();\n                $(\".jstree-preserve-structure\").hide();\n                $(\".jstree-files-message\").show();\n            } else if (event.target.value === \"jstree-disable-files\") {\n                $(\".jstree-files-message\").hide();\n                $(\".jstree-folders-message\").show();\n                $(\".jstree-preserve-structure\").show();\n                options.disabled_jstree_element = \"files\";\n                that.renderJstree(options);\n            }\n        });\n    },\n\n    /**\n     * Fetch the contents of user directory on Galaxy\n     * and render jstree component based on received\n     * data.\n     * @param  {[type]} options [description]\n     */\n    renderJstree: function renderJstree(options) {\n        var that = this;\n        this.options = _.extend(this.options, options);\n        var target = options.source || \"userdir\";\n        var disabled_jstree_element = this.options.disabled_jstree_element;\n        this.jstree = new _libraryModel2.default.Jstree();\n        this.jstree.url = this.jstree.urlRoot + \"?target=\" + target + \"&format=jstree&disable=\" + disabled_jstree_element;\n        this.jstree.fetch({\n            success: function success(model, response) {\n                $(\"#jstree_browser\").jstree(\"destroy\");\n                $(\"#jstree_browser\").jstree({\n                    core: {\n                        data: model\n                    },\n                    plugins: [\"types\", \"checkbox\"],\n                    types: {\n                        folder: {\n                            icon: \"jstree-folder\"\n                        },\n                        file: {\n                            icon: \"jstree-file\"\n                        }\n                    },\n                    checkbox: {\n                        three_state: false\n                    }\n                });\n            },\n            error: function error(model, response) {\n                if (typeof response.responseJSON !== \"undefined\") {\n                    if (response.responseJSON.err_code === 404001) {\n                        _toastr2.default.warning(response.responseJSON.err_msg);\n                    } else {\n                        _toastr2.default.error(response.responseJSON.err_msg);\n                    }\n                } else {\n                    _toastr2.default.error(\"An error occurred.\");\n                }\n            }\n        });\n    },\n\n    /**\n     * Take the paths from the textarea, split it, create\n     * a request queue and call a function that starts sending\n     * one by one to be imported on the server.\n     */\n    importFromPathsClicked: function importFromPathsClicked() {\n        var preserve_dirs = this.modal.$el.find(\".preserve-checkbox\").is(\":checked\");\n        var link_data = this.modal.$el.find(\".link-checkbox\").is(\":checked\");\n        var space_to_tab = this.modal.$el.find(\".spacetab-checkbox\").is(\":checked\");\n        var to_posix_lines = this.modal.$el.find(\".posix-checkbox\").is(\":checked\");\n        var tag_using_filenames = this.modal.$el.find(\".tag-files\").is(\":checked\");\n        var file_type = this.select_extension.value();\n        var dbkey = this.select_genome.value();\n        var paths = $(\"textarea#import_paths\").val();\n        var valid_paths = [];\n        if (!paths) {\n            _toastr2.default.info(\"Please enter a path relative to Galaxy root.\");\n        } else {\n            this.modal.disableButton(\"Import\");\n            paths = paths.split(\"\\n\");\n            for (var i = paths.length - 1; i >= 0; i--) {\n                var trimmed = paths[i].trim();\n                if (trimmed.length !== 0) {\n                    valid_paths.push(trimmed);\n                }\n            }\n            this.initChainCallControl({\n                length: valid_paths.length,\n                action: \"adding_datasets\"\n            });\n            this.chainCallImportingFolders({\n                paths: valid_paths,\n                preserve_dirs: preserve_dirs,\n                link_data: link_data,\n                space_to_tab: space_to_tab,\n                to_posix_lines: to_posix_lines,\n                source: \"admin_path\",\n                file_type: file_type,\n                tag_using_filenames: tag_using_filenames,\n                dbkey: dbkey\n            });\n        }\n    },\n\n    /**\n     * Initialize the control of chaining requests\n     * in the current modal.\n     * @param {int} length The number of items in the chain call.\n     */\n    initChainCallControl: function initChainCallControl(options) {\n        var template;\n        switch (options.action) {\n            case \"adding_datasets\":\n                template = this.templateAddingDatasetsProgressBar();\n                this.modal.$el.find(\".modal-body\").html(template({\n                    folder_name: this.options.folder_name\n                }));\n                break;\n            case \"deleting_datasets\":\n                template = this.templateDeletingItemsProgressBar();\n                this.modal.$el.find(\".modal-body\").html(template());\n                break;\n            case \"to_history\":\n                template = this.templateImportIntoHistoryProgressBar();\n                this.modal.$el.find(\".modal-body\").html(template({ history_name: options.history_name }));\n                break;\n            default:\n                Galaxy.emit.error(\"Wrong action specified.\", \"datalibs\");\n                break;\n        }\n\n        // var progress_bar_tmpl = this.templateAddingDatasetsProgressBar();\n        // this.modal.$el.find( '.modal-body' ).html( progress_bar_tmpl( { folder_name : this.options.folder_name } ) );\n        this.progress = 0;\n        this.progressStep = 100 / options.length;\n        this.options.chain_call_control.total_number = options.length;\n        this.options.chain_call_control.failed_number = 0;\n    },\n\n    /**\n     * Take the selected items from the jstree, create a request queue\n     * and send them one by one to the server for importing into\n     * the current folder.\n     *\n     * jstree.js has to be loaded before\n     * @see renderJstree\n     */\n    importFromJstreePath: function importFromJstreePath(that, options) {\n        var all_nodes = $(\"#jstree_browser\").jstree().get_selected(true);\n        // remove the disabled elements that could have been trigerred with the 'select all'\n        var selected_nodes = _.filter(all_nodes, function (node) {\n            return node.state.disabled == false;\n        });\n        var preserve_dirs = this.modal.$el.find(\".preserve-checkbox\").is(\":checked\");\n        var link_data = this.modal.$el.find(\".link-checkbox\").is(\":checked\");\n        var space_to_tab = this.modal.$el.find(\".spacetab-checkbox\").is(\":checked\");\n        var to_posix_lines = this.modal.$el.find(\".posix-checkbox\").is(\":checked\");\n        var file_type = this.select_extension.value();\n        var dbkey = this.select_genome.value();\n        var tag_using_filenames = this.modal.$el.find(\".tag-files\").is(\":checked\");\n        var selection_type = selected_nodes[0].type;\n        var paths = [];\n        if (selected_nodes.length < 1) {\n            _toastr2.default.info(\"Please select some items first.\");\n        } else {\n            this.modal.disableButton(\"Import\");\n            for (var i = selected_nodes.length - 1; i >= 0; i--) {\n                if (selected_nodes[i].li_attr.full_path !== undefined) {\n                    paths.push(selected_nodes[i].li_attr.full_path);\n                }\n            }\n            this.initChainCallControl({\n                length: paths.length,\n                action: \"adding_datasets\"\n            });\n            if (selection_type === \"folder\") {\n                var full_source = options.source + \"_folder\";\n                this.chainCallImportingFolders({\n                    paths: paths,\n                    preserve_dirs: preserve_dirs,\n                    link_data: link_data,\n                    space_to_tab: space_to_tab,\n                    to_posix_lines: to_posix_lines,\n                    source: full_source,\n                    file_type: file_type,\n                    dbkey: dbkey,\n                    tag_using_filenames: tag_using_filenames\n                });\n            } else if (selection_type === \"file\") {\n                var full_source = options.source + \"_file\";\n                this.chainCallImportingUserdirFiles({\n                    paths: paths,\n                    file_type: file_type,\n                    dbkey: dbkey,\n                    link_data: link_data,\n                    space_to_tab: space_to_tab,\n                    to_posix_lines: to_posix_lines,\n                    source: full_source,\n                    tag_using_filenames: tag_using_filenames\n                });\n            }\n        }\n    },\n\n    fetchAndDisplayHistoryContents: function fetchAndDisplayHistoryContents(history_id) {\n        var history_contents = new _libraryModel2.default.HistoryContents({\n            id: history_id\n        });\n        var self = this;\n        history_contents.fetch({\n            success: function success(history_contents) {\n                var history_contents_template = self.templateHistoryContents();\n                self.histories.get(history_id).set({ contents: history_contents });\n                self.modal.$el.find(\"#selected_history_content\").html(history_contents_template({\n                    history_contents: history_contents.models.reverse()\n                }));\n                self.modal.$el.find(\".history-import-select-all\").bind(\"click\", function () {\n                    $(\"#selected_history_content [type=checkbox]\").prop(\"checked\", true);\n                });\n                self.modal.$el.find(\".history-import-unselect-all\").bind(\"click\", function () {\n                    $(\"#selected_history_content [type=checkbox]\").prop(\"checked\", false);\n                });\n            },\n            error: function error(model, response) {\n                if (typeof response.responseJSON !== \"undefined\") {\n                    _toastr2.default.error(response.responseJSON.err_msg);\n                } else {\n                    _toastr2.default.error(\"An error occurred.\");\n                }\n            }\n        });\n    },\n\n    /**\n     * Import all selected datasets from history into the current folder.\n     */\n    addAllDatasetsFromHistory: function addAllDatasetsFromHistory() {\n        var checked_hdas = this.modal.$el.find(\"#selected_history_content\").find(\":checked\");\n        var history_item_ids = []; // can be hda or hdca\n        var history_item_types = [];\n        var items_to_add = [];\n        if (checked_hdas.length < 1) {\n            _toastr2.default.info(\"You must select some datasets first.\");\n        } else {\n            this.modal.disableButton(\"Add\");\n            checked_hdas.each(function () {\n                var hid = $(this).closest(\"li\").data(\"id\");\n                if (hid) {\n                    var item_type = $(this).closest(\"li\").data(\"name\");\n                    history_item_ids.push(hid);\n                    history_item_types.push(item_type);\n                }\n            });\n            for (var i = history_item_ids.length - 1; i >= 0; i--) {\n                var history_item_id = history_item_ids[i];\n                var folder_item = new _libraryModel2.default.Item();\n                folder_item.url = Galaxy.root + \"api/folders/\" + this.options.id + \"/contents\";\n                if (history_item_types[i] === \"collection\") {\n                    folder_item.set({ from_hdca_id: history_item_id });\n                } else {\n                    folder_item.set({ from_hda_id: history_item_id });\n                }\n                items_to_add.push(folder_item);\n            }\n            this.initChainCallControl({\n                length: items_to_add.length,\n                action: \"adding_datasets\"\n            });\n            this.chainCallAddingHdas(items_to_add);\n        }\n    },\n\n    /**\n     * Take array of empty history items and make request for each of them\n     * to create it on server. Update progress in between calls.\n     * @param  {array} history_item_set array of empty history items\n     * @param  {str} history_name     name of the history to import to\n     */\n    chainCallImportingIntoHistory: function chainCallImportingIntoHistory(history_item_set, history_name) {\n        var self = this;\n        var popped_item = history_item_set.pop();\n        if (typeof popped_item == \"undefined\") {\n            if (this.options.chain_call_control.failed_number === 0) {\n                _toastr2.default.success(\"Selected datasets imported into history. Click this to start analyzing it.\", \"\", {\n                    onclick: function onclick() {\n                        window.location = Galaxy.root;\n                    }\n                });\n            } else if (this.options.chain_call_control.failed_number === this.options.chain_call_control.total_number) {\n                _toastr2.default.error(\"There was an error and no datasets were imported into history.\");\n            } else if (this.options.chain_call_control.failed_number < this.options.chain_call_control.total_number) {\n                _toastr2.default.warning(\"Some of the datasets could not be imported into history. Click this to see what was imported.\", \"\", {\n                    onclick: function onclick() {\n                        window.location = Galaxy.root;\n                    }\n                });\n            }\n            Galaxy.modal.hide();\n            return true;\n        }\n        var promise = $.when(popped_item.save({\n            content: popped_item.content,\n            source: popped_item.source\n        }));\n\n        promise.done(function () {\n            self.updateProgress();\n            self.chainCallImportingIntoHistory(history_item_set, history_name);\n        }).fail(function () {\n            self.options.chain_call_control.failed_number += 1;\n            self.updateProgress();\n            self.chainCallImportingIntoHistory(history_item_set, history_name);\n        });\n    },\n\n    /**\n     * Take the array of paths and create a request for each of them\n     * calling them in chain. Update the progress bar in between each.\n     * @param  {array} paths                    paths relative to user folder on Galaxy\n     * @param  {boolean} tag_using_filenames    add tags to datasets using names of files\n     */\n    chainCallImportingUserdirFiles: function chainCallImportingUserdirFiles(options) {\n        var that = this;\n        var popped_item = options.paths.pop();\n        if (typeof popped_item === \"undefined\") {\n            if (this.options.chain_call_control.failed_number === 0) {\n                _toastr2.default.success(\"Selected files imported into the current folder\");\n                Galaxy.modal.hide();\n            } else {\n                _toastr2.default.error(\"An error occured.\");\n            }\n            return true;\n        }\n        var promise = $.when($.post(Galaxy.root + \"api/libraries/datasets?encoded_folder_id=\" + that.id + \"&source=\" + options.source + \"&path=\" + popped_item + \"&file_type=\" + options.file_type + \"&link_data=\" + options.link_data + \"&space_to_tab=\" + options.space_to_tab + \"&to_posix_lines=\" + options.to_posix_lines + \"&dbkey=\" + options.dbkey + \"&tag_using_filenames=\" + options.tag_using_filenames));\n        promise.done(function (response) {\n            that.updateProgress();\n            that.chainCallImportingUserdirFiles(options);\n        }).fail(function () {\n            that.options.chain_call_control.failed_number += 1;\n            that.updateProgress();\n            that.chainCallImportingUserdirFiles(options);\n        });\n    },\n\n    /**\n     * Take the array of paths and create a request for each of them\n     * calling them in series. Update the progress bar in between each.\n     * @param  {array} paths                    paths relative to Galaxy root folder\n     * @param  {boolean} preserve_dirs          indicates whether to preserve folder structure\n     * @param  {boolean} link_data              copy files to Galaxy or link instead\n     * @param  {boolean} to_posix_lines         convert line endings to POSIX standard\n     * @param  {boolean} space_to_tab           convert spaces to tabs\n     * @param  {str} source                     string representing what type of folder\n     *                                          is the source of import\n     * @param  {boolean} tag_using_filenames    add tags to datasets using names of files\n     */\n    chainCallImportingFolders: function chainCallImportingFolders(options) {\n        // TODO need to check which paths to call\n        var that = this;\n        var popped_item = options.paths.pop();\n        if (typeof popped_item == \"undefined\") {\n            if (this.options.chain_call_control.failed_number === 0) {\n                _toastr2.default.success(\"Selected folders and their contents imported into the current folder.\");\n                Galaxy.modal.hide();\n            } else {\n                // TODO better error report\n                _toastr2.default.error(\"An error occured.\");\n            }\n            return true;\n        }\n        var promise = $.when($.post(Galaxy.root + \"api/libraries/datasets?encoded_folder_id=\" + that.id + \"&source=\" + options.source + \"&path=\" + popped_item + \"&preserve_dirs=\" + options.preserve_dirs + \"&link_data=\" + options.link_data + \"&to_posix_lines=\" + options.to_posix_lines + \"&space_to_tab=\" + options.space_to_tab + \"&file_type=\" + options.file_type + \"&dbkey=\" + options.dbkey + \"&tag_using_filenames=\" + options.tag_using_filenames));\n        promise.done(function (response) {\n            that.updateProgress();\n            that.chainCallImportingFolders(options);\n        }).fail(function () {\n            that.options.chain_call_control.failed_number += 1;\n            that.updateProgress();\n            that.chainCallImportingFolders(options);\n        });\n    },\n\n    /**\n     * Take the array of hdas and create a request for each.\n     * Call them in chain and update progress bar in between each.\n     * @param  {array} hdas_set array of empty hda objects\n     */\n    chainCallAddingHdas: function chainCallAddingHdas(hdas_set) {\n        var self = this;\n        this.added_hdas = new _libraryModel2.default.Folder();\n        var popped_item = hdas_set.pop();\n        if (typeof popped_item == \"undefined\") {\n            if (this.options.chain_call_control.failed_number === 0) {\n                _toastr2.default.success(\"Selected datasets from history added to the folder\");\n            } else if (this.options.chain_call_control.failed_number === this.options.chain_call_control.total_number) {\n                _toastr2.default.error(\"There was an error and no datasets were added to the folder.\");\n            } else if (this.options.chain_call_control.failed_number < this.options.chain_call_control.total_number) {\n                _toastr2.default.warning(\"Some of the datasets could not be added to the folder\");\n            }\n            Galaxy.modal.hide();\n            return this.added_hdas;\n        }\n        var promise = $.when(popped_item.save({\n            from_hda_id: popped_item.get(\"from_hda_id\")\n        }));\n\n        promise.done(function (model) {\n            Galaxy.libraries.folderListView.collection.add(model);\n            self.updateProgress();\n            self.chainCallAddingHdas(hdas_set);\n        }).fail(function () {\n            self.options.chain_call_control.failed_number += 1;\n            self.updateProgress();\n            self.chainCallAddingHdas(hdas_set);\n        });\n    },\n\n    /**\n     * Take the array of lddas, create request for each and\n     * call them in chain. Update progress bar in between each.\n     * @param  {array} lddas_set array of lddas to delete\n     */\n    chainCallDeletingItems: function chainCallDeletingItems(items_to_delete) {\n        var self = this;\n        this.deleted_items = new _libraryModel2.default.Folder();\n        var item_to_delete = items_to_delete.pop();\n        if (typeof item_to_delete === \"undefined\") {\n            if (this.options.chain_call_control.failed_number === 0) {\n                _toastr2.default.success(\"Selected items were deleted.\");\n            } else if (this.options.chain_call_control.failed_number === this.options.chain_call_control.total_number) {\n                _toastr2.default.error(\"There was an error and no items were deleted. Please make sure you have sufficient permissions.\");\n            } else if (this.options.chain_call_control.failed_number < this.options.chain_call_control.total_number) {\n                _toastr2.default.warning(\"Some of the items could not be deleted. Please make sure you have sufficient permissions.\");\n            }\n            Galaxy.modal.hide();\n            return this.deleted_items;\n        }\n        item_to_delete.destroy().done(function (item) {\n            Galaxy.libraries.folderListView.collection.remove(item_to_delete.id);\n            self.updateProgress();\n            // add the deleted item to collection, triggers rendering\n            if (Galaxy.libraries.folderListView.options.include_deleted) {\n                var updated_item = null;\n                if (item.type === \"folder\" || item.model_class === \"LibraryFolder\") {\n                    updated_item = new _libraryModel2.default.FolderAsModel(item);\n                } else if (item.type === \"file\" || item.model_class === \"LibraryDataset\") {\n                    updated_item = new _libraryModel2.default.Item(item);\n                } else {\n                    Galaxy.emit.error(\"Unknown library item type found.\", \"datalibs\");\n                    Galaxy.emit.error(item.type || item.model_class, \"datalibs\");\n                }\n                Galaxy.libraries.folderListView.collection.add(updated_item);\n            }\n            self.chainCallDeletingItems(items_to_delete);\n        }).fail(function () {\n            self.options.chain_call_control.failed_number += 1;\n            self.updateProgress();\n            self.chainCallDeletingItems(items_to_delete);\n        });\n    },\n\n    /**\n     * Handles the click on 'show deleted' checkbox\n     */\n    checkIncludeDeleted: function checkIncludeDeleted(event) {\n        if (event.target.checked) {\n            Galaxy.libraries.folderListView.fetchFolder({\n                include_deleted: true\n            });\n        } else {\n            Galaxy.libraries.folderListView.fetchFolder({\n                include_deleted: false\n            });\n        }\n    },\n\n    /**\n     * Delete the selected items. Atomic. One by one.\n     */\n    deleteSelectedItems: function deleteSelectedItems() {\n        var dataset_ids = [];\n        var folder_ids = [];\n        var $checkedValues = this.findCheckedRows();\n        if ($checkedValues.length === 0) {\n            _toastr2.default.info(\"You must select at least one item for deletion.\");\n        } else {\n            var template = this.templateDeletingItemsProgressBar();\n            this.modal = Galaxy.modal;\n            this.modal.show({\n                closing_events: true,\n                title: (0, _localization2.default)(\"Deleting selected items\"),\n                body: template({}),\n                buttons: {\n                    Close: function Close() {\n                        Galaxy.modal.hide();\n                    }\n                }\n            });\n            // init the control counters\n            this.options.chain_call_control.total_number = 0;\n            this.options.chain_call_control.failed_number = 0;\n            $checkedValues.each(function () {\n                var row_id = $(this).closest(\"tr\").data(\"id\");\n                if (row_id !== undefined) {\n                    if (row_id.substring(0, 1) == \"F\") {\n                        folder_ids.push(row_id);\n                    } else {\n                        dataset_ids.push(row_id);\n                    }\n                }\n            });\n            // init the progress bar\n            var items_total = dataset_ids.length + folder_ids.length;\n            this.progressStep = 100 / items_total;\n            this.progress = 0;\n\n            // prepare the dataset items to be added\n            var items_to_delete = [];\n            for (var i = dataset_ids.length - 1; i >= 0; i--) {\n                var dataset = new _libraryModel2.default.Item({\n                    id: dataset_ids[i]\n                });\n                items_to_delete.push(dataset);\n            }\n            for (var i = folder_ids.length - 1; i >= 0; i--) {\n                var folder = new _libraryModel2.default.FolderAsModel({\n                    id: folder_ids[i]\n                });\n                items_to_delete.push(folder);\n            }\n\n            this.options.chain_call_control.total_number = items_total;\n            // call the recursive function to call ajax one after each other (request FIFO queue)\n            this.chainCallDeletingItems(items_to_delete);\n        }\n    },\n\n    showLocInfo: function showLocInfo() {\n        var library = null;\n        var that = this;\n        if (Galaxy.libraries.libraryListView !== null) {\n            library = Galaxy.libraries.libraryListView.collection.get(this.options.parent_library_id);\n            this.showLocInfoModal(library);\n        } else {\n            library = new _libraryModel2.default.Library({\n                id: this.options.parent_library_id\n            });\n            library.fetch({\n                success: function success() {\n                    that.showLocInfoModal(library);\n                },\n                error: function error(model, response) {\n                    if (typeof response.responseJSON !== \"undefined\") {\n                        _toastr2.default.error(response.responseJSON.err_msg);\n                    } else {\n                        _toastr2.default.error(\"An error occurred.\");\n                    }\n                }\n            });\n        }\n    },\n\n    showLocInfoModal: function showLocInfoModal(library) {\n        var that = this;\n        var template = this.templateLocInfoInModal();\n        this.modal = Galaxy.modal;\n        this.modal.show({\n            closing_events: true,\n            title: (0, _localization2.default)(\"Location Details\"),\n            body: template({ library: library, options: that.options }),\n            buttons: {\n                Close: function Close() {\n                    Galaxy.modal.hide();\n                }\n            }\n        });\n    },\n\n    showImportModal: function showImportModal(options) {\n        switch (options.source) {\n            case \"history\":\n                this.addFilesFromHistoryModal();\n                break;\n            case \"importdir\":\n                this.importFilesFromGalaxyFolderModal({\n                    source: \"importdir\"\n                });\n                break;\n            case \"path\":\n                this.importFilesFromPathModal();\n                break;\n            case \"userdir\":\n                this.importFilesFromGalaxyFolderModal({\n                    source: \"userdir\"\n                });\n                break;\n            default:\n                Galaxy.libraries.library_router.back();\n                _toastr2.default.error(\"Invalid import source.\");\n                break;\n        }\n    },\n\n    /**\n     * Show user the prompt to change the number of items shown on page.\n     */\n    showPageSizePrompt: function showPageSizePrompt(e) {\n        e.preventDefault();\n        var folder_page_size = prompt(\"How many items per page do you want to see?\", Galaxy.libraries.preferences.get(\"folder_page_size\"));\n        if (folder_page_size != null && folder_page_size == parseInt(folder_page_size)) {\n            Galaxy.libraries.preferences.set({\n                folder_page_size: parseInt(folder_page_size)\n            });\n            Galaxy.libraries.folderListView.render({\n                id: this.options.id,\n                show_page: 1\n            });\n        }\n    },\n\n    findCheckedRows: function findCheckedRows() {\n        return $(\"#folder_list_body\").find(\":checked\");\n    },\n\n    templateToolBar: function templateToolBar() {\n        return _.template([\n        // container start\n        '<div class=\"library_style_container\">',\n        // toolbar start\n        '<div id=\"library_toolbar\">', '<form class=\"form-inline\" role=\"form\">', \"<span><strong>DATA LIBRARIES</strong></span>\",\n        // paginator will append here\n        '<span class=\"library-paginator folder-paginator\"></span>', '<div class=\"checkbox toolbar-item logged-dataset-manipulation\" style=\"height: 20px; display:none;\">', \"<label>\", '<input id=\"include_deleted_datasets_chk\" type=\"checkbox\">include deleted</input>', \"</label>\", \"</div>\", '<button style=\"display:none;\" data-toggle=\"tooltip\" data-placement=\"top\" title=\"Create New Folder\" id=\"toolbtn_create_folder\" class=\"btn btn-default primary-button add-library-items toolbar-item\" type=\"button\">', '<span class=\"fa fa-plus\"></span><span class=\"fa fa-folder\"></span>', \"</button>\", \"<% if(mutiple_add_dataset_options) { %>\", '<div class=\"btn-group add-library-items\" style=\"display:none;\">', '<button title=\"Add Datasets to Current Folder\" id=\"\" type=\"button\" class=\"primary-button dropdown-toggle\" data-toggle=\"dropdown\">', '<span class=\"fa fa-plus\"></span><span class=\"fa fa-file\"></span><span class=\"caret\"></span>', \"</button>\", '<ul class=\"dropdown-menu\" role=\"menu\">', '<li><a href=\"#folders/<%= id %>/import/history\"> from History</a></li>', \"<% if(Galaxy.config.user_library_import_dir !== null) { %>\", '<li><a href=\"#folders/<%= id %>/import/userdir\"> from User Directory</a></li>', \"<% } %>\", \"<% if(Galaxy.config.allow_library_path_paste) { %>\", '<li class=\"divider\"></li>', '<li class=\"dropdown-header\">Admins only</li>', \"<% if(Galaxy.config.library_import_dir !== null) { %>\", '<li><a href=\"#folders/<%= id %>/import/importdir\">from Import Directory</a></li>', \"<% } %>\", \"<% if(Galaxy.config.allow_library_path_paste) { %>\", '<li><a href=\"#folders/<%= id %>/import/path\">from Path</a></li>', \"<% } %>\", \"<% } %>\", \"</ul>\", \"</div>\", \"<% } else { %>\", '<a  data-placement=\"top\" title=\"Add Datasets to Current Folder\" style=\"display:none;\" class=\"btn btn-default add-library-items\" href=\"#folders/<%= id %>/import/history\" role=\"button\">', '<span class=\"fa fa-plus\"></span><span class=\"fa fa-file\"></span>', \"</a>\", \"<% } %>\", '<button data-toggle=\"tooltip\" data-placement=\"top\" title=\"Import selected datasets into history\" id=\"toolbtn_bulk_import\" class=\"primary-button dataset-manipulation\" style=\"margin-left: 0.5em; display:none;\" type=\"button\">', '<span class=\"fa fa-book\"></span>', \"&nbsp;to History\", \"</button>\", '<div class=\"btn-group dataset-manipulation\" style=\"margin-left: 0.5em; display:none; \">', '<button title=\"Download selected items as archive\" type=\"button\" class=\"primary-button dropdown-toggle\" data-toggle=\"dropdown\">', '<span class=\"fa fa-download\"></span> Download <span class=\"caret\"></span>', \"</button>\", '<ul class=\"dropdown-menu\" role=\"menu\">', '<li><a href=\"#/folders/<%= id %>/download/tgz\">.tar.gz</a></li>', '<li><a href=\"#/folders/<%= id %>/download/tbz\">.tar.bz</a></li>', '<li><a href=\"#/folders/<%= id %>/download/zip\">.zip</a></li>', \"</ul>\", \"</div>\", '<button data-toggle=\"tooltip\" data-placement=\"top\" title=\"Mark selected items deleted\" id=\"toolbtn_bulk_delete\" class=\"primary-button logged-dataset-manipulation\" style=\"margin-left: 0.5em; display:none; \" type=\"button\">', '<span class=\"fa fa-times\"></span> Delete</button>', '<button data-id=\"<%- id %>\" data-toggle=\"tooltip\" data-placement=\"top\" title=\"Show location details\" class=\"primary-button toolbtn-show-locinfo\" style=\"margin-left: 0.5em;\" type=\"button\">', '<span class=\"fa fa-info-circle\"></span>', \"&nbsp;Details\", \"</button>\", '<span class=\"help-button\" data-toggle=\"tooltip\" data-placement=\"top\" title=\"See this screen annotated\">', '<a href=\"https://galaxyproject.org/data-libraries/screen/folder-contents/\" target=\"_blank\">', '<button class=\"primary-button\" type=\"button\">', '<span class=\"fa fa-question-circle\"></span>', \"&nbsp;Help\", \"</button>\", \"</a>\", \"</span>\", \"</div>\", \"</form>\",\n        // toolbar end\n        '<div id=\"folder_items_element\">', \"</div>\",\n        // paginator will append here\n        '<div class=\"folder-paginator paginator-bottom\"></div>',\n        // container end\n        \"</div>\"].join(\"\"));\n    },\n\n    templateLocInfoInModal: function templateLocInfoInModal() {\n        return _.template([\"<div>\", '<table class=\"grid table table-condensed\">', \"<thead>\", '<th style=\"width: 25%;\">library</th>', \"<th></th>\", \"</thead>\", \"<tbody>\", \"<tr>\", \"<td>name</td>\", '<td><%- library.get(\"name\") %></td>', \"</tr>\", '<% if(library.get(\"description\") !== \"\") { %>', \"<tr>\", \"<td>description</td>\", '<td><%- library.get(\"description\") %></td>', \"</tr>\", \"<% } %>\", '<% if(library.get(\"synopsis\") !== \"\") { %>', \"<tr>\", \"<td>synopsis</td>\", '<td><%- library.get(\"synopsis\") %></td>', \"</tr>\", \"<% } %>\", '<% if(library.get(\"create_time_pretty\") !== \"\") { %>', \"<tr>\", \"<td>created</td>\", '<td><span title=\"<%- library.get(\"create_time\") %>\"><%- library.get(\"create_time_pretty\") %></span></td>', \"</tr>\", \"<% } %>\", \"<tr>\", \"<td>id</td>\", '<td><%- library.get(\"id\") %></td>', \"</tr>\", \"</tbody>\", \"</table>\", '<table class=\"grid table table-condensed\">', \"<thead>\", '<th style=\"width: 25%;\">folder</th>', \"<th></th>\", \"</thead>\", \"<tbody>\", \"<tr>\", \"<td>name</td>\", \"<td><%- options.folder_name %></td>\", \"</tr>\", '<% if(options.folder_description !== \"\") { %>', \"<tr>\", \"<td>description</td>\", \"<td><%- options.folder_description %></td>\", \"</tr>\", \"<% } %>\", \"<tr>\", \"<td>id</td>\", \"<td><%- options.id %></td>\", \"</tr>\", \"</tbody>\", \"</table>\", \"</div>\"].join(\"\"));\n    },\n\n    templateNewFolderInModal: function templateNewFolderInModal() {\n        return _.template(['<div id=\"new_folder_modal\">', \"<form>\", '<input type=\"text\" name=\"Name\" value=\"\" placeholder=\"Name\" autofocus>', '<input type=\"text\" name=\"Description\" value=\"\" placeholder=\"Description\">', \"</form>\", \"</div>\"].join(\"\"));\n    },\n\n    templateBulkImportInModal: function templateBulkImportInModal() {\n        return _.template([\"<div>\", '<div class=\"library-modal-item\">', \"Select history: \", '<select id=\"dataset_import_bulk\" name=\"dataset_import_bulk\" style=\"width:50%; margin-bottom: 1em; \" autofocus>', \"<% _.each(histories, function(history) { %>\", '<option value=\"<%= _.escape(history.get(\"id\")) %>\"><%= _.escape(history.get(\"name\")) %></option>', \"<% }); %>\", \"</select>\", \"</div>\", '<div class=\"library-modal-item\">', \"or create new: \", '<input type=\"text\" name=\"history_name\" value=\"\" placeholder=\"name of the new history\" style=\"width:50%;\">', \"</input>\", \"</div>\", \"</div>\"].join(\"\"));\n    },\n\n    templateImportIntoHistoryProgressBar: function templateImportIntoHistoryProgressBar() {\n        return _.template(['<div class=\"import_text\">', \"Importing selected items to history <b><%= _.escape(history_name) %></b>\", \"</div>\", '<div class=\"progress\">', '<div class=\"progress-bar progress-bar-import\" role=\"progressbar\" aria-valuenow=\"0\" aria-valuemin=\"0\" aria-valuemax=\"100\" style=\"width: 00%;\">', '<span class=\"completion_span\">0% Complete</span>', \"</div>\", \"</div>\"].join(\"\"));\n    },\n\n    templateAddingDatasetsProgressBar: function templateAddingDatasetsProgressBar() {\n        return _.template(['<div class=\"import_text\">', \"Adding selected datasets to library folder <b><%= _.escape(folder_name) %></b>\", \"</div>\", '<div class=\"progress\">', '<div class=\"progress-bar progress-bar-import\" role=\"progressbar\" aria-valuenow=\"0\" aria-valuemin=\"0\" aria-valuemax=\"100\" style=\"width: 00%;\">', '<span class=\"completion_span\">0% Complete</span>', \"</div>\", \"</div>\"].join(\"\"));\n    },\n\n    templateDeletingItemsProgressBar: function templateDeletingItemsProgressBar() {\n        return _.template(['<div class=\"import_text\">', \"</div>\", '<div class=\"progress\">', '<div class=\"progress-bar progress-bar-import\" role=\"progressbar\" aria-valuenow=\"0\" aria-valuemin=\"0\" aria-valuemax=\"100\" style=\"width: 00%;\">', '<span class=\"completion_span\">0% Complete</span>', \"</div>\", \"</div>\"].join(\"\"));\n    },\n\n    templateBrowserModal: function templateBrowserModal() {\n        return _.template(['<div id=\"file_browser_modal\">', '<div class=\"alert alert-info jstree-files-message\">All files you select will be imported into the current folder ignoring their folder structure.</div>', '<div class=\"alert alert-info jstree-folders-message\" style=\"display:none;\">All files within the selected folders and their subfolders will be imported into the current folder.</div>', '<div style=\"margin-bottom:1em;\">', '<label title=\"Switch to selecting files\" class=\"radio-inline import-type-switch\">', '<input type=\"radio\" name=\"jstree-radio\" value=\"jstree-disable-folders\" checked=\"checked\"> Choose Files', \"</label>\", '<label title=\"Switch to selecting folders\" class=\"radio-inline import-type-switch\">', '<input type=\"radio\" name=\"jstree-radio\" value=\"jstree-disable-files\"> Choose Folders', \"</label>\", \"</div>\", '<div style=\"margin-bottom:1em;\">', '<label class=\"checkbox-inline jstree-preserve-structure\" style=\"display:none;\">', '<input class=\"preserve-checkbox\" type=\"checkbox\" value=\"preserve_directory_structure\">', \"Preserve directory structure\", \"</label>\", '<label class=\"checkbox-inline\">', '<input class=\"link-checkbox\" type=\"checkbox\" value=\"link_files\">', \"Link files instead of copying\", \"</label>\", '<label class=\"checkbox-inline\">', '<input class=\"posix-checkbox\" type=\"checkbox\" value=\"to_posix_lines\" checked=\"checked\">', \"Convert line endings to POSIX\", \"</label>\", '<label class=\"checkbox-inline\">', '<input class=\"spacetab-checkbox\" type=\"checkbox\" value=\"space_to_tab\">', \"Convert spaces to tabs\", \"</label>\", \"</div>\", '<button title=\"Select all files\" type=\"button\" class=\"button primary-button libimport-select-all\">', \"Select all\", \"</button>\", '<button title=\"Select no files\" type=\"button\" class=\"button primary-button libimport-select-none\">', \"Unselect all\", \"</button>\", \"<hr />\",\n        // append jstree object here\n        '<div id=\"jstree_browser\">', \"</div>\", \"<hr />\", \"<p>You can set extension type and genome for all imported datasets at once:</p>\", \"<div>\", 'Type: <span id=\"library_extension_select\" class=\"library-extension-select\" />', 'Genome: <span id=\"library_genome_select\" class=\"library-genome-select\" />', \"</div>\", \"<br>\", \"<div>\", '<label class=\"checkbox-inline tag-files\">', \"Tag datasets based on file names\", '<input class=\"tag-files\" type=\"checkbox\" value=\"tag_using_filenames\">', \"</label>\", \"</div>\", \"</div>\"].join(\"\"));\n    },\n\n    templateImportPathModal: function templateImportPathModal() {\n        return _.template(['<div id=\"file_browser_modal\">', '<div class=\"alert alert-info jstree-folders-message\">All files within the given folders and their subfolders will be imported into the current folder.</div>', '<div style=\"margin-bottom: 0.5em;\">', '<label class=\"checkbox-inline\">', '<input class=\"preserve-checkbox\" type=\"checkbox\" value=\"preserve_directory_structure\">', \"Preserve directory structure\", \"</label>\", '<label class=\"checkbox-inline\">', '<input class=\"link-checkbox\" type=\"checkbox\" value=\"link_files\">', \"Link files instead of copying\", \"</label>\", \"<br>\", '<label class=\"checkbox-inline\">', '<input class=\"posix-checkbox\" type=\"checkbox\" value=\"to_posix_lines\" checked=\"checked\">', \"Convert line endings to POSIX\", \"</label>\", '<label class=\"checkbox-inline\">', '<input class=\"spacetab-checkbox\" type=\"checkbox\" value=\"space_to_tab\">', \"Convert spaces to tabs\", \"</label>\", \"</div>\", '<textarea id=\"import_paths\" class=\"form-control\" rows=\"5\" placeholder=\"Absolute paths (or paths relative to Galaxy root) separated by newline\" autofocus></textarea>', \"<hr />\", \"<p>You can set extension type and genome for all imported datasets at once:</p>\", \"<div>\", 'Type: <span id=\"library_extension_select\" class=\"library-extension-select\" />', 'Genome: <span id=\"library_genome_select\" class=\"library-genome-select\" />', \"</div>\", \"<div>\", '<label class=\"checkbox-inline tag-files\">', \"Tag datasets based on file names\", '<input class=\"tag-files\" type=\"checkbox\" value=\"tag_using_filenames\">', \"</label>\", \"</div>\", \"</div>\"].join(\"\"));\n    },\n\n    templateAddFilesFromHistory: function templateAddFilesFromHistory() {\n        return _.template(['<div id=\"add_files_modal\">', \"<div>\", \"1.&nbsp;Select history:&nbsp;\", '<select id=\"dataset_add_bulk\" name=\"dataset_add_bulk\" style=\"width:66%; \"> ', \"<% _.each(histories, function(history) { %>\", //history select box\n        '<option value=\"<%= _.escape(history.get(\"id\")) %>\"><%= _.escape(history.get(\"name\")) %></option>', \"<% }); %>\", \"</select>\", \"</div>\", \"<br/>\", '<div id=\"selected_history_content\">', \"</div>\", \"</div>\"].join(\"\"));\n    },\n\n    templateHistoryContents: function templateHistoryContents() {\n        return _.template([\"<p>2.&nbsp;Choose the datasets to import:</p>\", \"<div>\", '<button title=\"Select all datasets\" type=\"button\" class=\"button primary-button history-import-select-all\">', \"Select all\", \"</button>\", '<button title=\"Select all datasets\" type=\"button\" class=\"button primary-button history-import-unselect-all\">', \"Unselect all\", \"</button>\", \"</div>\", \"<br>\", \"<ul>\", \"<% _.each(history_contents, function(history_item) { %>\", '<% if (history_item.get(\"deleted\") != true ) { %>', '<% var item_name = history_item.get(\"name\") %>', '<% if (history_item.get(\"type\") === \"collection\") { %>', '<% var collection_type = history_item.get(\"collection_type\") %>', '<% if (collection_type === \"list\") { %>', '<li data-id=\"<%= _.escape(history_item.get(\"id\")) %>\" data-name=\"<%= _.escape(history_item.get(\"type\")) %>\">', \"<label>\", '<label title=\"<%= _.escape(item_name) %>\">', '<input style=\"margin: 0;\" type=\"checkbox\"> <%= _.escape(history_item.get(\"hid\")) %>: ', '<%= item_name.length > 75 ? _.escape(\"...\".concat(item_name.substr(-75))) : _.escape(item_name) %> (Dataset Collection)', \"</label>\", \"</li>\", \"<% } else { %>\", '<li><input style=\"margin: 0;\" type=\"checkbox\" onclick=\"return false;\" disabled=\"disabled\">', '<span title=\"You can convert this collection into a collection of type list using the Collection Tools\">', '<%= _.escape(history_item.get(\"hid\")) %>: ', '<%= item_name.length > 75 ? _.escape(\"...\".concat(item_name.substr(-75))) : _.escape(item_name) %> (Dataset Collection of type <%= _.escape(collection_type) %> not supported.)', \"</span>\", \"</li>\", \"<% } %>\", '<% } else if (history_item.get(\"visible\") === true && history_item.get(\"state\") === \"ok\") { %>', '<li data-id=\"<%= _.escape(history_item.get(\"id\")) %>\" data-name=\"<%= _.escape(history_item.get(\"type\")) %>\">', '<label title=\"<%= _.escape(item_name) %>\">', '<input style=\"margin: 0;\" type=\"checkbox\"> <%= _.escape(history_item.get(\"hid\")) %>: ', '<%= item_name.length > 75 ? _.escape(\"...\".concat(item_name.substr(-75))) : _.escape(item_name) %>', \"</label>\", \"</li>\", \"<% } %>\", \"<% } %>\", \"<% }); %>\", \"</ul>\"].join(\"\"));\n    },\n\n    templatePaginator: function templatePaginator() {\n        return _.template(['<ul class=\"pagination pagination-sm\">', \"<% if ( ( show_page - 1 ) > 0 ) { %>\", \"<% if ( ( show_page - 1 ) > page_count ) { %>\", // we are on higher page than total page count\n        '<li><a href=\"#folders/<%= id %>/page/1\"><span class=\"fa fa-angle-double-left\"></span></a></li>', '<li class=\"disabled\"><a href=\"#folders/<%= id %>/page/<% print( show_page ) %>\"><% print( show_page - 1 ) %></a></li>', \"<% } else { %>\", '<li><a href=\"#folders/<%= id %>/page/1\"><span class=\"fa fa-angle-double-left\"></span></a></li>', '<li><a href=\"#folders/<%= id %>/page/<% print( show_page - 1 ) %>\"><% print( show_page - 1 ) %></a></li>', \"<% } %>\", \"<% } else { %>\", // we are on the first page\n        '<li class=\"disabled\"><a href=\"#folders/<%= id %>/page/1\"><span class=\"fa fa-angle-double-left\"></span></a></li>', '<li class=\"disabled\"><a href=\"#folders/<%= id %>/page/<% print( show_page ) %>\"><% print( show_page - 1 ) %></a></li>', \"<% } %>\", '<li class=\"active\">', '<a href=\"#folders/<%= id %>/page/<% print( show_page ) %>\"><% print( show_page ) %></a>', \"</li>\", \"<% if ( ( show_page ) < page_count ) { %>\", '<li><a href=\"#folders/<%= id %>/page/<% print( show_page + 1 ) %>\"><% print( show_page + 1 ) %></a></li>', '<li><a href=\"#folders/<%= id %>/page/<% print( page_count ) %>\"><span class=\"fa fa-angle-double-right\"></span></a></li>', \"<% } else { %>\", '<li class=\"disabled\"><a href=\"#folders/<%= id %>/page/<% print( show_page  ) %>\"><% print( show_page + 1 ) %></a></li>', '<li class=\"disabled\"><a href=\"#folders/<%= id %>/page/<% print( page_count ) %>\"><span class=\"fa fa-angle-double-right\"></span></a></li>', \"<% } %>\", \"</ul>\", \"<span>\", ' <%- items_shown %> items shown <a href=\"\" data-toggle=\"tooltip\" data-placement=\"top\" title=\"currently <%- folder_page_size %> per page\" class=\"page_size_prompt\">(change)</a>', \"</span>\", \"<span>\", \" <%- total_items_count %> total\", \"</span>\"].join(\"\"));\n    }\n});\n\nexports.default = {\n    FolderToolbarView: FolderToolbarView\n};\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! libs/backbone */ 2), __webpack_require__(/*! underscore */ 1), __webpack_require__(/*! jquery */ 0), __webpack_require__(/*! jquery */ 0)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzAzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL2dhbGF4eS9zY3JpcHRzL212Yy9saWJyYXJ5L2xpYnJhcnktZm9sZGVydG9vbGJhci12aWV3LmpzP2Y2NWMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IF9sIGZyb20gXCJ1dGlscy9sb2NhbGl6YXRpb25cIjtcbmltcG9ydCBtb2RfdXRpbHMgZnJvbSBcInV0aWxzL3V0aWxzXCI7XG5pbXBvcnQgbW9kX3RvYXN0ciBmcm9tIFwibGlicy90b2FzdHJcIjtcbmltcG9ydCBtb2RfbGlicmFyeV9tb2RlbCBmcm9tIFwibXZjL2xpYnJhcnkvbGlicmFyeS1tb2RlbFwiO1xuaW1wb3J0IG1vZF9zZWxlY3QgZnJvbSBcIm12Yy91aS91aS1zZWxlY3RcIjtcbmltcG9ydCBcImxpYnMvanF1ZXJ5L2pzdHJlZVwiO1xudmFyIEZvbGRlclRvb2xiYXJWaWV3ID0gQmFja2JvbmUuVmlldy5leHRlbmQoe1xuICAgIGVsOiBcIiNjZW50ZXJcIixcblxuICAgIGV2ZW50czoge1xuICAgICAgICBcImNsaWNrICN0b29sYnRuX2NyZWF0ZV9mb2xkZXJcIjogXCJjcmVhdGVGb2xkZXJGcm9tTW9kYWxcIixcbiAgICAgICAgXCJjbGljayAjdG9vbGJ0bl9idWxrX2ltcG9ydFwiOiBcIm1vZGFsQnVsa0ltcG9ydFwiLFxuICAgICAgICBcImNsaWNrICNpbmNsdWRlX2RlbGV0ZWRfZGF0YXNldHNfY2hrXCI6IFwiY2hlY2tJbmNsdWRlRGVsZXRlZFwiLFxuICAgICAgICBcImNsaWNrICN0b29sYnRuX2J1bGtfZGVsZXRlXCI6IFwiZGVsZXRlU2VsZWN0ZWRJdGVtc1wiLFxuICAgICAgICBcImNsaWNrIC50b29sYnRuLXNob3ctbG9jaW5mb1wiOiBcInNob3dMb2NJbmZvXCIsXG4gICAgICAgIFwiY2xpY2sgLnBhZ2Vfc2l6ZV9wcm9tcHRcIjogXCJzaG93UGFnZVNpemVQcm9tcHRcIlxuICAgIH0sXG5cbiAgICBkZWZhdWx0czoge1xuICAgICAgICBjYW5fYWRkX2xpYnJhcnlfaXRlbTogZmFsc2UsXG4gICAgICAgIGNvbnRhaW5zX2ZpbGVfb3JfZm9sZGVyOiBmYWxzZSxcbiAgICAgICAgY2hhaW5fY2FsbF9jb250cm9sOiB7XG4gICAgICAgICAgICB0b3RhbF9udW1iZXI6IDAsXG4gICAgICAgICAgICBmYWlsZWRfbnVtYmVyOiAwXG4gICAgICAgIH0sXG4gICAgICAgIGRpc2FibGVkX2pzdHJlZV9lbGVtZW50OiBcImZvbGRlcnNcIlxuICAgIH0sXG5cbiAgICBtb2RhbDogbnVsbCxcblxuICAgIC8vIGRpcmVjdG9yeSBicm93c2luZyBvYmplY3RcbiAgICBqc3RyZWU6IG51bGwsXG5cbiAgICAvLyB1c2VyJ3MgaGlzdG9yaWVzXG4gICAgaGlzdG9yaWVzOiBudWxsLFxuXG4gICAgLy8gZ2Vub21lIHNlbGVjdFxuICAgIHNlbGVjdF9nZW5vbWU6IG51bGwsXG5cbiAgICAvLyBleHRlbnNpb24gc2VsZWN0XG4gICAgc2VsZWN0X2V4dGVuc2lvbjogbnVsbCxcblxuICAgIC8vIGV4dGVuc2lvbiB0eXBlc1xuICAgIGxpc3RfZXh0ZW5zaW9uczogW10sXG5cbiAgICAvLyBkYXRhdHlwZSBwbGFjZWhvbGRlciBmb3IgZXh0ZW5zaW9uIGF1dG8tZGV0ZWN0aW9uXG4gICAgYXV0bzoge1xuICAgICAgICBpZDogXCJhdXRvXCIsXG4gICAgICAgIHRleHQ6IFwiQXV0by1kZXRlY3RcIixcbiAgICAgICAgZGVzY3JpcHRpb246XG4gICAgICAgICAgICBcIlRoaXMgc3lzdGVtIHdpbGwgdHJ5IHRvIGRldGVjdCB0aGUgZmlsZSB0eXBlIGF1dG9tYXRpY2FsbHkuXCIgK1xuICAgICAgICAgICAgXCIgSWYgeW91ciBmaWxlIGlzIG5vdCBkZXRlY3RlZCBwcm9wZXJseSBhcyBvbmUgb2YgdGhlIGtub3duIGZvcm1hdHMsXCIgK1xuICAgICAgICAgICAgXCIgaXQgbW9zdCBsaWtlbHkgbWVhbnMgdGhhdCBpdCBoYXMgc29tZSBmb3JtYXQgcHJvYmxlbXMgKGUuZy4sIGRpZmZlcmVudFwiICtcbiAgICAgICAgICAgIFwiIG51bWJlciBvZiBjb2x1bW5zIG9uIGRpZmZlcmVudCByb3dzKS4gWW91IGNhbiBzdGlsbCBjb2VyY2UgdGhlIHN5c3RlbVwiICtcbiAgICAgICAgICAgIFwiIHRvIHNldCB5b3VyIGRhdGEgdG8gdGhlIGZvcm1hdCB5b3UgdGhpbmsgaXQgc2hvdWxkIGJlLlwiICtcbiAgICAgICAgICAgIFwiIFlvdSBjYW4gYWxzbyB1cGxvYWQgY29tcHJlc3NlZCBmaWxlcywgd2hpY2ggd2lsbCBhdXRvbWF0aWNhbGx5IGJlIGRlY29tcHJlc3NlZC5cIlxuICAgIH0sXG5cbiAgICAvLyBnZW5vbWVzXG4gICAgbGlzdF9nZW5vbWVzOiBbXSxcblxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gXy5kZWZhdWx0cyhvcHRpb25zIHx8IHt9LCB0aGlzLmRlZmF1bHRzKTtcbiAgICAgICAgdGhpcy5mZXRjaEV4dEFuZEdlbm9tZXMoKTtcbiAgICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICB9LFxuXG4gICAgcmVuZGVyOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IF8uZXh0ZW5kKHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG4gICAgICAgIHZhciB0b29sYmFyX3RlbXBsYXRlID0gdGhpcy50ZW1wbGF0ZVRvb2xCYXIoKTtcbiAgICAgICAgdmFyIHRlbXBsYXRlX2RlZmF1bHRzID0ge1xuICAgICAgICAgICAgaWQ6IHRoaXMub3B0aW9ucy5pZCxcbiAgICAgICAgICAgIGlzX2FkbWluOiBmYWxzZSxcbiAgICAgICAgICAgIGlzX2Fub255bTogdHJ1ZSxcbiAgICAgICAgICAgIG11dGlwbGVfYWRkX2RhdGFzZXRfb3B0aW9uczogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKEdhbGF4eS51c2VyKSB7XG4gICAgICAgICAgICB0ZW1wbGF0ZV9kZWZhdWx0cy5pc19hZG1pbiA9IEdhbGF4eS51c2VyLmlzQWRtaW4oKTtcbiAgICAgICAgICAgIHRlbXBsYXRlX2RlZmF1bHRzLmlzX2Fub255bSA9IEdhbGF4eS51c2VyLmlzQW5vbnltb3VzKCk7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgR2FsYXh5LmNvbmZpZy51c2VyX2xpYnJhcnlfaW1wb3J0X2RpciAhPT0gbnVsbCB8fFxuICAgICAgICAgICAgICAgIEdhbGF4eS5jb25maWcuYWxsb3dfbGlicmFyeV9wYXRoX3Bhc3RlICE9PSBmYWxzZSB8fFxuICAgICAgICAgICAgICAgIEdhbGF4eS5jb25maWcubGlicmFyeV9pbXBvcnRfZGlyICE9PSBudWxsXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZV9kZWZhdWx0cy5tdXRpcGxlX2FkZF9kYXRhc2V0X29wdGlvbnMgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuJGVsLmh0bWwodG9vbGJhcl90ZW1wbGF0ZSh0ZW1wbGF0ZV9kZWZhdWx0cykpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgZnJvbSBGb2xkZXJMaXN0VmlldyB3aGVuIG5lZWRlZC5cbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9IG9wdGlvbnMgY29tbW9uIG9wdGlvbnNcbiAgICAgKi9cbiAgICByZW5kZXJQYWdpbmF0b3I6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gXy5leHRlbmQodGhpcy5vcHRpb25zLCBvcHRpb25zKTtcbiAgICAgICAgdmFyIHBhZ2luYXRvcl90ZW1wbGF0ZSA9IHRoaXMudGVtcGxhdGVQYWdpbmF0b3IoKTtcbiAgICAgICAgJChcImJvZHlcIilcbiAgICAgICAgICAgIC5maW5kKFwiLmZvbGRlci1wYWdpbmF0b3JcIilcbiAgICAgICAgICAgIC5odG1sKFxuICAgICAgICAgICAgICAgIHBhZ2luYXRvcl90ZW1wbGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIGlkOiB0aGlzLm9wdGlvbnMuaWQsXG4gICAgICAgICAgICAgICAgICAgIHNob3dfcGFnZTogcGFyc2VJbnQodGhpcy5vcHRpb25zLnNob3dfcGFnZSksXG4gICAgICAgICAgICAgICAgICAgIHBhZ2VfY291bnQ6IHBhcnNlSW50KHRoaXMub3B0aW9ucy5wYWdlX2NvdW50KSxcbiAgICAgICAgICAgICAgICAgICAgdG90YWxfaXRlbXNfY291bnQ6IHRoaXMub3B0aW9ucy50b3RhbF9pdGVtc19jb3VudCxcbiAgICAgICAgICAgICAgICAgICAgaXRlbXNfc2hvd246IHRoaXMub3B0aW9ucy5pdGVtc19zaG93bixcbiAgICAgICAgICAgICAgICAgICAgZm9sZGVyX3BhZ2Vfc2l6ZTogR2FsYXh5LmxpYnJhcmllcy5wcmVmZXJlbmNlcy5nZXQoXCJmb2xkZXJfcGFnZV9zaXplXCIpXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICk7XG4gICAgfSxcblxuICAgIGNvbmZpZ3VyZUVsZW1lbnRzOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IF8uZXh0ZW5kKHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5jYW5fYWRkX2xpYnJhcnlfaXRlbSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgJChcIi5hZGQtbGlicmFyeS1pdGVtc1wiKS5zaG93KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAkKFwiLmFkZC1saWJyYXJ5LWl0ZW1zXCIpLmhpZGUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmNvbnRhaW5zX2ZpbGVfb3JfZm9sZGVyID09PSB0cnVlKSB7XG4gICAgICAgICAgICBpZiAoR2FsYXh5LnVzZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUdhbGF4eS51c2VyLmlzQW5vbnltb3VzKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgJChcIi5sb2dnZWQtZGF0YXNldC1tYW5pcHVsYXRpb25cIikuc2hvdygpO1xuICAgICAgICAgICAgICAgICAgICAkKFwiLmRhdGFzZXQtbWFuaXB1bGF0aW9uXCIpLnNob3coKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAkKFwiLmRhdGFzZXQtbWFuaXB1bGF0aW9uXCIpLnNob3coKTtcbiAgICAgICAgICAgICAgICAgICAgJChcIi5sb2dnZWQtZGF0YXNldC1tYW5pcHVsYXRpb25cIikuaGlkZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgJChcIi5sb2dnZWQtZGF0YXNldC1tYW5pcHVsYXRpb25cIikuaGlkZSgpO1xuICAgICAgICAgICAgICAgICQoXCIuZGF0YXNldC1tYW5pcHVsYXRpb25cIikuaGlkZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJChcIi5sb2dnZWQtZGF0YXNldC1tYW5pcHVsYXRpb25cIikuaGlkZSgpO1xuICAgICAgICAgICAgJChcIi5kYXRhc2V0LW1hbmlwdWxhdGlvblwiKS5oaWRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4kZWwuZmluZChcIltkYXRhLXRvZ2dsZV1cIikudG9vbHRpcCgpO1xuICAgIH0sXG5cbiAgICAvLyBzaG93cyBtb2RhbCBmb3IgY3JlYXRpbmcgZm9sZGVyXG4gICAgY3JlYXRlRm9sZGVyRnJvbU1vZGFsOiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgICAgICAvLyBjcmVhdGUgbW9kYWxcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgdGVtcGxhdGUgPSB0aGlzLnRlbXBsYXRlTmV3Rm9sZGVySW5Nb2RhbCgpO1xuICAgICAgICB0aGlzLm1vZGFsID0gR2FsYXh5Lm1vZGFsO1xuICAgICAgICB0aGlzLm1vZGFsLnNob3coe1xuICAgICAgICAgICAgY2xvc2luZ19ldmVudHM6IHRydWUsXG4gICAgICAgICAgICB0aXRsZTogX2woXCJDcmVhdGUgTmV3IEZvbGRlclwiKSxcbiAgICAgICAgICAgIGJvZHk6IHRlbXBsYXRlKCksXG4gICAgICAgICAgICBidXR0b25zOiB7XG4gICAgICAgICAgICAgICAgQ3JlYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jcmVhdGVfbmV3X2ZvbGRlcl9ldmVudCgpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgQ2xvc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBHYWxheHkubW9kYWwuaGlkZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8vIGNyZWF0ZSB0aGUgbmV3IGZvbGRlciBmcm9tIG1vZGFsXG4gICAgY3JlYXRlX25ld19mb2xkZXJfZXZlbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZm9sZGVyRGV0YWlscyA9IHRoaXMuc2VyaWFsaXplX25ld19mb2xkZXIoKTtcbiAgICAgICAgaWYgKHRoaXMudmFsaWRhdGVfbmV3X2ZvbGRlcihmb2xkZXJEZXRhaWxzKSkge1xuICAgICAgICAgICAgdmFyIGZvbGRlciA9IG5ldyBtb2RfbGlicmFyeV9tb2RlbC5Gb2xkZXJBc01vZGVsKCk7XG4gICAgICAgICAgICB2YXIgdXJsX2l0ZW1zID0gQmFja2JvbmUuaGlzdG9yeS5mcmFnbWVudC5zcGxpdChcIi9cIik7XG4gICAgICAgICAgICB2YXIgY3VycmVudF9mb2xkZXJfaWQ7XG4gICAgICAgICAgICBpZiAodXJsX2l0ZW1zLmluZGV4T2YoXCJwYWdlXCIpID4gLTEpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50X2ZvbGRlcl9pZCA9IHVybF9pdGVtc1t1cmxfaXRlbXMubGVuZ3RoIC0gM107XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRfZm9sZGVyX2lkID0gdXJsX2l0ZW1zW3VybF9pdGVtcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvbGRlci51cmwgPSBmb2xkZXIudXJsUm9vdCArIGN1cnJlbnRfZm9sZGVyX2lkO1xuXG4gICAgICAgICAgICBmb2xkZXIuc2F2ZShmb2xkZXJEZXRhaWxzLCB7XG4gICAgICAgICAgICAgICAgc3VjY2VzczogZnVuY3Rpb24oZm9sZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIEdhbGF4eS5tb2RhbC5oaWRlKCk7XG4gICAgICAgICAgICAgICAgICAgIG1vZF90b2FzdHIuc3VjY2VzcyhcIkZvbGRlciBjcmVhdGVkLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgZm9sZGVyLnNldCh7IHR5cGU6IFwiZm9sZGVyXCIgfSk7XG4gICAgICAgICAgICAgICAgICAgIEdhbGF4eS5saWJyYXJpZXMuZm9sZGVyTGlzdFZpZXcuY29sbGVjdGlvbi5hZGQoZm9sZGVyKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGVycm9yOiBmdW5jdGlvbihtb2RlbCwgcmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgR2FsYXh5Lm1vZGFsLmhpZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByZXNwb25zZS5yZXNwb25zZUpTT04gIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZF90b2FzdHIuZXJyb3IocmVzcG9uc2UucmVzcG9uc2VKU09OLmVycl9tc2cpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9kX3RvYXN0ci5lcnJvcihcIkFuIGVycm9yIG9jY3VycmVkLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbW9kX3RvYXN0ci5lcnJvcihcIkZvbGRlcidzIG5hbWUgaXMgbWlzc2luZy5cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICAvLyBzZXJpYWxpemUgZGF0YSBmcm9tIHRoZSBtb2RhbFxuICAgIHNlcmlhbGl6ZV9uZXdfZm9sZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5hbWU6ICQoXCJpbnB1dFtuYW1lPSdOYW1lJ11cIikudmFsKCksXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogJChcImlucHV0W25hbWU9J0Rlc2NyaXB0aW9uJ11cIikudmFsKClcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgLy8gdmFsaWRhdGUgbmV3IGZvbGRlciBpbmZvXG4gICAgdmFsaWRhdGVfbmV3X2ZvbGRlcjogZnVuY3Rpb24oZm9sZGVyRGV0YWlscykge1xuICAgICAgICByZXR1cm4gZm9sZGVyRGV0YWlscy5uYW1lICE9PSBcIlwiO1xuICAgIH0sXG5cbiAgICAvLyBzaG93IGJ1bGsgaW1wb3J0IG1vZGFsXG4gICAgbW9kYWxCdWxrSW1wb3J0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyICRjaGVja2VkVmFsdWVzID0gdGhpcy5maW5kQ2hlY2tlZFJvd3MoKTtcbiAgICAgICAgaWYgKCRjaGVja2VkVmFsdWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgbW9kX3RvYXN0ci5pbmZvKFwiWW91IG11c3Qgc2VsZWN0IHNvbWUgZGF0YXNldHMgZmlyc3QuXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5oaXN0b3JpZXMgPSBuZXcgbW9kX2xpYnJhcnlfbW9kZWwuR2FsYXh5SGlzdG9yaWVzKCk7XG4gICAgICAgICAgICB0aGlzLmhpc3Rvcmllc1xuICAgICAgICAgICAgICAgIC5mZXRjaCgpXG4gICAgICAgICAgICAgICAgLmRvbmUoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGVtcGxhdGUgPSB0aGF0LnRlbXBsYXRlQnVsa0ltcG9ydEluTW9kYWwoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5tb2RhbCA9IEdhbGF4eS5tb2RhbDtcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5tb2RhbC5zaG93KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsb3NpbmdfZXZlbnRzOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IF9sKFwiSW1wb3J0IGludG8gSGlzdG9yeVwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IHRlbXBsYXRlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaXN0b3JpZXM6IHRoYXQuaGlzdG9yaWVzLm1vZGVsc1xuICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICBidXR0b25zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgSW1wb3J0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5pbXBvcnRBbGxJbnRvSGlzdG9yeSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQ2xvc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBHYWxheHkubW9kYWwuaGlkZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuZmFpbCgobW9kZWwsIHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcmVzcG9uc2UucmVzcG9uc2VKU09OICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RfdG9hc3RyLmVycm9yKHJlc3BvbnNlLnJlc3BvbnNlSlNPTi5lcnJfbXNnKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZF90b2FzdHIuZXJyb3IoXCJBbiBlcnJvciBvY2N1cnJlZC5cIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJbXBvcnQgYWxsIHNlbGVjdGVkIGRhdGFzZXRzIGludG8gaGlzdG9yeS5cbiAgICAgKi9cbiAgICBpbXBvcnRBbGxJbnRvSGlzdG9yeTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMubW9kYWwuZGlzYWJsZUJ1dHRvbihcIkltcG9ydFwiKTtcbiAgICAgICAgdmFyIG5ld19oaXN0b3J5X25hbWUgPSB0aGlzLm1vZGFsLiQoXCJpbnB1dFtuYW1lPWhpc3RvcnlfbmFtZV1cIikudmFsKCk7XG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgaWYgKG5ld19oaXN0b3J5X25hbWUgIT09IFwiXCIpIHtcbiAgICAgICAgICAgICQucG9zdChgJHtHYWxheHkucm9vdH1hcGkvaGlzdG9yaWVzYCwge1xuICAgICAgICAgICAgICAgIG5hbWU6IG5ld19oaXN0b3J5X25hbWVcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmRvbmUobmV3X2hpc3RvcnkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGF0Lm9wdGlvbnMubGFzdF91c2VkX2hpc3RvcnlfaWQgPSBuZXdfaGlzdG9yeS5pZDtcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5wcm9jZXNzSW1wb3J0VG9IaXN0b3J5KG5ld19oaXN0b3J5LmlkLCBuZXdfaGlzdG9yeS5uYW1lKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5mYWlsKCh4aHIsIHN0YXR1cywgZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbW9kX3RvYXN0ci5lcnJvcihcIkFuIGVycm9yIG9jY3VycmVkLlwiKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5hbHdheXMoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGF0Lm1vZGFsLmVuYWJsZUJ1dHRvbihcIkltcG9ydFwiKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBoaXN0b3J5X2lkID0gJChcInNlbGVjdFtuYW1lPWRhdGFzZXRfaW1wb3J0X2J1bGtdIG9wdGlvbjpzZWxlY3RlZFwiKS52YWwoKTtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5sYXN0X3VzZWRfaGlzdG9yeV9pZCA9IGhpc3RvcnlfaWQ7XG4gICAgICAgICAgICB2YXIgaGlzdG9yeV9uYW1lID0gJChcInNlbGVjdFtuYW1lPWRhdGFzZXRfaW1wb3J0X2J1bGtdIG9wdGlvbjpzZWxlY3RlZFwiKS50ZXh0KCk7XG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NJbXBvcnRUb0hpc3RvcnkoaGlzdG9yeV9pZCwgaGlzdG9yeV9uYW1lKTtcbiAgICAgICAgICAgIHRoaXMubW9kYWwuZW5hYmxlQnV0dG9uKFwiSW1wb3J0XCIpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHByb2Nlc3NJbXBvcnRUb0hpc3Rvcnk6IGZ1bmN0aW9uKGhpc3RvcnlfaWQsIGhpc3RvcnlfbmFtZSkge1xuICAgICAgICB2YXIgZGF0YXNldF9pZHMgPSBbXTtcbiAgICAgICAgdmFyIGZvbGRlcl9pZHMgPSBbXTtcbiAgICAgICAgdGhpcy5maW5kQ2hlY2tlZFJvd3MoKS5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHJvd19pZCA9ICQodGhpcylcbiAgICAgICAgICAgICAgICAuY2xvc2VzdChcInRyXCIpXG4gICAgICAgICAgICAgICAgLmRhdGEoXCJpZFwiKTtcbiAgICAgICAgICAgIGlmIChyb3dfaWQuc3Vic3RyaW5nKDAsIDEpID09IFwiRlwiKSB7XG4gICAgICAgICAgICAgICAgZm9sZGVyX2lkcy5wdXNoKHJvd19pZCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRhdGFzZXRfaWRzLnB1c2gocm93X2lkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIHByZXBhcmUgdGhlIGRhdGFzZXQgb2JqZWN0cyB0byBiZSBpbXBvcnRlZFxuICAgICAgICB2YXIgZGF0YXNldHNfdG9faW1wb3J0ID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSBkYXRhc2V0X2lkcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgdmFyIGxpYnJhcnlfZGF0YXNldF9pZCA9IGRhdGFzZXRfaWRzW2ldO1xuICAgICAgICAgICAgdmFyIGhpc3RvcnlJdGVtID0gbmV3IG1vZF9saWJyYXJ5X21vZGVsLkhpc3RvcnlJdGVtKCk7XG4gICAgICAgICAgICBoaXN0b3J5SXRlbS51cmwgPSBgJHtoaXN0b3J5SXRlbS51cmxSb290ICsgaGlzdG9yeV9pZH0vY29udGVudHNgO1xuICAgICAgICAgICAgaGlzdG9yeUl0ZW0uY29udGVudCA9IGxpYnJhcnlfZGF0YXNldF9pZDtcbiAgICAgICAgICAgIGhpc3RvcnlJdGVtLnNvdXJjZSA9IFwibGlicmFyeVwiO1xuICAgICAgICAgICAgZGF0YXNldHNfdG9faW1wb3J0LnB1c2goaGlzdG9yeUl0ZW0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcHJlcGFyZSB0aGUgZm9sZGVyIG9iamVjdHMgdG8gYmUgaW1wb3J0ZWRcbiAgICAgICAgdmFyIGZvbGRlcnNfdG9faW1wb3J0ID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSBmb2xkZXJfaWRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICB2YXIgbGlicmFyeV9mb2xkZXJfaWQgPSBmb2xkZXJfaWRzW2ldO1xuICAgICAgICAgICAgdmFyIGhpc3RvcnlJdGVtID0gbmV3IG1vZF9saWJyYXJ5X21vZGVsLkhpc3RvcnlJdGVtKCk7XG4gICAgICAgICAgICBoaXN0b3J5SXRlbS51cmwgPSBgJHtoaXN0b3J5SXRlbS51cmxSb290ICsgaGlzdG9yeV9pZH0vY29udGVudHNgO1xuICAgICAgICAgICAgaGlzdG9yeUl0ZW0uY29udGVudCA9IGxpYnJhcnlfZm9sZGVyX2lkO1xuICAgICAgICAgICAgaGlzdG9yeUl0ZW0uc291cmNlID0gXCJsaWJyYXJ5X2ZvbGRlclwiO1xuICAgICAgICAgICAgZGF0YXNldHNfdG9faW1wb3J0LnB1c2goaGlzdG9yeUl0ZW0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5pbml0Q2hhaW5DYWxsQ29udHJvbCh7XG4gICAgICAgICAgICBsZW5ndGg6IGRhdGFzZXRzX3RvX2ltcG9ydC5sZW5ndGgsXG4gICAgICAgICAgICBhY3Rpb246IFwidG9faGlzdG9yeVwiLFxuICAgICAgICAgICAgaGlzdG9yeV9uYW1lOiBoaXN0b3J5X25hbWVcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIHNldCB0aGUgdXNlZCBoaXN0b3J5IGFzIGN1cnJlbnQgc28gdXNlciB3aWxsIHNlZSB0aGUgbGFzdCBvbmVcbiAgICAgICAgLy8gdGhhdCBoZSBpbXBvcnRlZCBpbnRvIGluIHRoZSBoaXN0b3J5IHBhbmVsIG9uIHRoZSAnYW5hbHlzaXMnIHBhZ2VcbiAgICAgICAgalF1ZXJ5LmdldEpTT04oYCR7R2FsYXh5LnJvb3R9aGlzdG9yeS9zZXRfYXNfY3VycmVudD9pZD0ke2hpc3RvcnlfaWR9YCk7XG4gICAgICAgIHRoaXMuY2hhaW5DYWxsSW1wb3J0aW5nSW50b0hpc3RvcnkoZGF0YXNldHNfdG9faW1wb3J0LCBoaXN0b3J5X25hbWUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdGhlIHByb2dyZXNzIGJhciBpbiBtb2RhbCB3aW5kb3cuXG4gICAgICovXG4gICAgdXBkYXRlUHJvZ3Jlc3M6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnByb2dyZXNzICs9IHRoaXMucHJvZ3Jlc3NTdGVwO1xuICAgICAgICAkKFwiLnByb2dyZXNzLWJhci1pbXBvcnRcIikud2lkdGgoYCR7TWF0aC5yb3VuZCh0aGlzLnByb2dyZXNzKX0lYCk7XG4gICAgICAgIHZhciB0eHRfcmVwcmVzZW50YXRpb24gPSBgJHtNYXRoLnJvdW5kKHRoaXMucHJvZ3Jlc3MpfSUgQ29tcGxldGVgO1xuICAgICAgICAkKFwiLmNvbXBsZXRpb25fc3BhblwiKS50ZXh0KHR4dF9yZXByZXNlbnRhdGlvbik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGRvd25sb2FkIHNlbGVjdGVkIGRhdGFzZXRzXG4gICAgICogQHBhcmFtICB7c3RyfSBmb2xkZXJfaWQgaWQgb2YgdGhlIGN1cnJlbnQgZm9sZGVyXG4gICAgICogQHBhcmFtICB7c3RyfSBmb3JtYXQgICAgcmVxdWVzdGVkIGFyY2hpdmUgZm9ybWF0XG4gICAgICovXG4gICAgZG93bmxvYWQ6IGZ1bmN0aW9uKGZvbGRlcl9pZCwgZm9ybWF0KSB7XG4gICAgICAgIHZhciBkYXRhc2V0X2lkcyA9IFtdO1xuICAgICAgICB2YXIgZm9sZGVyX2lkcyA9IFtdO1xuICAgICAgICB0aGlzLmZpbmRDaGVja2VkUm93cygpLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgcm93X2lkID0gJCh0aGlzKVxuICAgICAgICAgICAgICAgIC5jbG9zZXN0KFwidHJcIilcbiAgICAgICAgICAgICAgICAuZGF0YShcImlkXCIpO1xuICAgICAgICAgICAgaWYgKHJvd19pZC5zdWJzdHJpbmcoMCwgMSkgPT0gXCJGXCIpIHtcbiAgICAgICAgICAgICAgICBmb2xkZXJfaWRzLnB1c2gocm93X2lkKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGF0YXNldF9pZHMucHVzaChyb3dfaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHVybCA9IGAke0dhbGF4eS5yb290fWFwaS9saWJyYXJpZXMvZGF0YXNldHMvZG93bmxvYWQvJHtmb3JtYXR9YDtcbiAgICAgICAgdmFyIGRhdGEgPSB7IGxkX2lkczogZGF0YXNldF9pZHMsIGZvbGRlcl9pZHM6IGZvbGRlcl9pZHMgfTtcbiAgICAgICAgdGhpcy5wcm9jZXNzRG93bmxvYWQodXJsLCBkYXRhLCBcImdldFwiKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGhpZGRlbiBmb3JtIGFuZCBzdWJtaXQgaXQgdGhyb3VnaCBQT1NUXG4gICAgICogdG8gaW5pdGlhbGl6ZSB0aGUgZG93bmxvYWQuXG4gICAgICogQHBhcmFtICB7c3RyfSB1cmwgICAgdXJsIHRvIGNhbGxcbiAgICAgKiBAcGFyYW0gIHtvYmp9IGRhdGEgICBkYXRhIHRvIGluY2x1ZGUgaW4gdGhlIHJlcXVlc3RcbiAgICAgKiBAcGFyYW0gIHtzdHJ9IG1ldGhvZCBtZXRob2Qgb2YgdGhlIHJlcXVlc3RcbiAgICAgKi9cbiAgICBwcm9jZXNzRG93bmxvYWQ6IGZ1bmN0aW9uKHVybCwgZGF0YSwgbWV0aG9kKSB7XG4gICAgICAgIGlmICh1cmwgJiYgZGF0YSkge1xuICAgICAgICAgICAgLy8gZGF0YSBjYW4gYmUgc3RyaW5nIG9mIHBhcmFtZXRlcnMgb3IgYXJyYXkvb2JqZWN0XG4gICAgICAgICAgICBkYXRhID0gdHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIgPyBkYXRhIDogJC5wYXJhbShkYXRhKTtcbiAgICAgICAgICAgIC8vIHNwbGl0IHBhcmFtcyBpbnRvIGZvcm0gaW5wdXRzXG4gICAgICAgICAgICB2YXIgaW5wdXRzID0gXCJcIjtcbiAgICAgICAgICAgICQuZWFjaChkYXRhLnNwbGl0KFwiJlwiKSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhaXIgPSB0aGlzLnNwbGl0KFwiPVwiKTtcbiAgICAgICAgICAgICAgICBpbnB1dHMgKz0gYDxpbnB1dCB0eXBlPVwiaGlkZGVuXCIgbmFtZT1cIiR7cGFpclswXX1cIiB2YWx1ZT1cIiR7cGFpclsxXX1cIiAvPmA7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIHNlbmQgcmVxdWVzdFxuICAgICAgICAgICAgJChgPGZvcm0gYWN0aW9uPVwiJHt1cmx9XCIgbWV0aG9kPVwiJHttZXRob2QgfHwgXCJwb3N0XCJ9XCI+JHtpbnB1dHN9PC9mb3JtPmApXG4gICAgICAgICAgICAgICAgLmFwcGVuZFRvKFwiYm9keVwiKVxuICAgICAgICAgICAgICAgIC5zdWJtaXQoKVxuICAgICAgICAgICAgICAgIC5yZW1vdmUoKTtcbiAgICAgICAgICAgIG1vZF90b2FzdHIuaW5mbyhcIllvdXIgZG93bmxvYWQgd2lsbCBiZWdpbiBzb29uLlwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1vZF90b2FzdHIuZXJyb3IoXCJBbiBlcnJvciBvY2N1cnJlZC5cIik7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgYWRkRmlsZXNGcm9tSGlzdG9yeU1vZGFsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5oaXN0b3JpZXMgPSBuZXcgbW9kX2xpYnJhcnlfbW9kZWwuR2FsYXh5SGlzdG9yaWVzKCk7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdGhpcy5oaXN0b3JpZXNcbiAgICAgICAgICAgIC5mZXRjaCgpXG4gICAgICAgICAgICAuZG9uZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgc2VsZi5tb2RhbCA9IEdhbGF4eS5tb2RhbDtcbiAgICAgICAgICAgICAgICB2YXIgdGVtcGxhdGVfbW9kYWwgPSBzZWxmLnRlbXBsYXRlQWRkRmlsZXNGcm9tSGlzdG9yeSgpO1xuICAgICAgICAgICAgICAgIHNlbGYubW9kYWwuc2hvdyh7XG4gICAgICAgICAgICAgICAgICAgIGNsb3NpbmdfZXZlbnRzOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogX2woXCJBZGRpbmcgZGF0YXNldHMgZnJvbSB5b3VyIGhpc3RvcnlcIiksXG4gICAgICAgICAgICAgICAgICAgIGJvZHk6IHRlbXBsYXRlX21vZGFsKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpc3Rvcmllczogc2VsZi5oaXN0b3JpZXMubW9kZWxzXG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICBidXR0b25zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBBZGQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuYWRkQWxsRGF0YXNldHNGcm9tSGlzdG9yeSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIENsb3NlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBHYWxheHkubW9kYWwuaGlkZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBjbG9zaW5nX2NhbGxiYWNrOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIEdhbGF4eS5saWJyYXJpZXMubGlicmFyeV9yb3V0ZXIubmF2aWdhdGUoYGZvbGRlcnMvJHtzZWxmLmlkfWAsIHsgdHJpZ2dlcjogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHNlbGYuZmV0Y2hBbmREaXNwbGF5SGlzdG9yeUNvbnRlbnRzKHNlbGYuaGlzdG9yaWVzLm1vZGVsc1swXS5pZCk7XG4gICAgICAgICAgICAgICAgJChcIiNkYXRhc2V0X2FkZF9idWxrXCIpLmNoYW5nZShldmVudCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZmV0Y2hBbmREaXNwbGF5SGlzdG9yeUNvbnRlbnRzKGV2ZW50LnRhcmdldC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmZhaWwoKG1vZGVsLCByZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcmVzcG9uc2UucmVzcG9uc2VKU09OICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIG1vZF90b2FzdHIuZXJyb3IocmVzcG9uc2UucmVzcG9uc2VKU09OLmVycl9tc2cpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG1vZF90b2FzdHIuZXJyb3IoXCJBbiBlcnJvciBvY2N1cnJlZC5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBtb2RhbCBmb3IgaW1wb3J0aW5nIGZyb20gR2FsYXh5IHBhdGguXG4gICAgICogVGhpcyBmZWF0dXJlIGlzIGFkbWluLW9ubHkuXG4gICAgICovXG4gICAgaW1wb3J0RmlsZXNGcm9tUGF0aE1vZGFsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICB0aGlzLm1vZGFsID0gR2FsYXh5Lm1vZGFsO1xuICAgICAgICB2YXIgdGVtcGxhdGVfbW9kYWwgPSB0aGlzLnRlbXBsYXRlSW1wb3J0UGF0aE1vZGFsKCk7XG4gICAgICAgIHRoaXMubW9kYWwuc2hvdyh7XG4gICAgICAgICAgICBjbG9zaW5nX2V2ZW50czogdHJ1ZSxcbiAgICAgICAgICAgIHRpdGxlOiBfbChcIlBsZWFzZSBlbnRlciBwYXRocyB0byBpbXBvcnRcIiksXG4gICAgICAgICAgICBib2R5OiB0ZW1wbGF0ZV9tb2RhbCh7fSksXG4gICAgICAgICAgICBidXR0b25zOiB7XG4gICAgICAgICAgICAgICAgSW1wb3J0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5pbXBvcnRGcm9tUGF0aHNDbGlja2VkKHRoYXQpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgQ2xvc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBHYWxheHkubW9kYWwuaGlkZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjbG9zaW5nX2NhbGxiYWNrOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAvLyAgVE9ETzogc2hvdWxkIG5vdCB0cmlnZ2VyIHJvdXRlcyBvdXRzaWRlIG9mIHRoZSByb3V0ZXJcbiAgICAgICAgICAgICAgICBHYWxheHkubGlicmFyaWVzLmxpYnJhcnlfcm91dGVyLm5hdmlnYXRlKGBmb2xkZXJzLyR7dGhhdC5pZH1gLCB7XG4gICAgICAgICAgICAgICAgICAgIHRyaWdnZXI6IHRydWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVuZGVyU2VsZWN0Qm94ZXMoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVxdWVzdCBhbGwgZXh0ZW5zaW9ucyBhbmQgZ2Vub21lcyBmcm9tIEdhbGF4eVxuICAgICAqIGFuZCBzYXZlIHRoZW0gc29ydGVkIGluIGFycmF5cy5cbiAgICAgKi9cbiAgICBmZXRjaEV4dEFuZEdlbm9tZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgIG1vZF91dGlscy5nZXQoe1xuICAgICAgICAgICAgdXJsOiBgJHtHYWxheHkucm9vdH1hcGkvZGF0YXR5cGVzP2V4dGVuc2lvbl9vbmx5PUZhbHNlYCxcbiAgICAgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uKGRhdGF0eXBlcykge1xuICAgICAgICAgICAgICAgIHRoYXQubGlzdF9leHRlbnNpb25zID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIGRhdGF0eXBlcykge1xuICAgICAgICAgICAgICAgICAgICB0aGF0Lmxpc3RfZXh0ZW5zaW9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBkYXRhdHlwZXNba2V5XS5leHRlbnNpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBkYXRhdHlwZXNba2V5XS5leHRlbnNpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogZGF0YXR5cGVzW2tleV0uZGVzY3JpcHRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbl91cmw6IGRhdGF0eXBlc1trZXldLmRlc2NyaXB0aW9uX3VybFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhhdC5saXN0X2V4dGVuc2lvbnMuc29ydCgoYSwgYikgPT4gKGEuaWQgPiBiLmlkID8gMSA6IGEuaWQgPCBiLmlkID8gLTEgOiAwKSk7XG4gICAgICAgICAgICAgICAgdGhhdC5saXN0X2V4dGVuc2lvbnMudW5zaGlmdCh0aGF0LmF1dG8pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNhY2hlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBtb2RfdXRpbHMuZ2V0KHtcbiAgICAgICAgICAgIHVybDogYCR7R2FsYXh5LnJvb3R9YXBpL2dlbm9tZXNgLFxuICAgICAgICAgICAgc3VjY2VzczogZnVuY3Rpb24oZ2Vub21lcykge1xuICAgICAgICAgICAgICAgIHRoYXQubGlzdF9nZW5vbWVzID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIGdlbm9tZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5saXN0X2dlbm9tZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogZ2Vub21lc1trZXldWzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogZ2Vub21lc1trZXldWzBdXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGF0Lmxpc3RfZ2Vub21lcy5zb3J0KChhLCBiKSA9PiAoYS5pZCA+IGIuaWQgPyAxIDogYS5pZCA8IGIuaWQgPyAtMSA6IDApKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjYWNoZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgcmVuZGVyU2VsZWN0Qm94ZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBUaGlzIHdvbid0IHdvcmsgcHJvcGVybHkgdW5sZXNzcyB3ZSBhbHJlYWR5IGhhdmUgdGhlIGRhdGEgZmV0Y2hlZC5cbiAgICAgICAgLy8gU2VlIHRoaXMuZmV0Y2hFeHRBbmRHZW5vbWVzKClcbiAgICAgICAgLy8gVE9ETyBzd2l0Y2ggdG8gY29tbW9uIHJlc291cmNlczpcbiAgICAgICAgLy8gaHR0cHM6Ly90cmVsbG8uY29tL2MvZElVRTlZUGwvMTkzMy11aS1jb21tb24tcmVzb3VyY2VzLWFuZC1kYXRhLWludG8tZ2FsYXh5LW9iamVjdFxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgIHRoaXMuc2VsZWN0X2dlbm9tZSA9IG5ldyBtb2Rfc2VsZWN0LlZpZXcoe1xuICAgICAgICAgICAgY3NzOiBcImxpYnJhcnktZ2Vub21lLXNlbGVjdFwiLFxuICAgICAgICAgICAgZGF0YTogdGhhdC5saXN0X2dlbm9tZXMsXG4gICAgICAgICAgICBjb250YWluZXI6IEdhbGF4eS5tb2RhbC4kZWwuZmluZChcIiNsaWJyYXJ5X2dlbm9tZV9zZWxlY3RcIiksXG4gICAgICAgICAgICB2YWx1ZTogXCI/XCJcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2VsZWN0X2V4dGVuc2lvbiA9IG5ldyBtb2Rfc2VsZWN0LlZpZXcoe1xuICAgICAgICAgICAgY3NzOiBcImxpYnJhcnktZXh0ZW5zaW9uLXNlbGVjdFwiLFxuICAgICAgICAgICAgZGF0YTogdGhhdC5saXN0X2V4dGVuc2lvbnMsXG4gICAgICAgICAgICBjb250YWluZXI6IEdhbGF4eS5tb2RhbC4kZWwuZmluZChcIiNsaWJyYXJ5X2V4dGVuc2lvbl9zZWxlY3RcIiksXG4gICAgICAgICAgICB2YWx1ZTogXCJhdXRvXCJcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBtb2RhbCBmb3IgaW1wb3J0aW5nIGZyb20gZ2l2ZW4gZGlyZWN0b3J5XG4gICAgICogb24gR2FsYXh5LiBCaW5kIGpRdWVyeSBldmVudHMuXG4gICAgICovXG4gICAgaW1wb3J0RmlsZXNGcm9tR2FsYXh5Rm9sZGVyTW9kYWw6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICB2YXIgdGVtcGxhdGVfbW9kYWwgPSB0aGlzLnRlbXBsYXRlQnJvd3Nlck1vZGFsKCk7XG4gICAgICAgIHRoaXMubW9kYWwgPSBHYWxheHkubW9kYWw7XG4gICAgICAgIHRoaXMubW9kYWwuc2hvdyh7XG4gICAgICAgICAgICBjbG9zaW5nX2V2ZW50czogdHJ1ZSxcbiAgICAgICAgICAgIHRpdGxlOiBfbChcIlBsZWFzZSBzZWxlY3QgZm9sZGVycyBvciBmaWxlc1wiKSxcbiAgICAgICAgICAgIGJvZHk6IHRlbXBsYXRlX21vZGFsKHt9KSxcbiAgICAgICAgICAgIGJ1dHRvbnM6IHtcbiAgICAgICAgICAgICAgICBJbXBvcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB0aGF0LmltcG9ydEZyb21Kc3RyZWVQYXRoKHRoYXQsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgQ2xvc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBHYWxheHkubW9kYWwuaGlkZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjbG9zaW5nX2NhbGxiYWNrOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAvLyAgVE9ETzogc2hvdWxkIG5vdCB0cmlnZ2VyIHJvdXRlcyBvdXRzaWRlIG9mIHRoZSByb3V0ZXJcbiAgICAgICAgICAgICAgICBHYWxheHkubGlicmFyaWVzLmxpYnJhcnlfcm91dGVyLm5hdmlnYXRlKGBmb2xkZXJzLyR7dGhhdC5pZH1gLCB7XG4gICAgICAgICAgICAgICAgICAgIHRyaWdnZXI6IHRydWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgJChcIi5saWJpbXBvcnQtc2VsZWN0LWFsbFwiKS5iaW5kKFwiY2xpY2tcIiwgKCkgPT4ge1xuICAgICAgICAgICAgJChcIiNqc3RyZWVfYnJvd3NlclwiKS5qc3RyZWUoXCJjaGVja19hbGxcIik7XG4gICAgICAgIH0pO1xuICAgICAgICAkKFwiLmxpYmltcG9ydC1zZWxlY3Qtbm9uZVwiKS5iaW5kKFwiY2xpY2tcIiwgKCkgPT4ge1xuICAgICAgICAgICAgJChcIiNqc3RyZWVfYnJvd3NlclwiKS5qc3RyZWUoXCJ1bmNoZWNrX2FsbFwiKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5yZW5kZXJTZWxlY3RCb3hlcygpO1xuICAgICAgICBvcHRpb25zLmRpc2FibGVkX2pzdHJlZV9lbGVtZW50ID0gXCJmb2xkZXJzXCI7XG4gICAgICAgIHRoaXMucmVuZGVySnN0cmVlKG9wdGlvbnMpO1xuXG4gICAgICAgICQoXCJpbnB1dFt0eXBlPXJhZGlvXVwiKS5jaGFuZ2UoZXZlbnQgPT4ge1xuICAgICAgICAgICAgaWYgKGV2ZW50LnRhcmdldC52YWx1ZSA9PT0gXCJqc3RyZWUtZGlzYWJsZS1mb2xkZXJzXCIpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmRpc2FibGVkX2pzdHJlZV9lbGVtZW50ID0gXCJmb2xkZXJzXCI7XG4gICAgICAgICAgICAgICAgdGhhdC5yZW5kZXJKc3RyZWUob3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgJChcIi5qc3RyZWUtZm9sZGVycy1tZXNzYWdlXCIpLmhpZGUoKTtcbiAgICAgICAgICAgICAgICAkKFwiLmpzdHJlZS1wcmVzZXJ2ZS1zdHJ1Y3R1cmVcIikuaGlkZSgpO1xuICAgICAgICAgICAgICAgICQoXCIuanN0cmVlLWZpbGVzLW1lc3NhZ2VcIikuc2hvdygpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChldmVudC50YXJnZXQudmFsdWUgPT09IFwianN0cmVlLWRpc2FibGUtZmlsZXNcIikge1xuICAgICAgICAgICAgICAgICQoXCIuanN0cmVlLWZpbGVzLW1lc3NhZ2VcIikuaGlkZSgpO1xuICAgICAgICAgICAgICAgICQoXCIuanN0cmVlLWZvbGRlcnMtbWVzc2FnZVwiKS5zaG93KCk7XG4gICAgICAgICAgICAgICAgJChcIi5qc3RyZWUtcHJlc2VydmUtc3RydWN0dXJlXCIpLnNob3coKTtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmRpc2FibGVkX2pzdHJlZV9lbGVtZW50ID0gXCJmaWxlc1wiO1xuICAgICAgICAgICAgICAgIHRoYXQucmVuZGVySnN0cmVlKG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmV0Y2ggdGhlIGNvbnRlbnRzIG9mIHVzZXIgZGlyZWN0b3J5IG9uIEdhbGF4eVxuICAgICAqIGFuZCByZW5kZXIganN0cmVlIGNvbXBvbmVudCBiYXNlZCBvbiByZWNlaXZlZFxuICAgICAqIGRhdGEuXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBvcHRpb25zIFtkZXNjcmlwdGlvbl1cbiAgICAgKi9cbiAgICByZW5kZXJKc3RyZWU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBfLmV4dGVuZCh0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuICAgICAgICB2YXIgdGFyZ2V0ID0gb3B0aW9ucy5zb3VyY2UgfHwgXCJ1c2VyZGlyXCI7XG4gICAgICAgIHZhciBkaXNhYmxlZF9qc3RyZWVfZWxlbWVudCA9IHRoaXMub3B0aW9ucy5kaXNhYmxlZF9qc3RyZWVfZWxlbWVudDtcbiAgICAgICAgdGhpcy5qc3RyZWUgPSBuZXcgbW9kX2xpYnJhcnlfbW9kZWwuSnN0cmVlKCk7XG4gICAgICAgIHRoaXMuanN0cmVlLnVybCA9IGAke3RoaXMuanN0cmVlLnVybFJvb3R9P3RhcmdldD0ke3RhcmdldH0mZm9ybWF0PWpzdHJlZSZkaXNhYmxlPSR7ZGlzYWJsZWRfanN0cmVlX2VsZW1lbnR9YDtcbiAgICAgICAgdGhpcy5qc3RyZWUuZmV0Y2goe1xuICAgICAgICAgICAgc3VjY2VzczogZnVuY3Rpb24obW9kZWwsIHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgJChcIiNqc3RyZWVfYnJvd3NlclwiKS5qc3RyZWUoXCJkZXN0cm95XCIpO1xuICAgICAgICAgICAgICAgICQoXCIjanN0cmVlX2Jyb3dzZXJcIikuanN0cmVlKHtcbiAgICAgICAgICAgICAgICAgICAgY29yZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogbW9kZWxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgcGx1Z2luczogW1widHlwZXNcIiwgXCJjaGVja2JveFwiXSxcbiAgICAgICAgICAgICAgICAgICAgdHlwZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvbGRlcjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGljb246IFwianN0cmVlLWZvbGRlclwiXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGljb246IFwianN0cmVlLWZpbGVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBjaGVja2JveDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyZWVfc3RhdGU6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlcnJvcjogZnVuY3Rpb24obW9kZWwsIHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByZXNwb25zZS5yZXNwb25zZUpTT04gIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnJlc3BvbnNlSlNPTi5lcnJfY29kZSA9PT0gNDA0MDAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RfdG9hc3RyLndhcm5pbmcocmVzcG9uc2UucmVzcG9uc2VKU09OLmVycl9tc2cpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9kX3RvYXN0ci5lcnJvcihyZXNwb25zZS5yZXNwb25zZUpTT04uZXJyX21zZyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtb2RfdG9hc3RyLmVycm9yKFwiQW4gZXJyb3Igb2NjdXJyZWQuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRha2UgdGhlIHBhdGhzIGZyb20gdGhlIHRleHRhcmVhLCBzcGxpdCBpdCwgY3JlYXRlXG4gICAgICogYSByZXF1ZXN0IHF1ZXVlIGFuZCBjYWxsIGEgZnVuY3Rpb24gdGhhdCBzdGFydHMgc2VuZGluZ1xuICAgICAqIG9uZSBieSBvbmUgdG8gYmUgaW1wb3J0ZWQgb24gdGhlIHNlcnZlci5cbiAgICAgKi9cbiAgICBpbXBvcnRGcm9tUGF0aHNDbGlja2VkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHByZXNlcnZlX2RpcnMgPSB0aGlzLm1vZGFsLiRlbC5maW5kKFwiLnByZXNlcnZlLWNoZWNrYm94XCIpLmlzKFwiOmNoZWNrZWRcIik7XG4gICAgICAgIHZhciBsaW5rX2RhdGEgPSB0aGlzLm1vZGFsLiRlbC5maW5kKFwiLmxpbmstY2hlY2tib3hcIikuaXMoXCI6Y2hlY2tlZFwiKTtcbiAgICAgICAgdmFyIHNwYWNlX3RvX3RhYiA9IHRoaXMubW9kYWwuJGVsLmZpbmQoXCIuc3BhY2V0YWItY2hlY2tib3hcIikuaXMoXCI6Y2hlY2tlZFwiKTtcbiAgICAgICAgdmFyIHRvX3Bvc2l4X2xpbmVzID0gdGhpcy5tb2RhbC4kZWwuZmluZChcIi5wb3NpeC1jaGVja2JveFwiKS5pcyhcIjpjaGVja2VkXCIpO1xuICAgICAgICB2YXIgdGFnX3VzaW5nX2ZpbGVuYW1lcyA9IHRoaXMubW9kYWwuJGVsLmZpbmQoXCIudGFnLWZpbGVzXCIpLmlzKFwiOmNoZWNrZWRcIik7XG4gICAgICAgIHZhciBmaWxlX3R5cGUgPSB0aGlzLnNlbGVjdF9leHRlbnNpb24udmFsdWUoKTtcbiAgICAgICAgdmFyIGRia2V5ID0gdGhpcy5zZWxlY3RfZ2Vub21lLnZhbHVlKCk7XG4gICAgICAgIHZhciBwYXRocyA9ICQoXCJ0ZXh0YXJlYSNpbXBvcnRfcGF0aHNcIikudmFsKCk7XG4gICAgICAgIHZhciB2YWxpZF9wYXRocyA9IFtdO1xuICAgICAgICBpZiAoIXBhdGhzKSB7XG4gICAgICAgICAgICBtb2RfdG9hc3RyLmluZm8oXCJQbGVhc2UgZW50ZXIgYSBwYXRoIHJlbGF0aXZlIHRvIEdhbGF4eSByb290LlwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubW9kYWwuZGlzYWJsZUJ1dHRvbihcIkltcG9ydFwiKTtcbiAgICAgICAgICAgIHBhdGhzID0gcGF0aHMuc3BsaXQoXCJcXG5cIik7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gcGF0aHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICB2YXIgdHJpbW1lZCA9IHBhdGhzW2ldLnRyaW0oKTtcbiAgICAgICAgICAgICAgICBpZiAodHJpbW1lZC5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRfcGF0aHMucHVzaCh0cmltbWVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmluaXRDaGFpbkNhbGxDb250cm9sKHtcbiAgICAgICAgICAgICAgICBsZW5ndGg6IHZhbGlkX3BhdGhzLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBhY3Rpb246IFwiYWRkaW5nX2RhdGFzZXRzXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5jaGFpbkNhbGxJbXBvcnRpbmdGb2xkZXJzKHtcbiAgICAgICAgICAgICAgICBwYXRoczogdmFsaWRfcGF0aHMsXG4gICAgICAgICAgICAgICAgcHJlc2VydmVfZGlyczogcHJlc2VydmVfZGlycyxcbiAgICAgICAgICAgICAgICBsaW5rX2RhdGE6IGxpbmtfZGF0YSxcbiAgICAgICAgICAgICAgICBzcGFjZV90b190YWI6IHNwYWNlX3RvX3RhYixcbiAgICAgICAgICAgICAgICB0b19wb3NpeF9saW5lczogdG9fcG9zaXhfbGluZXMsXG4gICAgICAgICAgICAgICAgc291cmNlOiBcImFkbWluX3BhdGhcIixcbiAgICAgICAgICAgICAgICBmaWxlX3R5cGU6IGZpbGVfdHlwZSxcbiAgICAgICAgICAgICAgICB0YWdfdXNpbmdfZmlsZW5hbWVzOiB0YWdfdXNpbmdfZmlsZW5hbWVzLFxuICAgICAgICAgICAgICAgIGRia2V5OiBkYmtleVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSB0aGUgY29udHJvbCBvZiBjaGFpbmluZyByZXF1ZXN0c1xuICAgICAqIGluIHRoZSBjdXJyZW50IG1vZGFsLlxuICAgICAqIEBwYXJhbSB7aW50fSBsZW5ndGggVGhlIG51bWJlciBvZiBpdGVtcyBpbiB0aGUgY2hhaW4gY2FsbC5cbiAgICAgKi9cbiAgICBpbml0Q2hhaW5DYWxsQ29udHJvbDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICB2YXIgdGVtcGxhdGU7XG4gICAgICAgIHN3aXRjaCAob3B0aW9ucy5hY3Rpb24pIHtcbiAgICAgICAgICAgIGNhc2UgXCJhZGRpbmdfZGF0YXNldHNcIjpcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZSA9IHRoaXMudGVtcGxhdGVBZGRpbmdEYXRhc2V0c1Byb2dyZXNzQmFyKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5tb2RhbC4kZWwuZmluZChcIi5tb2RhbC1ib2R5XCIpLmh0bWwoXG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvbGRlcl9uYW1lOiB0aGlzLm9wdGlvbnMuZm9sZGVyX25hbWVcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImRlbGV0aW5nX2RhdGFzZXRzXCI6XG4gICAgICAgICAgICAgICAgdGVtcGxhdGUgPSB0aGlzLnRlbXBsYXRlRGVsZXRpbmdJdGVtc1Byb2dyZXNzQmFyKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5tb2RhbC4kZWwuZmluZChcIi5tb2RhbC1ib2R5XCIpLmh0bWwodGVtcGxhdGUoKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwidG9faGlzdG9yeVwiOlxuICAgICAgICAgICAgICAgIHRlbXBsYXRlID0gdGhpcy50ZW1wbGF0ZUltcG9ydEludG9IaXN0b3J5UHJvZ3Jlc3NCYXIoKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGFsLiRlbC5maW5kKFwiLm1vZGFsLWJvZHlcIikuaHRtbCh0ZW1wbGF0ZSh7IGhpc3RvcnlfbmFtZTogb3B0aW9ucy5oaXN0b3J5X25hbWUgfSkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBHYWxheHkuZW1pdC5lcnJvcihcIldyb25nIGFjdGlvbiBzcGVjaWZpZWQuXCIsIFwiZGF0YWxpYnNcIik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB2YXIgcHJvZ3Jlc3NfYmFyX3RtcGwgPSB0aGlzLnRlbXBsYXRlQWRkaW5nRGF0YXNldHNQcm9ncmVzc0JhcigpO1xuICAgICAgICAvLyB0aGlzLm1vZGFsLiRlbC5maW5kKCAnLm1vZGFsLWJvZHknICkuaHRtbCggcHJvZ3Jlc3NfYmFyX3RtcGwoIHsgZm9sZGVyX25hbWUgOiB0aGlzLm9wdGlvbnMuZm9sZGVyX25hbWUgfSApICk7XG4gICAgICAgIHRoaXMucHJvZ3Jlc3MgPSAwO1xuICAgICAgICB0aGlzLnByb2dyZXNzU3RlcCA9IDEwMCAvIG9wdGlvbnMubGVuZ3RoO1xuICAgICAgICB0aGlzLm9wdGlvbnMuY2hhaW5fY2FsbF9jb250cm9sLnRvdGFsX251bWJlciA9IG9wdGlvbnMubGVuZ3RoO1xuICAgICAgICB0aGlzLm9wdGlvbnMuY2hhaW5fY2FsbF9jb250cm9sLmZhaWxlZF9udW1iZXIgPSAwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUYWtlIHRoZSBzZWxlY3RlZCBpdGVtcyBmcm9tIHRoZSBqc3RyZWUsIGNyZWF0ZSBhIHJlcXVlc3QgcXVldWVcbiAgICAgKiBhbmQgc2VuZCB0aGVtIG9uZSBieSBvbmUgdG8gdGhlIHNlcnZlciBmb3IgaW1wb3J0aW5nIGludG9cbiAgICAgKiB0aGUgY3VycmVudCBmb2xkZXIuXG4gICAgICpcbiAgICAgKiBqc3RyZWUuanMgaGFzIHRvIGJlIGxvYWRlZCBiZWZvcmVcbiAgICAgKiBAc2VlIHJlbmRlckpzdHJlZVxuICAgICAqL1xuICAgIGltcG9ydEZyb21Kc3RyZWVQYXRoOiBmdW5jdGlvbih0aGF0LCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBhbGxfbm9kZXMgPSAkKFwiI2pzdHJlZV9icm93c2VyXCIpXG4gICAgICAgICAgICAuanN0cmVlKClcbiAgICAgICAgICAgIC5nZXRfc2VsZWN0ZWQodHJ1ZSk7XG4gICAgICAgIC8vIHJlbW92ZSB0aGUgZGlzYWJsZWQgZWxlbWVudHMgdGhhdCBjb3VsZCBoYXZlIGJlZW4gdHJpZ2VycmVkIHdpdGggdGhlICdzZWxlY3QgYWxsJ1xuICAgICAgICB2YXIgc2VsZWN0ZWRfbm9kZXMgPSBfLmZpbHRlcihhbGxfbm9kZXMsIG5vZGUgPT4gbm9kZS5zdGF0ZS5kaXNhYmxlZCA9PSBmYWxzZSk7XG4gICAgICAgIHZhciBwcmVzZXJ2ZV9kaXJzID0gdGhpcy5tb2RhbC4kZWwuZmluZChcIi5wcmVzZXJ2ZS1jaGVja2JveFwiKS5pcyhcIjpjaGVja2VkXCIpO1xuICAgICAgICB2YXIgbGlua19kYXRhID0gdGhpcy5tb2RhbC4kZWwuZmluZChcIi5saW5rLWNoZWNrYm94XCIpLmlzKFwiOmNoZWNrZWRcIik7XG4gICAgICAgIHZhciBzcGFjZV90b190YWIgPSB0aGlzLm1vZGFsLiRlbC5maW5kKFwiLnNwYWNldGFiLWNoZWNrYm94XCIpLmlzKFwiOmNoZWNrZWRcIik7XG4gICAgICAgIHZhciB0b19wb3NpeF9saW5lcyA9IHRoaXMubW9kYWwuJGVsLmZpbmQoXCIucG9zaXgtY2hlY2tib3hcIikuaXMoXCI6Y2hlY2tlZFwiKTtcbiAgICAgICAgdmFyIGZpbGVfdHlwZSA9IHRoaXMuc2VsZWN0X2V4dGVuc2lvbi52YWx1ZSgpO1xuICAgICAgICB2YXIgZGJrZXkgPSB0aGlzLnNlbGVjdF9nZW5vbWUudmFsdWUoKTtcbiAgICAgICAgdmFyIHRhZ191c2luZ19maWxlbmFtZXMgPSB0aGlzLm1vZGFsLiRlbC5maW5kKFwiLnRhZy1maWxlc1wiKS5pcyhcIjpjaGVja2VkXCIpO1xuICAgICAgICB2YXIgc2VsZWN0aW9uX3R5cGUgPSBzZWxlY3RlZF9ub2Rlc1swXS50eXBlO1xuICAgICAgICB2YXIgcGF0aHMgPSBbXTtcbiAgICAgICAgaWYgKHNlbGVjdGVkX25vZGVzLmxlbmd0aCA8IDEpIHtcbiAgICAgICAgICAgIG1vZF90b2FzdHIuaW5mbyhcIlBsZWFzZSBzZWxlY3Qgc29tZSBpdGVtcyBmaXJzdC5cIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm1vZGFsLmRpc2FibGVCdXR0b24oXCJJbXBvcnRcIik7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gc2VsZWN0ZWRfbm9kZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZWN0ZWRfbm9kZXNbaV0ubGlfYXR0ci5mdWxsX3BhdGggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBwYXRocy5wdXNoKHNlbGVjdGVkX25vZGVzW2ldLmxpX2F0dHIuZnVsbF9wYXRoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmluaXRDaGFpbkNhbGxDb250cm9sKHtcbiAgICAgICAgICAgICAgICBsZW5ndGg6IHBhdGhzLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBhY3Rpb246IFwiYWRkaW5nX2RhdGFzZXRzXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHNlbGVjdGlvbl90eXBlID09PSBcImZvbGRlclwiKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZ1bGxfc291cmNlID0gYCR7b3B0aW9ucy5zb3VyY2V9X2ZvbGRlcmA7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGFpbkNhbGxJbXBvcnRpbmdGb2xkZXJzKHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aHM6IHBhdGhzLFxuICAgICAgICAgICAgICAgICAgICBwcmVzZXJ2ZV9kaXJzOiBwcmVzZXJ2ZV9kaXJzLFxuICAgICAgICAgICAgICAgICAgICBsaW5rX2RhdGE6IGxpbmtfZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgc3BhY2VfdG9fdGFiOiBzcGFjZV90b190YWIsXG4gICAgICAgICAgICAgICAgICAgIHRvX3Bvc2l4X2xpbmVzOiB0b19wb3NpeF9saW5lcyxcbiAgICAgICAgICAgICAgICAgICAgc291cmNlOiBmdWxsX3NvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgZmlsZV90eXBlOiBmaWxlX3R5cGUsXG4gICAgICAgICAgICAgICAgICAgIGRia2V5OiBkYmtleSxcbiAgICAgICAgICAgICAgICAgICAgdGFnX3VzaW5nX2ZpbGVuYW1lczogdGFnX3VzaW5nX2ZpbGVuYW1lc1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzZWxlY3Rpb25fdHlwZSA9PT0gXCJmaWxlXCIpIHtcbiAgICAgICAgICAgICAgICB2YXIgZnVsbF9zb3VyY2UgPSBgJHtvcHRpb25zLnNvdXJjZX1fZmlsZWA7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGFpbkNhbGxJbXBvcnRpbmdVc2VyZGlyRmlsZXMoe1xuICAgICAgICAgICAgICAgICAgICBwYXRoczogcGF0aHMsXG4gICAgICAgICAgICAgICAgICAgIGZpbGVfdHlwZTogZmlsZV90eXBlLFxuICAgICAgICAgICAgICAgICAgICBkYmtleTogZGJrZXksXG4gICAgICAgICAgICAgICAgICAgIGxpbmtfZGF0YTogbGlua19kYXRhLFxuICAgICAgICAgICAgICAgICAgICBzcGFjZV90b190YWI6IHNwYWNlX3RvX3RhYixcbiAgICAgICAgICAgICAgICAgICAgdG9fcG9zaXhfbGluZXM6IHRvX3Bvc2l4X2xpbmVzLFxuICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IGZ1bGxfc291cmNlLFxuICAgICAgICAgICAgICAgICAgICB0YWdfdXNpbmdfZmlsZW5hbWVzOiB0YWdfdXNpbmdfZmlsZW5hbWVzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZmV0Y2hBbmREaXNwbGF5SGlzdG9yeUNvbnRlbnRzOiBmdW5jdGlvbihoaXN0b3J5X2lkKSB7XG4gICAgICAgIHZhciBoaXN0b3J5X2NvbnRlbnRzID0gbmV3IG1vZF9saWJyYXJ5X21vZGVsLkhpc3RvcnlDb250ZW50cyh7XG4gICAgICAgICAgICBpZDogaGlzdG9yeV9pZFxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICBoaXN0b3J5X2NvbnRlbnRzLmZldGNoKHtcbiAgICAgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uKGhpc3RvcnlfY29udGVudHMpIHtcbiAgICAgICAgICAgICAgICB2YXIgaGlzdG9yeV9jb250ZW50c190ZW1wbGF0ZSA9IHNlbGYudGVtcGxhdGVIaXN0b3J5Q29udGVudHMoKTtcbiAgICAgICAgICAgICAgICBzZWxmLmhpc3Rvcmllcy5nZXQoaGlzdG9yeV9pZCkuc2V0KHsgY29udGVudHM6IGhpc3RvcnlfY29udGVudHMgfSk7XG4gICAgICAgICAgICAgICAgc2VsZi5tb2RhbC4kZWwuZmluZChcIiNzZWxlY3RlZF9oaXN0b3J5X2NvbnRlbnRcIikuaHRtbChcbiAgICAgICAgICAgICAgICAgICAgaGlzdG9yeV9jb250ZW50c190ZW1wbGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBoaXN0b3J5X2NvbnRlbnRzOiBoaXN0b3J5X2NvbnRlbnRzLm1vZGVscy5yZXZlcnNlKClcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHNlbGYubW9kYWwuJGVsLmZpbmQoXCIuaGlzdG9yeS1pbXBvcnQtc2VsZWN0LWFsbFwiKS5iaW5kKFwiY2xpY2tcIiwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAkKFwiI3NlbGVjdGVkX2hpc3RvcnlfY29udGVudCBbdHlwZT1jaGVja2JveF1cIikucHJvcChcImNoZWNrZWRcIiwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgc2VsZi5tb2RhbC4kZWwuZmluZChcIi5oaXN0b3J5LWltcG9ydC11bnNlbGVjdC1hbGxcIikuYmluZChcImNsaWNrXCIsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgJChcIiNzZWxlY3RlZF9oaXN0b3J5X2NvbnRlbnQgW3R5cGU9Y2hlY2tib3hdXCIpLnByb3AoXCJjaGVja2VkXCIsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlcnJvcjogZnVuY3Rpb24obW9kZWwsIHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByZXNwb25zZS5yZXNwb25zZUpTT04gIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgbW9kX3RvYXN0ci5lcnJvcihyZXNwb25zZS5yZXNwb25zZUpTT04uZXJyX21zZyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbW9kX3RvYXN0ci5lcnJvcihcIkFuIGVycm9yIG9jY3VycmVkLlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJbXBvcnQgYWxsIHNlbGVjdGVkIGRhdGFzZXRzIGZyb20gaGlzdG9yeSBpbnRvIHRoZSBjdXJyZW50IGZvbGRlci5cbiAgICAgKi9cbiAgICBhZGRBbGxEYXRhc2V0c0Zyb21IaXN0b3J5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNoZWNrZWRfaGRhcyA9IHRoaXMubW9kYWwuJGVsLmZpbmQoXCIjc2VsZWN0ZWRfaGlzdG9yeV9jb250ZW50XCIpLmZpbmQoXCI6Y2hlY2tlZFwiKTtcbiAgICAgICAgdmFyIGhpc3RvcnlfaXRlbV9pZHMgPSBbXTsgLy8gY2FuIGJlIGhkYSBvciBoZGNhXG4gICAgICAgIHZhciBoaXN0b3J5X2l0ZW1fdHlwZXMgPSBbXTtcbiAgICAgICAgdmFyIGl0ZW1zX3RvX2FkZCA9IFtdO1xuICAgICAgICBpZiAoY2hlY2tlZF9oZGFzLmxlbmd0aCA8IDEpIHtcbiAgICAgICAgICAgIG1vZF90b2FzdHIuaW5mbyhcIllvdSBtdXN0IHNlbGVjdCBzb21lIGRhdGFzZXRzIGZpcnN0LlwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubW9kYWwuZGlzYWJsZUJ1dHRvbihcIkFkZFwiKTtcbiAgICAgICAgICAgIGNoZWNrZWRfaGRhcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBoaWQgPSAkKHRoaXMpXG4gICAgICAgICAgICAgICAgICAgIC5jbG9zZXN0KFwibGlcIilcbiAgICAgICAgICAgICAgICAgICAgLmRhdGEoXCJpZFwiKTtcbiAgICAgICAgICAgICAgICBpZiAoaGlkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpdGVtX3R5cGUgPSAkKHRoaXMpXG4gICAgICAgICAgICAgICAgICAgICAgICAuY2xvc2VzdChcImxpXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAuZGF0YShcIm5hbWVcIik7XG4gICAgICAgICAgICAgICAgICAgIGhpc3RvcnlfaXRlbV9pZHMucHVzaChoaWQpO1xuICAgICAgICAgICAgICAgICAgICBoaXN0b3J5X2l0ZW1fdHlwZXMucHVzaChpdGVtX3R5cGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IGhpc3RvcnlfaXRlbV9pZHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICB2YXIgaGlzdG9yeV9pdGVtX2lkID0gaGlzdG9yeV9pdGVtX2lkc1tpXTtcbiAgICAgICAgICAgICAgICB2YXIgZm9sZGVyX2l0ZW0gPSBuZXcgbW9kX2xpYnJhcnlfbW9kZWwuSXRlbSgpO1xuICAgICAgICAgICAgICAgIGZvbGRlcl9pdGVtLnVybCA9IGAke0dhbGF4eS5yb290fWFwaS9mb2xkZXJzLyR7dGhpcy5vcHRpb25zLmlkfS9jb250ZW50c2A7XG4gICAgICAgICAgICAgICAgaWYgKGhpc3RvcnlfaXRlbV90eXBlc1tpXSA9PT0gXCJjb2xsZWN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9sZGVyX2l0ZW0uc2V0KHsgZnJvbV9oZGNhX2lkOiBoaXN0b3J5X2l0ZW1faWQgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZm9sZGVyX2l0ZW0uc2V0KHsgZnJvbV9oZGFfaWQ6IGhpc3RvcnlfaXRlbV9pZCB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaXRlbXNfdG9fYWRkLnB1c2goZm9sZGVyX2l0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5pbml0Q2hhaW5DYWxsQ29udHJvbCh7XG4gICAgICAgICAgICAgICAgbGVuZ3RoOiBpdGVtc190b19hZGQubGVuZ3RoLFxuICAgICAgICAgICAgICAgIGFjdGlvbjogXCJhZGRpbmdfZGF0YXNldHNcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmNoYWluQ2FsbEFkZGluZ0hkYXMoaXRlbXNfdG9fYWRkKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUYWtlIGFycmF5IG9mIGVtcHR5IGhpc3RvcnkgaXRlbXMgYW5kIG1ha2UgcmVxdWVzdCBmb3IgZWFjaCBvZiB0aGVtXG4gICAgICogdG8gY3JlYXRlIGl0IG9uIHNlcnZlci4gVXBkYXRlIHByb2dyZXNzIGluIGJldHdlZW4gY2FsbHMuXG4gICAgICogQHBhcmFtICB7YXJyYXl9IGhpc3RvcnlfaXRlbV9zZXQgYXJyYXkgb2YgZW1wdHkgaGlzdG9yeSBpdGVtc1xuICAgICAqIEBwYXJhbSAge3N0cn0gaGlzdG9yeV9uYW1lICAgICBuYW1lIG9mIHRoZSBoaXN0b3J5IHRvIGltcG9ydCB0b1xuICAgICAqL1xuICAgIGNoYWluQ2FsbEltcG9ydGluZ0ludG9IaXN0b3J5OiBmdW5jdGlvbihoaXN0b3J5X2l0ZW1fc2V0LCBoaXN0b3J5X25hbWUpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgcG9wcGVkX2l0ZW0gPSBoaXN0b3J5X2l0ZW1fc2V0LnBvcCgpO1xuICAgICAgICBpZiAodHlwZW9mIHBvcHBlZF9pdGVtID09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuY2hhaW5fY2FsbF9jb250cm9sLmZhaWxlZF9udW1iZXIgPT09IDApIHtcbiAgICAgICAgICAgICAgICBtb2RfdG9hc3RyLnN1Y2Nlc3MoXCJTZWxlY3RlZCBkYXRhc2V0cyBpbXBvcnRlZCBpbnRvIGhpc3RvcnkuIENsaWNrIHRoaXMgdG8gc3RhcnQgYW5hbHl6aW5nIGl0LlwiLCBcIlwiLCB7XG4gICAgICAgICAgICAgICAgICAgIG9uY2xpY2s6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uID0gR2FsYXh5LnJvb3Q7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLmNoYWluX2NhbGxfY29udHJvbC5mYWlsZWRfbnVtYmVyID09PSB0aGlzLm9wdGlvbnMuY2hhaW5fY2FsbF9jb250cm9sLnRvdGFsX251bWJlcikge1xuICAgICAgICAgICAgICAgIG1vZF90b2FzdHIuZXJyb3IoXCJUaGVyZSB3YXMgYW4gZXJyb3IgYW5kIG5vIGRhdGFzZXRzIHdlcmUgaW1wb3J0ZWQgaW50byBoaXN0b3J5LlwiKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLmNoYWluX2NhbGxfY29udHJvbC5mYWlsZWRfbnVtYmVyIDwgdGhpcy5vcHRpb25zLmNoYWluX2NhbGxfY29udHJvbC50b3RhbF9udW1iZXIpIHtcbiAgICAgICAgICAgICAgICBtb2RfdG9hc3RyLndhcm5pbmcoXG4gICAgICAgICAgICAgICAgICAgIFwiU29tZSBvZiB0aGUgZGF0YXNldHMgY291bGQgbm90IGJlIGltcG9ydGVkIGludG8gaGlzdG9yeS4gQ2xpY2sgdGhpcyB0byBzZWUgd2hhdCB3YXMgaW1wb3J0ZWQuXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiXCIsXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uY2xpY2s6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbiA9IEdhbGF4eS5yb290O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIEdhbGF4eS5tb2RhbC5oaWRlKCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHJvbWlzZSA9ICQud2hlbihcbiAgICAgICAgICAgIHBvcHBlZF9pdGVtLnNhdmUoe1xuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHBvcHBlZF9pdGVtLmNvbnRlbnQsXG4gICAgICAgICAgICAgICAgc291cmNlOiBwb3BwZWRfaXRlbS5zb3VyY2VcbiAgICAgICAgICAgIH0pXG4gICAgICAgICk7XG5cbiAgICAgICAgcHJvbWlzZVxuICAgICAgICAgICAgLmRvbmUoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHNlbGYudXBkYXRlUHJvZ3Jlc3MoKTtcbiAgICAgICAgICAgICAgICBzZWxmLmNoYWluQ2FsbEltcG9ydGluZ0ludG9IaXN0b3J5KGhpc3RvcnlfaXRlbV9zZXQsIGhpc3RvcnlfbmFtZSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmZhaWwoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHNlbGYub3B0aW9ucy5jaGFpbl9jYWxsX2NvbnRyb2wuZmFpbGVkX251bWJlciArPSAxO1xuICAgICAgICAgICAgICAgIHNlbGYudXBkYXRlUHJvZ3Jlc3MoKTtcbiAgICAgICAgICAgICAgICBzZWxmLmNoYWluQ2FsbEltcG9ydGluZ0ludG9IaXN0b3J5KGhpc3RvcnlfaXRlbV9zZXQsIGhpc3RvcnlfbmFtZSk7XG4gICAgICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGFrZSB0aGUgYXJyYXkgb2YgcGF0aHMgYW5kIGNyZWF0ZSBhIHJlcXVlc3QgZm9yIGVhY2ggb2YgdGhlbVxuICAgICAqIGNhbGxpbmcgdGhlbSBpbiBjaGFpbi4gVXBkYXRlIHRoZSBwcm9ncmVzcyBiYXIgaW4gYmV0d2VlbiBlYWNoLlxuICAgICAqIEBwYXJhbSAge2FycmF5fSBwYXRocyAgICAgICAgICAgICAgICAgICAgcGF0aHMgcmVsYXRpdmUgdG8gdXNlciBmb2xkZXIgb24gR2FsYXh5XG4gICAgICogQHBhcmFtICB7Ym9vbGVhbn0gdGFnX3VzaW5nX2ZpbGVuYW1lcyAgICBhZGQgdGFncyB0byBkYXRhc2V0cyB1c2luZyBuYW1lcyBvZiBmaWxlc1xuICAgICAqL1xuICAgIGNoYWluQ2FsbEltcG9ydGluZ1VzZXJkaXJGaWxlczogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgIHZhciBwb3BwZWRfaXRlbSA9IG9wdGlvbnMucGF0aHMucG9wKCk7XG4gICAgICAgIGlmICh0eXBlb2YgcG9wcGVkX2l0ZW0gPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuY2hhaW5fY2FsbF9jb250cm9sLmZhaWxlZF9udW1iZXIgPT09IDApIHtcbiAgICAgICAgICAgICAgICBtb2RfdG9hc3RyLnN1Y2Nlc3MoXCJTZWxlY3RlZCBmaWxlcyBpbXBvcnRlZCBpbnRvIHRoZSBjdXJyZW50IGZvbGRlclwiKTtcbiAgICAgICAgICAgICAgICBHYWxheHkubW9kYWwuaGlkZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtb2RfdG9hc3RyLmVycm9yKFwiQW4gZXJyb3Igb2NjdXJlZC5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHJvbWlzZSA9ICQud2hlbihcbiAgICAgICAgICAgICQucG9zdChcbiAgICAgICAgICAgICAgICBgJHtHYWxheHkucm9vdH1hcGkvbGlicmFyaWVzL2RhdGFzZXRzP2VuY29kZWRfZm9sZGVyX2lkPSR7dGhhdC5pZH0mc291cmNlPSR7b3B0aW9ucy5zb3VyY2V9JnBhdGg9JHtcbiAgICAgICAgICAgICAgICAgICAgcG9wcGVkX2l0ZW1cbiAgICAgICAgICAgICAgICB9JmZpbGVfdHlwZT0ke29wdGlvbnMuZmlsZV90eXBlfSZsaW5rX2RhdGE9JHtvcHRpb25zLmxpbmtfZGF0YX0mc3BhY2VfdG9fdGFiPSR7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuc3BhY2VfdG9fdGFiXG4gICAgICAgICAgICAgICAgfSZ0b19wb3NpeF9saW5lcz0ke29wdGlvbnMudG9fcG9zaXhfbGluZXN9JmRia2V5PSR7b3B0aW9ucy5kYmtleX0mdGFnX3VzaW5nX2ZpbGVuYW1lcz0ke1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnRhZ191c2luZ19maWxlbmFtZXNcbiAgICAgICAgICAgICAgICB9YFxuICAgICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgICBwcm9taXNlXG4gICAgICAgICAgICAuZG9uZShyZXNwb25zZSA9PiB7XG4gICAgICAgICAgICAgICAgdGhhdC51cGRhdGVQcm9ncmVzcygpO1xuICAgICAgICAgICAgICAgIHRoYXQuY2hhaW5DYWxsSW1wb3J0aW5nVXNlcmRpckZpbGVzKG9wdGlvbnMpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5mYWlsKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGF0Lm9wdGlvbnMuY2hhaW5fY2FsbF9jb250cm9sLmZhaWxlZF9udW1iZXIgKz0gMTtcbiAgICAgICAgICAgICAgICB0aGF0LnVwZGF0ZVByb2dyZXNzKCk7XG4gICAgICAgICAgICAgICAgdGhhdC5jaGFpbkNhbGxJbXBvcnRpbmdVc2VyZGlyRmlsZXMob3B0aW9ucyk7XG4gICAgICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGFrZSB0aGUgYXJyYXkgb2YgcGF0aHMgYW5kIGNyZWF0ZSBhIHJlcXVlc3QgZm9yIGVhY2ggb2YgdGhlbVxuICAgICAqIGNhbGxpbmcgdGhlbSBpbiBzZXJpZXMuIFVwZGF0ZSB0aGUgcHJvZ3Jlc3MgYmFyIGluIGJldHdlZW4gZWFjaC5cbiAgICAgKiBAcGFyYW0gIHthcnJheX0gcGF0aHMgICAgICAgICAgICAgICAgICAgIHBhdGhzIHJlbGF0aXZlIHRvIEdhbGF4eSByb290IGZvbGRlclxuICAgICAqIEBwYXJhbSAge2Jvb2xlYW59IHByZXNlcnZlX2RpcnMgICAgICAgICAgaW5kaWNhdGVzIHdoZXRoZXIgdG8gcHJlc2VydmUgZm9sZGVyIHN0cnVjdHVyZVxuICAgICAqIEBwYXJhbSAge2Jvb2xlYW59IGxpbmtfZGF0YSAgICAgICAgICAgICAgY29weSBmaWxlcyB0byBHYWxheHkgb3IgbGluayBpbnN0ZWFkXG4gICAgICogQHBhcmFtICB7Ym9vbGVhbn0gdG9fcG9zaXhfbGluZXMgICAgICAgICBjb252ZXJ0IGxpbmUgZW5kaW5ncyB0byBQT1NJWCBzdGFuZGFyZFxuICAgICAqIEBwYXJhbSAge2Jvb2xlYW59IHNwYWNlX3RvX3RhYiAgICAgICAgICAgY29udmVydCBzcGFjZXMgdG8gdGFic1xuICAgICAqIEBwYXJhbSAge3N0cn0gc291cmNlICAgICAgICAgICAgICAgICAgICAgc3RyaW5nIHJlcHJlc2VudGluZyB3aGF0IHR5cGUgb2YgZm9sZGVyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpcyB0aGUgc291cmNlIG9mIGltcG9ydFxuICAgICAqIEBwYXJhbSAge2Jvb2xlYW59IHRhZ191c2luZ19maWxlbmFtZXMgICAgYWRkIHRhZ3MgdG8gZGF0YXNldHMgdXNpbmcgbmFtZXMgb2YgZmlsZXNcbiAgICAgKi9cbiAgICBjaGFpbkNhbGxJbXBvcnRpbmdGb2xkZXJzOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIC8vIFRPRE8gbmVlZCB0byBjaGVjayB3aGljaCBwYXRocyB0byBjYWxsXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgdmFyIHBvcHBlZF9pdGVtID0gb3B0aW9ucy5wYXRocy5wb3AoKTtcbiAgICAgICAgaWYgKHR5cGVvZiBwb3BwZWRfaXRlbSA9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmNoYWluX2NhbGxfY29udHJvbC5mYWlsZWRfbnVtYmVyID09PSAwKSB7XG4gICAgICAgICAgICAgICAgbW9kX3RvYXN0ci5zdWNjZXNzKFwiU2VsZWN0ZWQgZm9sZGVycyBhbmQgdGhlaXIgY29udGVudHMgaW1wb3J0ZWQgaW50byB0aGUgY3VycmVudCBmb2xkZXIuXCIpO1xuICAgICAgICAgICAgICAgIEdhbGF4eS5tb2RhbC5oaWRlKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFRPRE8gYmV0dGVyIGVycm9yIHJlcG9ydFxuICAgICAgICAgICAgICAgIG1vZF90b2FzdHIuZXJyb3IoXCJBbiBlcnJvciBvY2N1cmVkLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwcm9taXNlID0gJC53aGVuKFxuICAgICAgICAgICAgJC5wb3N0KFxuICAgICAgICAgICAgICAgIGAke0dhbGF4eS5yb290fWFwaS9saWJyYXJpZXMvZGF0YXNldHM/ZW5jb2RlZF9mb2xkZXJfaWQ9JHt0aGF0LmlkfSZzb3VyY2U9JHtvcHRpb25zLnNvdXJjZX0mcGF0aD0ke1xuICAgICAgICAgICAgICAgICAgICBwb3BwZWRfaXRlbVxuICAgICAgICAgICAgICAgIH0mcHJlc2VydmVfZGlycz0ke29wdGlvbnMucHJlc2VydmVfZGlyc30mbGlua19kYXRhPSR7b3B0aW9ucy5saW5rX2RhdGF9JnRvX3Bvc2l4X2xpbmVzPSR7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMudG9fcG9zaXhfbGluZXNcbiAgICAgICAgICAgICAgICB9JnNwYWNlX3RvX3RhYj0ke29wdGlvbnMuc3BhY2VfdG9fdGFifSZmaWxlX3R5cGU9JHtvcHRpb25zLmZpbGVfdHlwZX0mZGJrZXk9JHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYmtleVxuICAgICAgICAgICAgICAgIH0mdGFnX3VzaW5nX2ZpbGVuYW1lcz0ke29wdGlvbnMudGFnX3VzaW5nX2ZpbGVuYW1lc31gXG4gICAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICAgIHByb21pc2VcbiAgICAgICAgICAgIC5kb25lKHJlc3BvbnNlID0+IHtcbiAgICAgICAgICAgICAgICB0aGF0LnVwZGF0ZVByb2dyZXNzKCk7XG4gICAgICAgICAgICAgICAgdGhhdC5jaGFpbkNhbGxJbXBvcnRpbmdGb2xkZXJzKG9wdGlvbnMpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5mYWlsKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGF0Lm9wdGlvbnMuY2hhaW5fY2FsbF9jb250cm9sLmZhaWxlZF9udW1iZXIgKz0gMTtcbiAgICAgICAgICAgICAgICB0aGF0LnVwZGF0ZVByb2dyZXNzKCk7XG4gICAgICAgICAgICAgICAgdGhhdC5jaGFpbkNhbGxJbXBvcnRpbmdGb2xkZXJzKG9wdGlvbnMpO1xuICAgICAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRha2UgdGhlIGFycmF5IG9mIGhkYXMgYW5kIGNyZWF0ZSBhIHJlcXVlc3QgZm9yIGVhY2guXG4gICAgICogQ2FsbCB0aGVtIGluIGNoYWluIGFuZCB1cGRhdGUgcHJvZ3Jlc3MgYmFyIGluIGJldHdlZW4gZWFjaC5cbiAgICAgKiBAcGFyYW0gIHthcnJheX0gaGRhc19zZXQgYXJyYXkgb2YgZW1wdHkgaGRhIG9iamVjdHNcbiAgICAgKi9cbiAgICBjaGFpbkNhbGxBZGRpbmdIZGFzOiBmdW5jdGlvbihoZGFzX3NldCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHRoaXMuYWRkZWRfaGRhcyA9IG5ldyBtb2RfbGlicmFyeV9tb2RlbC5Gb2xkZXIoKTtcbiAgICAgICAgdmFyIHBvcHBlZF9pdGVtID0gaGRhc19zZXQucG9wKCk7XG4gICAgICAgIGlmICh0eXBlb2YgcG9wcGVkX2l0ZW0gPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5jaGFpbl9jYWxsX2NvbnRyb2wuZmFpbGVkX251bWJlciA9PT0gMCkge1xuICAgICAgICAgICAgICAgIG1vZF90b2FzdHIuc3VjY2VzcyhcIlNlbGVjdGVkIGRhdGFzZXRzIGZyb20gaGlzdG9yeSBhZGRlZCB0byB0aGUgZm9sZGVyXCIpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMuY2hhaW5fY2FsbF9jb250cm9sLmZhaWxlZF9udW1iZXIgPT09IHRoaXMub3B0aW9ucy5jaGFpbl9jYWxsX2NvbnRyb2wudG90YWxfbnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgbW9kX3RvYXN0ci5lcnJvcihcIlRoZXJlIHdhcyBhbiBlcnJvciBhbmQgbm8gZGF0YXNldHMgd2VyZSBhZGRlZCB0byB0aGUgZm9sZGVyLlwiKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLmNoYWluX2NhbGxfY29udHJvbC5mYWlsZWRfbnVtYmVyIDwgdGhpcy5vcHRpb25zLmNoYWluX2NhbGxfY29udHJvbC50b3RhbF9udW1iZXIpIHtcbiAgICAgICAgICAgICAgICBtb2RfdG9hc3RyLndhcm5pbmcoXCJTb21lIG9mIHRoZSBkYXRhc2V0cyBjb3VsZCBub3QgYmUgYWRkZWQgdG8gdGhlIGZvbGRlclwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIEdhbGF4eS5tb2RhbC5oaWRlKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hZGRlZF9oZGFzO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwcm9taXNlID0gJC53aGVuKFxuICAgICAgICAgICAgcG9wcGVkX2l0ZW0uc2F2ZSh7XG4gICAgICAgICAgICAgICAgZnJvbV9oZGFfaWQ6IHBvcHBlZF9pdGVtLmdldChcImZyb21faGRhX2lkXCIpXG4gICAgICAgICAgICB9KVxuICAgICAgICApO1xuXG4gICAgICAgIHByb21pc2VcbiAgICAgICAgICAgIC5kb25lKG1vZGVsID0+IHtcbiAgICAgICAgICAgICAgICBHYWxheHkubGlicmFyaWVzLmZvbGRlckxpc3RWaWV3LmNvbGxlY3Rpb24uYWRkKG1vZGVsKTtcbiAgICAgICAgICAgICAgICBzZWxmLnVwZGF0ZVByb2dyZXNzKCk7XG4gICAgICAgICAgICAgICAgc2VsZi5jaGFpbkNhbGxBZGRpbmdIZGFzKGhkYXNfc2V0KTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuZmFpbCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgc2VsZi5vcHRpb25zLmNoYWluX2NhbGxfY29udHJvbC5mYWlsZWRfbnVtYmVyICs9IDE7XG4gICAgICAgICAgICAgICAgc2VsZi51cGRhdGVQcm9ncmVzcygpO1xuICAgICAgICAgICAgICAgIHNlbGYuY2hhaW5DYWxsQWRkaW5nSGRhcyhoZGFzX3NldCk7XG4gICAgICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGFrZSB0aGUgYXJyYXkgb2YgbGRkYXMsIGNyZWF0ZSByZXF1ZXN0IGZvciBlYWNoIGFuZFxuICAgICAqIGNhbGwgdGhlbSBpbiBjaGFpbi4gVXBkYXRlIHByb2dyZXNzIGJhciBpbiBiZXR3ZWVuIGVhY2guXG4gICAgICogQHBhcmFtICB7YXJyYXl9IGxkZGFzX3NldCBhcnJheSBvZiBsZGRhcyB0byBkZWxldGVcbiAgICAgKi9cbiAgICBjaGFpbkNhbGxEZWxldGluZ0l0ZW1zOiBmdW5jdGlvbihpdGVtc190b19kZWxldGUpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB0aGlzLmRlbGV0ZWRfaXRlbXMgPSBuZXcgbW9kX2xpYnJhcnlfbW9kZWwuRm9sZGVyKCk7XG4gICAgICAgIHZhciBpdGVtX3RvX2RlbGV0ZSA9IGl0ZW1zX3RvX2RlbGV0ZS5wb3AoKTtcbiAgICAgICAgaWYgKHR5cGVvZiBpdGVtX3RvX2RlbGV0ZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5jaGFpbl9jYWxsX2NvbnRyb2wuZmFpbGVkX251bWJlciA9PT0gMCkge1xuICAgICAgICAgICAgICAgIG1vZF90b2FzdHIuc3VjY2VzcyhcIlNlbGVjdGVkIGl0ZW1zIHdlcmUgZGVsZXRlZC5cIik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5jaGFpbl9jYWxsX2NvbnRyb2wuZmFpbGVkX251bWJlciA9PT0gdGhpcy5vcHRpb25zLmNoYWluX2NhbGxfY29udHJvbC50b3RhbF9udW1iZXIpIHtcbiAgICAgICAgICAgICAgICBtb2RfdG9hc3RyLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICBcIlRoZXJlIHdhcyBhbiBlcnJvciBhbmQgbm8gaXRlbXMgd2VyZSBkZWxldGVkLiBQbGVhc2UgbWFrZSBzdXJlIHlvdSBoYXZlIHN1ZmZpY2llbnQgcGVybWlzc2lvbnMuXCJcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMuY2hhaW5fY2FsbF9jb250cm9sLmZhaWxlZF9udW1iZXIgPCB0aGlzLm9wdGlvbnMuY2hhaW5fY2FsbF9jb250cm9sLnRvdGFsX251bWJlcikge1xuICAgICAgICAgICAgICAgIG1vZF90b2FzdHIud2FybmluZyhcbiAgICAgICAgICAgICAgICAgICAgXCJTb21lIG9mIHRoZSBpdGVtcyBjb3VsZCBub3QgYmUgZGVsZXRlZC4gUGxlYXNlIG1ha2Ugc3VyZSB5b3UgaGF2ZSBzdWZmaWNpZW50IHBlcm1pc3Npb25zLlwiXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIEdhbGF4eS5tb2RhbC5oaWRlKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZWxldGVkX2l0ZW1zO1xuICAgICAgICB9XG4gICAgICAgIGl0ZW1fdG9fZGVsZXRlXG4gICAgICAgICAgICAuZGVzdHJveSgpXG4gICAgICAgICAgICAuZG9uZShpdGVtID0+IHtcbiAgICAgICAgICAgICAgICBHYWxheHkubGlicmFyaWVzLmZvbGRlckxpc3RWaWV3LmNvbGxlY3Rpb24ucmVtb3ZlKGl0ZW1fdG9fZGVsZXRlLmlkKTtcbiAgICAgICAgICAgICAgICBzZWxmLnVwZGF0ZVByb2dyZXNzKCk7XG4gICAgICAgICAgICAgICAgLy8gYWRkIHRoZSBkZWxldGVkIGl0ZW0gdG8gY29sbGVjdGlvbiwgdHJpZ2dlcnMgcmVuZGVyaW5nXG4gICAgICAgICAgICAgICAgaWYgKEdhbGF4eS5saWJyYXJpZXMuZm9sZGVyTGlzdFZpZXcub3B0aW9ucy5pbmNsdWRlX2RlbGV0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHVwZGF0ZWRfaXRlbSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLnR5cGUgPT09IFwiZm9sZGVyXCIgfHwgaXRlbS5tb2RlbF9jbGFzcyA9PT0gXCJMaWJyYXJ5Rm9sZGVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZWRfaXRlbSA9IG5ldyBtb2RfbGlicmFyeV9tb2RlbC5Gb2xkZXJBc01vZGVsKGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGl0ZW0udHlwZSA9PT0gXCJmaWxlXCIgfHwgaXRlbS5tb2RlbF9jbGFzcyA9PT0gXCJMaWJyYXJ5RGF0YXNldFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVkX2l0ZW0gPSBuZXcgbW9kX2xpYnJhcnlfbW9kZWwuSXRlbShpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIEdhbGF4eS5lbWl0LmVycm9yKFwiVW5rbm93biBsaWJyYXJ5IGl0ZW0gdHlwZSBmb3VuZC5cIiwgXCJkYXRhbGlic1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIEdhbGF4eS5lbWl0LmVycm9yKGl0ZW0udHlwZSB8fCBpdGVtLm1vZGVsX2NsYXNzLCBcImRhdGFsaWJzXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIEdhbGF4eS5saWJyYXJpZXMuZm9sZGVyTGlzdFZpZXcuY29sbGVjdGlvbi5hZGQodXBkYXRlZF9pdGVtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2VsZi5jaGFpbkNhbGxEZWxldGluZ0l0ZW1zKGl0ZW1zX3RvX2RlbGV0ZSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmZhaWwoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHNlbGYub3B0aW9ucy5jaGFpbl9jYWxsX2NvbnRyb2wuZmFpbGVkX251bWJlciArPSAxO1xuICAgICAgICAgICAgICAgIHNlbGYudXBkYXRlUHJvZ3Jlc3MoKTtcbiAgICAgICAgICAgICAgICBzZWxmLmNoYWluQ2FsbERlbGV0aW5nSXRlbXMoaXRlbXNfdG9fZGVsZXRlKTtcbiAgICAgICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIHRoZSBjbGljayBvbiAnc2hvdyBkZWxldGVkJyBjaGVja2JveFxuICAgICAqL1xuICAgIGNoZWNrSW5jbHVkZURlbGV0ZWQ6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudC50YXJnZXQuY2hlY2tlZCkge1xuICAgICAgICAgICAgR2FsYXh5LmxpYnJhcmllcy5mb2xkZXJMaXN0Vmlldy5mZXRjaEZvbGRlcih7XG4gICAgICAgICAgICAgICAgaW5jbHVkZV9kZWxldGVkOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIEdhbGF4eS5saWJyYXJpZXMuZm9sZGVyTGlzdFZpZXcuZmV0Y2hGb2xkZXIoe1xuICAgICAgICAgICAgICAgIGluY2x1ZGVfZGVsZXRlZDogZmFsc2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERlbGV0ZSB0aGUgc2VsZWN0ZWQgaXRlbXMuIEF0b21pYy4gT25lIGJ5IG9uZS5cbiAgICAgKi9cbiAgICBkZWxldGVTZWxlY3RlZEl0ZW1zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGRhdGFzZXRfaWRzID0gW107XG4gICAgICAgIHZhciBmb2xkZXJfaWRzID0gW107XG4gICAgICAgIHZhciAkY2hlY2tlZFZhbHVlcyA9IHRoaXMuZmluZENoZWNrZWRSb3dzKCk7XG4gICAgICAgIGlmICgkY2hlY2tlZFZhbHVlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIG1vZF90b2FzdHIuaW5mbyhcIllvdSBtdXN0IHNlbGVjdCBhdCBsZWFzdCBvbmUgaXRlbSBmb3IgZGVsZXRpb24uXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHRlbXBsYXRlID0gdGhpcy50ZW1wbGF0ZURlbGV0aW5nSXRlbXNQcm9ncmVzc0JhcigpO1xuICAgICAgICAgICAgdGhpcy5tb2RhbCA9IEdhbGF4eS5tb2RhbDtcbiAgICAgICAgICAgIHRoaXMubW9kYWwuc2hvdyh7XG4gICAgICAgICAgICAgICAgY2xvc2luZ19ldmVudHM6IHRydWUsXG4gICAgICAgICAgICAgICAgdGl0bGU6IF9sKFwiRGVsZXRpbmcgc2VsZWN0ZWQgaXRlbXNcIiksXG4gICAgICAgICAgICAgICAgYm9keTogdGVtcGxhdGUoe30pLFxuICAgICAgICAgICAgICAgIGJ1dHRvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgQ2xvc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgR2FsYXh5Lm1vZGFsLmhpZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gaW5pdCB0aGUgY29udHJvbCBjb3VudGVyc1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLmNoYWluX2NhbGxfY29udHJvbC50b3RhbF9udW1iZXIgPSAwO1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLmNoYWluX2NhbGxfY29udHJvbC5mYWlsZWRfbnVtYmVyID0gMDtcbiAgICAgICAgICAgICRjaGVja2VkVmFsdWVzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJvd19pZCA9ICQodGhpcylcbiAgICAgICAgICAgICAgICAgICAgLmNsb3Nlc3QoXCJ0clwiKVxuICAgICAgICAgICAgICAgICAgICAuZGF0YShcImlkXCIpO1xuICAgICAgICAgICAgICAgIGlmIChyb3dfaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocm93X2lkLnN1YnN0cmluZygwLCAxKSA9PSBcIkZcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9sZGVyX2lkcy5wdXNoKHJvd19pZCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhc2V0X2lkcy5wdXNoKHJvd19pZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIGluaXQgdGhlIHByb2dyZXNzIGJhclxuICAgICAgICAgICAgdmFyIGl0ZW1zX3RvdGFsID0gZGF0YXNldF9pZHMubGVuZ3RoICsgZm9sZGVyX2lkcy5sZW5ndGg7XG4gICAgICAgICAgICB0aGlzLnByb2dyZXNzU3RlcCA9IDEwMCAvIGl0ZW1zX3RvdGFsO1xuICAgICAgICAgICAgdGhpcy5wcm9ncmVzcyA9IDA7XG5cbiAgICAgICAgICAgIC8vIHByZXBhcmUgdGhlIGRhdGFzZXQgaXRlbXMgdG8gYmUgYWRkZWRcbiAgICAgICAgICAgIHZhciBpdGVtc190b19kZWxldGUgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBkYXRhc2V0X2lkcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgIHZhciBkYXRhc2V0ID0gbmV3IG1vZF9saWJyYXJ5X21vZGVsLkl0ZW0oe1xuICAgICAgICAgICAgICAgICAgICBpZDogZGF0YXNldF9pZHNbaV1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpdGVtc190b19kZWxldGUucHVzaChkYXRhc2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBmb2xkZXJfaWRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZvbGRlciA9IG5ldyBtb2RfbGlicmFyeV9tb2RlbC5Gb2xkZXJBc01vZGVsKHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGZvbGRlcl9pZHNbaV1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpdGVtc190b19kZWxldGUucHVzaChmb2xkZXIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuY2hhaW5fY2FsbF9jb250cm9sLnRvdGFsX251bWJlciA9IGl0ZW1zX3RvdGFsO1xuICAgICAgICAgICAgLy8gY2FsbCB0aGUgcmVjdXJzaXZlIGZ1bmN0aW9uIHRvIGNhbGwgYWpheCBvbmUgYWZ0ZXIgZWFjaCBvdGhlciAocmVxdWVzdCBGSUZPIHF1ZXVlKVxuICAgICAgICAgICAgdGhpcy5jaGFpbkNhbGxEZWxldGluZ0l0ZW1zKGl0ZW1zX3RvX2RlbGV0ZSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgc2hvd0xvY0luZm86IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbGlicmFyeSA9IG51bGw7XG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgaWYgKEdhbGF4eS5saWJyYXJpZXMubGlicmFyeUxpc3RWaWV3ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBsaWJyYXJ5ID0gR2FsYXh5LmxpYnJhcmllcy5saWJyYXJ5TGlzdFZpZXcuY29sbGVjdGlvbi5nZXQodGhpcy5vcHRpb25zLnBhcmVudF9saWJyYXJ5X2lkKTtcbiAgICAgICAgICAgIHRoaXMuc2hvd0xvY0luZm9Nb2RhbChsaWJyYXJ5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxpYnJhcnkgPSBuZXcgbW9kX2xpYnJhcnlfbW9kZWwuTGlicmFyeSh7XG4gICAgICAgICAgICAgICAgaWQ6IHRoaXMub3B0aW9ucy5wYXJlbnRfbGlicmFyeV9pZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBsaWJyYXJ5LmZldGNoKHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5zaG93TG9jSW5mb01vZGFsKGxpYnJhcnkpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZXJyb3I6IGZ1bmN0aW9uKG1vZGVsLCByZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJlc3BvbnNlLnJlc3BvbnNlSlNPTiAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9kX3RvYXN0ci5lcnJvcihyZXNwb25zZS5yZXNwb25zZUpTT04uZXJyX21zZyk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RfdG9hc3RyLmVycm9yKFwiQW4gZXJyb3Igb2NjdXJyZWQuXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgc2hvd0xvY0luZm9Nb2RhbDogZnVuY3Rpb24obGlicmFyeSkge1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgIHZhciB0ZW1wbGF0ZSA9IHRoaXMudGVtcGxhdGVMb2NJbmZvSW5Nb2RhbCgpO1xuICAgICAgICB0aGlzLm1vZGFsID0gR2FsYXh5Lm1vZGFsO1xuICAgICAgICB0aGlzLm1vZGFsLnNob3coe1xuICAgICAgICAgICAgY2xvc2luZ19ldmVudHM6IHRydWUsXG4gICAgICAgICAgICB0aXRsZTogX2woXCJMb2NhdGlvbiBEZXRhaWxzXCIpLFxuICAgICAgICAgICAgYm9keTogdGVtcGxhdGUoeyBsaWJyYXJ5OiBsaWJyYXJ5LCBvcHRpb25zOiB0aGF0Lm9wdGlvbnMgfSksXG4gICAgICAgICAgICBidXR0b25zOiB7XG4gICAgICAgICAgICAgICAgQ2xvc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBHYWxheHkubW9kYWwuaGlkZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIHNob3dJbXBvcnRNb2RhbDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICBzd2l0Y2ggKG9wdGlvbnMuc291cmNlKSB7XG4gICAgICAgICAgICBjYXNlIFwiaGlzdG9yeVwiOlxuICAgICAgICAgICAgICAgIHRoaXMuYWRkRmlsZXNGcm9tSGlzdG9yeU1vZGFsKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiaW1wb3J0ZGlyXCI6XG4gICAgICAgICAgICAgICAgdGhpcy5pbXBvcnRGaWxlc0Zyb21HYWxheHlGb2xkZXJNb2RhbCh7XG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZTogXCJpbXBvcnRkaXJcIlxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInBhdGhcIjpcbiAgICAgICAgICAgICAgICB0aGlzLmltcG9ydEZpbGVzRnJvbVBhdGhNb2RhbCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInVzZXJkaXJcIjpcbiAgICAgICAgICAgICAgICB0aGlzLmltcG9ydEZpbGVzRnJvbUdhbGF4eUZvbGRlck1vZGFsKHtcbiAgICAgICAgICAgICAgICAgICAgc291cmNlOiBcInVzZXJkaXJcIlxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBHYWxheHkubGlicmFyaWVzLmxpYnJhcnlfcm91dGVyLmJhY2soKTtcbiAgICAgICAgICAgICAgICBtb2RfdG9hc3RyLmVycm9yKFwiSW52YWxpZCBpbXBvcnQgc291cmNlLlwiKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTaG93IHVzZXIgdGhlIHByb21wdCB0byBjaGFuZ2UgdGhlIG51bWJlciBvZiBpdGVtcyBzaG93biBvbiBwYWdlLlxuICAgICAqL1xuICAgIHNob3dQYWdlU2l6ZVByb21wdDogZnVuY3Rpb24oZSkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHZhciBmb2xkZXJfcGFnZV9zaXplID0gcHJvbXB0KFxuICAgICAgICAgICAgXCJIb3cgbWFueSBpdGVtcyBwZXIgcGFnZSBkbyB5b3Ugd2FudCB0byBzZWU/XCIsXG4gICAgICAgICAgICBHYWxheHkubGlicmFyaWVzLnByZWZlcmVuY2VzLmdldChcImZvbGRlcl9wYWdlX3NpemVcIilcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKGZvbGRlcl9wYWdlX3NpemUgIT0gbnVsbCAmJiBmb2xkZXJfcGFnZV9zaXplID09IHBhcnNlSW50KGZvbGRlcl9wYWdlX3NpemUpKSB7XG4gICAgICAgICAgICBHYWxheHkubGlicmFyaWVzLnByZWZlcmVuY2VzLnNldCh7XG4gICAgICAgICAgICAgICAgZm9sZGVyX3BhZ2Vfc2l6ZTogcGFyc2VJbnQoZm9sZGVyX3BhZ2Vfc2l6ZSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgR2FsYXh5LmxpYnJhcmllcy5mb2xkZXJMaXN0Vmlldy5yZW5kZXIoe1xuICAgICAgICAgICAgICAgIGlkOiB0aGlzLm9wdGlvbnMuaWQsXG4gICAgICAgICAgICAgICAgc2hvd19wYWdlOiAxXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBmaW5kQ2hlY2tlZFJvd3M6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gJChcIiNmb2xkZXJfbGlzdF9ib2R5XCIpLmZpbmQoXCI6Y2hlY2tlZFwiKTtcbiAgICB9LFxuXG4gICAgdGVtcGxhdGVUb29sQmFyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF8udGVtcGxhdGUoXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgLy8gY29udGFpbmVyIHN0YXJ0XG4gICAgICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJsaWJyYXJ5X3N0eWxlX2NvbnRhaW5lclwiPicsXG4gICAgICAgICAgICAgICAgLy8gdG9vbGJhciBzdGFydFxuICAgICAgICAgICAgICAgICc8ZGl2IGlkPVwibGlicmFyeV90b29sYmFyXCI+JyxcbiAgICAgICAgICAgICAgICAnPGZvcm0gY2xhc3M9XCJmb3JtLWlubGluZVwiIHJvbGU9XCJmb3JtXCI+JyxcbiAgICAgICAgICAgICAgICBcIjxzcGFuPjxzdHJvbmc+REFUQSBMSUJSQVJJRVM8L3N0cm9uZz48L3NwYW4+XCIsXG4gICAgICAgICAgICAgICAgLy8gcGFnaW5hdG9yIHdpbGwgYXBwZW5kIGhlcmVcbiAgICAgICAgICAgICAgICAnPHNwYW4gY2xhc3M9XCJsaWJyYXJ5LXBhZ2luYXRvciBmb2xkZXItcGFnaW5hdG9yXCI+PC9zcGFuPicsXG4gICAgICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJjaGVja2JveCB0b29sYmFyLWl0ZW0gbG9nZ2VkLWRhdGFzZXQtbWFuaXB1bGF0aW9uXCIgc3R5bGU9XCJoZWlnaHQ6IDIwcHg7IGRpc3BsYXk6bm9uZTtcIj4nLFxuICAgICAgICAgICAgICAgIFwiPGxhYmVsPlwiLFxuICAgICAgICAgICAgICAgICc8aW5wdXQgaWQ9XCJpbmNsdWRlX2RlbGV0ZWRfZGF0YXNldHNfY2hrXCIgdHlwZT1cImNoZWNrYm94XCI+aW5jbHVkZSBkZWxldGVkPC9pbnB1dD4nLFxuICAgICAgICAgICAgICAgIFwiPC9sYWJlbD5cIixcbiAgICAgICAgICAgICAgICBcIjwvZGl2PlwiLFxuICAgICAgICAgICAgICAgICc8YnV0dG9uIHN0eWxlPVwiZGlzcGxheTpub25lO1wiIGRhdGEtdG9nZ2xlPVwidG9vbHRpcFwiIGRhdGEtcGxhY2VtZW50PVwidG9wXCIgdGl0bGU9XCJDcmVhdGUgTmV3IEZvbGRlclwiIGlkPVwidG9vbGJ0bl9jcmVhdGVfZm9sZGVyXCIgY2xhc3M9XCJidG4gYnRuLWRlZmF1bHQgcHJpbWFyeS1idXR0b24gYWRkLWxpYnJhcnktaXRlbXMgdG9vbGJhci1pdGVtXCIgdHlwZT1cImJ1dHRvblwiPicsXG4gICAgICAgICAgICAgICAgJzxzcGFuIGNsYXNzPVwiZmEgZmEtcGx1c1wiPjwvc3Bhbj48c3BhbiBjbGFzcz1cImZhIGZhLWZvbGRlclwiPjwvc3Bhbj4nLFxuICAgICAgICAgICAgICAgIFwiPC9idXR0b24+XCIsXG4gICAgICAgICAgICAgICAgXCI8JSBpZihtdXRpcGxlX2FkZF9kYXRhc2V0X29wdGlvbnMpIHsgJT5cIixcbiAgICAgICAgICAgICAgICAnPGRpdiBjbGFzcz1cImJ0bi1ncm91cCBhZGQtbGlicmFyeS1pdGVtc1wiIHN0eWxlPVwiZGlzcGxheTpub25lO1wiPicsXG4gICAgICAgICAgICAgICAgJzxidXR0b24gdGl0bGU9XCJBZGQgRGF0YXNldHMgdG8gQ3VycmVudCBGb2xkZXJcIiBpZD1cIlwiIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cInByaW1hcnktYnV0dG9uIGRyb3Bkb3duLXRvZ2dsZVwiIGRhdGEtdG9nZ2xlPVwiZHJvcGRvd25cIj4nLFxuICAgICAgICAgICAgICAgICc8c3BhbiBjbGFzcz1cImZhIGZhLXBsdXNcIj48L3NwYW4+PHNwYW4gY2xhc3M9XCJmYSBmYS1maWxlXCI+PC9zcGFuPjxzcGFuIGNsYXNzPVwiY2FyZXRcIj48L3NwYW4+JyxcbiAgICAgICAgICAgICAgICBcIjwvYnV0dG9uPlwiLFxuICAgICAgICAgICAgICAgICc8dWwgY2xhc3M9XCJkcm9wZG93bi1tZW51XCIgcm9sZT1cIm1lbnVcIj4nLFxuICAgICAgICAgICAgICAgICc8bGk+PGEgaHJlZj1cIiNmb2xkZXJzLzwlPSBpZCAlPi9pbXBvcnQvaGlzdG9yeVwiPiBmcm9tIEhpc3Rvcnk8L2E+PC9saT4nLFxuICAgICAgICAgICAgICAgIFwiPCUgaWYoR2FsYXh5LmNvbmZpZy51c2VyX2xpYnJhcnlfaW1wb3J0X2RpciAhPT0gbnVsbCkgeyAlPlwiLFxuICAgICAgICAgICAgICAgICc8bGk+PGEgaHJlZj1cIiNmb2xkZXJzLzwlPSBpZCAlPi9pbXBvcnQvdXNlcmRpclwiPiBmcm9tIFVzZXIgRGlyZWN0b3J5PC9hPjwvbGk+JyxcbiAgICAgICAgICAgICAgICBcIjwlIH0gJT5cIixcbiAgICAgICAgICAgICAgICBcIjwlIGlmKEdhbGF4eS5jb25maWcuYWxsb3dfbGlicmFyeV9wYXRoX3Bhc3RlKSB7ICU+XCIsXG4gICAgICAgICAgICAgICAgJzxsaSBjbGFzcz1cImRpdmlkZXJcIj48L2xpPicsXG4gICAgICAgICAgICAgICAgJzxsaSBjbGFzcz1cImRyb3Bkb3duLWhlYWRlclwiPkFkbWlucyBvbmx5PC9saT4nLFxuICAgICAgICAgICAgICAgIFwiPCUgaWYoR2FsYXh5LmNvbmZpZy5saWJyYXJ5X2ltcG9ydF9kaXIgIT09IG51bGwpIHsgJT5cIixcbiAgICAgICAgICAgICAgICAnPGxpPjxhIGhyZWY9XCIjZm9sZGVycy88JT0gaWQgJT4vaW1wb3J0L2ltcG9ydGRpclwiPmZyb20gSW1wb3J0IERpcmVjdG9yeTwvYT48L2xpPicsXG4gICAgICAgICAgICAgICAgXCI8JSB9ICU+XCIsXG4gICAgICAgICAgICAgICAgXCI8JSBpZihHYWxheHkuY29uZmlnLmFsbG93X2xpYnJhcnlfcGF0aF9wYXN0ZSkgeyAlPlwiLFxuICAgICAgICAgICAgICAgICc8bGk+PGEgaHJlZj1cIiNmb2xkZXJzLzwlPSBpZCAlPi9pbXBvcnQvcGF0aFwiPmZyb20gUGF0aDwvYT48L2xpPicsXG4gICAgICAgICAgICAgICAgXCI8JSB9ICU+XCIsXG4gICAgICAgICAgICAgICAgXCI8JSB9ICU+XCIsXG4gICAgICAgICAgICAgICAgXCI8L3VsPlwiLFxuICAgICAgICAgICAgICAgIFwiPC9kaXY+XCIsXG4gICAgICAgICAgICAgICAgXCI8JSB9IGVsc2UgeyAlPlwiLFxuICAgICAgICAgICAgICAgICc8YSAgZGF0YS1wbGFjZW1lbnQ9XCJ0b3BcIiB0aXRsZT1cIkFkZCBEYXRhc2V0cyB0byBDdXJyZW50IEZvbGRlclwiIHN0eWxlPVwiZGlzcGxheTpub25lO1wiIGNsYXNzPVwiYnRuIGJ0bi1kZWZhdWx0IGFkZC1saWJyYXJ5LWl0ZW1zXCIgaHJlZj1cIiNmb2xkZXJzLzwlPSBpZCAlPi9pbXBvcnQvaGlzdG9yeVwiIHJvbGU9XCJidXR0b25cIj4nLFxuICAgICAgICAgICAgICAgICc8c3BhbiBjbGFzcz1cImZhIGZhLXBsdXNcIj48L3NwYW4+PHNwYW4gY2xhc3M9XCJmYSBmYS1maWxlXCI+PC9zcGFuPicsXG4gICAgICAgICAgICAgICAgXCI8L2E+XCIsXG4gICAgICAgICAgICAgICAgXCI8JSB9ICU+XCIsXG4gICAgICAgICAgICAgICAgJzxidXR0b24gZGF0YS10b2dnbGU9XCJ0b29sdGlwXCIgZGF0YS1wbGFjZW1lbnQ9XCJ0b3BcIiB0aXRsZT1cIkltcG9ydCBzZWxlY3RlZCBkYXRhc2V0cyBpbnRvIGhpc3RvcnlcIiBpZD1cInRvb2xidG5fYnVsa19pbXBvcnRcIiBjbGFzcz1cInByaW1hcnktYnV0dG9uIGRhdGFzZXQtbWFuaXB1bGF0aW9uXCIgc3R5bGU9XCJtYXJnaW4tbGVmdDogMC41ZW07IGRpc3BsYXk6bm9uZTtcIiB0eXBlPVwiYnV0dG9uXCI+JyxcbiAgICAgICAgICAgICAgICAnPHNwYW4gY2xhc3M9XCJmYSBmYS1ib29rXCI+PC9zcGFuPicsXG4gICAgICAgICAgICAgICAgXCImbmJzcDt0byBIaXN0b3J5XCIsXG4gICAgICAgICAgICAgICAgXCI8L2J1dHRvbj5cIixcbiAgICAgICAgICAgICAgICAnPGRpdiBjbGFzcz1cImJ0bi1ncm91cCBkYXRhc2V0LW1hbmlwdWxhdGlvblwiIHN0eWxlPVwibWFyZ2luLWxlZnQ6IDAuNWVtOyBkaXNwbGF5Om5vbmU7IFwiPicsXG4gICAgICAgICAgICAgICAgJzxidXR0b24gdGl0bGU9XCJEb3dubG9hZCBzZWxlY3RlZCBpdGVtcyBhcyBhcmNoaXZlXCIgdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwicHJpbWFyeS1idXR0b24gZHJvcGRvd24tdG9nZ2xlXCIgZGF0YS10b2dnbGU9XCJkcm9wZG93blwiPicsXG4gICAgICAgICAgICAgICAgJzxzcGFuIGNsYXNzPVwiZmEgZmEtZG93bmxvYWRcIj48L3NwYW4+IERvd25sb2FkIDxzcGFuIGNsYXNzPVwiY2FyZXRcIj48L3NwYW4+JyxcbiAgICAgICAgICAgICAgICBcIjwvYnV0dG9uPlwiLFxuICAgICAgICAgICAgICAgICc8dWwgY2xhc3M9XCJkcm9wZG93bi1tZW51XCIgcm9sZT1cIm1lbnVcIj4nLFxuICAgICAgICAgICAgICAgICc8bGk+PGEgaHJlZj1cIiMvZm9sZGVycy88JT0gaWQgJT4vZG93bmxvYWQvdGd6XCI+LnRhci5nejwvYT48L2xpPicsXG4gICAgICAgICAgICAgICAgJzxsaT48YSBocmVmPVwiIy9mb2xkZXJzLzwlPSBpZCAlPi9kb3dubG9hZC90YnpcIj4udGFyLmJ6PC9hPjwvbGk+JyxcbiAgICAgICAgICAgICAgICAnPGxpPjxhIGhyZWY9XCIjL2ZvbGRlcnMvPCU9IGlkICU+L2Rvd25sb2FkL3ppcFwiPi56aXA8L2E+PC9saT4nLFxuICAgICAgICAgICAgICAgIFwiPC91bD5cIixcbiAgICAgICAgICAgICAgICBcIjwvZGl2PlwiLFxuICAgICAgICAgICAgICAgICc8YnV0dG9uIGRhdGEtdG9nZ2xlPVwidG9vbHRpcFwiIGRhdGEtcGxhY2VtZW50PVwidG9wXCIgdGl0bGU9XCJNYXJrIHNlbGVjdGVkIGl0ZW1zIGRlbGV0ZWRcIiBpZD1cInRvb2xidG5fYnVsa19kZWxldGVcIiBjbGFzcz1cInByaW1hcnktYnV0dG9uIGxvZ2dlZC1kYXRhc2V0LW1hbmlwdWxhdGlvblwiIHN0eWxlPVwibWFyZ2luLWxlZnQ6IDAuNWVtOyBkaXNwbGF5Om5vbmU7IFwiIHR5cGU9XCJidXR0b25cIj4nLFxuICAgICAgICAgICAgICAgICc8c3BhbiBjbGFzcz1cImZhIGZhLXRpbWVzXCI+PC9zcGFuPiBEZWxldGU8L2J1dHRvbj4nLFxuICAgICAgICAgICAgICAgICc8YnV0dG9uIGRhdGEtaWQ9XCI8JS0gaWQgJT5cIiBkYXRhLXRvZ2dsZT1cInRvb2x0aXBcIiBkYXRhLXBsYWNlbWVudD1cInRvcFwiIHRpdGxlPVwiU2hvdyBsb2NhdGlvbiBkZXRhaWxzXCIgY2xhc3M9XCJwcmltYXJ5LWJ1dHRvbiB0b29sYnRuLXNob3ctbG9jaW5mb1wiIHN0eWxlPVwibWFyZ2luLWxlZnQ6IDAuNWVtO1wiIHR5cGU9XCJidXR0b25cIj4nLFxuICAgICAgICAgICAgICAgICc8c3BhbiBjbGFzcz1cImZhIGZhLWluZm8tY2lyY2xlXCI+PC9zcGFuPicsXG4gICAgICAgICAgICAgICAgXCImbmJzcDtEZXRhaWxzXCIsXG4gICAgICAgICAgICAgICAgXCI8L2J1dHRvbj5cIixcbiAgICAgICAgICAgICAgICAnPHNwYW4gY2xhc3M9XCJoZWxwLWJ1dHRvblwiIGRhdGEtdG9nZ2xlPVwidG9vbHRpcFwiIGRhdGEtcGxhY2VtZW50PVwidG9wXCIgdGl0bGU9XCJTZWUgdGhpcyBzY3JlZW4gYW5ub3RhdGVkXCI+JyxcbiAgICAgICAgICAgICAgICAnPGEgaHJlZj1cImh0dHBzOi8vZ2FsYXh5cHJvamVjdC5vcmcvZGF0YS1saWJyYXJpZXMvc2NyZWVuL2ZvbGRlci1jb250ZW50cy9cIiB0YXJnZXQ9XCJfYmxhbmtcIj4nLFxuICAgICAgICAgICAgICAgICc8YnV0dG9uIGNsYXNzPVwicHJpbWFyeS1idXR0b25cIiB0eXBlPVwiYnV0dG9uXCI+JyxcbiAgICAgICAgICAgICAgICAnPHNwYW4gY2xhc3M9XCJmYSBmYS1xdWVzdGlvbi1jaXJjbGVcIj48L3NwYW4+JyxcbiAgICAgICAgICAgICAgICBcIiZuYnNwO0hlbHBcIixcbiAgICAgICAgICAgICAgICBcIjwvYnV0dG9uPlwiLFxuICAgICAgICAgICAgICAgIFwiPC9hPlwiLFxuICAgICAgICAgICAgICAgIFwiPC9zcGFuPlwiLFxuICAgICAgICAgICAgICAgIFwiPC9kaXY+XCIsXG4gICAgICAgICAgICAgICAgXCI8L2Zvcm0+XCIsXG4gICAgICAgICAgICAgICAgLy8gdG9vbGJhciBlbmRcbiAgICAgICAgICAgICAgICAnPGRpdiBpZD1cImZvbGRlcl9pdGVtc19lbGVtZW50XCI+JyxcbiAgICAgICAgICAgICAgICBcIjwvZGl2PlwiLFxuICAgICAgICAgICAgICAgIC8vIHBhZ2luYXRvciB3aWxsIGFwcGVuZCBoZXJlXG4gICAgICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJmb2xkZXItcGFnaW5hdG9yIHBhZ2luYXRvci1ib3R0b21cIj48L2Rpdj4nLFxuICAgICAgICAgICAgICAgIC8vIGNvbnRhaW5lciBlbmRcbiAgICAgICAgICAgICAgICBcIjwvZGl2PlwiXG4gICAgICAgICAgICBdLmpvaW4oXCJcIilcbiAgICAgICAgKTtcbiAgICB9LFxuXG4gICAgdGVtcGxhdGVMb2NJbmZvSW5Nb2RhbDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfLnRlbXBsYXRlKFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiPGRpdj5cIixcbiAgICAgICAgICAgICAgICAnPHRhYmxlIGNsYXNzPVwiZ3JpZCB0YWJsZSB0YWJsZS1jb25kZW5zZWRcIj4nLFxuICAgICAgICAgICAgICAgIFwiPHRoZWFkPlwiLFxuICAgICAgICAgICAgICAgICc8dGggc3R5bGU9XCJ3aWR0aDogMjUlO1wiPmxpYnJhcnk8L3RoPicsXG4gICAgICAgICAgICAgICAgXCI8dGg+PC90aD5cIixcbiAgICAgICAgICAgICAgICBcIjwvdGhlYWQ+XCIsXG4gICAgICAgICAgICAgICAgXCI8dGJvZHk+XCIsXG4gICAgICAgICAgICAgICAgXCI8dHI+XCIsXG4gICAgICAgICAgICAgICAgXCI8dGQ+bmFtZTwvdGQ+XCIsXG4gICAgICAgICAgICAgICAgJzx0ZD48JS0gbGlicmFyeS5nZXQoXCJuYW1lXCIpICU+PC90ZD4nLFxuICAgICAgICAgICAgICAgIFwiPC90cj5cIixcbiAgICAgICAgICAgICAgICAnPCUgaWYobGlicmFyeS5nZXQoXCJkZXNjcmlwdGlvblwiKSAhPT0gXCJcIikgeyAlPicsXG4gICAgICAgICAgICAgICAgXCI8dHI+XCIsXG4gICAgICAgICAgICAgICAgXCI8dGQ+ZGVzY3JpcHRpb248L3RkPlwiLFxuICAgICAgICAgICAgICAgICc8dGQ+PCUtIGxpYnJhcnkuZ2V0KFwiZGVzY3JpcHRpb25cIikgJT48L3RkPicsXG4gICAgICAgICAgICAgICAgXCI8L3RyPlwiLFxuICAgICAgICAgICAgICAgIFwiPCUgfSAlPlwiLFxuICAgICAgICAgICAgICAgICc8JSBpZihsaWJyYXJ5LmdldChcInN5bm9wc2lzXCIpICE9PSBcIlwiKSB7ICU+JyxcbiAgICAgICAgICAgICAgICBcIjx0cj5cIixcbiAgICAgICAgICAgICAgICBcIjx0ZD5zeW5vcHNpczwvdGQ+XCIsXG4gICAgICAgICAgICAgICAgJzx0ZD48JS0gbGlicmFyeS5nZXQoXCJzeW5vcHNpc1wiKSAlPjwvdGQ+JyxcbiAgICAgICAgICAgICAgICBcIjwvdHI+XCIsXG4gICAgICAgICAgICAgICAgXCI8JSB9ICU+XCIsXG4gICAgICAgICAgICAgICAgJzwlIGlmKGxpYnJhcnkuZ2V0KFwiY3JlYXRlX3RpbWVfcHJldHR5XCIpICE9PSBcIlwiKSB7ICU+JyxcbiAgICAgICAgICAgICAgICBcIjx0cj5cIixcbiAgICAgICAgICAgICAgICBcIjx0ZD5jcmVhdGVkPC90ZD5cIixcbiAgICAgICAgICAgICAgICAnPHRkPjxzcGFuIHRpdGxlPVwiPCUtIGxpYnJhcnkuZ2V0KFwiY3JlYXRlX3RpbWVcIikgJT5cIj48JS0gbGlicmFyeS5nZXQoXCJjcmVhdGVfdGltZV9wcmV0dHlcIikgJT48L3NwYW4+PC90ZD4nLFxuICAgICAgICAgICAgICAgIFwiPC90cj5cIixcbiAgICAgICAgICAgICAgICBcIjwlIH0gJT5cIixcbiAgICAgICAgICAgICAgICBcIjx0cj5cIixcbiAgICAgICAgICAgICAgICBcIjx0ZD5pZDwvdGQ+XCIsXG4gICAgICAgICAgICAgICAgJzx0ZD48JS0gbGlicmFyeS5nZXQoXCJpZFwiKSAlPjwvdGQ+JyxcbiAgICAgICAgICAgICAgICBcIjwvdHI+XCIsXG4gICAgICAgICAgICAgICAgXCI8L3Rib2R5PlwiLFxuICAgICAgICAgICAgICAgIFwiPC90YWJsZT5cIixcbiAgICAgICAgICAgICAgICAnPHRhYmxlIGNsYXNzPVwiZ3JpZCB0YWJsZSB0YWJsZS1jb25kZW5zZWRcIj4nLFxuICAgICAgICAgICAgICAgIFwiPHRoZWFkPlwiLFxuICAgICAgICAgICAgICAgICc8dGggc3R5bGU9XCJ3aWR0aDogMjUlO1wiPmZvbGRlcjwvdGg+JyxcbiAgICAgICAgICAgICAgICBcIjx0aD48L3RoPlwiLFxuICAgICAgICAgICAgICAgIFwiPC90aGVhZD5cIixcbiAgICAgICAgICAgICAgICBcIjx0Ym9keT5cIixcbiAgICAgICAgICAgICAgICBcIjx0cj5cIixcbiAgICAgICAgICAgICAgICBcIjx0ZD5uYW1lPC90ZD5cIixcbiAgICAgICAgICAgICAgICBcIjx0ZD48JS0gb3B0aW9ucy5mb2xkZXJfbmFtZSAlPjwvdGQ+XCIsXG4gICAgICAgICAgICAgICAgXCI8L3RyPlwiLFxuICAgICAgICAgICAgICAgICc8JSBpZihvcHRpb25zLmZvbGRlcl9kZXNjcmlwdGlvbiAhPT0gXCJcIikgeyAlPicsXG4gICAgICAgICAgICAgICAgXCI8dHI+XCIsXG4gICAgICAgICAgICAgICAgXCI8dGQ+ZGVzY3JpcHRpb248L3RkPlwiLFxuICAgICAgICAgICAgICAgIFwiPHRkPjwlLSBvcHRpb25zLmZvbGRlcl9kZXNjcmlwdGlvbiAlPjwvdGQ+XCIsXG4gICAgICAgICAgICAgICAgXCI8L3RyPlwiLFxuICAgICAgICAgICAgICAgIFwiPCUgfSAlPlwiLFxuICAgICAgICAgICAgICAgIFwiPHRyPlwiLFxuICAgICAgICAgICAgICAgIFwiPHRkPmlkPC90ZD5cIixcbiAgICAgICAgICAgICAgICBcIjx0ZD48JS0gb3B0aW9ucy5pZCAlPjwvdGQ+XCIsXG4gICAgICAgICAgICAgICAgXCI8L3RyPlwiLFxuICAgICAgICAgICAgICAgIFwiPC90Ym9keT5cIixcbiAgICAgICAgICAgICAgICBcIjwvdGFibGU+XCIsXG4gICAgICAgICAgICAgICAgXCI8L2Rpdj5cIlxuICAgICAgICAgICAgXS5qb2luKFwiXCIpXG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIHRlbXBsYXRlTmV3Rm9sZGVySW5Nb2RhbDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfLnRlbXBsYXRlKFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICc8ZGl2IGlkPVwibmV3X2ZvbGRlcl9tb2RhbFwiPicsXG4gICAgICAgICAgICAgICAgXCI8Zm9ybT5cIixcbiAgICAgICAgICAgICAgICAnPGlucHV0IHR5cGU9XCJ0ZXh0XCIgbmFtZT1cIk5hbWVcIiB2YWx1ZT1cIlwiIHBsYWNlaG9sZGVyPVwiTmFtZVwiIGF1dG9mb2N1cz4nLFxuICAgICAgICAgICAgICAgICc8aW5wdXQgdHlwZT1cInRleHRcIiBuYW1lPVwiRGVzY3JpcHRpb25cIiB2YWx1ZT1cIlwiIHBsYWNlaG9sZGVyPVwiRGVzY3JpcHRpb25cIj4nLFxuICAgICAgICAgICAgICAgIFwiPC9mb3JtPlwiLFxuICAgICAgICAgICAgICAgIFwiPC9kaXY+XCJcbiAgICAgICAgICAgIF0uam9pbihcIlwiKVxuICAgICAgICApO1xuICAgIH0sXG5cbiAgICB0ZW1wbGF0ZUJ1bGtJbXBvcnRJbk1vZGFsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF8udGVtcGxhdGUoXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCI8ZGl2PlwiLFxuICAgICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwibGlicmFyeS1tb2RhbC1pdGVtXCI+JyxcbiAgICAgICAgICAgICAgICBcIlNlbGVjdCBoaXN0b3J5OiBcIixcbiAgICAgICAgICAgICAgICAnPHNlbGVjdCBpZD1cImRhdGFzZXRfaW1wb3J0X2J1bGtcIiBuYW1lPVwiZGF0YXNldF9pbXBvcnRfYnVsa1wiIHN0eWxlPVwid2lkdGg6NTAlOyBtYXJnaW4tYm90dG9tOiAxZW07IFwiIGF1dG9mb2N1cz4nLFxuICAgICAgICAgICAgICAgIFwiPCUgXy5lYWNoKGhpc3RvcmllcywgZnVuY3Rpb24oaGlzdG9yeSkgeyAlPlwiLFxuICAgICAgICAgICAgICAgICc8b3B0aW9uIHZhbHVlPVwiPCU9IF8uZXNjYXBlKGhpc3RvcnkuZ2V0KFwiaWRcIikpICU+XCI+PCU9IF8uZXNjYXBlKGhpc3RvcnkuZ2V0KFwibmFtZVwiKSkgJT48L29wdGlvbj4nLFxuICAgICAgICAgICAgICAgIFwiPCUgfSk7ICU+XCIsXG4gICAgICAgICAgICAgICAgXCI8L3NlbGVjdD5cIixcbiAgICAgICAgICAgICAgICBcIjwvZGl2PlwiLFxuICAgICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwibGlicmFyeS1tb2RhbC1pdGVtXCI+JyxcbiAgICAgICAgICAgICAgICBcIm9yIGNyZWF0ZSBuZXc6IFwiLFxuICAgICAgICAgICAgICAgICc8aW5wdXQgdHlwZT1cInRleHRcIiBuYW1lPVwiaGlzdG9yeV9uYW1lXCIgdmFsdWU9XCJcIiBwbGFjZWhvbGRlcj1cIm5hbWUgb2YgdGhlIG5ldyBoaXN0b3J5XCIgc3R5bGU9XCJ3aWR0aDo1MCU7XCI+JyxcbiAgICAgICAgICAgICAgICBcIjwvaW5wdXQ+XCIsXG4gICAgICAgICAgICAgICAgXCI8L2Rpdj5cIixcbiAgICAgICAgICAgICAgICBcIjwvZGl2PlwiXG4gICAgICAgICAgICBdLmpvaW4oXCJcIilcbiAgICAgICAgKTtcbiAgICB9LFxuXG4gICAgdGVtcGxhdGVJbXBvcnRJbnRvSGlzdG9yeVByb2dyZXNzQmFyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF8udGVtcGxhdGUoXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJpbXBvcnRfdGV4dFwiPicsXG4gICAgICAgICAgICAgICAgXCJJbXBvcnRpbmcgc2VsZWN0ZWQgaXRlbXMgdG8gaGlzdG9yeSA8Yj48JT0gXy5lc2NhcGUoaGlzdG9yeV9uYW1lKSAlPjwvYj5cIixcbiAgICAgICAgICAgICAgICBcIjwvZGl2PlwiLFxuICAgICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwicHJvZ3Jlc3NcIj4nLFxuICAgICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwicHJvZ3Jlc3MtYmFyIHByb2dyZXNzLWJhci1pbXBvcnRcIiByb2xlPVwicHJvZ3Jlc3NiYXJcIiBhcmlhLXZhbHVlbm93PVwiMFwiIGFyaWEtdmFsdWVtaW49XCIwXCIgYXJpYS12YWx1ZW1heD1cIjEwMFwiIHN0eWxlPVwid2lkdGg6IDAwJTtcIj4nLFxuICAgICAgICAgICAgICAgICc8c3BhbiBjbGFzcz1cImNvbXBsZXRpb25fc3BhblwiPjAlIENvbXBsZXRlPC9zcGFuPicsXG4gICAgICAgICAgICAgICAgXCI8L2Rpdj5cIixcbiAgICAgICAgICAgICAgICBcIjwvZGl2PlwiXG4gICAgICAgICAgICBdLmpvaW4oXCJcIilcbiAgICAgICAgKTtcbiAgICB9LFxuXG4gICAgdGVtcGxhdGVBZGRpbmdEYXRhc2V0c1Byb2dyZXNzQmFyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF8udGVtcGxhdGUoXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJpbXBvcnRfdGV4dFwiPicsXG4gICAgICAgICAgICAgICAgXCJBZGRpbmcgc2VsZWN0ZWQgZGF0YXNldHMgdG8gbGlicmFyeSBmb2xkZXIgPGI+PCU9IF8uZXNjYXBlKGZvbGRlcl9uYW1lKSAlPjwvYj5cIixcbiAgICAgICAgICAgICAgICBcIjwvZGl2PlwiLFxuICAgICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwicHJvZ3Jlc3NcIj4nLFxuICAgICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwicHJvZ3Jlc3MtYmFyIHByb2dyZXNzLWJhci1pbXBvcnRcIiByb2xlPVwicHJvZ3Jlc3NiYXJcIiBhcmlhLXZhbHVlbm93PVwiMFwiIGFyaWEtdmFsdWVtaW49XCIwXCIgYXJpYS12YWx1ZW1heD1cIjEwMFwiIHN0eWxlPVwid2lkdGg6IDAwJTtcIj4nLFxuICAgICAgICAgICAgICAgICc8c3BhbiBjbGFzcz1cImNvbXBsZXRpb25fc3BhblwiPjAlIENvbXBsZXRlPC9zcGFuPicsXG4gICAgICAgICAgICAgICAgXCI8L2Rpdj5cIixcbiAgICAgICAgICAgICAgICBcIjwvZGl2PlwiXG4gICAgICAgICAgICBdLmpvaW4oXCJcIilcbiAgICAgICAgKTtcbiAgICB9LFxuXG4gICAgdGVtcGxhdGVEZWxldGluZ0l0ZW1zUHJvZ3Jlc3NCYXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gXy50ZW1wbGF0ZShcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnPGRpdiBjbGFzcz1cImltcG9ydF90ZXh0XCI+JyxcbiAgICAgICAgICAgICAgICBcIjwvZGl2PlwiLFxuICAgICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwicHJvZ3Jlc3NcIj4nLFxuICAgICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwicHJvZ3Jlc3MtYmFyIHByb2dyZXNzLWJhci1pbXBvcnRcIiByb2xlPVwicHJvZ3Jlc3NiYXJcIiBhcmlhLXZhbHVlbm93PVwiMFwiIGFyaWEtdmFsdWVtaW49XCIwXCIgYXJpYS12YWx1ZW1heD1cIjEwMFwiIHN0eWxlPVwid2lkdGg6IDAwJTtcIj4nLFxuICAgICAgICAgICAgICAgICc8c3BhbiBjbGFzcz1cImNvbXBsZXRpb25fc3BhblwiPjAlIENvbXBsZXRlPC9zcGFuPicsXG4gICAgICAgICAgICAgICAgXCI8L2Rpdj5cIixcbiAgICAgICAgICAgICAgICBcIjwvZGl2PlwiXG4gICAgICAgICAgICBdLmpvaW4oXCJcIilcbiAgICAgICAgKTtcbiAgICB9LFxuXG4gICAgdGVtcGxhdGVCcm93c2VyTW9kYWw6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gXy50ZW1wbGF0ZShcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnPGRpdiBpZD1cImZpbGVfYnJvd3Nlcl9tb2RhbFwiPicsXG4gICAgICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJhbGVydCBhbGVydC1pbmZvIGpzdHJlZS1maWxlcy1tZXNzYWdlXCI+QWxsIGZpbGVzIHlvdSBzZWxlY3Qgd2lsbCBiZSBpbXBvcnRlZCBpbnRvIHRoZSBjdXJyZW50IGZvbGRlciBpZ25vcmluZyB0aGVpciBmb2xkZXIgc3RydWN0dXJlLjwvZGl2PicsXG4gICAgICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJhbGVydCBhbGVydC1pbmZvIGpzdHJlZS1mb2xkZXJzLW1lc3NhZ2VcIiBzdHlsZT1cImRpc3BsYXk6bm9uZTtcIj5BbGwgZmlsZXMgd2l0aGluIHRoZSBzZWxlY3RlZCBmb2xkZXJzIGFuZCB0aGVpciBzdWJmb2xkZXJzIHdpbGwgYmUgaW1wb3J0ZWQgaW50byB0aGUgY3VycmVudCBmb2xkZXIuPC9kaXY+JyxcbiAgICAgICAgICAgICAgICAnPGRpdiBzdHlsZT1cIm1hcmdpbi1ib3R0b206MWVtO1wiPicsXG4gICAgICAgICAgICAgICAgJzxsYWJlbCB0aXRsZT1cIlN3aXRjaCB0byBzZWxlY3RpbmcgZmlsZXNcIiBjbGFzcz1cInJhZGlvLWlubGluZSBpbXBvcnQtdHlwZS1zd2l0Y2hcIj4nLFxuICAgICAgICAgICAgICAgICc8aW5wdXQgdHlwZT1cInJhZGlvXCIgbmFtZT1cImpzdHJlZS1yYWRpb1wiIHZhbHVlPVwianN0cmVlLWRpc2FibGUtZm9sZGVyc1wiIGNoZWNrZWQ9XCJjaGVja2VkXCI+IENob29zZSBGaWxlcycsXG4gICAgICAgICAgICAgICAgXCI8L2xhYmVsPlwiLFxuICAgICAgICAgICAgICAgICc8bGFiZWwgdGl0bGU9XCJTd2l0Y2ggdG8gc2VsZWN0aW5nIGZvbGRlcnNcIiBjbGFzcz1cInJhZGlvLWlubGluZSBpbXBvcnQtdHlwZS1zd2l0Y2hcIj4nLFxuICAgICAgICAgICAgICAgICc8aW5wdXQgdHlwZT1cInJhZGlvXCIgbmFtZT1cImpzdHJlZS1yYWRpb1wiIHZhbHVlPVwianN0cmVlLWRpc2FibGUtZmlsZXNcIj4gQ2hvb3NlIEZvbGRlcnMnLFxuICAgICAgICAgICAgICAgIFwiPC9sYWJlbD5cIixcbiAgICAgICAgICAgICAgICBcIjwvZGl2PlwiLFxuICAgICAgICAgICAgICAgICc8ZGl2IHN0eWxlPVwibWFyZ2luLWJvdHRvbToxZW07XCI+JyxcbiAgICAgICAgICAgICAgICAnPGxhYmVsIGNsYXNzPVwiY2hlY2tib3gtaW5saW5lIGpzdHJlZS1wcmVzZXJ2ZS1zdHJ1Y3R1cmVcIiBzdHlsZT1cImRpc3BsYXk6bm9uZTtcIj4nLFxuICAgICAgICAgICAgICAgICc8aW5wdXQgY2xhc3M9XCJwcmVzZXJ2ZS1jaGVja2JveFwiIHR5cGU9XCJjaGVja2JveFwiIHZhbHVlPVwicHJlc2VydmVfZGlyZWN0b3J5X3N0cnVjdHVyZVwiPicsXG4gICAgICAgICAgICAgICAgXCJQcmVzZXJ2ZSBkaXJlY3Rvcnkgc3RydWN0dXJlXCIsXG4gICAgICAgICAgICAgICAgXCI8L2xhYmVsPlwiLFxuICAgICAgICAgICAgICAgICc8bGFiZWwgY2xhc3M9XCJjaGVja2JveC1pbmxpbmVcIj4nLFxuICAgICAgICAgICAgICAgICc8aW5wdXQgY2xhc3M9XCJsaW5rLWNoZWNrYm94XCIgdHlwZT1cImNoZWNrYm94XCIgdmFsdWU9XCJsaW5rX2ZpbGVzXCI+JyxcbiAgICAgICAgICAgICAgICBcIkxpbmsgZmlsZXMgaW5zdGVhZCBvZiBjb3B5aW5nXCIsXG4gICAgICAgICAgICAgICAgXCI8L2xhYmVsPlwiLFxuICAgICAgICAgICAgICAgICc8bGFiZWwgY2xhc3M9XCJjaGVja2JveC1pbmxpbmVcIj4nLFxuICAgICAgICAgICAgICAgICc8aW5wdXQgY2xhc3M9XCJwb3NpeC1jaGVja2JveFwiIHR5cGU9XCJjaGVja2JveFwiIHZhbHVlPVwidG9fcG9zaXhfbGluZXNcIiBjaGVja2VkPVwiY2hlY2tlZFwiPicsXG4gICAgICAgICAgICAgICAgXCJDb252ZXJ0IGxpbmUgZW5kaW5ncyB0byBQT1NJWFwiLFxuICAgICAgICAgICAgICAgIFwiPC9sYWJlbD5cIixcbiAgICAgICAgICAgICAgICAnPGxhYmVsIGNsYXNzPVwiY2hlY2tib3gtaW5saW5lXCI+JyxcbiAgICAgICAgICAgICAgICAnPGlucHV0IGNsYXNzPVwic3BhY2V0YWItY2hlY2tib3hcIiB0eXBlPVwiY2hlY2tib3hcIiB2YWx1ZT1cInNwYWNlX3RvX3RhYlwiPicsXG4gICAgICAgICAgICAgICAgXCJDb252ZXJ0IHNwYWNlcyB0byB0YWJzXCIsXG4gICAgICAgICAgICAgICAgXCI8L2xhYmVsPlwiLFxuICAgICAgICAgICAgICAgIFwiPC9kaXY+XCIsXG4gICAgICAgICAgICAgICAgJzxidXR0b24gdGl0bGU9XCJTZWxlY3QgYWxsIGZpbGVzXCIgdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiYnV0dG9uIHByaW1hcnktYnV0dG9uIGxpYmltcG9ydC1zZWxlY3QtYWxsXCI+JyxcbiAgICAgICAgICAgICAgICBcIlNlbGVjdCBhbGxcIixcbiAgICAgICAgICAgICAgICBcIjwvYnV0dG9uPlwiLFxuICAgICAgICAgICAgICAgICc8YnV0dG9uIHRpdGxlPVwiU2VsZWN0IG5vIGZpbGVzXCIgdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiYnV0dG9uIHByaW1hcnktYnV0dG9uIGxpYmltcG9ydC1zZWxlY3Qtbm9uZVwiPicsXG4gICAgICAgICAgICAgICAgXCJVbnNlbGVjdCBhbGxcIixcbiAgICAgICAgICAgICAgICBcIjwvYnV0dG9uPlwiLFxuICAgICAgICAgICAgICAgIFwiPGhyIC8+XCIsXG4gICAgICAgICAgICAgICAgLy8gYXBwZW5kIGpzdHJlZSBvYmplY3QgaGVyZVxuICAgICAgICAgICAgICAgICc8ZGl2IGlkPVwianN0cmVlX2Jyb3dzZXJcIj4nLFxuICAgICAgICAgICAgICAgIFwiPC9kaXY+XCIsXG4gICAgICAgICAgICAgICAgXCI8aHIgLz5cIixcbiAgICAgICAgICAgICAgICBcIjxwPllvdSBjYW4gc2V0IGV4dGVuc2lvbiB0eXBlIGFuZCBnZW5vbWUgZm9yIGFsbCBpbXBvcnRlZCBkYXRhc2V0cyBhdCBvbmNlOjwvcD5cIixcbiAgICAgICAgICAgICAgICBcIjxkaXY+XCIsXG4gICAgICAgICAgICAgICAgJ1R5cGU6IDxzcGFuIGlkPVwibGlicmFyeV9leHRlbnNpb25fc2VsZWN0XCIgY2xhc3M9XCJsaWJyYXJ5LWV4dGVuc2lvbi1zZWxlY3RcIiAvPicsXG4gICAgICAgICAgICAgICAgJ0dlbm9tZTogPHNwYW4gaWQ9XCJsaWJyYXJ5X2dlbm9tZV9zZWxlY3RcIiBjbGFzcz1cImxpYnJhcnktZ2Vub21lLXNlbGVjdFwiIC8+JyxcbiAgICAgICAgICAgICAgICBcIjwvZGl2PlwiLFxuICAgICAgICAgICAgICAgIFwiPGJyPlwiLFxuICAgICAgICAgICAgICAgIFwiPGRpdj5cIixcbiAgICAgICAgICAgICAgICAnPGxhYmVsIGNsYXNzPVwiY2hlY2tib3gtaW5saW5lIHRhZy1maWxlc1wiPicsXG4gICAgICAgICAgICAgICAgXCJUYWcgZGF0YXNldHMgYmFzZWQgb24gZmlsZSBuYW1lc1wiLFxuICAgICAgICAgICAgICAgICc8aW5wdXQgY2xhc3M9XCJ0YWctZmlsZXNcIiB0eXBlPVwiY2hlY2tib3hcIiB2YWx1ZT1cInRhZ191c2luZ19maWxlbmFtZXNcIj4nLFxuICAgICAgICAgICAgICAgIFwiPC9sYWJlbD5cIixcbiAgICAgICAgICAgICAgICBcIjwvZGl2PlwiLFxuICAgICAgICAgICAgICAgIFwiPC9kaXY+XCJcbiAgICAgICAgICAgIF0uam9pbihcIlwiKVxuICAgICAgICApO1xuICAgIH0sXG5cbiAgICB0ZW1wbGF0ZUltcG9ydFBhdGhNb2RhbDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfLnRlbXBsYXRlKFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICc8ZGl2IGlkPVwiZmlsZV9icm93c2VyX21vZGFsXCI+JyxcbiAgICAgICAgICAgICAgICAnPGRpdiBjbGFzcz1cImFsZXJ0IGFsZXJ0LWluZm8ganN0cmVlLWZvbGRlcnMtbWVzc2FnZVwiPkFsbCBmaWxlcyB3aXRoaW4gdGhlIGdpdmVuIGZvbGRlcnMgYW5kIHRoZWlyIHN1YmZvbGRlcnMgd2lsbCBiZSBpbXBvcnRlZCBpbnRvIHRoZSBjdXJyZW50IGZvbGRlci48L2Rpdj4nLFxuICAgICAgICAgICAgICAgICc8ZGl2IHN0eWxlPVwibWFyZ2luLWJvdHRvbTogMC41ZW07XCI+JyxcbiAgICAgICAgICAgICAgICAnPGxhYmVsIGNsYXNzPVwiY2hlY2tib3gtaW5saW5lXCI+JyxcbiAgICAgICAgICAgICAgICAnPGlucHV0IGNsYXNzPVwicHJlc2VydmUtY2hlY2tib3hcIiB0eXBlPVwiY2hlY2tib3hcIiB2YWx1ZT1cInByZXNlcnZlX2RpcmVjdG9yeV9zdHJ1Y3R1cmVcIj4nLFxuICAgICAgICAgICAgICAgIFwiUHJlc2VydmUgZGlyZWN0b3J5IHN0cnVjdHVyZVwiLFxuICAgICAgICAgICAgICAgIFwiPC9sYWJlbD5cIixcbiAgICAgICAgICAgICAgICAnPGxhYmVsIGNsYXNzPVwiY2hlY2tib3gtaW5saW5lXCI+JyxcbiAgICAgICAgICAgICAgICAnPGlucHV0IGNsYXNzPVwibGluay1jaGVja2JveFwiIHR5cGU9XCJjaGVja2JveFwiIHZhbHVlPVwibGlua19maWxlc1wiPicsXG4gICAgICAgICAgICAgICAgXCJMaW5rIGZpbGVzIGluc3RlYWQgb2YgY29weWluZ1wiLFxuICAgICAgICAgICAgICAgIFwiPC9sYWJlbD5cIixcbiAgICAgICAgICAgICAgICBcIjxicj5cIixcbiAgICAgICAgICAgICAgICAnPGxhYmVsIGNsYXNzPVwiY2hlY2tib3gtaW5saW5lXCI+JyxcbiAgICAgICAgICAgICAgICAnPGlucHV0IGNsYXNzPVwicG9zaXgtY2hlY2tib3hcIiB0eXBlPVwiY2hlY2tib3hcIiB2YWx1ZT1cInRvX3Bvc2l4X2xpbmVzXCIgY2hlY2tlZD1cImNoZWNrZWRcIj4nLFxuICAgICAgICAgICAgICAgIFwiQ29udmVydCBsaW5lIGVuZGluZ3MgdG8gUE9TSVhcIixcbiAgICAgICAgICAgICAgICBcIjwvbGFiZWw+XCIsXG4gICAgICAgICAgICAgICAgJzxsYWJlbCBjbGFzcz1cImNoZWNrYm94LWlubGluZVwiPicsXG4gICAgICAgICAgICAgICAgJzxpbnB1dCBjbGFzcz1cInNwYWNldGFiLWNoZWNrYm94XCIgdHlwZT1cImNoZWNrYm94XCIgdmFsdWU9XCJzcGFjZV90b190YWJcIj4nLFxuICAgICAgICAgICAgICAgIFwiQ29udmVydCBzcGFjZXMgdG8gdGFic1wiLFxuICAgICAgICAgICAgICAgIFwiPC9sYWJlbD5cIixcbiAgICAgICAgICAgICAgICBcIjwvZGl2PlwiLFxuICAgICAgICAgICAgICAgICc8dGV4dGFyZWEgaWQ9XCJpbXBvcnRfcGF0aHNcIiBjbGFzcz1cImZvcm0tY29udHJvbFwiIHJvd3M9XCI1XCIgcGxhY2Vob2xkZXI9XCJBYnNvbHV0ZSBwYXRocyAob3IgcGF0aHMgcmVsYXRpdmUgdG8gR2FsYXh5IHJvb3QpIHNlcGFyYXRlZCBieSBuZXdsaW5lXCIgYXV0b2ZvY3VzPjwvdGV4dGFyZWE+JyxcbiAgICAgICAgICAgICAgICBcIjxociAvPlwiLFxuICAgICAgICAgICAgICAgIFwiPHA+WW91IGNhbiBzZXQgZXh0ZW5zaW9uIHR5cGUgYW5kIGdlbm9tZSBmb3IgYWxsIGltcG9ydGVkIGRhdGFzZXRzIGF0IG9uY2U6PC9wPlwiLFxuICAgICAgICAgICAgICAgIFwiPGRpdj5cIixcbiAgICAgICAgICAgICAgICAnVHlwZTogPHNwYW4gaWQ9XCJsaWJyYXJ5X2V4dGVuc2lvbl9zZWxlY3RcIiBjbGFzcz1cImxpYnJhcnktZXh0ZW5zaW9uLXNlbGVjdFwiIC8+JyxcbiAgICAgICAgICAgICAgICAnR2Vub21lOiA8c3BhbiBpZD1cImxpYnJhcnlfZ2Vub21lX3NlbGVjdFwiIGNsYXNzPVwibGlicmFyeS1nZW5vbWUtc2VsZWN0XCIgLz4nLFxuICAgICAgICAgICAgICAgIFwiPC9kaXY+XCIsXG4gICAgICAgICAgICAgICAgXCI8ZGl2PlwiLFxuICAgICAgICAgICAgICAgICc8bGFiZWwgY2xhc3M9XCJjaGVja2JveC1pbmxpbmUgdGFnLWZpbGVzXCI+JyxcbiAgICAgICAgICAgICAgICBcIlRhZyBkYXRhc2V0cyBiYXNlZCBvbiBmaWxlIG5hbWVzXCIsXG4gICAgICAgICAgICAgICAgJzxpbnB1dCBjbGFzcz1cInRhZy1maWxlc1wiIHR5cGU9XCJjaGVja2JveFwiIHZhbHVlPVwidGFnX3VzaW5nX2ZpbGVuYW1lc1wiPicsXG4gICAgICAgICAgICAgICAgXCI8L2xhYmVsPlwiLFxuICAgICAgICAgICAgICAgIFwiPC9kaXY+XCIsXG4gICAgICAgICAgICAgICAgXCI8L2Rpdj5cIlxuICAgICAgICAgICAgXS5qb2luKFwiXCIpXG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIHRlbXBsYXRlQWRkRmlsZXNGcm9tSGlzdG9yeTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfLnRlbXBsYXRlKFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICc8ZGl2IGlkPVwiYWRkX2ZpbGVzX21vZGFsXCI+JyxcbiAgICAgICAgICAgICAgICBcIjxkaXY+XCIsXG4gICAgICAgICAgICAgICAgXCIxLiZuYnNwO1NlbGVjdCBoaXN0b3J5OiZuYnNwO1wiLFxuICAgICAgICAgICAgICAgICc8c2VsZWN0IGlkPVwiZGF0YXNldF9hZGRfYnVsa1wiIG5hbWU9XCJkYXRhc2V0X2FkZF9idWxrXCIgc3R5bGU9XCJ3aWR0aDo2NiU7IFwiPiAnLFxuICAgICAgICAgICAgICAgIFwiPCUgXy5lYWNoKGhpc3RvcmllcywgZnVuY3Rpb24oaGlzdG9yeSkgeyAlPlwiLCAvL2hpc3Rvcnkgc2VsZWN0IGJveFxuICAgICAgICAgICAgICAgICc8b3B0aW9uIHZhbHVlPVwiPCU9IF8uZXNjYXBlKGhpc3RvcnkuZ2V0KFwiaWRcIikpICU+XCI+PCU9IF8uZXNjYXBlKGhpc3RvcnkuZ2V0KFwibmFtZVwiKSkgJT48L29wdGlvbj4nLFxuICAgICAgICAgICAgICAgIFwiPCUgfSk7ICU+XCIsXG4gICAgICAgICAgICAgICAgXCI8L3NlbGVjdD5cIixcbiAgICAgICAgICAgICAgICBcIjwvZGl2PlwiLFxuICAgICAgICAgICAgICAgIFwiPGJyLz5cIixcbiAgICAgICAgICAgICAgICAnPGRpdiBpZD1cInNlbGVjdGVkX2hpc3RvcnlfY29udGVudFwiPicsXG4gICAgICAgICAgICAgICAgXCI8L2Rpdj5cIixcbiAgICAgICAgICAgICAgICBcIjwvZGl2PlwiXG4gICAgICAgICAgICBdLmpvaW4oXCJcIilcbiAgICAgICAgKTtcbiAgICB9LFxuXG4gICAgdGVtcGxhdGVIaXN0b3J5Q29udGVudHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gXy50ZW1wbGF0ZShcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIjxwPjIuJm5ic3A7Q2hvb3NlIHRoZSBkYXRhc2V0cyB0byBpbXBvcnQ6PC9wPlwiLFxuICAgICAgICAgICAgICAgIFwiPGRpdj5cIixcbiAgICAgICAgICAgICAgICAnPGJ1dHRvbiB0aXRsZT1cIlNlbGVjdCBhbGwgZGF0YXNldHNcIiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJidXR0b24gcHJpbWFyeS1idXR0b24gaGlzdG9yeS1pbXBvcnQtc2VsZWN0LWFsbFwiPicsXG4gICAgICAgICAgICAgICAgXCJTZWxlY3QgYWxsXCIsXG4gICAgICAgICAgICAgICAgXCI8L2J1dHRvbj5cIixcbiAgICAgICAgICAgICAgICAnPGJ1dHRvbiB0aXRsZT1cIlNlbGVjdCBhbGwgZGF0YXNldHNcIiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJidXR0b24gcHJpbWFyeS1idXR0b24gaGlzdG9yeS1pbXBvcnQtdW5zZWxlY3QtYWxsXCI+JyxcbiAgICAgICAgICAgICAgICBcIlVuc2VsZWN0IGFsbFwiLFxuICAgICAgICAgICAgICAgIFwiPC9idXR0b24+XCIsXG4gICAgICAgICAgICAgICAgXCI8L2Rpdj5cIixcbiAgICAgICAgICAgICAgICBcIjxicj5cIixcbiAgICAgICAgICAgICAgICBcIjx1bD5cIixcbiAgICAgICAgICAgICAgICBcIjwlIF8uZWFjaChoaXN0b3J5X2NvbnRlbnRzLCBmdW5jdGlvbihoaXN0b3J5X2l0ZW0pIHsgJT5cIixcbiAgICAgICAgICAgICAgICAnPCUgaWYgKGhpc3RvcnlfaXRlbS5nZXQoXCJkZWxldGVkXCIpICE9IHRydWUgKSB7ICU+JyxcbiAgICAgICAgICAgICAgICAnPCUgdmFyIGl0ZW1fbmFtZSA9IGhpc3RvcnlfaXRlbS5nZXQoXCJuYW1lXCIpICU+JyxcbiAgICAgICAgICAgICAgICAnPCUgaWYgKGhpc3RvcnlfaXRlbS5nZXQoXCJ0eXBlXCIpID09PSBcImNvbGxlY3Rpb25cIikgeyAlPicsXG4gICAgICAgICAgICAgICAgJzwlIHZhciBjb2xsZWN0aW9uX3R5cGUgPSBoaXN0b3J5X2l0ZW0uZ2V0KFwiY29sbGVjdGlvbl90eXBlXCIpICU+JyxcbiAgICAgICAgICAgICAgICAnPCUgaWYgKGNvbGxlY3Rpb25fdHlwZSA9PT0gXCJsaXN0XCIpIHsgJT4nLFxuICAgICAgICAgICAgICAgICc8bGkgZGF0YS1pZD1cIjwlPSBfLmVzY2FwZShoaXN0b3J5X2l0ZW0uZ2V0KFwiaWRcIikpICU+XCIgZGF0YS1uYW1lPVwiPCU9IF8uZXNjYXBlKGhpc3RvcnlfaXRlbS5nZXQoXCJ0eXBlXCIpKSAlPlwiPicsXG4gICAgICAgICAgICAgICAgXCI8bGFiZWw+XCIsXG4gICAgICAgICAgICAgICAgJzxsYWJlbCB0aXRsZT1cIjwlPSBfLmVzY2FwZShpdGVtX25hbWUpICU+XCI+JyxcbiAgICAgICAgICAgICAgICAnPGlucHV0IHN0eWxlPVwibWFyZ2luOiAwO1wiIHR5cGU9XCJjaGVja2JveFwiPiA8JT0gXy5lc2NhcGUoaGlzdG9yeV9pdGVtLmdldChcImhpZFwiKSkgJT46ICcsXG4gICAgICAgICAgICAgICAgJzwlPSBpdGVtX25hbWUubGVuZ3RoID4gNzUgPyBfLmVzY2FwZShcIi4uLlwiLmNvbmNhdChpdGVtX25hbWUuc3Vic3RyKC03NSkpKSA6IF8uZXNjYXBlKGl0ZW1fbmFtZSkgJT4gKERhdGFzZXQgQ29sbGVjdGlvbiknLFxuICAgICAgICAgICAgICAgIFwiPC9sYWJlbD5cIixcbiAgICAgICAgICAgICAgICBcIjwvbGk+XCIsXG4gICAgICAgICAgICAgICAgXCI8JSB9IGVsc2UgeyAlPlwiLFxuICAgICAgICAgICAgICAgICc8bGk+PGlucHV0IHN0eWxlPVwibWFyZ2luOiAwO1wiIHR5cGU9XCJjaGVja2JveFwiIG9uY2xpY2s9XCJyZXR1cm4gZmFsc2U7XCIgZGlzYWJsZWQ9XCJkaXNhYmxlZFwiPicsXG4gICAgICAgICAgICAgICAgJzxzcGFuIHRpdGxlPVwiWW91IGNhbiBjb252ZXJ0IHRoaXMgY29sbGVjdGlvbiBpbnRvIGEgY29sbGVjdGlvbiBvZiB0eXBlIGxpc3QgdXNpbmcgdGhlIENvbGxlY3Rpb24gVG9vbHNcIj4nLFxuICAgICAgICAgICAgICAgICc8JT0gXy5lc2NhcGUoaGlzdG9yeV9pdGVtLmdldChcImhpZFwiKSkgJT46ICcsXG4gICAgICAgICAgICAgICAgJzwlPSBpdGVtX25hbWUubGVuZ3RoID4gNzUgPyBfLmVzY2FwZShcIi4uLlwiLmNvbmNhdChpdGVtX25hbWUuc3Vic3RyKC03NSkpKSA6IF8uZXNjYXBlKGl0ZW1fbmFtZSkgJT4gKERhdGFzZXQgQ29sbGVjdGlvbiBvZiB0eXBlIDwlPSBfLmVzY2FwZShjb2xsZWN0aW9uX3R5cGUpICU+IG5vdCBzdXBwb3J0ZWQuKScsXG4gICAgICAgICAgICAgICAgXCI8L3NwYW4+XCIsXG4gICAgICAgICAgICAgICAgXCI8L2xpPlwiLFxuICAgICAgICAgICAgICAgIFwiPCUgfSAlPlwiLFxuICAgICAgICAgICAgICAgICc8JSB9IGVsc2UgaWYgKGhpc3RvcnlfaXRlbS5nZXQoXCJ2aXNpYmxlXCIpID09PSB0cnVlICYmIGhpc3RvcnlfaXRlbS5nZXQoXCJzdGF0ZVwiKSA9PT0gXCJva1wiKSB7ICU+JyxcbiAgICAgICAgICAgICAgICAnPGxpIGRhdGEtaWQ9XCI8JT0gXy5lc2NhcGUoaGlzdG9yeV9pdGVtLmdldChcImlkXCIpKSAlPlwiIGRhdGEtbmFtZT1cIjwlPSBfLmVzY2FwZShoaXN0b3J5X2l0ZW0uZ2V0KFwidHlwZVwiKSkgJT5cIj4nLFxuICAgICAgICAgICAgICAgICc8bGFiZWwgdGl0bGU9XCI8JT0gXy5lc2NhcGUoaXRlbV9uYW1lKSAlPlwiPicsXG4gICAgICAgICAgICAgICAgJzxpbnB1dCBzdHlsZT1cIm1hcmdpbjogMDtcIiB0eXBlPVwiY2hlY2tib3hcIj4gPCU9IF8uZXNjYXBlKGhpc3RvcnlfaXRlbS5nZXQoXCJoaWRcIikpICU+OiAnLFxuICAgICAgICAgICAgICAgICc8JT0gaXRlbV9uYW1lLmxlbmd0aCA+IDc1ID8gXy5lc2NhcGUoXCIuLi5cIi5jb25jYXQoaXRlbV9uYW1lLnN1YnN0cigtNzUpKSkgOiBfLmVzY2FwZShpdGVtX25hbWUpICU+JyxcbiAgICAgICAgICAgICAgICBcIjwvbGFiZWw+XCIsXG4gICAgICAgICAgICAgICAgXCI8L2xpPlwiLFxuICAgICAgICAgICAgICAgIFwiPCUgfSAlPlwiLFxuICAgICAgICAgICAgICAgIFwiPCUgfSAlPlwiLFxuICAgICAgICAgICAgICAgIFwiPCUgfSk7ICU+XCIsXG4gICAgICAgICAgICAgICAgXCI8L3VsPlwiXG4gICAgICAgICAgICBdLmpvaW4oXCJcIilcbiAgICAgICAgKTtcbiAgICB9LFxuXG4gICAgdGVtcGxhdGVQYWdpbmF0b3I6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gXy50ZW1wbGF0ZShcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnPHVsIGNsYXNzPVwicGFnaW5hdGlvbiBwYWdpbmF0aW9uLXNtXCI+JyxcbiAgICAgICAgICAgICAgICBcIjwlIGlmICggKCBzaG93X3BhZ2UgLSAxICkgPiAwICkgeyAlPlwiLFxuICAgICAgICAgICAgICAgIFwiPCUgaWYgKCAoIHNob3dfcGFnZSAtIDEgKSA+IHBhZ2VfY291bnQgKSB7ICU+XCIsIC8vIHdlIGFyZSBvbiBoaWdoZXIgcGFnZSB0aGFuIHRvdGFsIHBhZ2UgY291bnRcbiAgICAgICAgICAgICAgICAnPGxpPjxhIGhyZWY9XCIjZm9sZGVycy88JT0gaWQgJT4vcGFnZS8xXCI+PHNwYW4gY2xhc3M9XCJmYSBmYS1hbmdsZS1kb3VibGUtbGVmdFwiPjwvc3Bhbj48L2E+PC9saT4nLFxuICAgICAgICAgICAgICAgICc8bGkgY2xhc3M9XCJkaXNhYmxlZFwiPjxhIGhyZWY9XCIjZm9sZGVycy88JT0gaWQgJT4vcGFnZS88JSBwcmludCggc2hvd19wYWdlICkgJT5cIj48JSBwcmludCggc2hvd19wYWdlIC0gMSApICU+PC9hPjwvbGk+JyxcbiAgICAgICAgICAgICAgICBcIjwlIH0gZWxzZSB7ICU+XCIsXG4gICAgICAgICAgICAgICAgJzxsaT48YSBocmVmPVwiI2ZvbGRlcnMvPCU9IGlkICU+L3BhZ2UvMVwiPjxzcGFuIGNsYXNzPVwiZmEgZmEtYW5nbGUtZG91YmxlLWxlZnRcIj48L3NwYW4+PC9hPjwvbGk+JyxcbiAgICAgICAgICAgICAgICAnPGxpPjxhIGhyZWY9XCIjZm9sZGVycy88JT0gaWQgJT4vcGFnZS88JSBwcmludCggc2hvd19wYWdlIC0gMSApICU+XCI+PCUgcHJpbnQoIHNob3dfcGFnZSAtIDEgKSAlPjwvYT48L2xpPicsXG4gICAgICAgICAgICAgICAgXCI8JSB9ICU+XCIsXG4gICAgICAgICAgICAgICAgXCI8JSB9IGVsc2UgeyAlPlwiLCAvLyB3ZSBhcmUgb24gdGhlIGZpcnN0IHBhZ2VcbiAgICAgICAgICAgICAgICAnPGxpIGNsYXNzPVwiZGlzYWJsZWRcIj48YSBocmVmPVwiI2ZvbGRlcnMvPCU9IGlkICU+L3BhZ2UvMVwiPjxzcGFuIGNsYXNzPVwiZmEgZmEtYW5nbGUtZG91YmxlLWxlZnRcIj48L3NwYW4+PC9hPjwvbGk+JyxcbiAgICAgICAgICAgICAgICAnPGxpIGNsYXNzPVwiZGlzYWJsZWRcIj48YSBocmVmPVwiI2ZvbGRlcnMvPCU9IGlkICU+L3BhZ2UvPCUgcHJpbnQoIHNob3dfcGFnZSApICU+XCI+PCUgcHJpbnQoIHNob3dfcGFnZSAtIDEgKSAlPjwvYT48L2xpPicsXG4gICAgICAgICAgICAgICAgXCI8JSB9ICU+XCIsXG4gICAgICAgICAgICAgICAgJzxsaSBjbGFzcz1cImFjdGl2ZVwiPicsXG4gICAgICAgICAgICAgICAgJzxhIGhyZWY9XCIjZm9sZGVycy88JT0gaWQgJT4vcGFnZS88JSBwcmludCggc2hvd19wYWdlICkgJT5cIj48JSBwcmludCggc2hvd19wYWdlICkgJT48L2E+JyxcbiAgICAgICAgICAgICAgICBcIjwvbGk+XCIsXG4gICAgICAgICAgICAgICAgXCI8JSBpZiAoICggc2hvd19wYWdlICkgPCBwYWdlX2NvdW50ICkgeyAlPlwiLFxuICAgICAgICAgICAgICAgICc8bGk+PGEgaHJlZj1cIiNmb2xkZXJzLzwlPSBpZCAlPi9wYWdlLzwlIHByaW50KCBzaG93X3BhZ2UgKyAxICkgJT5cIj48JSBwcmludCggc2hvd19wYWdlICsgMSApICU+PC9hPjwvbGk+JyxcbiAgICAgICAgICAgICAgICAnPGxpPjxhIGhyZWY9XCIjZm9sZGVycy88JT0gaWQgJT4vcGFnZS88JSBwcmludCggcGFnZV9jb3VudCApICU+XCI+PHNwYW4gY2xhc3M9XCJmYSBmYS1hbmdsZS1kb3VibGUtcmlnaHRcIj48L3NwYW4+PC9hPjwvbGk+JyxcbiAgICAgICAgICAgICAgICBcIjwlIH0gZWxzZSB7ICU+XCIsXG4gICAgICAgICAgICAgICAgJzxsaSBjbGFzcz1cImRpc2FibGVkXCI+PGEgaHJlZj1cIiNmb2xkZXJzLzwlPSBpZCAlPi9wYWdlLzwlIHByaW50KCBzaG93X3BhZ2UgICkgJT5cIj48JSBwcmludCggc2hvd19wYWdlICsgMSApICU+PC9hPjwvbGk+JyxcbiAgICAgICAgICAgICAgICAnPGxpIGNsYXNzPVwiZGlzYWJsZWRcIj48YSBocmVmPVwiI2ZvbGRlcnMvPCU9IGlkICU+L3BhZ2UvPCUgcHJpbnQoIHBhZ2VfY291bnQgKSAlPlwiPjxzcGFuIGNsYXNzPVwiZmEgZmEtYW5nbGUtZG91YmxlLXJpZ2h0XCI+PC9zcGFuPjwvYT48L2xpPicsXG4gICAgICAgICAgICAgICAgXCI8JSB9ICU+XCIsXG4gICAgICAgICAgICAgICAgXCI8L3VsPlwiLFxuICAgICAgICAgICAgICAgIFwiPHNwYW4+XCIsXG4gICAgICAgICAgICAgICAgJyA8JS0gaXRlbXNfc2hvd24gJT4gaXRlbXMgc2hvd24gPGEgaHJlZj1cIlwiIGRhdGEtdG9nZ2xlPVwidG9vbHRpcFwiIGRhdGEtcGxhY2VtZW50PVwidG9wXCIgdGl0bGU9XCJjdXJyZW50bHkgPCUtIGZvbGRlcl9wYWdlX3NpemUgJT4gcGVyIHBhZ2VcIiBjbGFzcz1cInBhZ2Vfc2l6ZV9wcm9tcHRcIj4oY2hhbmdlKTwvYT4nLFxuICAgICAgICAgICAgICAgIFwiPC9zcGFuPlwiLFxuICAgICAgICAgICAgICAgIFwiPHNwYW4+XCIsXG4gICAgICAgICAgICAgICAgXCIgPCUtIHRvdGFsX2l0ZW1zX2NvdW50ICU+IHRvdGFsXCIsXG4gICAgICAgICAgICAgICAgXCI8L3NwYW4+XCJcbiAgICAgICAgICAgIF0uam9pbihcIlwiKVxuICAgICAgICApO1xuICAgIH1cbn0pO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gICAgRm9sZGVyVG9vbGJhclZpZXc6IEZvbGRlclRvb2xiYXJWaWV3XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGdhbGF4eS9zY3JpcHRzL212Yy9saWJyYXJ5L2xpYnJhcnktZm9sZGVydG9vbGJhci12aWV3LmpzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBOzs7QUFBQTtBQUNBOzs7QUFBQTtBQUNBOzs7QUFBQTtBQUNBOzs7QUFBQTtBQUNBOzs7QUFBQTtBQUNBOzs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBUEE7QUFDQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFDQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBSkE7QUFhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWRBO0FBZ0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFOQTtBQWVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFJQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVFBO0FBQ0E7QUFDQTtBQWhCQTtBQWtCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFqQkE7QUFtQkE7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBZkE7QUFpQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBWkE7QUFjQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFqQkE7QUFDQTtBQW1CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQUpBO0FBUUE7QUFDQTtBQURBO0FBYkE7QUFpQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBL0JBO0FBaUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVEE7QUFXQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQURBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBbkJBO0FBQ0E7QUFxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQVFBO0FBQ0E7QUFHQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVEE7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUkE7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFEQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUF0QkE7QUF3QkE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUhBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFGQTtBQUNBO0FBS0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFXQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFXQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFEQTtBQUNBO0FBSUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBSkE7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFWQTtBQVlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBSkE7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFwQkE7QUFzQkE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBa0VBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBOERBO0FBQ0E7QUFDQTtBQUNBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFtQkE7QUFDQTtBQUNBO0FBQ0E7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQVlBO0FBQ0E7QUFDQTtBQUNBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFzQ0E7QUFDQTtBQWtCQTtBQUNBO0FBQ0E7QUFDQTtBQXVDQTtBQUNBO0FBQ0E7QUFDQTtBQU9BO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUErQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQU9BO0FBc0JBO0FBeG9EQTtBQUNBO0FBMG9EQTtBQUNBO0FBREE7QSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///303\n");

/***/ }),

/***/ 304:
/*!************************************************************!*\
  !*** ./galaxy/scripts/mvc/library/library-library-view.js ***!
  \************************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(Backbone, _, $) {\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _toastr = __webpack_require__(/*! libs/toastr */ 7);\n\nvar _toastr2 = _interopRequireDefault(_toastr);\n\nvar _libraryModel = __webpack_require__(/*! mvc/library/library-model */ 13);\n\nvar _libraryModel2 = _interopRequireDefault(_libraryModel);\n\nvar _uiSelect = __webpack_require__(/*! mvc/ui/ui-select */ 10);\n\nvar _uiSelect2 = _interopRequireDefault(_uiSelect);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar LibraryView = Backbone.View.extend({\n    el: \"#center\",\n\n    model: null,\n\n    options: {},\n\n    events: {\n        \"click .toolbtn_save_permissions\": \"savePermissions\"\n    },\n\n    initialize: function initialize(options) {\n        this.options = _.extend(this.options, options);\n        if (this.options.id) {\n            this.fetchLibrary();\n        }\n    },\n\n    fetchLibrary: function fetchLibrary(options) {\n        this.options = _.extend(this.options, options);\n        this.model = new _libraryModel2.default.Library({\n            id: this.options.id\n        });\n        var that = this;\n        this.model.fetch({\n            success: function success() {\n                if (that.options.show_permissions) {\n                    that.showPermissions();\n                }\n            },\n            error: function error(model, response) {\n                if (typeof response.responseJSON !== \"undefined\") {\n                    _toastr2.default.error(response.responseJSON.err_msg + \" Click this to go back.\", \"\", {\n                        onclick: function onclick() {\n                            Galaxy.libraries.library_router.back();\n                        }\n                    });\n                } else {\n                    _toastr2.default.error(\"An error occurred. Click this to go back.\", \"\", {\n                        onclick: function onclick() {\n                            Galaxy.libraries.library_router.back();\n                        }\n                    });\n                }\n            }\n        });\n    },\n\n    showPermissions: function showPermissions(options) {\n        this.options = _.extend(this.options, options);\n        $(\".tooltip\").remove();\n\n        if (this.options.fetched_permissions !== undefined) {\n            if (this.options.fetched_permissions.access_library_role_list.length === 0) {\n                this.model.set({ is_unrestricted: true });\n            } else {\n                this.model.set({ is_unrestricted: false });\n            }\n        }\n        var is_admin = false;\n        if (Galaxy.user) {\n            is_admin = Galaxy.user.isAdmin();\n        }\n        var template = this.templateLibraryPermissions();\n        this.$el.html(template({ library: this.model, is_admin: is_admin }));\n\n        var self = this;\n        $.get(Galaxy.root + \"api/libraries/\" + self.id + \"/permissions?scope=current\").done(function (fetched_permissions) {\n            self.prepareSelectBoxes({\n                fetched_permissions: fetched_permissions\n            });\n        }).fail(function () {\n            _toastr2.default.error(\"An error occurred while attempting to fetch library permissions.\");\n        });\n\n        $(\"#center [data-toggle]\").tooltip();\n        //hack to show scrollbars\n        $(\"#center\").css(\"overflow\", \"auto\");\n    },\n\n    _serializeRoles: function _serializeRoles(role_list) {\n        var selected_roles = [];\n        for (var i = 0; i < role_list.length; i++) {\n            selected_roles.push(role_list[i][1] + \":\" + role_list[i][0]);\n        }\n        return selected_roles;\n    },\n\n    prepareSelectBoxes: function prepareSelectBoxes(options) {\n        this.options = _.extend(this.options, options);\n        var fetched_permissions = this.options.fetched_permissions;\n        var self = this;\n\n        var selected_access_library_roles = this._serializeRoles(fetched_permissions.access_library_role_list);\n        var selected_add_item_roles = this._serializeRoles(fetched_permissions.add_library_item_role_list);\n        var selected_manage_library_roles = this._serializeRoles(fetched_permissions.manage_library_role_list);\n        var selected_modify_library_roles = this._serializeRoles(fetched_permissions.modify_library_role_list);\n\n        self.accessSelectObject = new _uiSelect2.default.View(this._createSelectOptions(this, \"access_perm\", selected_access_library_roles, true));\n        self.addSelectObject = new _uiSelect2.default.View(this._createSelectOptions(this, \"add_perm\", selected_add_item_roles, false));\n        self.manageSelectObject = new _uiSelect2.default.View(this._createSelectOptions(this, \"manage_perm\", selected_manage_library_roles, false));\n        self.modifySelectObject = new _uiSelect2.default.View(this._createSelectOptions(this, \"modify_perm\", selected_modify_library_roles, false));\n    },\n\n    _createSelectOptions: function _createSelectOptions(self, id, init_data, is_library_access) {\n        is_library_access = is_library_access === true ? is_library_access : false;\n        var select_options = {\n            minimumInputLength: 0,\n            css: id,\n            multiple: true,\n            placeholder: \"Click to select a role\",\n            container: self.$el.find(\"#\" + id),\n            ajax: {\n                url: Galaxy.root + \"api/libraries/\" + self.id + \"/permissions?scope=available&is_library_access=\" + is_library_access,\n                dataType: \"json\",\n                quietMillis: 100,\n                data: function data(term, page) {\n                    // page is the one-based page number tracked by Select2\n                    return {\n                        q: term, //search term\n                        page_limit: 10, // page size\n                        page: page // page number\n                    };\n                },\n                results: function results(data, page) {\n                    var more = page * 10 < data.total; // whether or not there are more results available\n                    // notice we return the value of more so Select2 knows if more results can be loaded\n                    return { results: data.roles, more: more };\n                }\n            },\n            formatResult: function roleFormatResult(role) {\n                return role.name + \" type: \" + role.type;\n            },\n\n            formatSelection: function roleFormatSelection(role) {\n                return role.name;\n            },\n            initSelection: function initSelection(element, callback) {\n                // the input tag has a value attribute preloaded that points to a preselected role's id\n                // this function resolves that id attribute to an object that select2 can render\n                // using its formatResult renderer - that way the role name is shown preselected\n                var data = [];\n                $(element.val().split(\",\")).each(function () {\n                    var item = this.split(\":\");\n                    data.push({\n                        id: item[0],\n                        name: item[1]\n                    });\n                });\n                callback(data);\n            },\n            // initialData: init_data.join(','),\n            initialData: init_data,\n            dropdownCssClass: \"bigdrop\" // apply css that makes the dropdown taller\n        };\n\n        return select_options;\n    },\n\n    makeDatasetPrivate: function makeDatasetPrivate() {\n        var self = this;\n        $.post(Galaxy.root + \"api/libraries/datasets/\" + self.id + \"/permissions?action=make_private\").done(function (fetched_permissions) {\n            self.model.set({ is_unrestricted: false });\n            self.showPermissions({\n                fetched_permissions: fetched_permissions\n            });\n            _toastr2.default.success(\"The dataset is now private to you.\");\n        }).fail(function () {\n            _toastr2.default.error(\"An error occurred while attempting to make dataset private.\");\n        });\n    },\n\n    removeDatasetRestrictions: function removeDatasetRestrictions() {\n        var self = this;\n        $.post(Galaxy.root + \"api/libraries/datasets/\" + self.id + \"/permissions?action=remove_restrictions\").done(function (fetched_permissions) {\n            self.model.set({ is_unrestricted: true });\n            self.showPermissions({\n                fetched_permissions: fetched_permissions\n            });\n            _toastr2.default.success(\"Access to this dataset is now unrestricted.\");\n        }).fail(function () {\n            _toastr2.default.error(\"An error occurred while attempting to make dataset unrestricted.\");\n        });\n    },\n\n    _extractIds: function _extractIds(roles_list) {\n        var ids_list = [];\n        for (var i = roles_list.length - 1; i >= 0; i--) {\n            ids_list.push(roles_list[i].id);\n        }\n        return ids_list;\n    },\n    savePermissions: function savePermissions(event) {\n        var self = this;\n\n        var access_ids = this._extractIds(this.accessSelectObject.$el.select2(\"data\"));\n        var add_ids = this._extractIds(this.addSelectObject.$el.select2(\"data\"));\n        var manage_ids = this._extractIds(this.manageSelectObject.$el.select2(\"data\"));\n        var modify_ids = this._extractIds(this.modifySelectObject.$el.select2(\"data\"));\n\n        $.post(Galaxy.root + \"api/libraries/\" + self.id + \"/permissions?action=set_permissions\", {\n            \"access_ids[]\": access_ids,\n            \"add_ids[]\": add_ids,\n            \"manage_ids[]\": manage_ids,\n            \"modify_ids[]\": modify_ids\n        }).done(function (fetched_permissions) {\n            //fetch dataset again\n            self.showPermissions({\n                fetched_permissions: fetched_permissions\n            });\n            _toastr2.default.success(\"Permissions saved.\");\n        }).fail(function () {\n            _toastr2.default.error(\"An error occurred while attempting to set library permissions.\");\n        });\n    },\n\n    templateLibraryPermissions: function templateLibraryPermissions() {\n        return _.template(['<div class=\"library_style_container\">', '<div id=\"library_toolbar\">', '<a href=\"#\">', '<button data-toggle=\"tooltip\" data-placement=\"top\" title=\"Go back to the list of Libraries\" class=\"btn btn-default primary-button\" type=\"button\">', '<span class=\"fa fa-list\"/>', \"&nbsp;Libraries\", \"</button>\", \"</a>\", \"</div>\", \"<h1>\", 'Library: <%= _.escape(library.get(\"name\")) %>', \"</h1>\", '<div class=\"alert alert-warning\">', \"<% if (is_admin) { %>\", \"You are logged in as an <strong>administrator</strong> therefore you can manage any library on this Galaxy instance. Please make sure you understand the consequences.\", \"<% } else { %>\", \"You can assign any number of roles to any of the following permission types. However please read carefully the implications of such actions.\", \"<% }%>\", \"</div>\", '<div class=\"dataset_table\">', \"<h2>Library permissions</h2>\", \"<h4>Roles that can access the library</h4>\", '<div id=\"access_perm\" class=\"access_perm roles-selection\"/>', '<div class=\"alert alert-info roles-selection\">', \"User with <strong>any</strong> of these roles can access this library. If there are no access roles set on the library it is considered <strong>unrestricted</strong>.\", \"</div>\", \"<h4>Roles that can manage permissions on this library</h4>\", '<div id=\"manage_perm\" class=\"manage_perm roles-selection\"/>', '<div class=\"alert alert-info roles-selection\">', \"User with <strong>any</strong> of these roles can manage permissions on this library (includes giving access).\", \"</div>\", \"<h4>Roles that can add items to this library</h4>\", '<div id=\"add_perm\" class=\"add_perm roles-selection\"/>', '<div class=\"alert alert-info roles-selection\">', \"User with <strong>any</strong> of these roles can add items to this library (folders and datasets).\", \"</div>\", \"<h4>Roles that can modify this library</h4>\", '<div id=\"modify_perm\" class=\"modify_perm roles-selection\"/>', '<div class=\"alert alert-info roles-selection\">', \"User with <strong>any</strong> of these roles can modify this library (name, synopsis, etc.).\", \"</div>\", '<button data-toggle=\"tooltip\" data-placement=\"top\" title=\"Save modifications made on this page\" class=\"btn btn-default toolbtn_save_permissions primary-button\" type=\"button\">', '<span class=\"fa fa-floppy-o\"/>', \"&nbsp;Save\", \"</button>\", \"</div>\", \"</div>\"].join(\"\"));\n    }\n});\n\nexports.default = {\n    LibraryView: LibraryView\n};\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! libs/backbone */ 2), __webpack_require__(/*! underscore */ 1), __webpack_require__(/*! jquery */ 0)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzA0LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL2dhbGF4eS9zY3JpcHRzL212Yy9saWJyYXJ5L2xpYnJhcnktbGlicmFyeS12aWV3LmpzPzM4NWYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IG1vZF90b2FzdHIgZnJvbSBcImxpYnMvdG9hc3RyXCI7XG5pbXBvcnQgbW9kX2xpYnJhcnlfbW9kZWwgZnJvbSBcIm12Yy9saWJyYXJ5L2xpYnJhcnktbW9kZWxcIjtcbmltcG9ydCBtb2Rfc2VsZWN0IGZyb20gXCJtdmMvdWkvdWktc2VsZWN0XCI7XG52YXIgTGlicmFyeVZpZXcgPSBCYWNrYm9uZS5WaWV3LmV4dGVuZCh7XG4gICAgZWw6IFwiI2NlbnRlclwiLFxuXG4gICAgbW9kZWw6IG51bGwsXG5cbiAgICBvcHRpb25zOiB7fSxcblxuICAgIGV2ZW50czoge1xuICAgICAgICBcImNsaWNrIC50b29sYnRuX3NhdmVfcGVybWlzc2lvbnNcIjogXCJzYXZlUGVybWlzc2lvbnNcIlxuICAgIH0sXG5cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IF8uZXh0ZW5kKHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaWQpIHtcbiAgICAgICAgICAgIHRoaXMuZmV0Y2hMaWJyYXJ5KCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZmV0Y2hMaWJyYXJ5OiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IF8uZXh0ZW5kKHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMubW9kZWwgPSBuZXcgbW9kX2xpYnJhcnlfbW9kZWwuTGlicmFyeSh7XG4gICAgICAgICAgICBpZDogdGhpcy5vcHRpb25zLmlkXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgIHRoaXMubW9kZWwuZmV0Y2goe1xuICAgICAgICAgICAgc3VjY2VzczogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoYXQub3B0aW9ucy5zaG93X3Blcm1pc3Npb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoYXQuc2hvd1Blcm1pc3Npb25zKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVycm9yOiBmdW5jdGlvbihtb2RlbCwgcmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJlc3BvbnNlLnJlc3BvbnNlSlNPTiAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgICAgICBtb2RfdG9hc3RyLmVycm9yKGAke3Jlc3BvbnNlLnJlc3BvbnNlSlNPTi5lcnJfbXNnfSBDbGljayB0aGlzIHRvIGdvIGJhY2suYCwgXCJcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgb25jbGljazogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgR2FsYXh5LmxpYnJhcmllcy5saWJyYXJ5X3JvdXRlci5iYWNrKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG1vZF90b2FzdHIuZXJyb3IoXCJBbiBlcnJvciBvY2N1cnJlZC4gQ2xpY2sgdGhpcyB0byBnbyBiYWNrLlwiLCBcIlwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbmNsaWNrOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBHYWxheHkubGlicmFyaWVzLmxpYnJhcnlfcm91dGVyLmJhY2soKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgc2hvd1Blcm1pc3Npb25zOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IF8uZXh0ZW5kKHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG4gICAgICAgICQoXCIudG9vbHRpcFwiKS5yZW1vdmUoKTtcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmZldGNoZWRfcGVybWlzc2lvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5mZXRjaGVkX3Blcm1pc3Npb25zLmFjY2Vzc19saWJyYXJ5X3JvbGVfbGlzdC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGVsLnNldCh7IGlzX3VucmVzdHJpY3RlZDogdHJ1ZSB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tb2RlbC5zZXQoeyBpc191bnJlc3RyaWN0ZWQ6IGZhbHNlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBpc19hZG1pbiA9IGZhbHNlO1xuICAgICAgICBpZiAoR2FsYXh5LnVzZXIpIHtcbiAgICAgICAgICAgIGlzX2FkbWluID0gR2FsYXh5LnVzZXIuaXNBZG1pbigpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0ZW1wbGF0ZSA9IHRoaXMudGVtcGxhdGVMaWJyYXJ5UGVybWlzc2lvbnMoKTtcbiAgICAgICAgdGhpcy4kZWwuaHRtbCh0ZW1wbGF0ZSh7IGxpYnJhcnk6IHRoaXMubW9kZWwsIGlzX2FkbWluOiBpc19hZG1pbiB9KSk7XG5cbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAkLmdldChgJHtHYWxheHkucm9vdH1hcGkvbGlicmFyaWVzLyR7c2VsZi5pZH0vcGVybWlzc2lvbnM/c2NvcGU9Y3VycmVudGApXG4gICAgICAgICAgICAuZG9uZShmZXRjaGVkX3Blcm1pc3Npb25zID0+IHtcbiAgICAgICAgICAgICAgICBzZWxmLnByZXBhcmVTZWxlY3RCb3hlcyh7XG4gICAgICAgICAgICAgICAgICAgIGZldGNoZWRfcGVybWlzc2lvbnM6IGZldGNoZWRfcGVybWlzc2lvbnNcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuZmFpbCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgbW9kX3RvYXN0ci5lcnJvcihcIkFuIGVycm9yIG9jY3VycmVkIHdoaWxlIGF0dGVtcHRpbmcgdG8gZmV0Y2ggbGlicmFyeSBwZXJtaXNzaW9ucy5cIik7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAkKFwiI2NlbnRlciBbZGF0YS10b2dnbGVdXCIpLnRvb2x0aXAoKTtcbiAgICAgICAgLy9oYWNrIHRvIHNob3cgc2Nyb2xsYmFyc1xuICAgICAgICAkKFwiI2NlbnRlclwiKS5jc3MoXCJvdmVyZmxvd1wiLCBcImF1dG9cIik7XG4gICAgfSxcblxuICAgIF9zZXJpYWxpemVSb2xlczogZnVuY3Rpb24ocm9sZV9saXN0KSB7XG4gICAgICAgIHZhciBzZWxlY3RlZF9yb2xlcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJvbGVfbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgc2VsZWN0ZWRfcm9sZXMucHVzaChgJHtyb2xlX2xpc3RbaV1bMV19OiR7cm9sZV9saXN0W2ldWzBdfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWxlY3RlZF9yb2xlcztcbiAgICB9LFxuXG4gICAgcHJlcGFyZVNlbGVjdEJveGVzOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IF8uZXh0ZW5kKHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG4gICAgICAgIHZhciBmZXRjaGVkX3Blcm1pc3Npb25zID0gdGhpcy5vcHRpb25zLmZldGNoZWRfcGVybWlzc2lvbnM7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICB2YXIgc2VsZWN0ZWRfYWNjZXNzX2xpYnJhcnlfcm9sZXMgPSB0aGlzLl9zZXJpYWxpemVSb2xlcyhmZXRjaGVkX3Blcm1pc3Npb25zLmFjY2Vzc19saWJyYXJ5X3JvbGVfbGlzdCk7XG4gICAgICAgIHZhciBzZWxlY3RlZF9hZGRfaXRlbV9yb2xlcyA9IHRoaXMuX3NlcmlhbGl6ZVJvbGVzKGZldGNoZWRfcGVybWlzc2lvbnMuYWRkX2xpYnJhcnlfaXRlbV9yb2xlX2xpc3QpO1xuICAgICAgICB2YXIgc2VsZWN0ZWRfbWFuYWdlX2xpYnJhcnlfcm9sZXMgPSB0aGlzLl9zZXJpYWxpemVSb2xlcyhmZXRjaGVkX3Blcm1pc3Npb25zLm1hbmFnZV9saWJyYXJ5X3JvbGVfbGlzdCk7XG4gICAgICAgIHZhciBzZWxlY3RlZF9tb2RpZnlfbGlicmFyeV9yb2xlcyA9IHRoaXMuX3NlcmlhbGl6ZVJvbGVzKGZldGNoZWRfcGVybWlzc2lvbnMubW9kaWZ5X2xpYnJhcnlfcm9sZV9saXN0KTtcblxuICAgICAgICBzZWxmLmFjY2Vzc1NlbGVjdE9iamVjdCA9IG5ldyBtb2Rfc2VsZWN0LlZpZXcoXG4gICAgICAgICAgICB0aGlzLl9jcmVhdGVTZWxlY3RPcHRpb25zKHRoaXMsIFwiYWNjZXNzX3Blcm1cIiwgc2VsZWN0ZWRfYWNjZXNzX2xpYnJhcnlfcm9sZXMsIHRydWUpXG4gICAgICAgICk7XG4gICAgICAgIHNlbGYuYWRkU2VsZWN0T2JqZWN0ID0gbmV3IG1vZF9zZWxlY3QuVmlldyhcbiAgICAgICAgICAgIHRoaXMuX2NyZWF0ZVNlbGVjdE9wdGlvbnModGhpcywgXCJhZGRfcGVybVwiLCBzZWxlY3RlZF9hZGRfaXRlbV9yb2xlcywgZmFsc2UpXG4gICAgICAgICk7XG4gICAgICAgIHNlbGYubWFuYWdlU2VsZWN0T2JqZWN0ID0gbmV3IG1vZF9zZWxlY3QuVmlldyhcbiAgICAgICAgICAgIHRoaXMuX2NyZWF0ZVNlbGVjdE9wdGlvbnModGhpcywgXCJtYW5hZ2VfcGVybVwiLCBzZWxlY3RlZF9tYW5hZ2VfbGlicmFyeV9yb2xlcywgZmFsc2UpXG4gICAgICAgICk7XG4gICAgICAgIHNlbGYubW9kaWZ5U2VsZWN0T2JqZWN0ID0gbmV3IG1vZF9zZWxlY3QuVmlldyhcbiAgICAgICAgICAgIHRoaXMuX2NyZWF0ZVNlbGVjdE9wdGlvbnModGhpcywgXCJtb2RpZnlfcGVybVwiLCBzZWxlY3RlZF9tb2RpZnlfbGlicmFyeV9yb2xlcywgZmFsc2UpXG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIF9jcmVhdGVTZWxlY3RPcHRpb25zOiBmdW5jdGlvbihzZWxmLCBpZCwgaW5pdF9kYXRhLCBpc19saWJyYXJ5X2FjY2Vzcykge1xuICAgICAgICBpc19saWJyYXJ5X2FjY2VzcyA9IGlzX2xpYnJhcnlfYWNjZXNzID09PSB0cnVlID8gaXNfbGlicmFyeV9hY2Nlc3MgOiBmYWxzZTtcbiAgICAgICAgdmFyIHNlbGVjdF9vcHRpb25zID0ge1xuICAgICAgICAgICAgbWluaW11bUlucHV0TGVuZ3RoOiAwLFxuICAgICAgICAgICAgY3NzOiBpZCxcbiAgICAgICAgICAgIG11bHRpcGxlOiB0cnVlLFxuICAgICAgICAgICAgcGxhY2Vob2xkZXI6IFwiQ2xpY2sgdG8gc2VsZWN0IGEgcm9sZVwiLFxuICAgICAgICAgICAgY29udGFpbmVyOiBzZWxmLiRlbC5maW5kKGAjJHtpZH1gKSxcbiAgICAgICAgICAgIGFqYXg6IHtcbiAgICAgICAgICAgICAgICB1cmw6IGAke0dhbGF4eS5yb290fWFwaS9saWJyYXJpZXMvJHtzZWxmLmlkfS9wZXJtaXNzaW9ucz9zY29wZT1hdmFpbGFibGUmaXNfbGlicmFyeV9hY2Nlc3M9JHtcbiAgICAgICAgICAgICAgICAgICAgaXNfbGlicmFyeV9hY2Nlc3NcbiAgICAgICAgICAgICAgICB9YCxcbiAgICAgICAgICAgICAgICBkYXRhVHlwZTogXCJqc29uXCIsXG4gICAgICAgICAgICAgICAgcXVpZXRNaWxsaXM6IDEwMCxcbiAgICAgICAgICAgICAgICBkYXRhOiBmdW5jdGlvbih0ZXJtLCBwYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHBhZ2UgaXMgdGhlIG9uZS1iYXNlZCBwYWdlIG51bWJlciB0cmFja2VkIGJ5IFNlbGVjdDJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHE6IHRlcm0sIC8vc2VhcmNoIHRlcm1cbiAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2VfbGltaXQ6IDEwLCAvLyBwYWdlIHNpemVcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2U6IHBhZ2UgLy8gcGFnZSBudW1iZXJcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHJlc3VsdHM6IGZ1bmN0aW9uKGRhdGEsIHBhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1vcmUgPSBwYWdlICogMTAgPCBkYXRhLnRvdGFsOyAvLyB3aGV0aGVyIG9yIG5vdCB0aGVyZSBhcmUgbW9yZSByZXN1bHRzIGF2YWlsYWJsZVxuICAgICAgICAgICAgICAgICAgICAvLyBub3RpY2Ugd2UgcmV0dXJuIHRoZSB2YWx1ZSBvZiBtb3JlIHNvIFNlbGVjdDIga25vd3MgaWYgbW9yZSByZXN1bHRzIGNhbiBiZSBsb2FkZWRcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgcmVzdWx0czogZGF0YS5yb2xlcywgbW9yZTogbW9yZSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmb3JtYXRSZXN1bHQ6IGZ1bmN0aW9uIHJvbGVGb3JtYXRSZXN1bHQocm9sZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBgJHtyb2xlLm5hbWV9IHR5cGU6ICR7cm9sZS50eXBlfWA7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBmb3JtYXRTZWxlY3Rpb246IGZ1bmN0aW9uIHJvbGVGb3JtYXRTZWxlY3Rpb24ocm9sZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiByb2xlLm5hbWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaW5pdFNlbGVjdGlvbjogZnVuY3Rpb24oZWxlbWVudCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAvLyB0aGUgaW5wdXQgdGFnIGhhcyBhIHZhbHVlIGF0dHJpYnV0ZSBwcmVsb2FkZWQgdGhhdCBwb2ludHMgdG8gYSBwcmVzZWxlY3RlZCByb2xlJ3MgaWRcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGZ1bmN0aW9uIHJlc29sdmVzIHRoYXQgaWQgYXR0cmlidXRlIHRvIGFuIG9iamVjdCB0aGF0IHNlbGVjdDIgY2FuIHJlbmRlclxuICAgICAgICAgICAgICAgIC8vIHVzaW5nIGl0cyBmb3JtYXRSZXN1bHQgcmVuZGVyZXIgLSB0aGF0IHdheSB0aGUgcm9sZSBuYW1lIGlzIHNob3duIHByZXNlbGVjdGVkXG4gICAgICAgICAgICAgICAgdmFyIGRhdGEgPSBbXTtcbiAgICAgICAgICAgICAgICAkKGVsZW1lbnQudmFsKCkuc3BsaXQoXCIsXCIpKS5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IHRoaXMuc3BsaXQoXCI6XCIpO1xuICAgICAgICAgICAgICAgICAgICBkYXRhLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGl0ZW1bMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBpdGVtWzFdXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGRhdGEpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIGluaXRpYWxEYXRhOiBpbml0X2RhdGEuam9pbignLCcpLFxuICAgICAgICAgICAgaW5pdGlhbERhdGE6IGluaXRfZGF0YSxcbiAgICAgICAgICAgIGRyb3Bkb3duQ3NzQ2xhc3M6IFwiYmlnZHJvcFwiIC8vIGFwcGx5IGNzcyB0aGF0IG1ha2VzIHRoZSBkcm9wZG93biB0YWxsZXJcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gc2VsZWN0X29wdGlvbnM7XG4gICAgfSxcblxuICAgIG1ha2VEYXRhc2V0UHJpdmF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgJC5wb3N0KGAke0dhbGF4eS5yb290fWFwaS9saWJyYXJpZXMvZGF0YXNldHMvJHtzZWxmLmlkfS9wZXJtaXNzaW9ucz9hY3Rpb249bWFrZV9wcml2YXRlYClcbiAgICAgICAgICAgIC5kb25lKGZldGNoZWRfcGVybWlzc2lvbnMgPT4ge1xuICAgICAgICAgICAgICAgIHNlbGYubW9kZWwuc2V0KHsgaXNfdW5yZXN0cmljdGVkOiBmYWxzZSB9KTtcbiAgICAgICAgICAgICAgICBzZWxmLnNob3dQZXJtaXNzaW9ucyh7XG4gICAgICAgICAgICAgICAgICAgIGZldGNoZWRfcGVybWlzc2lvbnM6IGZldGNoZWRfcGVybWlzc2lvbnNcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBtb2RfdG9hc3RyLnN1Y2Nlc3MoXCJUaGUgZGF0YXNldCBpcyBub3cgcHJpdmF0ZSB0byB5b3UuXCIpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5mYWlsKCgpID0+IHtcbiAgICAgICAgICAgICAgICBtb2RfdG9hc3RyLmVycm9yKFwiQW4gZXJyb3Igb2NjdXJyZWQgd2hpbGUgYXR0ZW1wdGluZyB0byBtYWtlIGRhdGFzZXQgcHJpdmF0ZS5cIik7XG4gICAgICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgcmVtb3ZlRGF0YXNldFJlc3RyaWN0aW9uczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgJC5wb3N0KGAke0dhbGF4eS5yb290fWFwaS9saWJyYXJpZXMvZGF0YXNldHMvJHtzZWxmLmlkfS9wZXJtaXNzaW9ucz9hY3Rpb249cmVtb3ZlX3Jlc3RyaWN0aW9uc2ApXG4gICAgICAgICAgICAuZG9uZShmZXRjaGVkX3Blcm1pc3Npb25zID0+IHtcbiAgICAgICAgICAgICAgICBzZWxmLm1vZGVsLnNldCh7IGlzX3VucmVzdHJpY3RlZDogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICBzZWxmLnNob3dQZXJtaXNzaW9ucyh7XG4gICAgICAgICAgICAgICAgICAgIGZldGNoZWRfcGVybWlzc2lvbnM6IGZldGNoZWRfcGVybWlzc2lvbnNcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBtb2RfdG9hc3RyLnN1Y2Nlc3MoXCJBY2Nlc3MgdG8gdGhpcyBkYXRhc2V0IGlzIG5vdyB1bnJlc3RyaWN0ZWQuXCIpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5mYWlsKCgpID0+IHtcbiAgICAgICAgICAgICAgICBtb2RfdG9hc3RyLmVycm9yKFwiQW4gZXJyb3Igb2NjdXJyZWQgd2hpbGUgYXR0ZW1wdGluZyB0byBtYWtlIGRhdGFzZXQgdW5yZXN0cmljdGVkLlwiKTtcbiAgICAgICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBfZXh0cmFjdElkczogZnVuY3Rpb24ocm9sZXNfbGlzdCkge1xuICAgICAgICB2YXIgaWRzX2xpc3QgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IHJvbGVzX2xpc3QubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGlkc19saXN0LnB1c2gocm9sZXNfbGlzdFtpXS5pZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlkc19saXN0O1xuICAgIH0sXG4gICAgc2F2ZVBlcm1pc3Npb25zOiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgdmFyIGFjY2Vzc19pZHMgPSB0aGlzLl9leHRyYWN0SWRzKHRoaXMuYWNjZXNzU2VsZWN0T2JqZWN0LiRlbC5zZWxlY3QyKFwiZGF0YVwiKSk7XG4gICAgICAgIHZhciBhZGRfaWRzID0gdGhpcy5fZXh0cmFjdElkcyh0aGlzLmFkZFNlbGVjdE9iamVjdC4kZWwuc2VsZWN0MihcImRhdGFcIikpO1xuICAgICAgICB2YXIgbWFuYWdlX2lkcyA9IHRoaXMuX2V4dHJhY3RJZHModGhpcy5tYW5hZ2VTZWxlY3RPYmplY3QuJGVsLnNlbGVjdDIoXCJkYXRhXCIpKTtcbiAgICAgICAgdmFyIG1vZGlmeV9pZHMgPSB0aGlzLl9leHRyYWN0SWRzKHRoaXMubW9kaWZ5U2VsZWN0T2JqZWN0LiRlbC5zZWxlY3QyKFwiZGF0YVwiKSk7XG5cbiAgICAgICAgJC5wb3N0KGAke0dhbGF4eS5yb290fWFwaS9saWJyYXJpZXMvJHtzZWxmLmlkfS9wZXJtaXNzaW9ucz9hY3Rpb249c2V0X3Blcm1pc3Npb25zYCwge1xuICAgICAgICAgICAgXCJhY2Nlc3NfaWRzW11cIjogYWNjZXNzX2lkcyxcbiAgICAgICAgICAgIFwiYWRkX2lkc1tdXCI6IGFkZF9pZHMsXG4gICAgICAgICAgICBcIm1hbmFnZV9pZHNbXVwiOiBtYW5hZ2VfaWRzLFxuICAgICAgICAgICAgXCJtb2RpZnlfaWRzW11cIjogbW9kaWZ5X2lkc1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmRvbmUoZmV0Y2hlZF9wZXJtaXNzaW9ucyA9PiB7XG4gICAgICAgICAgICAgICAgLy9mZXRjaCBkYXRhc2V0IGFnYWluXG4gICAgICAgICAgICAgICAgc2VsZi5zaG93UGVybWlzc2lvbnMoe1xuICAgICAgICAgICAgICAgICAgICBmZXRjaGVkX3Blcm1pc3Npb25zOiBmZXRjaGVkX3Blcm1pc3Npb25zXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgbW9kX3RvYXN0ci5zdWNjZXNzKFwiUGVybWlzc2lvbnMgc2F2ZWQuXCIpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5mYWlsKCgpID0+IHtcbiAgICAgICAgICAgICAgICBtb2RfdG9hc3RyLmVycm9yKFwiQW4gZXJyb3Igb2NjdXJyZWQgd2hpbGUgYXR0ZW1wdGluZyB0byBzZXQgbGlicmFyeSBwZXJtaXNzaW9ucy5cIik7XG4gICAgICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgdGVtcGxhdGVMaWJyYXJ5UGVybWlzc2lvbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gXy50ZW1wbGF0ZShcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnPGRpdiBjbGFzcz1cImxpYnJhcnlfc3R5bGVfY29udGFpbmVyXCI+JyxcbiAgICAgICAgICAgICAgICAnPGRpdiBpZD1cImxpYnJhcnlfdG9vbGJhclwiPicsXG4gICAgICAgICAgICAgICAgJzxhIGhyZWY9XCIjXCI+JyxcbiAgICAgICAgICAgICAgICAnPGJ1dHRvbiBkYXRhLXRvZ2dsZT1cInRvb2x0aXBcIiBkYXRhLXBsYWNlbWVudD1cInRvcFwiIHRpdGxlPVwiR28gYmFjayB0byB0aGUgbGlzdCBvZiBMaWJyYXJpZXNcIiBjbGFzcz1cImJ0biBidG4tZGVmYXVsdCBwcmltYXJ5LWJ1dHRvblwiIHR5cGU9XCJidXR0b25cIj4nLFxuICAgICAgICAgICAgICAgICc8c3BhbiBjbGFzcz1cImZhIGZhLWxpc3RcIi8+JyxcbiAgICAgICAgICAgICAgICBcIiZuYnNwO0xpYnJhcmllc1wiLFxuICAgICAgICAgICAgICAgIFwiPC9idXR0b24+XCIsXG4gICAgICAgICAgICAgICAgXCI8L2E+XCIsXG4gICAgICAgICAgICAgICAgXCI8L2Rpdj5cIixcbiAgICAgICAgICAgICAgICBcIjxoMT5cIixcbiAgICAgICAgICAgICAgICAnTGlicmFyeTogPCU9IF8uZXNjYXBlKGxpYnJhcnkuZ2V0KFwibmFtZVwiKSkgJT4nLFxuICAgICAgICAgICAgICAgIFwiPC9oMT5cIixcbiAgICAgICAgICAgICAgICAnPGRpdiBjbGFzcz1cImFsZXJ0IGFsZXJ0LXdhcm5pbmdcIj4nLFxuICAgICAgICAgICAgICAgIFwiPCUgaWYgKGlzX2FkbWluKSB7ICU+XCIsXG4gICAgICAgICAgICAgICAgXCJZb3UgYXJlIGxvZ2dlZCBpbiBhcyBhbiA8c3Ryb25nPmFkbWluaXN0cmF0b3I8L3N0cm9uZz4gdGhlcmVmb3JlIHlvdSBjYW4gbWFuYWdlIGFueSBsaWJyYXJ5IG9uIHRoaXMgR2FsYXh5IGluc3RhbmNlLiBQbGVhc2UgbWFrZSBzdXJlIHlvdSB1bmRlcnN0YW5kIHRoZSBjb25zZXF1ZW5jZXMuXCIsXG4gICAgICAgICAgICAgICAgXCI8JSB9IGVsc2UgeyAlPlwiLFxuICAgICAgICAgICAgICAgIFwiWW91IGNhbiBhc3NpZ24gYW55IG51bWJlciBvZiByb2xlcyB0byBhbnkgb2YgdGhlIGZvbGxvd2luZyBwZXJtaXNzaW9uIHR5cGVzLiBIb3dldmVyIHBsZWFzZSByZWFkIGNhcmVmdWxseSB0aGUgaW1wbGljYXRpb25zIG9mIHN1Y2ggYWN0aW9ucy5cIixcbiAgICAgICAgICAgICAgICBcIjwlIH0lPlwiLFxuICAgICAgICAgICAgICAgIFwiPC9kaXY+XCIsXG4gICAgICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJkYXRhc2V0X3RhYmxlXCI+JyxcbiAgICAgICAgICAgICAgICBcIjxoMj5MaWJyYXJ5IHBlcm1pc3Npb25zPC9oMj5cIixcbiAgICAgICAgICAgICAgICBcIjxoND5Sb2xlcyB0aGF0IGNhbiBhY2Nlc3MgdGhlIGxpYnJhcnk8L2g0PlwiLFxuICAgICAgICAgICAgICAgICc8ZGl2IGlkPVwiYWNjZXNzX3Blcm1cIiBjbGFzcz1cImFjY2Vzc19wZXJtIHJvbGVzLXNlbGVjdGlvblwiLz4nLFxuICAgICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiYWxlcnQgYWxlcnQtaW5mbyByb2xlcy1zZWxlY3Rpb25cIj4nLFxuICAgICAgICAgICAgICAgIFwiVXNlciB3aXRoIDxzdHJvbmc+YW55PC9zdHJvbmc+IG9mIHRoZXNlIHJvbGVzIGNhbiBhY2Nlc3MgdGhpcyBsaWJyYXJ5LiBJZiB0aGVyZSBhcmUgbm8gYWNjZXNzIHJvbGVzIHNldCBvbiB0aGUgbGlicmFyeSBpdCBpcyBjb25zaWRlcmVkIDxzdHJvbmc+dW5yZXN0cmljdGVkPC9zdHJvbmc+LlwiLFxuICAgICAgICAgICAgICAgIFwiPC9kaXY+XCIsXG4gICAgICAgICAgICAgICAgXCI8aDQ+Um9sZXMgdGhhdCBjYW4gbWFuYWdlIHBlcm1pc3Npb25zIG9uIHRoaXMgbGlicmFyeTwvaDQ+XCIsXG4gICAgICAgICAgICAgICAgJzxkaXYgaWQ9XCJtYW5hZ2VfcGVybVwiIGNsYXNzPVwibWFuYWdlX3Blcm0gcm9sZXMtc2VsZWN0aW9uXCIvPicsXG4gICAgICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJhbGVydCBhbGVydC1pbmZvIHJvbGVzLXNlbGVjdGlvblwiPicsXG4gICAgICAgICAgICAgICAgXCJVc2VyIHdpdGggPHN0cm9uZz5hbnk8L3N0cm9uZz4gb2YgdGhlc2Ugcm9sZXMgY2FuIG1hbmFnZSBwZXJtaXNzaW9ucyBvbiB0aGlzIGxpYnJhcnkgKGluY2x1ZGVzIGdpdmluZyBhY2Nlc3MpLlwiLFxuICAgICAgICAgICAgICAgIFwiPC9kaXY+XCIsXG4gICAgICAgICAgICAgICAgXCI8aDQ+Um9sZXMgdGhhdCBjYW4gYWRkIGl0ZW1zIHRvIHRoaXMgbGlicmFyeTwvaDQ+XCIsXG4gICAgICAgICAgICAgICAgJzxkaXYgaWQ9XCJhZGRfcGVybVwiIGNsYXNzPVwiYWRkX3Blcm0gcm9sZXMtc2VsZWN0aW9uXCIvPicsXG4gICAgICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJhbGVydCBhbGVydC1pbmZvIHJvbGVzLXNlbGVjdGlvblwiPicsXG4gICAgICAgICAgICAgICAgXCJVc2VyIHdpdGggPHN0cm9uZz5hbnk8L3N0cm9uZz4gb2YgdGhlc2Ugcm9sZXMgY2FuIGFkZCBpdGVtcyB0byB0aGlzIGxpYnJhcnkgKGZvbGRlcnMgYW5kIGRhdGFzZXRzKS5cIixcbiAgICAgICAgICAgICAgICBcIjwvZGl2PlwiLFxuICAgICAgICAgICAgICAgIFwiPGg0PlJvbGVzIHRoYXQgY2FuIG1vZGlmeSB0aGlzIGxpYnJhcnk8L2g0PlwiLFxuICAgICAgICAgICAgICAgICc8ZGl2IGlkPVwibW9kaWZ5X3Blcm1cIiBjbGFzcz1cIm1vZGlmeV9wZXJtIHJvbGVzLXNlbGVjdGlvblwiLz4nLFxuICAgICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiYWxlcnQgYWxlcnQtaW5mbyByb2xlcy1zZWxlY3Rpb25cIj4nLFxuICAgICAgICAgICAgICAgIFwiVXNlciB3aXRoIDxzdHJvbmc+YW55PC9zdHJvbmc+IG9mIHRoZXNlIHJvbGVzIGNhbiBtb2RpZnkgdGhpcyBsaWJyYXJ5IChuYW1lLCBzeW5vcHNpcywgZXRjLikuXCIsXG4gICAgICAgICAgICAgICAgXCI8L2Rpdj5cIixcbiAgICAgICAgICAgICAgICAnPGJ1dHRvbiBkYXRhLXRvZ2dsZT1cInRvb2x0aXBcIiBkYXRhLXBsYWNlbWVudD1cInRvcFwiIHRpdGxlPVwiU2F2ZSBtb2RpZmljYXRpb25zIG1hZGUgb24gdGhpcyBwYWdlXCIgY2xhc3M9XCJidG4gYnRuLWRlZmF1bHQgdG9vbGJ0bl9zYXZlX3Blcm1pc3Npb25zIHByaW1hcnktYnV0dG9uXCIgdHlwZT1cImJ1dHRvblwiPicsXG4gICAgICAgICAgICAgICAgJzxzcGFuIGNsYXNzPVwiZmEgZmEtZmxvcHB5LW9cIi8+JyxcbiAgICAgICAgICAgICAgICBcIiZuYnNwO1NhdmVcIixcbiAgICAgICAgICAgICAgICBcIjwvYnV0dG9uPlwiLFxuICAgICAgICAgICAgICAgIFwiPC9kaXY+XCIsXG4gICAgICAgICAgICAgICAgXCI8L2Rpdj5cIlxuICAgICAgICAgICAgXS5qb2luKFwiXCIpXG4gICAgICAgICk7XG4gICAgfVxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgICBMaWJyYXJ5VmlldzogTGlicmFyeVZpZXdcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gZ2FsYXh5L3NjcmlwdHMvbXZjL2xpYnJhcnkvbGlicmFyeS1saWJyYXJ5LXZpZXcuanMiXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7OztBQUFBO0FBQ0E7OztBQUFBO0FBQ0E7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBcEJBO0FBc0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQURBO0FBR0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUdBO0FBR0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFsQkE7QUFvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBakRBO0FBQ0E7QUFtREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU9BO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQW1EQTtBQTlSQTtBQUNBO0FBZ1NBO0FBQ0E7QUFEQTtBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///304\n");

/***/ }),

/***/ 305:
/*!***********************************************************!*\
  !*** ./galaxy/scripts/mvc/library/library-folder-view.js ***!
  \***********************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(Backbone, _, $) {\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _toastr = __webpack_require__(/*! libs/toastr */ 7);\n\nvar _toastr2 = _interopRequireDefault(_toastr);\n\nvar _libraryModel = __webpack_require__(/*! mvc/library/library-model */ 13);\n\nvar _libraryModel2 = _interopRequireDefault(_libraryModel);\n\nvar _uiSelect = __webpack_require__(/*! mvc/ui/ui-select */ 10);\n\nvar _uiSelect2 = _interopRequireDefault(_uiSelect);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar FolderView = Backbone.View.extend({\n    el: \"#center\",\n\n    model: null,\n\n    options: {},\n\n    events: {\n        \"click .toolbtn_save_permissions\": \"savePermissions\"\n    },\n\n    initialize: function initialize(options) {\n        this.options = _.extend(this.options, options);\n        if (this.options.id) {\n            this.fetchFolder();\n        }\n    },\n\n    fetchFolder: function fetchFolder(options) {\n        this.options = _.extend(this.options, options);\n        this.model = new _libraryModel2.default.FolderAsModel({\n            id: this.options.id\n        });\n        var that = this;\n        this.model.fetch({\n            success: function success() {\n                if (that.options.show_permissions) {\n                    that.showPermissions();\n                }\n            },\n            error: function error(model, response) {\n                if (typeof response.responseJSON !== \"undefined\") {\n                    _toastr2.default.error(response.responseJSON.err_msg + \" Click this to go back.\", \"\", {\n                        onclick: function onclick() {\n                            Galaxy.libraries.library_router.back();\n                        }\n                    });\n                } else {\n                    _toastr2.default.error(\"An error occurred. Click this to go back.\", \"\", {\n                        onclick: function onclick() {\n                            Galaxy.libraries.library_router.back();\n                        }\n                    });\n                }\n            }\n        });\n    },\n\n    showPermissions: function showPermissions(options) {\n        this.options = _.extend(this.options, options);\n        $(\".tooltip\").remove();\n\n        var is_admin = false;\n        if (Galaxy.user) {\n            is_admin = Galaxy.user.isAdmin();\n        }\n        var template = this.templateFolderPermissions();\n        this.$el.html(template({ folder: this.model, is_admin: is_admin }));\n\n        var self = this;\n        $.get(Galaxy.root + \"api/folders/\" + self.id + \"/permissions?scope=current\").done(function (fetched_permissions) {\n            self.prepareSelectBoxes({\n                fetched_permissions: fetched_permissions\n            });\n        }).fail(function () {\n            _toastr2.default.error(\"An error occurred while attempting to fetch folder permissions.\");\n        });\n\n        $(\"#center [data-toggle]\").tooltip();\n        //hack to show scrollbars\n        $(\"#center\").css(\"overflow\", \"auto\");\n    },\n\n    _serializeRoles: function _serializeRoles(role_list) {\n        var selected_roles = [];\n        for (var i = 0; i < role_list.length; i++) {\n            selected_roles.push(role_list[i][1] + \":\" + role_list[i][0]);\n        }\n        return selected_roles;\n    },\n\n    prepareSelectBoxes: function prepareSelectBoxes(options) {\n        this.options = _.extend(this.options, options);\n        var fetched_permissions = this.options.fetched_permissions;\n        var self = this;\n\n        var selected_add_item_roles = this._serializeRoles(fetched_permissions.add_library_item_role_list);\n        var selected_manage_folder_roles = this._serializeRoles(fetched_permissions.manage_folder_role_list);\n        var selected_modify_folder_roles = this._serializeRoles(fetched_permissions.modify_folder_role_list);\n\n        self.addSelectObject = new _uiSelect2.default.View(this._createSelectOptions(this, \"add_perm\", selected_add_item_roles, false));\n        self.manageSelectObject = new _uiSelect2.default.View(this._createSelectOptions(this, \"manage_perm\", selected_manage_folder_roles, false));\n        self.modifySelectObject = new _uiSelect2.default.View(this._createSelectOptions(this, \"modify_perm\", selected_modify_folder_roles, false));\n    },\n\n    _createSelectOptions: function _createSelectOptions(self, id, init_data) {\n        var select_options = {\n            minimumInputLength: 0,\n            css: id,\n            multiple: true,\n            placeholder: \"Click to select a role\",\n            container: self.$el.find(\"#\" + id),\n            ajax: {\n                url: Galaxy.root + \"api/folders/\" + self.id + \"/permissions?scope=available\",\n                dataType: \"json\",\n                quietMillis: 100,\n                data: function data(term, page) {\n                    // page is the one-based page number tracked by Select2\n                    return {\n                        q: term, //search term\n                        page_limit: 10, // page size\n                        page: page // page number\n                    };\n                },\n                results: function results(data, page) {\n                    var more = page * 10 < data.total; // whether or not there are more results available\n                    // notice we return the value of more so Select2 knows if more results can be loaded\n                    return { results: data.roles, more: more };\n                }\n            },\n            formatResult: function roleFormatResult(role) {\n                return role.name + \" type: \" + role.type;\n            },\n\n            formatSelection: function roleFormatSelection(role) {\n                return role.name;\n            },\n            initSelection: function initSelection(element, callback) {\n                // the input tag has a value attribute preloaded that points to a preselected role's id\n                // this function resolves that id attribute to an object that select2 can render\n                // using its formatResult renderer - that way the role name is shown preselected\n                var data = [];\n                $(element.val().split(\",\")).each(function () {\n                    var item = this.split(\":\");\n                    data.push({\n                        id: item[0],\n                        name: item[1]\n                    });\n                });\n                callback(data);\n            },\n            initialData: init_data.join(\",\"),\n            dropdownCssClass: \"bigdrop\" // apply css that makes the dropdown taller\n        };\n\n        return select_options;\n    },\n\n    /**\n     * Extract the role ids from Select2 elements's 'data'\n     */\n    _extractIds: function _extractIds(roles_list) {\n        var ids_list = [];\n        for (var i = roles_list.length - 1; i >= 0; i--) {\n            ids_list.push(roles_list[i].id);\n        }\n        return ids_list;\n    },\n\n    /**\n     * Save the permissions for roles entered in the select boxes.\n     */\n    savePermissions: function savePermissions(event) {\n        var self = this;\n        var add_ids = this._extractIds(this.addSelectObject.$el.select2(\"data\"));\n        var manage_ids = this._extractIds(this.manageSelectObject.$el.select2(\"data\"));\n        var modify_ids = this._extractIds(this.modifySelectObject.$el.select2(\"data\"));\n        $.post(Galaxy.root + \"api/folders/\" + self.id + \"/permissions?action=set_permissions\", {\n            \"add_ids[]\": add_ids,\n            \"manage_ids[]\": manage_ids,\n            \"modify_ids[]\": modify_ids\n        }).done(function (fetched_permissions) {\n            self.showPermissions({\n                fetched_permissions: fetched_permissions\n            });\n            _toastr2.default.success(\"Permissions saved.\");\n        }).fail(function () {\n            _toastr2.default.error(\"An error occurred while attempting to set folder permissions.\");\n        });\n    },\n\n    templateFolderPermissions: function templateFolderPermissions() {\n        return _.template(['<div class=\"library_style_container\">', '<div id=\"library_toolbar\">', '<a href=\"#/folders/<%= folder.get(\"parent_id\") %>\">', '<button data-toggle=\"tooltip\" data-placement=\"top\" title=\"Go back to the parent folder\" class=\"btn btn-default primary-button\" type=\"button\">', '<span class=\"fa fa-caret-left fa-lg\"/>', \"&nbsp;Parent folder\", \"</button>\", \"</a>\", \"</div>\", \"<h1>\", 'Folder: <%= _.escape(folder.get(\"name\")) %>', \"</h1>\", '<div class=\"alert alert-warning\">', \"<% if (is_admin) { %>\", \"You are logged in as an <strong>administrator</strong> therefore you can manage any folder on this Galaxy instance. Please make sure you understand the consequences.\", \"<% } else { %>\", \"You can assign any number of roles to any of the following permission types. However please read carefully the implications of such actions.\", \"<% }%>\", \"</div>\", '<div class=\"dataset_table\">', \"<h2>Folder permissions</h2>\", \"<h4>\", \"Roles that can manage permissions on this folder\", \"</h4>\", '<div id=\"manage_perm\" class=\"manage_perm roles-selection\"/>', '<div class=\"alert alert-info roles-selection\">', \"User with <strong>any</strong> of these roles can manage permissions on this folder.\", \"</div>\", \"<h4>\", \"Roles that can add items to this folder\", \"</h4>\", '<div id=\"add_perm\" class=\"add_perm roles-selection\"/>', '<div class=\"alert alert-info roles-selection\">', \"User with <strong>any</strong> of these roles can add items to this folder (folders and datasets).\", \"</div>\", \"<h4>\", \"Roles that can modify this folder\", \"</h4>\", '<div id=\"modify_perm\" class=\"modify_perm roles-selection\"/>', '<div class=\"alert alert-info roles-selection\">', \"User with <strong>any</strong> of these roles can modify this folder (name, etc.).\", \"</div>\", '<button data-toggle=\"tooltip\" data-placement=\"top\" title=\"Save modifications\" class=\"btn btn-default toolbtn_save_permissions primary-button\" type=\"button\">', '<span class=\"fa fa-floppy-o\"/>', \"&nbsp;Save\", \"</button>\", \"</div>\", \"</div>\"].join(\"\"));\n    }\n});\n\nexports.default = {\n    FolderView: FolderView\n};\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! libs/backbone */ 2), __webpack_require__(/*! underscore */ 1), __webpack_require__(/*! jquery */ 0)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzA1LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL2dhbGF4eS9zY3JpcHRzL212Yy9saWJyYXJ5L2xpYnJhcnktZm9sZGVyLXZpZXcuanM/OTU0NiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgbW9kX3RvYXN0ciBmcm9tIFwibGlicy90b2FzdHJcIjtcbmltcG9ydCBtb2RfbGlicmFyeV9tb2RlbCBmcm9tIFwibXZjL2xpYnJhcnkvbGlicmFyeS1tb2RlbFwiO1xuaW1wb3J0IG1vZF9zZWxlY3QgZnJvbSBcIm12Yy91aS91aS1zZWxlY3RcIjtcbnZhciBGb2xkZXJWaWV3ID0gQmFja2JvbmUuVmlldy5leHRlbmQoe1xuICAgIGVsOiBcIiNjZW50ZXJcIixcblxuICAgIG1vZGVsOiBudWxsLFxuXG4gICAgb3B0aW9uczoge30sXG5cbiAgICBldmVudHM6IHtcbiAgICAgICAgXCJjbGljayAudG9vbGJ0bl9zYXZlX3Blcm1pc3Npb25zXCI6IFwic2F2ZVBlcm1pc3Npb25zXCJcbiAgICB9LFxuXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBfLmV4dGVuZCh0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmlkKSB7XG4gICAgICAgICAgICB0aGlzLmZldGNoRm9sZGVyKCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZmV0Y2hGb2xkZXI6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gXy5leHRlbmQodGhpcy5vcHRpb25zLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5tb2RlbCA9IG5ldyBtb2RfbGlicmFyeV9tb2RlbC5Gb2xkZXJBc01vZGVsKHtcbiAgICAgICAgICAgIGlkOiB0aGlzLm9wdGlvbnMuaWRcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgdGhpcy5tb2RlbC5mZXRjaCh7XG4gICAgICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhhdC5vcHRpb25zLnNob3dfcGVybWlzc2lvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5zaG93UGVybWlzc2lvbnMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZXJyb3I6IGZ1bmN0aW9uKG1vZGVsLCByZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcmVzcG9uc2UucmVzcG9uc2VKU09OICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIG1vZF90b2FzdHIuZXJyb3IoYCR7cmVzcG9uc2UucmVzcG9uc2VKU09OLmVycl9tc2d9IENsaWNrIHRoaXMgdG8gZ28gYmFjay5gLCBcIlwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbmNsaWNrOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBHYWxheHkubGlicmFyaWVzLmxpYnJhcnlfcm91dGVyLmJhY2soKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbW9kX3RvYXN0ci5lcnJvcihcIkFuIGVycm9yIG9jY3VycmVkLiBDbGljayB0aGlzIHRvIGdvIGJhY2suXCIsIFwiXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uY2xpY2s6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEdhbGF4eS5saWJyYXJpZXMubGlicmFyeV9yb3V0ZXIuYmFjaygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBzaG93UGVybWlzc2lvbnM6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gXy5leHRlbmQodGhpcy5vcHRpb25zLCBvcHRpb25zKTtcbiAgICAgICAgJChcIi50b29sdGlwXCIpLnJlbW92ZSgpO1xuXG4gICAgICAgIHZhciBpc19hZG1pbiA9IGZhbHNlO1xuICAgICAgICBpZiAoR2FsYXh5LnVzZXIpIHtcbiAgICAgICAgICAgIGlzX2FkbWluID0gR2FsYXh5LnVzZXIuaXNBZG1pbigpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0ZW1wbGF0ZSA9IHRoaXMudGVtcGxhdGVGb2xkZXJQZXJtaXNzaW9ucygpO1xuICAgICAgICB0aGlzLiRlbC5odG1sKHRlbXBsYXRlKHsgZm9sZGVyOiB0aGlzLm1vZGVsLCBpc19hZG1pbjogaXNfYWRtaW4gfSkpO1xuXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgJC5nZXQoYCR7R2FsYXh5LnJvb3R9YXBpL2ZvbGRlcnMvJHtzZWxmLmlkfS9wZXJtaXNzaW9ucz9zY29wZT1jdXJyZW50YClcbiAgICAgICAgICAgIC5kb25lKGZldGNoZWRfcGVybWlzc2lvbnMgPT4ge1xuICAgICAgICAgICAgICAgIHNlbGYucHJlcGFyZVNlbGVjdEJveGVzKHtcbiAgICAgICAgICAgICAgICAgICAgZmV0Y2hlZF9wZXJtaXNzaW9uczogZmV0Y2hlZF9wZXJtaXNzaW9uc1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5mYWlsKCgpID0+IHtcbiAgICAgICAgICAgICAgICBtb2RfdG9hc3RyLmVycm9yKFwiQW4gZXJyb3Igb2NjdXJyZWQgd2hpbGUgYXR0ZW1wdGluZyB0byBmZXRjaCBmb2xkZXIgcGVybWlzc2lvbnMuXCIpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgJChcIiNjZW50ZXIgW2RhdGEtdG9nZ2xlXVwiKS50b29sdGlwKCk7XG4gICAgICAgIC8vaGFjayB0byBzaG93IHNjcm9sbGJhcnNcbiAgICAgICAgJChcIiNjZW50ZXJcIikuY3NzKFwib3ZlcmZsb3dcIiwgXCJhdXRvXCIpO1xuICAgIH0sXG5cbiAgICBfc2VyaWFsaXplUm9sZXM6IGZ1bmN0aW9uKHJvbGVfbGlzdCkge1xuICAgICAgICB2YXIgc2VsZWN0ZWRfcm9sZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByb2xlX2xpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHNlbGVjdGVkX3JvbGVzLnB1c2goYCR7cm9sZV9saXN0W2ldWzFdfToke3JvbGVfbGlzdFtpXVswXX1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VsZWN0ZWRfcm9sZXM7XG4gICAgfSxcblxuICAgIHByZXBhcmVTZWxlY3RCb3hlczogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBfLmV4dGVuZCh0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuICAgICAgICB2YXIgZmV0Y2hlZF9wZXJtaXNzaW9ucyA9IHRoaXMub3B0aW9ucy5mZXRjaGVkX3Blcm1pc3Npb25zO1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgdmFyIHNlbGVjdGVkX2FkZF9pdGVtX3JvbGVzID0gdGhpcy5fc2VyaWFsaXplUm9sZXMoZmV0Y2hlZF9wZXJtaXNzaW9ucy5hZGRfbGlicmFyeV9pdGVtX3JvbGVfbGlzdCk7XG4gICAgICAgIHZhciBzZWxlY3RlZF9tYW5hZ2VfZm9sZGVyX3JvbGVzID0gdGhpcy5fc2VyaWFsaXplUm9sZXMoZmV0Y2hlZF9wZXJtaXNzaW9ucy5tYW5hZ2VfZm9sZGVyX3JvbGVfbGlzdCk7XG4gICAgICAgIHZhciBzZWxlY3RlZF9tb2RpZnlfZm9sZGVyX3JvbGVzID0gdGhpcy5fc2VyaWFsaXplUm9sZXMoZmV0Y2hlZF9wZXJtaXNzaW9ucy5tb2RpZnlfZm9sZGVyX3JvbGVfbGlzdCk7XG5cbiAgICAgICAgc2VsZi5hZGRTZWxlY3RPYmplY3QgPSBuZXcgbW9kX3NlbGVjdC5WaWV3KFxuICAgICAgICAgICAgdGhpcy5fY3JlYXRlU2VsZWN0T3B0aW9ucyh0aGlzLCBcImFkZF9wZXJtXCIsIHNlbGVjdGVkX2FkZF9pdGVtX3JvbGVzLCBmYWxzZSlcbiAgICAgICAgKTtcbiAgICAgICAgc2VsZi5tYW5hZ2VTZWxlY3RPYmplY3QgPSBuZXcgbW9kX3NlbGVjdC5WaWV3KFxuICAgICAgICAgICAgdGhpcy5fY3JlYXRlU2VsZWN0T3B0aW9ucyh0aGlzLCBcIm1hbmFnZV9wZXJtXCIsIHNlbGVjdGVkX21hbmFnZV9mb2xkZXJfcm9sZXMsIGZhbHNlKVxuICAgICAgICApO1xuICAgICAgICBzZWxmLm1vZGlmeVNlbGVjdE9iamVjdCA9IG5ldyBtb2Rfc2VsZWN0LlZpZXcoXG4gICAgICAgICAgICB0aGlzLl9jcmVhdGVTZWxlY3RPcHRpb25zKHRoaXMsIFwibW9kaWZ5X3Blcm1cIiwgc2VsZWN0ZWRfbW9kaWZ5X2ZvbGRlcl9yb2xlcywgZmFsc2UpXG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIF9jcmVhdGVTZWxlY3RPcHRpb25zOiBmdW5jdGlvbihzZWxmLCBpZCwgaW5pdF9kYXRhKSB7XG4gICAgICAgIHZhciBzZWxlY3Rfb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIG1pbmltdW1JbnB1dExlbmd0aDogMCxcbiAgICAgICAgICAgIGNzczogaWQsXG4gICAgICAgICAgICBtdWx0aXBsZTogdHJ1ZSxcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyOiBcIkNsaWNrIHRvIHNlbGVjdCBhIHJvbGVcIixcbiAgICAgICAgICAgIGNvbnRhaW5lcjogc2VsZi4kZWwuZmluZChgIyR7aWR9YCksXG4gICAgICAgICAgICBhamF4OiB7XG4gICAgICAgICAgICAgICAgdXJsOiBgJHtHYWxheHkucm9vdH1hcGkvZm9sZGVycy8ke3NlbGYuaWR9L3Blcm1pc3Npb25zP3Njb3BlPWF2YWlsYWJsZWAsXG4gICAgICAgICAgICAgICAgZGF0YVR5cGU6IFwianNvblwiLFxuICAgICAgICAgICAgICAgIHF1aWV0TWlsbGlzOiAxMDAsXG4gICAgICAgICAgICAgICAgZGF0YTogZnVuY3Rpb24odGVybSwgcGFnZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBwYWdlIGlzIHRoZSBvbmUtYmFzZWQgcGFnZSBudW1iZXIgdHJhY2tlZCBieSBTZWxlY3QyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBxOiB0ZXJtLCAvL3NlYXJjaCB0ZXJtXG4gICAgICAgICAgICAgICAgICAgICAgICBwYWdlX2xpbWl0OiAxMCwgLy8gcGFnZSBzaXplXG4gICAgICAgICAgICAgICAgICAgICAgICBwYWdlOiBwYWdlIC8vIHBhZ2UgbnVtYmVyXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICByZXN1bHRzOiBmdW5jdGlvbihkYXRhLCBwYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtb3JlID0gcGFnZSAqIDEwIDwgZGF0YS50b3RhbDsgLy8gd2hldGhlciBvciBub3QgdGhlcmUgYXJlIG1vcmUgcmVzdWx0cyBhdmFpbGFibGVcbiAgICAgICAgICAgICAgICAgICAgLy8gbm90aWNlIHdlIHJldHVybiB0aGUgdmFsdWUgb2YgbW9yZSBzbyBTZWxlY3QyIGtub3dzIGlmIG1vcmUgcmVzdWx0cyBjYW4gYmUgbG9hZGVkXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHJlc3VsdHM6IGRhdGEucm9sZXMsIG1vcmU6IG1vcmUgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZm9ybWF0UmVzdWx0OiBmdW5jdGlvbiByb2xlRm9ybWF0UmVzdWx0KHJvbGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYCR7cm9sZS5uYW1lfSB0eXBlOiAke3JvbGUudHlwZX1gO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZm9ybWF0U2VsZWN0aW9uOiBmdW5jdGlvbiByb2xlRm9ybWF0U2VsZWN0aW9uKHJvbGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcm9sZS5uYW1lO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGluaXRTZWxlY3Rpb246IGZ1bmN0aW9uKGVsZW1lbnQsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgLy8gdGhlIGlucHV0IHRhZyBoYXMgYSB2YWx1ZSBhdHRyaWJ1dGUgcHJlbG9hZGVkIHRoYXQgcG9pbnRzIHRvIGEgcHJlc2VsZWN0ZWQgcm9sZSdzIGlkXG4gICAgICAgICAgICAgICAgLy8gdGhpcyBmdW5jdGlvbiByZXNvbHZlcyB0aGF0IGlkIGF0dHJpYnV0ZSB0byBhbiBvYmplY3QgdGhhdCBzZWxlY3QyIGNhbiByZW5kZXJcbiAgICAgICAgICAgICAgICAvLyB1c2luZyBpdHMgZm9ybWF0UmVzdWx0IHJlbmRlcmVyIC0gdGhhdCB3YXkgdGhlIHJvbGUgbmFtZSBpcyBzaG93biBwcmVzZWxlY3RlZFxuICAgICAgICAgICAgICAgIHZhciBkYXRhID0gW107XG4gICAgICAgICAgICAgICAgJChlbGVtZW50LnZhbCgpLnNwbGl0KFwiLFwiKSkuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSB0aGlzLnNwbGl0KFwiOlwiKTtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBpdGVtWzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogaXRlbVsxXVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhkYXRhKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpbml0aWFsRGF0YTogaW5pdF9kYXRhLmpvaW4oXCIsXCIpLFxuICAgICAgICAgICAgZHJvcGRvd25Dc3NDbGFzczogXCJiaWdkcm9wXCIgLy8gYXBwbHkgY3NzIHRoYXQgbWFrZXMgdGhlIGRyb3Bkb3duIHRhbGxlclxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBzZWxlY3Rfb3B0aW9ucztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRXh0cmFjdCB0aGUgcm9sZSBpZHMgZnJvbSBTZWxlY3QyIGVsZW1lbnRzJ3MgJ2RhdGEnXG4gICAgICovXG4gICAgX2V4dHJhY3RJZHM6IGZ1bmN0aW9uKHJvbGVzX2xpc3QpIHtcbiAgICAgICAgdmFyIGlkc19saXN0ID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSByb2xlc19saXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBpZHNfbGlzdC5wdXNoKHJvbGVzX2xpc3RbaV0uaWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpZHNfbGlzdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2F2ZSB0aGUgcGVybWlzc2lvbnMgZm9yIHJvbGVzIGVudGVyZWQgaW4gdGhlIHNlbGVjdCBib3hlcy5cbiAgICAgKi9cbiAgICBzYXZlUGVybWlzc2lvbnM6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIGFkZF9pZHMgPSB0aGlzLl9leHRyYWN0SWRzKHRoaXMuYWRkU2VsZWN0T2JqZWN0LiRlbC5zZWxlY3QyKFwiZGF0YVwiKSk7XG4gICAgICAgIHZhciBtYW5hZ2VfaWRzID0gdGhpcy5fZXh0cmFjdElkcyh0aGlzLm1hbmFnZVNlbGVjdE9iamVjdC4kZWwuc2VsZWN0MihcImRhdGFcIikpO1xuICAgICAgICB2YXIgbW9kaWZ5X2lkcyA9IHRoaXMuX2V4dHJhY3RJZHModGhpcy5tb2RpZnlTZWxlY3RPYmplY3QuJGVsLnNlbGVjdDIoXCJkYXRhXCIpKTtcbiAgICAgICAgJC5wb3N0KGAke0dhbGF4eS5yb290fWFwaS9mb2xkZXJzLyR7c2VsZi5pZH0vcGVybWlzc2lvbnM/YWN0aW9uPXNldF9wZXJtaXNzaW9uc2AsIHtcbiAgICAgICAgICAgIFwiYWRkX2lkc1tdXCI6IGFkZF9pZHMsXG4gICAgICAgICAgICBcIm1hbmFnZV9pZHNbXVwiOiBtYW5hZ2VfaWRzLFxuICAgICAgICAgICAgXCJtb2RpZnlfaWRzW11cIjogbW9kaWZ5X2lkc1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmRvbmUoZmV0Y2hlZF9wZXJtaXNzaW9ucyA9PiB7XG4gICAgICAgICAgICAgICAgc2VsZi5zaG93UGVybWlzc2lvbnMoe1xuICAgICAgICAgICAgICAgICAgICBmZXRjaGVkX3Blcm1pc3Npb25zOiBmZXRjaGVkX3Blcm1pc3Npb25zXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgbW9kX3RvYXN0ci5zdWNjZXNzKFwiUGVybWlzc2lvbnMgc2F2ZWQuXCIpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5mYWlsKCgpID0+IHtcbiAgICAgICAgICAgICAgICBtb2RfdG9hc3RyLmVycm9yKFwiQW4gZXJyb3Igb2NjdXJyZWQgd2hpbGUgYXR0ZW1wdGluZyB0byBzZXQgZm9sZGVyIHBlcm1pc3Npb25zLlwiKTtcbiAgICAgICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICB0ZW1wbGF0ZUZvbGRlclBlcm1pc3Npb25zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF8udGVtcGxhdGUoXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJsaWJyYXJ5X3N0eWxlX2NvbnRhaW5lclwiPicsXG4gICAgICAgICAgICAgICAgJzxkaXYgaWQ9XCJsaWJyYXJ5X3Rvb2xiYXJcIj4nLFxuICAgICAgICAgICAgICAgICc8YSBocmVmPVwiIy9mb2xkZXJzLzwlPSBmb2xkZXIuZ2V0KFwicGFyZW50X2lkXCIpICU+XCI+JyxcbiAgICAgICAgICAgICAgICAnPGJ1dHRvbiBkYXRhLXRvZ2dsZT1cInRvb2x0aXBcIiBkYXRhLXBsYWNlbWVudD1cInRvcFwiIHRpdGxlPVwiR28gYmFjayB0byB0aGUgcGFyZW50IGZvbGRlclwiIGNsYXNzPVwiYnRuIGJ0bi1kZWZhdWx0IHByaW1hcnktYnV0dG9uXCIgdHlwZT1cImJ1dHRvblwiPicsXG4gICAgICAgICAgICAgICAgJzxzcGFuIGNsYXNzPVwiZmEgZmEtY2FyZXQtbGVmdCBmYS1sZ1wiLz4nLFxuICAgICAgICAgICAgICAgIFwiJm5ic3A7UGFyZW50IGZvbGRlclwiLFxuICAgICAgICAgICAgICAgIFwiPC9idXR0b24+XCIsXG4gICAgICAgICAgICAgICAgXCI8L2E+XCIsXG4gICAgICAgICAgICAgICAgXCI8L2Rpdj5cIixcbiAgICAgICAgICAgICAgICBcIjxoMT5cIixcbiAgICAgICAgICAgICAgICAnRm9sZGVyOiA8JT0gXy5lc2NhcGUoZm9sZGVyLmdldChcIm5hbWVcIikpICU+JyxcbiAgICAgICAgICAgICAgICBcIjwvaDE+XCIsXG4gICAgICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJhbGVydCBhbGVydC13YXJuaW5nXCI+JyxcbiAgICAgICAgICAgICAgICBcIjwlIGlmIChpc19hZG1pbikgeyAlPlwiLFxuICAgICAgICAgICAgICAgIFwiWW91IGFyZSBsb2dnZWQgaW4gYXMgYW4gPHN0cm9uZz5hZG1pbmlzdHJhdG9yPC9zdHJvbmc+IHRoZXJlZm9yZSB5b3UgY2FuIG1hbmFnZSBhbnkgZm9sZGVyIG9uIHRoaXMgR2FsYXh5IGluc3RhbmNlLiBQbGVhc2UgbWFrZSBzdXJlIHlvdSB1bmRlcnN0YW5kIHRoZSBjb25zZXF1ZW5jZXMuXCIsXG4gICAgICAgICAgICAgICAgXCI8JSB9IGVsc2UgeyAlPlwiLFxuICAgICAgICAgICAgICAgIFwiWW91IGNhbiBhc3NpZ24gYW55IG51bWJlciBvZiByb2xlcyB0byBhbnkgb2YgdGhlIGZvbGxvd2luZyBwZXJtaXNzaW9uIHR5cGVzLiBIb3dldmVyIHBsZWFzZSByZWFkIGNhcmVmdWxseSB0aGUgaW1wbGljYXRpb25zIG9mIHN1Y2ggYWN0aW9ucy5cIixcbiAgICAgICAgICAgICAgICBcIjwlIH0lPlwiLFxuICAgICAgICAgICAgICAgIFwiPC9kaXY+XCIsXG4gICAgICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJkYXRhc2V0X3RhYmxlXCI+JyxcbiAgICAgICAgICAgICAgICBcIjxoMj5Gb2xkZXIgcGVybWlzc2lvbnM8L2gyPlwiLFxuICAgICAgICAgICAgICAgIFwiPGg0PlwiLFxuICAgICAgICAgICAgICAgIFwiUm9sZXMgdGhhdCBjYW4gbWFuYWdlIHBlcm1pc3Npb25zIG9uIHRoaXMgZm9sZGVyXCIsXG4gICAgICAgICAgICAgICAgXCI8L2g0PlwiLFxuICAgICAgICAgICAgICAgICc8ZGl2IGlkPVwibWFuYWdlX3Blcm1cIiBjbGFzcz1cIm1hbmFnZV9wZXJtIHJvbGVzLXNlbGVjdGlvblwiLz4nLFxuICAgICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiYWxlcnQgYWxlcnQtaW5mbyByb2xlcy1zZWxlY3Rpb25cIj4nLFxuICAgICAgICAgICAgICAgIFwiVXNlciB3aXRoIDxzdHJvbmc+YW55PC9zdHJvbmc+IG9mIHRoZXNlIHJvbGVzIGNhbiBtYW5hZ2UgcGVybWlzc2lvbnMgb24gdGhpcyBmb2xkZXIuXCIsXG4gICAgICAgICAgICAgICAgXCI8L2Rpdj5cIixcbiAgICAgICAgICAgICAgICBcIjxoND5cIixcbiAgICAgICAgICAgICAgICBcIlJvbGVzIHRoYXQgY2FuIGFkZCBpdGVtcyB0byB0aGlzIGZvbGRlclwiLFxuICAgICAgICAgICAgICAgIFwiPC9oND5cIixcbiAgICAgICAgICAgICAgICAnPGRpdiBpZD1cImFkZF9wZXJtXCIgY2xhc3M9XCJhZGRfcGVybSByb2xlcy1zZWxlY3Rpb25cIi8+JyxcbiAgICAgICAgICAgICAgICAnPGRpdiBjbGFzcz1cImFsZXJ0IGFsZXJ0LWluZm8gcm9sZXMtc2VsZWN0aW9uXCI+JyxcbiAgICAgICAgICAgICAgICBcIlVzZXIgd2l0aCA8c3Ryb25nPmFueTwvc3Ryb25nPiBvZiB0aGVzZSByb2xlcyBjYW4gYWRkIGl0ZW1zIHRvIHRoaXMgZm9sZGVyIChmb2xkZXJzIGFuZCBkYXRhc2V0cykuXCIsXG4gICAgICAgICAgICAgICAgXCI8L2Rpdj5cIixcbiAgICAgICAgICAgICAgICBcIjxoND5cIixcbiAgICAgICAgICAgICAgICBcIlJvbGVzIHRoYXQgY2FuIG1vZGlmeSB0aGlzIGZvbGRlclwiLFxuICAgICAgICAgICAgICAgIFwiPC9oND5cIixcbiAgICAgICAgICAgICAgICAnPGRpdiBpZD1cIm1vZGlmeV9wZXJtXCIgY2xhc3M9XCJtb2RpZnlfcGVybSByb2xlcy1zZWxlY3Rpb25cIi8+JyxcbiAgICAgICAgICAgICAgICAnPGRpdiBjbGFzcz1cImFsZXJ0IGFsZXJ0LWluZm8gcm9sZXMtc2VsZWN0aW9uXCI+JyxcbiAgICAgICAgICAgICAgICBcIlVzZXIgd2l0aCA8c3Ryb25nPmFueTwvc3Ryb25nPiBvZiB0aGVzZSByb2xlcyBjYW4gbW9kaWZ5IHRoaXMgZm9sZGVyIChuYW1lLCBldGMuKS5cIixcbiAgICAgICAgICAgICAgICBcIjwvZGl2PlwiLFxuICAgICAgICAgICAgICAgICc8YnV0dG9uIGRhdGEtdG9nZ2xlPVwidG9vbHRpcFwiIGRhdGEtcGxhY2VtZW50PVwidG9wXCIgdGl0bGU9XCJTYXZlIG1vZGlmaWNhdGlvbnNcIiBjbGFzcz1cImJ0biBidG4tZGVmYXVsdCB0b29sYnRuX3NhdmVfcGVybWlzc2lvbnMgcHJpbWFyeS1idXR0b25cIiB0eXBlPVwiYnV0dG9uXCI+JyxcbiAgICAgICAgICAgICAgICAnPHNwYW4gY2xhc3M9XCJmYSBmYS1mbG9wcHktb1wiLz4nLFxuICAgICAgICAgICAgICAgIFwiJm5ic3A7U2F2ZVwiLFxuICAgICAgICAgICAgICAgIFwiPC9idXR0b24+XCIsXG4gICAgICAgICAgICAgICAgXCI8L2Rpdj5cIixcbiAgICAgICAgICAgICAgICBcIjwvZGl2PlwiXG4gICAgICAgICAgICBdLmpvaW4oXCJcIilcbiAgICAgICAgKTtcbiAgICB9XG59KTtcblxuZXhwb3J0IGRlZmF1bHQge1xuICAgIEZvbGRlclZpZXc6IEZvbGRlclZpZXdcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gZ2FsYXh5L3NjcmlwdHMvbXZjL2xpYnJhcnkvbGlicmFyeS1mb2xkZXItdmlldy5qcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTs7O0FBQUE7QUFDQTs7O0FBQUE7QUFDQTs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFwQkE7QUFzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQURBO0FBR0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFHQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFoQkE7QUFrQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQTlDQTtBQUNBO0FBZ0RBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBTUE7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQW9EQTtBQXBQQTtBQUNBO0FBc1BBO0FBQ0E7QUFEQTtBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///305\n");

/***/ }),

/***/ 306:
/*!******************************************!*\
  !*** ./galaxy/scripts/admin.toolshed.js ***!
  \******************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(Backbone) {\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _shedListView = __webpack_require__(/*! mvc/toolshed/shed-list-view */ 307);\n\nvar _shedListView2 = _interopRequireDefault(_shedListView);\n\nvar _categoriesView = __webpack_require__(/*! mvc/toolshed/categories-view */ 308);\n\nvar _categoriesView2 = _interopRequireDefault(_categoriesView);\n\nvar _repositoriesView = __webpack_require__(/*! mvc/toolshed/repositories-view */ 309);\n\nvar _repositoriesView2 = _interopRequireDefault(_repositoriesView);\n\nvar _repositoryView = __webpack_require__(/*! mvc/toolshed/repository-view */ 310);\n\nvar _repositoryView2 = _interopRequireDefault(_repositoryView);\n\nvar _repositoryQueueView = __webpack_require__(/*! mvc/toolshed/repository-queue-view */ 311);\n\nvar _repositoryQueueView2 = _interopRequireDefault(_repositoryQueueView);\n\nvar _repoStatusView = __webpack_require__(/*! mvc/toolshed/repo-status-view */ 312);\n\nvar _repoStatusView2 = _interopRequireDefault(_repoStatusView);\n\nvar _workflowsView = __webpack_require__(/*! mvc/toolshed/workflows-view */ 313);\n\nvar _workflowsView2 = _interopRequireDefault(_workflowsView);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar AdminToolshedRouter = Backbone.Router.extend({\n    initialize: function initialize() {\n        this.routesHit = 0;\n        // keep count of number of routes handled by the application\n        Backbone.history.on(\"route\", function () {\n            this.routesHit++;\n        }, this);\n        this.bind(\"route\", this.trackPageview);\n    },\n\n    routes: {\n        \"\": \"toolsheds\",\n        sheds: \"toolsheds\",\n        queue: \"queue\",\n        workflows: \"workflows\",\n        \"status/r/:repositories\": \"status\",\n        status: \"status\",\n        \"categories/s/:tool_shed\": \"categories\",\n        \"category/s/:tool_shed/c/:cateory_id\": \"repositories\",\n        \"repository/s/:tool_shed/r/:repository_id\": \"repository\"\n    },\n\n    /**\n     * If more than one route has been hit the user did not land on current\n     * page directly so we can go back safely. Otherwise go to the home page.\n     * Use replaceState if available so the navigation doesn't create an\n     * extra history entry\n     */\n    back: function back() {\n        if (this.routesHit > 1) {\n            window.history.back();\n        } else {\n            this.navigate(\"#\", { trigger: true, replace: true });\n        }\n    }\n});\n\nvar GalaxyAdminToolshedApp = Backbone.View.extend({\n    app_config: {\n        known_views: [\"toolsheds\", \"queue\", \"status\", \"categories\", \"repositories\", \"repoository\"]\n    },\n\n    initialize: function initialize() {\n        Galaxy.admintoolshedapp = this;\n        this.admin_toolshed_router = new AdminToolshedRouter();\n\n        this.admin_toolshed_router.on(\"route:queue\", function () {\n            if (Galaxy.admintoolshedapp.adminRepoQueueView) {\n                Galaxy.admintoolshedapp.adminRepoQueueView.reDraw();\n            } else {\n                Galaxy.admintoolshedapp.adminRepoQueueView = new _repositoryQueueView2.default.RepoQueueView();\n            }\n        });\n        this.admin_toolshed_router.on(\"route:toolsheds\", function () {\n            if (Galaxy.admintoolshedapp.adminShedListView) {\n                Galaxy.admintoolshedapp.adminShedListView.reDraw();\n            } else {\n                Galaxy.admintoolshedapp.adminShedListView = new _shedListView2.default.ShedListView();\n            }\n        });\n        this.admin_toolshed_router.on(\"route:categories\", function (tool_shed) {\n            if (Galaxy.admintoolshedapp.adminShedCategoriesView) {\n                Galaxy.admintoolshedapp.adminShedCategoriesView.reDraw({\n                    tool_shed: tool_shed.replace(/\\//g, \"%2f\")\n                });\n            } else {\n                Galaxy.admintoolshedapp.adminShedCategoriesView = new _categoriesView2.default.CategoryView({\n                    tool_shed: tool_shed.replace(/\\//g, \"%2f\")\n                });\n            }\n        });\n        this.admin_toolshed_router.on(\"route:repositories\", function (tool_shed, category_id) {\n            if (Galaxy.admintoolshedapp.adminShedCategoryView) {\n                Galaxy.admintoolshedapp.adminShedCategoryView.reDraw({\n                    tool_shed: tool_shed.replace(/\\//g, \"%2f\"),\n                    category_id: category_id\n                });\n            } else {\n                Galaxy.admintoolshedapp.adminShedCategoryView = new _repositoriesView2.default.Category({\n                    tool_shed: tool_shed.replace(/\\//g, \"%2f\"),\n                    category_id: category_id\n                });\n            }\n        });\n        this.admin_toolshed_router.on(\"route:repository\", function (tool_shed, repository_id) {\n            if (Galaxy.admintoolshedapp.adminRepositoryView) {\n                Galaxy.admintoolshedapp.adminRepositoryView.reDraw({\n                    tool_shed: tool_shed.replace(/\\//g, \"%2f\"),\n                    repository_id: repository_id\n                });\n            } else {\n                Galaxy.admintoolshedapp.adminRepositoryView = new _repositoryView2.default.RepoDetails({\n                    tool_shed: tool_shed.replace(/\\//g, \"%2f\"),\n                    repository_id: repository_id\n                });\n            }\n        });\n        this.admin_toolshed_router.on(\"route:status\", function (repositories) {\n            if (Galaxy.admintoolshedapp.adminRepoStatusView) {\n                Galaxy.admintoolshedapp.adminRepoStatusView.reDraw({\n                    repositories: repositories.split(\"|\")\n                });\n            } else {\n                Galaxy.admintoolshedapp.adminRepoStatusView = new _repoStatusView2.default.RepoStatus({\n                    repositories: repositories.split(\"|\")\n                });\n            }\n        });\n        this.admin_toolshed_router.on(\"route:workflows\", function () {\n            if (Galaxy.admintoolshedapp.adminWorkflowsView) {\n                Galaxy.admintoolshedapp.adminWorkflowsView.reDraw();\n            } else {\n                Galaxy.admintoolshedapp.adminWorkflowsView = new _workflowsView2.default.Workflows();\n            }\n        });\n\n        Backbone.history.start({ pushState: false });\n    }\n});\n\nexports.default = {\n    GalaxyApp: GalaxyAdminToolshedApp\n};\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! libs/backbone */ 2)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzA2LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL2dhbGF4eS9zY3JpcHRzL2FkbWluLnRvb2xzaGVkLmpzP2FkMWIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IG1vZF9zaGVkX2xpc3RfdmlldyBmcm9tIFwibXZjL3Rvb2xzaGVkL3NoZWQtbGlzdC12aWV3XCI7XG5pbXBvcnQgbW9kX2NhdGVnb3JpZXNfdmlldyBmcm9tIFwibXZjL3Rvb2xzaGVkL2NhdGVnb3JpZXMtdmlld1wiO1xuaW1wb3J0IG1vZF9yZXBvc2l0b3JpZXNfdmlldyBmcm9tIFwibXZjL3Rvb2xzaGVkL3JlcG9zaXRvcmllcy12aWV3XCI7XG5pbXBvcnQgbW9kX3JlcG9zaXRvcnlfdmlldyBmcm9tIFwibXZjL3Rvb2xzaGVkL3JlcG9zaXRvcnktdmlld1wiO1xuaW1wb3J0IG1vZF9yZXBvcXVldWVfdmlldyBmcm9tIFwibXZjL3Rvb2xzaGVkL3JlcG9zaXRvcnktcXVldWUtdmlld1wiO1xuaW1wb3J0IG1vZF9yZXBvX3N0YXR1c192aWV3IGZyb20gXCJtdmMvdG9vbHNoZWQvcmVwby1zdGF0dXMtdmlld1wiO1xuaW1wb3J0IG1vZF93b3JrZmxvd3NfdmlldyBmcm9tIFwibXZjL3Rvb2xzaGVkL3dvcmtmbG93cy12aWV3XCI7XG52YXIgQWRtaW5Ub29sc2hlZFJvdXRlciA9IEJhY2tib25lLlJvdXRlci5leHRlbmQoe1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnJvdXRlc0hpdCA9IDA7XG4gICAgICAgIC8vIGtlZXAgY291bnQgb2YgbnVtYmVyIG9mIHJvdXRlcyBoYW5kbGVkIGJ5IHRoZSBhcHBsaWNhdGlvblxuICAgICAgICBCYWNrYm9uZS5oaXN0b3J5Lm9uKFxuICAgICAgICAgICAgXCJyb3V0ZVwiLFxuICAgICAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yb3V0ZXNIaXQrKztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0aGlzXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuYmluZChcInJvdXRlXCIsIHRoaXMudHJhY2tQYWdldmlldyk7XG4gICAgfSxcblxuICAgIHJvdXRlczoge1xuICAgICAgICBcIlwiOiBcInRvb2xzaGVkc1wiLFxuICAgICAgICBzaGVkczogXCJ0b29sc2hlZHNcIixcbiAgICAgICAgcXVldWU6IFwicXVldWVcIixcbiAgICAgICAgd29ya2Zsb3dzOiBcIndvcmtmbG93c1wiLFxuICAgICAgICBcInN0YXR1cy9yLzpyZXBvc2l0b3JpZXNcIjogXCJzdGF0dXNcIixcbiAgICAgICAgc3RhdHVzOiBcInN0YXR1c1wiLFxuICAgICAgICBcImNhdGVnb3JpZXMvcy86dG9vbF9zaGVkXCI6IFwiY2F0ZWdvcmllc1wiLFxuICAgICAgICBcImNhdGVnb3J5L3MvOnRvb2xfc2hlZC9jLzpjYXRlb3J5X2lkXCI6IFwicmVwb3NpdG9yaWVzXCIsXG4gICAgICAgIFwicmVwb3NpdG9yeS9zLzp0b29sX3NoZWQvci86cmVwb3NpdG9yeV9pZFwiOiBcInJlcG9zaXRvcnlcIlxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJZiBtb3JlIHRoYW4gb25lIHJvdXRlIGhhcyBiZWVuIGhpdCB0aGUgdXNlciBkaWQgbm90IGxhbmQgb24gY3VycmVudFxuICAgICAqIHBhZ2UgZGlyZWN0bHkgc28gd2UgY2FuIGdvIGJhY2sgc2FmZWx5LiBPdGhlcndpc2UgZ28gdG8gdGhlIGhvbWUgcGFnZS5cbiAgICAgKiBVc2UgcmVwbGFjZVN0YXRlIGlmIGF2YWlsYWJsZSBzbyB0aGUgbmF2aWdhdGlvbiBkb2Vzbid0IGNyZWF0ZSBhblxuICAgICAqIGV4dHJhIGhpc3RvcnkgZW50cnlcbiAgICAgKi9cbiAgICBiYWNrOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMucm91dGVzSGl0ID4gMSkge1xuICAgICAgICAgICAgd2luZG93Lmhpc3RvcnkuYmFjaygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5uYXZpZ2F0ZShcIiNcIiwgeyB0cmlnZ2VyOiB0cnVlLCByZXBsYWNlOiB0cnVlIH0pO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cbnZhciBHYWxheHlBZG1pblRvb2xzaGVkQXBwID0gQmFja2JvbmUuVmlldy5leHRlbmQoe1xuICAgIGFwcF9jb25maWc6IHtcbiAgICAgICAga25vd25fdmlld3M6IFtcInRvb2xzaGVkc1wiLCBcInF1ZXVlXCIsIFwic3RhdHVzXCIsIFwiY2F0ZWdvcmllc1wiLCBcInJlcG9zaXRvcmllc1wiLCBcInJlcG9vc2l0b3J5XCJdXG4gICAgfSxcblxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKCkge1xuICAgICAgICBHYWxheHkuYWRtaW50b29sc2hlZGFwcCA9IHRoaXM7XG4gICAgICAgIHRoaXMuYWRtaW5fdG9vbHNoZWRfcm91dGVyID0gbmV3IEFkbWluVG9vbHNoZWRSb3V0ZXIoKTtcblxuICAgICAgICB0aGlzLmFkbWluX3Rvb2xzaGVkX3JvdXRlci5vbihcInJvdXRlOnF1ZXVlXCIsICgpID0+IHtcbiAgICAgICAgICAgIGlmIChHYWxheHkuYWRtaW50b29sc2hlZGFwcC5hZG1pblJlcG9RdWV1ZVZpZXcpIHtcbiAgICAgICAgICAgICAgICBHYWxheHkuYWRtaW50b29sc2hlZGFwcC5hZG1pblJlcG9RdWV1ZVZpZXcucmVEcmF3KCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIEdhbGF4eS5hZG1pbnRvb2xzaGVkYXBwLmFkbWluUmVwb1F1ZXVlVmlldyA9IG5ldyBtb2RfcmVwb3F1ZXVlX3ZpZXcuUmVwb1F1ZXVlVmlldygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5hZG1pbl90b29sc2hlZF9yb3V0ZXIub24oXCJyb3V0ZTp0b29sc2hlZHNcIiwgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKEdhbGF4eS5hZG1pbnRvb2xzaGVkYXBwLmFkbWluU2hlZExpc3RWaWV3KSB7XG4gICAgICAgICAgICAgICAgR2FsYXh5LmFkbWludG9vbHNoZWRhcHAuYWRtaW5TaGVkTGlzdFZpZXcucmVEcmF3KCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIEdhbGF4eS5hZG1pbnRvb2xzaGVkYXBwLmFkbWluU2hlZExpc3RWaWV3ID0gbmV3IG1vZF9zaGVkX2xpc3Rfdmlldy5TaGVkTGlzdFZpZXcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYWRtaW5fdG9vbHNoZWRfcm91dGVyLm9uKFwicm91dGU6Y2F0ZWdvcmllc1wiLCB0b29sX3NoZWQgPT4ge1xuICAgICAgICAgICAgaWYgKEdhbGF4eS5hZG1pbnRvb2xzaGVkYXBwLmFkbWluU2hlZENhdGVnb3JpZXNWaWV3KSB7XG4gICAgICAgICAgICAgICAgR2FsYXh5LmFkbWludG9vbHNoZWRhcHAuYWRtaW5TaGVkQ2F0ZWdvcmllc1ZpZXcucmVEcmF3KHtcbiAgICAgICAgICAgICAgICAgICAgdG9vbF9zaGVkOiB0b29sX3NoZWQucmVwbGFjZSgvXFwvL2csIFwiJTJmXCIpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIEdhbGF4eS5hZG1pbnRvb2xzaGVkYXBwLmFkbWluU2hlZENhdGVnb3JpZXNWaWV3ID0gbmV3IG1vZF9jYXRlZ29yaWVzX3ZpZXcuQ2F0ZWdvcnlWaWV3KHtcbiAgICAgICAgICAgICAgICAgICAgdG9vbF9zaGVkOiB0b29sX3NoZWQucmVwbGFjZSgvXFwvL2csIFwiJTJmXCIpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmFkbWluX3Rvb2xzaGVkX3JvdXRlci5vbihcInJvdXRlOnJlcG9zaXRvcmllc1wiLCAodG9vbF9zaGVkLCBjYXRlZ29yeV9pZCkgPT4ge1xuICAgICAgICAgICAgaWYgKEdhbGF4eS5hZG1pbnRvb2xzaGVkYXBwLmFkbWluU2hlZENhdGVnb3J5Vmlldykge1xuICAgICAgICAgICAgICAgIEdhbGF4eS5hZG1pbnRvb2xzaGVkYXBwLmFkbWluU2hlZENhdGVnb3J5Vmlldy5yZURyYXcoe1xuICAgICAgICAgICAgICAgICAgICB0b29sX3NoZWQ6IHRvb2xfc2hlZC5yZXBsYWNlKC9cXC8vZywgXCIlMmZcIiksXG4gICAgICAgICAgICAgICAgICAgIGNhdGVnb3J5X2lkOiBjYXRlZ29yeV9pZFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBHYWxheHkuYWRtaW50b29sc2hlZGFwcC5hZG1pblNoZWRDYXRlZ29yeVZpZXcgPSBuZXcgbW9kX3JlcG9zaXRvcmllc192aWV3LkNhdGVnb3J5KHtcbiAgICAgICAgICAgICAgICAgICAgdG9vbF9zaGVkOiB0b29sX3NoZWQucmVwbGFjZSgvXFwvL2csIFwiJTJmXCIpLFxuICAgICAgICAgICAgICAgICAgICBjYXRlZ29yeV9pZDogY2F0ZWdvcnlfaWRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYWRtaW5fdG9vbHNoZWRfcm91dGVyLm9uKFwicm91dGU6cmVwb3NpdG9yeVwiLCAodG9vbF9zaGVkLCByZXBvc2l0b3J5X2lkKSA9PiB7XG4gICAgICAgICAgICBpZiAoR2FsYXh5LmFkbWludG9vbHNoZWRhcHAuYWRtaW5SZXBvc2l0b3J5Vmlldykge1xuICAgICAgICAgICAgICAgIEdhbGF4eS5hZG1pbnRvb2xzaGVkYXBwLmFkbWluUmVwb3NpdG9yeVZpZXcucmVEcmF3KHtcbiAgICAgICAgICAgICAgICAgICAgdG9vbF9zaGVkOiB0b29sX3NoZWQucmVwbGFjZSgvXFwvL2csIFwiJTJmXCIpLFxuICAgICAgICAgICAgICAgICAgICByZXBvc2l0b3J5X2lkOiByZXBvc2l0b3J5X2lkXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIEdhbGF4eS5hZG1pbnRvb2xzaGVkYXBwLmFkbWluUmVwb3NpdG9yeVZpZXcgPSBuZXcgbW9kX3JlcG9zaXRvcnlfdmlldy5SZXBvRGV0YWlscyh7XG4gICAgICAgICAgICAgICAgICAgIHRvb2xfc2hlZDogdG9vbF9zaGVkLnJlcGxhY2UoL1xcLy9nLCBcIiUyZlwiKSxcbiAgICAgICAgICAgICAgICAgICAgcmVwb3NpdG9yeV9pZDogcmVwb3NpdG9yeV9pZFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5hZG1pbl90b29sc2hlZF9yb3V0ZXIub24oXCJyb3V0ZTpzdGF0dXNcIiwgcmVwb3NpdG9yaWVzID0+IHtcbiAgICAgICAgICAgIGlmIChHYWxheHkuYWRtaW50b29sc2hlZGFwcC5hZG1pblJlcG9TdGF0dXNWaWV3KSB7XG4gICAgICAgICAgICAgICAgR2FsYXh5LmFkbWludG9vbHNoZWRhcHAuYWRtaW5SZXBvU3RhdHVzVmlldy5yZURyYXcoe1xuICAgICAgICAgICAgICAgICAgICByZXBvc2l0b3JpZXM6IHJlcG9zaXRvcmllcy5zcGxpdChcInxcIilcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgR2FsYXh5LmFkbWludG9vbHNoZWRhcHAuYWRtaW5SZXBvU3RhdHVzVmlldyA9IG5ldyBtb2RfcmVwb19zdGF0dXNfdmlldy5SZXBvU3RhdHVzKHtcbiAgICAgICAgICAgICAgICAgICAgcmVwb3NpdG9yaWVzOiByZXBvc2l0b3JpZXMuc3BsaXQoXCJ8XCIpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmFkbWluX3Rvb2xzaGVkX3JvdXRlci5vbihcInJvdXRlOndvcmtmbG93c1wiLCAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoR2FsYXh5LmFkbWludG9vbHNoZWRhcHAuYWRtaW5Xb3JrZmxvd3NWaWV3KSB7XG4gICAgICAgICAgICAgICAgR2FsYXh5LmFkbWludG9vbHNoZWRhcHAuYWRtaW5Xb3JrZmxvd3NWaWV3LnJlRHJhdygpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBHYWxheHkuYWRtaW50b29sc2hlZGFwcC5hZG1pbldvcmtmbG93c1ZpZXcgPSBuZXcgbW9kX3dvcmtmbG93c192aWV3LldvcmtmbG93cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBCYWNrYm9uZS5oaXN0b3J5LnN0YXJ0KHsgcHVzaFN0YXRlOiBmYWxzZSB9KTtcbiAgICB9XG59KTtcblxuZXhwb3J0IGRlZmF1bHQge1xuICAgIEdhbGF4eUFwcDogR2FsYXh5QWRtaW5Ub29sc2hlZEFwcFxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBnYWxheHkvc2NyaXB0cy9hZG1pbi50b29sc2hlZC5qcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTs7O0FBQUE7QUFDQTs7O0FBQUE7QUFDQTs7O0FBQUE7QUFDQTs7O0FBQUE7QUFDQTs7O0FBQUE7QUFDQTs7O0FBQUE7QUFDQTs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVEE7QUFDQTtBQVdBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXRDQTtBQUNBO0FBd0NBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWhGQTtBQUNBO0FBa0ZBO0FBQ0E7QUFEQTtBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///306\n");

/***/ }),

/***/ 307:
/*!*******************************************************!*\
  !*** ./galaxy/scripts/mvc/toolshed/shed-list-view.js ***!
  \*******************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(Backbone, _) {\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _localization = __webpack_require__(/*! utils/localization */ 3);\n\nvar _localization2 = _interopRequireDefault(_localization);\n\nvar _toolshedModel = __webpack_require__(/*! mvc/toolshed/toolshed-model */ 17);\n\nvar _toolshedModel2 = _interopRequireDefault(_toolshedModel);\n\nvar _util = __webpack_require__(/*! mvc/toolshed/util */ 18);\n\nvar _util2 = _interopRequireDefault(_util);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar View = Backbone.View.extend({\n    defaults: {\n        tool_sheds: [{\n            url: \"https://toolshed.g2.bx.psu.edu/\",\n            name: \"Galaxy Main Tool Shed\"\n        }]\n    },\n\n    initialize: function initialize(options) {\n        var self = this;\n        this.options = _.defaults(this.options || {}, this.defaults);\n        this.model = new _toolshedModel2.default.ShedsCollection();\n        this.listenTo(this.model, \"sync\", this.render);\n        this.model.fetch();\n    },\n\n    el: \"#center\",\n\n    render: function render(options) {\n        this.options = _.defaults(this.options || {}, options, this.defaults);\n        var toolshed_list_template = this.templateToolshedList;\n        this.$el.html(toolshed_list_template({\n            title: (0, _localization2.default)(\"Configured Galaxy Tool Sheds\"),\n            tool_sheds: this.model.models,\n            queue: _util2.default.queueLength()\n        }));\n    },\n\n    reDraw: function reDraw(options) {\n        this.$el.empty();\n        this.render(options);\n    },\n\n    templateToolshedList: _.template(['<div class=\"unified-panel-header\" id=\"panel_header\" unselectable=\"on\">', '<div class=\"unified-panel-header-inner\"><%= title %></div>', '<div class=\"unified-panel-header-inner\" style=\"position: absolute; right: 5px; top: 0px;\"><a href=\"#/queue\">Repository Queue (<%= queue %>)</a></div>', \"</div>\", '<div class=\"unified-panel-body\" id=\"list_toolsheds\">', '<div class=\"form-row\">', '<table class=\"grid\">', \"<% _.each(tool_sheds, function(shed) { %>\", '<tr class=\"libraryTitle\">', \"<td>\", '<div style=\"float: left; margin-left: 1px;\" class=\"menubutton split\">', '<a class=\"view-info shed-selector\" href=\"#/categories/s/<%= shed.get(\"url\") %>\"><%= shed.get(\"name\") %></a>', \"</div>\", \"</td>\", \"</tr>\", \"<% }); %>\", \"</table>\", \"</div>\", '<div style=\"clear: both\"></div>', \"</div>\"].join(\"\"))\n});\n\nexports.default = {\n    ShedListView: View\n};\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! libs/backbone */ 2), __webpack_require__(/*! underscore */ 1)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzA3LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL2dhbGF4eS9zY3JpcHRzL212Yy90b29sc2hlZC9zaGVkLWxpc3Qtdmlldy5qcz81YjczIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBfbCBmcm9tIFwidXRpbHMvbG9jYWxpemF0aW9uXCI7XG5pbXBvcnQgdG9vbHNoZWRfbW9kZWwgZnJvbSBcIm12Yy90b29sc2hlZC90b29sc2hlZC1tb2RlbFwiO1xuaW1wb3J0IHRvb2xzaGVkX3V0aWwgZnJvbSBcIm12Yy90b29sc2hlZC91dGlsXCI7XG52YXIgVmlldyA9IEJhY2tib25lLlZpZXcuZXh0ZW5kKHtcbiAgICBkZWZhdWx0czoge1xuICAgICAgICB0b29sX3NoZWRzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdXJsOiBcImh0dHBzOi8vdG9vbHNoZWQuZzIuYngucHN1LmVkdS9cIixcbiAgICAgICAgICAgICAgICBuYW1lOiBcIkdhbGF4eSBNYWluIFRvb2wgU2hlZFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICB9LFxuXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IF8uZGVmYXVsdHModGhpcy5vcHRpb25zIHx8IHt9LCB0aGlzLmRlZmF1bHRzKTtcbiAgICAgICAgdGhpcy5tb2RlbCA9IG5ldyB0b29sc2hlZF9tb2RlbC5TaGVkc0NvbGxlY3Rpb24oKTtcbiAgICAgICAgdGhpcy5saXN0ZW5Ubyh0aGlzLm1vZGVsLCBcInN5bmNcIiwgdGhpcy5yZW5kZXIpO1xuICAgICAgICB0aGlzLm1vZGVsLmZldGNoKCk7XG4gICAgfSxcblxuICAgIGVsOiBcIiNjZW50ZXJcIixcblxuICAgIHJlbmRlcjogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBfLmRlZmF1bHRzKHRoaXMub3B0aW9ucyB8fCB7fSwgb3B0aW9ucywgdGhpcy5kZWZhdWx0cyk7XG4gICAgICAgIHZhciB0b29sc2hlZF9saXN0X3RlbXBsYXRlID0gdGhpcy50ZW1wbGF0ZVRvb2xzaGVkTGlzdDtcbiAgICAgICAgdGhpcy4kZWwuaHRtbChcbiAgICAgICAgICAgIHRvb2xzaGVkX2xpc3RfdGVtcGxhdGUoe1xuICAgICAgICAgICAgICAgIHRpdGxlOiBfbChcIkNvbmZpZ3VyZWQgR2FsYXh5IFRvb2wgU2hlZHNcIiksXG4gICAgICAgICAgICAgICAgdG9vbF9zaGVkczogdGhpcy5tb2RlbC5tb2RlbHMsXG4gICAgICAgICAgICAgICAgcXVldWU6IHRvb2xzaGVkX3V0aWwucXVldWVMZW5ndGgoKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICB9LFxuXG4gICAgcmVEcmF3OiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuJGVsLmVtcHR5KCk7XG4gICAgICAgIHRoaXMucmVuZGVyKG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICB0ZW1wbGF0ZVRvb2xzaGVkTGlzdDogXy50ZW1wbGF0ZShcbiAgICAgICAgW1xuICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJ1bmlmaWVkLXBhbmVsLWhlYWRlclwiIGlkPVwicGFuZWxfaGVhZGVyXCIgdW5zZWxlY3RhYmxlPVwib25cIj4nLFxuICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJ1bmlmaWVkLXBhbmVsLWhlYWRlci1pbm5lclwiPjwlPSB0aXRsZSAlPjwvZGl2PicsXG4gICAgICAgICAgICAnPGRpdiBjbGFzcz1cInVuaWZpZWQtcGFuZWwtaGVhZGVyLWlubmVyXCIgc3R5bGU9XCJwb3NpdGlvbjogYWJzb2x1dGU7IHJpZ2h0OiA1cHg7IHRvcDogMHB4O1wiPjxhIGhyZWY9XCIjL3F1ZXVlXCI+UmVwb3NpdG9yeSBRdWV1ZSAoPCU9IHF1ZXVlICU+KTwvYT48L2Rpdj4nLFxuICAgICAgICAgICAgXCI8L2Rpdj5cIixcbiAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwidW5pZmllZC1wYW5lbC1ib2R5XCIgaWQ9XCJsaXN0X3Rvb2xzaGVkc1wiPicsXG4gICAgICAgICAgICAnPGRpdiBjbGFzcz1cImZvcm0tcm93XCI+JyxcbiAgICAgICAgICAgICc8dGFibGUgY2xhc3M9XCJncmlkXCI+JyxcbiAgICAgICAgICAgIFwiPCUgXy5lYWNoKHRvb2xfc2hlZHMsIGZ1bmN0aW9uKHNoZWQpIHsgJT5cIixcbiAgICAgICAgICAgICc8dHIgY2xhc3M9XCJsaWJyYXJ5VGl0bGVcIj4nLFxuICAgICAgICAgICAgXCI8dGQ+XCIsXG4gICAgICAgICAgICAnPGRpdiBzdHlsZT1cImZsb2F0OiBsZWZ0OyBtYXJnaW4tbGVmdDogMXB4O1wiIGNsYXNzPVwibWVudWJ1dHRvbiBzcGxpdFwiPicsXG4gICAgICAgICAgICAnPGEgY2xhc3M9XCJ2aWV3LWluZm8gc2hlZC1zZWxlY3RvclwiIGhyZWY9XCIjL2NhdGVnb3JpZXMvcy88JT0gc2hlZC5nZXQoXCJ1cmxcIikgJT5cIj48JT0gc2hlZC5nZXQoXCJuYW1lXCIpICU+PC9hPicsXG4gICAgICAgICAgICBcIjwvZGl2PlwiLFxuICAgICAgICAgICAgXCI8L3RkPlwiLFxuICAgICAgICAgICAgXCI8L3RyPlwiLFxuICAgICAgICAgICAgXCI8JSB9KTsgJT5cIixcbiAgICAgICAgICAgIFwiPC90YWJsZT5cIixcbiAgICAgICAgICAgIFwiPC9kaXY+XCIsXG4gICAgICAgICAgICAnPGRpdiBzdHlsZT1cImNsZWFyOiBib3RoXCI+PC9kaXY+JyxcbiAgICAgICAgICAgIFwiPC9kaXY+XCJcbiAgICAgICAgXS5qb2luKFwiXCIpXG4gICAgKVxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgICBTaGVkTGlzdFZpZXc6IFZpZXdcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gZ2FsYXh5L3NjcmlwdHMvbXZjL3Rvb2xzaGVkL3NoZWQtbGlzdC12aWV3LmpzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBOzs7QUFBQTtBQUNBOzs7QUFBQTtBQUNBOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFGQTtBQUZBO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBSEE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBckNBO0FBQ0E7QUE4REE7QUFDQTtBQURBO0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///307\n");

/***/ }),

/***/ 308:
/*!********************************************************!*\
  !*** ./galaxy/scripts/mvc/toolshed/categories-view.js ***!
  \********************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(Backbone, _, $) {\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _toolshedModel = __webpack_require__(/*! mvc/toolshed/toolshed-model */ 17);\n\nvar _toolshedModel2 = _interopRequireDefault(_toolshedModel);\n\nvar _util = __webpack_require__(/*! mvc/toolshed/util */ 18);\n\nvar _util2 = _interopRequireDefault(_util);\n\n__webpack_require__(/*! libs/jquery/jquery-ui */ 30);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar ToolShedCategories = Backbone.View.extend({\n    el: \"#center\",\n\n    defaults: {\n        tool_shed: \"https://toolshed.g2.bx.psu.edu/\"\n    },\n\n    initialize: function initialize(options) {\n        var self = this;\n        var shed = options.tool_shed.replace(/\\//g, \"%2f\");\n        this.options = _.defaults(this.options || options, this.defaults);\n        this.model = new _toolshedModel2.default.Categories();\n        this.listenTo(this.model, \"sync\", this.render);\n        this.model.url = this.model.url + \"?tool_shed_url=\" + this.options.tool_shed;\n        this.model.tool_shed = shed;\n        this.model.fetch();\n    },\n\n    render: function render(options) {\n        this.options = _.extend(this.options, options);\n        this.options.categories = this.model.models;\n        this.options.queue = _util2.default.queueLength();\n        var category_list_template = this.templateCategoryList;\n        this.$el.html(category_list_template(this.options));\n        $(\"#center\").css(\"overflow\", \"auto\");\n        this.bindEvents();\n    },\n\n    bindEvents: function bindEvents() {\n        var that = this;\n        $(\"#search_box\").autocomplete({\n            source: function source(request, response) {\n                var shed_url = that.model.tool_shed.replace(/%2f/g, \"/\");\n                var base_url = Galaxy.root + \"api/tool_shed/search\";\n                var params = {\n                    term: request.term,\n                    tool_shed_url: shed_url\n                };\n                $.post(base_url, params, function (data) {\n                    console.log(data);\n                    var result_list = _util2.default.shedParser(data);\n                    response(result_list);\n                });\n            },\n            minLength: 3,\n            select: function select(event, ui) {\n                var tsr_id = ui.item.value;\n                var api_url = Galaxy.root + \"api/tool_shed/repository\";\n                var params = {\n                    tool_shed_url: that.model.tool_shed,\n                    tsr_id: tsr_id\n                };\n                var new_route = \"repository/s/\" + that.model.tool_shed + \"/r/\" + tsr_id;\n                Backbone.history.navigate(new_route, {\n                    trigger: true,\n                    replace: true\n                });\n            }\n        });\n    },\n\n    reDraw: function reDraw(options) {\n        this.$el.empty();\n        this.model.url = this.model.url + \"?tool_shed_url=\" + this.options.tool_shed;\n        this.initialize(options);\n    },\n\n    templateCategoryList: _.template(['<style type=\"text/css\">', \".ui-autocomplete { background-color: #fff; }\", \"li.ui-menu-item { list-style-type: none; }\", \"</style>\", '<div class=\"unified-panel-header\" id=\"panel_header\" unselectable=\"on\">', '<div class=\"unified-panel-header-inner\" style=\"layout: inline;\">Categories in <%= tool_shed.replace(/%2f/g, \"/\") %></div>', '<div class=\"unified-panel-header-inner\" style=\"position: absolute; right: 5px; top: 0px;\"><a href=\"#/queue\">Repository Queue (<%= queue %>)</a></div>', \"</div>\", '<div class=\"unified-panel-body\" id=\"list_categories\">', '<div id=\"standard-search\" style=\"height: 2em; margin: 1em;\">', '<span class=\"ui-widget\" >', '<input class=\"search-box-input\" id=\"search_box\" data-shedurl=\"<%= tool_shed.replace(/%2f/g, \"/\") %>\" name=\"search\" placeholder=\"Search repositories by name or id\" size=\"60\" type=\"text\" />', \"</span>\", \"</div>\", '<div style=\"clear: both; margin-top: 1em;\">', '<table class=\"grid\">', '<thead id=\"grid-table-header\">', \"<tr>\", \"<th>Name</th>\", \"<th>Description</th>\", \"<th>Repositories</th>\", \"</tr>\", \"</thead>\", \"<% _.each(categories, function(category) { %>\", \"<tr>\", \"<td>\", '<a href=\"#/category/s/<%= tool_shed %>/c/<%= category.get(\"id\") %>\"><%= category.get(\"name\") %></a>', \"</td>\", '<td><%= category.get(\"description\") %></td>', '<td><%= category.get(\"repositories\") %></td>', \"</tr>\", \"<% }); %>\", \"</table>\", \"</div>\", \"</div>\"].join(\"\"))\n});\n\nexports.default = {\n    CategoryView: ToolShedCategories\n};\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! libs/backbone */ 2), __webpack_require__(/*! underscore */ 1), __webpack_require__(/*! jquery */ 0)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzA4LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL2dhbGF4eS9zY3JpcHRzL212Yy90b29sc2hlZC9jYXRlZ29yaWVzLXZpZXcuanM/Y2I5OSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdG9vbHNoZWRfbW9kZWwgZnJvbSBcIm12Yy90b29sc2hlZC90b29sc2hlZC1tb2RlbFwiO1xuaW1wb3J0IHRvb2xzaGVkX3V0aWwgZnJvbSBcIm12Yy90b29sc2hlZC91dGlsXCI7XG5pbXBvcnQgXCJsaWJzL2pxdWVyeS9qcXVlcnktdWlcIjtcbnZhciBUb29sU2hlZENhdGVnb3JpZXMgPSBCYWNrYm9uZS5WaWV3LmV4dGVuZCh7XG4gICAgZWw6IFwiI2NlbnRlclwiLFxuXG4gICAgZGVmYXVsdHM6IHtcbiAgICAgICAgdG9vbF9zaGVkOiBcImh0dHBzOi8vdG9vbHNoZWQuZzIuYngucHN1LmVkdS9cIlxuICAgIH0sXG5cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIHNoZWQgPSBvcHRpb25zLnRvb2xfc2hlZC5yZXBsYWNlKC9cXC8vZywgXCIlMmZcIik7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IF8uZGVmYXVsdHModGhpcy5vcHRpb25zIHx8IG9wdGlvbnMsIHRoaXMuZGVmYXVsdHMpO1xuICAgICAgICB0aGlzLm1vZGVsID0gbmV3IHRvb2xzaGVkX21vZGVsLkNhdGVnb3JpZXMoKTtcbiAgICAgICAgdGhpcy5saXN0ZW5Ubyh0aGlzLm1vZGVsLCBcInN5bmNcIiwgdGhpcy5yZW5kZXIpO1xuICAgICAgICB0aGlzLm1vZGVsLnVybCA9IGAke3RoaXMubW9kZWwudXJsfT90b29sX3NoZWRfdXJsPSR7dGhpcy5vcHRpb25zLnRvb2xfc2hlZH1gO1xuICAgICAgICB0aGlzLm1vZGVsLnRvb2xfc2hlZCA9IHNoZWQ7XG4gICAgICAgIHRoaXMubW9kZWwuZmV0Y2goKTtcbiAgICB9LFxuXG4gICAgcmVuZGVyOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IF8uZXh0ZW5kKHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMub3B0aW9ucy5jYXRlZ29yaWVzID0gdGhpcy5tb2RlbC5tb2RlbHM7XG4gICAgICAgIHRoaXMub3B0aW9ucy5xdWV1ZSA9IHRvb2xzaGVkX3V0aWwucXVldWVMZW5ndGgoKTtcbiAgICAgICAgdmFyIGNhdGVnb3J5X2xpc3RfdGVtcGxhdGUgPSB0aGlzLnRlbXBsYXRlQ2F0ZWdvcnlMaXN0O1xuICAgICAgICB0aGlzLiRlbC5odG1sKGNhdGVnb3J5X2xpc3RfdGVtcGxhdGUodGhpcy5vcHRpb25zKSk7XG4gICAgICAgICQoXCIjY2VudGVyXCIpLmNzcyhcIm92ZXJmbG93XCIsIFwiYXV0b1wiKTtcbiAgICAgICAgdGhpcy5iaW5kRXZlbnRzKCk7XG4gICAgfSxcblxuICAgIGJpbmRFdmVudHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgICQoXCIjc2VhcmNoX2JveFwiKS5hdXRvY29tcGxldGUoe1xuICAgICAgICAgICAgc291cmNlOiBmdW5jdGlvbihyZXF1ZXN0LCByZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIHZhciBzaGVkX3VybCA9IHRoYXQubW9kZWwudG9vbF9zaGVkLnJlcGxhY2UoLyUyZi9nLCBcIi9cIik7XG4gICAgICAgICAgICAgICAgdmFyIGJhc2VfdXJsID0gYCR7R2FsYXh5LnJvb3R9YXBpL3Rvb2xfc2hlZC9zZWFyY2hgO1xuICAgICAgICAgICAgICAgIHZhciBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgICAgIHRlcm06IHJlcXVlc3QudGVybSxcbiAgICAgICAgICAgICAgICAgICAgdG9vbF9zaGVkX3VybDogc2hlZF91cmxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICQucG9zdChiYXNlX3VybCwgcGFyYW1zLCBkYXRhID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHRfbGlzdCA9IHRvb2xzaGVkX3V0aWwuc2hlZFBhcnNlcihkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UocmVzdWx0X2xpc3QpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1pbkxlbmd0aDogMyxcbiAgICAgICAgICAgIHNlbGVjdDogZnVuY3Rpb24oZXZlbnQsIHVpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRzcl9pZCA9IHVpLml0ZW0udmFsdWU7XG4gICAgICAgICAgICAgICAgdmFyIGFwaV91cmwgPSBgJHtHYWxheHkucm9vdH1hcGkvdG9vbF9zaGVkL3JlcG9zaXRvcnlgO1xuICAgICAgICAgICAgICAgIHZhciBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgICAgIHRvb2xfc2hlZF91cmw6IHRoYXQubW9kZWwudG9vbF9zaGVkLFxuICAgICAgICAgICAgICAgICAgICB0c3JfaWQ6IHRzcl9pZFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdmFyIG5ld19yb3V0ZSA9IGByZXBvc2l0b3J5L3MvJHt0aGF0Lm1vZGVsLnRvb2xfc2hlZH0vci8ke3Rzcl9pZH1gO1xuICAgICAgICAgICAgICAgIEJhY2tib25lLmhpc3RvcnkubmF2aWdhdGUobmV3X3JvdXRlLCB7XG4gICAgICAgICAgICAgICAgICAgIHRyaWdnZXI6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHJlcGxhY2U6IHRydWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIHJlRHJhdzogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICB0aGlzLiRlbC5lbXB0eSgpO1xuICAgICAgICB0aGlzLm1vZGVsLnVybCA9IGAke3RoaXMubW9kZWwudXJsfT90b29sX3NoZWRfdXJsPSR7dGhpcy5vcHRpb25zLnRvb2xfc2hlZH1gO1xuICAgICAgICB0aGlzLmluaXRpYWxpemUob3B0aW9ucyk7XG4gICAgfSxcblxuICAgIHRlbXBsYXRlQ2F0ZWdvcnlMaXN0OiBfLnRlbXBsYXRlKFxuICAgICAgICBbXG4gICAgICAgICAgICAnPHN0eWxlIHR5cGU9XCJ0ZXh0L2Nzc1wiPicsXG4gICAgICAgICAgICBcIi51aS1hdXRvY29tcGxldGUgeyBiYWNrZ3JvdW5kLWNvbG9yOiAjZmZmOyB9XCIsXG4gICAgICAgICAgICBcImxpLnVpLW1lbnUtaXRlbSB7IGxpc3Qtc3R5bGUtdHlwZTogbm9uZTsgfVwiLFxuICAgICAgICAgICAgXCI8L3N0eWxlPlwiLFxuICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJ1bmlmaWVkLXBhbmVsLWhlYWRlclwiIGlkPVwicGFuZWxfaGVhZGVyXCIgdW5zZWxlY3RhYmxlPVwib25cIj4nLFxuICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJ1bmlmaWVkLXBhbmVsLWhlYWRlci1pbm5lclwiIHN0eWxlPVwibGF5b3V0OiBpbmxpbmU7XCI+Q2F0ZWdvcmllcyBpbiA8JT0gdG9vbF9zaGVkLnJlcGxhY2UoLyUyZi9nLCBcIi9cIikgJT48L2Rpdj4nLFxuICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJ1bmlmaWVkLXBhbmVsLWhlYWRlci1pbm5lclwiIHN0eWxlPVwicG9zaXRpb246IGFic29sdXRlOyByaWdodDogNXB4OyB0b3A6IDBweDtcIj48YSBocmVmPVwiIy9xdWV1ZVwiPlJlcG9zaXRvcnkgUXVldWUgKDwlPSBxdWV1ZSAlPik8L2E+PC9kaXY+JyxcbiAgICAgICAgICAgIFwiPC9kaXY+XCIsXG4gICAgICAgICAgICAnPGRpdiBjbGFzcz1cInVuaWZpZWQtcGFuZWwtYm9keVwiIGlkPVwibGlzdF9jYXRlZ29yaWVzXCI+JyxcbiAgICAgICAgICAgICc8ZGl2IGlkPVwic3RhbmRhcmQtc2VhcmNoXCIgc3R5bGU9XCJoZWlnaHQ6IDJlbTsgbWFyZ2luOiAxZW07XCI+JyxcbiAgICAgICAgICAgICc8c3BhbiBjbGFzcz1cInVpLXdpZGdldFwiID4nLFxuICAgICAgICAgICAgJzxpbnB1dCBjbGFzcz1cInNlYXJjaC1ib3gtaW5wdXRcIiBpZD1cInNlYXJjaF9ib3hcIiBkYXRhLXNoZWR1cmw9XCI8JT0gdG9vbF9zaGVkLnJlcGxhY2UoLyUyZi9nLCBcIi9cIikgJT5cIiBuYW1lPVwic2VhcmNoXCIgcGxhY2Vob2xkZXI9XCJTZWFyY2ggcmVwb3NpdG9yaWVzIGJ5IG5hbWUgb3IgaWRcIiBzaXplPVwiNjBcIiB0eXBlPVwidGV4dFwiIC8+JyxcbiAgICAgICAgICAgIFwiPC9zcGFuPlwiLFxuICAgICAgICAgICAgXCI8L2Rpdj5cIixcbiAgICAgICAgICAgICc8ZGl2IHN0eWxlPVwiY2xlYXI6IGJvdGg7IG1hcmdpbi10b3A6IDFlbTtcIj4nLFxuICAgICAgICAgICAgJzx0YWJsZSBjbGFzcz1cImdyaWRcIj4nLFxuICAgICAgICAgICAgJzx0aGVhZCBpZD1cImdyaWQtdGFibGUtaGVhZGVyXCI+JyxcbiAgICAgICAgICAgIFwiPHRyPlwiLFxuICAgICAgICAgICAgXCI8dGg+TmFtZTwvdGg+XCIsXG4gICAgICAgICAgICBcIjx0aD5EZXNjcmlwdGlvbjwvdGg+XCIsXG4gICAgICAgICAgICBcIjx0aD5SZXBvc2l0b3JpZXM8L3RoPlwiLFxuICAgICAgICAgICAgXCI8L3RyPlwiLFxuICAgICAgICAgICAgXCI8L3RoZWFkPlwiLFxuICAgICAgICAgICAgXCI8JSBfLmVhY2goY2F0ZWdvcmllcywgZnVuY3Rpb24oY2F0ZWdvcnkpIHsgJT5cIixcbiAgICAgICAgICAgIFwiPHRyPlwiLFxuICAgICAgICAgICAgXCI8dGQ+XCIsXG4gICAgICAgICAgICAnPGEgaHJlZj1cIiMvY2F0ZWdvcnkvcy88JT0gdG9vbF9zaGVkICU+L2MvPCU9IGNhdGVnb3J5LmdldChcImlkXCIpICU+XCI+PCU9IGNhdGVnb3J5LmdldChcIm5hbWVcIikgJT48L2E+JyxcbiAgICAgICAgICAgIFwiPC90ZD5cIixcbiAgICAgICAgICAgICc8dGQ+PCU9IGNhdGVnb3J5LmdldChcImRlc2NyaXB0aW9uXCIpICU+PC90ZD4nLFxuICAgICAgICAgICAgJzx0ZD48JT0gY2F0ZWdvcnkuZ2V0KFwicmVwb3NpdG9yaWVzXCIpICU+PC90ZD4nLFxuICAgICAgICAgICAgXCI8L3RyPlwiLFxuICAgICAgICAgICAgXCI8JSB9KTsgJT5cIixcbiAgICAgICAgICAgIFwiPC90YWJsZT5cIixcbiAgICAgICAgICAgIFwiPC9kaXY+XCIsXG4gICAgICAgICAgICBcIjwvZGl2PlwiXG4gICAgICAgIF0uam9pbihcIlwiKVxuICAgIClcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gICAgQ2F0ZWdvcnlWaWV3OiBUb29sU2hlZENhdGVnb3JpZXNcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gZ2FsYXh5L3NjcmlwdHMvbXZjL3Rvb2xzaGVkL2NhdGVnb3JpZXMtdmlldy5qcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTs7O0FBQUE7QUFDQTs7O0FBQUE7QUFDQTs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUEzQkE7QUE2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBbkVBO0FBQ0E7QUEyR0E7QUFDQTtBQURBO0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///308\n");

/***/ }),

/***/ 309:
/*!**********************************************************!*\
  !*** ./galaxy/scripts/mvc/toolshed/repositories-view.js ***!
  \**********************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(Backbone, _, $) {\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _toolshedModel = __webpack_require__(/*! mvc/toolshed/toolshed-model */ 17);\n\nvar _toolshedModel2 = _interopRequireDefault(_toolshedModel);\n\nvar _util = __webpack_require__(/*! mvc/toolshed/util */ 18);\n\nvar _util2 = _interopRequireDefault(_util);\n\n__webpack_require__(/*! libs/jquery/jquery-ui */ 30);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar ToolShedCategoryContentsView = Backbone.View.extend({\n    el: \"#center\",\n\n    initialize: function initialize(params) {\n        var self = this;\n        this.model = new _toolshedModel2.default.CategoryCollection();\n        this.listenTo(this.model, \"sync\", this.render);\n        var shed = params.tool_shed.replace(/\\//g, \"%2f\");\n        this.model.url += \"?tool_shed_url=\" + shed + \"&category_id=\" + params.category_id;\n        this.model.tool_shed = shed;\n        this.model.category = params.category_id;\n        this.model.fetch();\n    },\n\n    render: function render(options) {\n        this.options = _.extend(this.options, options);\n        var category_contents_template = this.templateCategoryContents;\n        this.$el.html(category_contents_template({\n            category: this.model.models[0],\n            tool_shed: this.model.tool_shed,\n            queue: _util2.default.queueLength()\n        }));\n        $(\"#center\").css(\"overflow\", \"auto\");\n        this.bindEvents();\n    },\n\n    bindEvents: function bindEvents() {\n        var that = this;\n        $(\"#search_box\").autocomplete({\n            source: function source(request, response) {\n                var shed_url = that.model.tool_shed.replace(/%2f/g, \"/\");\n                var base_url = Galaxy.root + \"api/tool_shed/search\";\n                var params = {\n                    term: request.term,\n                    tool_shed_url: shed_url\n                };\n                $.post(base_url, params, function (data) {\n                    var result_list = _util2.default.shedParser(data);\n                    response(result_list);\n                });\n            },\n            minLength: 3,\n            select: function select(event, ui) {\n                var tsr_id = ui.item.value;\n                var new_route = \"repository/s/\" + that.model.tool_shed + \"/r/\" + tsr_id;\n                Backbone.history.navigate(new_route, {\n                    trigger: true,\n                    replace: true\n                });\n            }\n        });\n    },\n\n    reDraw: function reDraw(options) {\n        this.$el.empty();\n        this.initialize(options);\n    },\n\n    templateCategoryContents: _.template(['<style type=\"text/css\">', \".ui-autocomplete { background-color: #fff; }\", \"li.ui-menu-item { list-style-type: none; }\", \"</style>\", '<div class=\"unified-panel-header\" id=\"panel_header\" unselectable=\"on\">', '<div class=\"unified-panel-header-inner\">Repositories in <%= category.get(\"name\") %></div>', '<div class=\"unified-panel-header-inner\" style=\"position: absolute; right: 5px; top: 0px;\"><a href=\"#/queue\">Repository Queue (<%= queue %>)</a></div>', \"</div>\", '<div class=\"unified-panel-body\" id=\"list_repositories\">', '<div id=\"standard-search\" style=\"height: 2em; margin: 1em;\">', '<span class=\"ui-widget\" >', '<input class=\"search-box-input\" id=\"search_box\" name=\"search\" data-shedurl=\"<%= tool_shed.replace(/%2f/g, \"/\") %>\" placeholder=\"Search repositories by name or id\" size=\"60\" type=\"text\" />', \"</span>\", \"</div>\", '<div style=\"clear: both; margin-top: 1em;\">', '<table class=\"grid\">', '<thead id=\"grid-table-header\">', \"<tr>\", '<th style=\"width: 10%;\">Owner</th>', '<th style=\"width: 15%;\">Name</th>', \"<th>Synopsis</th>\", '<th style=\"width: 10%;\">Type</th>', \"</tr>\", \"</thead>\", '<% _.each(category.get(\"repositories\"), function(repository) { %>', \"<tr>\", \"<td><%= repository.owner %></td>\", \"<td>\", '<div style=\"float: left; margin-left: 1px;\" class=\"menubutton split\">', '<a href=\"#/repository/s/<%= tool_shed %>/r/<%= repository.id %>\"><%= repository.name %></a>', \"</div>\", \"</td>\", \"<td><%= repository.description %></td>\", \"<td><%= repository.type %></td>\", \"</tr>\", \"<% }); %>\", \"</table>\", \"</div>\", \"</div>\"].join(\"\"))\n});\n\nexports.default = {\n    Category: ToolShedCategoryContentsView\n};\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! libs/backbone */ 2), __webpack_require__(/*! underscore */ 1), __webpack_require__(/*! jquery */ 0)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzA5LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL2dhbGF4eS9zY3JpcHRzL212Yy90b29sc2hlZC9yZXBvc2l0b3JpZXMtdmlldy5qcz9jZDFhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0b29sc2hlZF9tb2RlbCBmcm9tIFwibXZjL3Rvb2xzaGVkL3Rvb2xzaGVkLW1vZGVsXCI7XG5pbXBvcnQgdG9vbHNoZWRfdXRpbCBmcm9tIFwibXZjL3Rvb2xzaGVkL3V0aWxcIjtcbmltcG9ydCBcImxpYnMvanF1ZXJ5L2pxdWVyeS11aVwiO1xudmFyIFRvb2xTaGVkQ2F0ZWdvcnlDb250ZW50c1ZpZXcgPSBCYWNrYm9uZS5WaWV3LmV4dGVuZCh7XG4gICAgZWw6IFwiI2NlbnRlclwiLFxuXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdGhpcy5tb2RlbCA9IG5ldyB0b29sc2hlZF9tb2RlbC5DYXRlZ29yeUNvbGxlY3Rpb24oKTtcbiAgICAgICAgdGhpcy5saXN0ZW5Ubyh0aGlzLm1vZGVsLCBcInN5bmNcIiwgdGhpcy5yZW5kZXIpO1xuICAgICAgICB2YXIgc2hlZCA9IHBhcmFtcy50b29sX3NoZWQucmVwbGFjZSgvXFwvL2csIFwiJTJmXCIpO1xuICAgICAgICB0aGlzLm1vZGVsLnVybCArPSBgP3Rvb2xfc2hlZF91cmw9JHtzaGVkfSZjYXRlZ29yeV9pZD0ke3BhcmFtcy5jYXRlZ29yeV9pZH1gO1xuICAgICAgICB0aGlzLm1vZGVsLnRvb2xfc2hlZCA9IHNoZWQ7XG4gICAgICAgIHRoaXMubW9kZWwuY2F0ZWdvcnkgPSBwYXJhbXMuY2F0ZWdvcnlfaWQ7XG4gICAgICAgIHRoaXMubW9kZWwuZmV0Y2goKTtcbiAgICB9LFxuXG4gICAgcmVuZGVyOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IF8uZXh0ZW5kKHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG4gICAgICAgIHZhciBjYXRlZ29yeV9jb250ZW50c190ZW1wbGF0ZSA9IHRoaXMudGVtcGxhdGVDYXRlZ29yeUNvbnRlbnRzO1xuICAgICAgICB0aGlzLiRlbC5odG1sKFxuICAgICAgICAgICAgY2F0ZWdvcnlfY29udGVudHNfdGVtcGxhdGUoe1xuICAgICAgICAgICAgICAgIGNhdGVnb3J5OiB0aGlzLm1vZGVsLm1vZGVsc1swXSxcbiAgICAgICAgICAgICAgICB0b29sX3NoZWQ6IHRoaXMubW9kZWwudG9vbF9zaGVkLFxuICAgICAgICAgICAgICAgIHF1ZXVlOiB0b29sc2hlZF91dGlsLnF1ZXVlTGVuZ3RoKClcbiAgICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICAgICQoXCIjY2VudGVyXCIpLmNzcyhcIm92ZXJmbG93XCIsIFwiYXV0b1wiKTtcbiAgICAgICAgdGhpcy5iaW5kRXZlbnRzKCk7XG4gICAgfSxcblxuICAgIGJpbmRFdmVudHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgICQoXCIjc2VhcmNoX2JveFwiKS5hdXRvY29tcGxldGUoe1xuICAgICAgICAgICAgc291cmNlOiBmdW5jdGlvbihyZXF1ZXN0LCByZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIHZhciBzaGVkX3VybCA9IHRoYXQubW9kZWwudG9vbF9zaGVkLnJlcGxhY2UoLyUyZi9nLCBcIi9cIik7XG4gICAgICAgICAgICAgICAgdmFyIGJhc2VfdXJsID0gYCR7R2FsYXh5LnJvb3R9YXBpL3Rvb2xfc2hlZC9zZWFyY2hgO1xuICAgICAgICAgICAgICAgIHZhciBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgICAgIHRlcm06IHJlcXVlc3QudGVybSxcbiAgICAgICAgICAgICAgICAgICAgdG9vbF9zaGVkX3VybDogc2hlZF91cmxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICQucG9zdChiYXNlX3VybCwgcGFyYW1zLCBkYXRhID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdF9saXN0ID0gdG9vbHNoZWRfdXRpbC5zaGVkUGFyc2VyKGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZShyZXN1bHRfbGlzdCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbWluTGVuZ3RoOiAzLFxuICAgICAgICAgICAgc2VsZWN0OiBmdW5jdGlvbihldmVudCwgdWkpIHtcbiAgICAgICAgICAgICAgICB2YXIgdHNyX2lkID0gdWkuaXRlbS52YWx1ZTtcbiAgICAgICAgICAgICAgICB2YXIgbmV3X3JvdXRlID0gYHJlcG9zaXRvcnkvcy8ke3RoYXQubW9kZWwudG9vbF9zaGVkfS9yLyR7dHNyX2lkfWA7XG4gICAgICAgICAgICAgICAgQmFja2JvbmUuaGlzdG9yeS5uYXZpZ2F0ZShuZXdfcm91dGUsIHtcbiAgICAgICAgICAgICAgICAgICAgdHJpZ2dlcjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgcmVwbGFjZTogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgcmVEcmF3OiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuJGVsLmVtcHR5KCk7XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZShvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgdGVtcGxhdGVDYXRlZ29yeUNvbnRlbnRzOiBfLnRlbXBsYXRlKFxuICAgICAgICBbXG4gICAgICAgICAgICAnPHN0eWxlIHR5cGU9XCJ0ZXh0L2Nzc1wiPicsXG4gICAgICAgICAgICBcIi51aS1hdXRvY29tcGxldGUgeyBiYWNrZ3JvdW5kLWNvbG9yOiAjZmZmOyB9XCIsXG4gICAgICAgICAgICBcImxpLnVpLW1lbnUtaXRlbSB7IGxpc3Qtc3R5bGUtdHlwZTogbm9uZTsgfVwiLFxuICAgICAgICAgICAgXCI8L3N0eWxlPlwiLFxuICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJ1bmlmaWVkLXBhbmVsLWhlYWRlclwiIGlkPVwicGFuZWxfaGVhZGVyXCIgdW5zZWxlY3RhYmxlPVwib25cIj4nLFxuICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJ1bmlmaWVkLXBhbmVsLWhlYWRlci1pbm5lclwiPlJlcG9zaXRvcmllcyBpbiA8JT0gY2F0ZWdvcnkuZ2V0KFwibmFtZVwiKSAlPjwvZGl2PicsXG4gICAgICAgICAgICAnPGRpdiBjbGFzcz1cInVuaWZpZWQtcGFuZWwtaGVhZGVyLWlubmVyXCIgc3R5bGU9XCJwb3NpdGlvbjogYWJzb2x1dGU7IHJpZ2h0OiA1cHg7IHRvcDogMHB4O1wiPjxhIGhyZWY9XCIjL3F1ZXVlXCI+UmVwb3NpdG9yeSBRdWV1ZSAoPCU9IHF1ZXVlICU+KTwvYT48L2Rpdj4nLFxuICAgICAgICAgICAgXCI8L2Rpdj5cIixcbiAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwidW5pZmllZC1wYW5lbC1ib2R5XCIgaWQ9XCJsaXN0X3JlcG9zaXRvcmllc1wiPicsXG4gICAgICAgICAgICAnPGRpdiBpZD1cInN0YW5kYXJkLXNlYXJjaFwiIHN0eWxlPVwiaGVpZ2h0OiAyZW07IG1hcmdpbjogMWVtO1wiPicsXG4gICAgICAgICAgICAnPHNwYW4gY2xhc3M9XCJ1aS13aWRnZXRcIiA+JyxcbiAgICAgICAgICAgICc8aW5wdXQgY2xhc3M9XCJzZWFyY2gtYm94LWlucHV0XCIgaWQ9XCJzZWFyY2hfYm94XCIgbmFtZT1cInNlYXJjaFwiIGRhdGEtc2hlZHVybD1cIjwlPSB0b29sX3NoZWQucmVwbGFjZSgvJTJmL2csIFwiL1wiKSAlPlwiIHBsYWNlaG9sZGVyPVwiU2VhcmNoIHJlcG9zaXRvcmllcyBieSBuYW1lIG9yIGlkXCIgc2l6ZT1cIjYwXCIgdHlwZT1cInRleHRcIiAvPicsXG4gICAgICAgICAgICBcIjwvc3Bhbj5cIixcbiAgICAgICAgICAgIFwiPC9kaXY+XCIsXG4gICAgICAgICAgICAnPGRpdiBzdHlsZT1cImNsZWFyOiBib3RoOyBtYXJnaW4tdG9wOiAxZW07XCI+JyxcbiAgICAgICAgICAgICc8dGFibGUgY2xhc3M9XCJncmlkXCI+JyxcbiAgICAgICAgICAgICc8dGhlYWQgaWQ9XCJncmlkLXRhYmxlLWhlYWRlclwiPicsXG4gICAgICAgICAgICBcIjx0cj5cIixcbiAgICAgICAgICAgICc8dGggc3R5bGU9XCJ3aWR0aDogMTAlO1wiPk93bmVyPC90aD4nLFxuICAgICAgICAgICAgJzx0aCBzdHlsZT1cIndpZHRoOiAxNSU7XCI+TmFtZTwvdGg+JyxcbiAgICAgICAgICAgIFwiPHRoPlN5bm9wc2lzPC90aD5cIixcbiAgICAgICAgICAgICc8dGggc3R5bGU9XCJ3aWR0aDogMTAlO1wiPlR5cGU8L3RoPicsXG4gICAgICAgICAgICBcIjwvdHI+XCIsXG4gICAgICAgICAgICBcIjwvdGhlYWQ+XCIsXG4gICAgICAgICAgICAnPCUgXy5lYWNoKGNhdGVnb3J5LmdldChcInJlcG9zaXRvcmllc1wiKSwgZnVuY3Rpb24ocmVwb3NpdG9yeSkgeyAlPicsXG4gICAgICAgICAgICBcIjx0cj5cIixcbiAgICAgICAgICAgIFwiPHRkPjwlPSByZXBvc2l0b3J5Lm93bmVyICU+PC90ZD5cIixcbiAgICAgICAgICAgIFwiPHRkPlwiLFxuICAgICAgICAgICAgJzxkaXYgc3R5bGU9XCJmbG9hdDogbGVmdDsgbWFyZ2luLWxlZnQ6IDFweDtcIiBjbGFzcz1cIm1lbnVidXR0b24gc3BsaXRcIj4nLFxuICAgICAgICAgICAgJzxhIGhyZWY9XCIjL3JlcG9zaXRvcnkvcy88JT0gdG9vbF9zaGVkICU+L3IvPCU9IHJlcG9zaXRvcnkuaWQgJT5cIj48JT0gcmVwb3NpdG9yeS5uYW1lICU+PC9hPicsXG4gICAgICAgICAgICBcIjwvZGl2PlwiLFxuICAgICAgICAgICAgXCI8L3RkPlwiLFxuICAgICAgICAgICAgXCI8dGQ+PCU9IHJlcG9zaXRvcnkuZGVzY3JpcHRpb24gJT48L3RkPlwiLFxuICAgICAgICAgICAgXCI8dGQ+PCU9IHJlcG9zaXRvcnkudHlwZSAlPjwvdGQ+XCIsXG4gICAgICAgICAgICBcIjwvdHI+XCIsXG4gICAgICAgICAgICBcIjwlIH0pOyAlPlwiLFxuICAgICAgICAgICAgXCI8L3RhYmxlPlwiLFxuICAgICAgICAgICAgXCI8L2Rpdj5cIixcbiAgICAgICAgICAgIFwiPC9kaXY+XCJcbiAgICAgICAgXS5qb2luKFwiXCIpXG4gICAgKVxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgICBDYXRlZ29yeTogVG9vbFNoZWRDYXRlZ29yeUNvbnRlbnRzVmlld1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBnYWxheHkvc2NyaXB0cy9tdmMvdG9vbHNoZWQvcmVwb3NpdG9yaWVzLXZpZXcuanMiXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7OztBQUFBO0FBQ0E7OztBQUFBO0FBQ0E7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUhBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFyQkE7QUF1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQTVEQTtBQUNBO0FBd0dBO0FBQ0E7QUFEQTtBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///309\n");

/***/ }),

/***/ 310:
/*!********************************************************!*\
  !*** ./galaxy/scripts/mvc/toolshed/repository-view.js ***!
  \********************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(Backbone, _, $) {\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _toolshedModel = __webpack_require__(/*! mvc/toolshed/toolshed-model */ 17);\n\nvar _toolshedModel2 = _interopRequireDefault(_toolshedModel);\n\nvar _jstree = __webpack_require__(/*! libs/jquery/jstree */ 128);\n\nvar _jstree2 = _interopRequireDefault(_jstree);\n\nvar _utils = __webpack_require__(/*! utils/utils */ 4);\n\nvar _utils2 = _interopRequireDefault(_utils);\n\nvar _uiModal = __webpack_require__(/*! mvc/ui/ui-modal */ 8);\n\nvar _uiModal2 = _interopRequireDefault(_uiModal);\n\nvar _formView = __webpack_require__(/*! mvc/form/form-view */ 11);\n\nvar _formView2 = _interopRequireDefault(_formView);\n\nvar _util = __webpack_require__(/*! mvc/toolshed/util */ 18);\n\nvar _util2 = _interopRequireDefault(_util);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar ToolShedRepositoryView = Backbone.View.extend({\n    el: \"#center\",\n\n    initialize: function initialize(params) {\n        var self = this;\n        this.options = _.defaults(this.options || {}, this.defaults);\n        this.model = new _toolshedModel2.default.RepositoryCollection();\n        this.listenTo(this.model, \"sync\", this.render);\n        var shed = params.tool_shed.replace(/\\//g, \"%2f\");\n        this.model.url += \"?tool_shed_url=\" + shed + \"&repository_id=\" + params.repository_id;\n        this.model.tool_shed_url = params.tool_shed.replace(/%2f/g, \"/\");\n        this.model.tool_shed = shed;\n        this.model.category = params.repository_id;\n        this.model.fetch();\n    },\n\n    render: function render(options) {\n        var repo_details_template = this.templateRepoDetails;\n        var models = this.model.models[0];\n        this.options = {\n            repository: models.get(\"repository\"),\n            tool_shed: this.model.tool_shed,\n            queue: _util2.default.queueLength()\n        };\n        var changesets = Object.keys(this.options.repository.metadata).sort(function (a, b) {\n            return parseInt(a.split(\":\")[0] - b.split(\":\")[0]);\n        });\n        var ordered_metadata = {};\n        var unordered_metadata = this.options.repository.metadata;\n        changesets.forEach(function (key) {\n            ordered_metadata[key] = unordered_metadata[key];\n        });\n        this.options.repository.metadata = ordered_metadata;\n        this.options.current_changeset = this.options.current_changeset || changesets[changesets.length - 1];\n        this.options.current_metadata = this.options.repository.metadata[this.options.current_changeset];\n        this.options.current_metadata.tool_shed_url = this.model.tool_shed_url;\n        this.options.tools = this.options.current_metadata.tools;\n        this.options.repository_dependencies_template = this.templateRepoDependencies;\n        this.options.repository_dependency_template = this.templateRepoDependency;\n        this.options.tps_template_global_select = this.templateGlobalSectionSelect;\n        this.options.tps_template_tool_select = this.templateToolSectionSelect;\n        this.options.tps_select_options = this.templatePanelSelectOptions;\n        this.options.tool_dependencies = models.get(\"tool_dependencies\");\n        this.options.shed_tool_conf = this.templateShedToolConf({\n            shed_tool_confs: models.get(\"shed_conf\")\n        });\n        this.options.panel_section_dict = models.get(\"panel_section_dict\");\n        this.options.api_url = Galaxy.root + \"api/tool_shed_repositories/install?async=True\";\n        this.options = _.extend(this.options, options);\n        this.$el.html(repo_details_template(this.options));\n        this.checkInstalled(this.options.current_metadata);\n        this.bindEvents();\n        $(\"#center\").css(\"overflow\", \"auto\");\n    },\n\n    bindEvents: function bindEvents() {\n        var that = this;\n        $(\"#changeset\").on(\"change\", function () {\n            that.options.current_changeset = $(\"#changeset\").find(\"option:selected\").text();\n            that.options.current_metadata = that.options.repository.metadata[that.options.current_changeset];\n            that.checkInstalled(that.options.current_metadata);\n            that.reDraw(that.options);\n        });\n        $(\"#tool_panel_section_select\").on(\"change\", function () {\n            that.tpsSelection();\n        });\n        $(\"#install_repository\").on(\"click\", function (ev) {\n            var form = $(\"#repository_installation\");\n            ev.preventDefault();\n            var params = {};\n            params.repositories = JSON.stringify([[$(\"#install_repository\").attr(\"data-tsrid\"), $(\"#changeset\").find(\"option:selected\").val()]]);\n            params.tool_shed_repository_ids = JSON.stringify([$(\"#install_repository\").attr(\"data-tsrid\")]);\n            params.tool_shed_url = that.model.tool_shed_url;\n            params.install_tool_dependencies = $(\"#install_tool_dependencies\").val();\n            params.install_repository_dependencies = $(\"#install_repository_dependencies\").val();\n            params.install_resolver_dependencies = $(\"#install_resolver_dependencies\").val();\n            var tps = that.panelSelect(params);\n            params.tool_panel_section = JSON.stringify(that.panelSelect(params));\n            params.shed_tool_conf = $(\"select[name='shed_tool_conf']\").find(\"option:selected\").val();\n            params.changeset = $(\"#changeset\").find(\"option:selected\").val();\n            var url = $(\"#repository_installation\").attr(\"action\");\n            that.prepareInstall(params, url);\n        });\n        $(\"#queue_install\").on(\"click\", function (ev) {\n            that.options.current_changeset = $(\"#changeset\").find(\"option:selected\").text();\n            that.options.current_metadata = that.options.repository.metadata[that.options.current_changeset];\n            var changeset = that.options.current_changeset;\n            var repository_metadata = {};\n            _.each(Object.keys(that.options.current_metadata), function (key) {\n                if (!repository_metadata[key]) {\n                    repository_metadata[key] = that.options.current_metadata[key];\n                }\n            });\n            repository_metadata.install_tool_dependencies = $(\"#install_tool_dependencies\").val();\n            repository_metadata.install_repository_dependencies = $(\"#install_repository_dependencies\").val();\n            repository_metadata.install_resolver_dependencies = $(\"#install_resolver_dependencies\").val();\n            repository_metadata.tool_panel_section = JSON.stringify(that.panelSelect({}));\n            repository_metadata.shed_tool_conf = $(\"select[name='shed_tool_conf']\").find(\"option:selected\").val();\n            repository_metadata.tool_shed_url = that.model.tool_shed_url;\n            if (repository_metadata.tool_shed_url.substr(-1) == \"/\") {\n                repository_metadata.tool_shed_url = repository_metadata.tool_shed_url.substr(0, repository_metadata.tool_shed_url.length - 1);\n            }\n            _util2.default.addToQueue(repository_metadata);\n            that.checkInstalled(repository_metadata);\n        });\n        $(\".tool_panel_section_picker\").on(\"change\", function () {\n            var new_value = $(this).find(\"option:selected\").val();\n            var default_tps = $(\"#tool_panel_section_select\").find(\"option:selected\").val();\n            if (new_value == default_tps) {\n                $(this).attr(\"default\", \"active\");\n            } else {\n                $(this).removeAttr(\"default\");\n            }\n        });\n        $(function () {\n            $(\"#repository_dependencies\").jstree();\n        });\n        $(\".tool_form\").on(\"click\", function () {\n            var guid = $(this).attr(\"data-guid\");\n            var clean = $(this).attr(\"data-clean\");\n            var name = $(this).attr(\"data-name\");\n            var desc = $(this).attr(\"data-desc\");\n            var tool_shed_url = that.model.tool_shed_url;\n            var tsr_id = $(\"#repository_details\").attr(\"data-tsrid\");\n            var changeset = $(\"#changeset\").find(\"option:selected\").val();\n            var api_url = Galaxy.root + \"api/tool_shed/tool_json\";\n            var params = {\n                guid: guid,\n                tool_shed_url: tool_shed_url,\n                tsr_id: tsr_id,\n                changeset: changeset\n            };\n            $.get(api_url, params, function (data) {\n                data.cls = \"ui-portlet-plain\";\n                var toolform = new _formView2.default(data);\n                _utils2.default.deepeach(data.inputs, function (input) {\n                    if (input.type) {\n                        if ([\"data\", \"data_collection\"].indexOf(input.type) != -1) {\n                            input.type = \"hidden\";\n                            input.info = \"Data input '\" + input.name + \"' (\" + _utils2.default.textify(input.extensions) + \")\";\n                        }\n                    }\n                });\n                var modal = new _uiModal2.default.View();\n                var modal_title = \"<u>\" + name + \"</u> \" + desc;\n                modal.show({\n                    closing_events: true,\n                    title: modal_title,\n                    body: toolform.$el,\n                    buttons: {\n                        Close: function Close() {\n                            modal.hide();\n                        }\n                    }\n                });\n            });\n        });\n    },\n\n    checkInstalled: function checkInstalled(metadata) {\n        var that = this;\n        var params = { name: metadata.name, owner: metadata.owner };\n        var already_installed = false;\n        var queued = that.repoQueued(metadata);\n        $.get(Galaxy.root + \"api/tool_shed_repositories\", params, function (data) {\n            for (var index = 0; index < data.length; index++) {\n                var repository = data[index];\n                var installed = !repository.deleted && !repository.uninstalled;\n                var changeset_match = repository.changeset_revision == metadata.changeset_revision || repository.installed_changeset_revision == metadata.changeset_revision;\n                if (repository.name == metadata.repository.name && repository.owner == metadata.repository.owner && installed && changeset_match) {\n                    already_installed = true;\n                }\n                if (already_installed) {\n                    $(\"#install_repository\").prop(\"disabled\", true);\n                    $(\"#install_repository\").val(\"This revision is already installed\");\n                } else {\n                    $(\"#install_repository\").prop(\"disabled\", false);\n                    $(\"#install_repository\").val(\"Install this revision\");\n                }\n            }\n            if (that.repoQueued(metadata) || already_installed) {\n                $(\"#queue_install\").hide();\n                $(\"#queue_install\").val(\"This revision is already in the queue\");\n            } else {\n                $(\"#queue_install\").show();\n                $(\"#queue_install\").val(\"Install this revision later\");\n            }\n        });\n    },\n\n    panelSelect: function panelSelect(params) {\n        var tool_panel_section = {};\n        if ($(\"#tool_panel_section_select\").length) {\n            params.tool_panel_section_id = $(\"#tool_panel_section_select\").find(\"option:selected\").val();\n        } else {\n            params.new_tool_panel_section = $(\"#new_tool_panel_section\").val();\n        }\n        $(\".tool_panel_section_picker\").each(function () {\n            var element_name = $(this).attr(\"name\");\n            var tool_guid = $(this).attr(\"data-toolguid\");\n            if (element_name === \"tool_panel_section_id\") {\n                tool_panel_section[tool_guid] = {\n                    tool_panel_section: $(this).find(\"option:selected\").val(),\n                    action: \"append\"\n                };\n            } else {\n                tool_panel_section[tool_guid] = {\n                    tool_panel_section: $(this).val(),\n                    action: \"create\"\n                };\n            }\n        });\n        return tool_panel_section;\n    },\n\n    reDraw: function reDraw(options) {\n        this.$el.empty();\n        this.render(options);\n    },\n\n    repoQueued: function repoQueued(metadata) {\n        var that = this;\n        if (!localStorage.repositories) {\n            return;\n        }\n        var queue_key = that.queueKey(metadata);\n        var queued_repos;\n        if (localStorage.repositories) {\n            queued_repos = JSON.parse(localStorage.repositories);\n        }\n        if (queued_repos && queued_repos.hasOwnProperty(queue_key)) {\n            return true;\n        }\n        return false;\n    },\n\n    queueKey: function queueKey(metadata) {\n        var shed_url = this.model.tool_shed_url;\n        // Make sure there is never a trailing slash on the shed URL.\n        if (shed_url.substr(-1) == \"/\") {\n            shed_url = shed_url.substr(0, shed_url.length - 1);\n        }\n        return shed_url + \"|\" + metadata.repository_id + \"|\" + metadata.changeset_revision;\n    },\n\n    tpsSelection: function tpsSelection() {\n        new_tps = $(\"#tool_panel_section_select\").find(\"option:selected\").val();\n        $('.tool_panel_section_picker[default=\"active\"]').each(function () {\n            $(this).val(new_tps);\n        });\n    },\n\n    prepareInstall: function prepareInstall(params, api_url) {\n        var that = this;\n        $.post(api_url, params, function (data) {\n            var iri_parameters = JSON.parse(data);\n            that.doInstall(iri_parameters);\n        });\n    },\n\n    doInstall: function doInstall(params) {\n        var controller_url = Galaxy.root + \"admin_toolshed/install_repositories\";\n        var repositories = params.repositories;\n        var new_route = \"status/r/\" + repositories.join(\"|\");\n        $.post(controller_url, params, function (data) {\n            console.log(\"Initializing repository installation succeeded\");\n        });\n        Backbone.history.navigate(new_route, {\n            trigger: true,\n            replace: true\n        });\n    },\n\n    templateRepoDetails: _.template(['<div class=\"unified-panel-header\" id=\"panel_header\" unselectable=\"on\">', '<div class=\"unified-panel-header-inner\">Repository information for <strong><%= repository.name %></strong> from <strong><%= repository.owner %></strong></div>', '<div class=\"unified-panel-header-inner\" style=\"position: absolute; right: 5px; top: 0px;\"><a href=\"#/queue\">Repository Queue (<%= queue %>)</a></div>', \"</div>\", '<div class=\"unified-panel-body\" id=\"repository_details\" data-tsrid=\"<%= repository.id %>\">', '<form id=\"repository_installation\" name=\"install_repository\" method=\"post\" action=\"<%= api_url %>\">', '<input type=\"hidden\" id=\"repositories\" name=\"<%= repository.id %>\" value=\"ID\" />', '<input type=\"hidden\" id=\"tool_shed_url\" name=\"tool_shed_url\" value=\"<%= tool_shed %>\" />', '<div class=\"toolForm\">', '<div class=\"toolFormTitle\">Changeset</div>', '<div class=\"toolFormBody changeset\">', '<select id=\"changeset\" name=\"changeset\" style=\"margin: 5px;\">', \"<% _.each(Object.keys(repository.metadata), function(changeset) { %>\", '<% if (changeset == current_changeset) { var selected = \"selected \"; } else { var selected = \"\"; } %>', '<option <%= selected %>value=\"<%= changeset.split(\":\")[1] %>\"><%= changeset %></option>', \"<% }); %>\", \"</select>\", '<input class=\"btn btn-primary preview-button\" data-tsrid=\"<%= current_metadata.repository.id %>\" type=\"submit\" id=\"install_repository\" name=\"install_repository\" value=\"Install this revision now\" />', '<input class=\"btn btn-primary preview-button\" type=\"button\" id=\"queue_install\" name=\"queue_install\" value=\"Install this revision later\" />', '<div class=\"toolParamHelp\" style=\"clear: both;\">Please select a revision and review the settings below before installing.</div>', \"</div>\", \"</div>\", \"<%= shed_tool_conf %>\", \"<% if (current_metadata.has_repository_dependencies) { %>\", '<div class=\"toolFormTitle\">Repository dependencies for <strong id=\"current_changeset\"><%= current_changeset %></strong></div>', '<div class=\"toolFormBody\">', '<p id=\"install_repository_dependencies_checkbox\">', '<input type=\"checkbox\" checked id=\"install_repository_dependencies\" />', '<label for=\"install_repository_dependencies\">Install repository dependencies</label>', \"</p>\", \"<% current_metadata.repository_dependency_template = repository_dependency_template; %>\", '<div class=\"tables container-table\" id=\"repository_dependencies\">', '<div class=\"expandLink\">', '<a class=\"toggle_folder\" data_target=\"repository_dependencies_table\">', \"Repository dependencies &ndash; <em>installation of these additional repositories is required</em>\", \"</a>\", \"</div>\", \"<%= repository_dependencies_template(current_metadata) %>\", \"</div>\", \"</div>\", \"<% } %>\", \"<% if (current_metadata.includes_tool_dependencies) { %>\", '<div class=\"toolFormTitle\">Tool dependencies</div>', '<div class=\"toolFormBody\">', '<p id=\"install_resolver_dependencies_checkbox\">', '<input type=\"checkbox\" checked id=\"install_resolver_dependencies\" />', '<label for=\"install_resolver_dependencies\">Install resolver dependencies</label>', \"</p>\", '<p id=\"install_tool_dependencies_checkbox\">', '<input type=\"checkbox\" checked id=\"install_tool_dependencies\" />', '<label for=\"install_tool_dependencies\">Install tool dependencies</label>', \"</p>\", '<div class=\"tables container-table\" id=\"tool_dependencies\">', '<div class=\"expandLink\">', '<a class=\"toggle_folder\" data_target=\"tool_dependencies_table\">', \"Tool dependencies &ndash; <em>repository tools require handling of these dependencies</em>\", \"</a>\", \"</div>\", '<table class=\"tables container-table\" id=\"tool_dependencies_table\" border=\"0\" cellpadding=\"2\" cellspacing=\"2\" width=\"100%\">', \"<thead>\", '<tr style=\"display: table-row;\" class=\"datasetRow\" parent=\"0\" id=\"libraryItem-rt-f9cad7b01a472135\">', '<th style=\"padding-left: 40px;\">Name</th>', \"<th>Version</th>\", \"<th>Type</th>\", \"</tr>\", \"</thead>\", '<tbody id=\"tool_deps\">', \"<% _.each(tool_dependencies[current_changeset], function(dependency) { %>\", '<tr class=\"datasetRow tool_dependency_row\" style=\"display: table-row;\">', '<td style=\"padding-left: 40px;\">', \"<%= dependency.name %></td>\", \"<td><%= dependency.version %></td>\", \"<td><%= dependency.type %></td>\", \"</tr>\", \"<% }); %>\", \"</tbody>\", \"</table>\", \"</div>\", \"</div>\", \"<% } %>\", \"<% if (current_metadata.includes_tools_for_display_in_tool_panel) { %>\", '<div class=\"toolFormTitle\">Tools &ndash; <em>click the name to preview the tool and use the pop-up menu to inspect all metadata</em></div>', '<div class=\"toolFormBody\">', '<div class=\"tables container-table\" id=\"tools_toggle\">', '<table class=\"tables container-table\" id=\"valid_tools\" border=\"0\" cellpadding=\"2\" cellspacing=\"2\" width=\"100%\">', \"<thead>\", '<tr style=\"display: table-row;\" class=\"datasetRow\" parent=\"0\" id=\"libraryItem-rt-f9cad7b01a472135\">', '<th style=\"padding-left: 40px;\">Name</th>', \"<th>Description</th>\", \"<th>Version</th>\", \"<th><%= tps_template_global_select({tps: panel_section_dict, tps_select_options: tps_select_options}) %></tr>\", \"</thead>\", '<tbody id=\"tools_in_repo\">', \"<% _.each(current_metadata.tools, function(tool) { %>\", '<tr id=\"libraryItem-<%= tool.clean %>\" class=\"tool_row\" style=\"display: table-row;\" style=\"width: 15%\">', '<td style=\"padding-left: 40px;\">', '<div id=\"tool-<%= tool.clean %>\" class=\"menubutton split popup\" style=\"float: left;\">', '<a class=\"tool_form view-info\" data-toggle=\"modal\" data-target=\"toolform_<%= tool.clean %>\" data-clean=\"<%= tool.clean %>\" data-guid=\"<%= tool.guid %>\" data-name=\"<%= tool.name %>\" data-desc=\"<%= tool.description %>\"><%= tool.name %></a>', \"</div>\", \"</td>\", \"<td><%= tool.description %></td>\", '<td style=\"width: 15%\"><%= tool.version %></td>', '<td style=\"width: 35%\" id=\"tool_tps_<%= tool.clean %>\">', \"<%= tps_template_tool_select({tool: tool, tps: panel_section_dict, tps_select_options: tps_select_options}) %>\", \"</td>\", \"</tr>\", \"<% }); %>\", \"</tbody>\", \"</table>\", \"</div>\", \"</div>\", \"<% } %>\", \"</form>\", \"</div>\"].join(\"\")),\n\n    templateRepoDependencies: _.template(['<div class=\"toolFormTitle\">Repository Dependencies</div>', '<div class=\"toolFormBody tables container-table\" id=\"repository_dependencies\">', \"<ul>\", \"<li>Repository installation requires the following\", \"<% if (has_repository_dependencies) { %>\", \"<% _.each(repository_dependencies, function(dependency) { %>\", \"<% dependency.repository_dependency_template = repository_dependency_template; %>\", \"<%= repository_dependency_template(dependency) %>\", \"<% }); %>\", \"<% } %>\", \"</li>\", \"</ul>\", \"</div>\"].join(\"\")),\n\n    templateRepoDependency: _.template(['<li id=\"metadata_<%= id %>\" class=\"datasetRow repository_dependency_row\">', \"Repository <b><%= repository.name %></b> revision <b><%= changeset_revision %></b> owned by <b><%= repository.owner %></b>\", \"<% if (has_repository_dependencies) { %>\", '<ul class=\"child_dependencies\">', \"<% _.each(repository_dependencies, function(dependency) { %>\", \"<% dependency.repository_dependency_template = repository_dependency_template; %>\", \"<%= repository_dependency_template(dependency) %>\", \"<% }); %>\", \"</ul>\", \"<% } %>\", \"</li>\"].join(\"\")),\n\n    templateShedToolConf: _.template(['<div class=\"toolFormTitle\">Shed tool configuration file:</div>', '<div class=\"toolFormBody\">', '<div class=\"form-row\">', '<select name=\"shed_tool_conf\">', \"<% _.each(shed_tool_confs.options, function(conf) { %>\", '<option value=\"<%= conf.value %>\"><%= conf.label %></option>', \"<% }); %>\", '</select>', '<div class=\"toolParamHelp\" style=\"clear: both;\">Select the file whose <b>tool_path</b> setting you want used for installing repositories.</div>', \"</div>\", \"</div>\"].join(\"\")),\n\n    templateToolDependency: _.template([\"<% if (has_repository_dependencies) { %>\", \"<% _.each(repository_dependencies, function(dependency) { %>\", \"<% if (dependency.includes_tool_dependencies) { %>\", \"<% dependency.tool_dependency_template = tool_dependency_template %>\", \"<%= tool_dependency_template(dependency) %>\", \"<% } %>\", \"<% }); %>\", \"<% } %>\"].join(\"\")),\n\n    templateGlobalSectionCreate: _.template(['<div id=\"tool_panel_section\">', '<div class=\"form-row\" id=\"new_tps\">', '<input id=\"new_tool_panel_section\" name=\"new_tool_panel_section\" type=\"textfield\" value=\"\" size=\"40\"/>', '<input class=\"btn btn-primary\" type=\"button\" id=\"select_existing\" value=\"Select existing\" />', '<div class=\"toolParamHelp\" style=\"clear: both;\">', \"Add a new tool panel section to contain the installed tools (optional).\", \"</div>\", \"</div>\", \"</div>\"].join(\"\")),\n\n    templateGlobalSectionSelect: _.template(['<div id=\"tool_panel_section\">', '<div class=\"toolFormTitle\">Tool Panel Section</div>', '<div class=\"toolFormBody\">', '<div class=\"tab-pane\" id=\"select_tps\">', '<select name=\"<%= name %>\" id=\"<%= tps.id %>\">', \"<%= tps_select_options({sections: tps.sections}) %>\", \"</select>\", '<input class=\"btn btn-primary\" type=\"button\" id=\"create_new\" value=\"Create new\" />', '<div class=\"toolParamHelp\" style=\"clear: both;\">', \"Select an existing tool panel section to contain the installed tools (optional).\", \"</div>\", \"</div>\", \"</div>\", \"</div>\"].join(\"\")),\n\n    templateToolSectionCreate: _.template(['<div id=\"new_tps_<%= tool.clean %>\" data-clean=\"<%= tool.clean %>\" class=\"form-row\">', '<input data-toolguid=\"<%= tool.guid %>\" class=\"tool_panel_section_picker\" size=\"40\" name=\"new_tool_panel_section\" id=\"new_tool_panel_section_<%= tool.clean %>\" type=\"text\">', '<input id=\"per_tool_select_<%= tool.clean %>\" class=\"btn btn-primary\" data-toolguid=\"<%= tool.guid %>\" value=\"Select existing\" id=\"select_existing_<%= tool.clean %>\" type=\"button\">', \"</div>\"].join(\"\")),\n\n    templateToolSectionSelect: _.template(['<div id=\"select_tps_<%= tool.clean %>\" data-clean=\"<%= tool.clean %>\" class=\"tps_creator\">', '<select default=\"active\" style=\"width: 30em;\" data-toolguid=\"<%= tool.guid %>\" class=\"tool_panel_section_picker\" name=\"tool_panel_section_id\" id=\"tool_panel_section_select_<%= tool.clean %>\">', \"<%= tps_select_options({sections: tps.sections}) %>\", \"</select>\", '<input id=\"per_tool_create_<%= tool.clean %>\" data-clean=\"<%= tool.clean %>\" class=\"btn btn-primary create-tps-button\" data-toolguid=\"<%= tool.guid %>\" value=\"Create new\" id=\"create_new_<%= tool.clean %>\" type=\"button\">', '<div style=\"clear: both;\" class=\"toolParamHelp\"></div>', \"</div>\"].join(\"\")),\n\n    templatePanelSelectOptions: _.template([\"<% _.each(sections, function(section) { %>\", '<option value=\"<%= section.id %>\"><%= section.name %></option>', \"<% }); %>\"].join(\"\"))\n});\n\nexports.default = {\n    RepoDetails: ToolShedRepositoryView\n};\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! libs/backbone */ 2), __webpack_require__(/*! underscore */ 1), __webpack_require__(/*! jquery */ 0)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzEwLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL2dhbGF4eS9zY3JpcHRzL212Yy90b29sc2hlZC9yZXBvc2l0b3J5LXZpZXcuanM/OTczYiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdG9vbHNoZWRfbW9kZWwgZnJvbSBcIm12Yy90b29sc2hlZC90b29sc2hlZC1tb2RlbFwiO1xuaW1wb3J0IGpzdHJlZSBmcm9tIFwibGlicy9qcXVlcnkvanN0cmVlXCI7XG5pbXBvcnQgVXRpbHMgZnJvbSBcInV0aWxzL3V0aWxzXCI7XG5pbXBvcnQgTW9kYWwgZnJvbSBcIm12Yy91aS91aS1tb2RhbFwiO1xuaW1wb3J0IEZvcm1WaWV3IGZyb20gXCJtdmMvZm9ybS9mb3JtLXZpZXdcIjtcbmltcG9ydCB0b29sc2hlZF91dGlsIGZyb20gXCJtdmMvdG9vbHNoZWQvdXRpbFwiO1xudmFyIFRvb2xTaGVkUmVwb3NpdG9yeVZpZXcgPSBCYWNrYm9uZS5WaWV3LmV4dGVuZCh7XG4gICAgZWw6IFwiI2NlbnRlclwiLFxuXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdGhpcy5vcHRpb25zID0gXy5kZWZhdWx0cyh0aGlzLm9wdGlvbnMgfHwge30sIHRoaXMuZGVmYXVsdHMpO1xuICAgICAgICB0aGlzLm1vZGVsID0gbmV3IHRvb2xzaGVkX21vZGVsLlJlcG9zaXRvcnlDb2xsZWN0aW9uKCk7XG4gICAgICAgIHRoaXMubGlzdGVuVG8odGhpcy5tb2RlbCwgXCJzeW5jXCIsIHRoaXMucmVuZGVyKTtcbiAgICAgICAgdmFyIHNoZWQgPSBwYXJhbXMudG9vbF9zaGVkLnJlcGxhY2UoL1xcLy9nLCBcIiUyZlwiKTtcbiAgICAgICAgdGhpcy5tb2RlbC51cmwgKz0gYD90b29sX3NoZWRfdXJsPSR7c2hlZH0mcmVwb3NpdG9yeV9pZD0ke3BhcmFtcy5yZXBvc2l0b3J5X2lkfWA7XG4gICAgICAgIHRoaXMubW9kZWwudG9vbF9zaGVkX3VybCA9IHBhcmFtcy50b29sX3NoZWQucmVwbGFjZSgvJTJmL2csIFwiL1wiKTtcbiAgICAgICAgdGhpcy5tb2RlbC50b29sX3NoZWQgPSBzaGVkO1xuICAgICAgICB0aGlzLm1vZGVsLmNhdGVnb3J5ID0gcGFyYW1zLnJlcG9zaXRvcnlfaWQ7XG4gICAgICAgIHRoaXMubW9kZWwuZmV0Y2goKTtcbiAgICB9LFxuXG4gICAgcmVuZGVyOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHZhciByZXBvX2RldGFpbHNfdGVtcGxhdGUgPSB0aGlzLnRlbXBsYXRlUmVwb0RldGFpbHM7XG4gICAgICAgIHZhciBtb2RlbHMgPSB0aGlzLm1vZGVsLm1vZGVsc1swXTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0ge1xuICAgICAgICAgICAgcmVwb3NpdG9yeTogbW9kZWxzLmdldChcInJlcG9zaXRvcnlcIiksXG4gICAgICAgICAgICB0b29sX3NoZWQ6IHRoaXMubW9kZWwudG9vbF9zaGVkLFxuICAgICAgICAgICAgcXVldWU6IHRvb2xzaGVkX3V0aWwucXVldWVMZW5ndGgoKVxuICAgICAgICB9O1xuICAgICAgICB2YXIgY2hhbmdlc2V0cyA9IE9iamVjdC5rZXlzKHRoaXMub3B0aW9ucy5yZXBvc2l0b3J5Lm1ldGFkYXRhKS5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUludChhLnNwbGl0KFwiOlwiKVswXSAtIGIuc3BsaXQoXCI6XCIpWzBdKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBvcmRlcmVkX21ldGFkYXRhID0ge307XG4gICAgICAgIHZhciB1bm9yZGVyZWRfbWV0YWRhdGEgPSB0aGlzLm9wdGlvbnMucmVwb3NpdG9yeS5tZXRhZGF0YTtcbiAgICAgICAgY2hhbmdlc2V0cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgb3JkZXJlZF9tZXRhZGF0YVtrZXldID0gdW5vcmRlcmVkX21ldGFkYXRhW2tleV07XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm9wdGlvbnMucmVwb3NpdG9yeS5tZXRhZGF0YSA9IG9yZGVyZWRfbWV0YWRhdGE7XG4gICAgICAgIHRoaXMub3B0aW9ucy5jdXJyZW50X2NoYW5nZXNldCA9IHRoaXMub3B0aW9ucy5jdXJyZW50X2NoYW5nZXNldCB8fCBjaGFuZ2VzZXRzW2NoYW5nZXNldHMubGVuZ3RoIC0gMV07XG4gICAgICAgIHRoaXMub3B0aW9ucy5jdXJyZW50X21ldGFkYXRhID0gdGhpcy5vcHRpb25zLnJlcG9zaXRvcnkubWV0YWRhdGFbdGhpcy5vcHRpb25zLmN1cnJlbnRfY2hhbmdlc2V0XTtcbiAgICAgICAgdGhpcy5vcHRpb25zLmN1cnJlbnRfbWV0YWRhdGEudG9vbF9zaGVkX3VybCA9IHRoaXMubW9kZWwudG9vbF9zaGVkX3VybDtcbiAgICAgICAgdGhpcy5vcHRpb25zLnRvb2xzID0gdGhpcy5vcHRpb25zLmN1cnJlbnRfbWV0YWRhdGEudG9vbHM7XG4gICAgICAgIHRoaXMub3B0aW9ucy5yZXBvc2l0b3J5X2RlcGVuZGVuY2llc190ZW1wbGF0ZSA9IHRoaXMudGVtcGxhdGVSZXBvRGVwZW5kZW5jaWVzO1xuICAgICAgICB0aGlzLm9wdGlvbnMucmVwb3NpdG9yeV9kZXBlbmRlbmN5X3RlbXBsYXRlID0gdGhpcy50ZW1wbGF0ZVJlcG9EZXBlbmRlbmN5O1xuICAgICAgICB0aGlzLm9wdGlvbnMudHBzX3RlbXBsYXRlX2dsb2JhbF9zZWxlY3QgPSB0aGlzLnRlbXBsYXRlR2xvYmFsU2VjdGlvblNlbGVjdDtcbiAgICAgICAgdGhpcy5vcHRpb25zLnRwc190ZW1wbGF0ZV90b29sX3NlbGVjdCA9IHRoaXMudGVtcGxhdGVUb29sU2VjdGlvblNlbGVjdDtcbiAgICAgICAgdGhpcy5vcHRpb25zLnRwc19zZWxlY3Rfb3B0aW9ucyA9IHRoaXMudGVtcGxhdGVQYW5lbFNlbGVjdE9wdGlvbnM7XG4gICAgICAgIHRoaXMub3B0aW9ucy50b29sX2RlcGVuZGVuY2llcyA9IG1vZGVscy5nZXQoXCJ0b29sX2RlcGVuZGVuY2llc1wiKTtcbiAgICAgICAgdGhpcy5vcHRpb25zLnNoZWRfdG9vbF9jb25mID0gdGhpcy50ZW1wbGF0ZVNoZWRUb29sQ29uZih7XG4gICAgICAgICAgICBzaGVkX3Rvb2xfY29uZnM6IG1vZGVscy5nZXQoXCJzaGVkX2NvbmZcIilcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMub3B0aW9ucy5wYW5lbF9zZWN0aW9uX2RpY3QgPSBtb2RlbHMuZ2V0KFwicGFuZWxfc2VjdGlvbl9kaWN0XCIpO1xuICAgICAgICB0aGlzLm9wdGlvbnMuYXBpX3VybCA9IGAke0dhbGF4eS5yb290fWFwaS90b29sX3NoZWRfcmVwb3NpdG9yaWVzL2luc3RhbGw/YXN5bmM9VHJ1ZWA7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IF8uZXh0ZW5kKHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuJGVsLmh0bWwocmVwb19kZXRhaWxzX3RlbXBsYXRlKHRoaXMub3B0aW9ucykpO1xuICAgICAgICB0aGlzLmNoZWNrSW5zdGFsbGVkKHRoaXMub3B0aW9ucy5jdXJyZW50X21ldGFkYXRhKTtcbiAgICAgICAgdGhpcy5iaW5kRXZlbnRzKCk7XG4gICAgICAgICQoXCIjY2VudGVyXCIpLmNzcyhcIm92ZXJmbG93XCIsIFwiYXV0b1wiKTtcbiAgICB9LFxuXG4gICAgYmluZEV2ZW50czogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgJChcIiNjaGFuZ2VzZXRcIikub24oXCJjaGFuZ2VcIiwgKCkgPT4ge1xuICAgICAgICAgICAgdGhhdC5vcHRpb25zLmN1cnJlbnRfY2hhbmdlc2V0ID0gJChcIiNjaGFuZ2VzZXRcIilcbiAgICAgICAgICAgICAgICAuZmluZChcIm9wdGlvbjpzZWxlY3RlZFwiKVxuICAgICAgICAgICAgICAgIC50ZXh0KCk7XG4gICAgICAgICAgICB0aGF0Lm9wdGlvbnMuY3VycmVudF9tZXRhZGF0YSA9IHRoYXQub3B0aW9ucy5yZXBvc2l0b3J5Lm1ldGFkYXRhW3RoYXQub3B0aW9ucy5jdXJyZW50X2NoYW5nZXNldF07XG4gICAgICAgICAgICB0aGF0LmNoZWNrSW5zdGFsbGVkKHRoYXQub3B0aW9ucy5jdXJyZW50X21ldGFkYXRhKTtcbiAgICAgICAgICAgIHRoYXQucmVEcmF3KHRoYXQub3B0aW9ucyk7XG4gICAgICAgIH0pO1xuICAgICAgICAkKFwiI3Rvb2xfcGFuZWxfc2VjdGlvbl9zZWxlY3RcIikub24oXCJjaGFuZ2VcIiwgKCkgPT4ge1xuICAgICAgICAgICAgdGhhdC50cHNTZWxlY3Rpb24oKTtcbiAgICAgICAgfSk7XG4gICAgICAgICQoXCIjaW5zdGFsbF9yZXBvc2l0b3J5XCIpLm9uKFwiY2xpY2tcIiwgZXYgPT4ge1xuICAgICAgICAgICAgdmFyIGZvcm0gPSAkKFwiI3JlcG9zaXRvcnlfaW5zdGFsbGF0aW9uXCIpO1xuICAgICAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHZhciBwYXJhbXMgPSB7fTtcbiAgICAgICAgICAgIHBhcmFtcy5yZXBvc2l0b3JpZXMgPSBKU09OLnN0cmluZ2lmeShbXG4gICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICAkKFwiI2luc3RhbGxfcmVwb3NpdG9yeVwiKS5hdHRyKFwiZGF0YS10c3JpZFwiKSxcbiAgICAgICAgICAgICAgICAgICAgJChcIiNjaGFuZ2VzZXRcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIC5maW5kKFwib3B0aW9uOnNlbGVjdGVkXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAudmFsKClcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIHBhcmFtcy50b29sX3NoZWRfcmVwb3NpdG9yeV9pZHMgPSBKU09OLnN0cmluZ2lmeShbJChcIiNpbnN0YWxsX3JlcG9zaXRvcnlcIikuYXR0cihcImRhdGEtdHNyaWRcIildKTtcbiAgICAgICAgICAgIHBhcmFtcy50b29sX3NoZWRfdXJsID0gdGhhdC5tb2RlbC50b29sX3NoZWRfdXJsO1xuICAgICAgICAgICAgcGFyYW1zLmluc3RhbGxfdG9vbF9kZXBlbmRlbmNpZXMgPSAkKFwiI2luc3RhbGxfdG9vbF9kZXBlbmRlbmNpZXNcIikudmFsKCk7XG4gICAgICAgICAgICBwYXJhbXMuaW5zdGFsbF9yZXBvc2l0b3J5X2RlcGVuZGVuY2llcyA9ICQoXCIjaW5zdGFsbF9yZXBvc2l0b3J5X2RlcGVuZGVuY2llc1wiKS52YWwoKTtcbiAgICAgICAgICAgIHBhcmFtcy5pbnN0YWxsX3Jlc29sdmVyX2RlcGVuZGVuY2llcyA9ICQoXCIjaW5zdGFsbF9yZXNvbHZlcl9kZXBlbmRlbmNpZXNcIikudmFsKCk7XG4gICAgICAgICAgICB2YXIgdHBzID0gdGhhdC5wYW5lbFNlbGVjdChwYXJhbXMpO1xuICAgICAgICAgICAgcGFyYW1zLnRvb2xfcGFuZWxfc2VjdGlvbiA9IEpTT04uc3RyaW5naWZ5KHRoYXQucGFuZWxTZWxlY3QocGFyYW1zKSk7XG4gICAgICAgICAgICBwYXJhbXMuc2hlZF90b29sX2NvbmYgPSAkKFwic2VsZWN0W25hbWU9J3NoZWRfdG9vbF9jb25mJ11cIilcbiAgICAgICAgICAgICAgICAuZmluZChcIm9wdGlvbjpzZWxlY3RlZFwiKVxuICAgICAgICAgICAgICAgIC52YWwoKTtcbiAgICAgICAgICAgIHBhcmFtcy5jaGFuZ2VzZXQgPSAkKFwiI2NoYW5nZXNldFwiKVxuICAgICAgICAgICAgICAgIC5maW5kKFwib3B0aW9uOnNlbGVjdGVkXCIpXG4gICAgICAgICAgICAgICAgLnZhbCgpO1xuICAgICAgICAgICAgdmFyIHVybCA9ICQoXCIjcmVwb3NpdG9yeV9pbnN0YWxsYXRpb25cIikuYXR0cihcImFjdGlvblwiKTtcbiAgICAgICAgICAgIHRoYXQucHJlcGFyZUluc3RhbGwocGFyYW1zLCB1cmwpO1xuICAgICAgICB9KTtcbiAgICAgICAgJChcIiNxdWV1ZV9pbnN0YWxsXCIpLm9uKFwiY2xpY2tcIiwgZXYgPT4ge1xuICAgICAgICAgICAgdGhhdC5vcHRpb25zLmN1cnJlbnRfY2hhbmdlc2V0ID0gJChcIiNjaGFuZ2VzZXRcIilcbiAgICAgICAgICAgICAgICAuZmluZChcIm9wdGlvbjpzZWxlY3RlZFwiKVxuICAgICAgICAgICAgICAgIC50ZXh0KCk7XG4gICAgICAgICAgICB0aGF0Lm9wdGlvbnMuY3VycmVudF9tZXRhZGF0YSA9IHRoYXQub3B0aW9ucy5yZXBvc2l0b3J5Lm1ldGFkYXRhW3RoYXQub3B0aW9ucy5jdXJyZW50X2NoYW5nZXNldF07XG4gICAgICAgICAgICB2YXIgY2hhbmdlc2V0ID0gdGhhdC5vcHRpb25zLmN1cnJlbnRfY2hhbmdlc2V0O1xuICAgICAgICAgICAgdmFyIHJlcG9zaXRvcnlfbWV0YWRhdGEgPSB7fTtcbiAgICAgICAgICAgIF8uZWFjaChPYmplY3Qua2V5cyh0aGF0Lm9wdGlvbnMuY3VycmVudF9tZXRhZGF0YSksIGtleSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFyZXBvc2l0b3J5X21ldGFkYXRhW2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmVwb3NpdG9yeV9tZXRhZGF0YVtrZXldID0gdGhhdC5vcHRpb25zLmN1cnJlbnRfbWV0YWRhdGFba2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJlcG9zaXRvcnlfbWV0YWRhdGEuaW5zdGFsbF90b29sX2RlcGVuZGVuY2llcyA9ICQoXCIjaW5zdGFsbF90b29sX2RlcGVuZGVuY2llc1wiKS52YWwoKTtcbiAgICAgICAgICAgIHJlcG9zaXRvcnlfbWV0YWRhdGEuaW5zdGFsbF9yZXBvc2l0b3J5X2RlcGVuZGVuY2llcyA9ICQoXCIjaW5zdGFsbF9yZXBvc2l0b3J5X2RlcGVuZGVuY2llc1wiKS52YWwoKTtcbiAgICAgICAgICAgIHJlcG9zaXRvcnlfbWV0YWRhdGEuaW5zdGFsbF9yZXNvbHZlcl9kZXBlbmRlbmNpZXMgPSAkKFwiI2luc3RhbGxfcmVzb2x2ZXJfZGVwZW5kZW5jaWVzXCIpLnZhbCgpO1xuICAgICAgICAgICAgcmVwb3NpdG9yeV9tZXRhZGF0YS50b29sX3BhbmVsX3NlY3Rpb24gPSBKU09OLnN0cmluZ2lmeSh0aGF0LnBhbmVsU2VsZWN0KHt9KSk7XG4gICAgICAgICAgICByZXBvc2l0b3J5X21ldGFkYXRhLnNoZWRfdG9vbF9jb25mID0gJChcInNlbGVjdFtuYW1lPSdzaGVkX3Rvb2xfY29uZiddXCIpXG4gICAgICAgICAgICAgICAgLmZpbmQoXCJvcHRpb246c2VsZWN0ZWRcIilcbiAgICAgICAgICAgICAgICAudmFsKCk7XG4gICAgICAgICAgICByZXBvc2l0b3J5X21ldGFkYXRhLnRvb2xfc2hlZF91cmwgPSB0aGF0Lm1vZGVsLnRvb2xfc2hlZF91cmw7XG4gICAgICAgICAgICBpZiAocmVwb3NpdG9yeV9tZXRhZGF0YS50b29sX3NoZWRfdXJsLnN1YnN0cigtMSkgPT0gXCIvXCIpIHtcbiAgICAgICAgICAgICAgICByZXBvc2l0b3J5X21ldGFkYXRhLnRvb2xfc2hlZF91cmwgPSByZXBvc2l0b3J5X21ldGFkYXRhLnRvb2xfc2hlZF91cmwuc3Vic3RyKFxuICAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgICByZXBvc2l0b3J5X21ldGFkYXRhLnRvb2xfc2hlZF91cmwubGVuZ3RoIC0gMVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0b29sc2hlZF91dGlsLmFkZFRvUXVldWUocmVwb3NpdG9yeV9tZXRhZGF0YSk7XG4gICAgICAgICAgICB0aGF0LmNoZWNrSW5zdGFsbGVkKHJlcG9zaXRvcnlfbWV0YWRhdGEpO1xuICAgICAgICB9KTtcbiAgICAgICAgJChcIi50b29sX3BhbmVsX3NlY3Rpb25fcGlja2VyXCIpLm9uKFwiY2hhbmdlXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIG5ld192YWx1ZSA9ICQodGhpcylcbiAgICAgICAgICAgICAgICAuZmluZChcIm9wdGlvbjpzZWxlY3RlZFwiKVxuICAgICAgICAgICAgICAgIC52YWwoKTtcbiAgICAgICAgICAgIHZhciBkZWZhdWx0X3RwcyA9ICQoXCIjdG9vbF9wYW5lbF9zZWN0aW9uX3NlbGVjdFwiKVxuICAgICAgICAgICAgICAgIC5maW5kKFwib3B0aW9uOnNlbGVjdGVkXCIpXG4gICAgICAgICAgICAgICAgLnZhbCgpO1xuICAgICAgICAgICAgaWYgKG5ld192YWx1ZSA9PSBkZWZhdWx0X3Rwcykge1xuICAgICAgICAgICAgICAgICQodGhpcykuYXR0cihcImRlZmF1bHRcIiwgXCJhY3RpdmVcIik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICQodGhpcykucmVtb3ZlQXR0cihcImRlZmF1bHRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAkKCgpID0+IHtcbiAgICAgICAgICAgICQoXCIjcmVwb3NpdG9yeV9kZXBlbmRlbmNpZXNcIikuanN0cmVlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICAkKFwiLnRvb2xfZm9ybVwiKS5vbihcImNsaWNrXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGd1aWQgPSAkKHRoaXMpLmF0dHIoXCJkYXRhLWd1aWRcIik7XG4gICAgICAgICAgICB2YXIgY2xlYW4gPSAkKHRoaXMpLmF0dHIoXCJkYXRhLWNsZWFuXCIpO1xuICAgICAgICAgICAgdmFyIG5hbWUgPSAkKHRoaXMpLmF0dHIoXCJkYXRhLW5hbWVcIik7XG4gICAgICAgICAgICB2YXIgZGVzYyA9ICQodGhpcykuYXR0cihcImRhdGEtZGVzY1wiKTtcbiAgICAgICAgICAgIHZhciB0b29sX3NoZWRfdXJsID0gdGhhdC5tb2RlbC50b29sX3NoZWRfdXJsO1xuICAgICAgICAgICAgdmFyIHRzcl9pZCA9ICQoXCIjcmVwb3NpdG9yeV9kZXRhaWxzXCIpLmF0dHIoXCJkYXRhLXRzcmlkXCIpO1xuICAgICAgICAgICAgdmFyIGNoYW5nZXNldCA9ICQoXCIjY2hhbmdlc2V0XCIpXG4gICAgICAgICAgICAgICAgLmZpbmQoXCJvcHRpb246c2VsZWN0ZWRcIilcbiAgICAgICAgICAgICAgICAudmFsKCk7XG4gICAgICAgICAgICB2YXIgYXBpX3VybCA9IGAke0dhbGF4eS5yb290fWFwaS90b29sX3NoZWQvdG9vbF9qc29uYDtcbiAgICAgICAgICAgIHZhciBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgZ3VpZDogZ3VpZCxcbiAgICAgICAgICAgICAgICB0b29sX3NoZWRfdXJsOiB0b29sX3NoZWRfdXJsLFxuICAgICAgICAgICAgICAgIHRzcl9pZDogdHNyX2lkLFxuICAgICAgICAgICAgICAgIGNoYW5nZXNldDogY2hhbmdlc2V0XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgJC5nZXQoYXBpX3VybCwgcGFyYW1zLCBkYXRhID0+IHtcbiAgICAgICAgICAgICAgICBkYXRhLmNscyA9IFwidWktcG9ydGxldC1wbGFpblwiO1xuICAgICAgICAgICAgICAgIHZhciB0b29sZm9ybSA9IG5ldyBGb3JtVmlldyhkYXRhKTtcbiAgICAgICAgICAgICAgICBVdGlscy5kZWVwZWFjaChkYXRhLmlucHV0cywgaW5wdXQgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXQudHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFtcImRhdGFcIiwgXCJkYXRhX2NvbGxlY3Rpb25cIl0uaW5kZXhPZihpbnB1dC50eXBlKSAhPSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0LnR5cGUgPSBcImhpZGRlblwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0LmluZm8gPSBgRGF0YSBpbnB1dCAnJHtpbnB1dC5uYW1lfScgKCR7VXRpbHMudGV4dGlmeShpbnB1dC5leHRlbnNpb25zKX0pYDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHZhciBtb2RhbCA9IG5ldyBNb2RhbC5WaWV3KCk7XG4gICAgICAgICAgICAgICAgdmFyIG1vZGFsX3RpdGxlID0gYDx1PiR7bmFtZX08L3U+ICR7ZGVzY31gO1xuICAgICAgICAgICAgICAgIG1vZGFsLnNob3coe1xuICAgICAgICAgICAgICAgICAgICBjbG9zaW5nX2V2ZW50czogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IG1vZGFsX3RpdGxlLFxuICAgICAgICAgICAgICAgICAgICBib2R5OiB0b29sZm9ybS4kZWwsXG4gICAgICAgICAgICAgICAgICAgIGJ1dHRvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIENsb3NlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RhbC5oaWRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgY2hlY2tJbnN0YWxsZWQ6IGZ1bmN0aW9uKG1ldGFkYXRhKSB7XG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgdmFyIHBhcmFtcyA9IHsgbmFtZTogbWV0YWRhdGEubmFtZSwgb3duZXI6IG1ldGFkYXRhLm93bmVyIH07XG4gICAgICAgIHZhciBhbHJlYWR5X2luc3RhbGxlZCA9IGZhbHNlO1xuICAgICAgICB2YXIgcXVldWVkID0gdGhhdC5yZXBvUXVldWVkKG1ldGFkYXRhKTtcbiAgICAgICAgJC5nZXQoYCR7R2FsYXh5LnJvb3R9YXBpL3Rvb2xfc2hlZF9yZXBvc2l0b3JpZXNgLCBwYXJhbXMsIGRhdGEgPT4ge1xuICAgICAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGRhdGEubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlcG9zaXRvcnkgPSBkYXRhW2luZGV4XTtcbiAgICAgICAgICAgICAgICB2YXIgaW5zdGFsbGVkID0gIXJlcG9zaXRvcnkuZGVsZXRlZCAmJiAhcmVwb3NpdG9yeS51bmluc3RhbGxlZDtcbiAgICAgICAgICAgICAgICB2YXIgY2hhbmdlc2V0X21hdGNoID1cbiAgICAgICAgICAgICAgICAgICAgcmVwb3NpdG9yeS5jaGFuZ2VzZXRfcmV2aXNpb24gPT0gbWV0YWRhdGEuY2hhbmdlc2V0X3JldmlzaW9uIHx8XG4gICAgICAgICAgICAgICAgICAgIHJlcG9zaXRvcnkuaW5zdGFsbGVkX2NoYW5nZXNldF9yZXZpc2lvbiA9PSBtZXRhZGF0YS5jaGFuZ2VzZXRfcmV2aXNpb247XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICByZXBvc2l0b3J5Lm5hbWUgPT0gbWV0YWRhdGEucmVwb3NpdG9yeS5uYW1lICYmXG4gICAgICAgICAgICAgICAgICAgIHJlcG9zaXRvcnkub3duZXIgPT0gbWV0YWRhdGEucmVwb3NpdG9yeS5vd25lciAmJlxuICAgICAgICAgICAgICAgICAgICBpbnN0YWxsZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlc2V0X21hdGNoXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIGFscmVhZHlfaW5zdGFsbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGFscmVhZHlfaW5zdGFsbGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICQoXCIjaW5zdGFsbF9yZXBvc2l0b3J5XCIpLnByb3AoXCJkaXNhYmxlZFwiLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgJChcIiNpbnN0YWxsX3JlcG9zaXRvcnlcIikudmFsKFwiVGhpcyByZXZpc2lvbiBpcyBhbHJlYWR5IGluc3RhbGxlZFwiKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAkKFwiI2luc3RhbGxfcmVwb3NpdG9yeVwiKS5wcm9wKFwiZGlzYWJsZWRcIiwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAkKFwiI2luc3RhbGxfcmVwb3NpdG9yeVwiKS52YWwoXCJJbnN0YWxsIHRoaXMgcmV2aXNpb25cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoYXQucmVwb1F1ZXVlZChtZXRhZGF0YSkgfHwgYWxyZWFkeV9pbnN0YWxsZWQpIHtcbiAgICAgICAgICAgICAgICAkKFwiI3F1ZXVlX2luc3RhbGxcIikuaGlkZSgpO1xuICAgICAgICAgICAgICAgICQoXCIjcXVldWVfaW5zdGFsbFwiKS52YWwoXCJUaGlzIHJldmlzaW9uIGlzIGFscmVhZHkgaW4gdGhlIHF1ZXVlXCIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAkKFwiI3F1ZXVlX2luc3RhbGxcIikuc2hvdygpO1xuICAgICAgICAgICAgICAgICQoXCIjcXVldWVfaW5zdGFsbFwiKS52YWwoXCJJbnN0YWxsIHRoaXMgcmV2aXNpb24gbGF0ZXJcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBwYW5lbFNlbGVjdDogZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgICAgIHZhciB0b29sX3BhbmVsX3NlY3Rpb24gPSB7fTtcbiAgICAgICAgaWYgKCQoXCIjdG9vbF9wYW5lbF9zZWN0aW9uX3NlbGVjdFwiKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHBhcmFtcy50b29sX3BhbmVsX3NlY3Rpb25faWQgPSAkKFwiI3Rvb2xfcGFuZWxfc2VjdGlvbl9zZWxlY3RcIilcbiAgICAgICAgICAgICAgICAuZmluZChcIm9wdGlvbjpzZWxlY3RlZFwiKVxuICAgICAgICAgICAgICAgIC52YWwoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcmFtcy5uZXdfdG9vbF9wYW5lbF9zZWN0aW9uID0gJChcIiNuZXdfdG9vbF9wYW5lbF9zZWN0aW9uXCIpLnZhbCgpO1xuICAgICAgICB9XG4gICAgICAgICQoXCIudG9vbF9wYW5lbF9zZWN0aW9uX3BpY2tlclwiKS5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGVsZW1lbnRfbmFtZSA9ICQodGhpcykuYXR0cihcIm5hbWVcIik7XG4gICAgICAgICAgICB2YXIgdG9vbF9ndWlkID0gJCh0aGlzKS5hdHRyKFwiZGF0YS10b29sZ3VpZFwiKTtcbiAgICAgICAgICAgIGlmIChlbGVtZW50X25hbWUgPT09IFwidG9vbF9wYW5lbF9zZWN0aW9uX2lkXCIpIHtcbiAgICAgICAgICAgICAgICB0b29sX3BhbmVsX3NlY3Rpb25bdG9vbF9ndWlkXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgdG9vbF9wYW5lbF9zZWN0aW9uOiAkKHRoaXMpXG4gICAgICAgICAgICAgICAgICAgICAgICAuZmluZChcIm9wdGlvbjpzZWxlY3RlZFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnZhbCgpLFxuICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFwiYXBwZW5kXCJcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0b29sX3BhbmVsX3NlY3Rpb25bdG9vbF9ndWlkXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgdG9vbF9wYW5lbF9zZWN0aW9uOiAkKHRoaXMpLnZhbCgpLFxuICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFwiY3JlYXRlXCJcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRvb2xfcGFuZWxfc2VjdGlvbjtcbiAgICB9LFxuXG4gICAgcmVEcmF3OiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuJGVsLmVtcHR5KCk7XG4gICAgICAgIHRoaXMucmVuZGVyKG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICByZXBvUXVldWVkOiBmdW5jdGlvbihtZXRhZGF0YSkge1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgIGlmICghbG9jYWxTdG9yYWdlLnJlcG9zaXRvcmllcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBxdWV1ZV9rZXkgPSB0aGF0LnF1ZXVlS2V5KG1ldGFkYXRhKTtcbiAgICAgICAgdmFyIHF1ZXVlZF9yZXBvcztcbiAgICAgICAgaWYgKGxvY2FsU3RvcmFnZS5yZXBvc2l0b3JpZXMpIHtcbiAgICAgICAgICAgIHF1ZXVlZF9yZXBvcyA9IEpTT04ucGFyc2UobG9jYWxTdG9yYWdlLnJlcG9zaXRvcmllcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHF1ZXVlZF9yZXBvcyAmJiBxdWV1ZWRfcmVwb3MuaGFzT3duUHJvcGVydHkocXVldWVfa2V5KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICBxdWV1ZUtleTogZnVuY3Rpb24obWV0YWRhdGEpIHtcbiAgICAgICAgdmFyIHNoZWRfdXJsID0gdGhpcy5tb2RlbC50b29sX3NoZWRfdXJsO1xuICAgICAgICAvLyBNYWtlIHN1cmUgdGhlcmUgaXMgbmV2ZXIgYSB0cmFpbGluZyBzbGFzaCBvbiB0aGUgc2hlZCBVUkwuXG4gICAgICAgIGlmIChzaGVkX3VybC5zdWJzdHIoLTEpID09IFwiL1wiKSB7XG4gICAgICAgICAgICBzaGVkX3VybCA9IHNoZWRfdXJsLnN1YnN0cigwLCBzaGVkX3VybC5sZW5ndGggLSAxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYCR7c2hlZF91cmx9fCR7bWV0YWRhdGEucmVwb3NpdG9yeV9pZH18JHttZXRhZGF0YS5jaGFuZ2VzZXRfcmV2aXNpb259YDtcbiAgICB9LFxuXG4gICAgdHBzU2VsZWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgbmV3X3RwcyA9ICQoXCIjdG9vbF9wYW5lbF9zZWN0aW9uX3NlbGVjdFwiKVxuICAgICAgICAgICAgLmZpbmQoXCJvcHRpb246c2VsZWN0ZWRcIilcbiAgICAgICAgICAgIC52YWwoKTtcbiAgICAgICAgJCgnLnRvb2xfcGFuZWxfc2VjdGlvbl9waWNrZXJbZGVmYXVsdD1cImFjdGl2ZVwiXScpLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAkKHRoaXMpLnZhbChuZXdfdHBzKTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIHByZXBhcmVJbnN0YWxsOiBmdW5jdGlvbihwYXJhbXMsIGFwaV91cmwpIHtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICAkLnBvc3QoYXBpX3VybCwgcGFyYW1zLCBkYXRhID0+IHtcbiAgICAgICAgICAgIHZhciBpcmlfcGFyYW1ldGVycyA9IEpTT04ucGFyc2UoZGF0YSk7XG4gICAgICAgICAgICB0aGF0LmRvSW5zdGFsbChpcmlfcGFyYW1ldGVycyk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBkb0luc3RhbGw6IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgICB2YXIgY29udHJvbGxlcl91cmwgPSBgJHtHYWxheHkucm9vdH1hZG1pbl90b29sc2hlZC9pbnN0YWxsX3JlcG9zaXRvcmllc2A7XG4gICAgICAgIHZhciByZXBvc2l0b3JpZXMgPSBwYXJhbXMucmVwb3NpdG9yaWVzO1xuICAgICAgICB2YXIgbmV3X3JvdXRlID0gYHN0YXR1cy9yLyR7cmVwb3NpdG9yaWVzLmpvaW4oXCJ8XCIpfWA7XG4gICAgICAgICQucG9zdChjb250cm9sbGVyX3VybCwgcGFyYW1zLCBkYXRhID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiSW5pdGlhbGl6aW5nIHJlcG9zaXRvcnkgaW5zdGFsbGF0aW9uIHN1Y2NlZWRlZFwiKTtcbiAgICAgICAgfSk7XG4gICAgICAgIEJhY2tib25lLmhpc3RvcnkubmF2aWdhdGUobmV3X3JvdXRlLCB7XG4gICAgICAgICAgICB0cmlnZ2VyOiB0cnVlLFxuICAgICAgICAgICAgcmVwbGFjZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgdGVtcGxhdGVSZXBvRGV0YWlsczogXy50ZW1wbGF0ZShcbiAgICAgICAgW1xuICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJ1bmlmaWVkLXBhbmVsLWhlYWRlclwiIGlkPVwicGFuZWxfaGVhZGVyXCIgdW5zZWxlY3RhYmxlPVwib25cIj4nLFxuICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJ1bmlmaWVkLXBhbmVsLWhlYWRlci1pbm5lclwiPlJlcG9zaXRvcnkgaW5mb3JtYXRpb24gZm9yIDxzdHJvbmc+PCU9IHJlcG9zaXRvcnkubmFtZSAlPjwvc3Ryb25nPiBmcm9tIDxzdHJvbmc+PCU9IHJlcG9zaXRvcnkub3duZXIgJT48L3N0cm9uZz48L2Rpdj4nLFxuICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJ1bmlmaWVkLXBhbmVsLWhlYWRlci1pbm5lclwiIHN0eWxlPVwicG9zaXRpb246IGFic29sdXRlOyByaWdodDogNXB4OyB0b3A6IDBweDtcIj48YSBocmVmPVwiIy9xdWV1ZVwiPlJlcG9zaXRvcnkgUXVldWUgKDwlPSBxdWV1ZSAlPik8L2E+PC9kaXY+JyxcbiAgICAgICAgICAgIFwiPC9kaXY+XCIsXG4gICAgICAgICAgICAnPGRpdiBjbGFzcz1cInVuaWZpZWQtcGFuZWwtYm9keVwiIGlkPVwicmVwb3NpdG9yeV9kZXRhaWxzXCIgZGF0YS10c3JpZD1cIjwlPSByZXBvc2l0b3J5LmlkICU+XCI+JyxcbiAgICAgICAgICAgICc8Zm9ybSBpZD1cInJlcG9zaXRvcnlfaW5zdGFsbGF0aW9uXCIgbmFtZT1cImluc3RhbGxfcmVwb3NpdG9yeVwiIG1ldGhvZD1cInBvc3RcIiBhY3Rpb249XCI8JT0gYXBpX3VybCAlPlwiPicsXG4gICAgICAgICAgICAnPGlucHV0IHR5cGU9XCJoaWRkZW5cIiBpZD1cInJlcG9zaXRvcmllc1wiIG5hbWU9XCI8JT0gcmVwb3NpdG9yeS5pZCAlPlwiIHZhbHVlPVwiSURcIiAvPicsXG4gICAgICAgICAgICAnPGlucHV0IHR5cGU9XCJoaWRkZW5cIiBpZD1cInRvb2xfc2hlZF91cmxcIiBuYW1lPVwidG9vbF9zaGVkX3VybFwiIHZhbHVlPVwiPCU9IHRvb2xfc2hlZCAlPlwiIC8+JyxcbiAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwidG9vbEZvcm1cIj4nLFxuICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJ0b29sRm9ybVRpdGxlXCI+Q2hhbmdlc2V0PC9kaXY+JyxcbiAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwidG9vbEZvcm1Cb2R5IGNoYW5nZXNldFwiPicsXG4gICAgICAgICAgICAnPHNlbGVjdCBpZD1cImNoYW5nZXNldFwiIG5hbWU9XCJjaGFuZ2VzZXRcIiBzdHlsZT1cIm1hcmdpbjogNXB4O1wiPicsXG4gICAgICAgICAgICBcIjwlIF8uZWFjaChPYmplY3Qua2V5cyhyZXBvc2l0b3J5Lm1ldGFkYXRhKSwgZnVuY3Rpb24oY2hhbmdlc2V0KSB7ICU+XCIsXG4gICAgICAgICAgICAnPCUgaWYgKGNoYW5nZXNldCA9PSBjdXJyZW50X2NoYW5nZXNldCkgeyB2YXIgc2VsZWN0ZWQgPSBcInNlbGVjdGVkIFwiOyB9IGVsc2UgeyB2YXIgc2VsZWN0ZWQgPSBcIlwiOyB9ICU+JyxcbiAgICAgICAgICAgICc8b3B0aW9uIDwlPSBzZWxlY3RlZCAlPnZhbHVlPVwiPCU9IGNoYW5nZXNldC5zcGxpdChcIjpcIilbMV0gJT5cIj48JT0gY2hhbmdlc2V0ICU+PC9vcHRpb24+JyxcbiAgICAgICAgICAgIFwiPCUgfSk7ICU+XCIsXG4gICAgICAgICAgICBcIjwvc2VsZWN0PlwiLFxuICAgICAgICAgICAgJzxpbnB1dCBjbGFzcz1cImJ0biBidG4tcHJpbWFyeSBwcmV2aWV3LWJ1dHRvblwiIGRhdGEtdHNyaWQ9XCI8JT0gY3VycmVudF9tZXRhZGF0YS5yZXBvc2l0b3J5LmlkICU+XCIgdHlwZT1cInN1Ym1pdFwiIGlkPVwiaW5zdGFsbF9yZXBvc2l0b3J5XCIgbmFtZT1cImluc3RhbGxfcmVwb3NpdG9yeVwiIHZhbHVlPVwiSW5zdGFsbCB0aGlzIHJldmlzaW9uIG5vd1wiIC8+JyxcbiAgICAgICAgICAgICc8aW5wdXQgY2xhc3M9XCJidG4gYnRuLXByaW1hcnkgcHJldmlldy1idXR0b25cIiB0eXBlPVwiYnV0dG9uXCIgaWQ9XCJxdWV1ZV9pbnN0YWxsXCIgbmFtZT1cInF1ZXVlX2luc3RhbGxcIiB2YWx1ZT1cIkluc3RhbGwgdGhpcyByZXZpc2lvbiBsYXRlclwiIC8+JyxcbiAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwidG9vbFBhcmFtSGVscFwiIHN0eWxlPVwiY2xlYXI6IGJvdGg7XCI+UGxlYXNlIHNlbGVjdCBhIHJldmlzaW9uIGFuZCByZXZpZXcgdGhlIHNldHRpbmdzIGJlbG93IGJlZm9yZSBpbnN0YWxsaW5nLjwvZGl2PicsXG4gICAgICAgICAgICBcIjwvZGl2PlwiLFxuICAgICAgICAgICAgXCI8L2Rpdj5cIixcbiAgICAgICAgICAgIFwiPCU9IHNoZWRfdG9vbF9jb25mICU+XCIsXG4gICAgICAgICAgICBcIjwlIGlmIChjdXJyZW50X21ldGFkYXRhLmhhc19yZXBvc2l0b3J5X2RlcGVuZGVuY2llcykgeyAlPlwiLFxuICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJ0b29sRm9ybVRpdGxlXCI+UmVwb3NpdG9yeSBkZXBlbmRlbmNpZXMgZm9yIDxzdHJvbmcgaWQ9XCJjdXJyZW50X2NoYW5nZXNldFwiPjwlPSBjdXJyZW50X2NoYW5nZXNldCAlPjwvc3Ryb25nPjwvZGl2PicsXG4gICAgICAgICAgICAnPGRpdiBjbGFzcz1cInRvb2xGb3JtQm9keVwiPicsXG4gICAgICAgICAgICAnPHAgaWQ9XCJpbnN0YWxsX3JlcG9zaXRvcnlfZGVwZW5kZW5jaWVzX2NoZWNrYm94XCI+JyxcbiAgICAgICAgICAgICc8aW5wdXQgdHlwZT1cImNoZWNrYm94XCIgY2hlY2tlZCBpZD1cImluc3RhbGxfcmVwb3NpdG9yeV9kZXBlbmRlbmNpZXNcIiAvPicsXG4gICAgICAgICAgICAnPGxhYmVsIGZvcj1cImluc3RhbGxfcmVwb3NpdG9yeV9kZXBlbmRlbmNpZXNcIj5JbnN0YWxsIHJlcG9zaXRvcnkgZGVwZW5kZW5jaWVzPC9sYWJlbD4nLFxuICAgICAgICAgICAgXCI8L3A+XCIsXG4gICAgICAgICAgICBcIjwlIGN1cnJlbnRfbWV0YWRhdGEucmVwb3NpdG9yeV9kZXBlbmRlbmN5X3RlbXBsYXRlID0gcmVwb3NpdG9yeV9kZXBlbmRlbmN5X3RlbXBsYXRlOyAlPlwiLFxuICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJ0YWJsZXMgY29udGFpbmVyLXRhYmxlXCIgaWQ9XCJyZXBvc2l0b3J5X2RlcGVuZGVuY2llc1wiPicsXG4gICAgICAgICAgICAnPGRpdiBjbGFzcz1cImV4cGFuZExpbmtcIj4nLFxuICAgICAgICAgICAgJzxhIGNsYXNzPVwidG9nZ2xlX2ZvbGRlclwiIGRhdGFfdGFyZ2V0PVwicmVwb3NpdG9yeV9kZXBlbmRlbmNpZXNfdGFibGVcIj4nLFxuICAgICAgICAgICAgXCJSZXBvc2l0b3J5IGRlcGVuZGVuY2llcyAmbmRhc2g7IDxlbT5pbnN0YWxsYXRpb24gb2YgdGhlc2UgYWRkaXRpb25hbCByZXBvc2l0b3JpZXMgaXMgcmVxdWlyZWQ8L2VtPlwiLFxuICAgICAgICAgICAgXCI8L2E+XCIsXG4gICAgICAgICAgICBcIjwvZGl2PlwiLFxuICAgICAgICAgICAgXCI8JT0gcmVwb3NpdG9yeV9kZXBlbmRlbmNpZXNfdGVtcGxhdGUoY3VycmVudF9tZXRhZGF0YSkgJT5cIixcbiAgICAgICAgICAgIFwiPC9kaXY+XCIsXG4gICAgICAgICAgICBcIjwvZGl2PlwiLFxuICAgICAgICAgICAgXCI8JSB9ICU+XCIsXG4gICAgICAgICAgICBcIjwlIGlmIChjdXJyZW50X21ldGFkYXRhLmluY2x1ZGVzX3Rvb2xfZGVwZW5kZW5jaWVzKSB7ICU+XCIsXG4gICAgICAgICAgICAnPGRpdiBjbGFzcz1cInRvb2xGb3JtVGl0bGVcIj5Ub29sIGRlcGVuZGVuY2llczwvZGl2PicsXG4gICAgICAgICAgICAnPGRpdiBjbGFzcz1cInRvb2xGb3JtQm9keVwiPicsXG4gICAgICAgICAgICAnPHAgaWQ9XCJpbnN0YWxsX3Jlc29sdmVyX2RlcGVuZGVuY2llc19jaGVja2JveFwiPicsXG4gICAgICAgICAgICAnPGlucHV0IHR5cGU9XCJjaGVja2JveFwiIGNoZWNrZWQgaWQ9XCJpbnN0YWxsX3Jlc29sdmVyX2RlcGVuZGVuY2llc1wiIC8+JyxcbiAgICAgICAgICAgICc8bGFiZWwgZm9yPVwiaW5zdGFsbF9yZXNvbHZlcl9kZXBlbmRlbmNpZXNcIj5JbnN0YWxsIHJlc29sdmVyIGRlcGVuZGVuY2llczwvbGFiZWw+JyxcbiAgICAgICAgICAgIFwiPC9wPlwiLFxuICAgICAgICAgICAgJzxwIGlkPVwiaW5zdGFsbF90b29sX2RlcGVuZGVuY2llc19jaGVja2JveFwiPicsXG4gICAgICAgICAgICAnPGlucHV0IHR5cGU9XCJjaGVja2JveFwiIGNoZWNrZWQgaWQ9XCJpbnN0YWxsX3Rvb2xfZGVwZW5kZW5jaWVzXCIgLz4nLFxuICAgICAgICAgICAgJzxsYWJlbCBmb3I9XCJpbnN0YWxsX3Rvb2xfZGVwZW5kZW5jaWVzXCI+SW5zdGFsbCB0b29sIGRlcGVuZGVuY2llczwvbGFiZWw+JyxcbiAgICAgICAgICAgIFwiPC9wPlwiLFxuICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJ0YWJsZXMgY29udGFpbmVyLXRhYmxlXCIgaWQ9XCJ0b29sX2RlcGVuZGVuY2llc1wiPicsXG4gICAgICAgICAgICAnPGRpdiBjbGFzcz1cImV4cGFuZExpbmtcIj4nLFxuICAgICAgICAgICAgJzxhIGNsYXNzPVwidG9nZ2xlX2ZvbGRlclwiIGRhdGFfdGFyZ2V0PVwidG9vbF9kZXBlbmRlbmNpZXNfdGFibGVcIj4nLFxuICAgICAgICAgICAgXCJUb29sIGRlcGVuZGVuY2llcyAmbmRhc2g7IDxlbT5yZXBvc2l0b3J5IHRvb2xzIHJlcXVpcmUgaGFuZGxpbmcgb2YgdGhlc2UgZGVwZW5kZW5jaWVzPC9lbT5cIixcbiAgICAgICAgICAgIFwiPC9hPlwiLFxuICAgICAgICAgICAgXCI8L2Rpdj5cIixcbiAgICAgICAgICAgICc8dGFibGUgY2xhc3M9XCJ0YWJsZXMgY29udGFpbmVyLXRhYmxlXCIgaWQ9XCJ0b29sX2RlcGVuZGVuY2llc190YWJsZVwiIGJvcmRlcj1cIjBcIiBjZWxscGFkZGluZz1cIjJcIiBjZWxsc3BhY2luZz1cIjJcIiB3aWR0aD1cIjEwMCVcIj4nLFxuICAgICAgICAgICAgXCI8dGhlYWQ+XCIsXG4gICAgICAgICAgICAnPHRyIHN0eWxlPVwiZGlzcGxheTogdGFibGUtcm93O1wiIGNsYXNzPVwiZGF0YXNldFJvd1wiIHBhcmVudD1cIjBcIiBpZD1cImxpYnJhcnlJdGVtLXJ0LWY5Y2FkN2IwMWE0NzIxMzVcIj4nLFxuICAgICAgICAgICAgJzx0aCBzdHlsZT1cInBhZGRpbmctbGVmdDogNDBweDtcIj5OYW1lPC90aD4nLFxuICAgICAgICAgICAgXCI8dGg+VmVyc2lvbjwvdGg+XCIsXG4gICAgICAgICAgICBcIjx0aD5UeXBlPC90aD5cIixcbiAgICAgICAgICAgIFwiPC90cj5cIixcbiAgICAgICAgICAgIFwiPC90aGVhZD5cIixcbiAgICAgICAgICAgICc8dGJvZHkgaWQ9XCJ0b29sX2RlcHNcIj4nLFxuICAgICAgICAgICAgXCI8JSBfLmVhY2godG9vbF9kZXBlbmRlbmNpZXNbY3VycmVudF9jaGFuZ2VzZXRdLCBmdW5jdGlvbihkZXBlbmRlbmN5KSB7ICU+XCIsXG4gICAgICAgICAgICAnPHRyIGNsYXNzPVwiZGF0YXNldFJvdyB0b29sX2RlcGVuZGVuY3lfcm93XCIgc3R5bGU9XCJkaXNwbGF5OiB0YWJsZS1yb3c7XCI+JyxcbiAgICAgICAgICAgICc8dGQgc3R5bGU9XCJwYWRkaW5nLWxlZnQ6IDQwcHg7XCI+JyxcbiAgICAgICAgICAgIFwiPCU9IGRlcGVuZGVuY3kubmFtZSAlPjwvdGQ+XCIsXG4gICAgICAgICAgICBcIjx0ZD48JT0gZGVwZW5kZW5jeS52ZXJzaW9uICU+PC90ZD5cIixcbiAgICAgICAgICAgIFwiPHRkPjwlPSBkZXBlbmRlbmN5LnR5cGUgJT48L3RkPlwiLFxuICAgICAgICAgICAgXCI8L3RyPlwiLFxuICAgICAgICAgICAgXCI8JSB9KTsgJT5cIixcbiAgICAgICAgICAgIFwiPC90Ym9keT5cIixcbiAgICAgICAgICAgIFwiPC90YWJsZT5cIixcbiAgICAgICAgICAgIFwiPC9kaXY+XCIsXG4gICAgICAgICAgICBcIjwvZGl2PlwiLFxuICAgICAgICAgICAgXCI8JSB9ICU+XCIsXG4gICAgICAgICAgICBcIjwlIGlmIChjdXJyZW50X21ldGFkYXRhLmluY2x1ZGVzX3Rvb2xzX2Zvcl9kaXNwbGF5X2luX3Rvb2xfcGFuZWwpIHsgJT5cIixcbiAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwidG9vbEZvcm1UaXRsZVwiPlRvb2xzICZuZGFzaDsgPGVtPmNsaWNrIHRoZSBuYW1lIHRvIHByZXZpZXcgdGhlIHRvb2wgYW5kIHVzZSB0aGUgcG9wLXVwIG1lbnUgdG8gaW5zcGVjdCBhbGwgbWV0YWRhdGE8L2VtPjwvZGl2PicsXG4gICAgICAgICAgICAnPGRpdiBjbGFzcz1cInRvb2xGb3JtQm9keVwiPicsXG4gICAgICAgICAgICAnPGRpdiBjbGFzcz1cInRhYmxlcyBjb250YWluZXItdGFibGVcIiBpZD1cInRvb2xzX3RvZ2dsZVwiPicsXG4gICAgICAgICAgICAnPHRhYmxlIGNsYXNzPVwidGFibGVzIGNvbnRhaW5lci10YWJsZVwiIGlkPVwidmFsaWRfdG9vbHNcIiBib3JkZXI9XCIwXCIgY2VsbHBhZGRpbmc9XCIyXCIgY2VsbHNwYWNpbmc9XCIyXCIgd2lkdGg9XCIxMDAlXCI+JyxcbiAgICAgICAgICAgIFwiPHRoZWFkPlwiLFxuICAgICAgICAgICAgJzx0ciBzdHlsZT1cImRpc3BsYXk6IHRhYmxlLXJvdztcIiBjbGFzcz1cImRhdGFzZXRSb3dcIiBwYXJlbnQ9XCIwXCIgaWQ9XCJsaWJyYXJ5SXRlbS1ydC1mOWNhZDdiMDFhNDcyMTM1XCI+JyxcbiAgICAgICAgICAgICc8dGggc3R5bGU9XCJwYWRkaW5nLWxlZnQ6IDQwcHg7XCI+TmFtZTwvdGg+JyxcbiAgICAgICAgICAgIFwiPHRoPkRlc2NyaXB0aW9uPC90aD5cIixcbiAgICAgICAgICAgIFwiPHRoPlZlcnNpb248L3RoPlwiLFxuICAgICAgICAgICAgXCI8dGg+PCU9IHRwc190ZW1wbGF0ZV9nbG9iYWxfc2VsZWN0KHt0cHM6IHBhbmVsX3NlY3Rpb25fZGljdCwgdHBzX3NlbGVjdF9vcHRpb25zOiB0cHNfc2VsZWN0X29wdGlvbnN9KSAlPjwvdHI+XCIsXG4gICAgICAgICAgICBcIjwvdGhlYWQ+XCIsXG4gICAgICAgICAgICAnPHRib2R5IGlkPVwidG9vbHNfaW5fcmVwb1wiPicsXG4gICAgICAgICAgICBcIjwlIF8uZWFjaChjdXJyZW50X21ldGFkYXRhLnRvb2xzLCBmdW5jdGlvbih0b29sKSB7ICU+XCIsXG4gICAgICAgICAgICAnPHRyIGlkPVwibGlicmFyeUl0ZW0tPCU9IHRvb2wuY2xlYW4gJT5cIiBjbGFzcz1cInRvb2xfcm93XCIgc3R5bGU9XCJkaXNwbGF5OiB0YWJsZS1yb3c7XCIgc3R5bGU9XCJ3aWR0aDogMTUlXCI+JyxcbiAgICAgICAgICAgICc8dGQgc3R5bGU9XCJwYWRkaW5nLWxlZnQ6IDQwcHg7XCI+JyxcbiAgICAgICAgICAgICc8ZGl2IGlkPVwidG9vbC08JT0gdG9vbC5jbGVhbiAlPlwiIGNsYXNzPVwibWVudWJ1dHRvbiBzcGxpdCBwb3B1cFwiIHN0eWxlPVwiZmxvYXQ6IGxlZnQ7XCI+JyxcbiAgICAgICAgICAgICc8YSBjbGFzcz1cInRvb2xfZm9ybSB2aWV3LWluZm9cIiBkYXRhLXRvZ2dsZT1cIm1vZGFsXCIgZGF0YS10YXJnZXQ9XCJ0b29sZm9ybV88JT0gdG9vbC5jbGVhbiAlPlwiIGRhdGEtY2xlYW49XCI8JT0gdG9vbC5jbGVhbiAlPlwiIGRhdGEtZ3VpZD1cIjwlPSB0b29sLmd1aWQgJT5cIiBkYXRhLW5hbWU9XCI8JT0gdG9vbC5uYW1lICU+XCIgZGF0YS1kZXNjPVwiPCU9IHRvb2wuZGVzY3JpcHRpb24gJT5cIj48JT0gdG9vbC5uYW1lICU+PC9hPicsXG4gICAgICAgICAgICBcIjwvZGl2PlwiLFxuICAgICAgICAgICAgXCI8L3RkPlwiLFxuICAgICAgICAgICAgXCI8dGQ+PCU9IHRvb2wuZGVzY3JpcHRpb24gJT48L3RkPlwiLFxuICAgICAgICAgICAgJzx0ZCBzdHlsZT1cIndpZHRoOiAxNSVcIj48JT0gdG9vbC52ZXJzaW9uICU+PC90ZD4nLFxuICAgICAgICAgICAgJzx0ZCBzdHlsZT1cIndpZHRoOiAzNSVcIiBpZD1cInRvb2xfdHBzXzwlPSB0b29sLmNsZWFuICU+XCI+JyxcbiAgICAgICAgICAgIFwiPCU9IHRwc190ZW1wbGF0ZV90b29sX3NlbGVjdCh7dG9vbDogdG9vbCwgdHBzOiBwYW5lbF9zZWN0aW9uX2RpY3QsIHRwc19zZWxlY3Rfb3B0aW9uczogdHBzX3NlbGVjdF9vcHRpb25zfSkgJT5cIixcbiAgICAgICAgICAgIFwiPC90ZD5cIixcbiAgICAgICAgICAgIFwiPC90cj5cIixcbiAgICAgICAgICAgIFwiPCUgfSk7ICU+XCIsXG4gICAgICAgICAgICBcIjwvdGJvZHk+XCIsXG4gICAgICAgICAgICBcIjwvdGFibGU+XCIsXG4gICAgICAgICAgICBcIjwvZGl2PlwiLFxuICAgICAgICAgICAgXCI8L2Rpdj5cIixcbiAgICAgICAgICAgIFwiPCUgfSAlPlwiLFxuICAgICAgICAgICAgXCI8L2Zvcm0+XCIsXG4gICAgICAgICAgICBcIjwvZGl2PlwiXG4gICAgICAgIF0uam9pbihcIlwiKVxuICAgICksXG5cbiAgICB0ZW1wbGF0ZVJlcG9EZXBlbmRlbmNpZXM6IF8udGVtcGxhdGUoXG4gICAgICAgIFtcbiAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwidG9vbEZvcm1UaXRsZVwiPlJlcG9zaXRvcnkgRGVwZW5kZW5jaWVzPC9kaXY+JyxcbiAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwidG9vbEZvcm1Cb2R5IHRhYmxlcyBjb250YWluZXItdGFibGVcIiBpZD1cInJlcG9zaXRvcnlfZGVwZW5kZW5jaWVzXCI+JyxcbiAgICAgICAgICAgIFwiPHVsPlwiLFxuICAgICAgICAgICAgXCI8bGk+UmVwb3NpdG9yeSBpbnN0YWxsYXRpb24gcmVxdWlyZXMgdGhlIGZvbGxvd2luZ1wiLFxuICAgICAgICAgICAgXCI8JSBpZiAoaGFzX3JlcG9zaXRvcnlfZGVwZW5kZW5jaWVzKSB7ICU+XCIsXG4gICAgICAgICAgICBcIjwlIF8uZWFjaChyZXBvc2l0b3J5X2RlcGVuZGVuY2llcywgZnVuY3Rpb24oZGVwZW5kZW5jeSkgeyAlPlwiLFxuICAgICAgICAgICAgXCI8JSBkZXBlbmRlbmN5LnJlcG9zaXRvcnlfZGVwZW5kZW5jeV90ZW1wbGF0ZSA9IHJlcG9zaXRvcnlfZGVwZW5kZW5jeV90ZW1wbGF0ZTsgJT5cIixcbiAgICAgICAgICAgIFwiPCU9IHJlcG9zaXRvcnlfZGVwZW5kZW5jeV90ZW1wbGF0ZShkZXBlbmRlbmN5KSAlPlwiLFxuICAgICAgICAgICAgXCI8JSB9KTsgJT5cIixcbiAgICAgICAgICAgIFwiPCUgfSAlPlwiLFxuICAgICAgICAgICAgXCI8L2xpPlwiLFxuICAgICAgICAgICAgXCI8L3VsPlwiLFxuICAgICAgICAgICAgXCI8L2Rpdj5cIlxuICAgICAgICBdLmpvaW4oXCJcIilcbiAgICApLFxuXG4gICAgdGVtcGxhdGVSZXBvRGVwZW5kZW5jeTogXy50ZW1wbGF0ZShcbiAgICAgICAgW1xuICAgICAgICAgICAgJzxsaSBpZD1cIm1ldGFkYXRhXzwlPSBpZCAlPlwiIGNsYXNzPVwiZGF0YXNldFJvdyByZXBvc2l0b3J5X2RlcGVuZGVuY3lfcm93XCI+JyxcbiAgICAgICAgICAgIFwiUmVwb3NpdG9yeSA8Yj48JT0gcmVwb3NpdG9yeS5uYW1lICU+PC9iPiByZXZpc2lvbiA8Yj48JT0gY2hhbmdlc2V0X3JldmlzaW9uICU+PC9iPiBvd25lZCBieSA8Yj48JT0gcmVwb3NpdG9yeS5vd25lciAlPjwvYj5cIixcbiAgICAgICAgICAgIFwiPCUgaWYgKGhhc19yZXBvc2l0b3J5X2RlcGVuZGVuY2llcykgeyAlPlwiLFxuICAgICAgICAgICAgJzx1bCBjbGFzcz1cImNoaWxkX2RlcGVuZGVuY2llc1wiPicsXG4gICAgICAgICAgICBcIjwlIF8uZWFjaChyZXBvc2l0b3J5X2RlcGVuZGVuY2llcywgZnVuY3Rpb24oZGVwZW5kZW5jeSkgeyAlPlwiLFxuICAgICAgICAgICAgXCI8JSBkZXBlbmRlbmN5LnJlcG9zaXRvcnlfZGVwZW5kZW5jeV90ZW1wbGF0ZSA9IHJlcG9zaXRvcnlfZGVwZW5kZW5jeV90ZW1wbGF0ZTsgJT5cIixcbiAgICAgICAgICAgIFwiPCU9IHJlcG9zaXRvcnlfZGVwZW5kZW5jeV90ZW1wbGF0ZShkZXBlbmRlbmN5KSAlPlwiLFxuICAgICAgICAgICAgXCI8JSB9KTsgJT5cIixcbiAgICAgICAgICAgIFwiPC91bD5cIixcbiAgICAgICAgICAgIFwiPCUgfSAlPlwiLFxuICAgICAgICAgICAgXCI8L2xpPlwiXG4gICAgICAgIF0uam9pbihcIlwiKVxuICAgICksXG5cbiAgICB0ZW1wbGF0ZVNoZWRUb29sQ29uZjogXy50ZW1wbGF0ZShcbiAgICAgICAgW1xuICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJ0b29sRm9ybVRpdGxlXCI+U2hlZCB0b29sIGNvbmZpZ3VyYXRpb24gZmlsZTo8L2Rpdj4nLFxuICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJ0b29sRm9ybUJvZHlcIj4nLFxuICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJmb3JtLXJvd1wiPicsXG4gICAgICAgICAgICAnPHNlbGVjdCBuYW1lPVwic2hlZF90b29sX2NvbmZcIj4nLFxuICAgICAgICAgICAgXCI8JSBfLmVhY2goc2hlZF90b29sX2NvbmZzLm9wdGlvbnMsIGZ1bmN0aW9uKGNvbmYpIHsgJT5cIixcbiAgICAgICAgICAgICc8b3B0aW9uIHZhbHVlPVwiPCU9IGNvbmYudmFsdWUgJT5cIj48JT0gY29uZi5sYWJlbCAlPjwvb3B0aW9uPicsXG4gICAgICAgICAgICBcIjwlIH0pOyAlPlwiLFxuICAgICAgICAgICAgJzwvc2VsZWN0PicsXG4gICAgICAgICAgICAnPGRpdiBjbGFzcz1cInRvb2xQYXJhbUhlbHBcIiBzdHlsZT1cImNsZWFyOiBib3RoO1wiPlNlbGVjdCB0aGUgZmlsZSB3aG9zZSA8Yj50b29sX3BhdGg8L2I+IHNldHRpbmcgeW91IHdhbnQgdXNlZCBmb3IgaW5zdGFsbGluZyByZXBvc2l0b3JpZXMuPC9kaXY+JyxcbiAgICAgICAgICAgIFwiPC9kaXY+XCIsXG4gICAgICAgICAgICBcIjwvZGl2PlwiXG4gICAgICAgIF0uam9pbihcIlwiKVxuICAgICksXG5cbiAgICB0ZW1wbGF0ZVRvb2xEZXBlbmRlbmN5OiBfLnRlbXBsYXRlKFxuICAgICAgICBbXG4gICAgICAgICAgICBcIjwlIGlmIChoYXNfcmVwb3NpdG9yeV9kZXBlbmRlbmNpZXMpIHsgJT5cIixcbiAgICAgICAgICAgIFwiPCUgXy5lYWNoKHJlcG9zaXRvcnlfZGVwZW5kZW5jaWVzLCBmdW5jdGlvbihkZXBlbmRlbmN5KSB7ICU+XCIsXG4gICAgICAgICAgICBcIjwlIGlmIChkZXBlbmRlbmN5LmluY2x1ZGVzX3Rvb2xfZGVwZW5kZW5jaWVzKSB7ICU+XCIsXG4gICAgICAgICAgICBcIjwlIGRlcGVuZGVuY3kudG9vbF9kZXBlbmRlbmN5X3RlbXBsYXRlID0gdG9vbF9kZXBlbmRlbmN5X3RlbXBsYXRlICU+XCIsXG4gICAgICAgICAgICBcIjwlPSB0b29sX2RlcGVuZGVuY3lfdGVtcGxhdGUoZGVwZW5kZW5jeSkgJT5cIixcbiAgICAgICAgICAgIFwiPCUgfSAlPlwiLFxuICAgICAgICAgICAgXCI8JSB9KTsgJT5cIixcbiAgICAgICAgICAgIFwiPCUgfSAlPlwiXG4gICAgICAgIF0uam9pbihcIlwiKVxuICAgICksXG5cbiAgICB0ZW1wbGF0ZUdsb2JhbFNlY3Rpb25DcmVhdGU6IF8udGVtcGxhdGUoXG4gICAgICAgIFtcbiAgICAgICAgICAgICc8ZGl2IGlkPVwidG9vbF9wYW5lbF9zZWN0aW9uXCI+JyxcbiAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiZm9ybS1yb3dcIiBpZD1cIm5ld190cHNcIj4nLFxuICAgICAgICAgICAgJzxpbnB1dCBpZD1cIm5ld190b29sX3BhbmVsX3NlY3Rpb25cIiBuYW1lPVwibmV3X3Rvb2xfcGFuZWxfc2VjdGlvblwiIHR5cGU9XCJ0ZXh0ZmllbGRcIiB2YWx1ZT1cIlwiIHNpemU9XCI0MFwiLz4nLFxuICAgICAgICAgICAgJzxpbnB1dCBjbGFzcz1cImJ0biBidG4tcHJpbWFyeVwiIHR5cGU9XCJidXR0b25cIiBpZD1cInNlbGVjdF9leGlzdGluZ1wiIHZhbHVlPVwiU2VsZWN0IGV4aXN0aW5nXCIgLz4nLFxuICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJ0b29sUGFyYW1IZWxwXCIgc3R5bGU9XCJjbGVhcjogYm90aDtcIj4nLFxuICAgICAgICAgICAgXCJBZGQgYSBuZXcgdG9vbCBwYW5lbCBzZWN0aW9uIHRvIGNvbnRhaW4gdGhlIGluc3RhbGxlZCB0b29scyAob3B0aW9uYWwpLlwiLFxuICAgICAgICAgICAgXCI8L2Rpdj5cIixcbiAgICAgICAgICAgIFwiPC9kaXY+XCIsXG4gICAgICAgICAgICBcIjwvZGl2PlwiXG4gICAgICAgIF0uam9pbihcIlwiKVxuICAgICksXG5cbiAgICB0ZW1wbGF0ZUdsb2JhbFNlY3Rpb25TZWxlY3Q6IF8udGVtcGxhdGUoXG4gICAgICAgIFtcbiAgICAgICAgICAgICc8ZGl2IGlkPVwidG9vbF9wYW5lbF9zZWN0aW9uXCI+JyxcbiAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwidG9vbEZvcm1UaXRsZVwiPlRvb2wgUGFuZWwgU2VjdGlvbjwvZGl2PicsXG4gICAgICAgICAgICAnPGRpdiBjbGFzcz1cInRvb2xGb3JtQm9keVwiPicsXG4gICAgICAgICAgICAnPGRpdiBjbGFzcz1cInRhYi1wYW5lXCIgaWQ9XCJzZWxlY3RfdHBzXCI+JyxcbiAgICAgICAgICAgICc8c2VsZWN0IG5hbWU9XCI8JT0gbmFtZSAlPlwiIGlkPVwiPCU9IHRwcy5pZCAlPlwiPicsXG4gICAgICAgICAgICBcIjwlPSB0cHNfc2VsZWN0X29wdGlvbnMoe3NlY3Rpb25zOiB0cHMuc2VjdGlvbnN9KSAlPlwiLFxuICAgICAgICAgICAgXCI8L3NlbGVjdD5cIixcbiAgICAgICAgICAgICc8aW5wdXQgY2xhc3M9XCJidG4gYnRuLXByaW1hcnlcIiB0eXBlPVwiYnV0dG9uXCIgaWQ9XCJjcmVhdGVfbmV3XCIgdmFsdWU9XCJDcmVhdGUgbmV3XCIgLz4nLFxuICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJ0b29sUGFyYW1IZWxwXCIgc3R5bGU9XCJjbGVhcjogYm90aDtcIj4nLFxuICAgICAgICAgICAgXCJTZWxlY3QgYW4gZXhpc3RpbmcgdG9vbCBwYW5lbCBzZWN0aW9uIHRvIGNvbnRhaW4gdGhlIGluc3RhbGxlZCB0b29scyAob3B0aW9uYWwpLlwiLFxuICAgICAgICAgICAgXCI8L2Rpdj5cIixcbiAgICAgICAgICAgIFwiPC9kaXY+XCIsXG4gICAgICAgICAgICBcIjwvZGl2PlwiLFxuICAgICAgICAgICAgXCI8L2Rpdj5cIlxuICAgICAgICBdLmpvaW4oXCJcIilcbiAgICApLFxuXG4gICAgdGVtcGxhdGVUb29sU2VjdGlvbkNyZWF0ZTogXy50ZW1wbGF0ZShcbiAgICAgICAgW1xuICAgICAgICAgICAgJzxkaXYgaWQ9XCJuZXdfdHBzXzwlPSB0b29sLmNsZWFuICU+XCIgZGF0YS1jbGVhbj1cIjwlPSB0b29sLmNsZWFuICU+XCIgY2xhc3M9XCJmb3JtLXJvd1wiPicsXG4gICAgICAgICAgICAnPGlucHV0IGRhdGEtdG9vbGd1aWQ9XCI8JT0gdG9vbC5ndWlkICU+XCIgY2xhc3M9XCJ0b29sX3BhbmVsX3NlY3Rpb25fcGlja2VyXCIgc2l6ZT1cIjQwXCIgbmFtZT1cIm5ld190b29sX3BhbmVsX3NlY3Rpb25cIiBpZD1cIm5ld190b29sX3BhbmVsX3NlY3Rpb25fPCU9IHRvb2wuY2xlYW4gJT5cIiB0eXBlPVwidGV4dFwiPicsXG4gICAgICAgICAgICAnPGlucHV0IGlkPVwicGVyX3Rvb2xfc2VsZWN0XzwlPSB0b29sLmNsZWFuICU+XCIgY2xhc3M9XCJidG4gYnRuLXByaW1hcnlcIiBkYXRhLXRvb2xndWlkPVwiPCU9IHRvb2wuZ3VpZCAlPlwiIHZhbHVlPVwiU2VsZWN0IGV4aXN0aW5nXCIgaWQ9XCJzZWxlY3RfZXhpc3RpbmdfPCU9IHRvb2wuY2xlYW4gJT5cIiB0eXBlPVwiYnV0dG9uXCI+JyxcbiAgICAgICAgICAgIFwiPC9kaXY+XCJcbiAgICAgICAgXS5qb2luKFwiXCIpXG4gICAgKSxcblxuICAgIHRlbXBsYXRlVG9vbFNlY3Rpb25TZWxlY3Q6IF8udGVtcGxhdGUoXG4gICAgICAgIFtcbiAgICAgICAgICAgICc8ZGl2IGlkPVwic2VsZWN0X3Rwc188JT0gdG9vbC5jbGVhbiAlPlwiIGRhdGEtY2xlYW49XCI8JT0gdG9vbC5jbGVhbiAlPlwiIGNsYXNzPVwidHBzX2NyZWF0b3JcIj4nLFxuICAgICAgICAgICAgJzxzZWxlY3QgZGVmYXVsdD1cImFjdGl2ZVwiIHN0eWxlPVwid2lkdGg6IDMwZW07XCIgZGF0YS10b29sZ3VpZD1cIjwlPSB0b29sLmd1aWQgJT5cIiBjbGFzcz1cInRvb2xfcGFuZWxfc2VjdGlvbl9waWNrZXJcIiBuYW1lPVwidG9vbF9wYW5lbF9zZWN0aW9uX2lkXCIgaWQ9XCJ0b29sX3BhbmVsX3NlY3Rpb25fc2VsZWN0XzwlPSB0b29sLmNsZWFuICU+XCI+JyxcbiAgICAgICAgICAgIFwiPCU9IHRwc19zZWxlY3Rfb3B0aW9ucyh7c2VjdGlvbnM6IHRwcy5zZWN0aW9uc30pICU+XCIsXG4gICAgICAgICAgICBcIjwvc2VsZWN0PlwiLFxuICAgICAgICAgICAgJzxpbnB1dCBpZD1cInBlcl90b29sX2NyZWF0ZV88JT0gdG9vbC5jbGVhbiAlPlwiIGRhdGEtY2xlYW49XCI8JT0gdG9vbC5jbGVhbiAlPlwiIGNsYXNzPVwiYnRuIGJ0bi1wcmltYXJ5IGNyZWF0ZS10cHMtYnV0dG9uXCIgZGF0YS10b29sZ3VpZD1cIjwlPSB0b29sLmd1aWQgJT5cIiB2YWx1ZT1cIkNyZWF0ZSBuZXdcIiBpZD1cImNyZWF0ZV9uZXdfPCU9IHRvb2wuY2xlYW4gJT5cIiB0eXBlPVwiYnV0dG9uXCI+JyxcbiAgICAgICAgICAgICc8ZGl2IHN0eWxlPVwiY2xlYXI6IGJvdGg7XCIgY2xhc3M9XCJ0b29sUGFyYW1IZWxwXCI+PC9kaXY+JyxcbiAgICAgICAgICAgIFwiPC9kaXY+XCJcbiAgICAgICAgXS5qb2luKFwiXCIpXG4gICAgKSxcblxuICAgIHRlbXBsYXRlUGFuZWxTZWxlY3RPcHRpb25zOiBfLnRlbXBsYXRlKFxuICAgICAgICBbXG4gICAgICAgICAgICBcIjwlIF8uZWFjaChzZWN0aW9ucywgZnVuY3Rpb24oc2VjdGlvbikgeyAlPlwiLFxuICAgICAgICAgICAgJzxvcHRpb24gdmFsdWU9XCI8JT0gc2VjdGlvbi5pZCAlPlwiPjwlPSBzZWN0aW9uLm5hbWUgJT48L29wdGlvbj4nLFxuICAgICAgICAgICAgXCI8JSB9KTsgJT5cIlxuICAgICAgICBdLmpvaW4oXCJcIilcbiAgICApXG59KTtcblxuZXhwb3J0IGRlZmF1bHQge1xuICAgIFJlcG9EZXRhaWxzOiBUb29sU2hlZFJlcG9zaXRvcnlWaWV3XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGdhbGF4eS9zY3JpcHRzL212Yy90b29sc2hlZC9yZXBvc2l0b3J5LXZpZXcuanMiXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7OztBQUFBO0FBQ0E7OztBQUFBO0FBQ0E7OztBQUFBO0FBQ0E7OztBQUFBO0FBQ0E7OztBQUFBO0FBQ0E7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFKQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQXNIQTtBQUNBO0FBaUJBO0FBQ0E7QUFlQTtBQUNBO0FBZUE7QUFDQTtBQVlBO0FBQ0E7QUFhQTtBQUNBO0FBa0JBO0FBQ0E7QUFRQTtBQUNBO0FBV0E7QUFwaUJBO0FBQ0E7QUE0aUJBO0FBQ0E7QUFEQTtBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///310\n");

/***/ }),

/***/ 311:
/*!**************************************************************!*\
  !*** ./galaxy/scripts/mvc/toolshed/repository-queue-view.js ***!
  \**************************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(Backbone, $, _) {\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _localization = __webpack_require__(/*! utils/localization */ 3);\n\nvar _localization2 = _interopRequireDefault(_localization);\n\nvar _toolshedModel = __webpack_require__(/*! mvc/toolshed/toolshed-model */ 17);\n\nvar _toolshedModel2 = _interopRequireDefault(_toolshedModel);\n\nvar _util = __webpack_require__(/*! mvc/toolshed/util */ 18);\n\nvar _util2 = _interopRequireDefault(_util);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar View = Backbone.View.extend({\n    el: \"#center\",\n\n    defaults: [{}],\n\n    initialize: function initialize(options) {\n        var that = this;\n        this.model = new _toolshedModel2.default.RepoQueue();\n        this.listenTo(this.model, \"sync\", this.render);\n        this.model.fetch();\n        that.render();\n    },\n\n    render: function render(options) {\n        var that = this;\n        var repo_queue_template = that.templateRepoQueue;\n        var repositories = that.model.models;\n        that.$el.html(repo_queue_template({\n            title: (0, _localization2.default)(\"Repository Installation Queue\"),\n            repositories: repositories,\n            queue: _util2.default.queueLength()\n        }));\n        $(\"#center\").css(\"overflow\", \"auto\");\n        that.bindEvents();\n    },\n\n    bindEvents: function bindEvents() {\n        var that = this;\n        $(\".install_one\").on(\"click\", function () {\n            var repository_metadata = that.loadFromQueue($(this).attr(\"data-repokey\"));\n            that.installFromQueue(repository_metadata, $(this).attr(\"data-repokey\"));\n        });\n        $(\".remove_one\").on(\"click\", function () {\n            var queue_key = $(this).attr(\"data-repokey\");\n            var repo_queue = JSON.parse(localStorage.repositories);\n            if (repo_queue.hasOwnProperty(queue_key)) {\n                var repository_id = repo_queue[queue_key].repository.id;\n                delete repo_queue[queue_key];\n                $(\"#queued_repository_\" + repository_id).remove();\n            }\n            localStorage.repositories = JSON.stringify(repo_queue);\n        });\n        $(\"#clear_queue\").on(\"click\", function () {\n            localStorage.repositories = \"{}\";\n        });\n        $(\"#from_workflow\").on(\"click\", function () {\n            Backbone.history.navigate(\"workflows\", {\n                trigger: true,\n                replace: true\n            });\n        });\n    },\n\n    installFromQueue: function installFromQueue(repository_metadata, queue_key) {\n        var that = this;\n        var params = Object();\n        params.install_tool_dependencies = repository_metadata.install_tool_dependencies;\n        params.install_repository_dependencies = repository_metadata.install_repository_dependencies;\n        params.install_resolver_dependencies = repository_metadata.install_resolver_dependencies;\n        params.tool_panel_section = repository_metadata.tool_panel_section;\n        params.shed_tool_conf = repository_metadata.shed_tool_conf;\n        params.repositories = JSON.stringify([[repository_metadata.repository.id, repository_metadata.changeset_revision]]);\n        params.tool_shed_repository_ids = JSON.stringify([repository_metadata.repository.id]);\n        params.tool_shed_url = queue_key.split(\"|\")[0];\n        params.changeset = repository_metadata.changeset_revision;\n        var url = Galaxy.root + \"api/tool_shed_repositories/install?async=True\";\n        $(\"#queued_repository_\" + repository_metadata.repository.id).remove();\n        if (localStorage.repositories) {\n            if (queue_key === undefined) {\n                queue_key = _util2.default.queueKey(repository_metadata);\n            }\n            var repository_queue = JSON.parse(localStorage.repositories);\n            if (repository_queue.hasOwnProperty(queue_key)) {\n                delete repository_queue[queue_key];\n                localStorage.repositories = JSON.stringify(repository_queue);\n            }\n        }\n\n        $.post(url, params, function (data) {\n            var iri_params = JSON.parse(data);\n            var repositories = iri_params.repositories;\n            var new_route = \"status/r/\" + repositories.join(\"|\");\n            $.post(Galaxy.root + \"admin_toolshed/install_repositories\", iri_params, function (data) {\n                console.log(\"Initializing repository installation succeeded\");\n            });\n            Backbone.history.navigate(new_route, {\n                trigger: true,\n                replace: true\n            });\n        });\n    },\n\n    loadFromQueue: function loadFromQueue(queue_key) {\n        var repository_queue = JSON.parse(localStorage.repositories);\n        if (repository_queue.hasOwnProperty(queue_key)) {\n            return repository_queue[queue_key];\n        }\n        return undefined;\n    },\n\n    reDraw: function reDraw(options) {\n        this.$el.empty();\n        this.initialize(options);\n        this.model.fetch();\n        this.render(options);\n    },\n\n    templateRepoQueue: _.template(['<div class=\"unified-panel-header\" id=\"panel_header\" unselectable=\"on\">', '<div class=\"unified-panel-header-inner\"><%= title %></div>', '<div class=\"unified-panel-header-inner\" style=\"position: absolute; right: 5px; top: 0px;\"><a href=\"#/queue\">Repository Queue (<%= queue %>)</a></div>', \"</div>\", '<div class=\"tab-pane\" id=\"panel_header\" id=\"repository_queue\">', '<table id=\"queued_repositories\" class=\"grid\" border=\"0\" cellpadding=\"2\" cellspacing=\"2\" width=\"100%\">', '<thead id=\"grid-table-header\">', \"<tr>\", '<th class=\"datasetRow\">Name</th>', '<th class=\"datasetRow\">Owner</th>', '<th class=\"datasetRow\">Revision</th>', '<th class=\"datasetRow\">ToolShed</th>', '<th class=\"datasetRow\">Install</th>', '<th class=\"datasetRow\"><input class=\"btn btn-primary\" type=\"submit\" id=\"clear_queue\" name=\"clear_queue\" value=\"Clear queue\" /></th>', \"</tr>\", \"</thead>\", \"<tbody>\", \"<% _.each(repositories, function(repository) { %>\", '<tr id=\"queued_repository_<%= repository.get(\"id\") %>\">', '<td class=\"datasetRow\"><%= repository.get(\"repository\").name %></td>', '<td class=\"datasetRow\"><%= repository.get(\"repository\").owner %></td>', '<td class=\"datasetRow\"><%= repository.get(\"changeset_revision\") %></td>', '<td class=\"datasetRow\"><%= repository.get(\"tool_shed_url\") %></td>', '<td class=\"datasetRow\">', '<input class=\"btn btn-primary install_one\" data-repokey=\"<%= repository.get(\"queue_key\") %>\" type=\"submit\" id=\"install_repository_<%= repository.get(\"id\") %>\" name=\"install_repository\" value=\"Install now\" />', \"</td>\", '<td class=\"datasetRow\">', '<input class=\"btn btn-primary remove_one\" data-repokey=\"<%= repository.get(\"queue_key\") %>\" type=\"submit\" id=\"unqueue_repository_<%= repository.get(\"id\") %>\" name=\"unqueue_repository\" value=\"Remove from queue\" />', \"</td>\", \"</tr>\", \"<% }); %>\", \"</tbody>\", \"</table>\", '<input type=\"button\" class=\"btn btn-primary\" id=\"from_workflow\" value=\"Add from workflow\" />', \"</div>\"].join(\"\"))\n});\n\nexports.default = {\n    RepoQueueView: View\n};\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! libs/backbone */ 2), __webpack_require__(/*! jquery */ 0), __webpack_require__(/*! underscore */ 1)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzExLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL2dhbGF4eS9zY3JpcHRzL212Yy90b29sc2hlZC9yZXBvc2l0b3J5LXF1ZXVlLXZpZXcuanM/NWM0MSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgX2wgZnJvbSBcInV0aWxzL2xvY2FsaXphdGlvblwiO1xuaW1wb3J0IHRvb2xzaGVkX21vZGVsIGZyb20gXCJtdmMvdG9vbHNoZWQvdG9vbHNoZWQtbW9kZWxcIjtcbmltcG9ydCB0b29sc2hlZF91dGlsIGZyb20gXCJtdmMvdG9vbHNoZWQvdXRpbFwiO1xudmFyIFZpZXcgPSBCYWNrYm9uZS5WaWV3LmV4dGVuZCh7XG4gICAgZWw6IFwiI2NlbnRlclwiLFxuXG4gICAgZGVmYXVsdHM6IFt7fV0sXG5cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgdGhpcy5tb2RlbCA9IG5ldyB0b29sc2hlZF9tb2RlbC5SZXBvUXVldWUoKTtcbiAgICAgICAgdGhpcy5saXN0ZW5Ubyh0aGlzLm1vZGVsLCBcInN5bmNcIiwgdGhpcy5yZW5kZXIpO1xuICAgICAgICB0aGlzLm1vZGVsLmZldGNoKCk7XG4gICAgICAgIHRoYXQucmVuZGVyKCk7XG4gICAgfSxcblxuICAgIHJlbmRlcjogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgIHZhciByZXBvX3F1ZXVlX3RlbXBsYXRlID0gdGhhdC50ZW1wbGF0ZVJlcG9RdWV1ZTtcbiAgICAgICAgdmFyIHJlcG9zaXRvcmllcyA9IHRoYXQubW9kZWwubW9kZWxzO1xuICAgICAgICB0aGF0LiRlbC5odG1sKFxuICAgICAgICAgICAgcmVwb19xdWV1ZV90ZW1wbGF0ZSh7XG4gICAgICAgICAgICAgICAgdGl0bGU6IF9sKFwiUmVwb3NpdG9yeSBJbnN0YWxsYXRpb24gUXVldWVcIiksXG4gICAgICAgICAgICAgICAgcmVwb3NpdG9yaWVzOiByZXBvc2l0b3JpZXMsXG4gICAgICAgICAgICAgICAgcXVldWU6IHRvb2xzaGVkX3V0aWwucXVldWVMZW5ndGgoKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgICAgJChcIiNjZW50ZXJcIikuY3NzKFwib3ZlcmZsb3dcIiwgXCJhdXRvXCIpO1xuICAgICAgICB0aGF0LmJpbmRFdmVudHMoKTtcbiAgICB9LFxuXG4gICAgYmluZEV2ZW50czogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgJChcIi5pbnN0YWxsX29uZVwiKS5vbihcImNsaWNrXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHJlcG9zaXRvcnlfbWV0YWRhdGEgPSB0aGF0LmxvYWRGcm9tUXVldWUoJCh0aGlzKS5hdHRyKFwiZGF0YS1yZXBva2V5XCIpKTtcbiAgICAgICAgICAgIHRoYXQuaW5zdGFsbEZyb21RdWV1ZShyZXBvc2l0b3J5X21ldGFkYXRhLCAkKHRoaXMpLmF0dHIoXCJkYXRhLXJlcG9rZXlcIikpO1xuICAgICAgICB9KTtcbiAgICAgICAgJChcIi5yZW1vdmVfb25lXCIpLm9uKFwiY2xpY2tcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgcXVldWVfa2V5ID0gJCh0aGlzKS5hdHRyKFwiZGF0YS1yZXBva2V5XCIpO1xuICAgICAgICAgICAgdmFyIHJlcG9fcXVldWUgPSBKU09OLnBhcnNlKGxvY2FsU3RvcmFnZS5yZXBvc2l0b3JpZXMpO1xuICAgICAgICAgICAgaWYgKHJlcG9fcXVldWUuaGFzT3duUHJvcGVydHkocXVldWVfa2V5KSkge1xuICAgICAgICAgICAgICAgIHZhciByZXBvc2l0b3J5X2lkID0gcmVwb19xdWV1ZVtxdWV1ZV9rZXldLnJlcG9zaXRvcnkuaWQ7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHJlcG9fcXVldWVbcXVldWVfa2V5XTtcbiAgICAgICAgICAgICAgICAkKGAjcXVldWVkX3JlcG9zaXRvcnlfJHtyZXBvc2l0b3J5X2lkfWApLnJlbW92ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnJlcG9zaXRvcmllcyA9IEpTT04uc3RyaW5naWZ5KHJlcG9fcXVldWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgJChcIiNjbGVhcl9xdWV1ZVwiKS5vbihcImNsaWNrXCIsICgpID0+IHtcbiAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5yZXBvc2l0b3JpZXMgPSBcInt9XCI7XG4gICAgICAgIH0pO1xuICAgICAgICAkKFwiI2Zyb21fd29ya2Zsb3dcIikub24oXCJjbGlja1wiLCAoKSA9PiB7XG4gICAgICAgICAgICBCYWNrYm9uZS5oaXN0b3J5Lm5hdmlnYXRlKFwid29ya2Zsb3dzXCIsIHtcbiAgICAgICAgICAgICAgICB0cmlnZ2VyOiB0cnVlLFxuICAgICAgICAgICAgICAgIHJlcGxhY2U6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgaW5zdGFsbEZyb21RdWV1ZTogZnVuY3Rpb24ocmVwb3NpdG9yeV9tZXRhZGF0YSwgcXVldWVfa2V5KSB7XG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgdmFyIHBhcmFtcyA9IE9iamVjdCgpO1xuICAgICAgICBwYXJhbXMuaW5zdGFsbF90b29sX2RlcGVuZGVuY2llcyA9IHJlcG9zaXRvcnlfbWV0YWRhdGEuaW5zdGFsbF90b29sX2RlcGVuZGVuY2llcztcbiAgICAgICAgcGFyYW1zLmluc3RhbGxfcmVwb3NpdG9yeV9kZXBlbmRlbmNpZXMgPSByZXBvc2l0b3J5X21ldGFkYXRhLmluc3RhbGxfcmVwb3NpdG9yeV9kZXBlbmRlbmNpZXM7XG4gICAgICAgIHBhcmFtcy5pbnN0YWxsX3Jlc29sdmVyX2RlcGVuZGVuY2llcyA9IHJlcG9zaXRvcnlfbWV0YWRhdGEuaW5zdGFsbF9yZXNvbHZlcl9kZXBlbmRlbmNpZXM7XG4gICAgICAgIHBhcmFtcy50b29sX3BhbmVsX3NlY3Rpb24gPSByZXBvc2l0b3J5X21ldGFkYXRhLnRvb2xfcGFuZWxfc2VjdGlvbjtcbiAgICAgICAgcGFyYW1zLnNoZWRfdG9vbF9jb25mID0gcmVwb3NpdG9yeV9tZXRhZGF0YS5zaGVkX3Rvb2xfY29uZjtcbiAgICAgICAgcGFyYW1zLnJlcG9zaXRvcmllcyA9IEpTT04uc3RyaW5naWZ5KFtcbiAgICAgICAgICAgIFtyZXBvc2l0b3J5X21ldGFkYXRhLnJlcG9zaXRvcnkuaWQsIHJlcG9zaXRvcnlfbWV0YWRhdGEuY2hhbmdlc2V0X3JldmlzaW9uXVxuICAgICAgICBdKTtcbiAgICAgICAgcGFyYW1zLnRvb2xfc2hlZF9yZXBvc2l0b3J5X2lkcyA9IEpTT04uc3RyaW5naWZ5KFtyZXBvc2l0b3J5X21ldGFkYXRhLnJlcG9zaXRvcnkuaWRdKTtcbiAgICAgICAgcGFyYW1zLnRvb2xfc2hlZF91cmwgPSBxdWV1ZV9rZXkuc3BsaXQoXCJ8XCIpWzBdO1xuICAgICAgICBwYXJhbXMuY2hhbmdlc2V0ID0gcmVwb3NpdG9yeV9tZXRhZGF0YS5jaGFuZ2VzZXRfcmV2aXNpb247XG4gICAgICAgIHZhciB1cmwgPSBgJHtHYWxheHkucm9vdH1hcGkvdG9vbF9zaGVkX3JlcG9zaXRvcmllcy9pbnN0YWxsP2FzeW5jPVRydWVgO1xuICAgICAgICAkKGAjcXVldWVkX3JlcG9zaXRvcnlfJHtyZXBvc2l0b3J5X21ldGFkYXRhLnJlcG9zaXRvcnkuaWR9YCkucmVtb3ZlKCk7XG4gICAgICAgIGlmIChsb2NhbFN0b3JhZ2UucmVwb3NpdG9yaWVzKSB7XG4gICAgICAgICAgICBpZiAocXVldWVfa2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBxdWV1ZV9rZXkgPSB0b29sc2hlZF91dGlsLnF1ZXVlS2V5KHJlcG9zaXRvcnlfbWV0YWRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHJlcG9zaXRvcnlfcXVldWUgPSBKU09OLnBhcnNlKGxvY2FsU3RvcmFnZS5yZXBvc2l0b3JpZXMpO1xuICAgICAgICAgICAgaWYgKHJlcG9zaXRvcnlfcXVldWUuaGFzT3duUHJvcGVydHkocXVldWVfa2V5KSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSByZXBvc2l0b3J5X3F1ZXVlW3F1ZXVlX2tleV07XG4gICAgICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnJlcG9zaXRvcmllcyA9IEpTT04uc3RyaW5naWZ5KHJlcG9zaXRvcnlfcXVldWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgJC5wb3N0KHVybCwgcGFyYW1zLCBkYXRhID0+IHtcbiAgICAgICAgICAgIHZhciBpcmlfcGFyYW1zID0gSlNPTi5wYXJzZShkYXRhKTtcbiAgICAgICAgICAgIHZhciByZXBvc2l0b3JpZXMgPSBpcmlfcGFyYW1zLnJlcG9zaXRvcmllcztcbiAgICAgICAgICAgIHZhciBuZXdfcm91dGUgPSBgc3RhdHVzL3IvJHtyZXBvc2l0b3JpZXMuam9pbihcInxcIil9YDtcbiAgICAgICAgICAgICQucG9zdChgJHtHYWxheHkucm9vdH1hZG1pbl90b29sc2hlZC9pbnN0YWxsX3JlcG9zaXRvcmllc2AsIGlyaV9wYXJhbXMsIGRhdGEgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiSW5pdGlhbGl6aW5nIHJlcG9zaXRvcnkgaW5zdGFsbGF0aW9uIHN1Y2NlZWRlZFwiKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgQmFja2JvbmUuaGlzdG9yeS5uYXZpZ2F0ZShuZXdfcm91dGUsIHtcbiAgICAgICAgICAgICAgICB0cmlnZ2VyOiB0cnVlLFxuICAgICAgICAgICAgICAgIHJlcGxhY2U6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgbG9hZEZyb21RdWV1ZTogZnVuY3Rpb24ocXVldWVfa2V5KSB7XG4gICAgICAgIHZhciByZXBvc2l0b3J5X3F1ZXVlID0gSlNPTi5wYXJzZShsb2NhbFN0b3JhZ2UucmVwb3NpdG9yaWVzKTtcbiAgICAgICAgaWYgKHJlcG9zaXRvcnlfcXVldWUuaGFzT3duUHJvcGVydHkocXVldWVfa2V5KSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlcG9zaXRvcnlfcXVldWVbcXVldWVfa2V5XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0sXG5cbiAgICByZURyYXc6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy4kZWwuZW1wdHkoKTtcbiAgICAgICAgdGhpcy5pbml0aWFsaXplKG9wdGlvbnMpO1xuICAgICAgICB0aGlzLm1vZGVsLmZldGNoKCk7XG4gICAgICAgIHRoaXMucmVuZGVyKG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICB0ZW1wbGF0ZVJlcG9RdWV1ZTogXy50ZW1wbGF0ZShcbiAgICAgICAgW1xuICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJ1bmlmaWVkLXBhbmVsLWhlYWRlclwiIGlkPVwicGFuZWxfaGVhZGVyXCIgdW5zZWxlY3RhYmxlPVwib25cIj4nLFxuICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJ1bmlmaWVkLXBhbmVsLWhlYWRlci1pbm5lclwiPjwlPSB0aXRsZSAlPjwvZGl2PicsXG4gICAgICAgICAgICAnPGRpdiBjbGFzcz1cInVuaWZpZWQtcGFuZWwtaGVhZGVyLWlubmVyXCIgc3R5bGU9XCJwb3NpdGlvbjogYWJzb2x1dGU7IHJpZ2h0OiA1cHg7IHRvcDogMHB4O1wiPjxhIGhyZWY9XCIjL3F1ZXVlXCI+UmVwb3NpdG9yeSBRdWV1ZSAoPCU9IHF1ZXVlICU+KTwvYT48L2Rpdj4nLFxuICAgICAgICAgICAgXCI8L2Rpdj5cIixcbiAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwidGFiLXBhbmVcIiBpZD1cInBhbmVsX2hlYWRlclwiIGlkPVwicmVwb3NpdG9yeV9xdWV1ZVwiPicsXG4gICAgICAgICAgICAnPHRhYmxlIGlkPVwicXVldWVkX3JlcG9zaXRvcmllc1wiIGNsYXNzPVwiZ3JpZFwiIGJvcmRlcj1cIjBcIiBjZWxscGFkZGluZz1cIjJcIiBjZWxsc3BhY2luZz1cIjJcIiB3aWR0aD1cIjEwMCVcIj4nLFxuICAgICAgICAgICAgJzx0aGVhZCBpZD1cImdyaWQtdGFibGUtaGVhZGVyXCI+JyxcbiAgICAgICAgICAgIFwiPHRyPlwiLFxuICAgICAgICAgICAgJzx0aCBjbGFzcz1cImRhdGFzZXRSb3dcIj5OYW1lPC90aD4nLFxuICAgICAgICAgICAgJzx0aCBjbGFzcz1cImRhdGFzZXRSb3dcIj5Pd25lcjwvdGg+JyxcbiAgICAgICAgICAgICc8dGggY2xhc3M9XCJkYXRhc2V0Um93XCI+UmV2aXNpb248L3RoPicsXG4gICAgICAgICAgICAnPHRoIGNsYXNzPVwiZGF0YXNldFJvd1wiPlRvb2xTaGVkPC90aD4nLFxuICAgICAgICAgICAgJzx0aCBjbGFzcz1cImRhdGFzZXRSb3dcIj5JbnN0YWxsPC90aD4nLFxuICAgICAgICAgICAgJzx0aCBjbGFzcz1cImRhdGFzZXRSb3dcIj48aW5wdXQgY2xhc3M9XCJidG4gYnRuLXByaW1hcnlcIiB0eXBlPVwic3VibWl0XCIgaWQ9XCJjbGVhcl9xdWV1ZVwiIG5hbWU9XCJjbGVhcl9xdWV1ZVwiIHZhbHVlPVwiQ2xlYXIgcXVldWVcIiAvPjwvdGg+JyxcbiAgICAgICAgICAgIFwiPC90cj5cIixcbiAgICAgICAgICAgIFwiPC90aGVhZD5cIixcbiAgICAgICAgICAgIFwiPHRib2R5PlwiLFxuICAgICAgICAgICAgXCI8JSBfLmVhY2gocmVwb3NpdG9yaWVzLCBmdW5jdGlvbihyZXBvc2l0b3J5KSB7ICU+XCIsXG4gICAgICAgICAgICAnPHRyIGlkPVwicXVldWVkX3JlcG9zaXRvcnlfPCU9IHJlcG9zaXRvcnkuZ2V0KFwiaWRcIikgJT5cIj4nLFxuICAgICAgICAgICAgJzx0ZCBjbGFzcz1cImRhdGFzZXRSb3dcIj48JT0gcmVwb3NpdG9yeS5nZXQoXCJyZXBvc2l0b3J5XCIpLm5hbWUgJT48L3RkPicsXG4gICAgICAgICAgICAnPHRkIGNsYXNzPVwiZGF0YXNldFJvd1wiPjwlPSByZXBvc2l0b3J5LmdldChcInJlcG9zaXRvcnlcIikub3duZXIgJT48L3RkPicsXG4gICAgICAgICAgICAnPHRkIGNsYXNzPVwiZGF0YXNldFJvd1wiPjwlPSByZXBvc2l0b3J5LmdldChcImNoYW5nZXNldF9yZXZpc2lvblwiKSAlPjwvdGQ+JyxcbiAgICAgICAgICAgICc8dGQgY2xhc3M9XCJkYXRhc2V0Um93XCI+PCU9IHJlcG9zaXRvcnkuZ2V0KFwidG9vbF9zaGVkX3VybFwiKSAlPjwvdGQ+JyxcbiAgICAgICAgICAgICc8dGQgY2xhc3M9XCJkYXRhc2V0Um93XCI+JyxcbiAgICAgICAgICAgICc8aW5wdXQgY2xhc3M9XCJidG4gYnRuLXByaW1hcnkgaW5zdGFsbF9vbmVcIiBkYXRhLXJlcG9rZXk9XCI8JT0gcmVwb3NpdG9yeS5nZXQoXCJxdWV1ZV9rZXlcIikgJT5cIiB0eXBlPVwic3VibWl0XCIgaWQ9XCJpbnN0YWxsX3JlcG9zaXRvcnlfPCU9IHJlcG9zaXRvcnkuZ2V0KFwiaWRcIikgJT5cIiBuYW1lPVwiaW5zdGFsbF9yZXBvc2l0b3J5XCIgdmFsdWU9XCJJbnN0YWxsIG5vd1wiIC8+JyxcbiAgICAgICAgICAgIFwiPC90ZD5cIixcbiAgICAgICAgICAgICc8dGQgY2xhc3M9XCJkYXRhc2V0Um93XCI+JyxcbiAgICAgICAgICAgICc8aW5wdXQgY2xhc3M9XCJidG4gYnRuLXByaW1hcnkgcmVtb3ZlX29uZVwiIGRhdGEtcmVwb2tleT1cIjwlPSByZXBvc2l0b3J5LmdldChcInF1ZXVlX2tleVwiKSAlPlwiIHR5cGU9XCJzdWJtaXRcIiBpZD1cInVucXVldWVfcmVwb3NpdG9yeV88JT0gcmVwb3NpdG9yeS5nZXQoXCJpZFwiKSAlPlwiIG5hbWU9XCJ1bnF1ZXVlX3JlcG9zaXRvcnlcIiB2YWx1ZT1cIlJlbW92ZSBmcm9tIHF1ZXVlXCIgLz4nLFxuICAgICAgICAgICAgXCI8L3RkPlwiLFxuICAgICAgICAgICAgXCI8L3RyPlwiLFxuICAgICAgICAgICAgXCI8JSB9KTsgJT5cIixcbiAgICAgICAgICAgIFwiPC90Ym9keT5cIixcbiAgICAgICAgICAgIFwiPC90YWJsZT5cIixcbiAgICAgICAgICAgICc8aW5wdXQgdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiYnRuIGJ0bi1wcmltYXJ5XCIgaWQ9XCJmcm9tX3dvcmtmbG93XCIgdmFsdWU9XCJBZGQgZnJvbSB3b3JrZmxvd1wiIC8+JyxcbiAgICAgICAgICAgIFwiPC9kaXY+XCJcbiAgICAgICAgXS5qb2luKFwiXCIpXG4gICAgKVxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgICBSZXBvUXVldWVWaWV3OiBWaWV3XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGdhbGF4eS9zY3JpcHRzL212Yy90b29sc2hlZC9yZXBvc2l0b3J5LXF1ZXVlLXZpZXcuanMiXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7OztBQUFBO0FBQ0E7OztBQUFBO0FBQ0E7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBSEE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBL0dBO0FBQ0E7QUF1SkE7QUFDQTtBQURBO0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///311\n");

/***/ }),

/***/ 312:
/*!*********************************************************!*\
  !*** ./galaxy/scripts/mvc/toolshed/repo-status-view.js ***!
  \*********************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(Backbone, _, $) {\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _localization = __webpack_require__(/*! utils/localization */ 3);\n\nvar _localization2 = _interopRequireDefault(_localization);\n\nvar _toolshedModel = __webpack_require__(/*! mvc/toolshed/toolshed-model */ 17);\n\nvar _toolshedModel2 = _interopRequireDefault(_toolshedModel);\n\nvar _util = __webpack_require__(/*! mvc/toolshed/util */ 18);\n\nvar _util2 = _interopRequireDefault(_util);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar ToolShedRepoStatusView = Backbone.View.extend({\n    el: \"#center\",\n\n    initialize: function initialize(options) {\n        var self = this;\n        this.options = _.defaults(this.options || [{}], options, this.defaults);\n        this.model = new _toolshedModel2.default.RepoStatus();\n        this.listenTo(this.model, \"sync\", this.render);\n        this.model.url += \"?repositories=\" + this.options.repositories.join(\"|\");\n        this.model.fetch();\n        this.timer = setInterval(function (self) {\n            var terminal_states = [\"installed\", \"error\"];\n            var all_done = true;\n            _.some(self.model.models, function (repository) {\n                repo_id = repository.get(\"id\");\n                var repo_status = repository.get(\"status\").toLowerCase();\n                if (terminal_states.indexOf(repo_status) === -1) {\n                    all_done = false;\n                    return true;\n                }\n            });\n            if (all_done) {\n                clearInterval(self.timer);\n            } else {\n                self.model.fetch();\n            }\n        }, 2000, this);\n    },\n\n    close: function close() {\n        clearInterval(this.timer);\n    },\n\n    render: function render(options) {\n        this.options = _.extend(this.options, options);\n        var repo_status_template = this.templateRepoStatus;\n        this.$el.html(repo_status_template({\n            title: (0, _localization2.default)(\"Repository Status\"),\n            repositories: this.model.models,\n            queue: _util2.default.queueLength()\n        }));\n        $(\"#center\").css(\"overflow\", \"auto\");\n        this.bindEvents();\n    },\n\n    bindEvents: function bindEvents() {\n        var that = this;\n    },\n\n    reDraw: function reDraw(options) {\n        this.$el.empty();\n        this.initialize(options);\n    },\n\n    templateRepoStatus: _.template(['<div class=\"unified-panel-header\" id=\"panel_header\" unselectable=\"on\">', '<div class=\"unified-panel-header-inner\"><%= title %></div>', '<div class=\"unified-panel-header-inner\" style=\"position: absolute; right: 5px; top: 0px;\"><a href=\"#/queue\">Repository Queue (<%= queue %>)</a></div>', \"</div>\", '<style type=\"text/css\">', \".state-color-new,\", \".state-color-deactivated,\", \".state-color-uninstalled { border-color:#bfbfbf; background:#eee }\", \".state-color-cloning,\", \".state-color-setting-tool-versions,\", \".state-color-installing-repository-dependencies,\", \".state-color-installing-tool-dependencies,\", \".state-color-loading-proprietary-datatypes { border-color:#AAAA66; background:#FFFFCC }\", \".state-color-installed { border-color:#20b520; background:#b0f1b0 }\", \".state-color-error { border-color:#dd1b15; background:#f9c7c5 }\", \"</style>\", '<table id=\"grid-table\" class=\"grid\">', '<thead id=\"grid-table-header\">', \"<tr>\", '<th id=\"null-header\">Name<span class=\"sort-arrow\"></span></th>', '<th id=\"null-header\">Description<span class=\"sort-arrow\"></span></th>', '<th id=\"null-header\">Owner<span class=\"sort-arrow\"></span></th>', '<th id=\"null-header\">Revision<span class=\"sort-arrow\"></span></th>', '<th id=\"null-header\">Installation Status<span class=\"sort-arrow\"></span></th>', \"</tr>\", \"</thead>\", '<tbody id=\"grid-table-body\">', \"<% _.each(repositories, function(repository) { %>\", \"<tr>\", \"<td>\", '<div id=\"\" class=\"\">', '<label id=\"repo-name-<%= repository.get(\"id\") %>\" for=\"<%= repository.get(\"id\") %>\">', '<%= repository.get(\"name\") %>', \"</label>\", \"</div>\", \"</td>\", \"<td>\", '<div id=\"\" class=\"\">', '<label id=\"repo-desc-<%= repository.get(\"id\") %>\" for=\"<%= repository.get(\"id\") %>\">', '<%= repository.get(\"description\") %>', \"</label>\", \"</div>\", \"</td>\", \"<td>\", '<div id=\"\" class=\"\">', '<label id=\"repo-user-<%= repository.get(\"id\") %>\" for=\"<%= repository.get(\"id\") %>\">', '<%= repository.get(\"owner\") %>', \"</label>\", \"</div>\", \"</td>\", \"<td>\", '<div id=\"\" class=\"\">', '<label id=\"repo-changeset-<%= repository.get(\"id\") %>\" for=\"<%= repository.get(\"id\") %>\">', '<%= repository.get(\"changeset_revision\") %>', \"</label>\", \"</div>\", \"</td>\", \"<td>\", '<div id=\"\" class=\"\">', '<label id=\"RepositoryStatus-<%= repository.get(\"id\") %>\" for=\"<%= repository.get(\"id\") %>\">', '<div class=\"repo-status count-box state-color-<%= repository.get(\"status\").toLowerCase().replace(/ /g, \"-\") %>\" id=\"RepositoryStatus-<%= repository.get(\"id\") %>\">', '<%= repository.get(\"status\") %>', \"</div>\", \"</label>\", \"</div>\", \"</td>\", \"</tr>\", \"<% }); %>\", \"</tbody>\", '<tfoot id=\"grid-table-footer\"></tfoot>', \"</table>\"].join(\"\"))\n});\n\nexports.default = {\n    RepoStatus: ToolShedRepoStatusView\n};\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! libs/backbone */ 2), __webpack_require__(/*! underscore */ 1), __webpack_require__(/*! jquery */ 0)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzEyLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL2dhbGF4eS9zY3JpcHRzL212Yy90b29sc2hlZC9yZXBvLXN0YXR1cy12aWV3LmpzPzU5YTgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IF9sIGZyb20gXCJ1dGlscy9sb2NhbGl6YXRpb25cIjtcbmltcG9ydCB0b29sc2hlZF9tb2RlbCBmcm9tIFwibXZjL3Rvb2xzaGVkL3Rvb2xzaGVkLW1vZGVsXCI7XG5pbXBvcnQgdG9vbHNoZWRfdXRpbCBmcm9tIFwibXZjL3Rvb2xzaGVkL3V0aWxcIjtcbnZhciBUb29sU2hlZFJlcG9TdGF0dXNWaWV3ID0gQmFja2JvbmUuVmlldy5leHRlbmQoe1xuICAgIGVsOiBcIiNjZW50ZXJcIixcblxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBfLmRlZmF1bHRzKHRoaXMub3B0aW9ucyB8fCBbe31dLCBvcHRpb25zLCB0aGlzLmRlZmF1bHRzKTtcbiAgICAgICAgdGhpcy5tb2RlbCA9IG5ldyB0b29sc2hlZF9tb2RlbC5SZXBvU3RhdHVzKCk7XG4gICAgICAgIHRoaXMubGlzdGVuVG8odGhpcy5tb2RlbCwgXCJzeW5jXCIsIHRoaXMucmVuZGVyKTtcbiAgICAgICAgdGhpcy5tb2RlbC51cmwgKz0gYD9yZXBvc2l0b3JpZXM9JHt0aGlzLm9wdGlvbnMucmVwb3NpdG9yaWVzLmpvaW4oXCJ8XCIpfWA7XG4gICAgICAgIHRoaXMubW9kZWwuZmV0Y2goKTtcbiAgICAgICAgdGhpcy50aW1lciA9IHNldEludGVydmFsKFxuICAgICAgICAgICAgc2VsZiA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIHRlcm1pbmFsX3N0YXRlcyA9IFtcImluc3RhbGxlZFwiLCBcImVycm9yXCJdO1xuICAgICAgICAgICAgICAgIHZhciBhbGxfZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgXy5zb21lKHNlbGYubW9kZWwubW9kZWxzLCByZXBvc2l0b3J5ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmVwb19pZCA9IHJlcG9zaXRvcnkuZ2V0KFwiaWRcIik7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXBvX3N0YXR1cyA9IHJlcG9zaXRvcnkuZ2V0KFwic3RhdHVzXCIpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ZXJtaW5hbF9zdGF0ZXMuaW5kZXhPZihyZXBvX3N0YXR1cykgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxfZG9uZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoYWxsX2RvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChzZWxmLnRpbWVyKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLm1vZGVsLmZldGNoKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIDIwMDAsXG4gICAgICAgICAgICB0aGlzXG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIGNsb3NlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLnRpbWVyKTtcbiAgICB9LFxuXG4gICAgcmVuZGVyOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IF8uZXh0ZW5kKHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG4gICAgICAgIHZhciByZXBvX3N0YXR1c190ZW1wbGF0ZSA9IHRoaXMudGVtcGxhdGVSZXBvU3RhdHVzO1xuICAgICAgICB0aGlzLiRlbC5odG1sKFxuICAgICAgICAgICAgcmVwb19zdGF0dXNfdGVtcGxhdGUoe1xuICAgICAgICAgICAgICAgIHRpdGxlOiBfbChcIlJlcG9zaXRvcnkgU3RhdHVzXCIpLFxuICAgICAgICAgICAgICAgIHJlcG9zaXRvcmllczogdGhpcy5tb2RlbC5tb2RlbHMsXG4gICAgICAgICAgICAgICAgcXVldWU6IHRvb2xzaGVkX3V0aWwucXVldWVMZW5ndGgoKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgICAgJChcIiNjZW50ZXJcIikuY3NzKFwib3ZlcmZsb3dcIiwgXCJhdXRvXCIpO1xuICAgICAgICB0aGlzLmJpbmRFdmVudHMoKTtcbiAgICB9LFxuXG4gICAgYmluZEV2ZW50czogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICB9LFxuXG4gICAgcmVEcmF3OiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuJGVsLmVtcHR5KCk7XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZShvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgdGVtcGxhdGVSZXBvU3RhdHVzOiBfLnRlbXBsYXRlKFxuICAgICAgICBbXG4gICAgICAgICAgICAnPGRpdiBjbGFzcz1cInVuaWZpZWQtcGFuZWwtaGVhZGVyXCIgaWQ9XCJwYW5lbF9oZWFkZXJcIiB1bnNlbGVjdGFibGU9XCJvblwiPicsXG4gICAgICAgICAgICAnPGRpdiBjbGFzcz1cInVuaWZpZWQtcGFuZWwtaGVhZGVyLWlubmVyXCI+PCU9IHRpdGxlICU+PC9kaXY+JyxcbiAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwidW5pZmllZC1wYW5lbC1oZWFkZXItaW5uZXJcIiBzdHlsZT1cInBvc2l0aW9uOiBhYnNvbHV0ZTsgcmlnaHQ6IDVweDsgdG9wOiAwcHg7XCI+PGEgaHJlZj1cIiMvcXVldWVcIj5SZXBvc2l0b3J5IFF1ZXVlICg8JT0gcXVldWUgJT4pPC9hPjwvZGl2PicsXG4gICAgICAgICAgICBcIjwvZGl2PlwiLFxuICAgICAgICAgICAgJzxzdHlsZSB0eXBlPVwidGV4dC9jc3NcIj4nLFxuICAgICAgICAgICAgXCIuc3RhdGUtY29sb3ItbmV3LFwiLFxuICAgICAgICAgICAgXCIuc3RhdGUtY29sb3ItZGVhY3RpdmF0ZWQsXCIsXG4gICAgICAgICAgICBcIi5zdGF0ZS1jb2xvci11bmluc3RhbGxlZCB7IGJvcmRlci1jb2xvcjojYmZiZmJmOyBiYWNrZ3JvdW5kOiNlZWUgfVwiLFxuICAgICAgICAgICAgXCIuc3RhdGUtY29sb3ItY2xvbmluZyxcIixcbiAgICAgICAgICAgIFwiLnN0YXRlLWNvbG9yLXNldHRpbmctdG9vbC12ZXJzaW9ucyxcIixcbiAgICAgICAgICAgIFwiLnN0YXRlLWNvbG9yLWluc3RhbGxpbmctcmVwb3NpdG9yeS1kZXBlbmRlbmNpZXMsXCIsXG4gICAgICAgICAgICBcIi5zdGF0ZS1jb2xvci1pbnN0YWxsaW5nLXRvb2wtZGVwZW5kZW5jaWVzLFwiLFxuICAgICAgICAgICAgXCIuc3RhdGUtY29sb3ItbG9hZGluZy1wcm9wcmlldGFyeS1kYXRhdHlwZXMgeyBib3JkZXItY29sb3I6I0FBQUE2NjsgYmFja2dyb3VuZDojRkZGRkNDIH1cIixcbiAgICAgICAgICAgIFwiLnN0YXRlLWNvbG9yLWluc3RhbGxlZCB7IGJvcmRlci1jb2xvcjojMjBiNTIwOyBiYWNrZ3JvdW5kOiNiMGYxYjAgfVwiLFxuICAgICAgICAgICAgXCIuc3RhdGUtY29sb3ItZXJyb3IgeyBib3JkZXItY29sb3I6I2RkMWIxNTsgYmFja2dyb3VuZDojZjljN2M1IH1cIixcbiAgICAgICAgICAgIFwiPC9zdHlsZT5cIixcbiAgICAgICAgICAgICc8dGFibGUgaWQ9XCJncmlkLXRhYmxlXCIgY2xhc3M9XCJncmlkXCI+JyxcbiAgICAgICAgICAgICc8dGhlYWQgaWQ9XCJncmlkLXRhYmxlLWhlYWRlclwiPicsXG4gICAgICAgICAgICBcIjx0cj5cIixcbiAgICAgICAgICAgICc8dGggaWQ9XCJudWxsLWhlYWRlclwiPk5hbWU8c3BhbiBjbGFzcz1cInNvcnQtYXJyb3dcIj48L3NwYW4+PC90aD4nLFxuICAgICAgICAgICAgJzx0aCBpZD1cIm51bGwtaGVhZGVyXCI+RGVzY3JpcHRpb248c3BhbiBjbGFzcz1cInNvcnQtYXJyb3dcIj48L3NwYW4+PC90aD4nLFxuICAgICAgICAgICAgJzx0aCBpZD1cIm51bGwtaGVhZGVyXCI+T3duZXI8c3BhbiBjbGFzcz1cInNvcnQtYXJyb3dcIj48L3NwYW4+PC90aD4nLFxuICAgICAgICAgICAgJzx0aCBpZD1cIm51bGwtaGVhZGVyXCI+UmV2aXNpb248c3BhbiBjbGFzcz1cInNvcnQtYXJyb3dcIj48L3NwYW4+PC90aD4nLFxuICAgICAgICAgICAgJzx0aCBpZD1cIm51bGwtaGVhZGVyXCI+SW5zdGFsbGF0aW9uIFN0YXR1czxzcGFuIGNsYXNzPVwic29ydC1hcnJvd1wiPjwvc3Bhbj48L3RoPicsXG4gICAgICAgICAgICBcIjwvdHI+XCIsXG4gICAgICAgICAgICBcIjwvdGhlYWQ+XCIsXG4gICAgICAgICAgICAnPHRib2R5IGlkPVwiZ3JpZC10YWJsZS1ib2R5XCI+JyxcbiAgICAgICAgICAgIFwiPCUgXy5lYWNoKHJlcG9zaXRvcmllcywgZnVuY3Rpb24ocmVwb3NpdG9yeSkgeyAlPlwiLFxuICAgICAgICAgICAgXCI8dHI+XCIsXG4gICAgICAgICAgICBcIjx0ZD5cIixcbiAgICAgICAgICAgICc8ZGl2IGlkPVwiXCIgY2xhc3M9XCJcIj4nLFxuICAgICAgICAgICAgJzxsYWJlbCBpZD1cInJlcG8tbmFtZS08JT0gcmVwb3NpdG9yeS5nZXQoXCJpZFwiKSAlPlwiIGZvcj1cIjwlPSByZXBvc2l0b3J5LmdldChcImlkXCIpICU+XCI+JyxcbiAgICAgICAgICAgICc8JT0gcmVwb3NpdG9yeS5nZXQoXCJuYW1lXCIpICU+JyxcbiAgICAgICAgICAgIFwiPC9sYWJlbD5cIixcbiAgICAgICAgICAgIFwiPC9kaXY+XCIsXG4gICAgICAgICAgICBcIjwvdGQ+XCIsXG4gICAgICAgICAgICBcIjx0ZD5cIixcbiAgICAgICAgICAgICc8ZGl2IGlkPVwiXCIgY2xhc3M9XCJcIj4nLFxuICAgICAgICAgICAgJzxsYWJlbCBpZD1cInJlcG8tZGVzYy08JT0gcmVwb3NpdG9yeS5nZXQoXCJpZFwiKSAlPlwiIGZvcj1cIjwlPSByZXBvc2l0b3J5LmdldChcImlkXCIpICU+XCI+JyxcbiAgICAgICAgICAgICc8JT0gcmVwb3NpdG9yeS5nZXQoXCJkZXNjcmlwdGlvblwiKSAlPicsXG4gICAgICAgICAgICBcIjwvbGFiZWw+XCIsXG4gICAgICAgICAgICBcIjwvZGl2PlwiLFxuICAgICAgICAgICAgXCI8L3RkPlwiLFxuICAgICAgICAgICAgXCI8dGQ+XCIsXG4gICAgICAgICAgICAnPGRpdiBpZD1cIlwiIGNsYXNzPVwiXCI+JyxcbiAgICAgICAgICAgICc8bGFiZWwgaWQ9XCJyZXBvLXVzZXItPCU9IHJlcG9zaXRvcnkuZ2V0KFwiaWRcIikgJT5cIiBmb3I9XCI8JT0gcmVwb3NpdG9yeS5nZXQoXCJpZFwiKSAlPlwiPicsXG4gICAgICAgICAgICAnPCU9IHJlcG9zaXRvcnkuZ2V0KFwib3duZXJcIikgJT4nLFxuICAgICAgICAgICAgXCI8L2xhYmVsPlwiLFxuICAgICAgICAgICAgXCI8L2Rpdj5cIixcbiAgICAgICAgICAgIFwiPC90ZD5cIixcbiAgICAgICAgICAgIFwiPHRkPlwiLFxuICAgICAgICAgICAgJzxkaXYgaWQ9XCJcIiBjbGFzcz1cIlwiPicsXG4gICAgICAgICAgICAnPGxhYmVsIGlkPVwicmVwby1jaGFuZ2VzZXQtPCU9IHJlcG9zaXRvcnkuZ2V0KFwiaWRcIikgJT5cIiBmb3I9XCI8JT0gcmVwb3NpdG9yeS5nZXQoXCJpZFwiKSAlPlwiPicsXG4gICAgICAgICAgICAnPCU9IHJlcG9zaXRvcnkuZ2V0KFwiY2hhbmdlc2V0X3JldmlzaW9uXCIpICU+JyxcbiAgICAgICAgICAgIFwiPC9sYWJlbD5cIixcbiAgICAgICAgICAgIFwiPC9kaXY+XCIsXG4gICAgICAgICAgICBcIjwvdGQ+XCIsXG4gICAgICAgICAgICBcIjx0ZD5cIixcbiAgICAgICAgICAgICc8ZGl2IGlkPVwiXCIgY2xhc3M9XCJcIj4nLFxuICAgICAgICAgICAgJzxsYWJlbCBpZD1cIlJlcG9zaXRvcnlTdGF0dXMtPCU9IHJlcG9zaXRvcnkuZ2V0KFwiaWRcIikgJT5cIiBmb3I9XCI8JT0gcmVwb3NpdG9yeS5nZXQoXCJpZFwiKSAlPlwiPicsXG4gICAgICAgICAgICAnPGRpdiBjbGFzcz1cInJlcG8tc3RhdHVzIGNvdW50LWJveCBzdGF0ZS1jb2xvci08JT0gcmVwb3NpdG9yeS5nZXQoXCJzdGF0dXNcIikudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC8gL2csIFwiLVwiKSAlPlwiIGlkPVwiUmVwb3NpdG9yeVN0YXR1cy08JT0gcmVwb3NpdG9yeS5nZXQoXCJpZFwiKSAlPlwiPicsXG4gICAgICAgICAgICAnPCU9IHJlcG9zaXRvcnkuZ2V0KFwic3RhdHVzXCIpICU+JyxcbiAgICAgICAgICAgIFwiPC9kaXY+XCIsXG4gICAgICAgICAgICBcIjwvbGFiZWw+XCIsXG4gICAgICAgICAgICBcIjwvZGl2PlwiLFxuICAgICAgICAgICAgXCI8L3RkPlwiLFxuICAgICAgICAgICAgXCI8L3RyPlwiLFxuICAgICAgICAgICAgXCI8JSB9KTsgJT5cIixcbiAgICAgICAgICAgIFwiPC90Ym9keT5cIixcbiAgICAgICAgICAgICc8dGZvb3QgaWQ9XCJncmlkLXRhYmxlLWZvb3RlclwiPjwvdGZvb3Q+JyxcbiAgICAgICAgICAgIFwiPC90YWJsZT5cIlxuICAgICAgICBdLmpvaW4oXCJcIilcbiAgICApXG59KTtcblxuZXhwb3J0IGRlZmF1bHQge1xuICAgIFJlcG9TdGF0dXM6IFRvb2xTaGVkUmVwb1N0YXR1c1ZpZXdcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gZ2FsYXh5L3NjcmlwdHMvbXZjL3Rvb2xzaGVkL3JlcG8tc3RhdHVzLXZpZXcuanMiXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7OztBQUFBO0FBQ0E7OztBQUFBO0FBQ0E7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFIQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUE1REE7QUFDQTtBQXdJQTtBQUNBO0FBREE7QSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///312\n");

/***/ }),

/***/ 313:
/*!*******************************************************!*\
  !*** ./galaxy/scripts/mvc/toolshed/workflows-view.js ***!
  \*******************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(Backbone, $, _) {\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _localization = __webpack_require__(/*! utils/localization */ 3);\n\nvar _localization2 = _interopRequireDefault(_localization);\n\nvar _toolshedModel = __webpack_require__(/*! mvc/toolshed/toolshed-model */ 17);\n\nvar _toolshedModel2 = _interopRequireDefault(_toolshedModel);\n\nvar _util = __webpack_require__(/*! mvc/toolshed/util */ 18);\n\nvar _util2 = _interopRequireDefault(_util);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar View = Backbone.View.extend({\n    el: \"#center\",\n\n    defaults: [{}],\n\n    initialize: function initialize(options) {\n        var that = this;\n        this.model = new _toolshedModel2.default.WorkflowTools();\n        this.listenTo(this.model, \"sync\", this.render);\n        this.model.fetch();\n        that.render();\n    },\n\n    render: function render(options) {\n        var that = this;\n        var workflows_missing_tools = that.templateWorkflows;\n        var workflows = that.model.models;\n        that.$el.html(workflows_missing_tools({\n            title: (0, _localization2.default)(\"Workflows Missing Tools\"),\n            workflows: workflows,\n            queue: _util2.default.queueLength()\n        }));\n        $(\"#center\").css(\"overflow\", \"auto\");\n        that.bindEvents();\n    },\n\n    bindEvents: function bindEvents() {\n        var that = this;\n        var repository_id;\n        $(\".show_wf_repo\").on(\"click\", function () {\n            var tool_ids = $(this).attr(\"data-toolids\");\n            var toolshed = $(this).attr(\"data-shed\");\n            var api_url = Galaxy.root + \"api/tool_shed/repository\";\n            var params = { tool_ids: tool_ids };\n            $.get(api_url, params, function (data) {\n                repository_id = data.repository.id;\n                var new_route = \"repository/s/\" + toolshed.replace(/:/g, \"%3a\").replace(/\\//g, \"%2f\") + \"/r/\" + data.repository.id;\n                Backbone.history.navigate(new_route, {\n                    trigger: true,\n                    replace: true\n                });\n            });\n        });\n        $(\".queue_wf_repo\").on(\"click\", function () {\n            var elem = $(this);\n            var tool_ids = elem.attr(\"data-toolids\");\n            var toolshed = elem.attr(\"data-shed\");\n            var api_url = Galaxy.root + \"api/tool_shed/repository\";\n            var params = { tool_ids: tool_ids };\n            $.get(api_url, params, function (data) {\n                repository_id = data.repository.id;\n                params = {\n                    tool_shed_url: toolshed,\n                    repository_id: repository_id\n                };\n                $.get(api_url, params, function (data) {\n                    var changesets = Object.keys(data.repository.metadata);\n                    var current_changeset = changesets[0];\n                    var current_metadata = data.repository.metadata[current_changeset];\n                    current_metadata.tool_shed_url = toolshed;\n                    _util2.default.addToQueue(current_metadata);\n                    elem.remove();\n                });\n            });\n        });\n        $(\"#from_workflow\").on(\"click\", that.loadWorkflows);\n    },\n\n    reDraw: function reDraw(options) {\n        this.$el.empty();\n        this.initialize(options);\n    },\n\n    templateWorkflows: _.template(['<div class=\"unified-panel-header\" id=\"panel_header\" unselectable=\"on\">', '<div class=\"unified-panel-header-inner\"><%= title %></div>', '<div class=\"unified-panel-header-inner\" style=\"position: absolute; right: 5px; top: 0px;\"><a href=\"#/queue\">Repository Queue (<%= queue %>)</a></div>', \"</div>\", '<style type=\"text/css\">', \".workflow_names, .workflow_tools { list-style-type: none; } ul.workflow_tools, ul.workflow_names {  padding-left: 0px; }\", \"</style>\", '<table id=\"workflows_missing_tools\" class=\"grid\" border=\"0\" cellpadding=\"2\" cellspacing=\"2\" width=\"100%\">', '<thead id=\"grid-table-header\">', \"<tr>\", '<th class=\"datasetRow\">Workflows</th>', '<th class=\"datasetRow\">Tool IDs</th>', '<th class=\"datasetRow\">Shed</th>', '<th class=\"datasetRow\">Name</th>', '<th class=\"datasetRow\">Owner</th>', '<th class=\"datasetRow\">Actions</th>', \"</tr>\", \"</thead>\", \"<tbody>\", \"<% _.each(workflows, function(workflow) { %>\", \"<tr>\", '<td class=\"datasetRow\">', '<ul class=\"workflow_names\">', '<% _.each(workflow.get(\"workflows\"), function(name) { %>', '<li class=\"workflow_names\"><%= name %></li>', \"<% }); %>\", \"</ul>\", \"</td>\", '<td class=\"datasetRow\">', '<ul class=\"workflow_tools\">', '<% _.each(workflow.get(\"tools\"), function(tool) { %>', '<li class=\"workflow_tools\"><%= tool %></li>', \"<% }); %>\", \"</ul>\", \"</td>\", '<td class=\"datasetRow\"><%= workflow.get(\"shed\") %></td>', '<td class=\"datasetRow\"><%= workflow.get(\"repository\") %></td>', '<td class=\"datasetRow\"><%= workflow.get(\"owner\") %></td>', '<td class=\"datasetRow\">', '<ul class=\"workflow_tools\">', '<li class=\"workflow_tools\">', '<input type=\"button\" class=\"show_wf_repo btn btn-primary\" data-shed=\"<%= workflow.get(\"shed\") %>\" data-owner=\"<%= workflow.get(\"owner\") %>\" data-repo=\"<%= workflow.get(\"repository\") %>\" data-toolids=\"<%= workflow.get(\"tools\").join(\",\") %>\" value=\"Show Repository\" /></li>', \"</ul>\", \"</td>\", \"</tr>\", \"<% }); %>\", \"</ul>\", \"</div>\"].join(\"\"))\n});\n\nexports.default = {\n    Workflows: View\n};\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! libs/backbone */ 2), __webpack_require__(/*! jquery */ 0), __webpack_require__(/*! underscore */ 1)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzEzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL2dhbGF4eS9zY3JpcHRzL212Yy90b29sc2hlZC93b3JrZmxvd3Mtdmlldy5qcz9mNGI2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBfbCBmcm9tIFwidXRpbHMvbG9jYWxpemF0aW9uXCI7XG5pbXBvcnQgdG9vbHNoZWRfbW9kZWwgZnJvbSBcIm12Yy90b29sc2hlZC90b29sc2hlZC1tb2RlbFwiO1xuaW1wb3J0IHRvb2xzaGVkX3V0aWwgZnJvbSBcIm12Yy90b29sc2hlZC91dGlsXCI7XG52YXIgVmlldyA9IEJhY2tib25lLlZpZXcuZXh0ZW5kKHtcbiAgICBlbDogXCIjY2VudGVyXCIsXG5cbiAgICBkZWZhdWx0czogW3t9XSxcblxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICB0aGlzLm1vZGVsID0gbmV3IHRvb2xzaGVkX21vZGVsLldvcmtmbG93VG9vbHMoKTtcbiAgICAgICAgdGhpcy5saXN0ZW5Ubyh0aGlzLm1vZGVsLCBcInN5bmNcIiwgdGhpcy5yZW5kZXIpO1xuICAgICAgICB0aGlzLm1vZGVsLmZldGNoKCk7XG4gICAgICAgIHRoYXQucmVuZGVyKCk7XG4gICAgfSxcblxuICAgIHJlbmRlcjogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgIHZhciB3b3JrZmxvd3NfbWlzc2luZ190b29scyA9IHRoYXQudGVtcGxhdGVXb3JrZmxvd3M7XG4gICAgICAgIHZhciB3b3JrZmxvd3MgPSB0aGF0Lm1vZGVsLm1vZGVscztcbiAgICAgICAgdGhhdC4kZWwuaHRtbChcbiAgICAgICAgICAgIHdvcmtmbG93c19taXNzaW5nX3Rvb2xzKHtcbiAgICAgICAgICAgICAgICB0aXRsZTogX2woXCJXb3JrZmxvd3MgTWlzc2luZyBUb29sc1wiKSxcbiAgICAgICAgICAgICAgICB3b3JrZmxvd3M6IHdvcmtmbG93cyxcbiAgICAgICAgICAgICAgICBxdWV1ZTogdG9vbHNoZWRfdXRpbC5xdWV1ZUxlbmd0aCgpXG4gICAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgICAkKFwiI2NlbnRlclwiKS5jc3MoXCJvdmVyZmxvd1wiLCBcImF1dG9cIik7XG4gICAgICAgIHRoYXQuYmluZEV2ZW50cygpO1xuICAgIH0sXG5cbiAgICBiaW5kRXZlbnRzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICB2YXIgcmVwb3NpdG9yeV9pZDtcbiAgICAgICAgJChcIi5zaG93X3dmX3JlcG9cIikub24oXCJjbGlja1wiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciB0b29sX2lkcyA9ICQodGhpcykuYXR0cihcImRhdGEtdG9vbGlkc1wiKTtcbiAgICAgICAgICAgIHZhciB0b29sc2hlZCA9ICQodGhpcykuYXR0cihcImRhdGEtc2hlZFwiKTtcbiAgICAgICAgICAgIHZhciBhcGlfdXJsID0gYCR7R2FsYXh5LnJvb3R9YXBpL3Rvb2xfc2hlZC9yZXBvc2l0b3J5YDtcbiAgICAgICAgICAgIHZhciBwYXJhbXMgPSB7IHRvb2xfaWRzOiB0b29sX2lkcyB9O1xuICAgICAgICAgICAgJC5nZXQoYXBpX3VybCwgcGFyYW1zLCBkYXRhID0+IHtcbiAgICAgICAgICAgICAgICByZXBvc2l0b3J5X2lkID0gZGF0YS5yZXBvc2l0b3J5LmlkO1xuICAgICAgICAgICAgICAgIHZhciBuZXdfcm91dGUgPSBgcmVwb3NpdG9yeS9zLyR7dG9vbHNoZWQucmVwbGFjZSgvOi9nLCBcIiUzYVwiKS5yZXBsYWNlKC9cXC8vZywgXCIlMmZcIil9L3IvJHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5yZXBvc2l0b3J5LmlkXG4gICAgICAgICAgICAgICAgfWA7XG4gICAgICAgICAgICAgICAgQmFja2JvbmUuaGlzdG9yeS5uYXZpZ2F0ZShuZXdfcm91dGUsIHtcbiAgICAgICAgICAgICAgICAgICAgdHJpZ2dlcjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgcmVwbGFjZTogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICAkKFwiLnF1ZXVlX3dmX3JlcG9cIikub24oXCJjbGlja1wiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBlbGVtID0gJCh0aGlzKTtcbiAgICAgICAgICAgIHZhciB0b29sX2lkcyA9IGVsZW0uYXR0cihcImRhdGEtdG9vbGlkc1wiKTtcbiAgICAgICAgICAgIHZhciB0b29sc2hlZCA9IGVsZW0uYXR0cihcImRhdGEtc2hlZFwiKTtcbiAgICAgICAgICAgIHZhciBhcGlfdXJsID0gYCR7R2FsYXh5LnJvb3R9YXBpL3Rvb2xfc2hlZC9yZXBvc2l0b3J5YDtcbiAgICAgICAgICAgIHZhciBwYXJhbXMgPSB7IHRvb2xfaWRzOiB0b29sX2lkcyB9O1xuICAgICAgICAgICAgJC5nZXQoYXBpX3VybCwgcGFyYW1zLCBkYXRhID0+IHtcbiAgICAgICAgICAgICAgICByZXBvc2l0b3J5X2lkID0gZGF0YS5yZXBvc2l0b3J5LmlkO1xuICAgICAgICAgICAgICAgIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgdG9vbF9zaGVkX3VybDogdG9vbHNoZWQsXG4gICAgICAgICAgICAgICAgICAgIHJlcG9zaXRvcnlfaWQ6IHJlcG9zaXRvcnlfaWRcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICQuZ2V0KGFwaV91cmwsIHBhcmFtcywgZGF0YSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGFuZ2VzZXRzID0gT2JqZWN0LmtleXMoZGF0YS5yZXBvc2l0b3J5Lm1ldGFkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRfY2hhbmdlc2V0ID0gY2hhbmdlc2V0c1swXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRfbWV0YWRhdGEgPSBkYXRhLnJlcG9zaXRvcnkubWV0YWRhdGFbY3VycmVudF9jaGFuZ2VzZXRdO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50X21ldGFkYXRhLnRvb2xfc2hlZF91cmwgPSB0b29sc2hlZDtcbiAgICAgICAgICAgICAgICAgICAgdG9vbHNoZWRfdXRpbC5hZGRUb1F1ZXVlKGN1cnJlbnRfbWV0YWRhdGEpO1xuICAgICAgICAgICAgICAgICAgICBlbGVtLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICAkKFwiI2Zyb21fd29ya2Zsb3dcIikub24oXCJjbGlja1wiLCB0aGF0LmxvYWRXb3JrZmxvd3MpO1xuICAgIH0sXG5cbiAgICByZURyYXc6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy4kZWwuZW1wdHkoKTtcbiAgICAgICAgdGhpcy5pbml0aWFsaXplKG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICB0ZW1wbGF0ZVdvcmtmbG93czogXy50ZW1wbGF0ZShcbiAgICAgICAgW1xuICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJ1bmlmaWVkLXBhbmVsLWhlYWRlclwiIGlkPVwicGFuZWxfaGVhZGVyXCIgdW5zZWxlY3RhYmxlPVwib25cIj4nLFxuICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJ1bmlmaWVkLXBhbmVsLWhlYWRlci1pbm5lclwiPjwlPSB0aXRsZSAlPjwvZGl2PicsXG4gICAgICAgICAgICAnPGRpdiBjbGFzcz1cInVuaWZpZWQtcGFuZWwtaGVhZGVyLWlubmVyXCIgc3R5bGU9XCJwb3NpdGlvbjogYWJzb2x1dGU7IHJpZ2h0OiA1cHg7IHRvcDogMHB4O1wiPjxhIGhyZWY9XCIjL3F1ZXVlXCI+UmVwb3NpdG9yeSBRdWV1ZSAoPCU9IHF1ZXVlICU+KTwvYT48L2Rpdj4nLFxuICAgICAgICAgICAgXCI8L2Rpdj5cIixcbiAgICAgICAgICAgICc8c3R5bGUgdHlwZT1cInRleHQvY3NzXCI+JyxcbiAgICAgICAgICAgIFwiLndvcmtmbG93X25hbWVzLCAud29ya2Zsb3dfdG9vbHMgeyBsaXN0LXN0eWxlLXR5cGU6IG5vbmU7IH0gdWwud29ya2Zsb3dfdG9vbHMsIHVsLndvcmtmbG93X25hbWVzIHsgIHBhZGRpbmctbGVmdDogMHB4OyB9XCIsXG4gICAgICAgICAgICBcIjwvc3R5bGU+XCIsXG4gICAgICAgICAgICAnPHRhYmxlIGlkPVwid29ya2Zsb3dzX21pc3NpbmdfdG9vbHNcIiBjbGFzcz1cImdyaWRcIiBib3JkZXI9XCIwXCIgY2VsbHBhZGRpbmc9XCIyXCIgY2VsbHNwYWNpbmc9XCIyXCIgd2lkdGg9XCIxMDAlXCI+JyxcbiAgICAgICAgICAgICc8dGhlYWQgaWQ9XCJncmlkLXRhYmxlLWhlYWRlclwiPicsXG4gICAgICAgICAgICBcIjx0cj5cIixcbiAgICAgICAgICAgICc8dGggY2xhc3M9XCJkYXRhc2V0Um93XCI+V29ya2Zsb3dzPC90aD4nLFxuICAgICAgICAgICAgJzx0aCBjbGFzcz1cImRhdGFzZXRSb3dcIj5Ub29sIElEczwvdGg+JyxcbiAgICAgICAgICAgICc8dGggY2xhc3M9XCJkYXRhc2V0Um93XCI+U2hlZDwvdGg+JyxcbiAgICAgICAgICAgICc8dGggY2xhc3M9XCJkYXRhc2V0Um93XCI+TmFtZTwvdGg+JyxcbiAgICAgICAgICAgICc8dGggY2xhc3M9XCJkYXRhc2V0Um93XCI+T3duZXI8L3RoPicsXG4gICAgICAgICAgICAnPHRoIGNsYXNzPVwiZGF0YXNldFJvd1wiPkFjdGlvbnM8L3RoPicsXG4gICAgICAgICAgICBcIjwvdHI+XCIsXG4gICAgICAgICAgICBcIjwvdGhlYWQ+XCIsXG4gICAgICAgICAgICBcIjx0Ym9keT5cIixcbiAgICAgICAgICAgIFwiPCUgXy5lYWNoKHdvcmtmbG93cywgZnVuY3Rpb24od29ya2Zsb3cpIHsgJT5cIixcbiAgICAgICAgICAgIFwiPHRyPlwiLFxuICAgICAgICAgICAgJzx0ZCBjbGFzcz1cImRhdGFzZXRSb3dcIj4nLFxuICAgICAgICAgICAgJzx1bCBjbGFzcz1cIndvcmtmbG93X25hbWVzXCI+JyxcbiAgICAgICAgICAgICc8JSBfLmVhY2god29ya2Zsb3cuZ2V0KFwid29ya2Zsb3dzXCIpLCBmdW5jdGlvbihuYW1lKSB7ICU+JyxcbiAgICAgICAgICAgICc8bGkgY2xhc3M9XCJ3b3JrZmxvd19uYW1lc1wiPjwlPSBuYW1lICU+PC9saT4nLFxuICAgICAgICAgICAgXCI8JSB9KTsgJT5cIixcbiAgICAgICAgICAgIFwiPC91bD5cIixcbiAgICAgICAgICAgIFwiPC90ZD5cIixcbiAgICAgICAgICAgICc8dGQgY2xhc3M9XCJkYXRhc2V0Um93XCI+JyxcbiAgICAgICAgICAgICc8dWwgY2xhc3M9XCJ3b3JrZmxvd190b29sc1wiPicsXG4gICAgICAgICAgICAnPCUgXy5lYWNoKHdvcmtmbG93LmdldChcInRvb2xzXCIpLCBmdW5jdGlvbih0b29sKSB7ICU+JyxcbiAgICAgICAgICAgICc8bGkgY2xhc3M9XCJ3b3JrZmxvd190b29sc1wiPjwlPSB0b29sICU+PC9saT4nLFxuICAgICAgICAgICAgXCI8JSB9KTsgJT5cIixcbiAgICAgICAgICAgIFwiPC91bD5cIixcbiAgICAgICAgICAgIFwiPC90ZD5cIixcbiAgICAgICAgICAgICc8dGQgY2xhc3M9XCJkYXRhc2V0Um93XCI+PCU9IHdvcmtmbG93LmdldChcInNoZWRcIikgJT48L3RkPicsXG4gICAgICAgICAgICAnPHRkIGNsYXNzPVwiZGF0YXNldFJvd1wiPjwlPSB3b3JrZmxvdy5nZXQoXCJyZXBvc2l0b3J5XCIpICU+PC90ZD4nLFxuICAgICAgICAgICAgJzx0ZCBjbGFzcz1cImRhdGFzZXRSb3dcIj48JT0gd29ya2Zsb3cuZ2V0KFwib3duZXJcIikgJT48L3RkPicsXG4gICAgICAgICAgICAnPHRkIGNsYXNzPVwiZGF0YXNldFJvd1wiPicsXG4gICAgICAgICAgICAnPHVsIGNsYXNzPVwid29ya2Zsb3dfdG9vbHNcIj4nLFxuICAgICAgICAgICAgJzxsaSBjbGFzcz1cIndvcmtmbG93X3Rvb2xzXCI+JyxcbiAgICAgICAgICAgICc8aW5wdXQgdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwic2hvd193Zl9yZXBvIGJ0biBidG4tcHJpbWFyeVwiIGRhdGEtc2hlZD1cIjwlPSB3b3JrZmxvdy5nZXQoXCJzaGVkXCIpICU+XCIgZGF0YS1vd25lcj1cIjwlPSB3b3JrZmxvdy5nZXQoXCJvd25lclwiKSAlPlwiIGRhdGEtcmVwbz1cIjwlPSB3b3JrZmxvdy5nZXQoXCJyZXBvc2l0b3J5XCIpICU+XCIgZGF0YS10b29saWRzPVwiPCU9IHdvcmtmbG93LmdldChcInRvb2xzXCIpLmpvaW4oXCIsXCIpICU+XCIgdmFsdWU9XCJTaG93IFJlcG9zaXRvcnlcIiAvPjwvbGk+JyxcbiAgICAgICAgICAgIFwiPC91bD5cIixcbiAgICAgICAgICAgIFwiPC90ZD5cIixcbiAgICAgICAgICAgIFwiPC90cj5cIixcbiAgICAgICAgICAgIFwiPCUgfSk7ICU+XCIsXG4gICAgICAgICAgICBcIjwvdWw+XCIsXG4gICAgICAgICAgICBcIjwvZGl2PlwiXG4gICAgICAgIF0uam9pbihcIlwiKVxuICAgIClcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gICAgV29ya2Zsb3dzOiBWaWV3XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGdhbGF4eS9zY3JpcHRzL212Yy90b29sc2hlZC93b3JrZmxvd3Mtdmlldy5qcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTs7O0FBQUE7QUFDQTs7O0FBQUE7QUFDQTs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFIQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBN0VBO0FBQ0E7QUFrSUE7QUFDQTtBQURBO0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///313\n");

/***/ }),

/***/ 61:
/*!*******************************************************!*\
  !*** ./galaxy/scripts/mvc/workflow/workflow-icons.js ***!
  \*******************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = {\n    tool: \"fa-wrench\",\n    data_input: \"fa-file-o\",\n    data_collection_input: \"fa-folder-o\",\n    subworkflow: \"fa-sitemap fa-rotate-270\",\n    pause: \"fa-pause\"\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZ2FsYXh5L3NjcmlwdHMvbXZjL3dvcmtmbG93L3dvcmtmbG93LWljb25zLmpzPzVlZGQiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQge1xuICAgIHRvb2w6IFwiZmEtd3JlbmNoXCIsXG4gICAgZGF0YV9pbnB1dDogXCJmYS1maWxlLW9cIixcbiAgICBkYXRhX2NvbGxlY3Rpb25faW5wdXQ6IFwiZmEtZm9sZGVyLW9cIixcbiAgICBzdWJ3b3JrZmxvdzogXCJmYS1zaXRlbWFwIGZhLXJvdGF0ZS0yNzBcIixcbiAgICBwYXVzZTogXCJmYS1wYXVzZVwiXG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGdhbGF4eS9zY3JpcHRzL212Yy93b3JrZmxvdy93b3JrZmxvdy1pY29ucy5qcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///61\n");

/***/ })

},[284]);
//# sourceMappingURL=extended.js.map