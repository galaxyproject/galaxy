{"version":3,"sources":["mvc/history/history-model.js"],"names":["_","Backbone","History","Model","extend","_baseMvc2","default","LoggableMixin","mixin","SearchableModelMixin","_logNamespace","UPDATE_DELAY","defaults","model_class","id","name","state","deleted","contents_active","contents_states","contentsClass","_historyContents2","HistoryContents","searchAttributes","searchAliases","title","tag","initialize","historyJSON","options","this","logger","log","urlRoot","Galaxy","root","contents","historyId","get","order","_setUpListeners","updateTimeoutId","on","error","model","xhr","msg","details","clearUpdateTimeout","change:id","newId","_setUpCollectionListeners","listenTo","trigger","apply","jQuery","makeArray","arguments","contentsShown","contentsActive","shown","active","includeDeleted","includeHidden","hidden","nice_size","size","_utils2","bytesToString","_localization2","toJSON","prototype","call","key","ownedByCurrUser","user","isAnonymous","numOfUnfinishedJobs","unfinishedJobIds","length","numOfUnfinishedShownContents","runningAndActive","_fetchContentRelatedAttributes","contentRelatedAttrs","fetch","param","keys","join","_this","lastUpdateTime","allFetched","currentPage","fetchPage","fetchUpdated","done","response","status","serverResponseDatetime","Date","getResponseHeader","err","console","checkForUpdates","_this2","delay","refresh","_delayThenUpdate","setTimeout","historyData","clearTimeout","stopPolling","parse","parsed","nonReadyContentCount","create_time","update_time","fetchWithContents","self","view","then","history","setHistoryId","contentsOptions","fetchContents","fetchCurrentPage","_delete","when","save","purged","copy","current","allDatasets","undefined","Error","postData","history_id","setAsCurrent","getJSON","toString","_collectionSuper","_controlledFetchCollection2","InfinitelyScrollingCollection","HistoryCollection","limitOnFirstFetch","limitPerFetch","models","currentHistoryId","setUpListeners","url","change:deleted","remove","original","newData","setCurrent","oldCurrentId","_buildFetchData","_buildFetchFilters","filters","debug","fetchFirst","_this3","copied","silent","limit","encoded_id-in","fetchMore","comparators","superFilters","ascending","buildComparator","size-asc","sort","currentHistory","create","data","hdas","historyOptions","xhrOptions","collection","offset"],"mappings":"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","file":"../../../scripts/mvc/history/history-model.js","sourcesContent":["import HISTORY_CONTENTS from \"mvc/history/history-contents\";\nimport CONTROLLED_FETCH_COLLECTION from \"mvc/base/controlled-fetch-collection\";\nimport UTILS from \"utils/utils\";\nimport BASE_MVC from \"mvc/base-mvc\";\nimport _l from \"utils/localization\";\nimport * as _ from \"libs/underscore\";\nimport * as Backbone from \"libs/backbone\";\n\n/* global jQuery */\n/* global Galaxy */\n\n//==============================================================================\n/** @class Model for a Galaxy history resource - both a record of user\n *      tool use and a collection of the datasets those tools produced.\n *  @name History\n *  @augments Backbone.Model\n */\nvar History = Backbone.Model.extend(BASE_MVC.LoggableMixin).extend(\n    BASE_MVC.mixin(\n        BASE_MVC.SearchableModelMixin,\n        /** @lends History.prototype */ {\n            _logNamespace: \"history\",\n\n            /** ms between fetches when checking running jobs/datasets for updates */\n            UPDATE_DELAY: 4000,\n\n            // values from api (may need more)\n            defaults: {\n                model_class: \"History\",\n                id: null,\n                name: \"Unnamed History\",\n                state: \"new\",\n\n                deleted: false,\n                contents_active: {},\n                contents_states: {}\n            },\n\n            contentsClass: HISTORY_CONTENTS.HistoryContents,\n\n            /** What model fields to search with */\n            searchAttributes: [\"name\", \"annotation\", \"tags\"],\n\n            /** Adding title and singular tag */\n            searchAliases: {\n                title: \"name\",\n                tag: \"tags\"\n            },\n\n            // ........................................................................ set up/tear down\n            /** Set up the model\n             *  @param {Object} historyJSON model data for this History\n             *  @param {Object} options     any extra settings including logger\n             */\n            initialize: function(historyJSON, options) {\n                options = options || {};\n                this.logger = options.logger || null;\n                this.log(`${this}.initialize:`, historyJSON, options);\n\n                this.urlRoot = `${Galaxy.root}api/histories`;\n                /** HistoryContents collection of the HDAs contained in this history. */\n                this.contents = new this.contentsClass([], {\n                    history: this,\n                    historyId: this.get(\"id\"),\n                    order: options.order\n                });\n\n                this._setUpListeners();\n                this._setUpCollectionListeners();\n\n                /** cached timeout id for the dataset updater */\n                this.updateTimeoutId = null;\n            },\n\n            /** set up any event listeners for this history including those to the contained HDAs\n             *  events: error:contents  if an error occurred with the contents collection\n             */\n            _setUpListeners: function() {\n                // if the model's id changes ('current' or null -> an actual id), update the contents history_id\n                return this.on({\n                    error: function(model, xhr, options, msg, details) {\n                        this.clearUpdateTimeout();\n                    },\n                    \"change:id\": function(model, newId) {\n                        if (this.contents) {\n                            this.contents.historyId = newId;\n                        }\n                    }\n                });\n            },\n\n            /** event handlers for the contents submodels */\n            _setUpCollectionListeners: function() {\n                if (!this.contents) {\n                    return this;\n                }\n                // bubble up errors\n                return this.listenTo(this.contents, {\n                    error: function() {\n                        this.trigger.apply(this, jQuery.makeArray(arguments));\n                    }\n                });\n            },\n\n            // ........................................................................ derived attributes\n            /**  */\n            contentsShown: function() {\n                var contentsActive = this.get(\"contents_active\");\n                var shown = contentsActive.active || 0;\n                shown += this.contents.includeDeleted ? contentsActive.deleted : 0;\n                shown += this.contents.includeHidden ? contentsActive.hidden : 0;\n                return shown;\n            },\n\n            /** convert size in bytes to a more human readable version */\n            nice_size: function() {\n                var size = this.get(\"size\");\n                return size ? UTILS.bytesToString(size, true, 2) : _l(\"(empty)\");\n            },\n\n            /** override to add nice_size */\n            toJSON: function() {\n                return _.extend(Backbone.Model.prototype.toJSON.call(this), {\n                    nice_size: this.nice_size()\n                });\n            },\n\n            /** override to allow getting nice_size */\n            get: function(key) {\n                if (key === \"nice_size\") {\n                    return this.nice_size();\n                }\n                return Backbone.Model.prototype.get.apply(this, arguments);\n            },\n\n            // ........................................................................ common queries\n            /** T/F is this history owned by the current user (Galaxy.user)\n             *      Note: that this will return false for an anon user even if the history is theirs.\n             */\n            ownedByCurrUser: function() {\n                // no currUser\n                if (!Galaxy || !Galaxy.user) {\n                    return false;\n                }\n                // user is anon or history isn't owned\n                if (Galaxy.user.isAnonymous() || Galaxy.user.id !== this.get(\"user_id\")) {\n                    return false;\n                }\n                return true;\n            },\n\n            /** Return the number of running jobs assoc with this history (note: unknown === 0) */\n            numOfUnfinishedJobs: function() {\n                var unfinishedJobIds = this.get(\"non_ready_jobs\");\n                return unfinishedJobIds ? unfinishedJobIds.length : 0;\n            },\n\n            /** Return the number of running hda/hdcas in this history (note: unknown === 0) */\n            numOfUnfinishedShownContents: function() {\n                return this.contents.runningAndActive().length || 0;\n            },\n\n            // ........................................................................ updates\n            _fetchContentRelatedAttributes: function() {\n                var contentRelatedAttrs = [\"size\", \"non_ready_jobs\", \"contents_active\", \"hid_counter\"];\n                return this.fetch({\n                    data: jQuery.param({\n                        keys: contentRelatedAttrs.join(\",\")\n                    })\n                });\n            },\n\n            /** check for any changes since the last time we updated (or fetch all if ) */\n            refresh: function(options) {\n                // console.log( this + '.refresh' );\n                options = options || {};\n\n                // note if there was no previous update time, all summary contents will be fetched\n                var lastUpdateTime = this.lastUpdateTime;\n                // if we don't flip this, then a fully-fetched list will not be re-checked via fetch\n                this.contents.allFetched = false;\n                var fetchFn =\n                    this.contents.currentPage !== 0\n                        ? () => this.contents.fetchPage(this.contents.currentPage)\n                        : () => this.contents.fetchUpdated(lastUpdateTime);\n                // note: if there was no previous update time, all summary contents will be fetched\n                return fetchFn().done((response, status, xhr) => {\n                    var serverResponseDatetime;\n                    try {\n                        serverResponseDatetime = new Date(xhr.getResponseHeader(\"Date\"));\n                    } catch (err) {\n                        console.error(err);\n                    }\n                    this.lastUpdateTime = serverResponseDatetime || new Date();\n                    this.checkForUpdates(options);\n                });\n            },\n\n            /** continuously fetch updated contents every UPDATE_DELAY ms if this history's datasets or jobs are unfinished */\n            checkForUpdates: function(options) {\n                // console.log( this + '.checkForUpdates' );\n                options = options || {};\n                var delay = this.UPDATE_DELAY;\n                if (!this.id) {\n                    return;\n                }\n\n                var _delayThenUpdate = () => {\n                    // prevent buildup of updater timeouts by clearing previous if any, then set new and cache id\n                    this.clearUpdateTimeout();\n                    this.updateTimeoutId = setTimeout(() => {\n                        this.refresh(options);\n                    }, delay);\n                };\n\n                // if there are still datasets in the non-ready state, recurse into this function with the new time\n                var nonReadyContentCount = this.numOfUnfinishedShownContents();\n                // console.log( 'nonReadyContentCount:', nonReadyContentCount );\n                if (nonReadyContentCount > 0) {\n                    _delayThenUpdate();\n                } else {\n                    // no datasets are running, but currently runnning jobs may still produce new datasets\n                    // see if the history has any running jobs and continue to update if so\n                    // (also update the size for the user in either case)\n                    this._fetchContentRelatedAttributes().done(historyData => {\n                        // console.log( 'non_ready_jobs:', historyData.non_ready_jobs );\n                        if (this.numOfUnfinishedJobs() > 0) {\n                            _delayThenUpdate();\n                        } else {\n                            // otherwise, let listeners know that all updates have stopped\n                            this.trigger(\"ready\");\n                        }\n                    });\n                }\n            },\n\n            /** clear the timeout and the cached timeout id */\n            clearUpdateTimeout: function() {\n                if (this.updateTimeoutId) {\n                    clearTimeout(this.updateTimeoutId);\n                    this.updateTimeoutId = null;\n                }\n            },\n\n            stopPolling: function() {\n                this.clearUpdateTimeout();\n                if (this.contents) {\n                    this.contents.stopPolling();\n                }\n            },\n\n            // ........................................................................ ajax\n            /** override to use actual Dates objects for create/update times */\n            parse: function(response, options) {\n                var parsed = Backbone.Model.prototype.parse.call(this, response, options);\n                if (parsed.create_time) {\n                    parsed.create_time = new Date(parsed.create_time);\n                }\n                if (parsed.update_time) {\n                    parsed.update_time = new Date(parsed.update_time);\n                }\n                return parsed;\n            },\n\n            /** fetch this histories data (using options) then it's contents (using contentsOptions) */\n            fetchWithContents: function(options, contentsOptions) {\n                options = options || {};\n                var self = this;\n\n                // console.log( this + '.fetchWithContents' );\n                // TODO: push down to a base class\n                options.view = \"dev-detailed\";\n\n                // fetch history then use history data to fetch (paginated) contents\n                return this.fetch(options).then(function getContents(history) {\n                    self.contents.history = self;\n                    self.contents.setHistoryId(history.id);\n                    return self.fetchContents(contentsOptions);\n                });\n            },\n\n            /** fetch this histories contents, adjusting options based on the stored history preferences */\n            fetchContents: function(options) {\n                options = options || {};\n\n                // we're updating, reset the update time\n                this.lastUpdateTime = new Date();\n                return this.contents.fetchCurrentPage(options);\n            },\n\n            /** save this history, _Mark_ing it as deleted (just a flag) */\n            _delete: function(options) {\n                if (this.get(\"deleted\")) {\n                    return jQuery.when();\n                }\n                return this.save({ deleted: true }, options);\n            },\n            /** purge this history, _Mark_ing it as purged and removing all dataset data from the server */\n            purge: function(options) {\n                if (this.get(\"purged\")) {\n                    return jQuery.when();\n                }\n                return this.save({ deleted: true, purged: true }, options);\n            },\n            /** save this history, _Mark_ing it as undeleted */\n            undelete: function(options) {\n                if (!this.get(\"deleted\")) {\n                    return jQuery.when();\n                }\n                return this.save({ deleted: false }, options);\n            },\n\n            /** Make a copy of this history on the server\n             *  @param {Boolean} current    if true, set the copy as the new current history (default: true)\n             *  @param {String} name        name of new history (default: none - server sets to: Copy of <current name>)\n             *  @fires copied               passed this history and the response JSON from the copy\n             *  @returns {xhr}\n             */\n            copy: function(current, name, allDatasets) {\n                current = current !== undefined ? current : true;\n                if (!this.id) {\n                    throw new Error(\"You must set the history ID before copying it.\");\n                }\n\n                var postData = { history_id: this.id };\n                if (current) {\n                    postData.current = true;\n                }\n                if (name) {\n                    postData.name = name;\n                }\n                if (!allDatasets) {\n                    postData.all_datasets = false;\n                }\n                postData.view = \"dev-detailed\";\n\n                var history = this;\n                var copy = jQuery.post(this.urlRoot, postData);\n                // if current - queue to setAsCurrent before firing 'copied'\n                if (current) {\n                    return copy.then(response => {\n                        var newHistory = new History(response);\n                        return newHistory.setAsCurrent().done(() => {\n                            history.trigger(\"copied\", history, response);\n                        });\n                    });\n                }\n                return copy.done(response => {\n                    history.trigger(\"copied\", history, response);\n                });\n            },\n\n            setAsCurrent: function() {\n                var history = this;\n\n                var xhr = jQuery.getJSON(`${Galaxy.root}history/set_as_current?id=${this.id}`);\n\n                xhr.done(() => {\n                    history.trigger(\"set-as-current\", history);\n                });\n                return xhr;\n            },\n\n            // ........................................................................ misc\n            toString: function() {\n                return `History(${this.get(\"id\")},${this.get(\"name\")})`;\n            }\n        }\n    )\n);\n\n//==============================================================================\nvar _collectionSuper = CONTROLLED_FETCH_COLLECTION.InfinitelyScrollingCollection;\n/** @class A collection of histories (per user)\n *      that maintains the current history as the first in the collection.\n *  New or copied histories become the current history.\n */\nvar HistoryCollection = _collectionSuper.extend(BASE_MVC.LoggableMixin).extend({\n    _logNamespace: \"history\",\n\n    model: History,\n    /** @type {String} initial order used by collection */\n    order: \"update_time\",\n    /** @type {Number} limit used for the first fetch (or a reset) */\n    limitOnFirstFetch: 10,\n    /** @type {Number} limit used for each subsequent fetch */\n    limitPerFetch: 10,\n\n    initialize: function(models, options) {\n        options = options || {};\n        this.log(\"HistoryCollection.initialize\", models, options);\n        this.urlRoot = `${Galaxy.root}api/histories`;\n        _collectionSuper.prototype.initialize.call(this, models, options);\n\n        /** @type {boolean} should deleted histories be included */\n        this.includeDeleted = options.includeDeleted || false;\n\n        /** @type {String} encoded id of the history that's current */\n        this.currentHistoryId = options.currentHistoryId;\n\n        this.setUpListeners();\n        // note: models are sent to reset *after* this fn ends; up to this point\n        // the collection *is empty*\n    },\n\n    url: function() {\n        return this.urlRoot;\n    },\n\n    /** set up reflexive event handlers */\n    setUpListeners: function setUpListeners() {\n        return this.on({\n            // when a history is deleted, remove it from the collection (if optionally set to do so)\n            \"change:deleted\": function(history) {\n                // TODO: this becomes complicated when more filters are used\n                this.debug(\"change:deleted\", this.includeDeleted, history.get(\"deleted\"));\n                if (!this.includeDeleted && history.get(\"deleted\")) {\n                    this.remove(history);\n                }\n            },\n            // listen for a history copy, setting it to current\n            copied: function(original, newData) {\n                this.setCurrent(new History(newData, []));\n            },\n            // when a history is made current, track the id in the collection\n            \"set-as-current\": function(history) {\n                var oldCurrentId = this.currentHistoryId;\n                this.trigger(\"no-longer-current\", oldCurrentId);\n                this.currentHistoryId = history.id;\n            }\n        });\n    },\n\n    /** override to change view */\n    _buildFetchData: function(options) {\n        return _.extend(_collectionSuper.prototype._buildFetchData.call(this, options), {\n            view: \"dev-detailed\"\n        });\n    },\n\n    /** override to filter out deleted and purged */\n    _buildFetchFilters: function(options) {\n        var superFilters = _collectionSuper.prototype._buildFetchFilters.call(this, options) || {};\n        var filters = {};\n        if (this.includeDeleted !== true) {\n            filters.deleted = false;\n            filters.purged = false;\n        } else {\n            // force API to return both deleted and non\n            //TODO: when the API is updated, remove this\n            filters.deleted = null;\n        }\n        return _.defaults(superFilters, filters);\n    },\n\n    /** override to fetch current as well (as it may be outside the first 10, etc.) */\n    fetchFirst: function(options) {\n        // TODO: batch?\n        var xhr = jQuery.when();\n        if (this.currentHistoryId) {\n            xhr = _collectionSuper.prototype.fetchFirst.call(this, {\n                silent: true,\n                limit: 1,\n                filters: {\n                    \"encoded_id-in\": this.currentHistoryId,\n                    // without these a deleted current history will return [] here and block the other xhr\n                    deleted: null,\n                    purged: \"\"\n                }\n            });\n        }\n        return xhr.then(() => {\n            options = options || {};\n            options.offset = 0;\n            return this.fetchMore(options);\n        });\n    },\n\n    /** @type {Object} map of collection available sorting orders containing comparator fns */\n    comparators: _.extend(_.clone(_collectionSuper.prototype.comparators), {\n        name: BASE_MVC.buildComparator(\"name\", {\n            ascending: true\n        }),\n        \"name-dsc\": BASE_MVC.buildComparator(\"name\", {\n            ascending: false\n        }),\n        size: BASE_MVC.buildComparator(\"size\", {\n            ascending: false\n        }),\n        \"size-asc\": BASE_MVC.buildComparator(\"size\", {\n            ascending: true\n        })\n    }),\n\n    /** override to always have the current history first */\n    sort: function(options) {\n        options = options || {};\n        var silent = options.silent;\n        var currentHistory = this.remove(this.get(this.currentHistoryId));\n        _collectionSuper.prototype.sort.call(this, _.defaults({ silent: true }, options));\n        this.unshift(currentHistory, { silent: true });\n        if (!silent) {\n            this.trigger(\"sort\", this, options);\n        }\n        return this;\n    },\n\n    /** create a new history and by default set it to be the current history */\n    create: function create(data, hdas, historyOptions, xhrOptions) {\n        //TODO: .create is actually a collection function that's overridden here\n        var collection = this;\n\n        var xhr = jQuery.getJSON(`${Galaxy.root}history/create_new_current`);\n        return xhr.done(newData => {\n            collection.setCurrent(new History(newData, [], historyOptions || {}));\n        });\n    },\n\n    /** set the current history to the given history, placing it first in the collection.\n     *  Pass standard bbone options for use in unshift.\n     *  @triggers new-current passed history and this collection\n     */\n    setCurrent: function(history, options) {\n        options = options || {};\n        // new histories go in the front\n        this.unshift(history, options);\n        this.currentHistoryId = history.get(\"id\");\n        if (!options.silent) {\n            this.trigger(\"new-current\", history, this);\n        }\n        return this;\n    },\n\n    toString: function toString() {\n        return `HistoryCollection(${this.length},current:${this.currentHistoryId})`;\n    }\n});\n\n//==============================================================================\nexport default {\n    History: History,\n    HistoryCollection: HistoryCollection\n};\n"]}