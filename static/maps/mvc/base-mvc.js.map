{"version":3,"sources":["mvc/base-mvc.js"],"names":["_","Backbone","LoggableMixin","logger","_logNamespace","_addLogging2","default","SessionStorageModel","Model","extend","initialize","initialAttrs","this","_checkEnabledSessionStorage","id","Error","existing","isNew","_read","clear","silent","save","defaults","on","window","sessionStorage","err","alert","sync","options","model","trigger","returned","method","_create","_update","_delete","success","error","json","toJSON","setItem","JSON","stringify","set","DOMException","getItem","hasOwnProperty","_log","toString","parse","prototype","SearchableModelMixin","searchAttributes","args","searchAttribute","attrKey","searchFor","attrVal","get","undefined","isArray","toLowerCase","indexOf","_searchArrayAttribute","array","elem","filter","key","matches","term","split","length","searchAliases","search","matchesAll","terms","match","s","all","replace","HiddenUntilActivatedViewMixin","hiddenUntilActivated","$activator","HUAVOptions","showFn","jQuery","toggle","showSpeed","hasBeenShown","$elementShown","is","mixin","isHidden","isFunction","onshowFirstTime","call","onshow","hidden","onhide","apply","arguments","DraggableViewMixin","attributes","draggable","$dragHandle","draggableOff","draggableOn","dragStartHandler","bind","_dragStartHandler","dragEndHandler","_dragEndHandler","handle","attr","addEventListener","removeEventListener","event","dataTransfer","effectAllowed","SelectableViewMixin","selectable","selected","$selector","$","_renderSelected","toggleClass","toggleSelector","hideSelector","showSelector","speed","fxSpeed","show","hide","toggleSelect","deselect","select","mixinHash1","propsHash","Array","slice","pop","unshift","lastArg","wrapTemplate","template","jsonNamespace","templateFn","join","templateVars","view","_l","buildComparator","attribute_name","ascending","__comparator","b","a"],"mappings":"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","file":"../../scripts/mvc/base-mvc.js","sourcesContent":["import * as _ from \"libs/underscore\";\nimport * as Backbone from \"libs/backbone\";\nimport addLogging from \"utils/add-logging\";\nimport _l from \"utils/localization\";\n\n//==============================================================================\n/** @class Mixin to add logging capabilities to an object.\n *      Designed to allow switching an objects log output off/on at one central\n *      statement. Can be used with plain browser console (or something more\n *      complex like an AJAX logger).\n *  <br />NOTE: currently only uses the console.debug log function\n *  (as opposed to debug, error, warn, etc.)\n *  @name LoggableMixin\n *\n *  @example\n *  // Add to your models/views at the definition using chaining:\n *      var MyModel = Backbone.Model.extend( LoggableMixin ).extend({ // ... });\n *\n *  // or - more explicitly AFTER the definition:\n *      var MyModel = Backbone.Model.extend({\n *          logger  : console\n *          // ...\n *          this.log( '$#%& it! - broken already...' );\n *      })\n *      _.extend( MyModel.prototype, LoggableMixin )\n *\n */\nvar LoggableMixin = /** @lends LoggableMixin# */ {\n    // replace null with console (if available) to see all logs for a particular view/model\n    /** The logging object whose log function will be used to output\n     *      messages. Null will supress all logging. Commonly set to console.\n     */\n    logger: null,\n    /** @type {String} a namespace for filtering/focusing log output */\n    _logNamespace: \".\"\n};\naddLogging(LoggableMixin);\n\n//==============================================================================\n/** Backbone model that syncs to the browser's sessionStorage API.\n *      This all largely happens behind the scenes and no special calls are required.\n */\nvar SessionStorageModel = Backbone.Model.extend({\n    initialize: function(initialAttrs) {\n        // check for sessionStorage and error if no id is provided\n        this._checkEnabledSessionStorage();\n        if (!initialAttrs.id) {\n            throw new Error(\n                \"SessionStorageModel requires an id in the initial attributes\"\n            );\n        }\n        this.id = initialAttrs.id;\n\n        // load existing from storage (if any), clear any attrs set by bbone before init is called,\n        //  layer initial over existing and defaults, and save\n        var existing = !this.isNew() ? this._read(this) : {};\n        this.clear({ silent: true });\n        this.save(_.extend({}, this.defaults, existing, initialAttrs), {\n            silent: true\n        });\n\n        // save on any change to it immediately\n        this.on(\"change\", function() {\n            this.save();\n        });\n    },\n\n    _checkEnabledSessionStorage: function() {\n        try {\n            return window.sessionStorage.length >= 0;\n        } catch (err) {\n            alert(\"Please enable cookies in your browser for this Galaxy site\");\n            return false;\n        }\n    },\n\n    /** override of bbone sync to save to sessionStorage rather than REST\n     *      bbone options (success, errror, etc.) should still apply\n     */\n    sync: function(method, model, options) {\n        if (!options.silent) {\n            model.trigger(\"request\", model, {}, options);\n        }\n        var returned = {};\n        switch (method) {\n            case \"create\":\n                returned = this._create(model);\n                break;\n            case \"read\":\n                returned = this._read(model);\n                break;\n            case \"update\":\n                returned = this._update(model);\n                break;\n            case \"delete\":\n                returned = this._delete(model);\n                break;\n        }\n        if (returned !== undefined || returned !== null) {\n            if (options.success) {\n                options.success();\n            }\n        } else {\n            if (options.error) {\n                options.error();\n            }\n        }\n        return returned;\n    },\n\n    /** set storage to the stringified item */\n    _create: function(model) {\n        try {\n            var json = model.toJSON(),\n                set = sessionStorage.setItem(model.id, JSON.stringify(json));\n            return set === null ? set : json;\n            // DOMException is thrown in Safari if in private browsing mode and sessionStorage is attempted:\n            // http://stackoverflow.com/questions/14555347\n            // TODO: this could probably use a more general soln - like detecting priv. mode + safari => non-ajaxing Model\n        } catch (err) {\n            if (\n                !(\n                    err instanceof DOMException &&\n                    navigator.userAgent.indexOf(\"Safari\") > -1\n                )\n            ) {\n                throw err;\n            }\n        }\n        return null;\n    },\n\n    /** read and parse json from storage */\n    _read: function(model) {\n        return JSON.parse(sessionStorage.getItem(model.id));\n    },\n\n    /** set storage to the item (alias to create) */\n    _update: function(model) {\n        return model._create(model);\n    },\n\n    /** remove the item from storage */\n    _delete: function(model) {\n        return sessionStorage.removeItem(model.id);\n    },\n\n    /** T/F whether sessionStorage contains the model's id (data is present) */\n    isNew: function() {\n        return !sessionStorage.hasOwnProperty(this.id);\n    },\n\n    _log: function() {\n        return JSON.stringify(this.toJSON(), null, \"  \");\n    },\n    toString: function() {\n        return \"SessionStorageModel(\" + this.id + \")\";\n    }\n});\n(function() {\n    SessionStorageModel.prototype = _.omit(\n        SessionStorageModel.prototype,\n        \"url\",\n        \"urlRoot\"\n    );\n})();\n\n//==============================================================================\n/** Function that allows mixing of hashs into bbone MVC while showing the mixins first\n *      (before the more local class overrides/hash).\n *      Basically, a simple reversal of param order on _.defaults() - to show mixins in top of definition.\n *  @example:\n *      var NewModel = Something.extend( mixin( MyMixinA, MyMixinB, { ... myVars : ... }) );\n *\n *  NOTE: this does not combine any hashes (like events, etc.) and you're expected to handle that\n */\nfunction mixin(mixinHash1, /* mixinHash2, etc: ... variadic */ propsHash) {\n    var args = Array.prototype.slice.call(arguments, 0),\n        lastArg = args.pop();\n    args.unshift(lastArg);\n    return _.defaults.apply(_, args);\n}\n\n//==============================================================================\n/** A mixin for models that allow T/F/Matching to their attributes - useful when\n *      searching or filtering collections of models.\n * @example:\n *      see hda-model for searchAttribute and searchAliases definition examples.\n *      see history-contents.matches for how collections are filtered\n *      and see readonly-history-view.searchHdas for how user input is connected to the filtering\n */\nvar SearchableModelMixin = {\n    /** what attributes of an HDA will be used in a text search */\n    searchAttributes: [\n        // override\n    ],\n\n    /** our attr keys don't often match the labels we display to the user - so, when using\n     *      attribute specifiers ('name=\"bler\"') in a term, allow passing in aliases for the\n     *      following attr keys.\n     */\n    searchAliases: {\n        // override\n    },\n\n    /** search the attribute with key attrKey for the string searchFor; T/F if found */\n    searchAttribute: function(attrKey, searchFor) {\n        var attrVal = this.get(attrKey);\n        //this.debug( 'searchAttribute', attrKey, attrVal, searchFor );\n        // bail if empty searchFor or unsearchable values\n        if (!searchFor || (attrVal === undefined || attrVal === null)) {\n            return false;\n        }\n        // pass to sep. fn for deep search of array attributes\n        if (_.isArray(attrVal)) {\n            return this._searchArrayAttribute(attrVal, searchFor);\n        }\n        return (\n            attrVal\n                .toString()\n                .toLowerCase()\n                .indexOf(searchFor.toLowerCase()) !== -1\n        );\n    },\n\n    /** deep(er) search for array attributes; T/F if found */\n    _searchArrayAttribute: function(array, searchFor) {\n        //this.debug( '_searchArrayAttribute', array, searchFor );\n        searchFor = searchFor.toLowerCase();\n        //precondition: searchFor has already been validated as non-empty string\n        //precondition: assumes only 1 level array\n        //TODO: could possibly break up searchFor more (CSV...)\n        return _.any(array, function(elem) {\n            return (\n                elem\n                    .toString()\n                    .toLowerCase()\n                    .indexOf(searchFor.toLowerCase()) !== -1\n            );\n        });\n    },\n\n    /** search all searchAttributes for the string searchFor,\n     *      returning a list of keys of attributes that contain searchFor\n     */\n    search: function(searchFor) {\n        var model = this;\n        return _.filter(this.searchAttributes, function(key) {\n            return model.searchAttribute(key, searchFor);\n        });\n    },\n\n    /** alias of search, but returns a boolean; accepts attribute specifiers where\n     *      the attributes searched can be narrowed to a single attribute using\n     *      the form: matches( 'genome_build=hg19' )\n     *      (the attribute keys allowed can also be aliases to the true attribute key;\n     *          see searchAliases above)\n     *  @param {String} term   plain text or ATTR_SPECIFIER sep. key=val pair\n     *  @returns {Boolean} was term found in (any) attribute(s)\n     */\n    matches: function(term) {\n        var ATTR_SPECIFIER = \"=\",\n            split = term.split(ATTR_SPECIFIER);\n        // attribute is specified - search only that\n        if (split.length >= 2) {\n            var attrKey = split[0];\n            attrKey = this.searchAliases[attrKey] || attrKey;\n            return this.searchAttribute(attrKey, split[1]);\n        }\n        // no attribute is specified - search all attributes in searchAttributes\n        return !!this.search(term).length;\n    },\n\n    /** an implicit AND search for all terms; IOW, a model must match all terms given\n     *      where terms is a whitespace separated value string.\n     *      e.g. given terms of: 'blah bler database=hg19'\n     *          an HDA would have to have attributes containing blah AND bler AND a genome_build == hg19\n     *      To include whitespace in terms: wrap the term in double quotations (name=\"blah bler\").\n     */\n    matchesAll: function(terms) {\n        var model = this;\n        // break the terms up by whitespace and filter out the empty strings\n        terms = terms.match(/(\".*\"|\\w*=\".*\"|\\S*)/g).filter(function(s) {\n            return !!s;\n        });\n        return _.all(terms, function(term) {\n            term = term.replace(/\"/g, \"\");\n            return model.matches(term);\n        });\n    }\n};\n\n//==============================================================================\n/** A view that renders hidden and shows when some activator is clicked.\n *      options:\n *          showFn: the effect used to show/hide the View (defaults to jq.toggle)\n *          $elementShown: some jqObject (defaults to this.$el) to be shown/hidden\n *          onShowFirstTime: fn called the first time the view is shown\n *          onshow: fn called every time the view is shown\n *          onhide: fn called every time the view is hidden\n *      events:\n *          hiddenUntilActivated:shown (the view is passed as an arg)\n *          hiddenUntilActivated:hidden (the view is passed as an arg)\n *      instance vars:\n *          view.hidden {boolean} is the view in the hidden state\n */\nvar HiddenUntilActivatedViewMixin = /** @lends hiddenUntilActivatedMixin# */ {\n    //TODO: since this is a mixin, consider moving toggle, hidden into HUAVOptions\n\n    /** call this in your initialize to set up the mixin\n     *  @param {jQuery} $activator the 'button' that's clicked to show/hide the view\n     *  @param {Object} hash with mixin options\n     */\n    hiddenUntilActivated: function($activator, options) {\n        // call this in your view's initialize fn\n        options = options || {};\n        //TODO: flesh out options - show them all here\n        this.HUAVOptions = {\n            $elementShown: this.$el,\n            showFn: jQuery.prototype.toggle,\n            showSpeed: \"fast\"\n        };\n        _.extend(this.HUAVOptions, options || {});\n        /** has this been shown already (and onshowFirstTime called)? */\n        this.HUAVOptions.hasBeenShown = this.HUAVOptions.$elementShown.is(\n            \":visible\"\n        );\n        this.hidden = this.isHidden();\n\n        if ($activator) {\n            var mixin = this;\n            $activator.on(\"click\", function(ev) {\n                mixin.toggle(mixin.HUAVOptions.showSpeed);\n            });\n        }\n    },\n\n    //TODO:?? remove? use .hidden?\n    /** returns T/F if the view is hidden */\n    isHidden: function() {\n        return this.HUAVOptions.$elementShown.is(\":hidden\");\n    },\n\n    /** toggle the hidden state, show/hide $elementShown, call onshow/hide, trigger events */\n    toggle: function() {\n        //TODO: more specific name - toggle is too general\n        // can be called manually as well with normal toggle arguments\n        //TODO: better as a callback (when the show/hide is actually done)\n        // show\n        if (this.hidden) {\n            // fire the optional fns on the first/each showing - good for render()\n            if (!this.HUAVOptions.hasBeenShown) {\n                if (_.isFunction(this.HUAVOptions.onshowFirstTime)) {\n                    this.HUAVOptions.hasBeenShown = true;\n                    this.HUAVOptions.onshowFirstTime.call(this);\n                }\n            }\n            if (_.isFunction(this.HUAVOptions.onshow)) {\n                this.HUAVOptions.onshow.call(this);\n                this.trigger(\"hiddenUntilActivated:shown\", this);\n            }\n            this.hidden = false;\n\n            // hide\n        } else {\n            if (_.isFunction(this.HUAVOptions.onhide)) {\n                this.HUAVOptions.onhide.call(this);\n                this.trigger(\"hiddenUntilActivated:hidden\", this);\n            }\n            this.hidden = true;\n        }\n        return this.HUAVOptions.showFn.apply(\n            this.HUAVOptions.$elementShown,\n            arguments\n        );\n    }\n};\n\n//==============================================================================\n/** Mixin for views that can be dragged and dropped\n *      Allows for the drag behavior to be turned on/off, setting/removing jQuery event\n *          handlers each time.\n *      dataTransfer data is set to the JSON string of the view's model.toJSON\n *      Override '$dragHandle' to define the draggable DOM sub-element.\n */\nvar DraggableViewMixin = {\n    /** set up instance vars to track whether this view is currently draggable */\n    initialize: function(attributes) {\n        /** is the body of this hda view expanded/not? */\n        this.draggable = attributes.draggable || false;\n    },\n\n    /** what part of the view's DOM triggers the dragging */\n    $dragHandle: function() {\n        //TODO: make abstract/general - move this to listItem\n        // override to the element you want to be your view's handle\n        return this.$(\".title-bar\");\n    },\n\n    /** toggle whether this view is draggable */\n    toggleDraggable: function() {\n        if (this.draggable) {\n            this.draggableOff();\n        } else {\n            this.draggableOn();\n        }\n    },\n\n    /** allow the view to be dragged, set up event handlers */\n    draggableOn: function() {\n        this.draggable = true;\n        this.dragStartHandler = _.bind(this._dragStartHandler, this);\n        this.dragEndHandler = _.bind(this._dragEndHandler, this);\n\n        var handle = this.$dragHandle()\n            .attr(\"draggable\", true)\n            .get(0);\n        handle.addEventListener(\"dragstart\", this.dragStartHandler, false);\n        handle.addEventListener(\"dragend\", this.dragEndHandler, false);\n    },\n\n    /** turn of view dragging and remove event listeners */\n    draggableOff: function() {\n        this.draggable = false;\n        var handle = this.$dragHandle()\n            .attr(\"draggable\", false)\n            .get(0);\n        handle.removeEventListener(\"dragstart\", this.dragStartHandler, false);\n        handle.removeEventListener(\"dragend\", this.dragEndHandler, false);\n    },\n\n    /** sets the dataTransfer data to the model's toJSON\n     *  @fires draggable:dragstart (bbone event) which is passed the event and this view\n     */\n    _dragStartHandler: function(event) {\n        event.dataTransfer.effectAllowed = \"move\";\n        //ASSUMES: this.model\n        //TODO: all except IE: should be 'application/json', IE: must be 'text'\n        event.dataTransfer.setData(\"text\", JSON.stringify(this.model.toJSON()));\n        this.trigger(\"draggable:dragstart\", event, this);\n        return false;\n    },\n\n    /** handle the dragend\n     *  @fires draggable:dragend (bbone event) which is passed the event and this view\n     */\n    _dragEndHandler: function(event) {\n        this.trigger(\"draggable:dragend\", event, this);\n        return false;\n    }\n};\n\n//==============================================================================\n/** Mixin that allows a view to be selected (gen. from a list).\n *      Selection controls ($selector) may be hidden/shown/toggled.\n *          The bbone event 'selectable' is fired when the controls are shown/hidden (passed T/F).\n *      Default rendering is a font-awesome checkbox.\n *      Default selector is '.selector' within the view's $el.\n *      The bbone events 'selected' and 'de-selected' are fired when the $selector is clicked.\n *          Both events are passed the view and the (jQuery) event.\n */\nvar SelectableViewMixin = {\n    /** Set up instance state vars for whether the selector is shown and whether the view has been selected */\n    initialize: function(attributes) {\n        /** is the view currently in selection mode? */\n        this.selectable = attributes.selectable || false;\n        /** is the view currently selected? */\n        this.selected = attributes.selected || false;\n    },\n\n    /** $el sub-element where the selector is rendered and what can be clicked to select. */\n    $selector: function() {\n        return this.$(\".selector\");\n    },\n\n    /** How the selector is rendered - defaults to font-awesome checkbox */\n    _renderSelected: function() {\n        // override\n        this.$selector()\n            .find(\"span\")\n            .toggleClass(\"fa-check-square-o\", this.selected)\n            .toggleClass(\"fa-square-o\", !this.selected);\n    },\n\n    /** Toggle whether the selector is shown */\n    toggleSelector: function() {\n        //TODO: use this.selectable\n        if (!this.$selector().is(\":visible\")) {\n            this.showSelector();\n        } else {\n            this.hideSelector();\n        }\n    },\n\n    /** Display the selector control.\n     *  @param {Number} a jQuery fx speed\n     *  @fires: selectable which is passed true (IOW, the selector is shown) and the view\n     */\n    showSelector: function(speed) {\n        speed = speed !== undefined ? speed : this.fxSpeed;\n        // make sure selected state is represented properly\n        this.selectable = true;\n        this.trigger(\"selectable\", true, this);\n        this._renderSelected();\n        if (speed) {\n            this.$selector().show(speed);\n        } else {\n            this.$selector().show();\n        }\n    },\n\n    /** remove the selector control\n     *  @param {Number} a jQuery fx speed\n     *  @fires: selectable which is passed false (IOW, the selector is not shown) and the view\n     */\n    hideSelector: function(speed) {\n        speed = speed !== undefined ? speed : this.fxSpeed;\n        // reverse the process from showSelect\n        this.selectable = false;\n        this.trigger(\"selectable\", false, this);\n        if (speed) {\n            this.$selector().hide(speed);\n        } else {\n            this.$selector().hide();\n        }\n    },\n\n    /** Toggle whether the view is selected */\n    toggleSelect: function(event) {\n        if (this.selected) {\n            this.deselect(event);\n        } else {\n            this.select(event);\n        }\n    },\n\n    /** Select this view and re-render the selector control to show it\n     *  @param {Event} a jQuery event that caused the selection\n     *  @fires: selected which is passed the view and the DOM event that triggered it (optionally)\n     */\n    select: function(event) {\n        // switch icon, set selected, and trigger event\n        if (!this.selected) {\n            this.trigger(\"selected\", this, event);\n            this.selected = true;\n            this._renderSelected();\n        }\n        return false;\n    },\n\n    /** De-select this view and re-render the selector control to show it\n     *  @param {Event} a jQuery event that caused the selection\n     *  @fires: de-selected which is passed the view and the DOM event that triggered it (optionally)\n     */\n    deselect: function(event) {\n        // switch icon, set selected, and trigger event\n        if (this.selected) {\n            this.trigger(\"de-selected\", this, event);\n            this.selected = false;\n            this._renderSelected();\n        }\n        return false;\n    }\n};\n\n//==============================================================================\n/** Return an underscore template fn from an array of strings.\n *  @param {String[]} template      the template strings to compile into the underscore template fn\n *  @param {String} jsonNamespace   an optional namespace for the json data passed in (defaults to 'model')\n *  @returns {Function} the (wrapped) underscore template fn\n *      The function accepts:\n *\n *  The template strings can access:\n *      the json/model hash using model (\"<%- model.myAttr %>) using the jsonNamespace above\n *      _l: the localizer function\n *      view (if passed): ostensibly, the view using the template (handy for view instance vars)\n *      Because they're namespaced, undefined attributes will not throw an error.\n *\n *  @example:\n *      templateBler : BASE_MVC.wrapTemplate([\n *          '<div class=\"myclass <%- mynamespace.modelClass %>\">',\n *              '<span><% print( _l( mynamespace.message ) ); %>:<%= view.status %></span>'\n *          '</div>'\n *      ], 'mynamespace' )\n *\n *  Meant to be called in a View's definition in order to compile only once.\n *\n */\nfunction wrapTemplate(template, jsonNamespace) {\n    jsonNamespace = jsonNamespace || \"model\";\n    var templateFn = _.template(template.join(\"\"));\n    return function(json, view) {\n        var templateVars = { view: view || {}, _l: _l };\n        templateVars[jsonNamespace] = json || {};\n        return templateFn(templateVars);\n    };\n}\n\n//==============================================================================\n/** Return a comparator function for sorted Collections */\nfunction buildComparator(attribute_name, options) {\n    options = options || {};\n    var ascending = options.ascending ? 1 : -1;\n    return function __comparator(a, b) {\n        a = a.get(attribute_name);\n        b = b.get(attribute_name);\n        return (a < b ? -1 : a > b ? 1 : 0) * ascending;\n    };\n}\n\n//==============================================================================\nexport default {\n    LoggableMixin: LoggableMixin,\n    SessionStorageModel: SessionStorageModel,\n    mixin: mixin,\n    SearchableModelMixin: SearchableModelMixin,\n    HiddenUntilActivatedViewMixin: HiddenUntilActivatedViewMixin,\n    DraggableViewMixin: DraggableViewMixin,\n    SelectableViewMixin: SelectableViewMixin,\n    wrapTemplate: wrapTemplate,\n    buildComparator: buildComparator\n};\n"]}