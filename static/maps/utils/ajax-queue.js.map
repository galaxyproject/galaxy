{"version":3,"sources":["utils/ajax-queue.js"],"names":["AjaxQueue","initialFunctions","_classCallCheck","this","deferred","jQuery","Deferred","queue","responses","numToProcess","running","init","start","_this","forEach","fn","add","_this2","index","length","push","fnIndex","xhr","done","response","notify","curr","total","always","shift","stop","causeFail","msg","reject","resolve","fail","progress","NamedAjaxQueue","obj","hasOwnProperty","Error","JSON","stringify","names","name","_get","prototype","__proto__","Object","getPrototypeOf","call"],"mappings":"6pCAUMA,aACF,SAAAA,EAAYC,GAAkBC,EAAAC,KAAAH,GAE1BG,KAAKC,SAAWC,OAAOC,WAEvBH,KAAKI,SAELJ,KAAKK,aAELL,KAAKM,aAAe,EAEpBN,KAAKO,SAAU,EAEfP,KAAKQ,KAAKV,OACVE,KAAKS,+CAIJX,GAAkB,IAAAY,EAAAV,KACnBF,EAAiBa,QAAQ,SAAAC,GACrBF,EAAKG,IAAID,iCAIbA,GAAI,IAAAE,EAAAd,KACAe,EAAQf,KAAKI,MAAMY,OAyBvB,OAxBAhB,KAAKM,cAAgB,EAErBN,KAAKI,MAAMa,KAAK,WACZ,IAAIC,EAAUH,EACVI,EAAMP,IAEVO,EAAIC,KAAK,SAAAC,GACLP,EAAKb,SAASqB,QACVC,KAAML,EACNM,MAAOV,EAAKR,aACZe,SAAUA,MAKlBF,EAAIM,OAAO,SAAAJ,GACPP,EAAKT,UAAUY,KAAKI,GAChBP,EAAKV,MAAMY,OACXF,EAAKV,MAAMsB,OAAXZ,GAEAA,EAAKa,WAIV3B,qCAQP,OAJIA,KAAKI,MAAMY,SACXhB,KAAKO,SAAU,EACfP,KAAKI,MAAMsB,OAAX1B,IAEGA,kCAON4B,EAAWC,GA5DZ,OA8DA7B,KAAKO,SAAU,EACfP,KAAKI,SACDwB,EApER5B,KAAAC,SAAA6B,OAAYhC,GAwEJE,KAAKC,SAAS8B,QAAQ/B,KAAKK,WAtE/BL,KAAAM,aAAgBJ,EAChBF,KAAAC,SAAAC,OAAAC,WACAH,kCAKAY,GACA,OAAAZ,KAAKO,SAAUa,KAAfR,gCAIHA,GAyEG,OAAOZ,KAAKC,SAAS+B,KAAKpB,kCAIvBA,GACH,OAAOZ,KAAKC,SAASwB,OAAOb,oCA1E5Bd,GACI,OAAAE,KAAAC,SAAAgC,SAAArB,oCAIAd,GAiFJ,OAAO,IAAID,EAAUC,GAAkBG,kBAlEnCiC,6HAAArC,kCAEAsB,GACI,IAAAgB,EAAAC,eAAK/B,UAAUY,EAAKI,eAApB,MACA,MAAA,IAAAgB,MAAA,oEAAuBC,KAAAC,UAAAJ,IAEtB,IAAAnC,KAAAwC,MAAAJ,eAAMD,EAAAM,MAKf,OADCzC,KAAAwC,MArBDL,EAAAM,OAAA,EAsBAC,EAAAR,EAAAS,UAAAC,WAAAC,OAAAC,eAAAZ,EAAAS,WAAA,MAAA3C,MAAA+C,KAAA/C,KAAOmC,EAAPvB,oCAIA,OAiFAZ,KAAKwC,SAjFLxC,sCAwFUF,GACV,OAAO,IAAIoC,EAAepC,GAAkBG,6BAzExCJ,UAAAA,EACAqC,eAAAA","file":"../../scripts/utils/ajax-queue.js","sourcesContent":["//ASSUMES: jquery\n//=============================================================================\n/** @class AjaxQueue\n *  Class that allows queueing functions that return jQuery promises (such\n *  as ajax calls). Each function waits for the previous to complete before\n *  being called\n *\n *  @constructor accepts a list of functions and automatically begins\n *      processing them\n */\nclass AjaxQueue {\n    constructor(initialFunctions) {\n        /** the main deferred for the entire queue - note: also sends notifications of progress */\n        this.deferred = jQuery.Deferred();\n        /** the queue array of functions */\n        this.queue = [];\n        /** cache the response from each deferred call - error or success */\n        this.responses = [];\n        /** total number of fn's to process */\n        this.numToProcess = 0;\n        /** is the queue processing/waiting for any calls to return? */\n        this.running = false;\n\n        this.init(initialFunctions || []);\n        this.start();\n    }\n\n    /** add all fns in initialFunctions (if any) to the queue */\n    init(initialFunctions) {\n        initialFunctions.forEach(fn => {\n            this.add(fn);\n        });\n    }\n\n    add(fn) {\n        var index = this.queue.length;\n        this.numToProcess += 1;\n\n        this.queue.push(() => {\n            var fnIndex = index;\n            var xhr = fn();\n            // if successful, notify using the deferred to allow tracking progress\n            xhr.done(response => {\n                this.deferred.notify({\n                    curr: fnIndex,\n                    total: this.numToProcess,\n                    response: response\n                });\n            });\n            // (regardless of previous error or success) if not last ajax call, shift and call the next\n            //  if last fn, resolve deferred\n            xhr.always(response => {\n                this.responses.push(response);\n                if (this.queue.length) {\n                    this.queue.shift()();\n                } else {\n                    this.stop();\n                }\n            });\n        });\n        return this;\n    }\n\n    start() {\n        if (this.queue.length) {\n            this.running = true;\n            this.queue.shift()();\n        }\n        return this;\n    }\n\n    /** stop the queue\n     *  @param {boolean} causeFail  cause an error/fail on the main deferred\n     *  @param {String} msg         message to send when rejecting the main deferred\n     */\n    stop(causeFail, msg) {\n        //TODO: doesn't abort current call\n        this.running = false;\n        this.queue = [];\n        if (causeFail) {\n            //TODO: spliced args instead\n            this.deferred.reject(msg);\n        } else {\n            this.deferred.resolve(this.responses);\n        }\n        this.numToProcess = 0;\n        this.deferred = jQuery.Deferred();\n        return this;\n    }\n\n    // only a handful of the deferred interface for now - possible YAGNI\n    /** implement done from the jq deferred interface */\n    done(fn) {\n        return this.deferred.done(fn);\n    }\n\n    /** implement fail from the jq deferred interface */\n    fail(fn) {\n        return this.deferred.fail(fn);\n    }\n\n    /** implement always from the jq deferred interface */\n    always(fn) {\n        return this.deferred.always(fn);\n    }\n\n    /** implement progress from the jq deferred interface */\n    progress(fn) {\n        return this.deferred.progress(fn);\n    }\n\n    /** shortcut constructor / fire and forget\n     *  @returns {Deferred} the queue's main deferred\n     */\n    static create(initialFunctions) {\n        return new AjaxQueue(initialFunctions).deferred;\n    }\n}\n\n//=============================================================================\n/** @class NamedAjaxQueue\n *  @augments AjaxQueue\n *  Allows associating a name with a deferring fn and prevents adding deferring\n *  fns if the name has already been used. Useful to prevent build up of duplicate\n *  async calls.\n *  Both the array initialFunctions sent to constructor and any added later with\n *  add() should be objects (NOT functions) of the form:\n *  { name: some unique id,\n *    fn:   the deferring fn or ajax call }\n */\nclass NamedAjaxQueue extends AjaxQueue {\n    /** add the obj.fn to the queue if obj.name hasn't been used before */\n    add(obj) {\n        if (!(obj.hasOwnProperty(\"name\") && obj.hasOwnProperty(\"fn\"))) {\n            throw new Error(`NamedAjaxQueue.add requires an object with both \"name\" and \"fn\": ${JSON.stringify(obj)}`);\n        }\n        if (this.names.hasOwnProperty(obj.name)) {\n            //console.warn( 'name has been used:', obj.name );\n            return;\n        }\n        this.names[obj.name] = true;\n        return super.add(obj.fn);\n    }\n\n    clear() {\n        this.names = {};\n        return this;\n    }\n\n    /** shortcut constructor / fire and forget\n     *  @returns {Deferred} the queue's main deferred\n     */\n    static create(initialFunctions) {\n        return new NamedAjaxQueue(initialFunctions).deferred;\n    }\n}\n\n//=============================================================================\nexport default {\n    AjaxQueue: AjaxQueue,\n    NamedAjaxQueue: NamedAjaxQueue\n};\n"]}